
BLESensorsPnPL.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000238  08000000  08000000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00026610  08000238  08000238  00001238  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00004478  08026848  08026848  00027848  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM          00000008  0802acc0  0802acc0  0002bcc0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .init_array   00000004  0802acc8  0802acc8  0002bcc8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .fini_array   00000004  0802accc  0802accc  0002bccc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .data         000003e4  20000000  0802acd0  0002c000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .bss          00001c06  200003e4  0802b0b4  0002c3e4  2**2
                  ALLOC
  8 ._user_heap_stack 00010006  20001fea  0802b0b4  0002cfea  2**0
                  ALLOC
  9 .ARM.attributes 00000034  00000000  00000000  0002c3e4  2**0
                  CONTENTS, READONLY
 10 .debug_line   00066b6c  00000000  00000000  0002c418  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_line_str 000000ba  00000000  00000000  00092f84  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_info   00069f47  00000000  00000000  0009303e  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 0000acb7  00000000  00000000  000fcf85  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_aranges 000054e8  00000000  00000000  00107c40  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_str    00196b57  00000000  00000000  0010d128  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_rnglists 0000423b  00000000  00000000  002a3c7f  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_macro  0004a045  00000000  00000000  002a7eba  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .comment      00000043  00000000  00000000  002f1eff  2**0
                  CONTENTS, READONLY
 19 .debug_frame  000185c0  00000000  00000000  002f1f44  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

08000238 <__do_global_dtors_aux>:
 8000238:	b510      	push	{r4, lr}
 800023a:	4c05      	ldr	r4, [pc, #20]	@ (8000250 <__do_global_dtors_aux+0x18>)
 800023c:	7823      	ldrb	r3, [r4, #0]
 800023e:	b933      	cbnz	r3, 800024e <__do_global_dtors_aux+0x16>
 8000240:	4b04      	ldr	r3, [pc, #16]	@ (8000254 <__do_global_dtors_aux+0x1c>)
 8000242:	b113      	cbz	r3, 800024a <__do_global_dtors_aux+0x12>
 8000244:	4804      	ldr	r0, [pc, #16]	@ (8000258 <__do_global_dtors_aux+0x20>)
 8000246:	f3af 8000 	nop.w
 800024a:	2301      	movs	r3, #1
 800024c:	7023      	strb	r3, [r4, #0]
 800024e:	bd10      	pop	{r4, pc}
 8000250:	200003e4 	.word	0x200003e4
 8000254:	00000000 	.word	0x00000000
 8000258:	08026830 	.word	0x08026830

0800025c <frame_dummy>:
 800025c:	b508      	push	{r3, lr}
 800025e:	4b03      	ldr	r3, [pc, #12]	@ (800026c <frame_dummy+0x10>)
 8000260:	b11b      	cbz	r3, 800026a <frame_dummy+0xe>
 8000262:	4903      	ldr	r1, [pc, #12]	@ (8000270 <frame_dummy+0x14>)
 8000264:	4803      	ldr	r0, [pc, #12]	@ (8000274 <frame_dummy+0x18>)
 8000266:	f3af 8000 	nop.w
 800026a:	bd08      	pop	{r3, pc}
 800026c:	00000000 	.word	0x00000000
 8000270:	200003e8 	.word	0x200003e8
 8000274:	08026830 	.word	0x08026830

08000278 <strcmp>:
 8000278:	f810 2b01 	ldrb.w	r2, [r0], #1
 800027c:	f811 3b01 	ldrb.w	r3, [r1], #1
 8000280:	2a01      	cmp	r2, #1
 8000282:	bf28      	it	cs
 8000284:	429a      	cmpcs	r2, r3
 8000286:	d0f7      	beq.n	8000278 <strcmp>
 8000288:	1ad0      	subs	r0, r2, r3
 800028a:	4770      	bx	lr

0800028c <strlen>:
 800028c:	4603      	mov	r3, r0
 800028e:	f813 2b01 	ldrb.w	r2, [r3], #1
 8000292:	2a00      	cmp	r2, #0
 8000294:	d1fb      	bne.n	800028e <strlen+0x2>
 8000296:	1a18      	subs	r0, r3, r0
 8000298:	3801      	subs	r0, #1
 800029a:	4770      	bx	lr

0800029c <__aeabi_drsub>:
 800029c:	f081 4100 	eor.w	r1, r1, #2147483648	@ 0x80000000
 80002a0:	e002      	b.n	80002a8 <__adddf3>
 80002a2:	bf00      	nop

080002a4 <__aeabi_dsub>:
 80002a4:	f083 4300 	eor.w	r3, r3, #2147483648	@ 0x80000000

080002a8 <__adddf3>:
 80002a8:	b530      	push	{r4, r5, lr}
 80002aa:	ea4f 0441 	mov.w	r4, r1, lsl #1
 80002ae:	ea4f 0543 	mov.w	r5, r3, lsl #1
 80002b2:	ea94 0f05 	teq	r4, r5
 80002b6:	bf08      	it	eq
 80002b8:	ea90 0f02 	teqeq	r0, r2
 80002bc:	bf1f      	itttt	ne
 80002be:	ea54 0c00 	orrsne.w	ip, r4, r0
 80002c2:	ea55 0c02 	orrsne.w	ip, r5, r2
 80002c6:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 80002ca:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80002ce:	f000 80e2 	beq.w	8000496 <__adddf3+0x1ee>
 80002d2:	ea4f 5454 	mov.w	r4, r4, lsr #21
 80002d6:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 80002da:	bfb8      	it	lt
 80002dc:	426d      	neglt	r5, r5
 80002de:	dd0c      	ble.n	80002fa <__adddf3+0x52>
 80002e0:	442c      	add	r4, r5
 80002e2:	ea80 0202 	eor.w	r2, r0, r2
 80002e6:	ea81 0303 	eor.w	r3, r1, r3
 80002ea:	ea82 0000 	eor.w	r0, r2, r0
 80002ee:	ea83 0101 	eor.w	r1, r3, r1
 80002f2:	ea80 0202 	eor.w	r2, r0, r2
 80002f6:	ea81 0303 	eor.w	r3, r1, r3
 80002fa:	2d36      	cmp	r5, #54	@ 0x36
 80002fc:	bf88      	it	hi
 80002fe:	bd30      	pophi	{r4, r5, pc}
 8000300:	f011 4f00 	tst.w	r1, #2147483648	@ 0x80000000
 8000304:	ea4f 3101 	mov.w	r1, r1, lsl #12
 8000308:	f44f 1c80 	mov.w	ip, #1048576	@ 0x100000
 800030c:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 8000310:	d002      	beq.n	8000318 <__adddf3+0x70>
 8000312:	4240      	negs	r0, r0
 8000314:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000318:	f013 4f00 	tst.w	r3, #2147483648	@ 0x80000000
 800031c:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8000320:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 8000324:	d002      	beq.n	800032c <__adddf3+0x84>
 8000326:	4252      	negs	r2, r2
 8000328:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 800032c:	ea94 0f05 	teq	r4, r5
 8000330:	f000 80a7 	beq.w	8000482 <__adddf3+0x1da>
 8000334:	f1a4 0401 	sub.w	r4, r4, #1
 8000338:	f1d5 0e20 	rsbs	lr, r5, #32
 800033c:	db0d      	blt.n	800035a <__adddf3+0xb2>
 800033e:	fa02 fc0e 	lsl.w	ip, r2, lr
 8000342:	fa22 f205 	lsr.w	r2, r2, r5
 8000346:	1880      	adds	r0, r0, r2
 8000348:	f141 0100 	adc.w	r1, r1, #0
 800034c:	fa03 f20e 	lsl.w	r2, r3, lr
 8000350:	1880      	adds	r0, r0, r2
 8000352:	fa43 f305 	asr.w	r3, r3, r5
 8000356:	4159      	adcs	r1, r3
 8000358:	e00e      	b.n	8000378 <__adddf3+0xd0>
 800035a:	f1a5 0520 	sub.w	r5, r5, #32
 800035e:	f10e 0e20 	add.w	lr, lr, #32
 8000362:	2a01      	cmp	r2, #1
 8000364:	fa03 fc0e 	lsl.w	ip, r3, lr
 8000368:	bf28      	it	cs
 800036a:	f04c 0c02 	orrcs.w	ip, ip, #2
 800036e:	fa43 f305 	asr.w	r3, r3, r5
 8000372:	18c0      	adds	r0, r0, r3
 8000374:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 8000378:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
 800037c:	d507      	bpl.n	800038e <__adddf3+0xe6>
 800037e:	f04f 0e00 	mov.w	lr, #0
 8000382:	f1dc 0c00 	rsbs	ip, ip, #0
 8000386:	eb7e 0000 	sbcs.w	r0, lr, r0
 800038a:	eb6e 0101 	sbc.w	r1, lr, r1
 800038e:	f5b1 1f80 	cmp.w	r1, #1048576	@ 0x100000
 8000392:	d31b      	bcc.n	80003cc <__adddf3+0x124>
 8000394:	f5b1 1f00 	cmp.w	r1, #2097152	@ 0x200000
 8000398:	d30c      	bcc.n	80003b4 <__adddf3+0x10c>
 800039a:	0849      	lsrs	r1, r1, #1
 800039c:	ea5f 0030 	movs.w	r0, r0, rrx
 80003a0:	ea4f 0c3c 	mov.w	ip, ip, rrx
 80003a4:	f104 0401 	add.w	r4, r4, #1
 80003a8:	ea4f 5244 	mov.w	r2, r4, lsl #21
 80003ac:	f512 0f80 	cmn.w	r2, #4194304	@ 0x400000
 80003b0:	f080 809a 	bcs.w	80004e8 <__adddf3+0x240>
 80003b4:	f1bc 4f00 	cmp.w	ip, #2147483648	@ 0x80000000
 80003b8:	bf08      	it	eq
 80003ba:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80003be:	f150 0000 	adcs.w	r0, r0, #0
 80003c2:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80003c6:	ea41 0105 	orr.w	r1, r1, r5
 80003ca:	bd30      	pop	{r4, r5, pc}
 80003cc:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 80003d0:	4140      	adcs	r0, r0
 80003d2:	eb41 0101 	adc.w	r1, r1, r1
 80003d6:	3c01      	subs	r4, #1
 80003d8:	bf28      	it	cs
 80003da:	f5b1 1f80 	cmpcs.w	r1, #1048576	@ 0x100000
 80003de:	d2e9      	bcs.n	80003b4 <__adddf3+0x10c>
 80003e0:	f091 0f00 	teq	r1, #0
 80003e4:	bf04      	itt	eq
 80003e6:	4601      	moveq	r1, r0
 80003e8:	2000      	moveq	r0, #0
 80003ea:	fab1 f381 	clz	r3, r1
 80003ee:	bf08      	it	eq
 80003f0:	3320      	addeq	r3, #32
 80003f2:	f1a3 030b 	sub.w	r3, r3, #11
 80003f6:	f1b3 0220 	subs.w	r2, r3, #32
 80003fa:	da0c      	bge.n	8000416 <__adddf3+0x16e>
 80003fc:	320c      	adds	r2, #12
 80003fe:	dd08      	ble.n	8000412 <__adddf3+0x16a>
 8000400:	f102 0c14 	add.w	ip, r2, #20
 8000404:	f1c2 020c 	rsb	r2, r2, #12
 8000408:	fa01 f00c 	lsl.w	r0, r1, ip
 800040c:	fa21 f102 	lsr.w	r1, r1, r2
 8000410:	e00c      	b.n	800042c <__adddf3+0x184>
 8000412:	f102 0214 	add.w	r2, r2, #20
 8000416:	bfd8      	it	le
 8000418:	f1c2 0c20 	rsble	ip, r2, #32
 800041c:	fa01 f102 	lsl.w	r1, r1, r2
 8000420:	fa20 fc0c 	lsr.w	ip, r0, ip
 8000424:	bfdc      	itt	le
 8000426:	ea41 010c 	orrle.w	r1, r1, ip
 800042a:	4090      	lslle	r0, r2
 800042c:	1ae4      	subs	r4, r4, r3
 800042e:	bfa2      	ittt	ge
 8000430:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8000434:	4329      	orrge	r1, r5
 8000436:	bd30      	popge	{r4, r5, pc}
 8000438:	ea6f 0404 	mvn.w	r4, r4
 800043c:	3c1f      	subs	r4, #31
 800043e:	da1c      	bge.n	800047a <__adddf3+0x1d2>
 8000440:	340c      	adds	r4, #12
 8000442:	dc0e      	bgt.n	8000462 <__adddf3+0x1ba>
 8000444:	f104 0414 	add.w	r4, r4, #20
 8000448:	f1c4 0220 	rsb	r2, r4, #32
 800044c:	fa20 f004 	lsr.w	r0, r0, r4
 8000450:	fa01 f302 	lsl.w	r3, r1, r2
 8000454:	ea40 0003 	orr.w	r0, r0, r3
 8000458:	fa21 f304 	lsr.w	r3, r1, r4
 800045c:	ea45 0103 	orr.w	r1, r5, r3
 8000460:	bd30      	pop	{r4, r5, pc}
 8000462:	f1c4 040c 	rsb	r4, r4, #12
 8000466:	f1c4 0220 	rsb	r2, r4, #32
 800046a:	fa20 f002 	lsr.w	r0, r0, r2
 800046e:	fa01 f304 	lsl.w	r3, r1, r4
 8000472:	ea40 0003 	orr.w	r0, r0, r3
 8000476:	4629      	mov	r1, r5
 8000478:	bd30      	pop	{r4, r5, pc}
 800047a:	fa21 f004 	lsr.w	r0, r1, r4
 800047e:	4629      	mov	r1, r5
 8000480:	bd30      	pop	{r4, r5, pc}
 8000482:	f094 0f00 	teq	r4, #0
 8000486:	f483 1380 	eor.w	r3, r3, #1048576	@ 0x100000
 800048a:	bf06      	itte	eq
 800048c:	f481 1180 	eoreq.w	r1, r1, #1048576	@ 0x100000
 8000490:	3401      	addeq	r4, #1
 8000492:	3d01      	subne	r5, #1
 8000494:	e74e      	b.n	8000334 <__adddf3+0x8c>
 8000496:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800049a:	bf18      	it	ne
 800049c:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80004a0:	d029      	beq.n	80004f6 <__adddf3+0x24e>
 80004a2:	ea94 0f05 	teq	r4, r5
 80004a6:	bf08      	it	eq
 80004a8:	ea90 0f02 	teqeq	r0, r2
 80004ac:	d005      	beq.n	80004ba <__adddf3+0x212>
 80004ae:	ea54 0c00 	orrs.w	ip, r4, r0
 80004b2:	bf04      	itt	eq
 80004b4:	4619      	moveq	r1, r3
 80004b6:	4610      	moveq	r0, r2
 80004b8:	bd30      	pop	{r4, r5, pc}
 80004ba:	ea91 0f03 	teq	r1, r3
 80004be:	bf1e      	ittt	ne
 80004c0:	2100      	movne	r1, #0
 80004c2:	2000      	movne	r0, #0
 80004c4:	bd30      	popne	{r4, r5, pc}
 80004c6:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 80004ca:	d105      	bne.n	80004d8 <__adddf3+0x230>
 80004cc:	0040      	lsls	r0, r0, #1
 80004ce:	4149      	adcs	r1, r1
 80004d0:	bf28      	it	cs
 80004d2:	f041 4100 	orrcs.w	r1, r1, #2147483648	@ 0x80000000
 80004d6:	bd30      	pop	{r4, r5, pc}
 80004d8:	f514 0480 	adds.w	r4, r4, #4194304	@ 0x400000
 80004dc:	bf3c      	itt	cc
 80004de:	f501 1180 	addcc.w	r1, r1, #1048576	@ 0x100000
 80004e2:	bd30      	popcc	{r4, r5, pc}
 80004e4:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
 80004e8:	f045 41fe 	orr.w	r1, r5, #2130706432	@ 0x7f000000
 80004ec:	f441 0170 	orr.w	r1, r1, #15728640	@ 0xf00000
 80004f0:	f04f 0000 	mov.w	r0, #0
 80004f4:	bd30      	pop	{r4, r5, pc}
 80004f6:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80004fa:	bf1a      	itte	ne
 80004fc:	4619      	movne	r1, r3
 80004fe:	4610      	movne	r0, r2
 8000500:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 8000504:	bf1c      	itt	ne
 8000506:	460b      	movne	r3, r1
 8000508:	4602      	movne	r2, r0
 800050a:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 800050e:	bf06      	itte	eq
 8000510:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 8000514:	ea91 0f03 	teqeq	r1, r3
 8000518:	f441 2100 	orrne.w	r1, r1, #524288	@ 0x80000
 800051c:	bd30      	pop	{r4, r5, pc}
 800051e:	bf00      	nop

08000520 <__aeabi_ui2d>:
 8000520:	f090 0f00 	teq	r0, #0
 8000524:	bf04      	itt	eq
 8000526:	2100      	moveq	r1, #0
 8000528:	4770      	bxeq	lr
 800052a:	b530      	push	{r4, r5, lr}
 800052c:	f44f 6480 	mov.w	r4, #1024	@ 0x400
 8000530:	f104 0432 	add.w	r4, r4, #50	@ 0x32
 8000534:	f04f 0500 	mov.w	r5, #0
 8000538:	f04f 0100 	mov.w	r1, #0
 800053c:	e750      	b.n	80003e0 <__adddf3+0x138>
 800053e:	bf00      	nop

08000540 <__aeabi_i2d>:
 8000540:	f090 0f00 	teq	r0, #0
 8000544:	bf04      	itt	eq
 8000546:	2100      	moveq	r1, #0
 8000548:	4770      	bxeq	lr
 800054a:	b530      	push	{r4, r5, lr}
 800054c:	f44f 6480 	mov.w	r4, #1024	@ 0x400
 8000550:	f104 0432 	add.w	r4, r4, #50	@ 0x32
 8000554:	f010 4500 	ands.w	r5, r0, #2147483648	@ 0x80000000
 8000558:	bf48      	it	mi
 800055a:	4240      	negmi	r0, r0
 800055c:	f04f 0100 	mov.w	r1, #0
 8000560:	e73e      	b.n	80003e0 <__adddf3+0x138>
 8000562:	bf00      	nop

08000564 <__aeabi_f2d>:
 8000564:	0042      	lsls	r2, r0, #1
 8000566:	ea4f 01e2 	mov.w	r1, r2, asr #3
 800056a:	ea4f 0131 	mov.w	r1, r1, rrx
 800056e:	ea4f 7002 	mov.w	r0, r2, lsl #28
 8000572:	bf1f      	itttt	ne
 8000574:	f012 437f 	andsne.w	r3, r2, #4278190080	@ 0xff000000
 8000578:	f093 4f7f 	teqne	r3, #4278190080	@ 0xff000000
 800057c:	f081 5160 	eorne.w	r1, r1, #939524096	@ 0x38000000
 8000580:	4770      	bxne	lr
 8000582:	f032 427f 	bics.w	r2, r2, #4278190080	@ 0xff000000
 8000586:	bf08      	it	eq
 8000588:	4770      	bxeq	lr
 800058a:	f093 4f7f 	teq	r3, #4278190080	@ 0xff000000
 800058e:	bf04      	itt	eq
 8000590:	f441 2100 	orreq.w	r1, r1, #524288	@ 0x80000
 8000594:	4770      	bxeq	lr
 8000596:	b530      	push	{r4, r5, lr}
 8000598:	f44f 7460 	mov.w	r4, #896	@ 0x380
 800059c:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
 80005a0:	f021 4100 	bic.w	r1, r1, #2147483648	@ 0x80000000
 80005a4:	e71c      	b.n	80003e0 <__adddf3+0x138>
 80005a6:	bf00      	nop

080005a8 <__aeabi_ul2d>:
 80005a8:	ea50 0201 	orrs.w	r2, r0, r1
 80005ac:	bf08      	it	eq
 80005ae:	4770      	bxeq	lr
 80005b0:	b530      	push	{r4, r5, lr}
 80005b2:	f04f 0500 	mov.w	r5, #0
 80005b6:	e00a      	b.n	80005ce <__aeabi_l2d+0x16>

080005b8 <__aeabi_l2d>:
 80005b8:	ea50 0201 	orrs.w	r2, r0, r1
 80005bc:	bf08      	it	eq
 80005be:	4770      	bxeq	lr
 80005c0:	b530      	push	{r4, r5, lr}
 80005c2:	f011 4500 	ands.w	r5, r1, #2147483648	@ 0x80000000
 80005c6:	d502      	bpl.n	80005ce <__aeabi_l2d+0x16>
 80005c8:	4240      	negs	r0, r0
 80005ca:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80005ce:	f44f 6480 	mov.w	r4, #1024	@ 0x400
 80005d2:	f104 0432 	add.w	r4, r4, #50	@ 0x32
 80005d6:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 80005da:	f43f aed8 	beq.w	800038e <__adddf3+0xe6>
 80005de:	f04f 0203 	mov.w	r2, #3
 80005e2:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80005e6:	bf18      	it	ne
 80005e8:	3203      	addne	r2, #3
 80005ea:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80005ee:	bf18      	it	ne
 80005f0:	3203      	addne	r2, #3
 80005f2:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 80005f6:	f1c2 0320 	rsb	r3, r2, #32
 80005fa:	fa00 fc03 	lsl.w	ip, r0, r3
 80005fe:	fa20 f002 	lsr.w	r0, r0, r2
 8000602:	fa01 fe03 	lsl.w	lr, r1, r3
 8000606:	ea40 000e 	orr.w	r0, r0, lr
 800060a:	fa21 f102 	lsr.w	r1, r1, r2
 800060e:	4414      	add	r4, r2
 8000610:	e6bd      	b.n	800038e <__adddf3+0xe6>
 8000612:	bf00      	nop

08000614 <__aeabi_dmul>:
 8000614:	b570      	push	{r4, r5, r6, lr}
 8000616:	f04f 0cff 	mov.w	ip, #255	@ 0xff
 800061a:	f44c 6ce0 	orr.w	ip, ip, #1792	@ 0x700
 800061e:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8000622:	bf1d      	ittte	ne
 8000624:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8000628:	ea94 0f0c 	teqne	r4, ip
 800062c:	ea95 0f0c 	teqne	r5, ip
 8000630:	f000 f8de 	bleq	80007f0 <__aeabi_dmul+0x1dc>
 8000634:	442c      	add	r4, r5
 8000636:	ea81 0603 	eor.w	r6, r1, r3
 800063a:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 800063e:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 8000642:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 8000646:	bf18      	it	ne
 8000648:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 800064c:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
 8000650:	f443 1380 	orr.w	r3, r3, #1048576	@ 0x100000
 8000654:	d038      	beq.n	80006c8 <__aeabi_dmul+0xb4>
 8000656:	fba0 ce02 	umull	ip, lr, r0, r2
 800065a:	f04f 0500 	mov.w	r5, #0
 800065e:	fbe1 e502 	umlal	lr, r5, r1, r2
 8000662:	f006 4200 	and.w	r2, r6, #2147483648	@ 0x80000000
 8000666:	fbe0 e503 	umlal	lr, r5, r0, r3
 800066a:	f04f 0600 	mov.w	r6, #0
 800066e:	fbe1 5603 	umlal	r5, r6, r1, r3
 8000672:	f09c 0f00 	teq	ip, #0
 8000676:	bf18      	it	ne
 8000678:	f04e 0e01 	orrne.w	lr, lr, #1
 800067c:	f1a4 04ff 	sub.w	r4, r4, #255	@ 0xff
 8000680:	f5b6 7f00 	cmp.w	r6, #512	@ 0x200
 8000684:	f564 7440 	sbc.w	r4, r4, #768	@ 0x300
 8000688:	d204      	bcs.n	8000694 <__aeabi_dmul+0x80>
 800068a:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 800068e:	416d      	adcs	r5, r5
 8000690:	eb46 0606 	adc.w	r6, r6, r6
 8000694:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 8000698:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 800069c:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 80006a0:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 80006a4:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 80006a8:	f1b4 0cfd 	subs.w	ip, r4, #253	@ 0xfd
 80006ac:	bf88      	it	hi
 80006ae:	f5bc 6fe0 	cmphi.w	ip, #1792	@ 0x700
 80006b2:	d81e      	bhi.n	80006f2 <__aeabi_dmul+0xde>
 80006b4:	f1be 4f00 	cmp.w	lr, #2147483648	@ 0x80000000
 80006b8:	bf08      	it	eq
 80006ba:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 80006be:	f150 0000 	adcs.w	r0, r0, #0
 80006c2:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80006c6:	bd70      	pop	{r4, r5, r6, pc}
 80006c8:	f006 4600 	and.w	r6, r6, #2147483648	@ 0x80000000
 80006cc:	ea46 0101 	orr.w	r1, r6, r1
 80006d0:	ea40 0002 	orr.w	r0, r0, r2
 80006d4:	ea81 0103 	eor.w	r1, r1, r3
 80006d8:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 80006dc:	bfc2      	ittt	gt
 80006de:	ebd4 050c 	rsbsgt	r5, r4, ip
 80006e2:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80006e6:	bd70      	popgt	{r4, r5, r6, pc}
 80006e8:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
 80006ec:	f04f 0e00 	mov.w	lr, #0
 80006f0:	3c01      	subs	r4, #1
 80006f2:	f300 80ab 	bgt.w	800084c <__aeabi_dmul+0x238>
 80006f6:	f114 0f36 	cmn.w	r4, #54	@ 0x36
 80006fa:	bfde      	ittt	le
 80006fc:	2000      	movle	r0, #0
 80006fe:	f001 4100 	andle.w	r1, r1, #2147483648	@ 0x80000000
 8000702:	bd70      	pople	{r4, r5, r6, pc}
 8000704:	f1c4 0400 	rsb	r4, r4, #0
 8000708:	3c20      	subs	r4, #32
 800070a:	da35      	bge.n	8000778 <__aeabi_dmul+0x164>
 800070c:	340c      	adds	r4, #12
 800070e:	dc1b      	bgt.n	8000748 <__aeabi_dmul+0x134>
 8000710:	f104 0414 	add.w	r4, r4, #20
 8000714:	f1c4 0520 	rsb	r5, r4, #32
 8000718:	fa00 f305 	lsl.w	r3, r0, r5
 800071c:	fa20 f004 	lsr.w	r0, r0, r4
 8000720:	fa01 f205 	lsl.w	r2, r1, r5
 8000724:	ea40 0002 	orr.w	r0, r0, r2
 8000728:	f001 4200 	and.w	r2, r1, #2147483648	@ 0x80000000
 800072c:	f021 4100 	bic.w	r1, r1, #2147483648	@ 0x80000000
 8000730:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8000734:	fa21 f604 	lsr.w	r6, r1, r4
 8000738:	eb42 0106 	adc.w	r1, r2, r6
 800073c:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000740:	bf08      	it	eq
 8000742:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8000746:	bd70      	pop	{r4, r5, r6, pc}
 8000748:	f1c4 040c 	rsb	r4, r4, #12
 800074c:	f1c4 0520 	rsb	r5, r4, #32
 8000750:	fa00 f304 	lsl.w	r3, r0, r4
 8000754:	fa20 f005 	lsr.w	r0, r0, r5
 8000758:	fa01 f204 	lsl.w	r2, r1, r4
 800075c:	ea40 0002 	orr.w	r0, r0, r2
 8000760:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
 8000764:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8000768:	f141 0100 	adc.w	r1, r1, #0
 800076c:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000770:	bf08      	it	eq
 8000772:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8000776:	bd70      	pop	{r4, r5, r6, pc}
 8000778:	f1c4 0520 	rsb	r5, r4, #32
 800077c:	fa00 f205 	lsl.w	r2, r0, r5
 8000780:	ea4e 0e02 	orr.w	lr, lr, r2
 8000784:	fa20 f304 	lsr.w	r3, r0, r4
 8000788:	fa01 f205 	lsl.w	r2, r1, r5
 800078c:	ea43 0302 	orr.w	r3, r3, r2
 8000790:	fa21 f004 	lsr.w	r0, r1, r4
 8000794:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
 8000798:	fa21 f204 	lsr.w	r2, r1, r4
 800079c:	ea20 0002 	bic.w	r0, r0, r2
 80007a0:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 80007a4:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80007a8:	bf08      	it	eq
 80007aa:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80007ae:	bd70      	pop	{r4, r5, r6, pc}
 80007b0:	f094 0f00 	teq	r4, #0
 80007b4:	d10f      	bne.n	80007d6 <__aeabi_dmul+0x1c2>
 80007b6:	f001 4600 	and.w	r6, r1, #2147483648	@ 0x80000000
 80007ba:	0040      	lsls	r0, r0, #1
 80007bc:	eb41 0101 	adc.w	r1, r1, r1
 80007c0:	f411 1f80 	tst.w	r1, #1048576	@ 0x100000
 80007c4:	bf08      	it	eq
 80007c6:	3c01      	subeq	r4, #1
 80007c8:	d0f7      	beq.n	80007ba <__aeabi_dmul+0x1a6>
 80007ca:	ea41 0106 	orr.w	r1, r1, r6
 80007ce:	f095 0f00 	teq	r5, #0
 80007d2:	bf18      	it	ne
 80007d4:	4770      	bxne	lr
 80007d6:	f003 4600 	and.w	r6, r3, #2147483648	@ 0x80000000
 80007da:	0052      	lsls	r2, r2, #1
 80007dc:	eb43 0303 	adc.w	r3, r3, r3
 80007e0:	f413 1f80 	tst.w	r3, #1048576	@ 0x100000
 80007e4:	bf08      	it	eq
 80007e6:	3d01      	subeq	r5, #1
 80007e8:	d0f7      	beq.n	80007da <__aeabi_dmul+0x1c6>
 80007ea:	ea43 0306 	orr.w	r3, r3, r6
 80007ee:	4770      	bx	lr
 80007f0:	ea94 0f0c 	teq	r4, ip
 80007f4:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80007f8:	bf18      	it	ne
 80007fa:	ea95 0f0c 	teqne	r5, ip
 80007fe:	d00c      	beq.n	800081a <__aeabi_dmul+0x206>
 8000800:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000804:	bf18      	it	ne
 8000806:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800080a:	d1d1      	bne.n	80007b0 <__aeabi_dmul+0x19c>
 800080c:	ea81 0103 	eor.w	r1, r1, r3
 8000810:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
 8000814:	f04f 0000 	mov.w	r0, #0
 8000818:	bd70      	pop	{r4, r5, r6, pc}
 800081a:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800081e:	bf06      	itte	eq
 8000820:	4610      	moveq	r0, r2
 8000822:	4619      	moveq	r1, r3
 8000824:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000828:	d019      	beq.n	800085e <__aeabi_dmul+0x24a>
 800082a:	ea94 0f0c 	teq	r4, ip
 800082e:	d102      	bne.n	8000836 <__aeabi_dmul+0x222>
 8000830:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 8000834:	d113      	bne.n	800085e <__aeabi_dmul+0x24a>
 8000836:	ea95 0f0c 	teq	r5, ip
 800083a:	d105      	bne.n	8000848 <__aeabi_dmul+0x234>
 800083c:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 8000840:	bf1c      	itt	ne
 8000842:	4610      	movne	r0, r2
 8000844:	4619      	movne	r1, r3
 8000846:	d10a      	bne.n	800085e <__aeabi_dmul+0x24a>
 8000848:	ea81 0103 	eor.w	r1, r1, r3
 800084c:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
 8000850:	f041 41fe 	orr.w	r1, r1, #2130706432	@ 0x7f000000
 8000854:	f441 0170 	orr.w	r1, r1, #15728640	@ 0xf00000
 8000858:	f04f 0000 	mov.w	r0, #0
 800085c:	bd70      	pop	{r4, r5, r6, pc}
 800085e:	f041 41fe 	orr.w	r1, r1, #2130706432	@ 0x7f000000
 8000862:	f441 0178 	orr.w	r1, r1, #16252928	@ 0xf80000
 8000866:	bd70      	pop	{r4, r5, r6, pc}

08000868 <__aeabi_ddiv>:
 8000868:	b570      	push	{r4, r5, r6, lr}
 800086a:	f04f 0cff 	mov.w	ip, #255	@ 0xff
 800086e:	f44c 6ce0 	orr.w	ip, ip, #1792	@ 0x700
 8000872:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8000876:	bf1d      	ittte	ne
 8000878:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 800087c:	ea94 0f0c 	teqne	r4, ip
 8000880:	ea95 0f0c 	teqne	r5, ip
 8000884:	f000 f8a7 	bleq	80009d6 <__aeabi_ddiv+0x16e>
 8000888:	eba4 0405 	sub.w	r4, r4, r5
 800088c:	ea81 0e03 	eor.w	lr, r1, r3
 8000890:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8000894:	ea4f 3101 	mov.w	r1, r1, lsl #12
 8000898:	f000 8088 	beq.w	80009ac <__aeabi_ddiv+0x144>
 800089c:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80008a0:	f04f 5580 	mov.w	r5, #268435456	@ 0x10000000
 80008a4:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 80008a8:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 80008ac:	ea4f 2202 	mov.w	r2, r2, lsl #8
 80008b0:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 80008b4:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 80008b8:	ea4f 2600 	mov.w	r6, r0, lsl #8
 80008bc:	f00e 4100 	and.w	r1, lr, #2147483648	@ 0x80000000
 80008c0:	429d      	cmp	r5, r3
 80008c2:	bf08      	it	eq
 80008c4:	4296      	cmpeq	r6, r2
 80008c6:	f144 04fd 	adc.w	r4, r4, #253	@ 0xfd
 80008ca:	f504 7440 	add.w	r4, r4, #768	@ 0x300
 80008ce:	d202      	bcs.n	80008d6 <__aeabi_ddiv+0x6e>
 80008d0:	085b      	lsrs	r3, r3, #1
 80008d2:	ea4f 0232 	mov.w	r2, r2, rrx
 80008d6:	1ab6      	subs	r6, r6, r2
 80008d8:	eb65 0503 	sbc.w	r5, r5, r3
 80008dc:	085b      	lsrs	r3, r3, #1
 80008de:	ea4f 0232 	mov.w	r2, r2, rrx
 80008e2:	f44f 1080 	mov.w	r0, #1048576	@ 0x100000
 80008e6:	f44f 2c00 	mov.w	ip, #524288	@ 0x80000
 80008ea:	ebb6 0e02 	subs.w	lr, r6, r2
 80008ee:	eb75 0e03 	sbcs.w	lr, r5, r3
 80008f2:	bf22      	ittt	cs
 80008f4:	1ab6      	subcs	r6, r6, r2
 80008f6:	4675      	movcs	r5, lr
 80008f8:	ea40 000c 	orrcs.w	r0, r0, ip
 80008fc:	085b      	lsrs	r3, r3, #1
 80008fe:	ea4f 0232 	mov.w	r2, r2, rrx
 8000902:	ebb6 0e02 	subs.w	lr, r6, r2
 8000906:	eb75 0e03 	sbcs.w	lr, r5, r3
 800090a:	bf22      	ittt	cs
 800090c:	1ab6      	subcs	r6, r6, r2
 800090e:	4675      	movcs	r5, lr
 8000910:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8000914:	085b      	lsrs	r3, r3, #1
 8000916:	ea4f 0232 	mov.w	r2, r2, rrx
 800091a:	ebb6 0e02 	subs.w	lr, r6, r2
 800091e:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000922:	bf22      	ittt	cs
 8000924:	1ab6      	subcs	r6, r6, r2
 8000926:	4675      	movcs	r5, lr
 8000928:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 800092c:	085b      	lsrs	r3, r3, #1
 800092e:	ea4f 0232 	mov.w	r2, r2, rrx
 8000932:	ebb6 0e02 	subs.w	lr, r6, r2
 8000936:	eb75 0e03 	sbcs.w	lr, r5, r3
 800093a:	bf22      	ittt	cs
 800093c:	1ab6      	subcs	r6, r6, r2
 800093e:	4675      	movcs	r5, lr
 8000940:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8000944:	ea55 0e06 	orrs.w	lr, r5, r6
 8000948:	d018      	beq.n	800097c <__aeabi_ddiv+0x114>
 800094a:	ea4f 1505 	mov.w	r5, r5, lsl #4
 800094e:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 8000952:	ea4f 1606 	mov.w	r6, r6, lsl #4
 8000956:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800095a:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 800095e:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 8000962:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 8000966:	d1c0      	bne.n	80008ea <__aeabi_ddiv+0x82>
 8000968:	f411 1f80 	tst.w	r1, #1048576	@ 0x100000
 800096c:	d10b      	bne.n	8000986 <__aeabi_ddiv+0x11e>
 800096e:	ea41 0100 	orr.w	r1, r1, r0
 8000972:	f04f 0000 	mov.w	r0, #0
 8000976:	f04f 4c00 	mov.w	ip, #2147483648	@ 0x80000000
 800097a:	e7b6      	b.n	80008ea <__aeabi_ddiv+0x82>
 800097c:	f411 1f80 	tst.w	r1, #1048576	@ 0x100000
 8000980:	bf04      	itt	eq
 8000982:	4301      	orreq	r1, r0
 8000984:	2000      	moveq	r0, #0
 8000986:	f1b4 0cfd 	subs.w	ip, r4, #253	@ 0xfd
 800098a:	bf88      	it	hi
 800098c:	f5bc 6fe0 	cmphi.w	ip, #1792	@ 0x700
 8000990:	f63f aeaf 	bhi.w	80006f2 <__aeabi_dmul+0xde>
 8000994:	ebb5 0c03 	subs.w	ip, r5, r3
 8000998:	bf04      	itt	eq
 800099a:	ebb6 0c02 	subseq.w	ip, r6, r2
 800099e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80009a2:	f150 0000 	adcs.w	r0, r0, #0
 80009a6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80009aa:	bd70      	pop	{r4, r5, r6, pc}
 80009ac:	f00e 4e00 	and.w	lr, lr, #2147483648	@ 0x80000000
 80009b0:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 80009b4:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 80009b8:	bfc2      	ittt	gt
 80009ba:	ebd4 050c 	rsbsgt	r5, r4, ip
 80009be:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80009c2:	bd70      	popgt	{r4, r5, r6, pc}
 80009c4:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
 80009c8:	f04f 0e00 	mov.w	lr, #0
 80009cc:	3c01      	subs	r4, #1
 80009ce:	e690      	b.n	80006f2 <__aeabi_dmul+0xde>
 80009d0:	ea45 0e06 	orr.w	lr, r5, r6
 80009d4:	e68d      	b.n	80006f2 <__aeabi_dmul+0xde>
 80009d6:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80009da:	ea94 0f0c 	teq	r4, ip
 80009de:	bf08      	it	eq
 80009e0:	ea95 0f0c 	teqeq	r5, ip
 80009e4:	f43f af3b 	beq.w	800085e <__aeabi_dmul+0x24a>
 80009e8:	ea94 0f0c 	teq	r4, ip
 80009ec:	d10a      	bne.n	8000a04 <__aeabi_ddiv+0x19c>
 80009ee:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80009f2:	f47f af34 	bne.w	800085e <__aeabi_dmul+0x24a>
 80009f6:	ea95 0f0c 	teq	r5, ip
 80009fa:	f47f af25 	bne.w	8000848 <__aeabi_dmul+0x234>
 80009fe:	4610      	mov	r0, r2
 8000a00:	4619      	mov	r1, r3
 8000a02:	e72c      	b.n	800085e <__aeabi_dmul+0x24a>
 8000a04:	ea95 0f0c 	teq	r5, ip
 8000a08:	d106      	bne.n	8000a18 <__aeabi_ddiv+0x1b0>
 8000a0a:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8000a0e:	f43f aefd 	beq.w	800080c <__aeabi_dmul+0x1f8>
 8000a12:	4610      	mov	r0, r2
 8000a14:	4619      	mov	r1, r3
 8000a16:	e722      	b.n	800085e <__aeabi_dmul+0x24a>
 8000a18:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000a1c:	bf18      	it	ne
 8000a1e:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000a22:	f47f aec5 	bne.w	80007b0 <__aeabi_dmul+0x19c>
 8000a26:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 8000a2a:	f47f af0d 	bne.w	8000848 <__aeabi_dmul+0x234>
 8000a2e:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 8000a32:	f47f aeeb 	bne.w	800080c <__aeabi_dmul+0x1f8>
 8000a36:	e712      	b.n	800085e <__aeabi_dmul+0x24a>

08000a38 <__gedf2>:
 8000a38:	f04f 3cff 	mov.w	ip, #4294967295
 8000a3c:	e006      	b.n	8000a4c <__cmpdf2+0x4>
 8000a3e:	bf00      	nop

08000a40 <__ledf2>:
 8000a40:	f04f 0c01 	mov.w	ip, #1
 8000a44:	e002      	b.n	8000a4c <__cmpdf2+0x4>
 8000a46:	bf00      	nop

08000a48 <__cmpdf2>:
 8000a48:	f04f 0c01 	mov.w	ip, #1
 8000a4c:	f84d cd04 	str.w	ip, [sp, #-4]!
 8000a50:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000a54:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000a58:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000a5c:	bf18      	it	ne
 8000a5e:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 8000a62:	d01b      	beq.n	8000a9c <__cmpdf2+0x54>
 8000a64:	b001      	add	sp, #4
 8000a66:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 8000a6a:	bf0c      	ite	eq
 8000a6c:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 8000a70:	ea91 0f03 	teqne	r1, r3
 8000a74:	bf02      	ittt	eq
 8000a76:	ea90 0f02 	teqeq	r0, r2
 8000a7a:	2000      	moveq	r0, #0
 8000a7c:	4770      	bxeq	lr
 8000a7e:	f110 0f00 	cmn.w	r0, #0
 8000a82:	ea91 0f03 	teq	r1, r3
 8000a86:	bf58      	it	pl
 8000a88:	4299      	cmppl	r1, r3
 8000a8a:	bf08      	it	eq
 8000a8c:	4290      	cmpeq	r0, r2
 8000a8e:	bf2c      	ite	cs
 8000a90:	17d8      	asrcs	r0, r3, #31
 8000a92:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 8000a96:	f040 0001 	orr.w	r0, r0, #1
 8000a9a:	4770      	bx	lr
 8000a9c:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000aa0:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000aa4:	d102      	bne.n	8000aac <__cmpdf2+0x64>
 8000aa6:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 8000aaa:	d107      	bne.n	8000abc <__cmpdf2+0x74>
 8000aac:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000ab0:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000ab4:	d1d6      	bne.n	8000a64 <__cmpdf2+0x1c>
 8000ab6:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 8000aba:	d0d3      	beq.n	8000a64 <__cmpdf2+0x1c>
 8000abc:	f85d 0b04 	ldr.w	r0, [sp], #4
 8000ac0:	4770      	bx	lr
 8000ac2:	bf00      	nop

08000ac4 <__aeabi_cdrcmple>:
 8000ac4:	4684      	mov	ip, r0
 8000ac6:	4610      	mov	r0, r2
 8000ac8:	4662      	mov	r2, ip
 8000aca:	468c      	mov	ip, r1
 8000acc:	4619      	mov	r1, r3
 8000ace:	4663      	mov	r3, ip
 8000ad0:	e000      	b.n	8000ad4 <__aeabi_cdcmpeq>
 8000ad2:	bf00      	nop

08000ad4 <__aeabi_cdcmpeq>:
 8000ad4:	b501      	push	{r0, lr}
 8000ad6:	f7ff ffb7 	bl	8000a48 <__cmpdf2>
 8000ada:	2800      	cmp	r0, #0
 8000adc:	bf48      	it	mi
 8000ade:	f110 0f00 	cmnmi.w	r0, #0
 8000ae2:	bd01      	pop	{r0, pc}

08000ae4 <__aeabi_dcmpeq>:
 8000ae4:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000ae8:	f7ff fff4 	bl	8000ad4 <__aeabi_cdcmpeq>
 8000aec:	bf0c      	ite	eq
 8000aee:	2001      	moveq	r0, #1
 8000af0:	2000      	movne	r0, #0
 8000af2:	f85d fb08 	ldr.w	pc, [sp], #8
 8000af6:	bf00      	nop

08000af8 <__aeabi_dcmplt>:
 8000af8:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000afc:	f7ff ffea 	bl	8000ad4 <__aeabi_cdcmpeq>
 8000b00:	bf34      	ite	cc
 8000b02:	2001      	movcc	r0, #1
 8000b04:	2000      	movcs	r0, #0
 8000b06:	f85d fb08 	ldr.w	pc, [sp], #8
 8000b0a:	bf00      	nop

08000b0c <__aeabi_dcmple>:
 8000b0c:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000b10:	f7ff ffe0 	bl	8000ad4 <__aeabi_cdcmpeq>
 8000b14:	bf94      	ite	ls
 8000b16:	2001      	movls	r0, #1
 8000b18:	2000      	movhi	r0, #0
 8000b1a:	f85d fb08 	ldr.w	pc, [sp], #8
 8000b1e:	bf00      	nop

08000b20 <__aeabi_dcmpge>:
 8000b20:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000b24:	f7ff ffce 	bl	8000ac4 <__aeabi_cdrcmple>
 8000b28:	bf94      	ite	ls
 8000b2a:	2001      	movls	r0, #1
 8000b2c:	2000      	movhi	r0, #0
 8000b2e:	f85d fb08 	ldr.w	pc, [sp], #8
 8000b32:	bf00      	nop

08000b34 <__aeabi_dcmpgt>:
 8000b34:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000b38:	f7ff ffc4 	bl	8000ac4 <__aeabi_cdrcmple>
 8000b3c:	bf34      	ite	cc
 8000b3e:	2001      	movcc	r0, #1
 8000b40:	2000      	movcs	r0, #0
 8000b42:	f85d fb08 	ldr.w	pc, [sp], #8
 8000b46:	bf00      	nop

08000b48 <__aeabi_dcmpun>:
 8000b48:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000b4c:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000b50:	d102      	bne.n	8000b58 <__aeabi_dcmpun+0x10>
 8000b52:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 8000b56:	d10a      	bne.n	8000b6e <__aeabi_dcmpun+0x26>
 8000b58:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000b5c:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000b60:	d102      	bne.n	8000b68 <__aeabi_dcmpun+0x20>
 8000b62:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 8000b66:	d102      	bne.n	8000b6e <__aeabi_dcmpun+0x26>
 8000b68:	f04f 0000 	mov.w	r0, #0
 8000b6c:	4770      	bx	lr
 8000b6e:	f04f 0001 	mov.w	r0, #1
 8000b72:	4770      	bx	lr

08000b74 <__aeabi_d2iz>:
 8000b74:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8000b78:	f512 1200 	adds.w	r2, r2, #2097152	@ 0x200000
 8000b7c:	d215      	bcs.n	8000baa <__aeabi_d2iz+0x36>
 8000b7e:	d511      	bpl.n	8000ba4 <__aeabi_d2iz+0x30>
 8000b80:	f46f 7378 	mvn.w	r3, #992	@ 0x3e0
 8000b84:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 8000b88:	d912      	bls.n	8000bb0 <__aeabi_d2iz+0x3c>
 8000b8a:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000b8e:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 8000b92:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 8000b96:	f011 4f00 	tst.w	r1, #2147483648	@ 0x80000000
 8000b9a:	fa23 f002 	lsr.w	r0, r3, r2
 8000b9e:	bf18      	it	ne
 8000ba0:	4240      	negne	r0, r0
 8000ba2:	4770      	bx	lr
 8000ba4:	f04f 0000 	mov.w	r0, #0
 8000ba8:	4770      	bx	lr
 8000baa:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 8000bae:	d105      	bne.n	8000bbc <__aeabi_d2iz+0x48>
 8000bb0:	f011 4000 	ands.w	r0, r1, #2147483648	@ 0x80000000
 8000bb4:	bf08      	it	eq
 8000bb6:	f06f 4000 	mvneq.w	r0, #2147483648	@ 0x80000000
 8000bba:	4770      	bx	lr
 8000bbc:	f04f 0000 	mov.w	r0, #0
 8000bc0:	4770      	bx	lr
 8000bc2:	bf00      	nop

08000bc4 <__aeabi_d2uiz>:
 8000bc4:	004a      	lsls	r2, r1, #1
 8000bc6:	d211      	bcs.n	8000bec <__aeabi_d2uiz+0x28>
 8000bc8:	f512 1200 	adds.w	r2, r2, #2097152	@ 0x200000
 8000bcc:	d211      	bcs.n	8000bf2 <__aeabi_d2uiz+0x2e>
 8000bce:	d50d      	bpl.n	8000bec <__aeabi_d2uiz+0x28>
 8000bd0:	f46f 7378 	mvn.w	r3, #992	@ 0x3e0
 8000bd4:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 8000bd8:	d40e      	bmi.n	8000bf8 <__aeabi_d2uiz+0x34>
 8000bda:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000bde:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 8000be2:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 8000be6:	fa23 f002 	lsr.w	r0, r3, r2
 8000bea:	4770      	bx	lr
 8000bec:	f04f 0000 	mov.w	r0, #0
 8000bf0:	4770      	bx	lr
 8000bf2:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 8000bf6:	d102      	bne.n	8000bfe <__aeabi_d2uiz+0x3a>
 8000bf8:	f04f 30ff 	mov.w	r0, #4294967295
 8000bfc:	4770      	bx	lr
 8000bfe:	f04f 0000 	mov.w	r0, #0
 8000c02:	4770      	bx	lr

08000c04 <__aeabi_d2f>:
 8000c04:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8000c08:	f1b2 43e0 	subs.w	r3, r2, #1879048192	@ 0x70000000
 8000c0c:	bf24      	itt	cs
 8000c0e:	f5b3 1c00 	subscs.w	ip, r3, #2097152	@ 0x200000
 8000c12:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	@ 0x1fc00000
 8000c16:	d90d      	bls.n	8000c34 <__aeabi_d2f+0x30>
 8000c18:	f001 4c00 	and.w	ip, r1, #2147483648	@ 0x80000000
 8000c1c:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 8000c20:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 8000c24:	f1b2 4f00 	cmp.w	r2, #2147483648	@ 0x80000000
 8000c28:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 8000c2c:	bf08      	it	eq
 8000c2e:	f020 0001 	biceq.w	r0, r0, #1
 8000c32:	4770      	bx	lr
 8000c34:	f011 4f80 	tst.w	r1, #1073741824	@ 0x40000000
 8000c38:	d121      	bne.n	8000c7e <__aeabi_d2f+0x7a>
 8000c3a:	f113 7238 	adds.w	r2, r3, #48234496	@ 0x2e00000
 8000c3e:	bfbc      	itt	lt
 8000c40:	f001 4000 	andlt.w	r0, r1, #2147483648	@ 0x80000000
 8000c44:	4770      	bxlt	lr
 8000c46:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
 8000c4a:	ea4f 5252 	mov.w	r2, r2, lsr #21
 8000c4e:	f1c2 0218 	rsb	r2, r2, #24
 8000c52:	f1c2 0c20 	rsb	ip, r2, #32
 8000c56:	fa10 f30c 	lsls.w	r3, r0, ip
 8000c5a:	fa20 f002 	lsr.w	r0, r0, r2
 8000c5e:	bf18      	it	ne
 8000c60:	f040 0001 	orrne.w	r0, r0, #1
 8000c64:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000c68:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 8000c6c:	fa03 fc0c 	lsl.w	ip, r3, ip
 8000c70:	ea40 000c 	orr.w	r0, r0, ip
 8000c74:	fa23 f302 	lsr.w	r3, r3, r2
 8000c78:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8000c7c:	e7cc      	b.n	8000c18 <__aeabi_d2f+0x14>
 8000c7e:	ea7f 5362 	mvns.w	r3, r2, asr #21
 8000c82:	d107      	bne.n	8000c94 <__aeabi_d2f+0x90>
 8000c84:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 8000c88:	bf1e      	ittt	ne
 8000c8a:	f04f 40fe 	movne.w	r0, #2130706432	@ 0x7f000000
 8000c8e:	f440 0040 	orrne.w	r0, r0, #12582912	@ 0xc00000
 8000c92:	4770      	bxne	lr
 8000c94:	f001 4000 	and.w	r0, r1, #2147483648	@ 0x80000000
 8000c98:	f040 40fe 	orr.w	r0, r0, #2130706432	@ 0x7f000000
 8000c9c:	f440 0000 	orr.w	r0, r0, #8388608	@ 0x800000
 8000ca0:	4770      	bx	lr
 8000ca2:	bf00      	nop

08000ca4 <__aeabi_uldivmod>:
 8000ca4:	b953      	cbnz	r3, 8000cbc <__aeabi_uldivmod+0x18>
 8000ca6:	b94a      	cbnz	r2, 8000cbc <__aeabi_uldivmod+0x18>
 8000ca8:	2900      	cmp	r1, #0
 8000caa:	bf08      	it	eq
 8000cac:	2800      	cmpeq	r0, #0
 8000cae:	bf1c      	itt	ne
 8000cb0:	f04f 31ff 	movne.w	r1, #4294967295
 8000cb4:	f04f 30ff 	movne.w	r0, #4294967295
 8000cb8:	f000 b9e6 	b.w	8001088 <__aeabi_idiv0>
 8000cbc:	f1ad 0c08 	sub.w	ip, sp, #8
 8000cc0:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8000cc4:	f000 f83c 	bl	8000d40 <__udivmoddi4>
 8000cc8:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000ccc:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000cd0:	b004      	add	sp, #16
 8000cd2:	4770      	bx	lr

08000cd4 <__aeabi_d2lz>:
 8000cd4:	b538      	push	{r3, r4, r5, lr}
 8000cd6:	2200      	movs	r2, #0
 8000cd8:	2300      	movs	r3, #0
 8000cda:	4604      	mov	r4, r0
 8000cdc:	460d      	mov	r5, r1
 8000cde:	f7ff ff0b 	bl	8000af8 <__aeabi_dcmplt>
 8000ce2:	b928      	cbnz	r0, 8000cf0 <__aeabi_d2lz+0x1c>
 8000ce4:	4620      	mov	r0, r4
 8000ce6:	4629      	mov	r1, r5
 8000ce8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8000cec:	f000 b80a 	b.w	8000d04 <__aeabi_d2ulz>
 8000cf0:	4620      	mov	r0, r4
 8000cf2:	f105 4100 	add.w	r1, r5, #2147483648	@ 0x80000000
 8000cf6:	f000 f805 	bl	8000d04 <__aeabi_d2ulz>
 8000cfa:	4240      	negs	r0, r0
 8000cfc:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000d00:	bd38      	pop	{r3, r4, r5, pc}
 8000d02:	bf00      	nop

08000d04 <__aeabi_d2ulz>:
 8000d04:	b5d0      	push	{r4, r6, r7, lr}
 8000d06:	2200      	movs	r2, #0
 8000d08:	4b0b      	ldr	r3, [pc, #44]	@ (8000d38 <__aeabi_d2ulz+0x34>)
 8000d0a:	4606      	mov	r6, r0
 8000d0c:	460f      	mov	r7, r1
 8000d0e:	f7ff fc81 	bl	8000614 <__aeabi_dmul>
 8000d12:	f7ff ff57 	bl	8000bc4 <__aeabi_d2uiz>
 8000d16:	4604      	mov	r4, r0
 8000d18:	f7ff fc02 	bl	8000520 <__aeabi_ui2d>
 8000d1c:	2200      	movs	r2, #0
 8000d1e:	4b07      	ldr	r3, [pc, #28]	@ (8000d3c <__aeabi_d2ulz+0x38>)
 8000d20:	f7ff fc78 	bl	8000614 <__aeabi_dmul>
 8000d24:	4602      	mov	r2, r0
 8000d26:	460b      	mov	r3, r1
 8000d28:	4630      	mov	r0, r6
 8000d2a:	4639      	mov	r1, r7
 8000d2c:	f7ff faba 	bl	80002a4 <__aeabi_dsub>
 8000d30:	f7ff ff48 	bl	8000bc4 <__aeabi_d2uiz>
 8000d34:	4621      	mov	r1, r4
 8000d36:	bdd0      	pop	{r4, r6, r7, pc}
 8000d38:	3df00000 	.word	0x3df00000
 8000d3c:	41f00000 	.word	0x41f00000

08000d40 <__udivmoddi4>:
 8000d40:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000d44:	9d09      	ldr	r5, [sp, #36]	@ 0x24
 8000d46:	4688      	mov	r8, r1
 8000d48:	4604      	mov	r4, r0
 8000d4a:	468e      	mov	lr, r1
 8000d4c:	2b00      	cmp	r3, #0
 8000d4e:	d14a      	bne.n	8000de6 <__udivmoddi4+0xa6>
 8000d50:	428a      	cmp	r2, r1
 8000d52:	4617      	mov	r7, r2
 8000d54:	d95f      	bls.n	8000e16 <__udivmoddi4+0xd6>
 8000d56:	fab2 f682 	clz	r6, r2
 8000d5a:	b14e      	cbz	r6, 8000d70 <__udivmoddi4+0x30>
 8000d5c:	f1c6 0320 	rsb	r3, r6, #32
 8000d60:	fa01 fe06 	lsl.w	lr, r1, r6
 8000d64:	40b7      	lsls	r7, r6
 8000d66:	40b4      	lsls	r4, r6
 8000d68:	fa20 f303 	lsr.w	r3, r0, r3
 8000d6c:	ea43 0e0e 	orr.w	lr, r3, lr
 8000d70:	ea4f 4817 	mov.w	r8, r7, lsr #16
 8000d74:	fa1f fc87 	uxth.w	ip, r7
 8000d78:	0c23      	lsrs	r3, r4, #16
 8000d7a:	fbbe f1f8 	udiv	r1, lr, r8
 8000d7e:	fb08 ee11 	mls	lr, r8, r1, lr
 8000d82:	fb01 f20c 	mul.w	r2, r1, ip
 8000d86:	ea43 430e 	orr.w	r3, r3, lr, lsl #16
 8000d8a:	429a      	cmp	r2, r3
 8000d8c:	d907      	bls.n	8000d9e <__udivmoddi4+0x5e>
 8000d8e:	18fb      	adds	r3, r7, r3
 8000d90:	f101 30ff 	add.w	r0, r1, #4294967295
 8000d94:	d202      	bcs.n	8000d9c <__udivmoddi4+0x5c>
 8000d96:	429a      	cmp	r2, r3
 8000d98:	f200 8154 	bhi.w	8001044 <__udivmoddi4+0x304>
 8000d9c:	4601      	mov	r1, r0
 8000d9e:	1a9b      	subs	r3, r3, r2
 8000da0:	b2a2      	uxth	r2, r4
 8000da2:	fbb3 f0f8 	udiv	r0, r3, r8
 8000da6:	fb08 3310 	mls	r3, r8, r0, r3
 8000daa:	fb00 fc0c 	mul.w	ip, r0, ip
 8000dae:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
 8000db2:	4594      	cmp	ip, r2
 8000db4:	d90b      	bls.n	8000dce <__udivmoddi4+0x8e>
 8000db6:	18ba      	adds	r2, r7, r2
 8000db8:	f100 33ff 	add.w	r3, r0, #4294967295
 8000dbc:	bf2c      	ite	cs
 8000dbe:	2401      	movcs	r4, #1
 8000dc0:	2400      	movcc	r4, #0
 8000dc2:	4594      	cmp	ip, r2
 8000dc4:	d902      	bls.n	8000dcc <__udivmoddi4+0x8c>
 8000dc6:	2c00      	cmp	r4, #0
 8000dc8:	f000 813f 	beq.w	800104a <__udivmoddi4+0x30a>
 8000dcc:	4618      	mov	r0, r3
 8000dce:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
 8000dd2:	eba2 020c 	sub.w	r2, r2, ip
 8000dd6:	2100      	movs	r1, #0
 8000dd8:	b11d      	cbz	r5, 8000de2 <__udivmoddi4+0xa2>
 8000dda:	40f2      	lsrs	r2, r6
 8000ddc:	2300      	movs	r3, #0
 8000dde:	e9c5 2300 	strd	r2, r3, [r5]
 8000de2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000de6:	428b      	cmp	r3, r1
 8000de8:	d905      	bls.n	8000df6 <__udivmoddi4+0xb6>
 8000dea:	b10d      	cbz	r5, 8000df0 <__udivmoddi4+0xb0>
 8000dec:	e9c5 0100 	strd	r0, r1, [r5]
 8000df0:	2100      	movs	r1, #0
 8000df2:	4608      	mov	r0, r1
 8000df4:	e7f5      	b.n	8000de2 <__udivmoddi4+0xa2>
 8000df6:	fab3 f183 	clz	r1, r3
 8000dfa:	2900      	cmp	r1, #0
 8000dfc:	d14e      	bne.n	8000e9c <__udivmoddi4+0x15c>
 8000dfe:	4543      	cmp	r3, r8
 8000e00:	f0c0 8112 	bcc.w	8001028 <__udivmoddi4+0x2e8>
 8000e04:	4282      	cmp	r2, r0
 8000e06:	f240 810f 	bls.w	8001028 <__udivmoddi4+0x2e8>
 8000e0a:	4608      	mov	r0, r1
 8000e0c:	2d00      	cmp	r5, #0
 8000e0e:	d0e8      	beq.n	8000de2 <__udivmoddi4+0xa2>
 8000e10:	e9c5 4e00 	strd	r4, lr, [r5]
 8000e14:	e7e5      	b.n	8000de2 <__udivmoddi4+0xa2>
 8000e16:	2a00      	cmp	r2, #0
 8000e18:	f000 80ac 	beq.w	8000f74 <__udivmoddi4+0x234>
 8000e1c:	fab2 f682 	clz	r6, r2
 8000e20:	2e00      	cmp	r6, #0
 8000e22:	f040 80bb 	bne.w	8000f9c <__udivmoddi4+0x25c>
 8000e26:	1a8b      	subs	r3, r1, r2
 8000e28:	ea4f 4e12 	mov.w	lr, r2, lsr #16
 8000e2c:	b2bc      	uxth	r4, r7
 8000e2e:	2101      	movs	r1, #1
 8000e30:	0c02      	lsrs	r2, r0, #16
 8000e32:	b280      	uxth	r0, r0
 8000e34:	fbb3 fcfe 	udiv	ip, r3, lr
 8000e38:	fb0e 331c 	mls	r3, lr, ip, r3
 8000e3c:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
 8000e40:	fb04 f20c 	mul.w	r2, r4, ip
 8000e44:	429a      	cmp	r2, r3
 8000e46:	d90e      	bls.n	8000e66 <__udivmoddi4+0x126>
 8000e48:	18fb      	adds	r3, r7, r3
 8000e4a:	f10c 38ff 	add.w	r8, ip, #4294967295
 8000e4e:	bf2c      	ite	cs
 8000e50:	f04f 0901 	movcs.w	r9, #1
 8000e54:	f04f 0900 	movcc.w	r9, #0
 8000e58:	429a      	cmp	r2, r3
 8000e5a:	d903      	bls.n	8000e64 <__udivmoddi4+0x124>
 8000e5c:	f1b9 0f00 	cmp.w	r9, #0
 8000e60:	f000 80ec 	beq.w	800103c <__udivmoddi4+0x2fc>
 8000e64:	46c4      	mov	ip, r8
 8000e66:	1a9b      	subs	r3, r3, r2
 8000e68:	fbb3 f8fe 	udiv	r8, r3, lr
 8000e6c:	fb0e 3318 	mls	r3, lr, r8, r3
 8000e70:	fb04 f408 	mul.w	r4, r4, r8
 8000e74:	ea40 4203 	orr.w	r2, r0, r3, lsl #16
 8000e78:	4294      	cmp	r4, r2
 8000e7a:	d90b      	bls.n	8000e94 <__udivmoddi4+0x154>
 8000e7c:	18ba      	adds	r2, r7, r2
 8000e7e:	f108 33ff 	add.w	r3, r8, #4294967295
 8000e82:	bf2c      	ite	cs
 8000e84:	2001      	movcs	r0, #1
 8000e86:	2000      	movcc	r0, #0
 8000e88:	4294      	cmp	r4, r2
 8000e8a:	d902      	bls.n	8000e92 <__udivmoddi4+0x152>
 8000e8c:	2800      	cmp	r0, #0
 8000e8e:	f000 80d1 	beq.w	8001034 <__udivmoddi4+0x2f4>
 8000e92:	4698      	mov	r8, r3
 8000e94:	1b12      	subs	r2, r2, r4
 8000e96:	ea48 400c 	orr.w	r0, r8, ip, lsl #16
 8000e9a:	e79d      	b.n	8000dd8 <__udivmoddi4+0x98>
 8000e9c:	f1c1 0620 	rsb	r6, r1, #32
 8000ea0:	408b      	lsls	r3, r1
 8000ea2:	fa08 f401 	lsl.w	r4, r8, r1
 8000ea6:	fa00 f901 	lsl.w	r9, r0, r1
 8000eaa:	fa22 f706 	lsr.w	r7, r2, r6
 8000eae:	fa28 f806 	lsr.w	r8, r8, r6
 8000eb2:	408a      	lsls	r2, r1
 8000eb4:	431f      	orrs	r7, r3
 8000eb6:	fa20 f306 	lsr.w	r3, r0, r6
 8000eba:	0c38      	lsrs	r0, r7, #16
 8000ebc:	4323      	orrs	r3, r4
 8000ebe:	fa1f fc87 	uxth.w	ip, r7
 8000ec2:	0c1c      	lsrs	r4, r3, #16
 8000ec4:	fbb8 fef0 	udiv	lr, r8, r0
 8000ec8:	fb00 881e 	mls	r8, r0, lr, r8
 8000ecc:	ea44 4408 	orr.w	r4, r4, r8, lsl #16
 8000ed0:	fb0e f80c 	mul.w	r8, lr, ip
 8000ed4:	45a0      	cmp	r8, r4
 8000ed6:	d90e      	bls.n	8000ef6 <__udivmoddi4+0x1b6>
 8000ed8:	193c      	adds	r4, r7, r4
 8000eda:	f10e 3aff 	add.w	sl, lr, #4294967295
 8000ede:	bf2c      	ite	cs
 8000ee0:	f04f 0b01 	movcs.w	fp, #1
 8000ee4:	f04f 0b00 	movcc.w	fp, #0
 8000ee8:	45a0      	cmp	r8, r4
 8000eea:	d903      	bls.n	8000ef4 <__udivmoddi4+0x1b4>
 8000eec:	f1bb 0f00 	cmp.w	fp, #0
 8000ef0:	f000 80b8 	beq.w	8001064 <__udivmoddi4+0x324>
 8000ef4:	46d6      	mov	lr, sl
 8000ef6:	eba4 0408 	sub.w	r4, r4, r8
 8000efa:	fa1f f883 	uxth.w	r8, r3
 8000efe:	fbb4 f3f0 	udiv	r3, r4, r0
 8000f02:	fb00 4413 	mls	r4, r0, r3, r4
 8000f06:	fb03 fc0c 	mul.w	ip, r3, ip
 8000f0a:	ea48 4404 	orr.w	r4, r8, r4, lsl #16
 8000f0e:	45a4      	cmp	ip, r4
 8000f10:	d90e      	bls.n	8000f30 <__udivmoddi4+0x1f0>
 8000f12:	193c      	adds	r4, r7, r4
 8000f14:	f103 30ff 	add.w	r0, r3, #4294967295
 8000f18:	bf2c      	ite	cs
 8000f1a:	f04f 0801 	movcs.w	r8, #1
 8000f1e:	f04f 0800 	movcc.w	r8, #0
 8000f22:	45a4      	cmp	ip, r4
 8000f24:	d903      	bls.n	8000f2e <__udivmoddi4+0x1ee>
 8000f26:	f1b8 0f00 	cmp.w	r8, #0
 8000f2a:	f000 809f 	beq.w	800106c <__udivmoddi4+0x32c>
 8000f2e:	4603      	mov	r3, r0
 8000f30:	ea43 400e 	orr.w	r0, r3, lr, lsl #16
 8000f34:	eba4 040c 	sub.w	r4, r4, ip
 8000f38:	fba0 ec02 	umull	lr, ip, r0, r2
 8000f3c:	4564      	cmp	r4, ip
 8000f3e:	4673      	mov	r3, lr
 8000f40:	46e0      	mov	r8, ip
 8000f42:	d302      	bcc.n	8000f4a <__udivmoddi4+0x20a>
 8000f44:	d107      	bne.n	8000f56 <__udivmoddi4+0x216>
 8000f46:	45f1      	cmp	r9, lr
 8000f48:	d205      	bcs.n	8000f56 <__udivmoddi4+0x216>
 8000f4a:	ebbe 0302 	subs.w	r3, lr, r2
 8000f4e:	eb6c 0c07 	sbc.w	ip, ip, r7
 8000f52:	3801      	subs	r0, #1
 8000f54:	46e0      	mov	r8, ip
 8000f56:	b15d      	cbz	r5, 8000f70 <__udivmoddi4+0x230>
 8000f58:	ebb9 0203 	subs.w	r2, r9, r3
 8000f5c:	eb64 0408 	sbc.w	r4, r4, r8
 8000f60:	fa04 f606 	lsl.w	r6, r4, r6
 8000f64:	fa22 f301 	lsr.w	r3, r2, r1
 8000f68:	40cc      	lsrs	r4, r1
 8000f6a:	431e      	orrs	r6, r3
 8000f6c:	e9c5 6400 	strd	r6, r4, [r5]
 8000f70:	2100      	movs	r1, #0
 8000f72:	e736      	b.n	8000de2 <__udivmoddi4+0xa2>
 8000f74:	fbb1 fcf2 	udiv	ip, r1, r2
 8000f78:	0c01      	lsrs	r1, r0, #16
 8000f7a:	4614      	mov	r4, r2
 8000f7c:	b280      	uxth	r0, r0
 8000f7e:	4696      	mov	lr, r2
 8000f80:	ea41 4108 	orr.w	r1, r1, r8, lsl #16
 8000f84:	2620      	movs	r6, #32
 8000f86:	4690      	mov	r8, r2
 8000f88:	ea40 4301 	orr.w	r3, r0, r1, lsl #16
 8000f8c:	4610      	mov	r0, r2
 8000f8e:	fbb1 f1f2 	udiv	r1, r1, r2
 8000f92:	eba3 0308 	sub.w	r3, r3, r8
 8000f96:	ea41 410c 	orr.w	r1, r1, ip, lsl #16
 8000f9a:	e74b      	b.n	8000e34 <__udivmoddi4+0xf4>
 8000f9c:	40b7      	lsls	r7, r6
 8000f9e:	f1c6 0320 	rsb	r3, r6, #32
 8000fa2:	fa01 f206 	lsl.w	r2, r1, r6
 8000fa6:	fa21 f803 	lsr.w	r8, r1, r3
 8000faa:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 8000fae:	fa20 f303 	lsr.w	r3, r0, r3
 8000fb2:	b2bc      	uxth	r4, r7
 8000fb4:	40b0      	lsls	r0, r6
 8000fb6:	4313      	orrs	r3, r2
 8000fb8:	0c02      	lsrs	r2, r0, #16
 8000fba:	0c19      	lsrs	r1, r3, #16
 8000fbc:	b280      	uxth	r0, r0
 8000fbe:	fbb8 f9fe 	udiv	r9, r8, lr
 8000fc2:	fb0e 8819 	mls	r8, lr, r9, r8
 8000fc6:	ea41 4108 	orr.w	r1, r1, r8, lsl #16
 8000fca:	fb09 f804 	mul.w	r8, r9, r4
 8000fce:	4588      	cmp	r8, r1
 8000fd0:	d951      	bls.n	8001076 <__udivmoddi4+0x336>
 8000fd2:	1879      	adds	r1, r7, r1
 8000fd4:	f109 3cff 	add.w	ip, r9, #4294967295
 8000fd8:	bf2c      	ite	cs
 8000fda:	f04f 0a01 	movcs.w	sl, #1
 8000fde:	f04f 0a00 	movcc.w	sl, #0
 8000fe2:	4588      	cmp	r8, r1
 8000fe4:	d902      	bls.n	8000fec <__udivmoddi4+0x2ac>
 8000fe6:	f1ba 0f00 	cmp.w	sl, #0
 8000fea:	d031      	beq.n	8001050 <__udivmoddi4+0x310>
 8000fec:	eba1 0108 	sub.w	r1, r1, r8
 8000ff0:	fbb1 f9fe 	udiv	r9, r1, lr
 8000ff4:	fb09 f804 	mul.w	r8, r9, r4
 8000ff8:	fb0e 1119 	mls	r1, lr, r9, r1
 8000ffc:	b29b      	uxth	r3, r3
 8000ffe:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8001002:	4543      	cmp	r3, r8
 8001004:	d235      	bcs.n	8001072 <__udivmoddi4+0x332>
 8001006:	18fb      	adds	r3, r7, r3
 8001008:	f109 31ff 	add.w	r1, r9, #4294967295
 800100c:	bf2c      	ite	cs
 800100e:	f04f 0a01 	movcs.w	sl, #1
 8001012:	f04f 0a00 	movcc.w	sl, #0
 8001016:	4543      	cmp	r3, r8
 8001018:	d2bb      	bcs.n	8000f92 <__udivmoddi4+0x252>
 800101a:	f1ba 0f00 	cmp.w	sl, #0
 800101e:	d1b8      	bne.n	8000f92 <__udivmoddi4+0x252>
 8001020:	f1a9 0102 	sub.w	r1, r9, #2
 8001024:	443b      	add	r3, r7
 8001026:	e7b4      	b.n	8000f92 <__udivmoddi4+0x252>
 8001028:	1a84      	subs	r4, r0, r2
 800102a:	eb68 0203 	sbc.w	r2, r8, r3
 800102e:	2001      	movs	r0, #1
 8001030:	4696      	mov	lr, r2
 8001032:	e6eb      	b.n	8000e0c <__udivmoddi4+0xcc>
 8001034:	443a      	add	r2, r7
 8001036:	f1a8 0802 	sub.w	r8, r8, #2
 800103a:	e72b      	b.n	8000e94 <__udivmoddi4+0x154>
 800103c:	f1ac 0c02 	sub.w	ip, ip, #2
 8001040:	443b      	add	r3, r7
 8001042:	e710      	b.n	8000e66 <__udivmoddi4+0x126>
 8001044:	3902      	subs	r1, #2
 8001046:	443b      	add	r3, r7
 8001048:	e6a9      	b.n	8000d9e <__udivmoddi4+0x5e>
 800104a:	443a      	add	r2, r7
 800104c:	3802      	subs	r0, #2
 800104e:	e6be      	b.n	8000dce <__udivmoddi4+0x8e>
 8001050:	eba7 0808 	sub.w	r8, r7, r8
 8001054:	f1a9 0c02 	sub.w	ip, r9, #2
 8001058:	4441      	add	r1, r8
 800105a:	fbb1 f9fe 	udiv	r9, r1, lr
 800105e:	fb09 f804 	mul.w	r8, r9, r4
 8001062:	e7c9      	b.n	8000ff8 <__udivmoddi4+0x2b8>
 8001064:	f1ae 0e02 	sub.w	lr, lr, #2
 8001068:	443c      	add	r4, r7
 800106a:	e744      	b.n	8000ef6 <__udivmoddi4+0x1b6>
 800106c:	3b02      	subs	r3, #2
 800106e:	443c      	add	r4, r7
 8001070:	e75e      	b.n	8000f30 <__udivmoddi4+0x1f0>
 8001072:	4649      	mov	r1, r9
 8001074:	e78d      	b.n	8000f92 <__udivmoddi4+0x252>
 8001076:	eba1 0108 	sub.w	r1, r1, r8
 800107a:	46cc      	mov	ip, r9
 800107c:	fbb1 f9fe 	udiv	r9, r1, lr
 8001080:	fb09 f804 	mul.w	r8, r9, r4
 8001084:	e7b8      	b.n	8000ff8 <__udivmoddi4+0x2b8>
 8001086:	bf00      	nop

08001088 <__aeabi_idiv0>:
 8001088:	4770      	bx	lr
 800108a:	bf00      	nop

0800108c <Reset_Handler>:

    .section	.text.Reset_Handler
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack    /* set stack pointer */
 800108c:	f8df d034 	ldr.w	sp, [pc, #52]	@ 80010c4 <LoopForever+0x2>
/* Call the clock system initialization function.*/
  bl  SystemInit
 8001090:	f00c fbf4 	bl	800d87c <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
 8001094:	2100      	movs	r1, #0
  b	LoopCopyDataInit
 8001096:	e003      	b.n	80010a0 <LoopCopyDataInit>

08001098 <CopyDataInit>:

CopyDataInit:
	ldr	r3, =_sidata
 8001098:	4b0b      	ldr	r3, [pc, #44]	@ (80010c8 <LoopForever+0x6>)
	ldr	r3, [r3, r1]
 800109a:	585b      	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
 800109c:	5043      	str	r3, [r0, r1]
	adds	r1, r1, #4
 800109e:	3104      	adds	r1, #4

080010a0 <LoopCopyDataInit>:

LoopCopyDataInit:
	ldr	r0, =_sdata
 80010a0:	480a      	ldr	r0, [pc, #40]	@ (80010cc <LoopForever+0xa>)
	ldr	r3, =_edata
 80010a2:	4b0b      	ldr	r3, [pc, #44]	@ (80010d0 <LoopForever+0xe>)
	adds	r2, r0, r1
 80010a4:	1842      	adds	r2, r0, r1
	cmp	r2, r3
 80010a6:	429a      	cmp	r2, r3
	bcc	CopyDataInit
 80010a8:	d3f6      	bcc.n	8001098 <CopyDataInit>
	ldr	r2, =_sbss
 80010aa:	4a0a      	ldr	r2, [pc, #40]	@ (80010d4 <LoopForever+0x12>)
	b	LoopFillZerobss
 80010ac:	e002      	b.n	80010b4 <LoopFillZerobss>

080010ae <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
	movs	r3, #0
 80010ae:	2300      	movs	r3, #0
	str	r3, [r2], #4
 80010b0:	f842 3b04 	str.w	r3, [r2], #4

080010b4 <LoopFillZerobss>:

LoopFillZerobss:
	ldr	r3, = _ebss
 80010b4:	4b08      	ldr	r3, [pc, #32]	@ (80010d8 <LoopForever+0x16>)
	cmp	r2, r3
 80010b6:	429a      	cmp	r2, r3
	bcc	FillZerobss
 80010b8:	d3f9      	bcc.n	80010ae <FillZerobss>

/* Call static constructors */
    bl __libc_init_array
 80010ba:	f023 f85b 	bl	8024174 <__libc_init_array>
/* Call the application's entry point.*/
	bl	main
 80010be:	f003 fe26 	bl	8004d0e <main>

080010c2 <LoopForever>:

LoopForever:
    b LoopForever
 80010c2:	e7fe      	b.n	80010c2 <LoopForever>
  ldr   sp, =_estack    /* set stack pointer */
 80010c4:	200c0000 	.word	0x200c0000
	ldr	r3, =_sidata
 80010c8:	0802acd0 	.word	0x0802acd0
	ldr	r0, =_sdata
 80010cc:	20000000 	.word	0x20000000
	ldr	r3, =_edata
 80010d0:	200003e4 	.word	0x200003e4
	ldr	r2, =_sbss
 80010d4:	200003e4 	.word	0x200003e4
	ldr	r3, = _ebss
 80010d8:	20001fea 	.word	0x20001fea

080010dc <ADC1_IRQHandler>:
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
 80010dc:	e7fe      	b.n	80010dc <ADC1_IRQHandler>
	...

080010e0 <environmental_comp_init>:

/* Device Components APIs ----------------------------------------------------*/

/* Environmental PnPL Component ----------------------------------------------*/
uint8_t environmental_comp_init(void)
{
 80010e0:	b580      	push	{r7, lr}
 80010e2:	af00      	add	r7, sp, #0
  app_model.environmental_model.comp_name = environmental_get_key();
 80010e4:	f000 f808 	bl	80010f8 <environmental_get_key>
 80010e8:	4603      	mov	r3, r0
 80010ea:	4a02      	ldr	r2, [pc, #8]	@ (80010f4 <environmental_comp_init+0x14>)
 80010ec:	6013      	str	r3, [r2, #0]

  /* USER Component initialization code */
  return 0;
 80010ee:	2300      	movs	r3, #0
}
 80010f0:	4618      	mov	r0, r3
 80010f2:	bd80      	pop	{r7, pc}
 80010f4:	20000400 	.word	0x20000400

080010f8 <environmental_get_key>:
char* environmental_get_key(void)
{
 80010f8:	b480      	push	{r7}
 80010fa:	af00      	add	r7, sp, #0
  return "environmental";
 80010fc:	4b02      	ldr	r3, [pc, #8]	@ (8001108 <environmental_get_key+0x10>)
}
 80010fe:	4618      	mov	r0, r3
 8001100:	46bd      	mov	sp, r7
 8001102:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001106:	4770      	bx	lr
 8001108:	08026848 	.word	0x08026848

0800110c <environmental_get_samplerate>:

uint8_t environmental_get_samplerate(float *value)
{
 800110c:	b480      	push	{r7}
 800110e:	b083      	sub	sp, #12
 8001110:	af00      	add	r7, sp, #0
 8001112:	6078      	str	r0, [r7, #4]
  /* USER Code */
  *value = CurrentEnvUpdateEnumValue;
 8001114:	4b07      	ldr	r3, [pc, #28]	@ (8001134 <environmental_get_samplerate+0x28>)
 8001116:	681b      	ldr	r3, [r3, #0]
 8001118:	ee07 3a90 	vmov	s15, r3
 800111c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8001120:	687b      	ldr	r3, [r7, #4]
 8001122:	edc3 7a00 	vstr	s15, [r3]
  return 0;
 8001126:	2300      	movs	r3, #0
}
 8001128:	4618      	mov	r0, r3
 800112a:	370c      	adds	r7, #12
 800112c:	46bd      	mov	sp, r7
 800112e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001132:	4770      	bx	lr
 8001134:	20000000 	.word	0x20000000

08001138 <environmental_set_samplerate>:
uint8_t environmental_set_samplerate(float value)
{
 8001138:	b580      	push	{r7, lr}
 800113a:	b084      	sub	sp, #16
 800113c:	af00      	add	r7, sp, #0
 800113e:	6078      	str	r0, [r7, #4]
  /* USER Code */
  CurrentEnvUpdateEnumValue = (int32_t) value;
 8001140:	edd7 7a01 	vldr	s15, [r7, #4]
 8001144:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8001148:	ee17 2a90 	vmov	r2, s15
 800114c:	4b26      	ldr	r3, [pc, #152]	@ (80011e8 <environmental_set_samplerate+0xb0>)
 800114e:	601a      	str	r2, [r3, #0]
  //if the Env are running, stop and restart with the new sample rate
  if(TimerEnvIsRunning) {
 8001150:	4b26      	ldr	r3, [pc, #152]	@ (80011ec <environmental_set_samplerate+0xb4>)
 8001152:	781b      	ldrb	r3, [r3, #0]
 8001154:	2b00      	cmp	r3, #0
 8001156:	d042      	beq.n	80011de <environmental_set_samplerate+0xa6>
    uint32_t uhCapture;
    /* Stop the TIM Base generation in interrupt mode */
    if(HAL_TIM_OC_Stop_IT(&TIM_CC_HANDLE, TIM_CHANNEL_2) != HAL_OK){
 8001158:	2104      	movs	r1, #4
 800115a:	4825      	ldr	r0, [pc, #148]	@ (80011f0 <environmental_set_samplerate+0xb8>)
 800115c:	f015 fcae 	bl	8016abc <HAL_TIM_OC_Stop_IT>
 8001160:	4603      	mov	r3, r0
 8001162:	2b00      	cmp	r3, #0
 8001164:	d004      	beq.n	8001170 <environmental_set_samplerate+0x38>
      /* Stopping Error */
      STBOX1_Error_Handler(STBOX1_ERROR_TIMER,__FILE__,__LINE__);
 8001166:	225c      	movs	r2, #92	@ 0x5c
 8001168:	4922      	ldr	r1, [pc, #136]	@ (80011f4 <environmental_set_samplerate+0xbc>)
 800116a:	2006      	movs	r0, #6
 800116c:	f003 fb5e 	bl	800482c <STBOX1_Error_Handler>
    }

    uhCapture = __HAL_TIM_GET_COUNTER(&TIM_CC_HANDLE);
 8001170:	4b1f      	ldr	r3, [pc, #124]	@ (80011f0 <environmental_set_samplerate+0xb8>)
 8001172:	681b      	ldr	r3, [r3, #0]
 8001174:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8001176:	60fb      	str	r3, [r7, #12]
    /* Start the TIM Base generation in interrupt mode */
    if(HAL_TIM_OC_Start_IT(&TIM_CC_HANDLE, TIM_CHANNEL_2) != HAL_OK){
 8001178:	2104      	movs	r1, #4
 800117a:	481d      	ldr	r0, [pc, #116]	@ (80011f0 <environmental_set_samplerate+0xb8>)
 800117c:	f015 fafe 	bl	801677c <HAL_TIM_OC_Start_IT>
 8001180:	4603      	mov	r3, r0
 8001182:	2b00      	cmp	r3, #0
 8001184:	d004      	beq.n	8001190 <environmental_set_samplerate+0x58>
       /* Starting Error */
       STBOX1_Error_Handler(STBOX1_ERROR_TIMER,__FILE__,__LINE__);
 8001186:	2263      	movs	r2, #99	@ 0x63
 8001188:	491a      	ldr	r1, [pc, #104]	@ (80011f4 <environmental_set_samplerate+0xbc>)
 800118a:	2006      	movs	r0, #6
 800118c:	f003 fb4e 	bl	800482c <STBOX1_Error_Handler>
    }

    /* Set the Capture Compare Register value */
    switch(CurrentEnvUpdateEnumValue) {
 8001190:	4b15      	ldr	r3, [pc, #84]	@ (80011e8 <environmental_set_samplerate+0xb0>)
 8001192:	681b      	ldr	r3, [r3, #0]
 8001194:	2b14      	cmp	r3, #20
 8001196:	d015      	beq.n	80011c4 <environmental_set_samplerate+0x8c>
 8001198:	2b14      	cmp	r3, #20
 800119a:	dc1a      	bgt.n	80011d2 <environmental_set_samplerate+0x9a>
 800119c:	2b01      	cmp	r3, #1
 800119e:	d002      	beq.n	80011a6 <environmental_set_samplerate+0x6e>
 80011a0:	2b0a      	cmp	r3, #10
 80011a2:	d008      	beq.n	80011b6 <environmental_set_samplerate+0x7e>
 80011a4:	e015      	b.n	80011d2 <environmental_set_samplerate+0x9a>
      case 1:
        __HAL_TIM_SET_COMPARE(&TIM_CC_HANDLE, TIM_CHANNEL_2, (uhCapture + 10000));
 80011a6:	4b12      	ldr	r3, [pc, #72]	@ (80011f0 <environmental_set_samplerate+0xb8>)
 80011a8:	681a      	ldr	r2, [r3, #0]
 80011aa:	68fb      	ldr	r3, [r7, #12]
 80011ac:	f503 531c 	add.w	r3, r3, #9984	@ 0x2700
 80011b0:	3310      	adds	r3, #16
 80011b2:	6393      	str	r3, [r2, #56]	@ 0x38
      break;
 80011b4:	e00d      	b.n	80011d2 <environmental_set_samplerate+0x9a>
      case 10:
        __HAL_TIM_SET_COMPARE(&TIM_CC_HANDLE, TIM_CHANNEL_2, (uhCapture + 1000));
 80011b6:	4b0e      	ldr	r3, [pc, #56]	@ (80011f0 <environmental_set_samplerate+0xb8>)
 80011b8:	681b      	ldr	r3, [r3, #0]
 80011ba:	68fa      	ldr	r2, [r7, #12]
 80011bc:	f502 727a 	add.w	r2, r2, #1000	@ 0x3e8
 80011c0:	639a      	str	r2, [r3, #56]	@ 0x38
      break;
 80011c2:	e006      	b.n	80011d2 <environmental_set_samplerate+0x9a>
      case 20:
        __HAL_TIM_SET_COMPARE(&TIM_CC_HANDLE, TIM_CHANNEL_2, (uhCapture + 500));
 80011c4:	4b0a      	ldr	r3, [pc, #40]	@ (80011f0 <environmental_set_samplerate+0xb8>)
 80011c6:	681b      	ldr	r3, [r3, #0]
 80011c8:	68fa      	ldr	r2, [r7, #12]
 80011ca:	f502 72fa 	add.w	r2, r2, #500	@ 0x1f4
 80011ce:	639a      	str	r2, [r3, #56]	@ 0x38
      break;
 80011d0:	bf00      	nop
    }
    STBOX1_PRINTF("Start Env@%ldHz\r\n",CurrentEnvUpdateEnumValue);
 80011d2:	4b05      	ldr	r3, [pc, #20]	@ (80011e8 <environmental_set_samplerate+0xb0>)
 80011d4:	681b      	ldr	r3, [r3, #0]
 80011d6:	4619      	mov	r1, r3
 80011d8:	4807      	ldr	r0, [pc, #28]	@ (80011f8 <environmental_set_samplerate+0xc0>)
 80011da:	f022 fdbf 	bl	8023d5c <iprintf>
  }
  return 0;
 80011de:	2300      	movs	r3, #0
}
 80011e0:	4618      	mov	r0, r3
 80011e2:	3710      	adds	r7, #16
 80011e4:	46bd      	mov	sp, r7
 80011e6:	bd80      	pop	{r7, pc}
 80011e8:	20000000 	.word	0x20000000
 80011ec:	200004c4 	.word	0x200004c4
 80011f0:	20000854 	.word	0x20000854
 80011f4:	08026858 	.word	0x08026858
 80011f8:	080268e0 	.word	0x080268e0

080011fc <inertial_comp_init>:

/* Inertial PnPL Component ---------------------------------------------------*/
uint8_t inertial_comp_init(void)
{
 80011fc:	b580      	push	{r7, lr}
 80011fe:	af00      	add	r7, sp, #0
  app_model.inertial_model.comp_name = inertial_get_key();
 8001200:	f000 f808 	bl	8001214 <inertial_get_key>
 8001204:	4603      	mov	r3, r0
 8001206:	4a02      	ldr	r2, [pc, #8]	@ (8001210 <inertial_comp_init+0x14>)
 8001208:	6053      	str	r3, [r2, #4]

  /* USER Component initialization code */
  return 0;
 800120a:	2300      	movs	r3, #0
}
 800120c:	4618      	mov	r0, r3
 800120e:	bd80      	pop	{r7, pc}
 8001210:	20000400 	.word	0x20000400

08001214 <inertial_get_key>:
char* inertial_get_key(void)
{
 8001214:	b480      	push	{r7}
 8001216:	af00      	add	r7, sp, #0
  return "inertial";
 8001218:	4b02      	ldr	r3, [pc, #8]	@ (8001224 <inertial_get_key+0x10>)
}
 800121a:	4618      	mov	r0, r3
 800121c:	46bd      	mov	sp, r7
 800121e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001222:	4770      	bx	lr
 8001224:	080268f4 	.word	0x080268f4

08001228 <inertial_get_samplerate>:

uint8_t inertial_get_samplerate(float *value)
{
 8001228:	b480      	push	{r7}
 800122a:	b083      	sub	sp, #12
 800122c:	af00      	add	r7, sp, #0
 800122e:	6078      	str	r0, [r7, #4]
  /* USER Code */
  *value =CurrentInerUpdateEnumValue;
 8001230:	4b07      	ldr	r3, [pc, #28]	@ (8001250 <inertial_get_samplerate+0x28>)
 8001232:	681b      	ldr	r3, [r3, #0]
 8001234:	ee07 3a90 	vmov	s15, r3
 8001238:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800123c:	687b      	ldr	r3, [r7, #4]
 800123e:	edc3 7a00 	vstr	s15, [r3]
  return 0;
 8001242:	2300      	movs	r3, #0
}
 8001244:	4618      	mov	r0, r3
 8001246:	370c      	adds	r7, #12
 8001248:	46bd      	mov	sp, r7
 800124a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800124e:	4770      	bx	lr
 8001250:	20000004 	.word	0x20000004

08001254 <inertial_get_change_acc>:
uint8_t inertial_get_change_acc(float *value)
{
 8001254:	b480      	push	{r7}
 8001256:	b083      	sub	sp, #12
 8001258:	af00      	add	r7, sp, #0
 800125a:	6078      	str	r0, [r7, #4]
  /* USER Code */
  if( CurrentAccType == STBOX1_ACC_LSM6DSV16X) {
 800125c:	4b09      	ldr	r3, [pc, #36]	@ (8001284 <inertial_get_change_acc+0x30>)
 800125e:	781b      	ldrb	r3, [r3, #0]
 8001260:	2b00      	cmp	r3, #0
 8001262:	d104      	bne.n	800126e <inertial_get_change_acc+0x1a>
    *value = 0;
 8001264:	687b      	ldr	r3, [r7, #4]
 8001266:	f04f 0200 	mov.w	r2, #0
 800126a:	601a      	str	r2, [r3, #0]
 800126c:	e003      	b.n	8001276 <inertial_get_change_acc+0x22>
  } else {
     *value = 1;
 800126e:	687b      	ldr	r3, [r7, #4]
 8001270:	f04f 527e 	mov.w	r2, #1065353216	@ 0x3f800000
 8001274:	601a      	str	r2, [r3, #0]
  }
  return 0;
 8001276:	2300      	movs	r3, #0
}
 8001278:	4618      	mov	r0, r3
 800127a:	370c      	adds	r7, #12
 800127c:	46bd      	mov	sp, r7
 800127e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001282:	4770      	bx	lr
 8001284:	20000599 	.word	0x20000599

08001288 <inertial_set_samplerate>:
uint8_t inertial_set_samplerate(float value)
{
 8001288:	b580      	push	{r7, lr}
 800128a:	b084      	sub	sp, #16
 800128c:	af00      	add	r7, sp, #0
 800128e:	6078      	str	r0, [r7, #4]
  /* USER Code */
  CurrentInerUpdateEnumValue = (int32_t) value;
 8001290:	edd7 7a01 	vldr	s15, [r7, #4]
 8001294:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8001298:	ee17 2a90 	vmov	r2, s15
 800129c:	4b26      	ldr	r3, [pc, #152]	@ (8001338 <inertial_set_samplerate+0xb0>)
 800129e:	601a      	str	r2, [r3, #0]
  //if the Inertial are running, stop and restart with the new sample rate
  if(TimerInerIsRunning) {
 80012a0:	4b26      	ldr	r3, [pc, #152]	@ (800133c <inertial_set_samplerate+0xb4>)
 80012a2:	781b      	ldrb	r3, [r3, #0]
 80012a4:	2b00      	cmp	r3, #0
 80012a6:	d041      	beq.n	800132c <inertial_set_samplerate+0xa4>
    uint32_t uhCapture;
    /* Stop the TIM Base generation in interrupt mode */
    if(HAL_TIM_OC_Stop_IT(&TIM_CC_HANDLE, TIM_CHANNEL_3) != HAL_OK){
 80012a8:	2108      	movs	r1, #8
 80012aa:	4825      	ldr	r0, [pc, #148]	@ (8001340 <inertial_set_samplerate+0xb8>)
 80012ac:	f015 fc06 	bl	8016abc <HAL_TIM_OC_Stop_IT>
 80012b0:	4603      	mov	r3, r0
 80012b2:	2b00      	cmp	r3, #0
 80012b4:	d004      	beq.n	80012c0 <inertial_set_samplerate+0x38>
      /* Stopping Error */
      STBOX1_Error_Handler(STBOX1_ERROR_TIMER,__FILE__,__LINE__);
 80012b6:	229e      	movs	r2, #158	@ 0x9e
 80012b8:	4922      	ldr	r1, [pc, #136]	@ (8001344 <inertial_set_samplerate+0xbc>)
 80012ba:	2006      	movs	r0, #6
 80012bc:	f003 fab6 	bl	800482c <STBOX1_Error_Handler>
    }

    uhCapture = __HAL_TIM_GET_COUNTER(&TIM_CC_HANDLE);
 80012c0:	4b1f      	ldr	r3, [pc, #124]	@ (8001340 <inertial_set_samplerate+0xb8>)
 80012c2:	681b      	ldr	r3, [r3, #0]
 80012c4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80012c6:	60fb      	str	r3, [r7, #12]
    /* Start the TIM Base generation in interrupt mode */
    if(HAL_TIM_OC_Start_IT(&TIM_CC_HANDLE, TIM_CHANNEL_3) != HAL_OK){
 80012c8:	2108      	movs	r1, #8
 80012ca:	481d      	ldr	r0, [pc, #116]	@ (8001340 <inertial_set_samplerate+0xb8>)
 80012cc:	f015 fa56 	bl	801677c <HAL_TIM_OC_Start_IT>
 80012d0:	4603      	mov	r3, r0
 80012d2:	2b00      	cmp	r3, #0
 80012d4:	d004      	beq.n	80012e0 <inertial_set_samplerate+0x58>
       /* Starting Error */
       STBOX1_Error_Handler(STBOX1_ERROR_TIMER,__FILE__,__LINE__);
 80012d6:	22a5      	movs	r2, #165	@ 0xa5
 80012d8:	491a      	ldr	r1, [pc, #104]	@ (8001344 <inertial_set_samplerate+0xbc>)
 80012da:	2006      	movs	r0, #6
 80012dc:	f003 faa6 	bl	800482c <STBOX1_Error_Handler>
    }

    /* Set the Capture Compare Register value */
    switch(CurrentInerUpdateEnumValue) {
 80012e0:	4b15      	ldr	r3, [pc, #84]	@ (8001338 <inertial_set_samplerate+0xb0>)
 80012e2:	681b      	ldr	r3, [r3, #0]
 80012e4:	2b1e      	cmp	r3, #30
 80012e6:	d014      	beq.n	8001312 <inertial_set_samplerate+0x8a>
 80012e8:	2b1e      	cmp	r3, #30
 80012ea:	dc19      	bgt.n	8001320 <inertial_set_samplerate+0x98>
 80012ec:	2b0a      	cmp	r3, #10
 80012ee:	d002      	beq.n	80012f6 <inertial_set_samplerate+0x6e>
 80012f0:	2b14      	cmp	r3, #20
 80012f2:	d007      	beq.n	8001304 <inertial_set_samplerate+0x7c>
 80012f4:	e014      	b.n	8001320 <inertial_set_samplerate+0x98>
      case 10:
        __HAL_TIM_SET_COMPARE(&TIM_CC_HANDLE, TIM_CHANNEL_3, (uhCapture + 1000));
 80012f6:	4b12      	ldr	r3, [pc, #72]	@ (8001340 <inertial_set_samplerate+0xb8>)
 80012f8:	681b      	ldr	r3, [r3, #0]
 80012fa:	68fa      	ldr	r2, [r7, #12]
 80012fc:	f502 727a 	add.w	r2, r2, #1000	@ 0x3e8
 8001300:	63da      	str	r2, [r3, #60]	@ 0x3c
      break;
 8001302:	e00d      	b.n	8001320 <inertial_set_samplerate+0x98>
      case 20:
        __HAL_TIM_SET_COMPARE(&TIM_CC_HANDLE, TIM_CHANNEL_3, (uhCapture + 500));
 8001304:	4b0e      	ldr	r3, [pc, #56]	@ (8001340 <inertial_set_samplerate+0xb8>)
 8001306:	681b      	ldr	r3, [r3, #0]
 8001308:	68fa      	ldr	r2, [r7, #12]
 800130a:	f502 72fa 	add.w	r2, r2, #500	@ 0x1f4
 800130e:	63da      	str	r2, [r3, #60]	@ 0x3c
      break;
 8001310:	e006      	b.n	8001320 <inertial_set_samplerate+0x98>
      case 30:
        __HAL_TIM_SET_COMPARE(&TIM_CC_HANDLE, TIM_CHANNEL_3, (uhCapture + 333));
 8001312:	4b0b      	ldr	r3, [pc, #44]	@ (8001340 <inertial_set_samplerate+0xb8>)
 8001314:	681b      	ldr	r3, [r3, #0]
 8001316:	68fa      	ldr	r2, [r7, #12]
 8001318:	f202 124d 	addw	r2, r2, #333	@ 0x14d
 800131c:	63da      	str	r2, [r3, #60]	@ 0x3c
      break;
 800131e:	bf00      	nop
    }
    STBOX1_PRINTF("Start Iner@%ldHz\r\n",CurrentInerUpdateEnumValue);
 8001320:	4b05      	ldr	r3, [pc, #20]	@ (8001338 <inertial_set_samplerate+0xb0>)
 8001322:	681b      	ldr	r3, [r3, #0]
 8001324:	4619      	mov	r1, r3
 8001326:	4808      	ldr	r0, [pc, #32]	@ (8001348 <inertial_set_samplerate+0xc0>)
 8001328:	f022 fd18 	bl	8023d5c <iprintf>
  }
  return 0;
 800132c:	2300      	movs	r3, #0
}
 800132e:	4618      	mov	r0, r3
 8001330:	3710      	adds	r7, #16
 8001332:	46bd      	mov	sp, r7
 8001334:	bd80      	pop	{r7, pc}
 8001336:	bf00      	nop
 8001338:	20000004 	.word	0x20000004
 800133c:	200004c5 	.word	0x200004c5
 8001340:	20000854 	.word	0x20000854
 8001344:	08026858 	.word	0x08026858
 8001348:	08026900 	.word	0x08026900

0800134c <inertial_set_change_acc>:
uint8_t inertial_set_change_acc(float value)
{
 800134c:	b580      	push	{r7, lr}
 800134e:	b082      	sub	sp, #8
 8001350:	af00      	add	r7, sp, #0
 8001352:	6078      	str	r0, [r7, #4]
  /* USER Code */
  if(value==0.0) {
 8001354:	edd7 7a01 	vldr	s15, [r7, #4]
 8001358:	eef5 7a40 	vcmp.f32	s15, #0.0
 800135c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001360:	d106      	bne.n	8001370 <inertial_set_change_acc+0x24>
    CurrentAccType = STBOX1_ACC_LSM6DSV16X;
 8001362:	4b09      	ldr	r3, [pc, #36]	@ (8001388 <inertial_set_change_acc+0x3c>)
 8001364:	2200      	movs	r2, #0
 8001366:	701a      	strb	r2, [r3, #0]
    STBOX1_PRINTF("Set LSM6DSV16X Like Current Acc\r\n");
 8001368:	4808      	ldr	r0, [pc, #32]	@ (800138c <inertial_set_change_acc+0x40>)
 800136a:	f022 fd5f 	bl	8023e2c <puts>
 800136e:	e005      	b.n	800137c <inertial_set_change_acc+0x30>
  } else {
    CurrentAccType = STBOX1_ACC_LIS2DU12;
 8001370:	4b05      	ldr	r3, [pc, #20]	@ (8001388 <inertial_set_change_acc+0x3c>)
 8001372:	2201      	movs	r2, #1
 8001374:	701a      	strb	r2, [r3, #0]
    STBOX1_PRINTF("Set LIS2DU12 Like Current Acc\r\n");
 8001376:	4806      	ldr	r0, [pc, #24]	@ (8001390 <inertial_set_change_acc+0x44>)
 8001378:	f022 fd58 	bl	8023e2c <puts>
  }
  return 0;
 800137c:	2300      	movs	r3, #0
}
 800137e:	4618      	mov	r0, r3
 8001380:	3708      	adds	r7, #8
 8001382:	46bd      	mov	sp, r7
 8001384:	bd80      	pop	{r7, pc}
 8001386:	bf00      	nop
 8001388:	20000599 	.word	0x20000599
 800138c:	08026914 	.word	0x08026914
 8001390:	08026938 	.word	0x08026938

08001394 <control_comp_init>:

/* Control PnPL Component ----------------------------------------------------*/
uint8_t control_comp_init(void)
{
 8001394:	b580      	push	{r7, lr}
 8001396:	af00      	add	r7, sp, #0
  app_model.control_model.comp_name = control_get_key();
 8001398:	f000 f808 	bl	80013ac <control_get_key>
 800139c:	4603      	mov	r3, r0
 800139e:	4a02      	ldr	r2, [pc, #8]	@ (80013a8 <control_comp_init+0x14>)
 80013a0:	6093      	str	r3, [r2, #8]

  /* USER Component initialization code */
  return 0;
 80013a2:	2300      	movs	r3, #0
}
 80013a4:	4618      	mov	r0, r3
 80013a6:	bd80      	pop	{r7, pc}
 80013a8:	20000400 	.word	0x20000400

080013ac <control_get_key>:
char* control_get_key(void)
{
 80013ac:	b480      	push	{r7}
 80013ae:	af00      	add	r7, sp, #0
  return "control";
 80013b0:	4b02      	ldr	r3, [pc, #8]	@ (80013bc <control_get_key+0x10>)
}
 80013b2:	4618      	mov	r0, r3
 80013b4:	46bd      	mov	sp, r7
 80013b6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80013ba:	4770      	bx	lr
 80013bc:	08026958 	.word	0x08026958

080013c0 <control_get_fw_status>:

uint8_t control_get_fw_status(char **value)
{
 80013c0:	b580      	push	{r7, lr}
 80013c2:	b082      	sub	sp, #8
 80013c4:	af00      	add	r7, sp, #0
 80013c6:	6078      	str	r0, [r7, #4]
  /* USER Code */
  static char FwName[8];

  if(TimerEnvIsRunning | TimerInerIsRunning) {
 80013c8:	4b0c      	ldr	r3, [pc, #48]	@ (80013fc <control_get_fw_status+0x3c>)
 80013ca:	781a      	ldrb	r2, [r3, #0]
 80013cc:	4b0c      	ldr	r3, [pc, #48]	@ (8001400 <control_get_fw_status+0x40>)
 80013ce:	781b      	ldrb	r3, [r3, #0]
 80013d0:	4313      	orrs	r3, r2
 80013d2:	b2db      	uxtb	r3, r3
 80013d4:	2b00      	cmp	r3, #0
 80013d6:	d004      	beq.n	80013e2 <control_get_fw_status+0x22>
    sprintf(FwName,"Running");
 80013d8:	490a      	ldr	r1, [pc, #40]	@ (8001404 <control_get_fw_status+0x44>)
 80013da:	480b      	ldr	r0, [pc, #44]	@ (8001408 <control_get_fw_status+0x48>)
 80013dc:	f022 fd2e 	bl	8023e3c <siprintf>
 80013e0:	e003      	b.n	80013ea <control_get_fw_status+0x2a>
  } else {
     sprintf(FwName,"Paused");
 80013e2:	490a      	ldr	r1, [pc, #40]	@ (800140c <control_get_fw_status+0x4c>)
 80013e4:	4808      	ldr	r0, [pc, #32]	@ (8001408 <control_get_fw_status+0x48>)
 80013e6:	f022 fd29 	bl	8023e3c <siprintf>
  }
  *value = FwName;
 80013ea:	687b      	ldr	r3, [r7, #4]
 80013ec:	4a06      	ldr	r2, [pc, #24]	@ (8001408 <control_get_fw_status+0x48>)
 80013ee:	601a      	str	r2, [r3, #0]
  return 0;
 80013f0:	2300      	movs	r3, #0
}
 80013f2:	4618      	mov	r0, r3
 80013f4:	3708      	adds	r7, #8
 80013f6:	46bd      	mov	sp, r7
 80013f8:	bd80      	pop	{r7, pc}
 80013fa:	bf00      	nop
 80013fc:	200004c4 	.word	0x200004c4
 8001400:	200004c5 	.word	0x200004c5
 8001404:	08026960 	.word	0x08026960
 8001408:	20000410 	.word	0x20000410
 800140c:	08026968 	.word	0x08026968

08001410 <control_pause_resume>:
uint8_t control_pause_resume(IControl_t *ifn)
{
 8001410:	b580      	push	{r7, lr}
 8001412:	b098      	sub	sp, #96	@ 0x60
 8001414:	af00      	add	r7, sp, #0
 8001416:	6078      	str	r0, [r7, #4]
  //IControl_pause_resume(ifn);
  if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_ENV))  {
 8001418:	4b43      	ldr	r3, [pc, #268]	@ (8001528 <control_pause_resume+0x118>)
 800141a:	681b      	ldr	r3, [r3, #0]
 800141c:	f003 0301 	and.w	r3, r3, #1
 8001420:	b2db      	uxtb	r3, r3
 8001422:	2b00      	cmp	r3, #0
 8001424:	d070      	beq.n	8001508 <control_pause_resume+0xf8>
    if(TimerEnvIsRunning) {
 8001426:	4b41      	ldr	r3, [pc, #260]	@ (800152c <control_pause_resume+0x11c>)
 8001428:	781b      	ldrb	r3, [r3, #0]
 800142a:	2b00      	cmp	r3, #0
 800142c:	d012      	beq.n	8001454 <control_pause_resume+0x44>
      /* Stop the TIM Base generation in interrupt mode */
      if(HAL_TIM_OC_Stop_IT(&TIM_CC_HANDLE, TIM_CHANNEL_2) != HAL_OK){
 800142e:	2104      	movs	r1, #4
 8001430:	483f      	ldr	r0, [pc, #252]	@ (8001530 <control_pause_resume+0x120>)
 8001432:	f015 fb43 	bl	8016abc <HAL_TIM_OC_Stop_IT>
 8001436:	4603      	mov	r3, r0
 8001438:	2b00      	cmp	r3, #0
 800143a:	d004      	beq.n	8001446 <control_pause_resume+0x36>
        /* Stopping Error */
        STBOX1_Error_Handler(STBOX1_ERROR_TIMER,__FILE__,__LINE__);
 800143c:	22e7      	movs	r2, #231	@ 0xe7
 800143e:	493d      	ldr	r1, [pc, #244]	@ (8001534 <control_pause_resume+0x124>)
 8001440:	2006      	movs	r0, #6
 8001442:	f003 f9f3 	bl	800482c <STBOX1_Error_Handler>
      }
      STBOX1_PRINTF("Stop Env\r\n");
 8001446:	483c      	ldr	r0, [pc, #240]	@ (8001538 <control_pause_resume+0x128>)
 8001448:	f022 fcf0 	bl	8023e2c <puts>
      TimerEnvIsRunning=0;
 800144c:	4b37      	ldr	r3, [pc, #220]	@ (800152c <control_pause_resume+0x11c>)
 800144e:	2200      	movs	r2, #0
 8001450:	701a      	strb	r2, [r3, #0]
 8001452:	e039      	b.n	80014c8 <control_pause_resume+0xb8>
    } else {
      uint32_t uhCapture = __HAL_TIM_GET_COUNTER(&TIM_CC_HANDLE);
 8001454:	4b36      	ldr	r3, [pc, #216]	@ (8001530 <control_pause_resume+0x120>)
 8001456:	681b      	ldr	r3, [r3, #0]
 8001458:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800145a:	65fb      	str	r3, [r7, #92]	@ 0x5c
      /* Start the TIM Base generation in interrupt mode */
      if(HAL_TIM_OC_Start_IT(&TIM_CC_HANDLE, TIM_CHANNEL_2) != HAL_OK){
 800145c:	2104      	movs	r1, #4
 800145e:	4834      	ldr	r0, [pc, #208]	@ (8001530 <control_pause_resume+0x120>)
 8001460:	f015 f98c 	bl	801677c <HAL_TIM_OC_Start_IT>
 8001464:	4603      	mov	r3, r0
 8001466:	2b00      	cmp	r3, #0
 8001468:	d004      	beq.n	8001474 <control_pause_resume+0x64>
        /* Starting Error */
        STBOX1_Error_Handler(STBOX1_ERROR_TIMER,__FILE__,__LINE__);
 800146a:	22f0      	movs	r2, #240	@ 0xf0
 800146c:	4931      	ldr	r1, [pc, #196]	@ (8001534 <control_pause_resume+0x124>)
 800146e:	2006      	movs	r0, #6
 8001470:	f003 f9dc 	bl	800482c <STBOX1_Error_Handler>
      }

      /* Set the Capture Compare Register value */
      switch(CurrentEnvUpdateEnumValue) {
 8001474:	4b31      	ldr	r3, [pc, #196]	@ (800153c <control_pause_resume+0x12c>)
 8001476:	681b      	ldr	r3, [r3, #0]
 8001478:	2b14      	cmp	r3, #20
 800147a:	d015      	beq.n	80014a8 <control_pause_resume+0x98>
 800147c:	2b14      	cmp	r3, #20
 800147e:	dc1a      	bgt.n	80014b6 <control_pause_resume+0xa6>
 8001480:	2b01      	cmp	r3, #1
 8001482:	d002      	beq.n	800148a <control_pause_resume+0x7a>
 8001484:	2b0a      	cmp	r3, #10
 8001486:	d008      	beq.n	800149a <control_pause_resume+0x8a>
 8001488:	e015      	b.n	80014b6 <control_pause_resume+0xa6>
        case 1:
          __HAL_TIM_SET_COMPARE(&TIM_CC_HANDLE, TIM_CHANNEL_2, (uhCapture + 10000));
 800148a:	4b29      	ldr	r3, [pc, #164]	@ (8001530 <control_pause_resume+0x120>)
 800148c:	681a      	ldr	r2, [r3, #0]
 800148e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8001490:	f503 531c 	add.w	r3, r3, #9984	@ 0x2700
 8001494:	3310      	adds	r3, #16
 8001496:	6393      	str	r3, [r2, #56]	@ 0x38
        break;
 8001498:	e00d      	b.n	80014b6 <control_pause_resume+0xa6>
        case 10:
          __HAL_TIM_SET_COMPARE(&TIM_CC_HANDLE, TIM_CHANNEL_2, (uhCapture + 1000));
 800149a:	4b25      	ldr	r3, [pc, #148]	@ (8001530 <control_pause_resume+0x120>)
 800149c:	681b      	ldr	r3, [r3, #0]
 800149e:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 80014a0:	f502 727a 	add.w	r2, r2, #1000	@ 0x3e8
 80014a4:	639a      	str	r2, [r3, #56]	@ 0x38
        break;
 80014a6:	e006      	b.n	80014b6 <control_pause_resume+0xa6>
        case 20:
          __HAL_TIM_SET_COMPARE(&TIM_CC_HANDLE, TIM_CHANNEL_2, (uhCapture + 500));
 80014a8:	4b21      	ldr	r3, [pc, #132]	@ (8001530 <control_pause_resume+0x120>)
 80014aa:	681b      	ldr	r3, [r3, #0]
 80014ac:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 80014ae:	f502 72fa 	add.w	r2, r2, #500	@ 0x1f4
 80014b2:	639a      	str	r2, [r3, #56]	@ 0x38
        break;
 80014b4:	bf00      	nop
      }
      STBOX1_PRINTF("Start Env@%ldHz\r\n",CurrentEnvUpdateEnumValue);
 80014b6:	4b21      	ldr	r3, [pc, #132]	@ (800153c <control_pause_resume+0x12c>)
 80014b8:	681b      	ldr	r3, [r3, #0]
 80014ba:	4619      	mov	r1, r3
 80014bc:	4820      	ldr	r0, [pc, #128]	@ (8001540 <control_pause_resume+0x130>)
 80014be:	f022 fc4d 	bl	8023d5c <iprintf>
      TimerEnvIsRunning=1;
 80014c2:	4b1a      	ldr	r3, [pc, #104]	@ (800152c <control_pause_resume+0x11c>)
 80014c4:	2201      	movs	r2, #1
 80014c6:	701a      	strb	r2, [r3, #0]
        PnPLCommand_t PnPLCommand;
        char *SerializedJSON;
        uint32_t size;

        //sprintf(PnPLCommand.comp_name,"%s",Control_get_key());
        sprintf(PnPLCommand.comp_name,"%s","all");
 80014c8:	f107 030c 	add.w	r3, r7, #12
 80014cc:	3301      	adds	r3, #1
 80014ce:	4a1d      	ldr	r2, [pc, #116]	@ (8001544 <control_pause_resume+0x134>)
 80014d0:	491d      	ldr	r1, [pc, #116]	@ (8001548 <control_pause_resume+0x138>)
 80014d2:	4618      	mov	r0, r3
 80014d4:	f022 fcb2 	bl	8023e3c <siprintf>
        PnPLCommand.comm_type = PNPL_CMD_GET;
 80014d8:	2310      	movs	r3, #16
 80014da:	733b      	strb	r3, [r7, #12]

        PnPLSerializeResponse(&PnPLCommand,&SerializedJSON,&size,0);
 80014dc:	f107 0254 	add.w	r2, r7, #84	@ 0x54
 80014e0:	f107 0158 	add.w	r1, r7, #88	@ 0x58
 80014e4:	f107 000c 	add.w	r0, r7, #12
 80014e8:	2300      	movs	r3, #0
 80014ea:	f01b fc51 	bl	801cd90 <PnPLSerializeResponse>

        STBOX1_PRINTF("--> <%.*s>\r\n",size,SerializedJSON);
 80014ee:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80014f0:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 80014f2:	4619      	mov	r1, r3
 80014f4:	4815      	ldr	r0, [pc, #84]	@ (800154c <control_pause_resume+0x13c>)
 80014f6:	f022 fc31 	bl	8023d5c <iprintf>

        PnPLikeEncapsulate((uint8_t*) SerializedJSON,size);
 80014fa:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80014fc:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 80014fe:	4611      	mov	r1, r2
 8001500:	4618      	mov	r0, r3
 8001502:	f000 fc7b 	bl	8001dfc <PnPLikeEncapsulate>
 8001506:	e00a      	b.n	800151e <control_pause_resume+0x10e>
      }

  } else if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_ACC_GYRO_MAG)) {
 8001508:	4b07      	ldr	r3, [pc, #28]	@ (8001528 <control_pause_resume+0x118>)
 800150a:	681b      	ldr	r3, [r3, #0]
 800150c:	085b      	lsrs	r3, r3, #1
 800150e:	f003 0301 	and.w	r3, r3, #1
 8001512:	b2db      	uxtb	r3, r3
 8001514:	2b00      	cmp	r3, #0
 8001516:	d002      	beq.n	800151e <control_pause_resume+0x10e>
    STBOX1_PRINTF("The pause/resume command has not effect in this situation\r\n");
 8001518:	480d      	ldr	r0, [pc, #52]	@ (8001550 <control_pause_resume+0x140>)
 800151a:	f022 fc87 	bl	8023e2c <puts>
  }
  return 0;
 800151e:	2300      	movs	r3, #0
}
 8001520:	4618      	mov	r0, r3
 8001522:	3760      	adds	r7, #96	@ 0x60
 8001524:	46bd      	mov	sp, r7
 8001526:	bd80      	pop	{r7, pc}
 8001528:	200004bc 	.word	0x200004bc
 800152c:	200004c4 	.word	0x200004c4
 8001530:	20000854 	.word	0x20000854
 8001534:	08026858 	.word	0x08026858
 8001538:	08026970 	.word	0x08026970
 800153c:	20000000 	.word	0x20000000
 8001540:	080268e0 	.word	0x080268e0
 8001544:	0802697c 	.word	0x0802697c
 8001548:	08026980 	.word	0x08026980
 800154c:	08026984 	.word	0x08026984
 8001550:	08026994 	.word	0x08026994

08001554 <configuration_comp_init>:

/* Configuration PnPL Component ----------------------------------------------*/
uint8_t configuration_comp_init(void)
{
 8001554:	b580      	push	{r7, lr}
 8001556:	af00      	add	r7, sp, #0
  app_model.configuration_model.comp_name = configuration_get_key();
 8001558:	f000 f808 	bl	800156c <configuration_get_key>
 800155c:	4603      	mov	r3, r0
 800155e:	4a02      	ldr	r2, [pc, #8]	@ (8001568 <configuration_comp_init+0x14>)
 8001560:	60d3      	str	r3, [r2, #12]

  /* USER Component initialization code */
  return 0;
 8001562:	2300      	movs	r3, #0
}
 8001564:	4618      	mov	r0, r3
 8001566:	bd80      	pop	{r7, pc}
 8001568:	20000400 	.word	0x20000400

0800156c <configuration_get_key>:
char* configuration_get_key(void)
{
 800156c:	b480      	push	{r7}
 800156e:	af00      	add	r7, sp, #0
  return "configuration";
 8001570:	4b02      	ldr	r3, [pc, #8]	@ (800157c <configuration_get_key+0x10>)
}
 8001572:	4618      	mov	r0, r3
 8001574:	46bd      	mov	sp, r7
 8001576:	f85d 7b04 	ldr.w	r7, [sp], #4
 800157a:	4770      	bx	lr
 800157c:	080269d0 	.word	0x080269d0

08001580 <configuration_get_version_fw>:

uint8_t configuration_get_version_fw(char **value)
{
 8001580:	b580      	push	{r7, lr}
 8001582:	b086      	sub	sp, #24
 8001584:	af04      	add	r7, sp, #16
 8001586:	6078      	str	r0, [r7, #4]
  /* USER Code */
  static char FwName[32];
   sprintf(FwName,"%s_%s_%c.%c.%c",
 8001588:	2330      	movs	r3, #48	@ 0x30
 800158a:	9302      	str	r3, [sp, #8]
 800158c:	2330      	movs	r3, #48	@ 0x30
 800158e:	9301      	str	r3, [sp, #4]
 8001590:	2332      	movs	r3, #50	@ 0x32
 8001592:	9300      	str	r3, [sp, #0]
 8001594:	4b06      	ldr	r3, [pc, #24]	@ (80015b0 <configuration_get_version_fw+0x30>)
 8001596:	4a07      	ldr	r2, [pc, #28]	@ (80015b4 <configuration_get_version_fw+0x34>)
 8001598:	4907      	ldr	r1, [pc, #28]	@ (80015b8 <configuration_get_version_fw+0x38>)
 800159a:	4808      	ldr	r0, [pc, #32]	@ (80015bc <configuration_get_version_fw+0x3c>)
 800159c:	f022 fc4e 	bl	8023e3c <siprintf>
                  "U585",
                  STBOX1_PACKAGENAME,
                  STBOX1_VERSION_MAJOR,
                  STBOX1_VERSION_MINOR,
                  STBOX1_VERSION_PATCH);
   *value = FwName;
 80015a0:	687b      	ldr	r3, [r7, #4]
 80015a2:	4a06      	ldr	r2, [pc, #24]	@ (80015bc <configuration_get_version_fw+0x3c>)
 80015a4:	601a      	str	r2, [r3, #0]
  return 0;
 80015a6:	2300      	movs	r3, #0
}
 80015a8:	4618      	mov	r0, r3
 80015aa:	3708      	adds	r7, #8
 80015ac:	46bd      	mov	sp, r7
 80015ae:	bd80      	pop	{r7, pc}
 80015b0:	080269e0 	.word	0x080269e0
 80015b4:	080269f0 	.word	0x080269f0
 80015b8:	080269f8 	.word	0x080269f8
 80015bc:	20000418 	.word	0x20000418

080015c0 <configuration_get_board_name>:
uint8_t configuration_get_board_name(char **value)
{
 80015c0:	b580      	push	{r7, lr}
 80015c2:	b082      	sub	sp, #8
 80015c4:	af00      	add	r7, sp, #0
 80015c6:	6078      	str	r0, [r7, #4]
  /* USER Code */
  static char PackageName[16];
  sprintf(PackageName,"%s",BLE_StackValue.BoardName);
 80015c8:	4a06      	ldr	r2, [pc, #24]	@ (80015e4 <configuration_get_board_name+0x24>)
 80015ca:	4907      	ldr	r1, [pc, #28]	@ (80015e8 <configuration_get_board_name+0x28>)
 80015cc:	4807      	ldr	r0, [pc, #28]	@ (80015ec <configuration_get_board_name+0x2c>)
 80015ce:	f022 fc35 	bl	8023e3c <siprintf>
  *value = PackageName;
 80015d2:	687b      	ldr	r3, [r7, #4]
 80015d4:	4a05      	ldr	r2, [pc, #20]	@ (80015ec <configuration_get_board_name+0x2c>)
 80015d6:	601a      	str	r2, [r3, #0]
  return 0;
 80015d8:	2300      	movs	r3, #0
}
 80015da:	4618      	mov	r0, r3
 80015dc:	3708      	adds	r7, #8
 80015de:	46bd      	mov	sp, r7
 80015e0:	bd80      	pop	{r7, pc}
 80015e2:	bf00      	nop
 80015e4:	20001b19 	.word	0x20001b19
 80015e8:	08026980 	.word	0x08026980
 80015ec:	20000438 	.word	0x20000438

080015f0 <configuration_set_board_name>:
uint8_t configuration_set_board_name(const char *value)
{
 80015f0:	b580      	push	{r7, lr}
 80015f2:	b088      	sub	sp, #32
 80015f4:	af00      	add	r7, sp, #0
 80015f6:	6078      	str	r0, [r7, #4]
  /* USER Code */
  char PackageName[16];
  int NumberChar =  sprintf(PackageName,"%s",value);
 80015f8:	f107 030c 	add.w	r3, r7, #12
 80015fc:	687a      	ldr	r2, [r7, #4]
 80015fe:	490f      	ldr	r1, [pc, #60]	@ (800163c <configuration_set_board_name+0x4c>)
 8001600:	4618      	mov	r0, r3
 8001602:	f022 fc1b 	bl	8023e3c <siprintf>
 8001606:	61f8      	str	r0, [r7, #28]
  //Fill with spaces...
  for(;NumberChar<7;NumberChar++) {
 8001608:	e008      	b.n	800161c <configuration_set_board_name+0x2c>
    PackageName[NumberChar]=' ';
 800160a:	f107 020c 	add.w	r2, r7, #12
 800160e:	69fb      	ldr	r3, [r7, #28]
 8001610:	4413      	add	r3, r2
 8001612:	2220      	movs	r2, #32
 8001614:	701a      	strb	r2, [r3, #0]
  for(;NumberChar<7;NumberChar++) {
 8001616:	69fb      	ldr	r3, [r7, #28]
 8001618:	3301      	adds	r3, #1
 800161a:	61fb      	str	r3, [r7, #28]
 800161c:	69fb      	ldr	r3, [r7, #28]
 800161e:	2b06      	cmp	r3, #6
 8001620:	ddf3      	ble.n	800160a <configuration_set_board_name+0x1a>
  }
  //Termination
  PackageName[7] ='\0';
 8001622:	2300      	movs	r3, #0
 8001624:	74fb      	strb	r3, [r7, #19]

  ExtConfigSetNameCommandCallback((uint8_t*) PackageName);
 8001626:	f107 030c 	add.w	r3, r7, #12
 800162a:	4618      	mov	r0, r3
 800162c:	f001 f91e 	bl	800286c <ExtConfigSetNameCommandCallback>
  return 0;
 8001630:	2300      	movs	r3, #0
}
 8001632:	4618      	mov	r0, r3
 8001634:	3720      	adds	r7, #32
 8001636:	46bd      	mov	sp, r7
 8001638:	bd80      	pop	{r7, pc}
 800163a:	bf00      	nop
 800163c:	08026980 	.word	0x08026980

08001640 <DeviceInformation_comp_init>:

/* Device Information PnPL Component -----------------------------------------*/
uint8_t DeviceInformation_comp_init(void)
{
 8001640:	b480      	push	{r7}
 8001642:	af00      	add	r7, sp, #0

  /* USER Component initialization code */
  return 0;
 8001644:	2300      	movs	r3, #0
}
 8001646:	4618      	mov	r0, r3
 8001648:	46bd      	mov	sp, r7
 800164a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800164e:	4770      	bx	lr

08001650 <DeviceInformation_get_key>:
char* DeviceInformation_get_key(void)
{
 8001650:	b480      	push	{r7}
 8001652:	af00      	add	r7, sp, #0
  return "DeviceInformation";
 8001654:	4b02      	ldr	r3, [pc, #8]	@ (8001660 <DeviceInformation_get_key+0x10>)
}
 8001656:	4618      	mov	r0, r3
 8001658:	46bd      	mov	sp, r7
 800165a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800165e:	4770      	bx	lr
 8001660:	08026a08 	.word	0x08026a08

08001664 <DeviceInformation_get_manufacturer>:

uint8_t DeviceInformation_get_manufacturer(char **value)
{
 8001664:	b580      	push	{r7, lr}
 8001666:	b082      	sub	sp, #8
 8001668:	af00      	add	r7, sp, #0
 800166a:	6078      	str	r0, [r7, #4]
  /* USER Code */
  static char StringValue[24];
  sprintf(StringValue,"STMicroelectronics");
 800166c:	4905      	ldr	r1, [pc, #20]	@ (8001684 <DeviceInformation_get_manufacturer+0x20>)
 800166e:	4806      	ldr	r0, [pc, #24]	@ (8001688 <DeviceInformation_get_manufacturer+0x24>)
 8001670:	f022 fbe4 	bl	8023e3c <siprintf>
  *value = StringValue;
 8001674:	687b      	ldr	r3, [r7, #4]
 8001676:	4a04      	ldr	r2, [pc, #16]	@ (8001688 <DeviceInformation_get_manufacturer+0x24>)
 8001678:	601a      	str	r2, [r3, #0]
  return 0;
 800167a:	2300      	movs	r3, #0
}
 800167c:	4618      	mov	r0, r3
 800167e:	3708      	adds	r7, #8
 8001680:	46bd      	mov	sp, r7
 8001682:	bd80      	pop	{r7, pc}
 8001684:	08026a1c 	.word	0x08026a1c
 8001688:	20000448 	.word	0x20000448

0800168c <DeviceInformation_get_model>:

uint8_t DeviceInformation_get_model(char **value)
{
 800168c:	b580      	push	{r7, lr}
 800168e:	b082      	sub	sp, #8
 8001690:	af00      	add	r7, sp, #0
 8001692:	6078      	str	r0, [r7, #4]
  /* USER Code */
  static char StringValue[24];
  sprintf(StringValue,"steval_stbox_pro");
 8001694:	4905      	ldr	r1, [pc, #20]	@ (80016ac <DeviceInformation_get_model+0x20>)
 8001696:	4806      	ldr	r0, [pc, #24]	@ (80016b0 <DeviceInformation_get_model+0x24>)
 8001698:	f022 fbd0 	bl	8023e3c <siprintf>
  *value = StringValue;
 800169c:	687b      	ldr	r3, [r7, #4]
 800169e:	4a04      	ldr	r2, [pc, #16]	@ (80016b0 <DeviceInformation_get_model+0x24>)
 80016a0:	601a      	str	r2, [r3, #0]
  return 0;
 80016a2:	2300      	movs	r3, #0
}
 80016a4:	4618      	mov	r0, r3
 80016a6:	3708      	adds	r7, #8
 80016a8:	46bd      	mov	sp, r7
 80016aa:	bd80      	pop	{r7, pc}
 80016ac:	08026a30 	.word	0x08026a30
 80016b0:	20000460 	.word	0x20000460

080016b4 <DeviceInformation_get_swVersion>:

uint8_t DeviceInformation_get_swVersion(char **value)
{
 80016b4:	b580      	push	{r7, lr}
 80016b6:	b086      	sub	sp, #24
 80016b8:	af04      	add	r7, sp, #16
 80016ba:	6078      	str	r0, [r7, #4]
  /* USER Code */
  static char FwName[32];
  sprintf(FwName,"%s_%s_%c.%c.%c",
 80016bc:	2330      	movs	r3, #48	@ 0x30
 80016be:	9302      	str	r3, [sp, #8]
 80016c0:	2330      	movs	r3, #48	@ 0x30
 80016c2:	9301      	str	r3, [sp, #4]
 80016c4:	2332      	movs	r3, #50	@ 0x32
 80016c6:	9300      	str	r3, [sp, #0]
 80016c8:	4b06      	ldr	r3, [pc, #24]	@ (80016e4 <DeviceInformation_get_swVersion+0x30>)
 80016ca:	4a07      	ldr	r2, [pc, #28]	@ (80016e8 <DeviceInformation_get_swVersion+0x34>)
 80016cc:	4907      	ldr	r1, [pc, #28]	@ (80016ec <DeviceInformation_get_swVersion+0x38>)
 80016ce:	4808      	ldr	r0, [pc, #32]	@ (80016f0 <DeviceInformation_get_swVersion+0x3c>)
 80016d0:	f022 fbb4 	bl	8023e3c <siprintf>
                "U585",
                STBOX1_PACKAGENAME,
                STBOX1_VERSION_MAJOR,
                STBOX1_VERSION_MINOR,
                STBOX1_VERSION_PATCH);
  *value = FwName;
 80016d4:	687b      	ldr	r3, [r7, #4]
 80016d6:	4a06      	ldr	r2, [pc, #24]	@ (80016f0 <DeviceInformation_get_swVersion+0x3c>)
 80016d8:	601a      	str	r2, [r3, #0]
  return 0;
 80016da:	2300      	movs	r3, #0
}
 80016dc:	4618      	mov	r0, r3
 80016de:	3708      	adds	r7, #8
 80016e0:	46bd      	mov	sp, r7
 80016e2:	bd80      	pop	{r7, pc}
 80016e4:	080269e0 	.word	0x080269e0
 80016e8:	080269f0 	.word	0x080269f0
 80016ec:	080269f8 	.word	0x080269f8
 80016f0:	20000478 	.word	0x20000478

080016f4 <DeviceInformation_get_osName>:
uint8_t DeviceInformation_get_osName(char **value)
{
 80016f4:	b580      	push	{r7, lr}
 80016f6:	b082      	sub	sp, #8
 80016f8:	af00      	add	r7, sp, #0
 80016fa:	6078      	str	r0, [r7, #4]
  /* USER Code */
  static char StringValue[8];
  sprintf(StringValue,"None");
 80016fc:	4905      	ldr	r1, [pc, #20]	@ (8001714 <DeviceInformation_get_osName+0x20>)
 80016fe:	4806      	ldr	r0, [pc, #24]	@ (8001718 <DeviceInformation_get_osName+0x24>)
 8001700:	f022 fb9c 	bl	8023e3c <siprintf>
  *value = StringValue;
 8001704:	687b      	ldr	r3, [r7, #4]
 8001706:	4a04      	ldr	r2, [pc, #16]	@ (8001718 <DeviceInformation_get_osName+0x24>)
 8001708:	601a      	str	r2, [r3, #0]
  return 0;
 800170a:	2300      	movs	r3, #0
}
 800170c:	4618      	mov	r0, r3
 800170e:	3708      	adds	r7, #8
 8001710:	46bd      	mov	sp, r7
 8001712:	bd80      	pop	{r7, pc}
 8001714:	08026a44 	.word	0x08026a44
 8001718:	20000498 	.word	0x20000498

0800171c <DeviceInformation_get_processorArchitecture>:
uint8_t DeviceInformation_get_processorArchitecture(char **value)
{
 800171c:	b580      	push	{r7, lr}
 800171e:	b082      	sub	sp, #8
 8001720:	af00      	add	r7, sp, #0
 8001722:	6078      	str	r0, [r7, #4]
  /* USER Code */
  static char StringValue[4];
  sprintf(StringValue,"ARM");
 8001724:	4905      	ldr	r1, [pc, #20]	@ (800173c <DeviceInformation_get_processorArchitecture+0x20>)
 8001726:	4806      	ldr	r0, [pc, #24]	@ (8001740 <DeviceInformation_get_processorArchitecture+0x24>)
 8001728:	f022 fb88 	bl	8023e3c <siprintf>
  *value = StringValue;
 800172c:	687b      	ldr	r3, [r7, #4]
 800172e:	4a04      	ldr	r2, [pc, #16]	@ (8001740 <DeviceInformation_get_processorArchitecture+0x24>)
 8001730:	601a      	str	r2, [r3, #0]
  return 0;
 8001732:	2300      	movs	r3, #0
}
 8001734:	4618      	mov	r0, r3
 8001736:	3708      	adds	r7, #8
 8001738:	46bd      	mov	sp, r7
 800173a:	bd80      	pop	{r7, pc}
 800173c:	08026a4c 	.word	0x08026a4c
 8001740:	200004a0 	.word	0x200004a0

08001744 <DeviceInformation_get_processorManufacturer>:
uint8_t DeviceInformation_get_processorManufacturer(char **value)
{
 8001744:	b580      	push	{r7, lr}
 8001746:	b082      	sub	sp, #8
 8001748:	af00      	add	r7, sp, #0
 800174a:	6078      	str	r0, [r7, #4]
  /* USER Code */
  static char StringValue[4];
  sprintf(StringValue,"ARM");
 800174c:	4905      	ldr	r1, [pc, #20]	@ (8001764 <DeviceInformation_get_processorManufacturer+0x20>)
 800174e:	4806      	ldr	r0, [pc, #24]	@ (8001768 <DeviceInformation_get_processorManufacturer+0x24>)
 8001750:	f022 fb74 	bl	8023e3c <siprintf>
  *value = StringValue;
 8001754:	687b      	ldr	r3, [r7, #4]
 8001756:	4a04      	ldr	r2, [pc, #16]	@ (8001768 <DeviceInformation_get_processorManufacturer+0x24>)
 8001758:	601a      	str	r2, [r3, #0]
  return 0;
 800175a:	2300      	movs	r3, #0
}
 800175c:	4618      	mov	r0, r3
 800175e:	3708      	adds	r7, #8
 8001760:	46bd      	mov	sp, r7
 8001762:	bd80      	pop	{r7, pc}
 8001764:	08026a4c 	.word	0x08026a4c
 8001768:	200004a4 	.word	0x200004a4

0800176c <DeviceInformation_get_totalStorage>:
uint8_t DeviceInformation_get_totalStorage(float *value)
{
 800176c:	b480      	push	{r7}
 800176e:	b083      	sub	sp, #12
 8001770:	af00      	add	r7, sp, #0
 8001772:	6078      	str	r0, [r7, #4]
  /* USER Code */
  *value =2097151;
 8001774:	687b      	ldr	r3, [r7, #4]
 8001776:	4a04      	ldr	r2, [pc, #16]	@ (8001788 <DeviceInformation_get_totalStorage+0x1c>)
 8001778:	601a      	str	r2, [r3, #0]
  return 0;
 800177a:	2300      	movs	r3, #0
}
 800177c:	4618      	mov	r0, r3
 800177e:	370c      	adds	r7, #12
 8001780:	46bd      	mov	sp, r7
 8001782:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001786:	4770      	bx	lr
 8001788:	49fffff8 	.word	0x49fffff8

0800178c <DeviceInformation_get_totalMemory>:
uint8_t DeviceInformation_get_totalMemory(float *value)
{
 800178c:	b480      	push	{r7}
 800178e:	b083      	sub	sp, #12
 8001790:	af00      	add	r7, sp, #0
 8001792:	6078      	str	r0, [r7, #4]
  /* USER Code */
  *value=786431;
 8001794:	687b      	ldr	r3, [r7, #4]
 8001796:	4a04      	ldr	r2, [pc, #16]	@ (80017a8 <DeviceInformation_get_totalMemory+0x1c>)
 8001798:	601a      	str	r2, [r3, #0]
  return 0;
 800179a:	2300      	movs	r3, #0
}
 800179c:	4618      	mov	r0, r3
 800179e:	370c      	adds	r7, #12
 80017a0:	46bd      	mov	sp, r7
 80017a2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80017a6:	4770      	bx	lr
 80017a8:	493ffff0 	.word	0x493ffff0

080017ac <StartBLEScan>:
    BLE_MANAGER_PRINTF("aci_gap_set_advertising_enable: Advertising Disabled\r\n");
    }
}

uint8_t StartBLEScan(void)
{
 80017ac:	b580      	push	{r7, lr}
 80017ae:	b084      	sub	sp, #16
 80017b0:	af02      	add	r7, sp, #8
    tBleStatus status;
    BLE_MANAGER_PRINTF("Attempting to start BLE scan...\r\n");
 80017b2:	481a      	ldr	r0, [pc, #104]	@ (800181c <StartBLEScan+0x70>)
 80017b4:	f022 fb3a 	bl	8023e2c <puts>
    BLE_MANAGER_DELAY(100);
 80017b8:	2064      	movs	r0, #100	@ 0x64
 80017ba:	f003 f81f 	bl	80047fc <HAL_Delay>
    // if (status != BLE_STATUS_SUCCESS) {
    //     BLE_MANAGER_PRINTF("Scan configuration failed. Status: 0x%02X\r\n", status);
    //     return 0;
    // }

    status = hci_le_set_scan_parameters(PASSIVE_SCAN, SCAN_INTERVAL, SCAN_WINDOW, PUBLIC_ADDR, SCAN_ACCEPT_ALL);
 80017be:	2300      	movs	r3, #0
 80017c0:	9300      	str	r3, [sp, #0]
 80017c2:	2300      	movs	r3, #0
 80017c4:	2225      	movs	r2, #37	@ 0x25
 80017c6:	2150      	movs	r1, #80	@ 0x50
 80017c8:	2000      	movs	r0, #0
 80017ca:	f01a f8d0 	bl	801b96e <hci_le_set_scan_parameters>
 80017ce:	4603      	mov	r3, r0
 80017d0:	71fb      	strb	r3, [r7, #7]
    if (status != BLE_STATUS_SUCCESS) {
 80017d2:	79fb      	ldrb	r3, [r7, #7]
 80017d4:	2b00      	cmp	r3, #0
 80017d6:	d006      	beq.n	80017e6 <StartBLEScan+0x3a>
        BLE_MANAGER_PRINTF("Scan configuration failed. Status: 0x%02X\r\n", status);
 80017d8:	79fb      	ldrb	r3, [r7, #7]
 80017da:	4619      	mov	r1, r3
 80017dc:	4810      	ldr	r0, [pc, #64]	@ (8001820 <StartBLEScan+0x74>)
 80017de:	f022 fabd 	bl	8023d5c <iprintf>
        return 0;
 80017e2:	2300      	movs	r3, #0
 80017e4:	e016      	b.n	8001814 <StartBLEScan+0x68>
    }
    BLE_MANAGER_DELAY(50);
 80017e6:	2032      	movs	r0, #50	@ 0x32
 80017e8:	f003 f808 	bl	80047fc <HAL_Delay>

    // Start scanning for BLE devices
    // status = aci_gap_start_procedure(GAP_OBSERVATION_PROC, LE_1M_PHY_BIT, 0x01, 0x01);
    status = hci_le_set_scan_enable(ENABLE, 0x00);
 80017ec:	2100      	movs	r1, #0
 80017ee:	2001      	movs	r0, #1
 80017f0:	f01a f963 	bl	801baba <hci_le_set_scan_enable>
 80017f4:	4603      	mov	r3, r0
 80017f6:	71fb      	strb	r3, [r7, #7]
    // status = aci_gap_start_general_discovery_proc(0x10, 0x10, PUBLIC_ADDR, 0x00);
    if (status == BLE_STATUS_SUCCESS)
 80017f8:	79fb      	ldrb	r3, [r7, #7]
 80017fa:	2b00      	cmp	r3, #0
 80017fc:	d104      	bne.n	8001808 <StartBLEScan+0x5c>
    {
        BLE_MANAGER_PRINTF("BLE scanning started...\r\n");
 80017fe:	4809      	ldr	r0, [pc, #36]	@ (8001824 <StartBLEScan+0x78>)
 8001800:	f022 fb14 	bl	8023e2c <puts>
    else
    {
        BLE_MANAGER_PRINTF("Failed to start BLE scanning. Status: 0x%02X\r\n", status);
        return 0;
    }
    return 1;
 8001804:	2301      	movs	r3, #1
 8001806:	e005      	b.n	8001814 <StartBLEScan+0x68>
        BLE_MANAGER_PRINTF("Failed to start BLE scanning. Status: 0x%02X\r\n", status);
 8001808:	79fb      	ldrb	r3, [r7, #7]
 800180a:	4619      	mov	r1, r3
 800180c:	4806      	ldr	r0, [pc, #24]	@ (8001828 <StartBLEScan+0x7c>)
 800180e:	f022 faa5 	bl	8023d5c <iprintf>
        return 0;
 8001812:	2300      	movs	r3, #0
}
 8001814:	4618      	mov	r0, r3
 8001816:	3708      	adds	r7, #8
 8001818:	46bd      	mov	sp, r7
 800181a:	bd80      	pop	{r7, pc}
 800181c:	08026b90 	.word	0x08026b90
 8001820:	08026bb4 	.word	0x08026bb4
 8001824:	08026be0 	.word	0x08026be0
 8001828:	08026bfc 	.word	0x08026bfc

0800182c <hci_le_advertising_report_event>:

void hci_le_advertising_report_event(uint8_t num_reports,
                                     Advertising_Report_t advertising_report[])
{
 800182c:	b580      	push	{r7, lr}
 800182e:	b086      	sub	sp, #24
 8001830:	af00      	add	r7, sp, #0
 8001832:	4603      	mov	r3, r0
 8001834:	6039      	str	r1, [r7, #0]
 8001836:	71fb      	strb	r3, [r7, #7]
    BLE_MANAGER_PRINTF("Advertising Report Event Called...");
 8001838:	4828      	ldr	r0, [pc, #160]	@ (80018dc <hci_le_advertising_report_event+0xb0>)
 800183a:	f022 fa8f 	bl	8023d5c <iprintf>
    for (uint8_t i = 0; i < num_reports; i++)
 800183e:	2300      	movs	r3, #0
 8001840:	75fb      	strb	r3, [r7, #23]
 8001842:	e041      	b.n	80018c8 <hci_le_advertising_report_event+0x9c>
    {
        // Extract advertising data
        uint8_t *adv_data = advertising_report[i].Data;
 8001844:	7dfa      	ldrb	r2, [r7, #23]
 8001846:	4613      	mov	r3, r2
 8001848:	009b      	lsls	r3, r3, #2
 800184a:	4413      	add	r3, r2
 800184c:	009b      	lsls	r3, r3, #2
 800184e:	461a      	mov	r2, r3
 8001850:	683b      	ldr	r3, [r7, #0]
 8001852:	4413      	add	r3, r2
 8001854:	68db      	ldr	r3, [r3, #12]
 8001856:	613b      	str	r3, [r7, #16]
        uint8_t adv_data_len = advertising_report[i].Data_Length;
 8001858:	7dfa      	ldrb	r2, [r7, #23]
 800185a:	4613      	mov	r3, r2
 800185c:	009b      	lsls	r3, r3, #2
 800185e:	4413      	add	r3, r2
 8001860:	009b      	lsls	r3, r3, #2
 8001862:	461a      	mov	r2, r3
 8001864:	683b      	ldr	r3, [r7, #0]
 8001866:	4413      	add	r3, r2
 8001868:	7a1b      	ldrb	r3, [r3, #8]
 800186a:	73fb      	strb	r3, [r7, #15]
        int8_t rssi = advertising_report[i].RSSI;
 800186c:	7dfa      	ldrb	r2, [r7, #23]
 800186e:	4613      	mov	r3, r2
 8001870:	009b      	lsls	r3, r3, #2
 8001872:	4413      	add	r3, r2
 8001874:	009b      	lsls	r3, r3, #2
 8001876:	461a      	mov	r2, r3
 8001878:	683b      	ldr	r3, [r7, #0]
 800187a:	4413      	add	r3, r2
 800187c:	7c1b      	ldrb	r3, [r3, #16]
 800187e:	73bb      	strb	r3, [r7, #14]

        // Print advertising data
        BLE_MANAGER_PRINTF("Device found:\r\n");
 8001880:	4817      	ldr	r0, [pc, #92]	@ (80018e0 <hci_le_advertising_report_event+0xb4>)
 8001882:	f022 fad3 	bl	8023e2c <puts>
        BLE_MANAGER_PRINTF("  RSSI: %d dBm\r\n", rssi);
 8001886:	f997 300e 	ldrsb.w	r3, [r7, #14]
 800188a:	4619      	mov	r1, r3
 800188c:	4815      	ldr	r0, [pc, #84]	@ (80018e4 <hci_le_advertising_report_event+0xb8>)
 800188e:	f022 fa65 	bl	8023d5c <iprintf>
        BLE_MANAGER_PRINTF("  Advertising Data: ");
 8001892:	4815      	ldr	r0, [pc, #84]	@ (80018e8 <hci_le_advertising_report_event+0xbc>)
 8001894:	f022 fa62 	bl	8023d5c <iprintf>
        for (uint8_t j = 0; j < adv_data_len; j++)
 8001898:	2300      	movs	r3, #0
 800189a:	75bb      	strb	r3, [r7, #22]
 800189c:	e00a      	b.n	80018b4 <hci_le_advertising_report_event+0x88>
        {
            BLE_MANAGER_PRINTF("%02X ", adv_data[j]);
 800189e:	7dbb      	ldrb	r3, [r7, #22]
 80018a0:	693a      	ldr	r2, [r7, #16]
 80018a2:	4413      	add	r3, r2
 80018a4:	781b      	ldrb	r3, [r3, #0]
 80018a6:	4619      	mov	r1, r3
 80018a8:	4810      	ldr	r0, [pc, #64]	@ (80018ec <hci_le_advertising_report_event+0xc0>)
 80018aa:	f022 fa57 	bl	8023d5c <iprintf>
        for (uint8_t j = 0; j < adv_data_len; j++)
 80018ae:	7dbb      	ldrb	r3, [r7, #22]
 80018b0:	3301      	adds	r3, #1
 80018b2:	75bb      	strb	r3, [r7, #22]
 80018b4:	7dba      	ldrb	r2, [r7, #22]
 80018b6:	7bfb      	ldrb	r3, [r7, #15]
 80018b8:	429a      	cmp	r2, r3
 80018ba:	d3f0      	bcc.n	800189e <hci_le_advertising_report_event+0x72>
        }
        BLE_MANAGER_PRINTF("\r\n");
 80018bc:	480c      	ldr	r0, [pc, #48]	@ (80018f0 <hci_le_advertising_report_event+0xc4>)
 80018be:	f022 fab5 	bl	8023e2c <puts>
    for (uint8_t i = 0; i < num_reports; i++)
 80018c2:	7dfb      	ldrb	r3, [r7, #23]
 80018c4:	3301      	adds	r3, #1
 80018c6:	75fb      	strb	r3, [r7, #23]
 80018c8:	7dfa      	ldrb	r2, [r7, #23]
 80018ca:	79fb      	ldrb	r3, [r7, #7]
 80018cc:	429a      	cmp	r2, r3
 80018ce:	d3b9      	bcc.n	8001844 <hci_le_advertising_report_event+0x18>
    }
}
 80018d0:	bf00      	nop
 80018d2:	bf00      	nop
 80018d4:	3718      	adds	r7, #24
 80018d6:	46bd      	mov	sp, r7
 80018d8:	bd80      	pop	{r7, pc}
 80018da:	bf00      	nop
 80018dc:	08026c2c 	.word	0x08026c2c
 80018e0:	08026c50 	.word	0x08026c50
 80018e4:	08026c60 	.word	0x08026c60
 80018e8:	08026c74 	.word	0x08026c74
 80018ec:	08026c8c 	.word	0x08026c8c
 80018f0:	08026c94 	.word	0x08026c94

080018f4 <InitBleBroadcaster>:
    {
        BLE_MANAGER_PRINTF("Failed to stop BLE scanning. Status: 0x%02X\r\n", status);
    }
}

tBleStatus InitBleBroadcaster(void) {
 80018f4:	b580      	push	{r7, lr}
 80018f6:	b082      	sub	sp, #8
 80018f8:	af00      	add	r7, sp, #0
    tBleStatus ret = BLE_STATUS_SUCCESS;
 80018fa:	2300      	movs	r3, #0
 80018fc:	71fb      	strb	r3, [r7, #7]

    if (BLE_StackValue.BoardId == 0U)
 80018fe:	4b1d      	ldr	r3, [pc, #116]	@ (8001974 <InitBleBroadcaster+0x80>)
 8001900:	f893 302a 	ldrb.w	r3, [r3, #42]	@ 0x2a
 8001904:	2b00      	cmp	r3, #0
 8001906:	d104      	bne.n	8001912 <InitBleBroadcaster+0x1e>
    {
    BLE_MANAGER_PRINTF("Error BLE_StackValue.BoardId Not Defined\r\n");
 8001908:	481b      	ldr	r0, [pc, #108]	@ (8001978 <InitBleBroadcaster+0x84>)
 800190a:	f022 fa8f 	bl	8023e2c <puts>
    return BLE_ERROR_UNSPECIFIED;
 800190e:	231f      	movs	r3, #31
 8001910:	e02c      	b.n	800196c <InitBleBroadcaster+0x78>
    }

    BLE_Conf_Service = BLE_SERV_NOT_ENABLE;
 8001912:	4b1a      	ldr	r3, [pc, #104]	@ (800197c <InitBleBroadcaster+0x88>)
 8001914:	2200      	movs	r2, #0
 8001916:	701a      	strb	r2, [r3, #0]
    BLE_StdTerm_Service = BLE_SERV_NOT_ENABLE;
 8001918:	4b19      	ldr	r3, [pc, #100]	@ (8001980 <InitBleBroadcaster+0x8c>)
 800191a:	2200      	movs	r2, #0
 800191c:	701a      	strb	r2, [r3, #0]
    BLE_StdErr_Service = BLE_SERV_NOT_ENABLE;
 800191e:	4b19      	ldr	r3, [pc, #100]	@ (8001984 <InitBleBroadcaster+0x90>)
 8001920:	2200      	movs	r2, #0
 8001922:	701a      	strb	r2, [r3, #0]
    BLE_ExtConf_Service = BLE_SERV_NOT_ENABLE;
 8001924:	4b18      	ldr	r3, [pc, #96]	@ (8001988 <InitBleBroadcaster+0x94>)
 8001926:	2200      	movs	r2, #0
 8001928:	701a      	strb	r2, [r3, #0]

    UsedBleChars = 0;
 800192a:	4b18      	ldr	r3, [pc, #96]	@ (800198c <InitBleBroadcaster+0x98>)
 800192c:	2200      	movs	r2, #0
 800192e:	701a      	strb	r2, [r3, #0]
    UsedStandardBleChars = 0;
 8001930:	4b17      	ldr	r3, [pc, #92]	@ (8001990 <InitBleBroadcaster+0x9c>)
 8001932:	2200      	movs	r2, #0
 8001934:	701a      	strb	r2, [r3, #0]
    connection_handle = 0;
 8001936:	4b17      	ldr	r3, [pc, #92]	@ (8001994 <InitBleBroadcaster+0xa0>)
 8001938:	2200      	movs	r2, #0
 800193a:	801a      	strh	r2, [r3, #0]
    MaxBleCharStdOutLen = DEFAULT_MAX_STDOUT_CHAR_LEN;
 800193c:	4b16      	ldr	r3, [pc, #88]	@ (8001998 <InitBleBroadcaster+0xa4>)
 800193e:	22ff      	movs	r2, #255	@ 0xff
 8001940:	701a      	strb	r2, [r3, #0]
    MaxBleCharStdErrLen = DEFAULT_MAX_STDERR_CHAR_LEN;
 8001942:	4b16      	ldr	r3, [pc, #88]	@ (800199c <InitBleBroadcaster+0xa8>)
 8001944:	22f4      	movs	r2, #244	@ 0xf4
 8001946:	701a      	strb	r2, [r3, #0]

    ret = InitBleBroadcaster_BLE_Stack();
 8001948:	f000 f82e 	bl	80019a8 <InitBleBroadcaster_BLE_Stack>
 800194c:	4603      	mov	r3, r0
 800194e:	71fb      	strb	r3, [r7, #7]

    ResetBleManagerCallbackFunctionPointer();
 8001950:	f000 f958 	bl	8001c04 <ResetBleManagerCallbackFunctionPointer>

    #ifndef BLE_MANAGER_NO_PARSON
    ClearCustomCommandsList();
 8001954:	4912      	ldr	r1, [pc, #72]	@ (80019a0 <InitBleBroadcaster+0xac>)
 8001956:	4813      	ldr	r0, [pc, #76]	@ (80019a4 <InitBleBroadcaster+0xb0>)
 8001958:	f01b ff6c 	bl	801d834 <GenericClearCustomCommandsList>
    #endif /* BLE_MANAGER_NO_PARSON */

    if (ret == (tBleStatus)BLE_STATUS_SUCCESS)
 800195c:	79fb      	ldrb	r3, [r7, #7]
 800195e:	2b00      	cmp	r3, #0
 8001960:	d103      	bne.n	800196a <InitBleBroadcaster+0x76>
    {
    /* Ble Manager services initialization */
    ret = InitBleBroadcasterServices();
 8001962:	f000 f8b9 	bl	8001ad8 <InitBleBroadcasterServices>
 8001966:	4603      	mov	r3, r0
 8001968:	71fb      	strb	r3, [r7, #7]
    }

    return ret;
 800196a:	79fb      	ldrb	r3, [r7, #7]
}
 800196c:	4618      	mov	r0, r3
 800196e:	3708      	adds	r7, #8
 8001970:	46bd      	mov	sp, r7
 8001972:	bd80      	pop	{r7, pc}
 8001974:	20001b0c 	.word	0x20001b0c
 8001978:	08026ce0 	.word	0x08026ce0
 800197c:	20001a04 	.word	0x20001a04
 8001980:	20001a05 	.word	0x20001a05
 8001984:	20001a06 	.word	0x20001a06
 8001988:	20001a07 	.word	0x20001a07
 800198c:	200004ae 	.word	0x200004ae
 8001990:	200004af 	.word	0x200004af
 8001994:	200004ac 	.word	0x200004ac
 8001998:	20001dae 	.word	0x20001dae
 800199c:	20001daf 	.word	0x20001daf
 80019a0:	20001bb0 	.word	0x20001bb0
 80019a4:	20001bac 	.word	0x20001bac

080019a8 <InitBleBroadcaster_BLE_Stack>:

static tBleStatus InitBleBroadcaster_BLE_Stack(void) {
 80019a8:	b5b0      	push	{r4, r5, r7, lr}
 80019aa:	b08a      	sub	sp, #40	@ 0x28
 80019ac:	af04      	add	r7, sp, #16
    uint8_t random_number[8];
    uint8_t  hwVersion;
    uint16_t fwVersion;

    /* Initialize the BlueNRG HCI */
    hci_init(APP_UserEvtRx, NULL);
 80019ae:	2100      	movs	r1, #0
 80019b0:	4840      	ldr	r0, [pc, #256]	@ (8001ab4 <InitBleBroadcaster_BLE_Stack+0x10c>)
 80019b2:	f01a fa3b 	bl	801be2c <hci_init>

    InitBLEIntForBlueNRGLP();
 80019b6:	f001 f869 	bl	8002a8c <InitBLEIntForBlueNRGLP>

    /* Sw reset of the device */
    hci_reset();
 80019ba:	f019 ff6b 	bl	801b894 <hci_reset>

    BLE_MANAGER_DELAY(2000);
 80019be:	f44f 60fa 	mov.w	r0, #2000	@ 0x7d0
 80019c2:	f002 ff1b 	bl	80047fc <HAL_Delay>

    /* get the BlueNRG HW and FW versions */
    getBlueNRGVersion(&hwVersion, &fwVersion);
 80019c6:	1d3a      	adds	r2, r7, #4
 80019c8:	1dfb      	adds	r3, r7, #7
 80019ca:	4611      	mov	r1, r2
 80019cc:	4618      	mov	r0, r3
 80019ce:	f01c f89f 	bl	801db10 <getBlueNRGVersion>
    // {
    // BLE_MANAGER_PRINTF("\r\nSetting Public BD_ADDR failed\r\n");
    // goto fail;
    // }

    ret = aci_gatt_srv_init();
 80019d2:	f017 fb0b 	bl	8018fec <aci_gatt_srv_init>
 80019d6:	4603      	mov	r3, r0
 80019d8:	75fb      	strb	r3, [r7, #23]
    if (ret != BLE_STATUS_SUCCESS)
 80019da:	7dfb      	ldrb	r3, [r7, #23]
 80019dc:	2b00      	cmp	r3, #0
 80019de:	d003      	beq.n	80019e8 <InitBleBroadcaster_BLE_Stack+0x40>
    {
    BLE_MANAGER_PRINTF("\r\nGATT_Init failed\r\n");
 80019e0:	4835      	ldr	r0, [pc, #212]	@ (8001ab8 <InitBleBroadcaster_BLE_Stack+0x110>)
 80019e2:	f022 fa23 	bl	8023e2c <puts>
    goto fail;
 80019e6:	e060      	b.n	8001aaa <InitBleBroadcaster_BLE_Stack+0x102>
    }

    ret = aci_gap_init(BLE_StackValue.GAP_Roles,
 80019e8:	4b34      	ldr	r3, [pc, #208]	@ (8001abc <InitBleBroadcaster_BLE_Stack+0x114>)
 80019ea:	789c      	ldrb	r4, [r3, #2]
                        0x00,
                        (uint8_t) strlen(BLE_StackValue.BoardName),
 80019ec:	4834      	ldr	r0, [pc, #208]	@ (8001ac0 <InitBleBroadcaster_BLE_Stack+0x118>)
 80019ee:	f7fe fc4d 	bl	800028c <strlen>
 80019f2:	4603      	mov	r3, r0
    ret = aci_gap_init(BLE_StackValue.GAP_Roles,
 80019f4:	b2da      	uxtb	r2, r3
 80019f6:	f107 0310 	add.w	r3, r7, #16
 80019fa:	9302      	str	r3, [sp, #8]
 80019fc:	f107 0312 	add.w	r3, r7, #18
 8001a00:	9301      	str	r3, [sp, #4]
 8001a02:	f107 0314 	add.w	r3, r7, #20
 8001a06:	9300      	str	r3, [sp, #0]
 8001a08:	2300      	movs	r3, #0
 8001a0a:	2100      	movs	r1, #0
 8001a0c:	4620      	mov	r0, r4
 8001a0e:	f016 ff09 	bl	8018824 <aci_gap_init>
 8001a12:	4603      	mov	r3, r0
 8001a14:	75fb      	strb	r3, [r7, #23]
                        PUBLIC_ADDR,
                        &service_handle,
                        &dev_name_char_handle,
                        &appearance_char_handle);

    if (ret != BLE_STATUS_SUCCESS)
 8001a16:	7dfb      	ldrb	r3, [r7, #23]
 8001a18:	2b00      	cmp	r3, #0
 8001a1a:	d003      	beq.n	8001a24 <InitBleBroadcaster_BLE_Stack+0x7c>
    {
    BLE_MANAGER_PRINTF("\r\nGAP_Init failed\r\n");
 8001a1c:	4829      	ldr	r0, [pc, #164]	@ (8001ac4 <InitBleBroadcaster_BLE_Stack+0x11c>)
 8001a1e:	f022 fa05 	bl	8023e2c <puts>
    goto fail;
 8001a22:	e042      	b.n	8001aaa <InitBleBroadcaster_BLE_Stack+0x102>
    }

    ret = aci_gatt_srv_write_handle_value_nwk(dev_name_char_handle + 1,
 8001a24:	8a7b      	ldrh	r3, [r7, #18]
 8001a26:	3301      	adds	r3, #1
 8001a28:	b29c      	uxth	r4, r3
                                            0,
                                            (uint8_t) strlen(BLE_StackValue.BoardName),
 8001a2a:	4825      	ldr	r0, [pc, #148]	@ (8001ac0 <InitBleBroadcaster_BLE_Stack+0x118>)
 8001a2c:	f7fe fc2e 	bl	800028c <strlen>
 8001a30:	4603      	mov	r3, r0
 8001a32:	b2db      	uxtb	r3, r3
    ret = aci_gatt_srv_write_handle_value_nwk(dev_name_char_handle + 1,
 8001a34:	461a      	mov	r2, r3
 8001a36:	4b22      	ldr	r3, [pc, #136]	@ (8001ac0 <InitBleBroadcaster_BLE_Stack+0x118>)
 8001a38:	2100      	movs	r1, #0
 8001a3a:	4620      	mov	r0, r4
 8001a3c:	f017 fb00 	bl	8019040 <aci_gatt_srv_write_handle_value_nwk>
 8001a40:	4603      	mov	r3, r0
 8001a42:	75fb      	strb	r3, [r7, #23]
                                            (uint8_t *) BLE_StackValue.BoardName);
    if (ret != BLE_STATUS_SUCCESS)
 8001a44:	7dfb      	ldrb	r3, [r7, #23]
 8001a46:	2b00      	cmp	r3, #0
 8001a48:	d005      	beq.n	8001a56 <InitBleBroadcaster_BLE_Stack+0xae>
    {
    BLE_MANAGER_PRINTF("\taci_gatt_srv_write_handle_value_nwk failed: 0x%02x\r\n", ret);
 8001a4a:	7dfb      	ldrb	r3, [r7, #23]
 8001a4c:	4619      	mov	r1, r3
 8001a4e:	481e      	ldr	r0, [pc, #120]	@ (8001ac8 <InitBleBroadcaster_BLE_Stack+0x120>)
 8001a50:	f022 f984 	bl	8023d5c <iprintf>
    goto fail;
 8001a54:	e029      	b.n	8001aaa <InitBleBroadcaster_BLE_Stack+0x102>
    }
    else
    {
    BLE_MANAGER_PRINTF("\taci_gatt_srv_write_handle_value_nwk\r\n");
 8001a56:	481d      	ldr	r0, [pc, #116]	@ (8001acc <InitBleBroadcaster_BLE_Stack+0x124>)
 8001a58:	f022 f9e8 	bl	8023e2c <puts>
    // {
    // BLE_MANAGER_PRINTF("\r\nGAP setting Authentication failed\r\n");
    // goto fail;
    // }

    BLE_MANAGER_PRINTF("\r\nSERVER: BLE Stack Initialized \r\n"
 8001a5c:	4b17      	ldr	r3, [pc, #92]	@ (8001abc <InitBleBroadcaster_BLE_Stack+0x114>)
 8001a5e:	f893 3024 	ldrb.w	r3, [r3, #36]	@ 0x24
 8001a62:	461c      	mov	r4, r3
 8001a64:	4b15      	ldr	r3, [pc, #84]	@ (8001abc <InitBleBroadcaster_BLE_Stack+0x114>)
 8001a66:	f893 3023 	ldrb.w	r3, [r3, #35]	@ 0x23
 8001a6a:	461d      	mov	r5, r3
 8001a6c:	4b13      	ldr	r3, [pc, #76]	@ (8001abc <InitBleBroadcaster_BLE_Stack+0x114>)
 8001a6e:	f893 3022 	ldrb.w	r3, [r3, #34]	@ 0x22
 8001a72:	461a      	mov	r2, r3
 8001a74:	4b11      	ldr	r3, [pc, #68]	@ (8001abc <InitBleBroadcaster_BLE_Stack+0x114>)
 8001a76:	f893 3021 	ldrb.w	r3, [r3, #33]	@ 0x21
 8001a7a:	4619      	mov	r1, r3
 8001a7c:	4b0f      	ldr	r3, [pc, #60]	@ (8001abc <InitBleBroadcaster_BLE_Stack+0x114>)
 8001a7e:	f893 3020 	ldrb.w	r3, [r3, #32]
 8001a82:	4618      	mov	r0, r3
 8001a84:	4b0d      	ldr	r3, [pc, #52]	@ (8001abc <InitBleBroadcaster_BLE_Stack+0x114>)
 8001a86:	7fdb      	ldrb	r3, [r3, #31]
 8001a88:	9303      	str	r3, [sp, #12]
 8001a8a:	9002      	str	r0, [sp, #8]
 8001a8c:	9101      	str	r1, [sp, #4]
 8001a8e:	9200      	str	r2, [sp, #0]
 8001a90:	462b      	mov	r3, r5
 8001a92:	4622      	mov	r2, r4
 8001a94:	490a      	ldr	r1, [pc, #40]	@ (8001ac0 <InitBleBroadcaster_BLE_Stack+0x118>)
 8001a96:	480e      	ldr	r0, [pc, #56]	@ (8001ad0 <InitBleBroadcaster_BLE_Stack+0x128>)
 8001a98:	f022 f960 	bl	8023d5c <iprintf>
                    BLE_StackValue.BleMacAddress[3],
                    BLE_StackValue.BleMacAddress[2],
                    BLE_StackValue.BleMacAddress[1],
                    BLE_StackValue.BleMacAddress[0]);

    BLE_MANAGER_PRINTF("BlueNRG-LP HWver %d FWver %d\r\n", hwVersion, fwVersion);
 8001a9c:	79fb      	ldrb	r3, [r7, #7]
 8001a9e:	4619      	mov	r1, r3
 8001aa0:	88bb      	ldrh	r3, [r7, #4]
 8001aa2:	461a      	mov	r2, r3
 8001aa4:	480b      	ldr	r0, [pc, #44]	@ (8001ad4 <InitBleBroadcaster_BLE_Stack+0x12c>)
 8001aa6:	f022 f959 	bl	8023d5c <iprintf>
    // {
    // BLE_MANAGER_PRINTF("\thci_le_write_suggested_default_data_length\r\n");
    // }

    fail:
        return ret;
 8001aaa:	7dfb      	ldrb	r3, [r7, #23]
}
 8001aac:	4618      	mov	r0, r3
 8001aae:	3718      	adds	r7, #24
 8001ab0:	46bd      	mov	sp, r7
 8001ab2:	bdb0      	pop	{r4, r5, r7, pc}
 8001ab4:	08001af1 	.word	0x08001af1
 8001ab8:	08026d0c 	.word	0x08026d0c
 8001abc:	20001b0c 	.word	0x20001b0c
 8001ac0:	20001b19 	.word	0x20001b19
 8001ac4:	08026d20 	.word	0x08026d20
 8001ac8:	08026d34 	.word	0x08026d34
 8001acc:	08026d6c 	.word	0x08026d6c
 8001ad0:	08026d94 	.word	0x08026d94
 8001ad4:	08026de8 	.word	0x08026de8

08001ad8 <InitBleBroadcasterServices>:

static tBleStatus InitBleBroadcasterServices(void) {
 8001ad8:	b580      	push	{r7, lr}
 8001ada:	b082      	sub	sp, #8
 8001adc:	af00      	add	r7, sp, #0
    tBleStatus Status = BLE_ERROR_UNSPECIFIED;
 8001ade:	231f      	movs	r3, #31
 8001ae0:	71fb      	strb	r3, [r7, #7]
    BleCharTypeDef *BleCharPointer;

    BLE_InitCustomService();
 8001ae2:	f000 ffef 	bl	8002ac4 <BLE_InitCustomService>
    return Status;
 8001ae6:	79fb      	ldrb	r3, [r7, #7]
}
 8001ae8:	4618      	mov	r0, r3
 8001aea:	3708      	adds	r7, #8
 8001aec:	46bd      	mov	sp, r7
 8001aee:	bd80      	pop	{r7, pc}

08001af0 <APP_UserEvtRx>:

static void APP_UserEvtRx(void *pData)
{
 8001af0:	b580      	push	{r7, lr}
 8001af2:	b08a      	sub	sp, #40	@ 0x28
 8001af4:	af00      	add	r7, sp, #0
 8001af6:	6078      	str	r0, [r7, #4]
  uint32_t i;

  hci_spi_pckt *hci_pckt = (hci_spi_pckt *)pData;
 8001af8:	687b      	ldr	r3, [r7, #4]
 8001afa:	61fb      	str	r3, [r7, #28]

  if (hci_pckt->type == HCI_EVENT_PKT || hci_pckt->type == HCI_EVENT_EXT_PKT)
 8001afc:	69fb      	ldr	r3, [r7, #28]
 8001afe:	781b      	ldrb	r3, [r3, #0]
 8001b00:	2b04      	cmp	r3, #4
 8001b02:	d003      	beq.n	8001b0c <APP_UserEvtRx+0x1c>
 8001b04:	69fb      	ldr	r3, [r7, #28]
 8001b06:	781b      	ldrb	r3, [r3, #0]
 8001b08:	2b82      	cmp	r3, #130	@ 0x82
 8001b0a:	d171      	bne.n	8001bf0 <APP_UserEvtRx+0x100>
  {
    void *data;
    hci_event_pckt *event_pckt = (hci_event_pckt *)hci_pckt->data;
 8001b0c:	69fb      	ldr	r3, [r7, #28]
 8001b0e:	3301      	adds	r3, #1
 8001b10:	61bb      	str	r3, [r7, #24]

    if (hci_pckt->type == HCI_EVENT_PKT)
 8001b12:	69fb      	ldr	r3, [r7, #28]
 8001b14:	781b      	ldrb	r3, [r3, #0]
 8001b16:	2b04      	cmp	r3, #4
 8001b18:	d103      	bne.n	8001b22 <APP_UserEvtRx+0x32>
    {
      data = event_pckt->data;
 8001b1a:	69bb      	ldr	r3, [r7, #24]
 8001b1c:	3302      	adds	r3, #2
 8001b1e:	623b      	str	r3, [r7, #32]
 8001b20:	e005      	b.n	8001b2e <APP_UserEvtRx+0x3e>
    }
    else
    {
      hci_event_ext_pckt *event_pckt = (hci_event_ext_pckt *)hci_pckt->data;
 8001b22:	69fb      	ldr	r3, [r7, #28]
 8001b24:	3301      	adds	r3, #1
 8001b26:	617b      	str	r3, [r7, #20]
      data = event_pckt->data;
 8001b28:	697b      	ldr	r3, [r7, #20]
 8001b2a:	3303      	adds	r3, #3
 8001b2c:	623b      	str	r3, [r7, #32]
    }

    if (event_pckt->evt == EVT_LE_META_EVENT)
 8001b2e:	69bb      	ldr	r3, [r7, #24]
 8001b30:	781b      	ldrb	r3, [r3, #0]
 8001b32:	2b3e      	cmp	r3, #62	@ 0x3e
 8001b34:	d11e      	bne.n	8001b74 <APP_UserEvtRx+0x84>
    {
      evt_le_meta_event *evt = data;
 8001b36:	6a3b      	ldr	r3, [r7, #32]
 8001b38:	60fb      	str	r3, [r7, #12]

      for (i = 0; i < (sizeof(hci_le_meta_events_table) / sizeof(hci_le_meta_events_table_type)); i++)
 8001b3a:	2300      	movs	r3, #0
 8001b3c:	627b      	str	r3, [r7, #36]	@ 0x24
 8001b3e:	e015      	b.n	8001b6c <APP_UserEvtRx+0x7c>
      {
        if (evt->subevent == hci_le_meta_events_table[i].evt_code)
 8001b40:	68fb      	ldr	r3, [r7, #12]
 8001b42:	781b      	ldrb	r3, [r3, #0]
 8001b44:	4619      	mov	r1, r3
 8001b46:	4a2c      	ldr	r2, [pc, #176]	@ (8001bf8 <APP_UserEvtRx+0x108>)
 8001b48:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8001b4a:	f832 3033 	ldrh.w	r3, [r2, r3, lsl #3]
 8001b4e:	4299      	cmp	r1, r3
 8001b50:	d109      	bne.n	8001b66 <APP_UserEvtRx+0x76>
        {
          hci_le_meta_events_table[i].process((void *)evt->data);
 8001b52:	4a29      	ldr	r2, [pc, #164]	@ (8001bf8 <APP_UserEvtRx+0x108>)
 8001b54:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8001b56:	00db      	lsls	r3, r3, #3
 8001b58:	4413      	add	r3, r2
 8001b5a:	685b      	ldr	r3, [r3, #4]
 8001b5c:	68fa      	ldr	r2, [r7, #12]
 8001b5e:	3201      	adds	r2, #1
 8001b60:	4610      	mov	r0, r2
 8001b62:	4798      	blx	r3
          break;
 8001b64:	e044      	b.n	8001bf0 <APP_UserEvtRx+0x100>
      for (i = 0; i < (sizeof(hci_le_meta_events_table) / sizeof(hci_le_meta_events_table_type)); i++)
 8001b66:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8001b68:	3301      	adds	r3, #1
 8001b6a:	627b      	str	r3, [r7, #36]	@ 0x24
 8001b6c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8001b6e:	2b18      	cmp	r3, #24
 8001b70:	d9e6      	bls.n	8001b40 <APP_UserEvtRx+0x50>
          break;
        }
      }
    }
  }
}
 8001b72:	e03d      	b.n	8001bf0 <APP_UserEvtRx+0x100>
    else if (event_pckt->evt == EVT_VENDOR)
 8001b74:	69bb      	ldr	r3, [r7, #24]
 8001b76:	781b      	ldrb	r3, [r3, #0]
 8001b78:	2bff      	cmp	r3, #255	@ 0xff
 8001b7a:	d11e      	bne.n	8001bba <APP_UserEvtRx+0xca>
      evt_blue_aci *blue_evt = data;
 8001b7c:	6a3b      	ldr	r3, [r7, #32]
 8001b7e:	613b      	str	r3, [r7, #16]
      for (i = 0; i < (sizeof(hci_vendor_specific_events_table) / sizeof(hci_vendor_specific_events_table_type)); i++)
 8001b80:	2300      	movs	r3, #0
 8001b82:	627b      	str	r3, [r7, #36]	@ 0x24
 8001b84:	e015      	b.n	8001bb2 <APP_UserEvtRx+0xc2>
        if (blue_evt->ecode == hci_vendor_specific_events_table[i].evt_code)
 8001b86:	693b      	ldr	r3, [r7, #16]
 8001b88:	881b      	ldrh	r3, [r3, #0]
 8001b8a:	b29a      	uxth	r2, r3
 8001b8c:	491b      	ldr	r1, [pc, #108]	@ (8001bfc <APP_UserEvtRx+0x10c>)
 8001b8e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8001b90:	f831 3033 	ldrh.w	r3, [r1, r3, lsl #3]
 8001b94:	429a      	cmp	r2, r3
 8001b96:	d109      	bne.n	8001bac <APP_UserEvtRx+0xbc>
          hci_vendor_specific_events_table[i].process((void *)blue_evt->data);
 8001b98:	4a18      	ldr	r2, [pc, #96]	@ (8001bfc <APP_UserEvtRx+0x10c>)
 8001b9a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8001b9c:	00db      	lsls	r3, r3, #3
 8001b9e:	4413      	add	r3, r2
 8001ba0:	685b      	ldr	r3, [r3, #4]
 8001ba2:	693a      	ldr	r2, [r7, #16]
 8001ba4:	3202      	adds	r2, #2
 8001ba6:	4610      	mov	r0, r2
 8001ba8:	4798      	blx	r3
          break;
 8001baa:	e021      	b.n	8001bf0 <APP_UserEvtRx+0x100>
      for (i = 0; i < (sizeof(hci_vendor_specific_events_table) / sizeof(hci_vendor_specific_events_table_type)); i++)
 8001bac:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8001bae:	3301      	adds	r3, #1
 8001bb0:	627b      	str	r3, [r7, #36]	@ 0x24
 8001bb2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8001bb4:	2b2d      	cmp	r3, #45	@ 0x2d
 8001bb6:	d9e6      	bls.n	8001b86 <APP_UserEvtRx+0x96>
}
 8001bb8:	e01a      	b.n	8001bf0 <APP_UserEvtRx+0x100>
      for (i = 0; i < (sizeof(hci_events_table) / sizeof(hci_events_table_type)); i++)
 8001bba:	2300      	movs	r3, #0
 8001bbc:	627b      	str	r3, [r7, #36]	@ 0x24
 8001bbe:	e013      	b.n	8001be8 <APP_UserEvtRx+0xf8>
        if (event_pckt->evt == hci_events_table[i].evt_code)
 8001bc0:	69bb      	ldr	r3, [r7, #24]
 8001bc2:	781b      	ldrb	r3, [r3, #0]
 8001bc4:	4619      	mov	r1, r3
 8001bc6:	4a0e      	ldr	r2, [pc, #56]	@ (8001c00 <APP_UserEvtRx+0x110>)
 8001bc8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8001bca:	f832 3033 	ldrh.w	r3, [r2, r3, lsl #3]
 8001bce:	4299      	cmp	r1, r3
 8001bd0:	d107      	bne.n	8001be2 <APP_UserEvtRx+0xf2>
          hci_events_table[i].process(data);
 8001bd2:	4a0b      	ldr	r2, [pc, #44]	@ (8001c00 <APP_UserEvtRx+0x110>)
 8001bd4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8001bd6:	00db      	lsls	r3, r3, #3
 8001bd8:	4413      	add	r3, r2
 8001bda:	685b      	ldr	r3, [r3, #4]
 8001bdc:	6a38      	ldr	r0, [r7, #32]
 8001bde:	4798      	blx	r3
          break;
 8001be0:	e006      	b.n	8001bf0 <APP_UserEvtRx+0x100>
      for (i = 0; i < (sizeof(hci_events_table) / sizeof(hci_events_table_type)); i++)
 8001be2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8001be4:	3301      	adds	r3, #1
 8001be6:	627b      	str	r3, [r7, #36]	@ 0x24
 8001be8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8001bea:	2b07      	cmp	r3, #7
 8001bec:	d9e8      	bls.n	8001bc0 <APP_UserEvtRx+0xd0>
}
 8001bee:	e7ff      	b.n	8001bf0 <APP_UserEvtRx+0x100>
 8001bf0:	bf00      	nop
 8001bf2:	3728      	adds	r7, #40	@ 0x28
 8001bf4:	46bd      	mov	sp, r7
 8001bf6:	bd80      	pop	{r7, pc}
 8001bf8:	0802a608 	.word	0x0802a608
 8001bfc:	0802a6d0 	.word	0x0802a6d0
 8001c00:	0802a5c8 	.word	0x0802a5c8

08001c04 <ResetBleManagerCallbackFunctionPointer>:

static void ResetBleManagerCallbackFunctionPointer(void)
{
 8001c04:	b480      	push	{r7}
 8001c06:	af00      	add	r7, sp, #0
  /**************** Bluetooth Communication *************************/
  CustomPairingCompleted = NULL;
 8001c08:	4b2d      	ldr	r3, [pc, #180]	@ (8001cc0 <ResetBleManagerCallbackFunctionPointer+0xbc>)
 8001c0a:	2200      	movs	r2, #0
 8001c0c:	601a      	str	r2, [r3, #0]
  CustomMTUExchangeRespEvent = NULL;
 8001c0e:	4b2d      	ldr	r3, [pc, #180]	@ (8001cc4 <ResetBleManagerCallbackFunctionPointer+0xc0>)
 8001c10:	2200      	movs	r2, #0
 8001c12:	601a      	str	r2, [r3, #0]
  CustomSetConnectable = NULL;
 8001c14:	4b2c      	ldr	r3, [pc, #176]	@ (8001cc8 <ResetBleManagerCallbackFunctionPointer+0xc4>)
 8001c16:	2200      	movs	r2, #0
 8001c18:	601a      	str	r2, [r3, #0]
  CustomConnectionCompleted = NULL;
 8001c1a:	4b2c      	ldr	r3, [pc, #176]	@ (8001ccc <ResetBleManagerCallbackFunctionPointer+0xc8>)
 8001c1c:	2200      	movs	r2, #0
 8001c1e:	601a      	str	r2, [r3, #0]
  CustomDisconnectionCompleted = NULL;
 8001c20:	4b2b      	ldr	r3, [pc, #172]	@ (8001cd0 <ResetBleManagerCallbackFunctionPointer+0xcc>)
 8001c22:	2200      	movs	r2, #0
 8001c24:	601a      	str	r2, [r3, #0]
  CustomAciGattTxPoolAvailableEvent = NULL;
 8001c26:	4b2b      	ldr	r3, [pc, #172]	@ (8001cd4 <ResetBleManagerCallbackFunctionPointer+0xd0>)
 8001c28:	2200      	movs	r2, #0
 8001c2a:	601a      	str	r2, [r3, #0]
  CustomHardwareErrorEventHandler = NULL;
 8001c2c:	4b2a      	ldr	r3, [pc, #168]	@ (8001cd8 <ResetBleManagerCallbackFunctionPointer+0xd4>)
 8001c2e:	2200      	movs	r2, #0
 8001c30:	601a      	str	r2, [r3, #0]

  /**************** Debug Console *************************/
  CustomDebugConsoleParsingCallback = NULL;
 8001c32:	4b2a      	ldr	r3, [pc, #168]	@ (8001cdc <ResetBleManagerCallbackFunctionPointer+0xd8>)
 8001c34:	2200      	movs	r2, #0
 8001c36:	601a      	str	r2, [r3, #0]

  /******************* Config Char *************************/
  CustomAttrModConfigCallback = NULL;
 8001c38:	4b29      	ldr	r3, [pc, #164]	@ (8001ce0 <ResetBleManagerCallbackFunctionPointer+0xdc>)
 8001c3a:	2200      	movs	r2, #0
 8001c3c:	601a      	str	r2, [r3, #0]
  CustomWriteRequestConfigCallback = NULL;
 8001c3e:	4b29      	ldr	r3, [pc, #164]	@ (8001ce4 <ResetBleManagerCallbackFunctionPointer+0xe0>)
 8001c40:	2200      	movs	r2, #0
 8001c42:	601a      	str	r2, [r3, #0]

#ifndef BLE_MANAGER_NO_PARSON
  /**************** Extended Configuration *************************/
  /* For Reboot on DFU Command */
  CustomExtConfigRebootOnDFUModeCommandCallback = NULL;
 8001c44:	4b28      	ldr	r3, [pc, #160]	@ (8001ce8 <ResetBleManagerCallbackFunctionPointer+0xe4>)
 8001c46:	2200      	movs	r2, #0
 8001c48:	601a      	str	r2, [r3, #0]
  /* For Power off Command */
  CustomExtConfigPowerOffCommandCallback = NULL;
 8001c4a:	4b28      	ldr	r3, [pc, #160]	@ (8001cec <ResetBleManagerCallbackFunctionPointer+0xe8>)
 8001c4c:	2200      	movs	r2, #0
 8001c4e:	601a      	str	r2, [r3, #0]
  /* For Set board Name Command */
  CustomExtConfigSetNameCommandCallback = NULL;
 8001c50:	4b27      	ldr	r3, [pc, #156]	@ (8001cf0 <ResetBleManagerCallbackFunctionPointer+0xec>)
 8001c52:	2200      	movs	r2, #0
 8001c54:	601a      	str	r2, [r3, #0]
  /* For Set Time Command */
  CustomExtConfigSetTimeCommandCallback = NULL;
 8001c56:	4b27      	ldr	r3, [pc, #156]	@ (8001cf4 <ResetBleManagerCallbackFunctionPointer+0xf0>)
 8001c58:	2200      	movs	r2, #0
 8001c5a:	601a      	str	r2, [r3, #0]
  /* For Set Date Command */
  CustomExtConfigSetDateCommandCallback = NULL;
 8001c5c:	4b26      	ldr	r3, [pc, #152]	@ (8001cf8 <ResetBleManagerCallbackFunctionPointer+0xf4>)
 8001c5e:	2200      	movs	r2, #0
 8001c60:	601a      	str	r2, [r3, #0]
  /* For Set Wi-Fi Command */
  CustomExtConfigSetWiFiCommandCallback = NULL;
 8001c62:	4b26      	ldr	r3, [pc, #152]	@ (8001cfc <ResetBleManagerCallbackFunctionPointer+0xf8>)
 8001c64:	2200      	movs	r2, #0
 8001c66:	601a      	str	r2, [r3, #0]
  /* For Change Secure PIN Command */
  CustomExtConfigChangePinCommandCallback = NULL;
 8001c68:	4b25      	ldr	r3, [pc, #148]	@ (8001d00 <ResetBleManagerCallbackFunctionPointer+0xfc>)
 8001c6a:	2200      	movs	r2, #0
 8001c6c:	601a      	str	r2, [r3, #0]
  /* For Clear Secure Data Base Command */
  CustomExtConfigClearDBCommandCallback = NULL;
 8001c6e:	4b25      	ldr	r3, [pc, #148]	@ (8001d04 <ResetBleManagerCallbackFunctionPointer+0x100>)
 8001c70:	2200      	movs	r2, #0
 8001c72:	601a      	str	r2, [r3, #0]
  /* For Reading the Flash Banks Fw Ids */
  CustomExtConfigReadBanksFwIdCommandCallback = NULL;
 8001c74:	4b24      	ldr	r3, [pc, #144]	@ (8001d08 <ResetBleManagerCallbackFunctionPointer+0x104>)
 8001c76:	2200      	movs	r2, #0
 8001c78:	601a      	str	r2, [r3, #0]
  /* For Swapping the Flash Banks */
  CustomExtConfigBanksSwapCommandCallback = NULL;
 8001c7a:	4b24      	ldr	r3, [pc, #144]	@ (8001d0c <ResetBleManagerCallbackFunctionPointer+0x108>)
 8001c7c:	2200      	movs	r2, #0
 8001c7e:	601a      	str	r2, [r3, #0]
  /* For UID Command */
  CustomExtConfigUidCommandCallback = NULL;
 8001c80:	4b23      	ldr	r3, [pc, #140]	@ (8001d10 <ResetBleManagerCallbackFunctionPointer+0x10c>)
 8001c82:	2200      	movs	r2, #0
 8001c84:	601a      	str	r2, [r3, #0]
  /* For Info Command */
  CustomExtConfigInfoCommandCallback = NULL;
 8001c86:	4b23      	ldr	r3, [pc, #140]	@ (8001d14 <ResetBleManagerCallbackFunctionPointer+0x110>)
 8001c88:	2200      	movs	r2, #0
 8001c8a:	601a      	str	r2, [r3, #0]
  /* For Help Command */
  CustomExtConfigHelpCommandCallback = NULL;
 8001c8c:	4b22      	ldr	r3, [pc, #136]	@ (8001d18 <ResetBleManagerCallbackFunctionPointer+0x114>)
 8001c8e:	2200      	movs	r2, #0
 8001c90:	601a      	str	r2, [r3, #0]
  /* For PowerStatus Command */
  CustomExtConfigPowerStatusCommandCallback = NULL;
 8001c92:	4b22      	ldr	r3, [pc, #136]	@ (8001d1c <ResetBleManagerCallbackFunctionPointer+0x118>)
 8001c94:	2200      	movs	r2, #0
 8001c96:	601a      	str	r2, [r3, #0]
  /* For VersionFw Command */
  CustomExtConfigVersionFwCommandCallback = NULL;
 8001c98:	4b21      	ldr	r3, [pc, #132]	@ (8001d20 <ResetBleManagerCallbackFunctionPointer+0x11c>)
 8001c9a:	2200      	movs	r2, #0
 8001c9c:	601a      	str	r2, [r3, #0]
  /* For Custom Command */
  CustomExtConfigReadCustomCommandsCallback = NULL;
 8001c9e:	4b21      	ldr	r3, [pc, #132]	@ (8001d24 <ResetBleManagerCallbackFunctionPointer+0x120>)
 8001ca0:	2200      	movs	r2, #0
 8001ca2:	601a      	str	r2, [r3, #0]
  CustomExtConfigCustomCommandCallback = NULL;
 8001ca4:	4b20      	ldr	r3, [pc, #128]	@ (8001d28 <ResetBleManagerCallbackFunctionPointer+0x124>)
 8001ca6:	2200      	movs	r2, #0
 8001ca8:	601a      	str	r2, [r3, #0]
  /* For Read Certificate Command */
  CustomExtConfigReadCertCommandCallback = NULL;
 8001caa:	4b20      	ldr	r3, [pc, #128]	@ (8001d2c <ResetBleManagerCallbackFunctionPointer+0x128>)
 8001cac:	2200      	movs	r2, #0
 8001cae:	601a      	str	r2, [r3, #0]
  /* For Set Certificate Command */
  CustomExtConfigSetCertCommandCallback = NULL;
 8001cb0:	4b1f      	ldr	r3, [pc, #124]	@ (8001d30 <ResetBleManagerCallbackFunctionPointer+0x12c>)
 8001cb2:	2200      	movs	r2, #0
 8001cb4:	601a      	str	r2, [r3, #0]
#endif /* BLE_MANAGER_NO_PARSON */
 8001cb6:	bf00      	nop
 8001cb8:	46bd      	mov	sp, r7
 8001cba:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001cbe:	4770      	bx	lr
 8001cc0:	20001b38 	.word	0x20001b38
 8001cc4:	20001b3c 	.word	0x20001b3c
 8001cc8:	20001b40 	.word	0x20001b40
 8001ccc:	20001b44 	.word	0x20001b44
 8001cd0:	20001b48 	.word	0x20001b48
 8001cd4:	20001b4c 	.word	0x20001b4c
 8001cd8:	20001b50 	.word	0x20001b50
 8001cdc:	20001b54 	.word	0x20001b54
 8001ce0:	20001b58 	.word	0x20001b58
 8001ce4:	20001b5c 	.word	0x20001b5c
 8001ce8:	20001b60 	.word	0x20001b60
 8001cec:	20001b64 	.word	0x20001b64
 8001cf0:	20001b68 	.word	0x20001b68
 8001cf4:	20001b6c 	.word	0x20001b6c
 8001cf8:	20001b70 	.word	0x20001b70
 8001cfc:	20001b74 	.word	0x20001b74
 8001d00:	20001b78 	.word	0x20001b78
 8001d04:	20001b7c 	.word	0x20001b7c
 8001d08:	20001b80 	.word	0x20001b80
 8001d0c:	20001b84 	.word	0x20001b84
 8001d10:	20001b88 	.word	0x20001b88
 8001d14:	20001b8c 	.word	0x20001b8c
 8001d18:	20001b90 	.word	0x20001b90
 8001d1c:	20001b94 	.word	0x20001b94
 8001d20:	20001b98 	.word	0x20001b98
 8001d24:	20001b9c 	.word	0x20001b9c
 8001d28:	20001ba0 	.word	0x20001ba0
 8001d2c:	20001ba4 	.word	0x20001ba4
 8001d30:	20001ba8 	.word	0x20001ba8

08001d34 <MTUExcahngeRespEvent>:
  * @brief  Callback Called after a MTU Exchange Event
  * @param  int32_t MaxCharLength
  * @retval none
  */
void MTUExcahngeRespEvent(int32_t MaxCharLength)
{
 8001d34:	b580      	push	{r7, lr}
 8001d36:	b082      	sub	sp, #8
 8001d38:	af00      	add	r7, sp, #0
 8001d3a:	6078      	str	r0, [r7, #4]
  if(MaxCharLength<BLE_PnPLikeGetMaxCharLength()) {
 8001d3c:	f01b fd32 	bl	801d7a4 <BLE_PnPLikeGetMaxCharLength>
 8001d40:	4603      	mov	r3, r0
 8001d42:	461a      	mov	r2, r3
 8001d44:	687b      	ldr	r3, [r7, #4]
 8001d46:	4293      	cmp	r3, r2
 8001d48:	da08      	bge.n	8001d5c <MTUExcahngeRespEvent+0x28>
    BLE_PnPLikeSetMaxCharLength(MaxCharLength);
 8001d4a:	687b      	ldr	r3, [r7, #4]
 8001d4c:	b29b      	uxth	r3, r3
 8001d4e:	4618      	mov	r0, r3
 8001d50:	f01b fd18 	bl	801d784 <BLE_PnPLikeSetMaxCharLength>
    STBOX1_PRINTF("BLE_PnPLikeSetMaxCharLength ->%ld\r\n", MaxCharLength);
 8001d54:	6879      	ldr	r1, [r7, #4]
 8001d56:	4803      	ldr	r0, [pc, #12]	@ (8001d64 <MTUExcahngeRespEvent+0x30>)
 8001d58:	f022 f800 	bl	8023d5c <iprintf>
  }
}
 8001d5c:	bf00      	nop
 8001d5e:	3708      	adds	r7, #8
 8001d60:	46bd      	mov	sp, r7
 8001d62:	bd80      	pop	{r7, pc}
 8001d64:	08026e94 	.word	0x08026e94

08001d68 <TxPoolAvailableEvent>:
  * @brief  Callback Called after a aci_gatt_tx_pool_available_event Event
  * @param  none
  * @retval none
  */
void TxPoolAvailableEvent(void)
{
 8001d68:	b580      	push	{r7, lr}
 8001d6a:	af00      	add	r7, sp, #0
  PoolAvailable=1;
 8001d6c:	4b03      	ldr	r3, [pc, #12]	@ (8001d7c <TxPoolAvailableEvent+0x14>)
 8001d6e:	2201      	movs	r2, #1
 8001d70:	601a      	str	r2, [r3, #0]
  STBOX1_PRINTF("TxPoolAvailableEvent\r\n");
 8001d72:	4803      	ldr	r0, [pc, #12]	@ (8001d80 <TxPoolAvailableEvent+0x18>)
 8001d74:	f022 f85a 	bl	8023e2c <puts>
}
 8001d78:	bf00      	nop
 8001d7a:	bd80      	pop	{r7, pc}
 8001d7c:	20000008 	.word	0x20000008
 8001d80:	08026eb8 	.word	0x08026eb8

08001d84 <WriteRequestPnPLike>:
 * @param  uint8_t* received_msg received message
 * @param  uint8_t msg_length message length
 * @retval None
 */
void WriteRequestPnPLike(uint8_t* received_msg, uint8_t msg_length)
{
 8001d84:	b580      	push	{r7, lr}
 8001d86:	b096      	sub	sp, #88	@ 0x58
 8001d88:	af00      	add	r7, sp, #0
 8001d8a:	6078      	str	r0, [r7, #4]
 8001d8c:	460b      	mov	r3, r1
 8001d8e:	70fb      	strb	r3, [r7, #3]
  PnPLCommand_t PnPLCommand;
  STBOX1_PRINTF("PnPMessage Received\r\n");
 8001d90:	4817      	ldr	r0, [pc, #92]	@ (8001df0 <WriteRequestPnPLike+0x6c>)
 8001d92:	f022 f84b 	bl	8023e2c <puts>
  STBOX1_PRINTF("\t<%.*s>\r\n",msg_length,received_msg);
 8001d96:	78fb      	ldrb	r3, [r7, #3]
 8001d98:	687a      	ldr	r2, [r7, #4]
 8001d9a:	4619      	mov	r1, r3
 8001d9c:	4815      	ldr	r0, [pc, #84]	@ (8001df4 <WriteRequestPnPLike+0x70>)
 8001d9e:	f021 ffdd 	bl	8023d5c <iprintf>

  PnPLParseCommand((char *)received_msg,&PnPLCommand);
 8001da2:	f107 0310 	add.w	r3, r7, #16
 8001da6:	4619      	mov	r1, r3
 8001da8:	6878      	ldr	r0, [r7, #4]
 8001daa:	f01a ff35 	bl	801cc18 <PnPLParseCommand>

  if(PnPLCommand.comm_type == PNPL_CMD_GET) {
 8001dae:	7c3b      	ldrb	r3, [r7, #16]
 8001db0:	2b10      	cmp	r3, #16
 8001db2:	d118      	bne.n	8001de6 <WriteRequestPnPLike+0x62>
    char *SerializedJSON;
    uint32_t size;

    PnPLSerializeResponse(&PnPLCommand,&SerializedJSON,&size,0);
 8001db4:	f107 0208 	add.w	r2, r7, #8
 8001db8:	f107 010c 	add.w	r1, r7, #12
 8001dbc:	f107 0010 	add.w	r0, r7, #16
 8001dc0:	2300      	movs	r3, #0
 8001dc2:	f01a ffe5 	bl	801cd90 <PnPLSerializeResponse>

    STBOX1_PRINTF("--> <%.*s>\r\n",size,SerializedJSON);
 8001dc6:	68bb      	ldr	r3, [r7, #8]
 8001dc8:	68fa      	ldr	r2, [r7, #12]
 8001dca:	4619      	mov	r1, r3
 8001dcc:	480a      	ldr	r0, [pc, #40]	@ (8001df8 <WriteRequestPnPLike+0x74>)
 8001dce:	f021 ffc5 	bl	8023d5c <iprintf>

    PnPLikeEncapsulate((uint8_t*) SerializedJSON,size);
 8001dd2:	68fb      	ldr	r3, [r7, #12]
 8001dd4:	68ba      	ldr	r2, [r7, #8]
 8001dd6:	4611      	mov	r1, r2
 8001dd8:	4618      	mov	r0, r3
 8001dda:	f000 f80f 	bl	8001dfc <PnPLikeEncapsulate>
    free(SerializedJSON);
 8001dde:	68fb      	ldr	r3, [r7, #12]
 8001de0:	4618      	mov	r0, r3
 8001de2:	f020 f8f9 	bl	8021fd8 <free>
  }
}
 8001de6:	bf00      	nop
 8001de8:	3758      	adds	r7, #88	@ 0x58
 8001dea:	46bd      	mov	sp, r7
 8001dec:	bd80      	pop	{r7, pc}
 8001dee:	bf00      	nop
 8001df0:	08026ed0 	.word	0x08026ed0
 8001df4:	08026ee8 	.word	0x08026ee8
 8001df8:	08026ef4 	.word	0x08026ef4

08001dfc <PnPLikeEncapsulate>:
* @param  uint8_t *data string to write
* @param  uint32_t lenght lengt of string to write
* @retval tBleStatus      Status
*/
tBleStatus PnPLikeEncapsulate(uint8_t *data,uint32_t length)
{
 8001dfc:	b580      	push	{r7, lr}
 8001dfe:	b086      	sub	sp, #24
 8001e00:	af00      	add	r7, sp, #0
 8001e02:	6078      	str	r0, [r7, #4]
 8001e04:	6039      	str	r1, [r7, #0]
  uint32_t length_wTP;

  int32_t MaxPnPLikeUpdate = BLE_PnPLikeGetMaxCharLength();
 8001e06:	f01b fccd 	bl	801d7a4 <BLE_PnPLikeGetMaxCharLength>
 8001e0a:	4603      	mov	r3, r0
 8001e0c:	613b      	str	r3, [r7, #16]
  int32_t MaxPnPLikeUpdateMinus1 = MaxPnPLikeUpdate - 1;
 8001e0e:	693b      	ldr	r3, [r7, #16]
 8001e10:	3b01      	subs	r3, #1
 8001e12:	60fb      	str	r3, [r7, #12]

  if ((length % MaxPnPLikeUpdateMinus1) == 0U) {
 8001e14:	68fa      	ldr	r2, [r7, #12]
 8001e16:	683b      	ldr	r3, [r7, #0]
 8001e18:	fbb3 f1f2 	udiv	r1, r3, r2
 8001e1c:	fb01 f202 	mul.w	r2, r1, r2
 8001e20:	1a9b      	subs	r3, r3, r2
 8001e22:	2b00      	cmp	r3, #0
 8001e24:	d107      	bne.n	8001e36 <PnPLikeEncapsulate+0x3a>
    length_wTP = (length/MaxPnPLikeUpdateMinus1)+length;
 8001e26:	68fb      	ldr	r3, [r7, #12]
 8001e28:	683a      	ldr	r2, [r7, #0]
 8001e2a:	fbb2 f3f3 	udiv	r3, r2, r3
 8001e2e:	683a      	ldr	r2, [r7, #0]
 8001e30:	4413      	add	r3, r2
 8001e32:	617b      	str	r3, [r7, #20]
 8001e34:	e007      	b.n	8001e46 <PnPLikeEncapsulate+0x4a>
  } else {
    length_wTP = (length/MaxPnPLikeUpdateMinus1)+1U+length;
 8001e36:	68fb      	ldr	r3, [r7, #12]
 8001e38:	683a      	ldr	r2, [r7, #0]
 8001e3a:	fbb2 f2f3 	udiv	r2, r2, r3
 8001e3e:	683b      	ldr	r3, [r7, #0]
 8001e40:	4413      	add	r3, r2
 8001e42:	3301      	adds	r3, #1
 8001e44:	617b      	str	r3, [r7, #20]
  }

  if(JSON_string_command_wTP!=NULL) {
 8001e46:	4b14      	ldr	r3, [pc, #80]	@ (8001e98 <PnPLikeEncapsulate+0x9c>)
 8001e48:	681b      	ldr	r3, [r3, #0]
 8001e4a:	2b00      	cmp	r3, #0
 8001e4c:	d002      	beq.n	8001e54 <PnPLikeEncapsulate+0x58>
    STBOX1_PRINTF("BIG PROBLEM!!\r\tNot good at all\r\n");
 8001e4e:	4813      	ldr	r0, [pc, #76]	@ (8001e9c <PnPLikeEncapsulate+0xa0>)
 8001e50:	f021 ffec 	bl	8023e2c <puts>
  }
  JSON_string_command_wTP = malloc(sizeof(uint8_t) * length_wTP);
 8001e54:	6978      	ldr	r0, [r7, #20]
 8001e56:	f020 f8b7 	bl	8021fc8 <malloc>
 8001e5a:	4603      	mov	r3, r0
 8001e5c:	461a      	mov	r2, r3
 8001e5e:	4b0e      	ldr	r3, [pc, #56]	@ (8001e98 <PnPLikeEncapsulate+0x9c>)
 8001e60:	601a      	str	r2, [r3, #0]

  if(JSON_string_command_wTP==NULL) {
 8001e62:	4b0d      	ldr	r3, [pc, #52]	@ (8001e98 <PnPLikeEncapsulate+0x9c>)
 8001e64:	681b      	ldr	r3, [r3, #0]
 8001e66:	2b00      	cmp	r3, #0
 8001e68:	d107      	bne.n	8001e7a <PnPLikeEncapsulate+0x7e>
    STBOX1_PRINTF("Error: Mem calloc error [%lu]: %d@%s\r\n",length,__LINE__,__FILE__);
 8001e6a:	4b0d      	ldr	r3, [pc, #52]	@ (8001ea0 <PnPLikeEncapsulate+0xa4>)
 8001e6c:	22c0      	movs	r2, #192	@ 0xc0
 8001e6e:	6839      	ldr	r1, [r7, #0]
 8001e70:	480c      	ldr	r0, [pc, #48]	@ (8001ea4 <PnPLikeEncapsulate+0xa8>)
 8001e72:	f021 ff73 	bl	8023d5c <iprintf>
    return BLE_STATUS_ERROR;
 8001e76:	2386      	movs	r3, #134	@ 0x86
 8001e78:	e00a      	b.n	8001e90 <PnPLikeEncapsulate+0x94>
  } else {
    JSON_len_command_wTP = BLE_Command_TP_Encapsulate(JSON_string_command_wTP, data, length,MaxPnPLikeUpdate);
 8001e7a:	4b07      	ldr	r3, [pc, #28]	@ (8001e98 <PnPLikeEncapsulate+0x9c>)
 8001e7c:	6818      	ldr	r0, [r3, #0]
 8001e7e:	693b      	ldr	r3, [r7, #16]
 8001e80:	683a      	ldr	r2, [r7, #0]
 8001e82:	6879      	ldr	r1, [r7, #4]
 8001e84:	f01b ffbc 	bl	801de00 <BLE_Command_TP_Encapsulate>
 8001e88:	4603      	mov	r3, r0
 8001e8a:	4a07      	ldr	r2, [pc, #28]	@ (8001ea8 <PnPLikeEncapsulate+0xac>)
 8001e8c:	6013      	str	r3, [r2, #0]
    return BLE_STATUS_SUCCESS;
 8001e8e:	2300      	movs	r3, #0
  }
}
 8001e90:	4618      	mov	r0, r3
 8001e92:	3718      	adds	r7, #24
 8001e94:	46bd      	mov	sp, r7
 8001e96:	bd80      	pop	{r7, pc}
 8001e98:	200004cc 	.word	0x200004cc
 8001e9c:	08026f04 	.word	0x08026f04
 8001ea0:	08026e08 	.word	0x08026e08
 8001ea4:	08026f24 	.word	0x08026f24
 8001ea8:	200004c8 	.word	0x200004c8

08001eac <NotifyEventBattery>:
 * @brief  Callback Function for Un/Subscription Battery Feature
 * @param  BLE_NotifyEvent_t Event Sub/Unsub
 * @retval None
 */
void NotifyEventBattery(BLE_NotifyEvent_t Event)
{
 8001eac:	b580      	push	{r7, lr}
 8001eae:	b084      	sub	sp, #16
 8001eb0:	af00      	add	r7, sp, #0
 8001eb2:	4603      	mov	r3, r0
 8001eb4:	71fb      	strb	r3, [r7, #7]
  if(Event == BLE_NOTIFY_SUB){
 8001eb6:	79fb      	ldrb	r3, [r7, #7]
 8001eb8:	2b01      	cmp	r3, #1
 8001eba:	d121      	bne.n	8001f00 <NotifyEventBattery+0x54>
    uint32_t uhCapture = __HAL_TIM_GET_COUNTER(&TIM_CC_HANDLE);
 8001ebc:	4b1f      	ldr	r3, [pc, #124]	@ (8001f3c <NotifyEventBattery+0x90>)
 8001ebe:	681b      	ldr	r3, [r3, #0]
 8001ec0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8001ec2:	60fb      	str	r3, [r7, #12]

    W2ST_ON_CONNECTION(W2ST_CONNECT_BAT_EVENT);
 8001ec4:	4b1e      	ldr	r3, [pc, #120]	@ (8001f40 <NotifyEventBattery+0x94>)
 8001ec6:	681b      	ldr	r3, [r3, #0]
 8001ec8:	f043 0310 	orr.w	r3, r3, #16
 8001ecc:	4a1c      	ldr	r2, [pc, #112]	@ (8001f40 <NotifyEventBattery+0x94>)
 8001ece:	6013      	str	r3, [r2, #0]

    /* Start the TIM Base generation in interrupt mode */
    if(HAL_TIM_OC_Start_IT(&TIM_CC_HANDLE, TIM_CHANNEL_1) != HAL_OK){
 8001ed0:	2100      	movs	r1, #0
 8001ed2:	481a      	ldr	r0, [pc, #104]	@ (8001f3c <NotifyEventBattery+0x90>)
 8001ed4:	f014 fc52 	bl	801677c <HAL_TIM_OC_Start_IT>
 8001ed8:	4603      	mov	r3, r0
 8001eda:	2b00      	cmp	r3, #0
 8001edc:	d005      	beq.n	8001eea <NotifyEventBattery+0x3e>
      /* Starting Error */
      STBOX1_Error_Handler(STBOX1_ERROR_TIMER,__FILE__,__LINE__);
 8001ede:	f240 1207 	movw	r2, #263	@ 0x107
 8001ee2:	4918      	ldr	r1, [pc, #96]	@ (8001f44 <NotifyEventBattery+0x98>)
 8001ee4:	2006      	movs	r0, #6
 8001ee6:	f002 fca1 	bl	800482c <STBOX1_Error_Handler>
    }

    /* Set the Capture Compare Register value */
    __HAL_TIM_SET_COMPARE(&TIM_CC_HANDLE, TIM_CHANNEL_1, (uhCapture + STBOX1_UPDATE_LED_BATTERY));
 8001eea:	4b14      	ldr	r3, [pc, #80]	@ (8001f3c <NotifyEventBattery+0x90>)
 8001eec:	681a      	ldr	r2, [r3, #0]
 8001eee:	68fb      	ldr	r3, [r7, #12]
 8001ef0:	f503 531c 	add.w	r3, r3, #9984	@ 0x2700
 8001ef4:	3310      	adds	r3, #16
 8001ef6:	6353      	str	r3, [r2, #52]	@ 0x34
    STBOX1_PRINTF("Start Battery\r\n");
 8001ef8:	4813      	ldr	r0, [pc, #76]	@ (8001f48 <NotifyEventBattery+0x9c>)
 8001efa:	f021 ff97 	bl	8023e2c <puts>
      /* Stopping Error */
      STBOX1_Error_Handler(STBOX1_ERROR_TIMER,__FILE__,__LINE__);
    }
    STBOX1_PRINTF("Stop Battery\r\n");
  }
}
 8001efe:	e018      	b.n	8001f32 <NotifyEventBattery+0x86>
  } else if(Event == BLE_NOTIFY_UNSUB) {
 8001f00:	79fb      	ldrb	r3, [r7, #7]
 8001f02:	2b02      	cmp	r3, #2
 8001f04:	d115      	bne.n	8001f32 <NotifyEventBattery+0x86>
    W2ST_OFF_CONNECTION(W2ST_CONNECT_BAT_EVENT);
 8001f06:	4b0e      	ldr	r3, [pc, #56]	@ (8001f40 <NotifyEventBattery+0x94>)
 8001f08:	681b      	ldr	r3, [r3, #0]
 8001f0a:	f023 0310 	bic.w	r3, r3, #16
 8001f0e:	4a0c      	ldr	r2, [pc, #48]	@ (8001f40 <NotifyEventBattery+0x94>)
 8001f10:	6013      	str	r3, [r2, #0]
    if(HAL_TIM_OC_Stop_IT(&TIM_CC_HANDLE, TIM_CHANNEL_1) != HAL_OK){
 8001f12:	2100      	movs	r1, #0
 8001f14:	4809      	ldr	r0, [pc, #36]	@ (8001f3c <NotifyEventBattery+0x90>)
 8001f16:	f014 fdd1 	bl	8016abc <HAL_TIM_OC_Stop_IT>
 8001f1a:	4603      	mov	r3, r0
 8001f1c:	2b00      	cmp	r3, #0
 8001f1e:	d005      	beq.n	8001f2c <NotifyEventBattery+0x80>
      STBOX1_Error_Handler(STBOX1_ERROR_TIMER,__FILE__,__LINE__);
 8001f20:	f240 1213 	movw	r2, #275	@ 0x113
 8001f24:	4907      	ldr	r1, [pc, #28]	@ (8001f44 <NotifyEventBattery+0x98>)
 8001f26:	2006      	movs	r0, #6
 8001f28:	f002 fc80 	bl	800482c <STBOX1_Error_Handler>
    STBOX1_PRINTF("Stop Battery\r\n");
 8001f2c:	4807      	ldr	r0, [pc, #28]	@ (8001f4c <NotifyEventBattery+0xa0>)
 8001f2e:	f021 ff7d 	bl	8023e2c <puts>
}
 8001f32:	bf00      	nop
 8001f34:	3710      	adds	r7, #16
 8001f36:	46bd      	mov	sp, r7
 8001f38:	bd80      	pop	{r7, pc}
 8001f3a:	bf00      	nop
 8001f3c:	20000854 	.word	0x20000854
 8001f40:	200004bc 	.word	0x200004bc
 8001f44:	08026e08 	.word	0x08026e08
 8001f48:	08026f4c 	.word	0x08026f4c
 8001f4c:	08026f5c 	.word	0x08026f5c

08001f50 <NotifyEventEnv>:
 * @brief  Callback Function for Un/Subscription Environmental Feature
 * @param  BLE_NotifyEvent_t Event Sub/Unsub
 * @retval None
 */
void NotifyEventEnv(BLE_NotifyEvent_t Event)
{
 8001f50:	b580      	push	{r7, lr}
 8001f52:	b084      	sub	sp, #16
 8001f54:	af00      	add	r7, sp, #0
 8001f56:	4603      	mov	r3, r0
 8001f58:	71fb      	strb	r3, [r7, #7]
  if(Event == BLE_NOTIFY_SUB){
 8001f5a:	79fb      	ldrb	r3, [r7, #7]
 8001f5c:	2b01      	cmp	r3, #1
 8001f5e:	d149      	bne.n	8001ff4 <NotifyEventEnv+0xa4>

    if(TimerEnvIsRunning==0) {
 8001f60:	4b38      	ldr	r3, [pc, #224]	@ (8002044 <NotifyEventEnv+0xf4>)
 8001f62:	781b      	ldrb	r3, [r3, #0]
 8001f64:	2b00      	cmp	r3, #0
 8001f66:	d141      	bne.n	8001fec <NotifyEventEnv+0x9c>
      uint32_t uhCapture = __HAL_TIM_GET_COUNTER(&TIM_CC_HANDLE);
 8001f68:	4b37      	ldr	r3, [pc, #220]	@ (8002048 <NotifyEventEnv+0xf8>)
 8001f6a:	681b      	ldr	r3, [r3, #0]
 8001f6c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8001f6e:	60fb      	str	r3, [r7, #12]
      W2ST_ON_CONNECTION(W2ST_CONNECT_ENV);
 8001f70:	4b36      	ldr	r3, [pc, #216]	@ (800204c <NotifyEventEnv+0xfc>)
 8001f72:	681b      	ldr	r3, [r3, #0]
 8001f74:	f043 0301 	orr.w	r3, r3, #1
 8001f78:	4a34      	ldr	r2, [pc, #208]	@ (800204c <NotifyEventEnv+0xfc>)
 8001f7a:	6013      	str	r3, [r2, #0]

      /* Start the TIM Base generation in interrupt mode */
      if(HAL_TIM_OC_Start_IT(&TIM_CC_HANDLE, TIM_CHANNEL_2) != HAL_OK){
 8001f7c:	2104      	movs	r1, #4
 8001f7e:	4832      	ldr	r0, [pc, #200]	@ (8002048 <NotifyEventEnv+0xf8>)
 8001f80:	f014 fbfc 	bl	801677c <HAL_TIM_OC_Start_IT>
 8001f84:	4603      	mov	r3, r0
 8001f86:	2b00      	cmp	r3, #0
 8001f88:	d005      	beq.n	8001f96 <NotifyEventEnv+0x46>
        /* Starting Error */
        STBOX1_Error_Handler(STBOX1_ERROR_TIMER,__FILE__,__LINE__);
 8001f8a:	f240 1229 	movw	r2, #297	@ 0x129
 8001f8e:	4930      	ldr	r1, [pc, #192]	@ (8002050 <NotifyEventEnv+0x100>)
 8001f90:	2006      	movs	r0, #6
 8001f92:	f002 fc4b 	bl	800482c <STBOX1_Error_Handler>
      }

      /* Set the Capture Compare Register value */
      switch(CurrentEnvUpdateEnumValue) {
 8001f96:	4b2f      	ldr	r3, [pc, #188]	@ (8002054 <NotifyEventEnv+0x104>)
 8001f98:	681b      	ldr	r3, [r3, #0]
 8001f9a:	2b14      	cmp	r3, #20
 8001f9c:	d015      	beq.n	8001fca <NotifyEventEnv+0x7a>
 8001f9e:	2b14      	cmp	r3, #20
 8001fa0:	dc1a      	bgt.n	8001fd8 <NotifyEventEnv+0x88>
 8001fa2:	2b01      	cmp	r3, #1
 8001fa4:	d002      	beq.n	8001fac <NotifyEventEnv+0x5c>
 8001fa6:	2b0a      	cmp	r3, #10
 8001fa8:	d008      	beq.n	8001fbc <NotifyEventEnv+0x6c>
 8001faa:	e015      	b.n	8001fd8 <NotifyEventEnv+0x88>
        case 1:
          __HAL_TIM_SET_COMPARE(&TIM_CC_HANDLE, TIM_CHANNEL_2, (uhCapture + 10000));
 8001fac:	4b26      	ldr	r3, [pc, #152]	@ (8002048 <NotifyEventEnv+0xf8>)
 8001fae:	681a      	ldr	r2, [r3, #0]
 8001fb0:	68fb      	ldr	r3, [r7, #12]
 8001fb2:	f503 531c 	add.w	r3, r3, #9984	@ 0x2700
 8001fb6:	3310      	adds	r3, #16
 8001fb8:	6393      	str	r3, [r2, #56]	@ 0x38
        break;
 8001fba:	e00d      	b.n	8001fd8 <NotifyEventEnv+0x88>
        case 10:
          __HAL_TIM_SET_COMPARE(&TIM_CC_HANDLE, TIM_CHANNEL_2, (uhCapture + 1000));
 8001fbc:	4b22      	ldr	r3, [pc, #136]	@ (8002048 <NotifyEventEnv+0xf8>)
 8001fbe:	681b      	ldr	r3, [r3, #0]
 8001fc0:	68fa      	ldr	r2, [r7, #12]
 8001fc2:	f502 727a 	add.w	r2, r2, #1000	@ 0x3e8
 8001fc6:	639a      	str	r2, [r3, #56]	@ 0x38
        break;
 8001fc8:	e006      	b.n	8001fd8 <NotifyEventEnv+0x88>
        case 20:
          __HAL_TIM_SET_COMPARE(&TIM_CC_HANDLE, TIM_CHANNEL_2, (uhCapture + 500));
 8001fca:	4b1f      	ldr	r3, [pc, #124]	@ (8002048 <NotifyEventEnv+0xf8>)
 8001fcc:	681b      	ldr	r3, [r3, #0]
 8001fce:	68fa      	ldr	r2, [r7, #12]
 8001fd0:	f502 72fa 	add.w	r2, r2, #500	@ 0x1f4
 8001fd4:	639a      	str	r2, [r3, #56]	@ 0x38
        break;
 8001fd6:	bf00      	nop
      }

      STBOX1_PRINTF("Start Env@%ldHz\r\n",CurrentEnvUpdateEnumValue);
 8001fd8:	4b1e      	ldr	r3, [pc, #120]	@ (8002054 <NotifyEventEnv+0x104>)
 8001fda:	681b      	ldr	r3, [r3, #0]
 8001fdc:	4619      	mov	r1, r3
 8001fde:	481e      	ldr	r0, [pc, #120]	@ (8002058 <NotifyEventEnv+0x108>)
 8001fe0:	f021 febc 	bl	8023d5c <iprintf>
      TimerEnvIsRunning=1;
 8001fe4:	4b17      	ldr	r3, [pc, #92]	@ (8002044 <NotifyEventEnv+0xf4>)
 8001fe6:	2201      	movs	r2, #1
 8001fe8:	701a      	strb	r2, [r3, #0]
      TimerEnvIsRunning=0;
    } else {
      STBOX1_PRINTF("Env Already Stopped\r\n");
    }
  }
}
 8001fea:	e027      	b.n	800203c <NotifyEventEnv+0xec>
      STBOX1_PRINTF("Env Already Started\r\n");
 8001fec:	481b      	ldr	r0, [pc, #108]	@ (800205c <NotifyEventEnv+0x10c>)
 8001fee:	f021 ff1d 	bl	8023e2c <puts>
}
 8001ff2:	e023      	b.n	800203c <NotifyEventEnv+0xec>
  } else if(Event == BLE_NOTIFY_UNSUB) {
 8001ff4:	79fb      	ldrb	r3, [r7, #7]
 8001ff6:	2b02      	cmp	r3, #2
 8001ff8:	d120      	bne.n	800203c <NotifyEventEnv+0xec>
    W2ST_OFF_CONNECTION(W2ST_CONNECT_ENV);
 8001ffa:	4b14      	ldr	r3, [pc, #80]	@ (800204c <NotifyEventEnv+0xfc>)
 8001ffc:	681b      	ldr	r3, [r3, #0]
 8001ffe:	f023 0301 	bic.w	r3, r3, #1
 8002002:	4a12      	ldr	r2, [pc, #72]	@ (800204c <NotifyEventEnv+0xfc>)
 8002004:	6013      	str	r3, [r2, #0]
    if(TimerEnvIsRunning) {
 8002006:	4b0f      	ldr	r3, [pc, #60]	@ (8002044 <NotifyEventEnv+0xf4>)
 8002008:	781b      	ldrb	r3, [r3, #0]
 800200a:	2b00      	cmp	r3, #0
 800200c:	d013      	beq.n	8002036 <NotifyEventEnv+0xe6>
      if(HAL_TIM_OC_Stop_IT(&TIM_CC_HANDLE, TIM_CHANNEL_2) != HAL_OK){
 800200e:	2104      	movs	r1, #4
 8002010:	480d      	ldr	r0, [pc, #52]	@ (8002048 <NotifyEventEnv+0xf8>)
 8002012:	f014 fd53 	bl	8016abc <HAL_TIM_OC_Stop_IT>
 8002016:	4603      	mov	r3, r0
 8002018:	2b00      	cmp	r3, #0
 800201a:	d005      	beq.n	8002028 <NotifyEventEnv+0xd8>
        STBOX1_Error_Handler(STBOX1_ERROR_TIMER,__FILE__,__LINE__);
 800201c:	f44f 72a2 	mov.w	r2, #324	@ 0x144
 8002020:	490b      	ldr	r1, [pc, #44]	@ (8002050 <NotifyEventEnv+0x100>)
 8002022:	2006      	movs	r0, #6
 8002024:	f002 fc02 	bl	800482c <STBOX1_Error_Handler>
      STBOX1_PRINTF("Stop Env\r\n");
 8002028:	480d      	ldr	r0, [pc, #52]	@ (8002060 <NotifyEventEnv+0x110>)
 800202a:	f021 feff 	bl	8023e2c <puts>
      TimerEnvIsRunning=0;
 800202e:	4b05      	ldr	r3, [pc, #20]	@ (8002044 <NotifyEventEnv+0xf4>)
 8002030:	2200      	movs	r2, #0
 8002032:	701a      	strb	r2, [r3, #0]
}
 8002034:	e002      	b.n	800203c <NotifyEventEnv+0xec>
      STBOX1_PRINTF("Env Already Stopped\r\n");
 8002036:	480b      	ldr	r0, [pc, #44]	@ (8002064 <NotifyEventEnv+0x114>)
 8002038:	f021 fef8 	bl	8023e2c <puts>
}
 800203c:	bf00      	nop
 800203e:	3710      	adds	r7, #16
 8002040:	46bd      	mov	sp, r7
 8002042:	bd80      	pop	{r7, pc}
 8002044:	200004c4 	.word	0x200004c4
 8002048:	20000854 	.word	0x20000854
 800204c:	200004bc 	.word	0x200004bc
 8002050:	08026e08 	.word	0x08026e08
 8002054:	20000000 	.word	0x20000000
 8002058:	08026f6c 	.word	0x08026f6c
 800205c:	08026f80 	.word	0x08026f80
 8002060:	08026f98 	.word	0x08026f98
 8002064:	08026fa4 	.word	0x08026fa4

08002068 <NotifyEventInertial>:
 * @brief  Callback Function for Un/Subscription Inertial Feature
 * @param  BLE_NotifyEvent_t Event Sub/Unsub
 * @retval None
 */
void NotifyEventInertial(BLE_NotifyEvent_t Event)
{
 8002068:	b580      	push	{r7, lr}
 800206a:	b084      	sub	sp, #16
 800206c:	af00      	add	r7, sp, #0
 800206e:	4603      	mov	r3, r0
 8002070:	71fb      	strb	r3, [r7, #7]
  if(Event == BLE_NOTIFY_SUB){
 8002072:	79fb      	ldrb	r3, [r7, #7]
 8002074:	2b01      	cmp	r3, #1
 8002076:	d148      	bne.n	800210a <NotifyEventInertial+0xa2>
    W2ST_ON_CONNECTION(W2ST_CONNECT_ACC_GYRO_MAG);
 8002078:	4b38      	ldr	r3, [pc, #224]	@ (800215c <NotifyEventInertial+0xf4>)
 800207a:	681b      	ldr	r3, [r3, #0]
 800207c:	f043 0302 	orr.w	r3, r3, #2
 8002080:	4a36      	ldr	r2, [pc, #216]	@ (800215c <NotifyEventInertial+0xf4>)
 8002082:	6013      	str	r3, [r2, #0]
    if(TimerInerIsRunning==0) {
 8002084:	4b36      	ldr	r3, [pc, #216]	@ (8002160 <NotifyEventInertial+0xf8>)
 8002086:	781b      	ldrb	r3, [r3, #0]
 8002088:	2b00      	cmp	r3, #0
 800208a:	d13a      	bne.n	8002102 <NotifyEventInertial+0x9a>
      uint32_t uhCapture = __HAL_TIM_GET_COUNTER(&TIM_CC_HANDLE);
 800208c:	4b35      	ldr	r3, [pc, #212]	@ (8002164 <NotifyEventInertial+0xfc>)
 800208e:	681b      	ldr	r3, [r3, #0]
 8002090:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8002092:	60fb      	str	r3, [r7, #12]

      /* Start the TIM Base generation in interrupt mode */
      if(HAL_TIM_OC_Start_IT(&TIM_CC_HANDLE, TIM_CHANNEL_3) != HAL_OK){
 8002094:	2108      	movs	r1, #8
 8002096:	4833      	ldr	r0, [pc, #204]	@ (8002164 <NotifyEventInertial+0xfc>)
 8002098:	f014 fb70 	bl	801677c <HAL_TIM_OC_Start_IT>
 800209c:	4603      	mov	r3, r0
 800209e:	2b00      	cmp	r3, #0
 80020a0:	d005      	beq.n	80020ae <NotifyEventInertial+0x46>
        /* Starting Error */
        STBOX1_Error_Handler(STBOX1_ERROR_TIMER,__FILE__,__LINE__);
 80020a2:	f240 126d 	movw	r2, #365	@ 0x16d
 80020a6:	4930      	ldr	r1, [pc, #192]	@ (8002168 <NotifyEventInertial+0x100>)
 80020a8:	2006      	movs	r0, #6
 80020aa:	f002 fbbf 	bl	800482c <STBOX1_Error_Handler>
      }

      /* Set the Capture Compare Register value */
      switch(CurrentInerUpdateEnumValue) {
 80020ae:	4b2f      	ldr	r3, [pc, #188]	@ (800216c <NotifyEventInertial+0x104>)
 80020b0:	681b      	ldr	r3, [r3, #0]
 80020b2:	2b1e      	cmp	r3, #30
 80020b4:	d014      	beq.n	80020e0 <NotifyEventInertial+0x78>
 80020b6:	2b1e      	cmp	r3, #30
 80020b8:	dc19      	bgt.n	80020ee <NotifyEventInertial+0x86>
 80020ba:	2b0a      	cmp	r3, #10
 80020bc:	d002      	beq.n	80020c4 <NotifyEventInertial+0x5c>
 80020be:	2b14      	cmp	r3, #20
 80020c0:	d007      	beq.n	80020d2 <NotifyEventInertial+0x6a>
 80020c2:	e014      	b.n	80020ee <NotifyEventInertial+0x86>
        case 10:
          __HAL_TIM_SET_COMPARE(&TIM_CC_HANDLE, TIM_CHANNEL_3, (uhCapture + 1000));
 80020c4:	4b27      	ldr	r3, [pc, #156]	@ (8002164 <NotifyEventInertial+0xfc>)
 80020c6:	681b      	ldr	r3, [r3, #0]
 80020c8:	68fa      	ldr	r2, [r7, #12]
 80020ca:	f502 727a 	add.w	r2, r2, #1000	@ 0x3e8
 80020ce:	63da      	str	r2, [r3, #60]	@ 0x3c
        break;
 80020d0:	e00d      	b.n	80020ee <NotifyEventInertial+0x86>
        case 20:
          __HAL_TIM_SET_COMPARE(&TIM_CC_HANDLE, TIM_CHANNEL_3, (uhCapture + 500));
 80020d2:	4b24      	ldr	r3, [pc, #144]	@ (8002164 <NotifyEventInertial+0xfc>)
 80020d4:	681b      	ldr	r3, [r3, #0]
 80020d6:	68fa      	ldr	r2, [r7, #12]
 80020d8:	f502 72fa 	add.w	r2, r2, #500	@ 0x1f4
 80020dc:	63da      	str	r2, [r3, #60]	@ 0x3c
        break;
 80020de:	e006      	b.n	80020ee <NotifyEventInertial+0x86>
        case 30:
          __HAL_TIM_SET_COMPARE(&TIM_CC_HANDLE, TIM_CHANNEL_3, (uhCapture + 333));
 80020e0:	4b20      	ldr	r3, [pc, #128]	@ (8002164 <NotifyEventInertial+0xfc>)
 80020e2:	681b      	ldr	r3, [r3, #0]
 80020e4:	68fa      	ldr	r2, [r7, #12]
 80020e6:	f202 124d 	addw	r2, r2, #333	@ 0x14d
 80020ea:	63da      	str	r2, [r3, #60]	@ 0x3c
        break;
 80020ec:	bf00      	nop
      }

      STBOX1_PRINTF("Start Iner@%ldHz\r\n",CurrentInerUpdateEnumValue);
 80020ee:	4b1f      	ldr	r3, [pc, #124]	@ (800216c <NotifyEventInertial+0x104>)
 80020f0:	681b      	ldr	r3, [r3, #0]
 80020f2:	4619      	mov	r1, r3
 80020f4:	481e      	ldr	r0, [pc, #120]	@ (8002170 <NotifyEventInertial+0x108>)
 80020f6:	f021 fe31 	bl	8023d5c <iprintf>
      TimerInerIsRunning=1;
 80020fa:	4b19      	ldr	r3, [pc, #100]	@ (8002160 <NotifyEventInertial+0xf8>)
 80020fc:	2201      	movs	r2, #1
 80020fe:	701a      	strb	r2, [r3, #0]
      TimerInerIsRunning=0;
    } else {
      STBOX1_PRINTF("Iner Already Stopped\r\n");
    }
  }
}
 8002100:	e027      	b.n	8002152 <NotifyEventInertial+0xea>
      STBOX1_PRINTF("Iner Already Started\r\n");
 8002102:	481c      	ldr	r0, [pc, #112]	@ (8002174 <NotifyEventInertial+0x10c>)
 8002104:	f021 fe92 	bl	8023e2c <puts>
}
 8002108:	e023      	b.n	8002152 <NotifyEventInertial+0xea>
  } else if(Event == BLE_NOTIFY_UNSUB) {
 800210a:	79fb      	ldrb	r3, [r7, #7]
 800210c:	2b02      	cmp	r3, #2
 800210e:	d120      	bne.n	8002152 <NotifyEventInertial+0xea>
    W2ST_OFF_CONNECTION(W2ST_CONNECT_ACC_GYRO_MAG);
 8002110:	4b12      	ldr	r3, [pc, #72]	@ (800215c <NotifyEventInertial+0xf4>)
 8002112:	681b      	ldr	r3, [r3, #0]
 8002114:	f023 0302 	bic.w	r3, r3, #2
 8002118:	4a10      	ldr	r2, [pc, #64]	@ (800215c <NotifyEventInertial+0xf4>)
 800211a:	6013      	str	r3, [r2, #0]
     if(TimerInerIsRunning) {
 800211c:	4b10      	ldr	r3, [pc, #64]	@ (8002160 <NotifyEventInertial+0xf8>)
 800211e:	781b      	ldrb	r3, [r3, #0]
 8002120:	2b00      	cmp	r3, #0
 8002122:	d013      	beq.n	800214c <NotifyEventInertial+0xe4>
      if(HAL_TIM_OC_Stop_IT(&TIM_CC_HANDLE, TIM_CHANNEL_3) != HAL_OK){
 8002124:	2108      	movs	r1, #8
 8002126:	480f      	ldr	r0, [pc, #60]	@ (8002164 <NotifyEventInertial+0xfc>)
 8002128:	f014 fcc8 	bl	8016abc <HAL_TIM_OC_Stop_IT>
 800212c:	4603      	mov	r3, r0
 800212e:	2b00      	cmp	r3, #0
 8002130:	d005      	beq.n	800213e <NotifyEventInertial+0xd6>
        STBOX1_Error_Handler(STBOX1_ERROR_TIMER,__FILE__,__LINE__);
 8002132:	f240 1289 	movw	r2, #393	@ 0x189
 8002136:	490c      	ldr	r1, [pc, #48]	@ (8002168 <NotifyEventInertial+0x100>)
 8002138:	2006      	movs	r0, #6
 800213a:	f002 fb77 	bl	800482c <STBOX1_Error_Handler>
      STBOX1_PRINTF("Stop Iner\r\n");
 800213e:	480e      	ldr	r0, [pc, #56]	@ (8002178 <NotifyEventInertial+0x110>)
 8002140:	f021 fe74 	bl	8023e2c <puts>
      TimerInerIsRunning=0;
 8002144:	4b06      	ldr	r3, [pc, #24]	@ (8002160 <NotifyEventInertial+0xf8>)
 8002146:	2200      	movs	r2, #0
 8002148:	701a      	strb	r2, [r3, #0]
}
 800214a:	e002      	b.n	8002152 <NotifyEventInertial+0xea>
      STBOX1_PRINTF("Iner Already Stopped\r\n");
 800214c:	480b      	ldr	r0, [pc, #44]	@ (800217c <NotifyEventInertial+0x114>)
 800214e:	f021 fe6d 	bl	8023e2c <puts>
}
 8002152:	bf00      	nop
 8002154:	3710      	adds	r7, #16
 8002156:	46bd      	mov	sp, r7
 8002158:	bd80      	pop	{r7, pc}
 800215a:	bf00      	nop
 800215c:	200004bc 	.word	0x200004bc
 8002160:	200004c5 	.word	0x200004c5
 8002164:	20000854 	.word	0x20000854
 8002168:	08026e08 	.word	0x08026e08
 800216c:	20000004 	.word	0x20000004
 8002170:	08026fe8 	.word	0x08026fe8
 8002174:	08026ffc 	.word	0x08026ffc
 8002178:	08027014 	.word	0x08027014
 800217c:	08027020 	.word	0x08027020

08002180 <DebugConsoleParsing>:
* @param  uint8_t *att_data attribute data
* @param  uint8_t data_length length of the data
* @retval uint32_t SendBackData true/false
*/
uint32_t DebugConsoleParsing(uint8_t * att_data, uint8_t data_length)
{
 8002180:	b580      	push	{r7, lr}
 8002182:	b084      	sub	sp, #16
 8002184:	af00      	add	r7, sp, #0
 8002186:	6078      	str	r0, [r7, #4]
 8002188:	460b      	mov	r3, r1
 800218a:	70fb      	strb	r3, [r7, #3]
  /* By default Answer with the same message received */
  uint32_t SendBackData =1;
 800218c:	2301      	movs	r3, #1
 800218e:	60fb      	str	r3, [r7, #12]

 if(SizeOfUpdateBlueFW!=0) {
 8002190:	4b19      	ldr	r3, [pc, #100]	@ (80021f8 <DebugConsoleParsing+0x78>)
 8002192:	681b      	ldr	r3, [r3, #0]
 8002194:	2b00      	cmp	r3, #0
 8002196:	d023      	beq.n	80021e0 <DebugConsoleParsing+0x60>
    /* Firwmare update */
    int8_t RetValue = UpdateFWBlueMS(&SizeOfUpdateBlueFW,att_data, data_length,1);
 8002198:	78fa      	ldrb	r2, [r7, #3]
 800219a:	2301      	movs	r3, #1
 800219c:	6879      	ldr	r1, [r7, #4]
 800219e:	4816      	ldr	r0, [pc, #88]	@ (80021f8 <DebugConsoleParsing+0x78>)
 80021a0:	f001 fb90 	bl	80038c4 <UpdateFWBlueMS>
 80021a4:	4603      	mov	r3, r0
 80021a6:	72fb      	strb	r3, [r7, #11]
    if(RetValue!=0) {
 80021a8:	f997 300b 	ldrsb.w	r3, [r7, #11]
 80021ac:	2b00      	cmp	r3, #0
 80021ae:	d014      	beq.n	80021da <DebugConsoleParsing+0x5a>
      Term_Update(((uint8_t *)&RetValue),1);
 80021b0:	f107 030b 	add.w	r3, r7, #11
 80021b4:	2101      	movs	r1, #1
 80021b6:	4618      	mov	r0, r3
 80021b8:	f01b fc24 	bl	801da04 <Term_Update>
      if(RetValue==1) {
 80021bc:	f997 300b 	ldrsb.w	r3, [r7, #11]
 80021c0:	2b01      	cmp	r3, #1
 80021c2:	d10a      	bne.n	80021da <DebugConsoleParsing+0x5a>
        /* if OTA checked */
        STBOX1_PRINTF("%s will restart after the disconnection\r\n",STBOX1_PACKAGENAME);
 80021c4:	490d      	ldr	r1, [pc, #52]	@ (80021fc <DebugConsoleParsing+0x7c>)
 80021c6:	480e      	ldr	r0, [pc, #56]	@ (8002200 <DebugConsoleParsing+0x80>)
 80021c8:	f021 fdc8 	bl	8023d5c <iprintf>
        HAL_Delay(1000);
 80021cc:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
 80021d0:	f002 fb14 	bl	80047fc <HAL_Delay>
        NeedToSwapBanks=1;
 80021d4:	4b0b      	ldr	r3, [pc, #44]	@ (8002204 <DebugConsoleParsing+0x84>)
 80021d6:	2201      	movs	r2, #1
 80021d8:	601a      	str	r2, [r3, #0]
      }
    }
    SendBackData=0;
 80021da:	2300      	movs	r3, #0
 80021dc:	60fb      	str	r3, [r7, #12]
 80021de:	e005      	b.n	80021ec <DebugConsoleParsing+0x6c>
  } else {
    /* Received one write from Client on Terminal characteristc */
    SendBackData = DebugConsoleCommandParsing(att_data,data_length);
 80021e0:	78fb      	ldrb	r3, [r7, #3]
 80021e2:	4619      	mov	r1, r3
 80021e4:	6878      	ldr	r0, [r7, #4]
 80021e6:	f000 f80f 	bl	8002208 <DebugConsoleCommandParsing>
 80021ea:	60f8      	str	r0, [r7, #12]
  }

  return SendBackData;
 80021ec:	68fb      	ldr	r3, [r7, #12]
}
 80021ee:	4618      	mov	r0, r3
 80021f0:	3710      	adds	r7, #16
 80021f2:	46bd      	mov	sp, r7
 80021f4:	bd80      	pop	{r7, pc}
 80021f6:	bf00      	nop
 80021f8:	200004c0 	.word	0x200004c0
 80021fc:	08027038 	.word	0x08027038
 8002200:	08027048 	.word	0x08027048
 8002204:	200004d4 	.word	0x200004d4

08002208 <DebugConsoleCommandParsing>:
 * @param  uint8_t *att_data attribute data
 * @param  uint8_t data_length length of the data
 * @retval uint32_t SendBackData true/false
 */
uint32_t DebugConsoleCommandParsing(uint8_t * att_data, uint8_t data_length)
{
 8002208:	b5f0      	push	{r4, r5, r6, r7, lr}
 800220a:	b099      	sub	sp, #100	@ 0x64
 800220c:	af0c      	add	r7, sp, #48	@ 0x30
 800220e:	6178      	str	r0, [r7, #20]
 8002210:	460b      	mov	r3, r1
 8002212:	74fb      	strb	r3, [r7, #19]
  uint32_t SendBackData = 1;
 8002214:	2301      	movs	r3, #1
 8002216:	62fb      	str	r3, [r7, #44]	@ 0x2c

  /* Help Command */
  if(!strncmp("help",(char *)(att_data),4)) {
 8002218:	2204      	movs	r2, #4
 800221a:	6979      	ldr	r1, [r7, #20]
 800221c:	4891      	ldr	r0, [pc, #580]	@ (8002464 <DebugConsoleCommandParsing+0x25c>)
 800221e:	f021 ff36 	bl	802408e <strncmp>
 8002222:	4603      	mov	r3, r0
 8002224:	2b00      	cmp	r3, #0
 8002226:	d110      	bne.n	800224a <DebugConsoleCommandParsing+0x42>
    /* Print Legend */
    SendBackData=0;
 8002228:	2300      	movs	r3, #0
 800222a:	62fb      	str	r3, [r7, #44]	@ 0x2c

    BytesToWrite =sprintf((char *)BufferToWrite,
 800222c:	498e      	ldr	r1, [pc, #568]	@ (8002468 <DebugConsoleCommandParsing+0x260>)
 800222e:	488f      	ldr	r0, [pc, #572]	@ (800246c <DebugConsoleCommandParsing+0x264>)
 8002230:	f021 fe04 	bl	8023e3c <siprintf>
 8002234:	4603      	mov	r3, r0
 8002236:	b2da      	uxtb	r2, r3
 8002238:	4b8d      	ldr	r3, [pc, #564]	@ (8002470 <DebugConsoleCommandParsing+0x268>)
 800223a:	701a      	strb	r2, [r3, #0]
                          "info\n");
    Term_Update(BufferToWrite,BytesToWrite);
 800223c:	4b8c      	ldr	r3, [pc, #560]	@ (8002470 <DebugConsoleCommandParsing+0x268>)
 800223e:	781b      	ldrb	r3, [r3, #0]
 8002240:	4619      	mov	r1, r3
 8002242:	488a      	ldr	r0, [pc, #552]	@ (800246c <DebugConsoleCommandParsing+0x264>)
 8002244:	f01b fbde 	bl	801da04 <Term_Update>
 8002248:	e194      	b.n	8002574 <DebugConsoleCommandParsing+0x36c>
  } else if(!strncmp("versionFw",(char *)(att_data),9)) {
 800224a:	2209      	movs	r2, #9
 800224c:	6979      	ldr	r1, [r7, #20]
 800224e:	4889      	ldr	r0, [pc, #548]	@ (8002474 <DebugConsoleCommandParsing+0x26c>)
 8002250:	f021 ff1d 	bl	802408e <strncmp>
 8002254:	4603      	mov	r3, r0
 8002256:	2b00      	cmp	r3, #0
 8002258:	d118      	bne.n	800228c <DebugConsoleCommandParsing+0x84>
    BytesToWrite =sprintf((char *)BufferToWrite,"%s_%s_%c.%c.%c\r\n",
 800225a:	2330      	movs	r3, #48	@ 0x30
 800225c:	9302      	str	r3, [sp, #8]
 800225e:	2330      	movs	r3, #48	@ 0x30
 8002260:	9301      	str	r3, [sp, #4]
 8002262:	2332      	movs	r3, #50	@ 0x32
 8002264:	9300      	str	r3, [sp, #0]
 8002266:	4b84      	ldr	r3, [pc, #528]	@ (8002478 <DebugConsoleCommandParsing+0x270>)
 8002268:	4a84      	ldr	r2, [pc, #528]	@ (800247c <DebugConsoleCommandParsing+0x274>)
 800226a:	4985      	ldr	r1, [pc, #532]	@ (8002480 <DebugConsoleCommandParsing+0x278>)
 800226c:	487f      	ldr	r0, [pc, #508]	@ (800246c <DebugConsoleCommandParsing+0x264>)
 800226e:	f021 fde5 	bl	8023e3c <siprintf>
 8002272:	4603      	mov	r3, r0
 8002274:	b2da      	uxtb	r2, r3
 8002276:	4b7e      	ldr	r3, [pc, #504]	@ (8002470 <DebugConsoleCommandParsing+0x268>)
 8002278:	701a      	strb	r2, [r3, #0]
                          "U585",
                          STBOX1_PACKAGENAME,
                          STBOX1_VERSION_MAJOR,
                          STBOX1_VERSION_MINOR,
                          STBOX1_VERSION_PATCH);
    Term_Update(BufferToWrite,BytesToWrite);
 800227a:	4b7d      	ldr	r3, [pc, #500]	@ (8002470 <DebugConsoleCommandParsing+0x268>)
 800227c:	781b      	ldrb	r3, [r3, #0]
 800227e:	4619      	mov	r1, r3
 8002280:	487a      	ldr	r0, [pc, #488]	@ (800246c <DebugConsoleCommandParsing+0x264>)
 8002282:	f01b fbbf 	bl	801da04 <Term_Update>
    SendBackData=0;
 8002286:	2300      	movs	r3, #0
 8002288:	62fb      	str	r3, [r7, #44]	@ 0x2c
 800228a:	e173      	b.n	8002574 <DebugConsoleCommandParsing+0x36c>
  } else if(!strncmp("info",(char *)(att_data),4)) {
 800228c:	2204      	movs	r2, #4
 800228e:	6979      	ldr	r1, [r7, #20]
 8002290:	487c      	ldr	r0, [pc, #496]	@ (8002484 <DebugConsoleCommandParsing+0x27c>)
 8002292:	f021 fefc 	bl	802408e <strncmp>
 8002296:	4603      	mov	r3, r0
 8002298:	2b00      	cmp	r3, #0
 800229a:	d157      	bne.n	800234c <DebugConsoleCommandParsing+0x144>
    SendBackData=0;
 800229c:	2300      	movs	r3, #0
 800229e:	62fb      	str	r3, [r7, #44]	@ 0x2c
       "\tVersion %c.%c.%c\n"
      "\tSTM32U585AI-SensorTile.box-Pro  (%c) board"
        "\n",
        STBOX1_PACKAGENAME,
        STBOX1_VERSION_MAJOR,STBOX1_VERSION_MINOR,STBOX1_VERSION_PATCH,
        (FinishGood==FINISHA) ? 'A' : 'B');
 80022a0:	4b79      	ldr	r3, [pc, #484]	@ (8002488 <DebugConsoleCommandParsing+0x280>)
 80022a2:	781b      	ldrb	r3, [r3, #0]
    BytesToWrite =sprintf((char *)BufferToWrite,"\r\nSTMicroelectronics %s:\n"
 80022a4:	2b00      	cmp	r3, #0
 80022a6:	d101      	bne.n	80022ac <DebugConsoleCommandParsing+0xa4>
 80022a8:	2341      	movs	r3, #65	@ 0x41
 80022aa:	e000      	b.n	80022ae <DebugConsoleCommandParsing+0xa6>
 80022ac:	2342      	movs	r3, #66	@ 0x42
 80022ae:	9302      	str	r3, [sp, #8]
 80022b0:	2330      	movs	r3, #48	@ 0x30
 80022b2:	9301      	str	r3, [sp, #4]
 80022b4:	2330      	movs	r3, #48	@ 0x30
 80022b6:	9300      	str	r3, [sp, #0]
 80022b8:	2332      	movs	r3, #50	@ 0x32
 80022ba:	4a6f      	ldr	r2, [pc, #444]	@ (8002478 <DebugConsoleCommandParsing+0x270>)
 80022bc:	4973      	ldr	r1, [pc, #460]	@ (800248c <DebugConsoleCommandParsing+0x284>)
 80022be:	486b      	ldr	r0, [pc, #428]	@ (800246c <DebugConsoleCommandParsing+0x264>)
 80022c0:	f021 fdbc 	bl	8023e3c <siprintf>
 80022c4:	4603      	mov	r3, r0
 80022c6:	b2da      	uxtb	r2, r3
 80022c8:	4b69      	ldr	r3, [pc, #420]	@ (8002470 <DebugConsoleCommandParsing+0x268>)
 80022ca:	701a      	strb	r2, [r3, #0]
    Term_Update(BufferToWrite,BytesToWrite);
 80022cc:	4b68      	ldr	r3, [pc, #416]	@ (8002470 <DebugConsoleCommandParsing+0x268>)
 80022ce:	781b      	ldrb	r3, [r3, #0]
 80022d0:	4619      	mov	r1, r3
 80022d2:	4866      	ldr	r0, [pc, #408]	@ (800246c <DebugConsoleCommandParsing+0x264>)
 80022d4:	f01b fb96 	bl	801da04 <Term_Update>
#elif defined (__ARMCC_VERSION)
      " (KEIL)\r\n",
#elif defined (__GNUC__)
      " (STM32CubeIDE)\r\n",
#endif
        HAL_GetHalVersion() >>24,
 80022d8:	f00b fbce 	bl	800da78 <HAL_GetHalVersion>
 80022dc:	4603      	mov	r3, r0
    BytesToWrite =sprintf((char *)BufferToWrite,"\t(HAL %ld.%ld.%ld_%ld)\n"
 80022de:	0e1d      	lsrs	r5, r3, #24
        (HAL_GetHalVersion() >>16)&0xFF,
 80022e0:	f00b fbca 	bl	800da78 <HAL_GetHalVersion>
 80022e4:	4603      	mov	r3, r0
 80022e6:	0c1b      	lsrs	r3, r3, #16
    BytesToWrite =sprintf((char *)BufferToWrite,"\t(HAL %ld.%ld.%ld_%ld)\n"
 80022e8:	b2de      	uxtb	r6, r3
        (HAL_GetHalVersion() >> 8)&0xFF,
 80022ea:	f00b fbc5 	bl	800da78 <HAL_GetHalVersion>
 80022ee:	4603      	mov	r3, r0
 80022f0:	0a1b      	lsrs	r3, r3, #8
    BytesToWrite =sprintf((char *)BufferToWrite,"\t(HAL %ld.%ld.%ld_%ld)\n"
 80022f2:	b2dc      	uxtb	r4, r3
         HAL_GetHalVersion()      &0xFF,
 80022f4:	f00b fbc0 	bl	800da78 <HAL_GetHalVersion>
 80022f8:	4603      	mov	r3, r0
    BytesToWrite =sprintf((char *)BufferToWrite,"\t(HAL %ld.%ld.%ld_%ld)\n"
 80022fa:	b2db      	uxtb	r3, r3
 80022fc:	4a64      	ldr	r2, [pc, #400]	@ (8002490 <DebugConsoleCommandParsing+0x288>)
 80022fe:	9203      	str	r2, [sp, #12]
 8002300:	4a64      	ldr	r2, [pc, #400]	@ (8002494 <DebugConsoleCommandParsing+0x28c>)
 8002302:	9202      	str	r2, [sp, #8]
 8002304:	9301      	str	r3, [sp, #4]
 8002306:	9400      	str	r4, [sp, #0]
 8002308:	4633      	mov	r3, r6
 800230a:	462a      	mov	r2, r5
 800230c:	4962      	ldr	r1, [pc, #392]	@ (8002498 <DebugConsoleCommandParsing+0x290>)
 800230e:	4857      	ldr	r0, [pc, #348]	@ (800246c <DebugConsoleCommandParsing+0x264>)
 8002310:	f021 fd94 	bl	8023e3c <siprintf>
 8002314:	4603      	mov	r3, r0
 8002316:	b2da      	uxtb	r2, r3
 8002318:	4b55      	ldr	r3, [pc, #340]	@ (8002470 <DebugConsoleCommandParsing+0x268>)
 800231a:	701a      	strb	r2, [r3, #0]
         __DATE__,__TIME__);
    Term_Update(BufferToWrite,BytesToWrite);
 800231c:	4b54      	ldr	r3, [pc, #336]	@ (8002470 <DebugConsoleCommandParsing+0x268>)
 800231e:	781b      	ldrb	r3, [r3, #0]
 8002320:	4619      	mov	r1, r3
 8002322:	4852      	ldr	r0, [pc, #328]	@ (800246c <DebugConsoleCommandParsing+0x264>)
 8002324:	f01b fb6e 	bl	801da04 <Term_Update>
    BytesToWrite =sprintf((char *)BufferToWrite,"Current Bank =%ld\n",CurrentActiveBank);
 8002328:	4b5c      	ldr	r3, [pc, #368]	@ (800249c <DebugConsoleCommandParsing+0x294>)
 800232a:	681b      	ldr	r3, [r3, #0]
 800232c:	461a      	mov	r2, r3
 800232e:	495c      	ldr	r1, [pc, #368]	@ (80024a0 <DebugConsoleCommandParsing+0x298>)
 8002330:	484e      	ldr	r0, [pc, #312]	@ (800246c <DebugConsoleCommandParsing+0x264>)
 8002332:	f021 fd83 	bl	8023e3c <siprintf>
 8002336:	4603      	mov	r3, r0
 8002338:	b2da      	uxtb	r2, r3
 800233a:	4b4d      	ldr	r3, [pc, #308]	@ (8002470 <DebugConsoleCommandParsing+0x268>)
 800233c:	701a      	strb	r2, [r3, #0]
    Term_Update(BufferToWrite,BytesToWrite);
 800233e:	4b4c      	ldr	r3, [pc, #304]	@ (8002470 <DebugConsoleCommandParsing+0x268>)
 8002340:	781b      	ldrb	r3, [r3, #0]
 8002342:	4619      	mov	r1, r3
 8002344:	4849      	ldr	r0, [pc, #292]	@ (800246c <DebugConsoleCommandParsing+0x264>)
 8002346:	f01b fb5d 	bl	801da04 <Term_Update>
 800234a:	e113      	b.n	8002574 <DebugConsoleCommandParsing+0x36c>
  } else if(!strncmp("upgradeFw",(char *)(att_data),9)) {
 800234c:	2209      	movs	r2, #9
 800234e:	6979      	ldr	r1, [r7, #20]
 8002350:	4854      	ldr	r0, [pc, #336]	@ (80024a4 <DebugConsoleCommandParsing+0x29c>)
 8002352:	f021 fe9c 	bl	802408e <strncmp>
 8002356:	4603      	mov	r3, r0
 8002358:	2b00      	cmp	r3, #0
 800235a:	f040 80ab 	bne.w	80024b4 <DebugConsoleCommandParsing+0x2ac>
    uint32_t uwCRCValue;
    uint8_t *PointerByte = (uint8_t*) &SizeOfUpdateBlueFW;
 800235e:	4b52      	ldr	r3, [pc, #328]	@ (80024a8 <DebugConsoleCommandParsing+0x2a0>)
 8002360:	623b      	str	r3, [r7, #32]

    PointerByte[0]=att_data[ 9];
 8002362:	697b      	ldr	r3, [r7, #20]
 8002364:	7a5a      	ldrb	r2, [r3, #9]
 8002366:	6a3b      	ldr	r3, [r7, #32]
 8002368:	701a      	strb	r2, [r3, #0]
    PointerByte[1]=att_data[10];
 800236a:	6a3b      	ldr	r3, [r7, #32]
 800236c:	3301      	adds	r3, #1
 800236e:	697a      	ldr	r2, [r7, #20]
 8002370:	7a92      	ldrb	r2, [r2, #10]
 8002372:	701a      	strb	r2, [r3, #0]
    PointerByte[2]=att_data[11];
 8002374:	6a3b      	ldr	r3, [r7, #32]
 8002376:	3302      	adds	r3, #2
 8002378:	697a      	ldr	r2, [r7, #20]
 800237a:	7ad2      	ldrb	r2, [r2, #11]
 800237c:	701a      	strb	r2, [r3, #0]
    PointerByte[3]=att_data[12];
 800237e:	6a3b      	ldr	r3, [r7, #32]
 8002380:	3303      	adds	r3, #3
 8002382:	697a      	ldr	r2, [r7, #20]
 8002384:	7b12      	ldrb	r2, [r2, #12]
 8002386:	701a      	strb	r2, [r3, #0]

    /* Check the Maximum Possible OTA size */
    if(SizeOfUpdateBlueFW>OTA_MAX_PROG_SIZE) {
 8002388:	4b47      	ldr	r3, [pc, #284]	@ (80024a8 <DebugConsoleCommandParsing+0x2a0>)
 800238a:	681b      	ldr	r3, [r3, #0]
 800238c:	f5b3 2f7e 	cmp.w	r3, #1040384	@ 0xfe000
 8002390:	d928      	bls.n	80023e4 <DebugConsoleCommandParsing+0x1dc>
      STBOX1_PRINTF("OTA %s SIZE=%ld > %d Max Allowed\r\n",STBOX1_PACKAGENAME,SizeOfUpdateBlueFW, OTA_MAX_PROG_SIZE);
 8002392:	4b45      	ldr	r3, [pc, #276]	@ (80024a8 <DebugConsoleCommandParsing+0x2a0>)
 8002394:	681a      	ldr	r2, [r3, #0]
 8002396:	f44f 237e 	mov.w	r3, #1040384	@ 0xfe000
 800239a:	4937      	ldr	r1, [pc, #220]	@ (8002478 <DebugConsoleCommandParsing+0x270>)
 800239c:	4843      	ldr	r0, [pc, #268]	@ (80024ac <DebugConsoleCommandParsing+0x2a4>)
 800239e:	f021 fcdd 	bl	8023d5c <iprintf>
      /* Answer with a wrong CRC value for signaling the problem to BlueMS application */
      BufferToWrite[0]= att_data[13];
 80023a2:	697b      	ldr	r3, [r7, #20]
 80023a4:	7b5a      	ldrb	r2, [r3, #13]
 80023a6:	4b31      	ldr	r3, [pc, #196]	@ (800246c <DebugConsoleCommandParsing+0x264>)
 80023a8:	701a      	strb	r2, [r3, #0]
      BufferToWrite[1]=(att_data[14]!=0) ? 0 : 1;/* In order to be sure to have a wrong CRC */
 80023aa:	697b      	ldr	r3, [r7, #20]
 80023ac:	330e      	adds	r3, #14
 80023ae:	781b      	ldrb	r3, [r3, #0]
 80023b0:	2b00      	cmp	r3, #0
 80023b2:	bf0c      	ite	eq
 80023b4:	2301      	moveq	r3, #1
 80023b6:	2300      	movne	r3, #0
 80023b8:	b2db      	uxtb	r3, r3
 80023ba:	461a      	mov	r2, r3
 80023bc:	4b2b      	ldr	r3, [pc, #172]	@ (800246c <DebugConsoleCommandParsing+0x264>)
 80023be:	705a      	strb	r2, [r3, #1]
      BufferToWrite[2]= att_data[15];
 80023c0:	697b      	ldr	r3, [r7, #20]
 80023c2:	7bda      	ldrb	r2, [r3, #15]
 80023c4:	4b29      	ldr	r3, [pc, #164]	@ (800246c <DebugConsoleCommandParsing+0x264>)
 80023c6:	709a      	strb	r2, [r3, #2]
      BufferToWrite[3]= att_data[16];
 80023c8:	697b      	ldr	r3, [r7, #20]
 80023ca:	7c1a      	ldrb	r2, [r3, #16]
 80023cc:	4b27      	ldr	r3, [pc, #156]	@ (800246c <DebugConsoleCommandParsing+0x264>)
 80023ce:	70da      	strb	r2, [r3, #3]
      BytesToWrite = 4;
 80023d0:	4b27      	ldr	r3, [pc, #156]	@ (8002470 <DebugConsoleCommandParsing+0x268>)
 80023d2:	2204      	movs	r2, #4
 80023d4:	701a      	strb	r2, [r3, #0]
      Term_Update(BufferToWrite,BytesToWrite);
 80023d6:	4b26      	ldr	r3, [pc, #152]	@ (8002470 <DebugConsoleCommandParsing+0x268>)
 80023d8:	781b      	ldrb	r3, [r3, #0]
 80023da:	4619      	mov	r1, r3
 80023dc:	4823      	ldr	r0, [pc, #140]	@ (800246c <DebugConsoleCommandParsing+0x264>)
 80023de:	f01b fb11 	bl	801da04 <Term_Update>
 80023e2:	e03c      	b.n	800245e <DebugConsoleCommandParsing+0x256>
    } else {
      PointerByte = (uint8_t*) &uwCRCValue;
 80023e4:	f107 031c 	add.w	r3, r7, #28
 80023e8:	623b      	str	r3, [r7, #32]
      PointerByte[0]=att_data[13];
 80023ea:	697b      	ldr	r3, [r7, #20]
 80023ec:	7b5a      	ldrb	r2, [r3, #13]
 80023ee:	6a3b      	ldr	r3, [r7, #32]
 80023f0:	701a      	strb	r2, [r3, #0]
      PointerByte[1]=att_data[14];
 80023f2:	6a3b      	ldr	r3, [r7, #32]
 80023f4:	3301      	adds	r3, #1
 80023f6:	697a      	ldr	r2, [r7, #20]
 80023f8:	7b92      	ldrb	r2, [r2, #14]
 80023fa:	701a      	strb	r2, [r3, #0]
      PointerByte[2]=att_data[15];
 80023fc:	6a3b      	ldr	r3, [r7, #32]
 80023fe:	3302      	adds	r3, #2
 8002400:	697a      	ldr	r2, [r7, #20]
 8002402:	7bd2      	ldrb	r2, [r2, #15]
 8002404:	701a      	strb	r2, [r3, #0]
      PointerByte[3]=att_data[16];
 8002406:	6a3b      	ldr	r3, [r7, #32]
 8002408:	3303      	adds	r3, #3
 800240a:	697a      	ldr	r2, [r7, #20]
 800240c:	7c12      	ldrb	r2, [r2, #16]
 800240e:	701a      	strb	r2, [r3, #0]

      STBOX1_PRINTF("OTA %s SIZE=%ld uwCRCValue=%lx\r\n",STBOX1_PACKAGENAME,SizeOfUpdateBlueFW,uwCRCValue);
 8002410:	4b25      	ldr	r3, [pc, #148]	@ (80024a8 <DebugConsoleCommandParsing+0x2a0>)
 8002412:	681a      	ldr	r2, [r3, #0]
 8002414:	69fb      	ldr	r3, [r7, #28]
 8002416:	4918      	ldr	r1, [pc, #96]	@ (8002478 <DebugConsoleCommandParsing+0x270>)
 8002418:	4825      	ldr	r0, [pc, #148]	@ (80024b0 <DebugConsoleCommandParsing+0x2a8>)
 800241a:	f021 fc9f 	bl	8023d5c <iprintf>

      /* Reset the Flash */
      StartUpdateFWBlueMS(SizeOfUpdateBlueFW,uwCRCValue);
 800241e:	4b22      	ldr	r3, [pc, #136]	@ (80024a8 <DebugConsoleCommandParsing+0x2a0>)
 8002420:	681b      	ldr	r3, [r3, #0]
 8002422:	69fa      	ldr	r2, [r7, #28]
 8002424:	4611      	mov	r1, r2
 8002426:	4618      	mov	r0, r3
 8002428:	f001 fbcc 	bl	8003bc4 <StartUpdateFWBlueMS>
        }
      }
#endif

      /* Signal that we are ready sending back the CRV value*/
      BufferToWrite[0] = PointerByte[0];
 800242c:	6a3b      	ldr	r3, [r7, #32]
 800242e:	781a      	ldrb	r2, [r3, #0]
 8002430:	4b0e      	ldr	r3, [pc, #56]	@ (800246c <DebugConsoleCommandParsing+0x264>)
 8002432:	701a      	strb	r2, [r3, #0]
      BufferToWrite[1] = PointerByte[1];
 8002434:	6a3b      	ldr	r3, [r7, #32]
 8002436:	785a      	ldrb	r2, [r3, #1]
 8002438:	4b0c      	ldr	r3, [pc, #48]	@ (800246c <DebugConsoleCommandParsing+0x264>)
 800243a:	705a      	strb	r2, [r3, #1]
      BufferToWrite[2] = PointerByte[2];
 800243c:	6a3b      	ldr	r3, [r7, #32]
 800243e:	789a      	ldrb	r2, [r3, #2]
 8002440:	4b0a      	ldr	r3, [pc, #40]	@ (800246c <DebugConsoleCommandParsing+0x264>)
 8002442:	709a      	strb	r2, [r3, #2]
      BufferToWrite[3] = PointerByte[3];
 8002444:	6a3b      	ldr	r3, [r7, #32]
 8002446:	78da      	ldrb	r2, [r3, #3]
 8002448:	4b08      	ldr	r3, [pc, #32]	@ (800246c <DebugConsoleCommandParsing+0x264>)
 800244a:	70da      	strb	r2, [r3, #3]
      BytesToWrite = 4;
 800244c:	4b08      	ldr	r3, [pc, #32]	@ (8002470 <DebugConsoleCommandParsing+0x268>)
 800244e:	2204      	movs	r2, #4
 8002450:	701a      	strb	r2, [r3, #0]
      Term_Update(BufferToWrite,BytesToWrite);
 8002452:	4b07      	ldr	r3, [pc, #28]	@ (8002470 <DebugConsoleCommandParsing+0x268>)
 8002454:	781b      	ldrb	r3, [r3, #0]
 8002456:	4619      	mov	r1, r3
 8002458:	4804      	ldr	r0, [pc, #16]	@ (800246c <DebugConsoleCommandParsing+0x264>)
 800245a:	f01b fad3 	bl	801da04 <Term_Update>
    }

    SendBackData=0;
 800245e:	2300      	movs	r3, #0
 8002460:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8002462:	e087      	b.n	8002574 <DebugConsoleCommandParsing+0x36c>
 8002464:	08027074 	.word	0x08027074
 8002468:	0802707c 	.word	0x0802707c
 800246c:	20001a08 	.word	0x20001a08
 8002470:	20001b08 	.word	0x20001b08
 8002474:	08027084 	.word	0x08027084
 8002478:	08027038 	.word	0x08027038
 800247c:	08027090 	.word	0x08027090
 8002480:	08027098 	.word	0x08027098
 8002484:	080270ac 	.word	0x080270ac
 8002488:	2000059a 	.word	0x2000059a
 800248c:	080270b4 	.word	0x080270b4
 8002490:	08027144 	.word	0x08027144
 8002494:	08027150 	.word	0x08027150
 8002498:	0802710c 	.word	0x0802710c
 800249c:	20000590 	.word	0x20000590
 80024a0:	0802715c 	.word	0x0802715c
 80024a4:	08027170 	.word	0x08027170
 80024a8:	200004c0 	.word	0x200004c0
 80024ac:	0802717c 	.word	0x0802717c
 80024b0:	080271a0 	.word	0x080271a0
  }  else if(!strncmp("uid",(char *)(att_data),3)) {
 80024b4:	2203      	movs	r2, #3
 80024b6:	6979      	ldr	r1, [r7, #20]
 80024b8:	4831      	ldr	r0, [pc, #196]	@ (8002580 <DebugConsoleCommandParsing+0x378>)
 80024ba:	f021 fde8 	bl	802408e <strncmp>
 80024be:	4603      	mov	r3, r0
 80024c0:	2b00      	cmp	r3, #0
 80024c2:	d157      	bne.n	8002574 <DebugConsoleCommandParsing+0x36c>
    /* Write back the STM32 UID */
    uint8_t *uid = (uint8_t *)STM32_UUID;
 80024c4:	4b2f      	ldr	r3, [pc, #188]	@ (8002584 <DebugConsoleCommandParsing+0x37c>)
 80024c6:	62bb      	str	r3, [r7, #40]	@ 0x28
    uint32_t MCU_ID = STM32_MCU_ID[0]&0xFFF;
 80024c8:	4b2f      	ldr	r3, [pc, #188]	@ (8002588 <DebugConsoleCommandParsing+0x380>)
 80024ca:	681b      	ldr	r3, [r3, #0]
 80024cc:	f3c3 030b 	ubfx	r3, r3, #0, #12
 80024d0:	627b      	str	r3, [r7, #36]	@ 0x24
    BytesToWrite =sprintf((char *)BufferToWrite,"%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X_%.3lX\n",
                          uid[ 3],uid[ 2],uid[ 1],uid[ 0],
 80024d2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80024d4:	3303      	adds	r3, #3
 80024d6:	781b      	ldrb	r3, [r3, #0]
    BytesToWrite =sprintf((char *)BufferToWrite,"%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X_%.3lX\n",
 80024d8:	469c      	mov	ip, r3
                          uid[ 3],uid[ 2],uid[ 1],uid[ 0],
 80024da:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80024dc:	3302      	adds	r3, #2
 80024de:	781b      	ldrb	r3, [r3, #0]
    BytesToWrite =sprintf((char *)BufferToWrite,"%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X_%.3lX\n",
 80024e0:	469e      	mov	lr, r3
                          uid[ 3],uid[ 2],uid[ 1],uid[ 0],
 80024e2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80024e4:	3301      	adds	r3, #1
 80024e6:	781b      	ldrb	r3, [r3, #0]
    BytesToWrite =sprintf((char *)BufferToWrite,"%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X_%.3lX\n",
 80024e8:	461a      	mov	r2, r3
                          uid[ 3],uid[ 2],uid[ 1],uid[ 0],
 80024ea:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80024ec:	781b      	ldrb	r3, [r3, #0]
    BytesToWrite =sprintf((char *)BufferToWrite,"%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X_%.3lX\n",
 80024ee:	4619      	mov	r1, r3
                          uid[ 7],uid[ 6],uid[ 5],uid[ 4],
 80024f0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80024f2:	3307      	adds	r3, #7
 80024f4:	781b      	ldrb	r3, [r3, #0]
    BytesToWrite =sprintf((char *)BufferToWrite,"%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X_%.3lX\n",
 80024f6:	4618      	mov	r0, r3
                          uid[ 7],uid[ 6],uid[ 5],uid[ 4],
 80024f8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80024fa:	3306      	adds	r3, #6
 80024fc:	781b      	ldrb	r3, [r3, #0]
    BytesToWrite =sprintf((char *)BufferToWrite,"%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X_%.3lX\n",
 80024fe:	461c      	mov	r4, r3
                          uid[ 7],uid[ 6],uid[ 5],uid[ 4],
 8002500:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8002502:	3305      	adds	r3, #5
 8002504:	781b      	ldrb	r3, [r3, #0]
    BytesToWrite =sprintf((char *)BufferToWrite,"%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X_%.3lX\n",
 8002506:	461d      	mov	r5, r3
                          uid[ 7],uid[ 6],uid[ 5],uid[ 4],
 8002508:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800250a:	3304      	adds	r3, #4
 800250c:	781b      	ldrb	r3, [r3, #0]
    BytesToWrite =sprintf((char *)BufferToWrite,"%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X_%.3lX\n",
 800250e:	461e      	mov	r6, r3
                          uid[11],uid[ 10],uid[9],uid[8],
 8002510:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8002512:	330b      	adds	r3, #11
 8002514:	781b      	ldrb	r3, [r3, #0]
    BytesToWrite =sprintf((char *)BufferToWrite,"%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X_%.3lX\n",
 8002516:	60fb      	str	r3, [r7, #12]
                          uid[11],uid[ 10],uid[9],uid[8],
 8002518:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800251a:	330a      	adds	r3, #10
 800251c:	781b      	ldrb	r3, [r3, #0]
    BytesToWrite =sprintf((char *)BufferToWrite,"%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X_%.3lX\n",
 800251e:	60bb      	str	r3, [r7, #8]
                          uid[11],uid[ 10],uid[9],uid[8],
 8002520:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8002522:	3309      	adds	r3, #9
 8002524:	781b      	ldrb	r3, [r3, #0]
    BytesToWrite =sprintf((char *)BufferToWrite,"%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X_%.3lX\n",
 8002526:	607b      	str	r3, [r7, #4]
                          uid[11],uid[ 10],uid[9],uid[8],
 8002528:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800252a:	3308      	adds	r3, #8
 800252c:	781b      	ldrb	r3, [r3, #0]
    BytesToWrite =sprintf((char *)BufferToWrite,"%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X_%.3lX\n",
 800252e:	603b      	str	r3, [r7, #0]
 8002530:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8002532:	930a      	str	r3, [sp, #40]	@ 0x28
 8002534:	683b      	ldr	r3, [r7, #0]
 8002536:	9309      	str	r3, [sp, #36]	@ 0x24
 8002538:	687b      	ldr	r3, [r7, #4]
 800253a:	9308      	str	r3, [sp, #32]
 800253c:	68bb      	ldr	r3, [r7, #8]
 800253e:	9307      	str	r3, [sp, #28]
 8002540:	68fb      	ldr	r3, [r7, #12]
 8002542:	9306      	str	r3, [sp, #24]
 8002544:	9605      	str	r6, [sp, #20]
 8002546:	9504      	str	r5, [sp, #16]
 8002548:	9403      	str	r4, [sp, #12]
 800254a:	9002      	str	r0, [sp, #8]
 800254c:	9101      	str	r1, [sp, #4]
 800254e:	9200      	str	r2, [sp, #0]
 8002550:	4673      	mov	r3, lr
 8002552:	4662      	mov	r2, ip
 8002554:	490d      	ldr	r1, [pc, #52]	@ (800258c <DebugConsoleCommandParsing+0x384>)
 8002556:	480e      	ldr	r0, [pc, #56]	@ (8002590 <DebugConsoleCommandParsing+0x388>)
 8002558:	f021 fc70 	bl	8023e3c <siprintf>
 800255c:	4603      	mov	r3, r0
 800255e:	b2da      	uxtb	r2, r3
 8002560:	4b0c      	ldr	r3, [pc, #48]	@ (8002594 <DebugConsoleCommandParsing+0x38c>)
 8002562:	701a      	strb	r2, [r3, #0]
                          MCU_ID);
    Term_Update(BufferToWrite,BytesToWrite);
 8002564:	4b0b      	ldr	r3, [pc, #44]	@ (8002594 <DebugConsoleCommandParsing+0x38c>)
 8002566:	781b      	ldrb	r3, [r3, #0]
 8002568:	4619      	mov	r1, r3
 800256a:	4809      	ldr	r0, [pc, #36]	@ (8002590 <DebugConsoleCommandParsing+0x388>)
 800256c:	f01b fa4a 	bl	801da04 <Term_Update>
    SendBackData=0;
 8002570:	2300      	movs	r3, #0
 8002572:	62fb      	str	r3, [r7, #44]	@ 0x2c
  }

  return SendBackData;
 8002574:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
}
 8002576:	4618      	mov	r0, r3
 8002578:	3734      	adds	r7, #52	@ 0x34
 800257a:	46bd      	mov	sp, r7
 800257c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800257e:	bf00      	nop
 8002580:	080271c4 	.word	0x080271c4
 8002584:	0bfa0700 	.word	0x0bfa0700
 8002588:	e0044000 	.word	0xe0044000
 800258c:	080271c8 	.word	0x080271c8
 8002590:	20001a08 	.word	0x20001a08
 8002594:	20001b08 	.word	0x20001b08

08002598 <ReadRequestEnvFunction>:
 * @param  int16_t *Temp1 Temperature Number 1
 * @param  int16_t *Temp2 Temperature Number 2
 * @retval None
 */
void ReadRequestEnvFunction(int32_t *Press,uint16_t *Hum,int16_t *Temp1,int16_t *Temp2)
{
 8002598:	b580      	push	{r7, lr}
 800259a:	b086      	sub	sp, #24
 800259c:	af00      	add	r7, sp, #0
 800259e:	60f8      	str	r0, [r7, #12]
 80025a0:	60b9      	str	r1, [r7, #8]
 80025a2:	607a      	str	r2, [r7, #4]
 80025a4:	603b      	str	r3, [r7, #0]
  float Temperature1,Pressure;
  BSP_ENV_SENSOR_GetValue(STTS22H_0, ENV_TEMPERATURE, &Temperature1);
 80025a6:	f107 0314 	add.w	r3, r7, #20
 80025aa:	461a      	mov	r2, r3
 80025ac:	2101      	movs	r1, #1
 80025ae:	2000      	movs	r0, #0
 80025b0:	f00a fb96 	bl	800cce0 <BSP_ENV_SENSOR_GetValue>
  BSP_ENV_SENSOR_GetValue(LPS22DF_0, ENV_PRESSURE, &Pressure);
 80025b4:	f107 0310 	add.w	r3, r7, #16
 80025b8:	461a      	mov	r2, r3
 80025ba:	2102      	movs	r1, #2
 80025bc:	2001      	movs	r0, #1
 80025be:	f00a fb8f 	bl	800cce0 <BSP_ENV_SENSOR_GetValue>

  *Press = (int32_t)(Pressure *100);
 80025c2:	edd7 7a04 	vldr	s15, [r7, #16]
 80025c6:	ed9f 7a0d 	vldr	s14, [pc, #52]	@ 80025fc <ReadRequestEnvFunction+0x64>
 80025ca:	ee67 7a87 	vmul.f32	s15, s15, s14
 80025ce:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80025d2:	ee17 2a90 	vmov	r2, s15
 80025d6:	68fb      	ldr	r3, [r7, #12]
 80025d8:	601a      	str	r2, [r3, #0]
  *Temp1 = (int16_t)(Temperature1 * 10);
 80025da:	edd7 7a05 	vldr	s15, [r7, #20]
 80025de:	eeb2 7a04 	vmov.f32	s14, #36	@ 0x41200000  10.0
 80025e2:	ee67 7a87 	vmul.f32	s15, s15, s14
 80025e6:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80025ea:	ee17 3a90 	vmov	r3, s15
 80025ee:	b21a      	sxth	r2, r3
 80025f0:	687b      	ldr	r3, [r7, #4]
 80025f2:	801a      	strh	r2, [r3, #0]
}
 80025f4:	bf00      	nop
 80025f6:	3718      	adds	r7, #24
 80025f8:	46bd      	mov	sp, r7
 80025fa:	bd80      	pop	{r7, pc}
 80025fc:	42c80000 	.word	0x42c80000

08002600 <DisconnectionCompletedFunction>:
 * @brief  This function is called when the peer device get disconnected.
 * @param  None
 * @retval None
 */
void DisconnectionCompletedFunction(void)
{
 8002600:	b580      	push	{r7, lr}
 8002602:	af00      	add	r7, sp, #0
  connected = FALSE;
 8002604:	4b3f      	ldr	r3, [pc, #252]	@ (8002704 <DisconnectionCompletedFunction+0x104>)
 8002606:	2200      	movs	r2, #0
 8002608:	701a      	strb	r2, [r3, #0]

  PoolAvailable=1;
 800260a:	4b3f      	ldr	r3, [pc, #252]	@ (8002708 <DisconnectionCompletedFunction+0x108>)
 800260c:	2201      	movs	r2, #1
 800260e:	601a      	str	r2, [r3, #0]
  JSON_len_command_wTP =0;
 8002610:	4b3e      	ldr	r3, [pc, #248]	@ (800270c <DisconnectionCompletedFunction+0x10c>)
 8002612:	2200      	movs	r2, #0
 8002614:	601a      	str	r2, [r3, #0]
  JSON_string_command_wTP = NULL;
 8002616:	4b3e      	ldr	r3, [pc, #248]	@ (8002710 <DisconnectionCompletedFunction+0x110>)
 8002618:	2200      	movs	r2, #0
 800261a:	601a      	str	r2, [r3, #0]

  /* Reset for any problem during FOTA update */
  SizeOfUpdateBlueFW = 0;
 800261c:	4b3d      	ldr	r3, [pc, #244]	@ (8002714 <DisconnectionCompletedFunction+0x114>)
 800261e:	2200      	movs	r2, #0
 8002620:	601a      	str	r2, [r3, #0]

  /*Stop all the timers */
  if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_ACC_GYRO_MAG)) {
 8002622:	4b3d      	ldr	r3, [pc, #244]	@ (8002718 <DisconnectionCompletedFunction+0x118>)
 8002624:	681b      	ldr	r3, [r3, #0]
 8002626:	085b      	lsrs	r3, r3, #1
 8002628:	f003 0301 	and.w	r3, r3, #1
 800262c:	b2db      	uxtb	r3, r3
 800262e:	2b00      	cmp	r3, #0
 8002630:	d016      	beq.n	8002660 <DisconnectionCompletedFunction+0x60>
    if(TimerInerIsRunning) {
 8002632:	4b3a      	ldr	r3, [pc, #232]	@ (800271c <DisconnectionCompletedFunction+0x11c>)
 8002634:	781b      	ldrb	r3, [r3, #0]
 8002636:	2b00      	cmp	r3, #0
 8002638:	d012      	beq.n	8002660 <DisconnectionCompletedFunction+0x60>
      if(HAL_TIM_OC_Stop_IT(&TIM_CC_HANDLE, TIM_CHANNEL_3) != HAL_OK){
 800263a:	2108      	movs	r1, #8
 800263c:	4838      	ldr	r0, [pc, #224]	@ (8002720 <DisconnectionCompletedFunction+0x120>)
 800263e:	f014 fa3d 	bl	8016abc <HAL_TIM_OC_Stop_IT>
 8002642:	4603      	mov	r3, r0
 8002644:	2b00      	cmp	r3, #0
 8002646:	d005      	beq.n	8002654 <DisconnectionCompletedFunction+0x54>
        /* Stopping Error */
        STBOX1_Error_Handler(STBOX1_ERROR_TIMER,__FILE__,__LINE__);
 8002648:	f240 225d 	movw	r2, #605	@ 0x25d
 800264c:	4935      	ldr	r1, [pc, #212]	@ (8002724 <DisconnectionCompletedFunction+0x124>)
 800264e:	2006      	movs	r0, #6
 8002650:	f002 f8ec 	bl	800482c <STBOX1_Error_Handler>
      }
      STBOX1_PRINTF("Stop Iner\r\n");
 8002654:	4834      	ldr	r0, [pc, #208]	@ (8002728 <DisconnectionCompletedFunction+0x128>)
 8002656:	f021 fbe9 	bl	8023e2c <puts>
      TimerInerIsRunning=0;
 800265a:	4b30      	ldr	r3, [pc, #192]	@ (800271c <DisconnectionCompletedFunction+0x11c>)
 800265c:	2200      	movs	r2, #0
 800265e:	701a      	strb	r2, [r3, #0]
    }
  }

  if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_ENV)) {
 8002660:	4b2d      	ldr	r3, [pc, #180]	@ (8002718 <DisconnectionCompletedFunction+0x118>)
 8002662:	681b      	ldr	r3, [r3, #0]
 8002664:	f003 0301 	and.w	r3, r3, #1
 8002668:	b2db      	uxtb	r3, r3
 800266a:	2b00      	cmp	r3, #0
 800266c:	d016      	beq.n	800269c <DisconnectionCompletedFunction+0x9c>
    if(TimerEnvIsRunning) {
 800266e:	4b2f      	ldr	r3, [pc, #188]	@ (800272c <DisconnectionCompletedFunction+0x12c>)
 8002670:	781b      	ldrb	r3, [r3, #0]
 8002672:	2b00      	cmp	r3, #0
 8002674:	d012      	beq.n	800269c <DisconnectionCompletedFunction+0x9c>
      if(HAL_TIM_OC_Stop_IT(&TIM_CC_HANDLE, TIM_CHANNEL_2) != HAL_OK){
 8002676:	2104      	movs	r1, #4
 8002678:	4829      	ldr	r0, [pc, #164]	@ (8002720 <DisconnectionCompletedFunction+0x120>)
 800267a:	f014 fa1f 	bl	8016abc <HAL_TIM_OC_Stop_IT>
 800267e:	4603      	mov	r3, r0
 8002680:	2b00      	cmp	r3, #0
 8002682:	d005      	beq.n	8002690 <DisconnectionCompletedFunction+0x90>
        /* Stopping Error */
        STBOX1_Error_Handler(STBOX1_ERROR_TIMER,__FILE__,__LINE__);
 8002684:	f44f 721a 	mov.w	r2, #616	@ 0x268
 8002688:	4926      	ldr	r1, [pc, #152]	@ (8002724 <DisconnectionCompletedFunction+0x124>)
 800268a:	2006      	movs	r0, #6
 800268c:	f002 f8ce 	bl	800482c <STBOX1_Error_Handler>
      }
      STBOX1_PRINTF("Stop Env\r\n");
 8002690:	4827      	ldr	r0, [pc, #156]	@ (8002730 <DisconnectionCompletedFunction+0x130>)
 8002692:	f021 fbcb 	bl	8023e2c <puts>
      TimerEnvIsRunning=0;
 8002696:	4b25      	ldr	r3, [pc, #148]	@ (800272c <DisconnectionCompletedFunction+0x12c>)
 8002698:	2200      	movs	r2, #0
 800269a:	701a      	strb	r2, [r3, #0]
    }
  }

  if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_BAT_EVENT)) {
 800269c:	4b1e      	ldr	r3, [pc, #120]	@ (8002718 <DisconnectionCompletedFunction+0x118>)
 800269e:	681b      	ldr	r3, [r3, #0]
 80026a0:	091b      	lsrs	r3, r3, #4
 80026a2:	f003 0301 	and.w	r3, r3, #1
 80026a6:	b2db      	uxtb	r3, r3
 80026a8:	2b00      	cmp	r3, #0
 80026aa:	d00f      	beq.n	80026cc <DisconnectionCompletedFunction+0xcc>
    if(HAL_TIM_OC_Stop_IT(&TIM_CC_HANDLE, TIM_CHANNEL_1) != HAL_OK){
 80026ac:	2100      	movs	r1, #0
 80026ae:	481c      	ldr	r0, [pc, #112]	@ (8002720 <DisconnectionCompletedFunction+0x120>)
 80026b0:	f014 fa04 	bl	8016abc <HAL_TIM_OC_Stop_IT>
 80026b4:	4603      	mov	r3, r0
 80026b6:	2b00      	cmp	r3, #0
 80026b8:	d005      	beq.n	80026c6 <DisconnectionCompletedFunction+0xc6>
      /* Stopping Error */
      STBOX1_Error_Handler(STBOX1_ERROR_TIMER,__FILE__,__LINE__);
 80026ba:	f240 2272 	movw	r2, #626	@ 0x272
 80026be:	4919      	ldr	r1, [pc, #100]	@ (8002724 <DisconnectionCompletedFunction+0x124>)
 80026c0:	2006      	movs	r0, #6
 80026c2:	f002 f8b3 	bl	800482c <STBOX1_Error_Handler>
    }
    STBOX1_PRINTF("Stop Battery\r\n");
 80026c6:	481b      	ldr	r0, [pc, #108]	@ (8002734 <DisconnectionCompletedFunction+0x134>)
 80026c8:	f021 fbb0 	bl	8023e2c <puts>
  }

  /* Reset the BLE Connection Variable */
  ConnectionBleStatus=0;
 80026cc:	4b12      	ldr	r3, [pc, #72]	@ (8002718 <DisconnectionCompletedFunction+0x118>)
 80026ce:	2200      	movs	r2, #0
 80026d0:	601a      	str	r2, [r3, #0]

  if(NeedToRebootBoard) {
 80026d2:	4b19      	ldr	r3, [pc, #100]	@ (8002738 <DisconnectionCompletedFunction+0x138>)
 80026d4:	681b      	ldr	r3, [r3, #0]
 80026d6:	2b00      	cmp	r3, #0
 80026d8:	d005      	beq.n	80026e6 <DisconnectionCompletedFunction+0xe6>
    NeedToRebootBoard=0;
 80026da:	4b17      	ldr	r3, [pc, #92]	@ (8002738 <DisconnectionCompletedFunction+0x138>)
 80026dc:	2200      	movs	r2, #0
 80026de:	601a      	str	r2, [r3, #0]
    RebootBoard=1;
 80026e0:	4b16      	ldr	r3, [pc, #88]	@ (800273c <DisconnectionCompletedFunction+0x13c>)
 80026e2:	2201      	movs	r2, #1
 80026e4:	601a      	str	r2, [r3, #0]
  }

   if(NeedToSwapBanks) {
 80026e6:	4b16      	ldr	r3, [pc, #88]	@ (8002740 <DisconnectionCompletedFunction+0x140>)
 80026e8:	681b      	ldr	r3, [r3, #0]
 80026ea:	2b00      	cmp	r3, #0
 80026ec:	d005      	beq.n	80026fa <DisconnectionCompletedFunction+0xfa>
    NeedToSwapBanks=0;
 80026ee:	4b14      	ldr	r3, [pc, #80]	@ (8002740 <DisconnectionCompletedFunction+0x140>)
 80026f0:	2200      	movs	r2, #0
 80026f2:	601a      	str	r2, [r3, #0]
    SwapBanks=1;
 80026f4:	4b13      	ldr	r3, [pc, #76]	@ (8002744 <DisconnectionCompletedFunction+0x144>)
 80026f6:	2201      	movs	r2, #1
 80026f8:	601a      	str	r2, [r3, #0]
  }

  HAL_Delay(200);
 80026fa:	20c8      	movs	r0, #200	@ 0xc8
 80026fc:	f002 f87e 	bl	80047fc <HAL_Delay>
}
 8002700:	bf00      	nop
 8002702:	bd80      	pop	{r7, pc}
 8002704:	200004b0 	.word	0x200004b0
 8002708:	20000008 	.word	0x20000008
 800270c:	200004c8 	.word	0x200004c8
 8002710:	200004cc 	.word	0x200004cc
 8002714:	200004c0 	.word	0x200004c0
 8002718:	200004bc 	.word	0x200004bc
 800271c:	200004c5 	.word	0x200004c5
 8002720:	20000854 	.word	0x20000854
 8002724:	08026e08 	.word	0x08026e08
 8002728:	08027014 	.word	0x08027014
 800272c:	200004c4 	.word	0x200004c4
 8002730:	08026f98 	.word	0x08026f98
 8002734:	08026f5c 	.word	0x08026f5c
 8002738:	200004d0 	.word	0x200004d0
 800273c:	200004b4 	.word	0x200004b4
 8002740:	200004d4 	.word	0x200004d4
 8002744:	200004b8 	.word	0x200004b8

08002748 <ConnectionCompletedFunction>:
 * @brief  This function is called when there is a LE Connection Complete event.
 * @param  None
 * @retval None
 */
void ConnectionCompletedFunction(uint16_t ConnectionHandle, uint8_t Address_Type,uint8_t Addr[6])
{
 8002748:	b580      	push	{r7, lr}
 800274a:	b082      	sub	sp, #8
 800274c:	af00      	add	r7, sp, #0
 800274e:	4603      	mov	r3, r0
 8002750:	603a      	str	r2, [r7, #0]
 8002752:	80fb      	strh	r3, [r7, #6]
 8002754:	460b      	mov	r3, r1
 8002756:	717b      	strb	r3, [r7, #5]
  connected = TRUE;
 8002758:	4b12      	ldr	r3, [pc, #72]	@ (80027a4 <ConnectionCompletedFunction+0x5c>)
 800275a:	2201      	movs	r2, #1
 800275c:	701a      	strb	r2, [r3, #0]
  ConnectionBleStatus=0;
 800275e:	4b12      	ldr	r3, [pc, #72]	@ (80027a8 <ConnectionCompletedFunction+0x60>)
 8002760:	2200      	movs	r2, #0
 8002762:	601a      	str	r2, [r3, #0]

  PoolAvailable=1;
 8002764:	4b11      	ldr	r3, [pc, #68]	@ (80027ac <ConnectionCompletedFunction+0x64>)
 8002766:	2201      	movs	r2, #1
 8002768:	601a      	str	r2, [r3, #0]
  JSON_len_command_wTP =0;
 800276a:	4b11      	ldr	r3, [pc, #68]	@ (80027b0 <ConnectionCompletedFunction+0x68>)
 800276c:	2200      	movs	r2, #0
 800276e:	601a      	str	r2, [r3, #0]
  JSON_string_command_wTP = NULL;
 8002770:	4b10      	ldr	r3, [pc, #64]	@ (80027b4 <ConnectionCompletedFunction+0x6c>)
 8002772:	2200      	movs	r2, #0
 8002774:	601a      	str	r2, [r3, #0]

  /* Stop the TIM Base generation in interrupt mode for Led Blinking*/
  if(HAL_TIM_OC_Stop_IT(&TIM_CC_HANDLE, TIM_CHANNEL_1) != HAL_OK){
 8002776:	2100      	movs	r1, #0
 8002778:	480f      	ldr	r0, [pc, #60]	@ (80027b8 <ConnectionCompletedFunction+0x70>)
 800277a:	f014 f99f 	bl	8016abc <HAL_TIM_OC_Stop_IT>
 800277e:	4603      	mov	r3, r0
 8002780:	2b00      	cmp	r3, #0
 8002782:	d005      	beq.n	8002790 <ConnectionCompletedFunction+0x48>
    /* Stopping Error */
    STBOX1_Error_Handler(STBOX1_ERROR_TIMER,__FILE__,__LINE__);
 8002784:	f44f 7226 	mov.w	r2, #664	@ 0x298
 8002788:	490c      	ldr	r1, [pc, #48]	@ (80027bc <ConnectionCompletedFunction+0x74>)
 800278a:	2006      	movs	r0, #6
 800278c:	f002 f84e 	bl	800482c <STBOX1_Error_Handler>
  }

  BSP_LED_Off(LED_GREEN);
 8002790:	2003      	movs	r0, #3
 8002792:	f002 fba5 	bl	8004ee0 <BSP_LED_Off>

  HAL_Delay(100);
 8002796:	2064      	movs	r0, #100	@ 0x64
 8002798:	f002 f830 	bl	80047fc <HAL_Delay>
}
 800279c:	bf00      	nop
 800279e:	3708      	adds	r7, #8
 80027a0:	46bd      	mov	sp, r7
 80027a2:	bd80      	pop	{r7, pc}
 80027a4:	200004b0 	.word	0x200004b0
 80027a8:	200004bc 	.word	0x200004bc
 80027ac:	20000008 	.word	0x20000008
 80027b0:	200004c8 	.word	0x200004c8
 80027b4:	200004cc 	.word	0x200004cc
 80027b8:	20000854 	.word	0x20000854
 80027bc:	08026e08 	.word	0x08026e08

080027c0 <ExtExtConfigUidCommandCallback>:
 * @brief  Callback Function for answering to the UID command
 * @param  uint8_t **UID STM32 UID Return value
 * @retval None
 */
void ExtExtConfigUidCommandCallback(uint8_t **UID)
{
 80027c0:	b480      	push	{r7}
 80027c2:	b083      	sub	sp, #12
 80027c4:	af00      	add	r7, sp, #0
 80027c6:	6078      	str	r0, [r7, #4]
  *UID = (uint8_t *)STM32_UUID;
 80027c8:	687b      	ldr	r3, [r7, #4]
 80027ca:	4a04      	ldr	r2, [pc, #16]	@ (80027dc <ExtExtConfigUidCommandCallback+0x1c>)
 80027cc:	601a      	str	r2, [r3, #0]
}
 80027ce:	bf00      	nop
 80027d0:	370c      	adds	r7, #12
 80027d2:	46bd      	mov	sp, r7
 80027d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80027d8:	4770      	bx	lr
 80027da:	bf00      	nop
 80027dc:	0bfa0700 	.word	0x0bfa0700

080027e0 <ExtConfigInfoCommandCallback>:
 * @brief  Callback Function for answering to Info command
 * @param  uint8_t *Answer Return String
 * @retval None
 */
void ExtConfigInfoCommandCallback(uint8_t *Answer)
{
 80027e0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80027e2:	b08d      	sub	sp, #52	@ 0x34
 80027e4:	af0a      	add	r7, sp, #40	@ 0x28
 80027e6:	6078      	str	r0, [r7, #4]
       " (STM32CubeIDE)\n"
#endif
       "\tCurrent Bank =%ld\n",
        STBOX1_PACKAGENAME,
        STBOX1_VERSION_MAJOR,STBOX1_VERSION_MINOR,STBOX1_VERSION_PATCH,
        (FinishGood==FINISHA) ? 'A' : 'B',
 80027e8:	4b1a      	ldr	r3, [pc, #104]	@ (8002854 <ExtConfigInfoCommandCallback+0x74>)
 80027ea:	781b      	ldrb	r3, [r3, #0]
  sprintf((char *)Answer,"\r\nSTMicroelectronics %s:\n"
 80027ec:	2b00      	cmp	r3, #0
 80027ee:	d101      	bne.n	80027f4 <ExtConfigInfoCommandCallback+0x14>
 80027f0:	2441      	movs	r4, #65	@ 0x41
 80027f2:	e000      	b.n	80027f6 <ExtConfigInfoCommandCallback+0x16>
 80027f4:	2442      	movs	r4, #66	@ 0x42
        HAL_GetHalVersion() >>24,
 80027f6:	f00b f93f 	bl	800da78 <HAL_GetHalVersion>
 80027fa:	4603      	mov	r3, r0
  sprintf((char *)Answer,"\r\nSTMicroelectronics %s:\n"
 80027fc:	0e1d      	lsrs	r5, r3, #24
        (HAL_GetHalVersion() >>16)&0xFF,
 80027fe:	f00b f93b 	bl	800da78 <HAL_GetHalVersion>
 8002802:	4603      	mov	r3, r0
 8002804:	0c1b      	lsrs	r3, r3, #16
  sprintf((char *)Answer,"\r\nSTMicroelectronics %s:\n"
 8002806:	b2de      	uxtb	r6, r3
        (HAL_GetHalVersion() >> 8)&0xFF,
 8002808:	f00b f936 	bl	800da78 <HAL_GetHalVersion>
 800280c:	4603      	mov	r3, r0
 800280e:	0a1b      	lsrs	r3, r3, #8
  sprintf((char *)Answer,"\r\nSTMicroelectronics %s:\n"
 8002810:	b2db      	uxtb	r3, r3
 8002812:	603b      	str	r3, [r7, #0]
         HAL_GetHalVersion()      &0xFF,
 8002814:	f00b f930 	bl	800da78 <HAL_GetHalVersion>
 8002818:	4603      	mov	r3, r0
  sprintf((char *)Answer,"\r\nSTMicroelectronics %s:\n"
 800281a:	b2db      	uxtb	r3, r3
 800281c:	4a0e      	ldr	r2, [pc, #56]	@ (8002858 <ExtConfigInfoCommandCallback+0x78>)
 800281e:	6812      	ldr	r2, [r2, #0]
 8002820:	9209      	str	r2, [sp, #36]	@ 0x24
 8002822:	4a0e      	ldr	r2, [pc, #56]	@ (800285c <ExtConfigInfoCommandCallback+0x7c>)
 8002824:	9208      	str	r2, [sp, #32]
 8002826:	4a0e      	ldr	r2, [pc, #56]	@ (8002860 <ExtConfigInfoCommandCallback+0x80>)
 8002828:	9207      	str	r2, [sp, #28]
 800282a:	9306      	str	r3, [sp, #24]
 800282c:	683b      	ldr	r3, [r7, #0]
 800282e:	9305      	str	r3, [sp, #20]
 8002830:	9604      	str	r6, [sp, #16]
 8002832:	9503      	str	r5, [sp, #12]
 8002834:	9402      	str	r4, [sp, #8]
 8002836:	2330      	movs	r3, #48	@ 0x30
 8002838:	9301      	str	r3, [sp, #4]
 800283a:	2330      	movs	r3, #48	@ 0x30
 800283c:	9300      	str	r3, [sp, #0]
 800283e:	2332      	movs	r3, #50	@ 0x32
 8002840:	4a08      	ldr	r2, [pc, #32]	@ (8002864 <ExtConfigInfoCommandCallback+0x84>)
 8002842:	4909      	ldr	r1, [pc, #36]	@ (8002868 <ExtConfigInfoCommandCallback+0x88>)
 8002844:	6878      	ldr	r0, [r7, #4]
 8002846:	f021 faf9 	bl	8023e3c <siprintf>
         __DATE__,__TIME__,
         CurrentActiveBank);
}
 800284a:	bf00      	nop
 800284c:	370c      	adds	r7, #12
 800284e:	46bd      	mov	sp, r7
 8002850:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002852:	bf00      	nop
 8002854:	2000059a 	.word	0x2000059a
 8002858:	20000590 	.word	0x20000590
 800285c:	08027144 	.word	0x08027144
 8002860:	08027150 	.word	0x08027150
 8002864:	08027038 	.word	0x08027038
 8002868:	08027228 	.word	0x08027228

0800286c <ExtConfigSetNameCommandCallback>:
 * @brief  Callback Function for answering to SetName command
 * @param  uint8_t *NewName New Name
 * @retval None
 */
void ExtConfigSetNameCommandCallback(uint8_t *NewName)
{
 800286c:	b580      	push	{r7, lr}
 800286e:	b082      	sub	sp, #8
 8002870:	af00      	add	r7, sp, #0
 8002872:	6078      	str	r0, [r7, #4]
  STBOX1_PRINTF("Received a new Board's Name=%s\r\n",NewName);
 8002874:	6879      	ldr	r1, [r7, #4]
 8002876:	480c      	ldr	r0, [pc, #48]	@ (80028a8 <ExtConfigSetNameCommandCallback+0x3c>)
 8002878:	f021 fa70 	bl	8023d5c <iprintf>
  /* Update the Board's name in flash */
  if(FinishGood==FINISHA) {
 800287c:	4b0b      	ldr	r3, [pc, #44]	@ (80028ac <ExtConfigSetNameCommandCallback+0x40>)
 800287e:	781b      	ldrb	r3, [r3, #0]
 8002880:	2b00      	cmp	r3, #0
 8002882:	d104      	bne.n	800288e <ExtConfigSetNameCommandCallback+0x22>
    UpdateCurrFlashBankFwIdBoardName(STBOX1A_BLUEST_SDK_FW_ID,NewName);
 8002884:	6879      	ldr	r1, [r7, #4]
 8002886:	2032      	movs	r0, #50	@ 0x32
 8002888:	f001 fafa 	bl	8003e80 <UpdateCurrFlashBankFwIdBoardName>
 800288c:	e003      	b.n	8002896 <ExtConfigSetNameCommandCallback+0x2a>
  } else {
    UpdateCurrFlashBankFwIdBoardName(STBOX1B_BLUEST_SDK_FW_ID,NewName);
 800288e:	6879      	ldr	r1, [r7, #4]
 8002890:	2012      	movs	r0, #18
 8002892:	f001 faf5 	bl	8003e80 <UpdateCurrFlashBankFwIdBoardName>
  }

  /* Update the Name for BLE Advertise */
  sprintf(BLE_StackValue.BoardName,"%s",NewName);
 8002896:	687a      	ldr	r2, [r7, #4]
 8002898:	4905      	ldr	r1, [pc, #20]	@ (80028b0 <ExtConfigSetNameCommandCallback+0x44>)
 800289a:	4806      	ldr	r0, [pc, #24]	@ (80028b4 <ExtConfigSetNameCommandCallback+0x48>)
 800289c:	f021 face 	bl	8023e3c <siprintf>
}
 80028a0:	bf00      	nop
 80028a2:	3708      	adds	r7, #8
 80028a4:	46bd      	mov	sp, r7
 80028a6:	bd80      	pop	{r7, pc}
 80028a8:	080272c8 	.word	0x080272c8
 80028ac:	2000059a 	.word	0x2000059a
 80028b0:	080272ec 	.word	0x080272ec
 80028b4:	20001b19 	.word	0x20001b19

080028b8 <ExtConfigHelpCommandCallback>:
 * @brief  Callback Function for answering to Help command
 * @param  uint8_t *Answer Return String
 * @retval None
 */
void ExtConfigHelpCommandCallback(uint8_t *Answer)
{
 80028b8:	b580      	push	{r7, lr}
 80028ba:	b082      	sub	sp, #8
 80028bc:	af00      	add	r7, sp, #0
 80028be:	6078      	str	r0, [r7, #4]
  sprintf((char *)Answer,"Help Message.....");
 80028c0:	4903      	ldr	r1, [pc, #12]	@ (80028d0 <ExtConfigHelpCommandCallback+0x18>)
 80028c2:	6878      	ldr	r0, [r7, #4]
 80028c4:	f021 faba 	bl	8023e3c <siprintf>
}
 80028c8:	bf00      	nop
 80028ca:	3708      	adds	r7, #8
 80028cc:	46bd      	mov	sp, r7
 80028ce:	bd80      	pop	{r7, pc}
 80028d0:	080272f0 	.word	0x080272f0

080028d4 <ExtConfigVersionFwCommandCallback>:
 * @brief  Callback Function for answering to VersionFw command
 * @param  uint8_t *Answer Return String
 * @retval None
 */
void ExtConfigVersionFwCommandCallback(uint8_t *Answer)
{
 80028d4:	b580      	push	{r7, lr}
 80028d6:	b086      	sub	sp, #24
 80028d8:	af04      	add	r7, sp, #16
 80028da:	6078      	str	r0, [r7, #4]
  sprintf((char *)Answer,"%s_%s_%c.%c.%c\r\n",
 80028dc:	2330      	movs	r3, #48	@ 0x30
 80028de:	9302      	str	r3, [sp, #8]
 80028e0:	2330      	movs	r3, #48	@ 0x30
 80028e2:	9301      	str	r3, [sp, #4]
 80028e4:	2332      	movs	r3, #50	@ 0x32
 80028e6:	9300      	str	r3, [sp, #0]
 80028e8:	4b04      	ldr	r3, [pc, #16]	@ (80028fc <ExtConfigVersionFwCommandCallback+0x28>)
 80028ea:	4a05      	ldr	r2, [pc, #20]	@ (8002900 <ExtConfigVersionFwCommandCallback+0x2c>)
 80028ec:	4905      	ldr	r1, [pc, #20]	@ (8002904 <ExtConfigVersionFwCommandCallback+0x30>)
 80028ee:	6878      	ldr	r0, [r7, #4]
 80028f0:	f021 faa4 	bl	8023e3c <siprintf>
                  "U585",
                  STBOX1_PACKAGENAME,
                  STBOX1_VERSION_MAJOR,
                  STBOX1_VERSION_MINOR,
                  STBOX1_VERSION_PATCH);
}
 80028f4:	bf00      	nop
 80028f6:	3708      	adds	r7, #8
 80028f8:	46bd      	mov	sp, r7
 80028fa:	bd80      	pop	{r7, pc}
 80028fc:	08027038 	.word	0x08027038
 8002900:	08027090 	.word	0x08027090
 8002904:	08027098 	.word	0x08027098

08002908 <ExtConfigReadBanksFwIdCommandCallback>:
 * @param  uint16_t *FwId1 Bank1 Firmware Id
 * @param  uint16_t *FwId2 Bank2 Firmware Id
 * @retval None
 */
void ExtConfigReadBanksFwIdCommandCallback (uint8_t *CurBank,uint16_t *FwId1,uint16_t *FwId2)
{
 8002908:	b580      	push	{r7, lr}
 800290a:	b084      	sub	sp, #16
 800290c:	af00      	add	r7, sp, #0
 800290e:	60f8      	str	r0, [r7, #12]
 8002910:	60b9      	str	r1, [r7, #8]
 8002912:	607a      	str	r2, [r7, #4]
  ReadFlashBanksFwId(FwId1,FwId2);
 8002914:	6879      	ldr	r1, [r7, #4]
 8002916:	68b8      	ldr	r0, [r7, #8]
 8002918:	f001 f9ce 	bl	8003cb8 <ReadFlashBanksFwId>
  *CurBank=CurrentActiveBank;
 800291c:	4b04      	ldr	r3, [pc, #16]	@ (8002930 <ExtConfigReadBanksFwIdCommandCallback+0x28>)
 800291e:	681b      	ldr	r3, [r3, #0]
 8002920:	b2da      	uxtb	r2, r3
 8002922:	68fb      	ldr	r3, [r7, #12]
 8002924:	701a      	strb	r2, [r3, #0]
}
 8002926:	bf00      	nop
 8002928:	3710      	adds	r7, #16
 800292a:	46bd      	mov	sp, r7
 800292c:	bd80      	pop	{r7, pc}
 800292e:	bf00      	nop
 8002930:	20000590 	.word	0x20000590

08002934 <ExtConfigBanksSwapCommandCallback>:
 * @brief  Callback Function for answering to BanksSwap command
 * @param  None
 * @retval None
 */
void ExtConfigBanksSwapCommandCallback(void)
{
 8002934:	b580      	push	{r7, lr}
 8002936:	b082      	sub	sp, #8
 8002938:	af00      	add	r7, sp, #0
  uint16_t FwId1,FwId2;

  ReadFlashBanksFwId(&FwId1,&FwId2);
 800293a:	1d3a      	adds	r2, r7, #4
 800293c:	1dbb      	adds	r3, r7, #6
 800293e:	4611      	mov	r1, r2
 8002940:	4618      	mov	r0, r3
 8002942:	f001 f9b9 	bl	8003cb8 <ReadFlashBanksFwId>
  if(FwId2!=OTA_OTA_FW_ID_NOT_VALID) {
 8002946:	88bb      	ldrh	r3, [r7, #4]
 8002948:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 800294c:	4293      	cmp	r3, r2
 800294e:	d012      	beq.n	8002976 <ExtConfigBanksSwapCommandCallback+0x42>
    STBOX1_PRINTF("Swapping to Bank%d\n",(CurrentActiveBank==1) ? 0 : 1);
 8002950:	4b16      	ldr	r3, [pc, #88]	@ (80029ac <ExtConfigBanksSwapCommandCallback+0x78>)
 8002952:	681b      	ldr	r3, [r3, #0]
 8002954:	2b01      	cmp	r3, #1
 8002956:	bf14      	ite	ne
 8002958:	2301      	movne	r3, #1
 800295a:	2300      	moveq	r3, #0
 800295c:	b2db      	uxtb	r3, r3
 800295e:	4619      	mov	r1, r3
 8002960:	4813      	ldr	r0, [pc, #76]	@ (80029b0 <ExtConfigBanksSwapCommandCallback+0x7c>)
 8002962:	f021 f9fb 	bl	8023d5c <iprintf>
    STBOX1_PRINTF("%s will restart after the disconnection\r\n",STBOX1_PACKAGENAME);
 8002966:	4913      	ldr	r1, [pc, #76]	@ (80029b4 <ExtConfigBanksSwapCommandCallback+0x80>)
 8002968:	4813      	ldr	r0, [pc, #76]	@ (80029b8 <ExtConfigBanksSwapCommandCallback+0x84>)
 800296a:	f021 f9f7 	bl	8023d5c <iprintf>
    NeedToSwapBanks = 1;
 800296e:	4b13      	ldr	r3, [pc, #76]	@ (80029bc <ExtConfigBanksSwapCommandCallback+0x88>)
 8002970:	2201      	movs	r2, #1
 8002972:	601a      	str	r2, [r3, #0]
  } else {
    STBOX1_PRINTF("Not Valid fw on Bank%d\n\tCommand Rejected\n",(CurrentActiveBank==1) ? 0 : 1);
    STBOX1_PRINTF("\tLoad a Firwmare on Bank%d\n",(CurrentActiveBank==1) ? 0 : 1);
  }
}
 8002974:	e015      	b.n	80029a2 <ExtConfigBanksSwapCommandCallback+0x6e>
    STBOX1_PRINTF("Not Valid fw on Bank%d\n\tCommand Rejected\n",(CurrentActiveBank==1) ? 0 : 1);
 8002976:	4b0d      	ldr	r3, [pc, #52]	@ (80029ac <ExtConfigBanksSwapCommandCallback+0x78>)
 8002978:	681b      	ldr	r3, [r3, #0]
 800297a:	2b01      	cmp	r3, #1
 800297c:	bf14      	ite	ne
 800297e:	2301      	movne	r3, #1
 8002980:	2300      	moveq	r3, #0
 8002982:	b2db      	uxtb	r3, r3
 8002984:	4619      	mov	r1, r3
 8002986:	480e      	ldr	r0, [pc, #56]	@ (80029c0 <ExtConfigBanksSwapCommandCallback+0x8c>)
 8002988:	f021 f9e8 	bl	8023d5c <iprintf>
    STBOX1_PRINTF("\tLoad a Firwmare on Bank%d\n",(CurrentActiveBank==1) ? 0 : 1);
 800298c:	4b07      	ldr	r3, [pc, #28]	@ (80029ac <ExtConfigBanksSwapCommandCallback+0x78>)
 800298e:	681b      	ldr	r3, [r3, #0]
 8002990:	2b01      	cmp	r3, #1
 8002992:	bf14      	ite	ne
 8002994:	2301      	movne	r3, #1
 8002996:	2300      	moveq	r3, #0
 8002998:	b2db      	uxtb	r3, r3
 800299a:	4619      	mov	r1, r3
 800299c:	4809      	ldr	r0, [pc, #36]	@ (80029c4 <ExtConfigBanksSwapCommandCallback+0x90>)
 800299e:	f021 f9dd 	bl	8023d5c <iprintf>
}
 80029a2:	bf00      	nop
 80029a4:	3708      	adds	r7, #8
 80029a6:	46bd      	mov	sp, r7
 80029a8:	bd80      	pop	{r7, pc}
 80029aa:	bf00      	nop
 80029ac:	20000590 	.word	0x20000590
 80029b0:	08027304 	.word	0x08027304
 80029b4:	08027038 	.word	0x08027038
 80029b8:	08027048 	.word	0x08027048
 80029bc:	200004d4 	.word	0x200004d4
 80029c0:	08027318 	.word	0x08027318
 80029c4:	08027344 	.word	0x08027344

080029c8 <SetBoardName>:
  * @brief  Set Board Name.
  * @param  None
  * @retval None
  */
void SetBoardName(void)
{
 80029c8:	b580      	push	{r7, lr}
 80029ca:	af00      	add	r7, sp, #0
  sprintf(BLE_StackValue.BoardName, "%s", STBOX1_FW_PACKAGENAME);
 80029cc:	4a03      	ldr	r2, [pc, #12]	@ (80029dc <SetBoardName+0x14>)
 80029ce:	4904      	ldr	r1, [pc, #16]	@ (80029e0 <SetBoardName+0x18>)
 80029d0:	4804      	ldr	r0, [pc, #16]	@ (80029e4 <SetBoardName+0x1c>)
 80029d2:	f021 fa33 	bl	8023e3c <siprintf>
}
 80029d6:	bf00      	nop
 80029d8:	bd80      	pop	{r7, pc}
 80029da:	bf00      	nop
 80029dc:	08027360 	.word	0x08027360
 80029e0:	080272ec 	.word	0x080272ec
 80029e4:	20001b19 	.word	0x20001b19

080029e8 <BluetoothInit>:
/** @brief Initialize the BlueNRG stack and services
  * @param  None
  * @retval None
  */
void BluetoothInit(void)
{
 80029e8:	b580      	push	{r7, lr}
 80029ea:	af00      	add	r7, sp, #0
  /* BlueNRG stack setting */
  BLE_StackValue.ConfigValueOffsets                   = CONFIG_VALUE_OFFSETS;
 80029ec:	4b25      	ldr	r3, [pc, #148]	@ (8002a84 <BluetoothInit+0x9c>)
 80029ee:	2200      	movs	r2, #0
 80029f0:	701a      	strb	r2, [r3, #0]
  BLE_StackValue.ConfigValuelength                    = CONFIG_VALUE_LENGTH;
 80029f2:	4b24      	ldr	r3, [pc, #144]	@ (8002a84 <BluetoothInit+0x9c>)
 80029f4:	2206      	movs	r2, #6
 80029f6:	705a      	strb	r2, [r3, #1]
  // Changed to GAP_BROADCASTER_ROLE from GAP_ROLES for BLE periodic advertising
  if (PERIODIC_ADV) {
    BLE_StackValue.GAP_Roles                          = GAP_ROLES;
  } else if (ENABLE_SCAN) {
    BLE_StackValue.GAP_Roles                          = GAP_CENTRAL_ROLE;
 80029f8:	4b22      	ldr	r3, [pc, #136]	@ (8002a84 <BluetoothInit+0x9c>)
 80029fa:	2204      	movs	r2, #4
 80029fc:	709a      	strb	r2, [r3, #2]
  }
  BLE_StackValue.GAP_Roles                            = GAP_ROLES;
 80029fe:	4b21      	ldr	r3, [pc, #132]	@ (8002a84 <BluetoothInit+0x9c>)
 8002a00:	2201      	movs	r2, #1
 8002a02:	709a      	strb	r2, [r3, #2]
  BLE_StackValue.IO_capabilities                      = IO_CAPABILITIES;
 8002a04:	4b1f      	ldr	r3, [pc, #124]	@ (8002a84 <BluetoothInit+0x9c>)
 8002a06:	2200      	movs	r2, #0
 8002a08:	70da      	strb	r2, [r3, #3]
  /* Regular Auth req is BONDING - Change to NO_BONDING for periodic adv */
  BLE_StackValue.AuthenticationRequirements           = NO_BONDING;
 8002a0a:	4b1e      	ldr	r3, [pc, #120]	@ (8002a84 <BluetoothInit+0x9c>)
 8002a0c:	2200      	movs	r2, #0
 8002a0e:	711a      	strb	r2, [r3, #4]
  BLE_StackValue.MITM_ProtectionRequirements          = AUTHENTICATION_REQUIREMENTS;
 8002a10:	4b1c      	ldr	r3, [pc, #112]	@ (8002a84 <BluetoothInit+0x9c>)
 8002a12:	2201      	movs	r2, #1
 8002a14:	715a      	strb	r2, [r3, #5]
  BLE_StackValue.SecureConnectionSupportOptionCode    = SECURE_CONNECTION_SUPPORT_OPTION_CODE;
 8002a16:	4b1b      	ldr	r3, [pc, #108]	@ (8002a84 <BluetoothInit+0x9c>)
 8002a18:	2201      	movs	r2, #1
 8002a1a:	719a      	strb	r2, [r3, #6]
  BLE_StackValue.SecureConnectionKeypressNotification = SECURE_CONNECTION_KEYPRESS_NOTIFICATION;
 8002a1c:	4b19      	ldr	r3, [pc, #100]	@ (8002a84 <BluetoothInit+0x9c>)
 8002a1e:	2200      	movs	r2, #0
 8002a20:	71da      	strb	r2, [r3, #7]

  /* Use BLE Random Address */
  BLE_StackValue.OwnAddressType = ADDRESS_TYPE;
 8002a22:	4b18      	ldr	r3, [pc, #96]	@ (8002a84 <BluetoothInit+0x9c>)
 8002a24:	2201      	movs	r2, #1
 8002a26:	779a      	strb	r2, [r3, #30]

  /* Set the BLE Board Name */
  SetBoardName();
 8002a28:	f7ff ffce 	bl	80029c8 <SetBoardName>
  /* En_High_Power Enable High Power mode.
     High power mode should be enabled only to reach the maximum output power.
     Values:
     - 0x00: Normal Power
     - 0x01: High Power */
  BLE_StackValue.EnableHighPowerMode = ENABLE_HIGH_POWER_MODE;
 8002a2c:	4b15      	ldr	r3, [pc, #84]	@ (8002a84 <BluetoothInit+0x9c>)
 8002a2e:	2201      	movs	r2, #1
 8002a30:	721a      	strb	r2, [r3, #8]

  /* Values: 0x00 ... 0x31 - The value depends on the device */
  BLE_StackValue.PowerAmplifierOutputLevel = POWER_AMPLIFIER_OUTPUT_LEVEL;
 8002a32:	4b14      	ldr	r3, [pc, #80]	@ (8002a84 <BluetoothInit+0x9c>)
 8002a34:	2204      	movs	r2, #4
 8002a36:	725a      	strb	r2, [r3, #9]

  /* BlueNRG services setting */
  BLE_StackValue.EnableConfig    = ENABLE_CONFIG;
 8002a38:	4b12      	ldr	r3, [pc, #72]	@ (8002a84 <BluetoothInit+0x9c>)
 8002a3a:	2200      	movs	r2, #0
 8002a3c:	729a      	strb	r2, [r3, #10]
  BLE_StackValue.EnableConsole   = ENABLE_CONSOLE;
 8002a3e:	4b11      	ldr	r3, [pc, #68]	@ (8002a84 <BluetoothInit+0x9c>)
 8002a40:	2201      	movs	r2, #1
 8002a42:	72da      	strb	r2, [r3, #11]
  BLE_StackValue.EnableExtConfig = ENABLE_EXT_CONFIG;
 8002a44:	4b0f      	ldr	r3, [pc, #60]	@ (8002a84 <BluetoothInit+0x9c>)
 8002a46:	2201      	movs	r2, #1
 8002a48:	731a      	strb	r2, [r3, #12]

  /* For Enabling the Secure Connection */
  BLE_StackValue.EnableSecureConnection = ENABLE_SECURE_CONNECTION;
 8002a4a:	4b0e      	ldr	r3, [pc, #56]	@ (8002a84 <BluetoothInit+0x9c>)
 8002a4c:	2200      	movs	r2, #0
 8002a4e:	755a      	strb	r2, [r3, #21]
  // BLE_StackValue.EnableSecureConnection = 0;
  /* Default Secure PIN */
  BLE_StackValue.SecurePIN = SECURE_PIN;
 8002a50:	4b0c      	ldr	r3, [pc, #48]	@ (8002a84 <BluetoothInit+0x9c>)
 8002a52:	4a0d      	ldr	r2, [pc, #52]	@ (8002a88 <BluetoothInit+0xa0>)
 8002a54:	619a      	str	r2, [r3, #24]
  /* For creating a Random Secure PIN */
  BLE_StackValue.EnableRandomSecurePIN = ENABLE_RANDOM_SECURE_PIN;
 8002a56:	4b0b      	ldr	r3, [pc, #44]	@ (8002a84 <BluetoothInit+0x9c>)
 8002a58:	2200      	movs	r2, #0
 8002a5a:	771a      	strb	r2, [r3, #28]

  /* Used platform */
  BLE_StackValue.BoardId = BLE_MANAGER_USED_PLATFORM;
 8002a5c:	4b09      	ldr	r3, [pc, #36]	@ (8002a84 <BluetoothInit+0x9c>)
 8002a5e:	220d      	movs	r2, #13
 8002a60:	f883 202a 	strb.w	r2, [r3, #42]	@ 0x2a

  if (BLE_StackValue.EnableSecureConnection)
 8002a64:	4b07      	ldr	r3, [pc, #28]	@ (8002a84 <BluetoothInit+0x9c>)
 8002a66:	7d5b      	ldrb	r3, [r3, #21]
 8002a68:	2b00      	cmp	r3, #0
 8002a6a:	d003      	beq.n	8002a74 <BluetoothInit+0x8c>
  {
    /* Using the Secure Connection, the Rescan should be done by BLE chip */
    BLE_StackValue.ForceRescan = 0;
 8002a6c:	4b05      	ldr	r3, [pc, #20]	@ (8002a84 <BluetoothInit+0x9c>)
 8002a6e:	2200      	movs	r2, #0
 8002a70:	775a      	strb	r2, [r3, #29]
 8002a72:	e002      	b.n	8002a7a <BluetoothInit+0x92>
  }
  else
  {
    BLE_StackValue.ForceRescan = 1;
 8002a74:	4b03      	ldr	r3, [pc, #12]	@ (8002a84 <BluetoothInit+0x9c>)
 8002a76:	2201      	movs	r2, #1
 8002a78:	775a      	strb	r2, [r3, #29]
  }

  // InitBleManager();
  InitBleBroadcaster();
 8002a7a:	f7fe ff3b 	bl	80018f4 <InitBleBroadcaster>
}
 8002a7e:	bf00      	nop
 8002a80:	bd80      	pop	{r7, pc}
 8002a82:	bf00      	nop
 8002a84:	20001b0c 	.word	0x20001b0c
 8002a88:	0001e240 	.word	0x0001e240

08002a8c <InitBLEIntForBlueNRGLP>:
  * @brief  Enable BlueNRG-LP Interrupt.
  * @param  None
  * @retval None
  */
void InitBLEIntForBlueNRGLP(void)
{
 8002a8c:	b580      	push	{r7, lr}
 8002a8e:	af00      	add	r7, sp, #0
  HAL_EXTI_GetHandle(&H_EXTI, EXTI_LINE);
 8002a90:	4909      	ldr	r1, [pc, #36]	@ (8002ab8 <InitBLEIntForBlueNRGLP+0x2c>)
 8002a92:	480a      	ldr	r0, [pc, #40]	@ (8002abc <InitBLEIntForBlueNRGLP+0x30>)
 8002a94:	f00c fab3 	bl	800effe <HAL_EXTI_GetHandle>
  HAL_EXTI_RegisterCallback(&H_EXTI, HAL_EXTI_COMMON_CB_ID, hci_tl_lowlevel_isr);
 8002a98:	4a09      	ldr	r2, [pc, #36]	@ (8002ac0 <InitBLEIntForBlueNRGLP+0x34>)
 8002a9a:	2100      	movs	r1, #0
 8002a9c:	4807      	ldr	r0, [pc, #28]	@ (8002abc <InitBLEIntForBlueNRGLP+0x30>)
 8002a9e:	f00c fa82 	bl	800efa6 <HAL_EXTI_RegisterCallback>
  HAL_NVIC_SetPriority(HCI_TL_SPI_EXTI_IRQn, 0, 0);
 8002aa2:	2200      	movs	r2, #0
 8002aa4:	2100      	movs	r1, #0
 8002aa6:	2016      	movs	r0, #22
 8002aa8:	f00b f8e3 	bl	800dc72 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(HCI_TL_SPI_EXTI_IRQn);
 8002aac:	2016      	movs	r0, #22
 8002aae:	f00b f8fa 	bl	800dca6 <HAL_NVIC_EnableIRQ>
}
 8002ab2:	bf00      	nop
 8002ab4:	bd80      	pop	{r7, pc}
 8002ab6:	bf00      	nop
 8002ab8:	0600000b 	.word	0x0600000b
 8002abc:	200005a4 	.word	0x200005a4
 8002ac0:	08004ced 	.word	0x08004ced

08002ac4 <BLE_InitCustomService>:
  * @brief  Custom Service Initialization.
  * @param  None
  * @retval None
  */
void BLE_InitCustomService(void)
{
 8002ac4:	b580      	push	{r7, lr}
 8002ac6:	af00      	add	r7, sp, #0

  /* Define Custom Function for Connection Completed */
  CustomConnectionCompleted = ConnectionCompletedFunction;
 8002ac8:	4b2c      	ldr	r3, [pc, #176]	@ (8002b7c <BLE_InitCustomService+0xb8>)
 8002aca:	4a2d      	ldr	r2, [pc, #180]	@ (8002b80 <BLE_InitCustomService+0xbc>)
 8002acc:	601a      	str	r2, [r3, #0]

  /* Define Custom Function for Disconnection Completed */
  CustomDisconnectionCompleted = DisconnectionCompletedFunction;
 8002ace:	4b2d      	ldr	r3, [pc, #180]	@ (8002b84 <BLE_InitCustomService+0xc0>)
 8002ad0:	4a2d      	ldr	r2, [pc, #180]	@ (8002b88 <BLE_InitCustomService+0xc4>)
 8002ad2:	601a      	str	r2, [r3, #0]

  /* Define Custom Function for Attribute Modify Config */
  CustomAttrModConfigCallback = AttrModConfigFunction;
 8002ad4:	4b2d      	ldr	r3, [pc, #180]	@ (8002b8c <BLE_InitCustomService+0xc8>)
 8002ad6:	4a2e      	ldr	r2, [pc, #184]	@ (8002b90 <BLE_InitCustomService+0xcc>)
 8002ad8:	601a      	str	r2, [r3, #0]

  /* Define Custom Function for Pairing Completed */
  CustomPairingCompleted = PairingCompletedFunction;
 8002ada:	4b2e      	ldr	r3, [pc, #184]	@ (8002b94 <BLE_InitCustomService+0xd0>)
 8002adc:	4a2e      	ldr	r2, [pc, #184]	@ (8002b98 <BLE_InitCustomService+0xd4>)
 8002ade:	601a      	str	r2, [r3, #0]

  /* Define Custom Function for Set Connectable */
  CustomSetConnectable = SetConnectableFunction;
 8002ae0:	4b2e      	ldr	r3, [pc, #184]	@ (8002b9c <BLE_InitCustomService+0xd8>)
 8002ae2:	4a2f      	ldr	r2, [pc, #188]	@ (8002ba0 <BLE_InitCustomService+0xdc>)
 8002ae4:	601a      	str	r2, [r3, #0]

  /* Define Custom Function for Aci Gatt Tx Pool Available Event */
  CustomAciGattTxPoolAvailableEvent = AciGattTxPoolAvailableEventFunction;
 8002ae6:	4b2f      	ldr	r3, [pc, #188]	@ (8002ba4 <BLE_InitCustomService+0xe0>)
 8002ae8:	4a2f      	ldr	r2, [pc, #188]	@ (8002ba8 <BLE_InitCustomService+0xe4>)
 8002aea:	601a      	str	r2, [r3, #0]

  /* Define Custom Function for Hardware Error Event Handler */
  CustomHardwareErrorEventHandler = HardwareErrorEventHandlerFunction;
 8002aec:	4b2f      	ldr	r3, [pc, #188]	@ (8002bac <BLE_InitCustomService+0xe8>)
 8002aee:	4a30      	ldr	r2, [pc, #192]	@ (8002bb0 <BLE_InitCustomService+0xec>)
 8002af0:	601a      	str	r2, [r3, #0]

  /* Define Custom Function for Debug Console Command parsing */
  CustomDebugConsoleParsingCallback = DebugConsoleParsing;
 8002af2:	4b30      	ldr	r3, [pc, #192]	@ (8002bb4 <BLE_InitCustomService+0xf0>)
 8002af4:	4a30      	ldr	r2, [pc, #192]	@ (8002bb8 <BLE_InitCustomService+0xf4>)
 8002af6:	601a      	str	r2, [r3, #0]

  /***************************************************************************************
    * Callback functions to manage the notify events and write request for each features *
    **************************************************************************************/

  CustomNotifyEventBattery =                     NotifyEventBattery;
 8002af8:	4b30      	ldr	r3, [pc, #192]	@ (8002bbc <BLE_InitCustomService+0xf8>)
 8002afa:	4a31      	ldr	r2, [pc, #196]	@ (8002bc0 <BLE_InitCustomService+0xfc>)
 8002afc:	601a      	str	r2, [r3, #0]

  CustomNotifyEventEnv =                         NotifyEventEnv;
 8002afe:	4b31      	ldr	r3, [pc, #196]	@ (8002bc4 <BLE_InitCustomService+0x100>)
 8002b00:	4a31      	ldr	r2, [pc, #196]	@ (8002bc8 <BLE_InitCustomService+0x104>)
 8002b02:	601a      	str	r2, [r3, #0]

  CustomNotifyEventInertial =                    NotifyEventInertial;
 8002b04:	4b31      	ldr	r3, [pc, #196]	@ (8002bcc <BLE_InitCustomService+0x108>)
 8002b06:	4a32      	ldr	r2, [pc, #200]	@ (8002bd0 <BLE_InitCustomService+0x10c>)
 8002b08:	601a      	str	r2, [r3, #0]

  CustomNotifyEventPnPLike =                     NotifyEventPnpLike;
 8002b0a:	4b32      	ldr	r3, [pc, #200]	@ (8002bd4 <BLE_InitCustomService+0x110>)
 8002b0c:	4a32      	ldr	r2, [pc, #200]	@ (8002bd8 <BLE_InitCustomService+0x114>)
 8002b0e:	601a      	str	r2, [r3, #0]
  CustomWriteRequestPnPLike =                    WriteRequestPnPLike;
 8002b10:	4b32      	ldr	r3, [pc, #200]	@ (8002bdc <BLE_InitCustomService+0x118>)
 8002b12:	4a33      	ldr	r2, [pc, #204]	@ (8002be0 <BLE_InitCustomService+0x11c>)
 8002b14:	601a      	str	r2, [r3, #0]

  /************************************************************************************
    * Callback functions to manage the extended configuration characteristic commands *
    ***********************************************************************************/
  CustomExtConfigUidCommandCallback  = ExtExtConfigUidCommandCallback;
 8002b16:	4b33      	ldr	r3, [pc, #204]	@ (8002be4 <BLE_InitCustomService+0x120>)
 8002b18:	4a33      	ldr	r2, [pc, #204]	@ (8002be8 <BLE_InitCustomService+0x124>)
 8002b1a:	601a      	str	r2, [r3, #0]
  CustomExtConfigVersionFwCommandCallback = ExtConfigVersionFwCommandCallback;
 8002b1c:	4b33      	ldr	r3, [pc, #204]	@ (8002bec <BLE_InitCustomService+0x128>)
 8002b1e:	4a34      	ldr	r2, [pc, #208]	@ (8002bf0 <BLE_InitCustomService+0x12c>)
 8002b20:	601a      	str	r2, [r3, #0]
  CustomExtConfigInfoCommandCallback = ExtConfigInfoCommandCallback;
 8002b22:	4b34      	ldr	r3, [pc, #208]	@ (8002bf4 <BLE_InitCustomService+0x130>)
 8002b24:	4a34      	ldr	r2, [pc, #208]	@ (8002bf8 <BLE_InitCustomService+0x134>)
 8002b26:	601a      	str	r2, [r3, #0]
  CustomExtConfigHelpCommandCallback = ExtConfigHelpCommandCallback;
 8002b28:	4b34      	ldr	r3, [pc, #208]	@ (8002bfc <BLE_InitCustomService+0x138>)
 8002b2a:	4a35      	ldr	r2, [pc, #212]	@ (8002c00 <BLE_InitCustomService+0x13c>)
 8002b2c:	601a      	str	r2, [r3, #0]

  CustomExtConfigReadBanksFwIdCommandCallback       = ExtConfigReadBanksFwIdCommandCallback;
 8002b2e:	4b35      	ldr	r3, [pc, #212]	@ (8002c04 <BLE_InitCustomService+0x140>)
 8002b30:	4a35      	ldr	r2, [pc, #212]	@ (8002c08 <BLE_InitCustomService+0x144>)
 8002b32:	601a      	str	r2, [r3, #0]
    * ReadRequestEnvFunction function is already defined.
    *
  */

  /* Define Custom Function for Read Request Environmental Data */
  CustomReadRequestEnv = ReadRequestEnvFunction;
 8002b34:	4b35      	ldr	r3, [pc, #212]	@ (8002c0c <BLE_InitCustomService+0x148>)
 8002b36:	4a36      	ldr	r2, [pc, #216]	@ (8002c10 <BLE_InitCustomService+0x14c>)
 8002b38:	601a      	str	r2, [r3, #0]
    * BLE_InitEnvService(PressEnable,HumEnable,NumTempEnabled)
    * BleManagerAddChar(BleCharPointer= BLE_InitEnvService(1, 1, 1));
  */

  /* Characteristc allocation for battery features */
  BleManagerAddChar(BLE_InitBatteryService());
 8002b3a:	f01a f9c5 	bl	801cec8 <BLE_InitBatteryService>
 8002b3e:	4603      	mov	r3, r0
 8002b40:	4618      	mov	r0, r3
 8002b42:	f01a ffbd 	bl	801dac0 <BleManagerAddChar>

  /* Characteristc allocation for environmental features */
  /* BLE_InitEnvService(PressEnable,HumEnable,NumTempEnabled) */
  BleManagerAddChar(BLE_InitEnvService(ENABLE_ENV_PRESSURE_DATA,
 8002b46:	2201      	movs	r2, #1
 8002b48:	2100      	movs	r1, #0
 8002b4a:	2001      	movs	r0, #1
 8002b4c:	f01a fa44 	bl	801cfd8 <BLE_InitEnvService>
 8002b50:	4603      	mov	r3, r0
 8002b52:	4618      	mov	r0, r3
 8002b54:	f01a ffb4 	bl	801dac0 <BleManagerAddChar>
                                       ENABLE_ENV_HUMIDITY_DATA,
                                       ENABLE_ENV_TEMPERATURE_DATA));

  /* Characteristc allocation for inertial features */
  /* BLE_InitInertialService(AccEnable, GyroEnable, MagEnabled) */
  BleManagerAddChar(BLE_InitInertialService(ENABLE_ACC_DATA, ENABLE_GYRO_DATA, ENABLE_MAG_DATA));
 8002b58:	2201      	movs	r2, #1
 8002b5a:	2101      	movs	r1, #1
 8002b5c:	2001      	movs	r0, #1
 8002b5e:	f01a fc5d 	bl	801d41c <BLE_InitInertialService>
 8002b62:	4603      	mov	r3, r0
 8002b64:	4618      	mov	r0, r3
 8002b66:	f01a ffab 	bl	801dac0 <BleManagerAddChar>

  /* Characteristc allocation for SD Logging features */
  BleManagerAddChar(BLE_InitPnPLikeService());
 8002b6a:	f01a fd39 	bl	801d5e0 <BLE_InitPnPLikeService>
 8002b6e:	4603      	mov	r3, r0
 8002b70:	4618      	mov	r0, r3
 8002b72:	f01a ffa5 	bl	801dac0 <BleManagerAddChar>

}
 8002b76:	bf00      	nop
 8002b78:	bd80      	pop	{r7, pc}
 8002b7a:	bf00      	nop
 8002b7c:	20001b44 	.word	0x20001b44
 8002b80:	08002749 	.word	0x08002749
 8002b84:	20001b48 	.word	0x20001b48
 8002b88:	08002601 	.word	0x08002601
 8002b8c:	20001b58 	.word	0x20001b58
 8002b90:	08002c15 	.word	0x08002c15
 8002b94:	20001b38 	.word	0x20001b38
 8002b98:	08002c39 	.word	0x08002c39
 8002b9c:	20001b40 	.word	0x20001b40
 8002ba0:	08002c5d 	.word	0x08002c5d
 8002ba4:	20001b4c 	.word	0x20001b4c
 8002ba8:	08002c7d 	.word	0x08002c7d
 8002bac:	20001b50 	.word	0x20001b50
 8002bb0:	08002c95 	.word	0x08002c95
 8002bb4:	20001b54 	.word	0x20001b54
 8002bb8:	08002181 	.word	0x08002181
 8002bbc:	20001928 	.word	0x20001928
 8002bc0:	08001ead 	.word	0x08001ead
 8002bc4:	2000195c 	.word	0x2000195c
 8002bc8:	08001f51 	.word	0x08001f51
 8002bcc:	20001994 	.word	0x20001994
 8002bd0:	08002069 	.word	0x08002069
 8002bd4:	200019cc 	.word	0x200019cc
 8002bd8:	08002cb9 	.word	0x08002cb9
 8002bdc:	200019d0 	.word	0x200019d0
 8002be0:	08001d85 	.word	0x08001d85
 8002be4:	20001b88 	.word	0x20001b88
 8002be8:	080027c1 	.word	0x080027c1
 8002bec:	20001b98 	.word	0x20001b98
 8002bf0:	080028d5 	.word	0x080028d5
 8002bf4:	20001b8c 	.word	0x20001b8c
 8002bf8:	080027e1 	.word	0x080027e1
 8002bfc:	20001b90 	.word	0x20001b90
 8002c00:	080028b9 	.word	0x080028b9
 8002c04:	20001b80 	.word	0x20001b80
 8002c08:	08002909 	.word	0x08002909
 8002c0c:	20001958 	.word	0x20001958
 8002c10:	08002599 	.word	0x08002599

08002c14 <AttrModConfigFunction>:
  * @brief  This function is called when there is a change on the gatt attribute.
  * @param  None
  * @retval None
  */
__weak void AttrModConfigFunction(uint8_t *att_data, uint8_t data_length)
{
 8002c14:	b580      	push	{r7, lr}
 8002c16:	b082      	sub	sp, #8
 8002c18:	af00      	add	r7, sp, #0
 8002c1a:	6078      	str	r0, [r7, #4]
 8002c1c:	460b      	mov	r3, r1
 8002c1e:	70fb      	strb	r3, [r7, #3]
  BLE_MANAGER_PRINTF("Call to AttrModConfigFunction\r\n");
 8002c20:	4804      	ldr	r0, [pc, #16]	@ (8002c34 <AttrModConfigFunction+0x20>)
 8002c22:	f021 f903 	bl	8023e2c <puts>
  BLE_MANAGER_DELAY(100);
 8002c26:	2064      	movs	r0, #100	@ 0x64
 8002c28:	f001 fde8 	bl	80047fc <HAL_Delay>

  /* NOTE: This function Should not be modified, when the callback is needed,
           the AttrModConfigFunction could be implemented in the user file
   */
}
 8002c2c:	bf00      	nop
 8002c2e:	3708      	adds	r7, #8
 8002c30:	46bd      	mov	sp, r7
 8002c32:	bd80      	pop	{r7, pc}
 8002c34:	08027500 	.word	0x08027500

08002c38 <PairingCompletedFunction>:
  *         or a pairing procedure timeout has occurred or the pairing has failed.
  * @param  uint8_t PairingStatus
  * @retval None
  */
__weak void PairingCompletedFunction(uint8_t PairingStatus)
{
 8002c38:	b580      	push	{r7, lr}
 8002c3a:	b082      	sub	sp, #8
 8002c3c:	af00      	add	r7, sp, #0
 8002c3e:	4603      	mov	r3, r0
 8002c40:	71fb      	strb	r3, [r7, #7]
  BLE_MANAGER_PRINTF("Call to PairingCompletedFunction\r\n");
 8002c42:	4805      	ldr	r0, [pc, #20]	@ (8002c58 <PairingCompletedFunction+0x20>)
 8002c44:	f021 f8f2 	bl	8023e2c <puts>
  BLE_MANAGER_DELAY(100);
 8002c48:	2064      	movs	r0, #100	@ 0x64
 8002c4a:	f001 fdd7 	bl	80047fc <HAL_Delay>

  /* NOTE: This function Should not be modified, when the callback is needed,
           the PairingCompletedFunction could be implemented in the user file
   */
}
 8002c4e:	bf00      	nop
 8002c50:	3708      	adds	r7, #8
 8002c52:	46bd      	mov	sp, r7
 8002c54:	bd80      	pop	{r7, pc}
 8002c56:	bf00      	nop
 8002c58:	08027520 	.word	0x08027520

08002c5c <SetConnectableFunction>:
  * @brief  This function is called when the device is put in connectable mode.
  * @param  uint8_t *ManufData Filling Manufacter Advertise data
  * @retval None
  */
__weak void SetConnectableFunction(uint8_t *ManufData)
{
 8002c5c:	b580      	push	{r7, lr}
 8002c5e:	b082      	sub	sp, #8
 8002c60:	af00      	add	r7, sp, #0
 8002c62:	6078      	str	r0, [r7, #4]
  BLE_MANAGER_PRINTF("Call to SetConnectableFunction\r\n");
 8002c64:	4804      	ldr	r0, [pc, #16]	@ (8002c78 <SetConnectableFunction+0x1c>)
 8002c66:	f021 f8e1 	bl	8023e2c <puts>
  BLE_MANAGER_DELAY(100);
 8002c6a:	2064      	movs	r0, #100	@ 0x64
 8002c6c:	f001 fdc6 	bl	80047fc <HAL_Delay>

  /* NOTE: This function Should not be modified, when the callback is needed,
           the SetConnectableFunction could be implemented in the user file
   */
}
 8002c70:	bf00      	nop
 8002c72:	3708      	adds	r7, #8
 8002c74:	46bd      	mov	sp, r7
 8002c76:	bd80      	pop	{r7, pc}
 8002c78:	08027544 	.word	0x08027544

08002c7c <AciGattTxPoolAvailableEventFunction>:
  *         or a pairing procedure timeout has occurred or the pairing has failed.
  * @param  None
  * @retval None
  */
__weak void AciGattTxPoolAvailableEventFunction(void)
{
 8002c7c:	b580      	push	{r7, lr}
 8002c7e:	af00      	add	r7, sp, #0
  BLE_MANAGER_PRINTF("Call to AciGattTxPoolAvailableEventFunction\r\n");
 8002c80:	4803      	ldr	r0, [pc, #12]	@ (8002c90 <AciGattTxPoolAvailableEventFunction+0x14>)
 8002c82:	f021 f8d3 	bl	8023e2c <puts>
  BLE_MANAGER_DELAY(100);
 8002c86:	2064      	movs	r0, #100	@ 0x64
 8002c88:	f001 fdb8 	bl	80047fc <HAL_Delay>

  /* NOTE: This function Should not be modified, when the callback is needed,
           the AciGattTxPoolAvailableEventFunction could be implemented in the user file
   */
}
 8002c8c:	bf00      	nop
 8002c8e:	bd80      	pop	{r7, pc}
 8002c90:	08027564 	.word	0x08027564

08002c94 <HardwareErrorEventHandlerFunction>:
  * @brief  This event is used to notify the Host that a hardware failure has occurred in the Controller.
  * @param  uint8_t Hardware_Code Hardware Error Event code.
  * @retval None
  */
__weak void HardwareErrorEventHandlerFunction(uint8_t Hardware_Code)
{
 8002c94:	b580      	push	{r7, lr}
 8002c96:	b082      	sub	sp, #8
 8002c98:	af00      	add	r7, sp, #0
 8002c9a:	4603      	mov	r3, r0
 8002c9c:	71fb      	strb	r3, [r7, #7]
  BLE_MANAGER_PRINTF("Call to HardwareErrorEventHandlerFunction\r\n");
 8002c9e:	4805      	ldr	r0, [pc, #20]	@ (8002cb4 <HardwareErrorEventHandlerFunction+0x20>)
 8002ca0:	f021 f8c4 	bl	8023e2c <puts>
  BLE_MANAGER_DELAY(100);
 8002ca4:	2064      	movs	r0, #100	@ 0x64
 8002ca6:	f001 fda9 	bl	80047fc <HAL_Delay>

  /* NOTE: This function Should not be modified, when the callback is needed,
           the HardwareErrorEventHandlerFunction could be implemented in the user file
   */
}
 8002caa:	bf00      	nop
 8002cac:	3708      	adds	r7, #8
 8002cae:	46bd      	mov	sp, r7
 8002cb0:	bd80      	pop	{r7, pc}
 8002cb2:	bf00      	nop
 8002cb4:	08027594 	.word	0x08027594

08002cb8 <NotifyEventPnpLike>:
  * @brief  Callback Function for Un/Subscription Feature
  * @param  BLE_NotifyEvent_t Event Sub/Unsub
  * @retval None
  */
__weak void NotifyEventPnpLike(BLE_NotifyEvent_t Event)
{
 8002cb8:	b480      	push	{r7}
 8002cba:	b083      	sub	sp, #12
 8002cbc:	af00      	add	r7, sp, #0
 8002cbe:	4603      	mov	r3, r0
 8002cc0:	71fb      	strb	r3, [r7, #7]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(Event);
  /* NOTE: This function Should not be modified, when the callback is needed,
           the NotifyEventPnpLike could be implemented in the user file
   */
}
 8002cc2:	bf00      	nop
 8002cc4:	370c      	adds	r7, #12
 8002cc6:	46bd      	mov	sp, r7
 8002cc8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002ccc:	4770      	bx	lr
	...

08002cd0 <Configuration_PnPLAlloc>:
/* Objects instance ----------------------------------------------------------*/
static Configuration_PnPL sConfiguration_PnPL;

/* Public API definition -----------------------------------------------------*/
IPnPLComponent_t *Configuration_PnPLAlloc()
{
 8002cd0:	b480      	push	{r7}
 8002cd2:	b083      	sub	sp, #12
 8002cd4:	af00      	add	r7, sp, #0
  IPnPLComponent_t *pxObj = (IPnPLComponent_t *) &sConfiguration_PnPL;
 8002cd6:	4b07      	ldr	r3, [pc, #28]	@ (8002cf4 <Configuration_PnPLAlloc+0x24>)
 8002cd8:	607b      	str	r3, [r7, #4]
  if (pxObj != NULL)
 8002cda:	687b      	ldr	r3, [r7, #4]
 8002cdc:	2b00      	cmp	r3, #0
 8002cde:	d002      	beq.n	8002ce6 <Configuration_PnPLAlloc+0x16>
  {
    pxObj->vptr = &sConfiguration_PnPL_CompIF_vtbl;
 8002ce0:	687b      	ldr	r3, [r7, #4]
 8002ce2:	4a05      	ldr	r2, [pc, #20]	@ (8002cf8 <Configuration_PnPLAlloc+0x28>)
 8002ce4:	601a      	str	r2, [r3, #0]
  }
  return pxObj;
 8002ce6:	687b      	ldr	r3, [r7, #4]
}
 8002ce8:	4618      	mov	r0, r3
 8002cea:	370c      	adds	r7, #12
 8002cec:	46bd      	mov	sp, r7
 8002cee:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002cf2:	4770      	bx	lr
 8002cf4:	200004f0 	.word	0x200004f0
 8002cf8:	0802a428 	.word	0x0802a428

08002cfc <Configuration_PnPLInit>:

uint8_t Configuration_PnPLInit(IPnPLComponent_t *_this)
{
 8002cfc:	b580      	push	{r7, lr}
 8002cfe:	b084      	sub	sp, #16
 8002d00:	af00      	add	r7, sp, #0
 8002d02:	6078      	str	r0, [r7, #4]
  IPnPLComponent_t *component_if = _this;
 8002d04:	687b      	ldr	r3, [r7, #4]
 8002d06:	60fb      	str	r3, [r7, #12]
  PnPLAddComponent(component_if);
 8002d08:	68f8      	ldr	r0, [r7, #12]
 8002d0a:	f019 fc53 	bl	801c5b4 <PnPLAddComponent>
  configuration_comp_init();
 8002d0e:	f7fe fc21 	bl	8001554 <configuration_comp_init>
  return 0;
 8002d12:	2300      	movs	r3, #0
}
 8002d14:	4618      	mov	r0, r3
 8002d16:	3710      	adds	r7, #16
 8002d18:	46bd      	mov	sp, r7
 8002d1a:	bd80      	pop	{r7, pc}

08002d1c <Configuration_PnPL_vtblGetKey>:

/* IPnPLComponent virtual functions definition -------------------------------*/
char *Configuration_PnPL_vtblGetKey(IPnPLComponent_t *_this)
{
 8002d1c:	b580      	push	{r7, lr}
 8002d1e:	b082      	sub	sp, #8
 8002d20:	af00      	add	r7, sp, #0
 8002d22:	6078      	str	r0, [r7, #4]
  return configuration_get_key();
 8002d24:	f7fe fc22 	bl	800156c <configuration_get_key>
 8002d28:	4603      	mov	r3, r0
}
 8002d2a:	4618      	mov	r0, r3
 8002d2c:	3708      	adds	r7, #8
 8002d2e:	46bd      	mov	sp, r7
 8002d30:	bd80      	pop	{r7, pc}

08002d32 <Configuration_PnPL_vtblGetNCommands>:

uint8_t Configuration_PnPL_vtblGetNCommands(IPnPLComponent_t *_this)
{
 8002d32:	b480      	push	{r7}
 8002d34:	b083      	sub	sp, #12
 8002d36:	af00      	add	r7, sp, #0
 8002d38:	6078      	str	r0, [r7, #4]
  return 0;
 8002d3a:	2300      	movs	r3, #0
}
 8002d3c:	4618      	mov	r0, r3
 8002d3e:	370c      	adds	r7, #12
 8002d40:	46bd      	mov	sp, r7
 8002d42:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002d46:	4770      	bx	lr

08002d48 <Configuration_PnPL_vtblGetCommandKey>:

char *Configuration_PnPL_vtblGetCommandKey(IPnPLComponent_t *_this, uint8_t id)
{
 8002d48:	b480      	push	{r7}
 8002d4a:	b083      	sub	sp, #12
 8002d4c:	af00      	add	r7, sp, #0
 8002d4e:	6078      	str	r0, [r7, #4]
 8002d50:	460b      	mov	r3, r1
 8002d52:	70fb      	strb	r3, [r7, #3]
  return "";
 8002d54:	4b03      	ldr	r3, [pc, #12]	@ (8002d64 <Configuration_PnPL_vtblGetCommandKey+0x1c>)
}
 8002d56:	4618      	mov	r0, r3
 8002d58:	370c      	adds	r7, #12
 8002d5a:	46bd      	mov	sp, r7
 8002d5c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002d60:	4770      	bx	lr
 8002d62:	bf00      	nop
 8002d64:	08027694 	.word	0x08027694

08002d68 <Configuration_PnPL_vtblGetStatus>:

uint8_t Configuration_PnPL_vtblGetStatus(IPnPLComponent_t *_this, char **serializedJSON, uint32_t *size, uint8_t pretty)
{
 8002d68:	b580      	push	{r7, lr}
 8002d6a:	b088      	sub	sp, #32
 8002d6c:	af00      	add	r7, sp, #0
 8002d6e:	60f8      	str	r0, [r7, #12]
 8002d70:	60b9      	str	r1, [r7, #8]
 8002d72:	607a      	str	r2, [r7, #4]
 8002d74:	70fb      	strb	r3, [r7, #3]
  JSON_Value *tempJSON;
  JSON_Object *JSON_Status;

  tempJSON = json_value_init_object();
 8002d76:	f01e fd0f 	bl	8021798 <json_value_init_object>
 8002d7a:	61f8      	str	r0, [r7, #28]
  JSON_Status = json_value_get_object(tempJSON);
 8002d7c:	69f8      	ldr	r0, [r7, #28]
 8002d7e:	f01e fc46 	bl	802160e <json_value_get_object>
 8002d82:	61b8      	str	r0, [r7, #24]

  char *temp_s = "";
 8002d84:	4b21      	ldr	r3, [pc, #132]	@ (8002e0c <Configuration_PnPL_vtblGetStatus+0xa4>)
 8002d86:	617b      	str	r3, [r7, #20]
  configuration_get_version_fw(&temp_s);
 8002d88:	f107 0314 	add.w	r3, r7, #20
 8002d8c:	4618      	mov	r0, r3
 8002d8e:	f7fe fbf7 	bl	8001580 <configuration_get_version_fw>
  json_object_dotset_string(JSON_Status, "configuration.version_fw", temp_s);
 8002d92:	697b      	ldr	r3, [r7, #20]
 8002d94:	461a      	mov	r2, r3
 8002d96:	491e      	ldr	r1, [pc, #120]	@ (8002e10 <Configuration_PnPL_vtblGetStatus+0xa8>)
 8002d98:	69b8      	ldr	r0, [r7, #24]
 8002d9a:	f01f f8a9 	bl	8021ef0 <json_object_dotset_string>
  configuration_get_board_name(&temp_s);
 8002d9e:	f107 0314 	add.w	r3, r7, #20
 8002da2:	4618      	mov	r0, r3
 8002da4:	f7fe fc0c 	bl	80015c0 <configuration_get_board_name>
  json_object_dotset_string(JSON_Status, "configuration.board_name", temp_s);
 8002da8:	697b      	ldr	r3, [r7, #20]
 8002daa:	461a      	mov	r2, r3
 8002dac:	4919      	ldr	r1, [pc, #100]	@ (8002e14 <Configuration_PnPL_vtblGetStatus+0xac>)
 8002dae:	69b8      	ldr	r0, [r7, #24]
 8002db0:	f01f f89e 	bl	8021ef0 <json_object_dotset_string>
  json_object_dotset_number(JSON_Status, "configuration.c_type", COMP_TYPE_OTHER);
 8002db4:	f04f 0200 	mov.w	r2, #0
 8002db8:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8002dbc:	4916      	ldr	r1, [pc, #88]	@ (8002e18 <Configuration_PnPL_vtblGetStatus+0xb0>)
 8002dbe:	69b8      	ldr	r0, [r7, #24]
 8002dc0:	f01f f8b9 	bl	8021f36 <json_object_dotset_number>

  if (pretty == 1)
 8002dc4:	78fb      	ldrb	r3, [r7, #3]
 8002dc6:	2b01      	cmp	r3, #1
 8002dc8:	d10c      	bne.n	8002de4 <Configuration_PnPL_vtblGetStatus+0x7c>
  {
    *serializedJSON = json_serialize_to_string_pretty(tempJSON);
 8002dca:	69f8      	ldr	r0, [r7, #28]
 8002dcc:	f01e fece 	bl	8021b6c <json_serialize_to_string_pretty>
 8002dd0:	4602      	mov	r2, r0
 8002dd2:	68bb      	ldr	r3, [r7, #8]
 8002dd4:	601a      	str	r2, [r3, #0]
    *size = json_serialization_size_pretty(tempJSON);
 8002dd6:	69f8      	ldr	r0, [r7, #28]
 8002dd8:	f01e fe84 	bl	8021ae4 <json_serialization_size_pretty>
 8002ddc:	4602      	mov	r2, r0
 8002dde:	687b      	ldr	r3, [r7, #4]
 8002de0:	601a      	str	r2, [r3, #0]
 8002de2:	e00b      	b.n	8002dfc <Configuration_PnPL_vtblGetStatus+0x94>
  }
  else
  {
    *serializedJSON = json_serialize_to_string(tempJSON);
 8002de4:	69f8      	ldr	r0, [r7, #28]
 8002de6:	f01e fe4b 	bl	8021a80 <json_serialize_to_string>
 8002dea:	4602      	mov	r2, r0
 8002dec:	68bb      	ldr	r3, [r7, #8]
 8002dee:	601a      	str	r2, [r3, #0]
    *size = json_serialization_size(tempJSON);
 8002df0:	69f8      	ldr	r0, [r7, #28]
 8002df2:	f01e fe01 	bl	80219f8 <json_serialization_size>
 8002df6:	4602      	mov	r2, r0
 8002df8:	687b      	ldr	r3, [r7, #4]
 8002dfa:	601a      	str	r2, [r3, #0]
  }

  /* No need to free temp_j as it is part of tempJSON */
  json_value_free(tempJSON);
 8002dfc:	69f8      	ldr	r0, [r7, #28]
 8002dfe:	f01e fc9d 	bl	802173c <json_value_free>

  return 0;
 8002e02:	2300      	movs	r3, #0
}
 8002e04:	4618      	mov	r0, r3
 8002e06:	3720      	adds	r7, #32
 8002e08:	46bd      	mov	sp, r7
 8002e0a:	bd80      	pop	{r7, pc}
 8002e0c:	08027694 	.word	0x08027694
 8002e10:	08027698 	.word	0x08027698
 8002e14:	080276b4 	.word	0x080276b4
 8002e18:	080276d0 	.word	0x080276d0

08002e1c <Configuration_PnPL_vtblSetProperty>:

uint8_t Configuration_PnPL_vtblSetProperty(IPnPLComponent_t *_this, char *serializedJSON)
{
 8002e1c:	b580      	push	{r7, lr}
 8002e1e:	b086      	sub	sp, #24
 8002e20:	af00      	add	r7, sp, #0
 8002e22:	6078      	str	r0, [r7, #4]
 8002e24:	6039      	str	r1, [r7, #0]
  JSON_Value *tempJSON = json_parse_string(serializedJSON);
 8002e26:	6838      	ldr	r0, [r7, #0]
 8002e28:	f01e fa3a 	bl	80212a0 <json_parse_string>
 8002e2c:	6178      	str	r0, [r7, #20]
  JSON_Object *tempJSONObject = json_value_get_object(tempJSON);
 8002e2e:	6978      	ldr	r0, [r7, #20]
 8002e30:	f01e fbed 	bl	802160e <json_value_get_object>
 8002e34:	6138      	str	r0, [r7, #16]

  uint8_t ret = 0;
 8002e36:	2300      	movs	r3, #0
 8002e38:	73fb      	strb	r3, [r7, #15]
  if (json_object_dothas_value(tempJSONObject, "configuration.board_name"))
 8002e3a:	490b      	ldr	r1, [pc, #44]	@ (8002e68 <Configuration_PnPL_vtblSetProperty+0x4c>)
 8002e3c:	6938      	ldr	r0, [r7, #16]
 8002e3e:	f01e fb72 	bl	8021526 <json_object_dothas_value>
 8002e42:	4603      	mov	r3, r0
 8002e44:	2b00      	cmp	r3, #0
 8002e46:	d007      	beq.n	8002e58 <Configuration_PnPL_vtblSetProperty+0x3c>
  {
    const char *board_name = json_object_dotget_string(tempJSONObject, "configuration.board_name");
 8002e48:	4907      	ldr	r1, [pc, #28]	@ (8002e68 <Configuration_PnPL_vtblSetProperty+0x4c>)
 8002e4a:	6938      	ldr	r0, [r7, #16]
 8002e4c:	f01e fac8 	bl	80213e0 <json_object_dotget_string>
 8002e50:	60b8      	str	r0, [r7, #8]
    configuration_set_board_name(board_name);
 8002e52:	68b8      	ldr	r0, [r7, #8]
 8002e54:	f7fe fbcc 	bl	80015f0 <configuration_set_board_name>
  }
  json_value_free(tempJSON);
 8002e58:	6978      	ldr	r0, [r7, #20]
 8002e5a:	f01e fc6f 	bl	802173c <json_value_free>
  return ret;
 8002e5e:	7bfb      	ldrb	r3, [r7, #15]
}
 8002e60:	4618      	mov	r0, r3
 8002e62:	3718      	adds	r7, #24
 8002e64:	46bd      	mov	sp, r7
 8002e66:	bd80      	pop	{r7, pc}
 8002e68:	080276b4 	.word	0x080276b4

08002e6c <Configuration_PnPL_vtblExecuteFunction>:

uint8_t Configuration_PnPL_vtblExecuteFunction(IPnPLComponent_t *_this, char *serializedJSON)
{
 8002e6c:	b480      	push	{r7}
 8002e6e:	b083      	sub	sp, #12
 8002e70:	af00      	add	r7, sp, #0
 8002e72:	6078      	str	r0, [r7, #4]
 8002e74:	6039      	str	r1, [r7, #0]
  return 1;
 8002e76:	2301      	movs	r3, #1
}
 8002e78:	4618      	mov	r0, r3
 8002e7a:	370c      	adds	r7, #12
 8002e7c:	46bd      	mov	sp, r7
 8002e7e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002e82:	4770      	bx	lr

08002e84 <Control_PnPLAlloc>:
/* Objects instance ----------------------------------------------------------*/
static Control_PnPL sControl_PnPL;

/* Public API definition -----------------------------------------------------*/
IPnPLComponent_t *Control_PnPLAlloc()
{
 8002e84:	b480      	push	{r7}
 8002e86:	b083      	sub	sp, #12
 8002e88:	af00      	add	r7, sp, #0
  IPnPLComponent_t *pxObj = (IPnPLComponent_t *) &sControl_PnPL;
 8002e8a:	4b07      	ldr	r3, [pc, #28]	@ (8002ea8 <Control_PnPLAlloc+0x24>)
 8002e8c:	607b      	str	r3, [r7, #4]
  if (pxObj != NULL)
 8002e8e:	687b      	ldr	r3, [r7, #4]
 8002e90:	2b00      	cmp	r3, #0
 8002e92:	d002      	beq.n	8002e9a <Control_PnPLAlloc+0x16>
  {
    pxObj->vptr = &sControl_PnPL_CompIF_vtbl;
 8002e94:	687b      	ldr	r3, [r7, #4]
 8002e96:	4a05      	ldr	r2, [pc, #20]	@ (8002eac <Control_PnPLAlloc+0x28>)
 8002e98:	601a      	str	r2, [r3, #0]
  }
  return pxObj;
 8002e9a:	687b      	ldr	r3, [r7, #4]
}
 8002e9c:	4618      	mov	r0, r3
 8002e9e:	370c      	adds	r7, #12
 8002ea0:	46bd      	mov	sp, r7
 8002ea2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002ea6:	4770      	bx	lr
 8002ea8:	200004f4 	.word	0x200004f4
 8002eac:	0802a440 	.word	0x0802a440

08002eb0 <Control_PnPLInit>:

uint8_t Control_PnPLInit(IPnPLComponent_t *_this,  IControl_t *inf)
{
 8002eb0:	b580      	push	{r7, lr}
 8002eb2:	b084      	sub	sp, #16
 8002eb4:	af00      	add	r7, sp, #0
 8002eb6:	6078      	str	r0, [r7, #4]
 8002eb8:	6039      	str	r1, [r7, #0]
  IPnPLComponent_t *component_if = _this;
 8002eba:	687b      	ldr	r3, [r7, #4]
 8002ebc:	60fb      	str	r3, [r7, #12]
  PnPLAddComponent(component_if);
 8002ebe:	68f8      	ldr	r0, [r7, #12]
 8002ec0:	f019 fb78 	bl	801c5b4 <PnPLAddComponent>
  Control_PnPL *p_if_owner = (Control_PnPL *) _this;
 8002ec4:	687b      	ldr	r3, [r7, #4]
 8002ec6:	60bb      	str	r3, [r7, #8]
  p_if_owner->cmdIF = inf;
 8002ec8:	68bb      	ldr	r3, [r7, #8]
 8002eca:	683a      	ldr	r2, [r7, #0]
 8002ecc:	605a      	str	r2, [r3, #4]
  control_comp_init();
 8002ece:	f7fe fa61 	bl	8001394 <control_comp_init>
  return 0;
 8002ed2:	2300      	movs	r3, #0
}
 8002ed4:	4618      	mov	r0, r3
 8002ed6:	3710      	adds	r7, #16
 8002ed8:	46bd      	mov	sp, r7
 8002eda:	bd80      	pop	{r7, pc}

08002edc <Control_PnPL_vtblGetKey>:

/* IPnPLComponent virtual functions definition -------------------------------*/
char *Control_PnPL_vtblGetKey(IPnPLComponent_t *_this)
{
 8002edc:	b580      	push	{r7, lr}
 8002ede:	b082      	sub	sp, #8
 8002ee0:	af00      	add	r7, sp, #0
 8002ee2:	6078      	str	r0, [r7, #4]
  return control_get_key();
 8002ee4:	f7fe fa62 	bl	80013ac <control_get_key>
 8002ee8:	4603      	mov	r3, r0
}
 8002eea:	4618      	mov	r0, r3
 8002eec:	3708      	adds	r7, #8
 8002eee:	46bd      	mov	sp, r7
 8002ef0:	bd80      	pop	{r7, pc}

08002ef2 <Control_PnPL_vtblGetNCommands>:

uint8_t Control_PnPL_vtblGetNCommands(IPnPLComponent_t *_this)
{
 8002ef2:	b480      	push	{r7}
 8002ef4:	b083      	sub	sp, #12
 8002ef6:	af00      	add	r7, sp, #0
 8002ef8:	6078      	str	r0, [r7, #4]
  return 1;
 8002efa:	2301      	movs	r3, #1
}
 8002efc:	4618      	mov	r0, r3
 8002efe:	370c      	adds	r7, #12
 8002f00:	46bd      	mov	sp, r7
 8002f02:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002f06:	4770      	bx	lr

08002f08 <Control_PnPL_vtblGetCommandKey>:

char *Control_PnPL_vtblGetCommandKey(IPnPLComponent_t *_this, uint8_t id)
{
 8002f08:	b480      	push	{r7}
 8002f0a:	b083      	sub	sp, #12
 8002f0c:	af00      	add	r7, sp, #0
 8002f0e:	6078      	str	r0, [r7, #4]
 8002f10:	460b      	mov	r3, r1
 8002f12:	70fb      	strb	r3, [r7, #3]
  switch (id)
 8002f14:	78fb      	ldrb	r3, [r7, #3]
 8002f16:	2b00      	cmp	r3, #0
 8002f18:	d101      	bne.n	8002f1e <Control_PnPL_vtblGetCommandKey+0x16>
  {
  case 0:
    return "control*pause_resume";
 8002f1a:	4b04      	ldr	r3, [pc, #16]	@ (8002f2c <Control_PnPL_vtblGetCommandKey+0x24>)
 8002f1c:	e000      	b.n	8002f20 <Control_PnPL_vtblGetCommandKey+0x18>
    break;
  }
  return 0;
 8002f1e:	2300      	movs	r3, #0
}
 8002f20:	4618      	mov	r0, r3
 8002f22:	370c      	adds	r7, #12
 8002f24:	46bd      	mov	sp, r7
 8002f26:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002f2a:	4770      	bx	lr
 8002f2c:	080276e8 	.word	0x080276e8

08002f30 <Control_PnPL_vtblGetStatus>:

uint8_t Control_PnPL_vtblGetStatus(IPnPLComponent_t *_this, char **serializedJSON, uint32_t *size, uint8_t pretty)
{
 8002f30:	b580      	push	{r7, lr}
 8002f32:	b088      	sub	sp, #32
 8002f34:	af00      	add	r7, sp, #0
 8002f36:	60f8      	str	r0, [r7, #12]
 8002f38:	60b9      	str	r1, [r7, #8]
 8002f3a:	607a      	str	r2, [r7, #4]
 8002f3c:	70fb      	strb	r3, [r7, #3]
  JSON_Value *tempJSON;
  JSON_Object *JSON_Status;

  tempJSON = json_value_init_object();
 8002f3e:	f01e fc2b 	bl	8021798 <json_value_init_object>
 8002f42:	61f8      	str	r0, [r7, #28]
  JSON_Status = json_value_get_object(tempJSON);
 8002f44:	69f8      	ldr	r0, [r7, #28]
 8002f46:	f01e fb62 	bl	802160e <json_value_get_object>
 8002f4a:	61b8      	str	r0, [r7, #24]

  char *temp_s = "";
 8002f4c:	4b1c      	ldr	r3, [pc, #112]	@ (8002fc0 <Control_PnPL_vtblGetStatus+0x90>)
 8002f4e:	617b      	str	r3, [r7, #20]
  control_get_fw_status(&temp_s);
 8002f50:	f107 0314 	add.w	r3, r7, #20
 8002f54:	4618      	mov	r0, r3
 8002f56:	f7fe fa33 	bl	80013c0 <control_get_fw_status>
  json_object_dotset_string(JSON_Status, "control.fw_status", temp_s);
 8002f5a:	697b      	ldr	r3, [r7, #20]
 8002f5c:	461a      	mov	r2, r3
 8002f5e:	4919      	ldr	r1, [pc, #100]	@ (8002fc4 <Control_PnPL_vtblGetStatus+0x94>)
 8002f60:	69b8      	ldr	r0, [r7, #24]
 8002f62:	f01e ffc5 	bl	8021ef0 <json_object_dotset_string>
  json_object_dotset_number(JSON_Status, "control.c_type", COMP_TYPE_OTHER);
 8002f66:	f04f 0200 	mov.w	r2, #0
 8002f6a:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8002f6e:	4916      	ldr	r1, [pc, #88]	@ (8002fc8 <Control_PnPL_vtblGetStatus+0x98>)
 8002f70:	69b8      	ldr	r0, [r7, #24]
 8002f72:	f01e ffe0 	bl	8021f36 <json_object_dotset_number>

  if (pretty == 1)
 8002f76:	78fb      	ldrb	r3, [r7, #3]
 8002f78:	2b01      	cmp	r3, #1
 8002f7a:	d10c      	bne.n	8002f96 <Control_PnPL_vtblGetStatus+0x66>
  {
    *serializedJSON = json_serialize_to_string_pretty(tempJSON);
 8002f7c:	69f8      	ldr	r0, [r7, #28]
 8002f7e:	f01e fdf5 	bl	8021b6c <json_serialize_to_string_pretty>
 8002f82:	4602      	mov	r2, r0
 8002f84:	68bb      	ldr	r3, [r7, #8]
 8002f86:	601a      	str	r2, [r3, #0]
    *size = json_serialization_size_pretty(tempJSON);
 8002f88:	69f8      	ldr	r0, [r7, #28]
 8002f8a:	f01e fdab 	bl	8021ae4 <json_serialization_size_pretty>
 8002f8e:	4602      	mov	r2, r0
 8002f90:	687b      	ldr	r3, [r7, #4]
 8002f92:	601a      	str	r2, [r3, #0]
 8002f94:	e00b      	b.n	8002fae <Control_PnPL_vtblGetStatus+0x7e>
  }
  else
  {
    *serializedJSON = json_serialize_to_string(tempJSON);
 8002f96:	69f8      	ldr	r0, [r7, #28]
 8002f98:	f01e fd72 	bl	8021a80 <json_serialize_to_string>
 8002f9c:	4602      	mov	r2, r0
 8002f9e:	68bb      	ldr	r3, [r7, #8]
 8002fa0:	601a      	str	r2, [r3, #0]
    *size = json_serialization_size(tempJSON);
 8002fa2:	69f8      	ldr	r0, [r7, #28]
 8002fa4:	f01e fd28 	bl	80219f8 <json_serialization_size>
 8002fa8:	4602      	mov	r2, r0
 8002faa:	687b      	ldr	r3, [r7, #4]
 8002fac:	601a      	str	r2, [r3, #0]
  }

  /* No need to free temp_j as it is part of tempJSON */
  json_value_free(tempJSON);
 8002fae:	69f8      	ldr	r0, [r7, #28]
 8002fb0:	f01e fbc4 	bl	802173c <json_value_free>

  return 0;
 8002fb4:	2300      	movs	r3, #0
}
 8002fb6:	4618      	mov	r0, r3
 8002fb8:	3720      	adds	r7, #32
 8002fba:	46bd      	mov	sp, r7
 8002fbc:	bd80      	pop	{r7, pc}
 8002fbe:	bf00      	nop
 8002fc0:	08027700 	.word	0x08027700
 8002fc4:	08027704 	.word	0x08027704
 8002fc8:	08027718 	.word	0x08027718

08002fcc <Control_PnPL_vtblSetProperty>:

uint8_t Control_PnPL_vtblSetProperty(IPnPLComponent_t *_this, char *serializedJSON)
{
 8002fcc:	b480      	push	{r7}
 8002fce:	b083      	sub	sp, #12
 8002fd0:	af00      	add	r7, sp, #0
 8002fd2:	6078      	str	r0, [r7, #4]
 8002fd4:	6039      	str	r1, [r7, #0]
  return 0;
 8002fd6:	2300      	movs	r3, #0
}
 8002fd8:	4618      	mov	r0, r3
 8002fda:	370c      	adds	r7, #12
 8002fdc:	46bd      	mov	sp, r7
 8002fde:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002fe2:	4770      	bx	lr

08002fe4 <Control_PnPL_vtblExecuteFunction>:

uint8_t Control_PnPL_vtblExecuteFunction(IPnPLComponent_t *_this, char *serializedJSON)
{
 8002fe4:	b580      	push	{r7, lr}
 8002fe6:	b086      	sub	sp, #24
 8002fe8:	af00      	add	r7, sp, #0
 8002fea:	6078      	str	r0, [r7, #4]
 8002fec:	6039      	str	r1, [r7, #0]
  Control_PnPL *p_if_owner = (Control_PnPL *) _this;
 8002fee:	687b      	ldr	r3, [r7, #4]
 8002ff0:	617b      	str	r3, [r7, #20]
  JSON_Value *tempJSON = json_parse_string(serializedJSON);
 8002ff2:	6838      	ldr	r0, [r7, #0]
 8002ff4:	f01e f954 	bl	80212a0 <json_parse_string>
 8002ff8:	6138      	str	r0, [r7, #16]
  JSON_Object *tempJSONObject = json_value_get_object(tempJSON);
 8002ffa:	6938      	ldr	r0, [r7, #16]
 8002ffc:	f01e fb07 	bl	802160e <json_value_get_object>
 8003000:	60f8      	str	r0, [r7, #12]
  if (json_object_dothas_value(tempJSONObject, "control*pause_resume"))
 8003002:	490a      	ldr	r1, [pc, #40]	@ (800302c <Control_PnPL_vtblExecuteFunction+0x48>)
 8003004:	68f8      	ldr	r0, [r7, #12]
 8003006:	f01e fa8e 	bl	8021526 <json_object_dothas_value>
 800300a:	4603      	mov	r3, r0
 800300c:	2b00      	cmp	r3, #0
 800300e:	d004      	beq.n	800301a <Control_PnPL_vtblExecuteFunction+0x36>
  {
    control_pause_resume(p_if_owner->cmdIF);
 8003010:	697b      	ldr	r3, [r7, #20]
 8003012:	685b      	ldr	r3, [r3, #4]
 8003014:	4618      	mov	r0, r3
 8003016:	f7fe f9fb 	bl	8001410 <control_pause_resume>
  }
  json_value_free(tempJSON);
 800301a:	6938      	ldr	r0, [r7, #16]
 800301c:	f01e fb8e 	bl	802173c <json_value_free>
  return 0;
 8003020:	2300      	movs	r3, #0
}
 8003022:	4618      	mov	r0, r3
 8003024:	3718      	adds	r7, #24
 8003026:	46bd      	mov	sp, r7
 8003028:	bd80      	pop	{r7, pc}
 800302a:	bf00      	nop
 800302c:	080276e8 	.word	0x080276e8

08003030 <DLC_Init>:
uint8_t timStartFlag;

static void timersInit(void);

/* Initialise BLE_Broadcaster */
void DLC_Init(void) {
 8003030:	b580      	push	{r7, lr}
 8003032:	af00      	add	r7, sp, #0
    advStartFlag = TRUE;
 8003034:	4b06      	ldr	r3, [pc, #24]	@ (8003050 <DLC_Init+0x20>)
 8003036:	2201      	movs	r2, #1
 8003038:	701a      	strb	r2, [r3, #0]
    timersInit();
 800303a:	f000 f833 	bl	80030a4 <timersInit>
    timStartFlag = TRUE;
 800303e:	4b05      	ldr	r3, [pc, #20]	@ (8003054 <DLC_Init+0x24>)
 8003040:	2201      	movs	r2, #1
 8003042:	701a      	strb	r2, [r3, #0]
    bleScanStartFlag = TRUE;
 8003044:	4b04      	ldr	r3, [pc, #16]	@ (8003058 <DLC_Init+0x28>)
 8003046:	2201      	movs	r2, #1
 8003048:	701a      	strb	r2, [r3, #0]
}
 800304a:	bf00      	nop
 800304c:	bd80      	pop	{r7, pc}
 800304e:	bf00      	nop
 8003050:	200004a8 	.word	0x200004a8
 8003054:	200004fc 	.word	0x200004fc
 8003058:	200004ab 	.word	0x200004ab

0800305c <DLC_mainProcess>:

/* Handles DLC pressure measurements and BLE communication */
void DLC_mainProcess(void) {
 800305c:	b580      	push	{r7, lr}
 800305e:	b082      	sub	sp, #8
 8003060:	af00      	add	r7, sp, #0
    hci_event=0;
 8003062:	4b0e      	ldr	r3, [pc, #56]	@ (800309c <DLC_mainProcess+0x40>)
 8003064:	2200      	movs	r2, #0
 8003066:	601a      	str	r2, [r3, #0]
    hci_user_evt_proc();
 8003068:	f019 f85e 	bl	801c128 <hci_user_evt_proc>
        BSP_LED_Off(LED_GREEN);
    }
    #endif

    #if ENABLE_SCAN
    if (bleScanStartFlag) {
 800306c:	4b0c      	ldr	r3, [pc, #48]	@ (80030a0 <DLC_mainProcess+0x44>)
 800306e:	781b      	ldrb	r3, [r3, #0]
 8003070:	2b00      	cmp	r3, #0
 8003072:	d00e      	beq.n	8003092 <DLC_mainProcess+0x36>
        uint8_t scanStartSuccess;
        scanStartSuccess = StartBLEScan();
 8003074:	f7fe fb9a 	bl	80017ac <StartBLEScan>
 8003078:	4603      	mov	r3, r0
 800307a:	71fb      	strb	r3, [r7, #7]
        if (scanStartSuccess) {
 800307c:	79fb      	ldrb	r3, [r7, #7]
 800307e:	2b00      	cmp	r3, #0
 8003080:	d003      	beq.n	800308a <DLC_mainProcess+0x2e>
            bleScanStartFlag = FALSE;
 8003082:	4b07      	ldr	r3, [pc, #28]	@ (80030a0 <DLC_mainProcess+0x44>)
 8003084:	2200      	movs	r2, #0
 8003086:	701a      	strb	r2, [r3, #0]
            HAL_Delay(1000);
        }
    }
    #endif

}
 8003088:	e003      	b.n	8003092 <DLC_mainProcess+0x36>
            HAL_Delay(1000);
 800308a:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
 800308e:	f001 fbb5 	bl	80047fc <HAL_Delay>
}
 8003092:	bf00      	nop
 8003094:	3708      	adds	r7, #8
 8003096:	46bd      	mov	sp, r7
 8003098:	bd80      	pop	{r7, pc}
 800309a:	bf00      	nop
 800309c:	2000059c 	.word	0x2000059c
 80030a0:	200004ab 	.word	0x200004ab

080030a4 <timersInit>:

static void timersInit(void) {
 80030a4:	b580      	push	{r7, lr}
 80030a6:	b088      	sub	sp, #32
 80030a8:	af00      	add	r7, sp, #0

    /* Timer Output Compare Configuration Structure declaration */
    TIM_OC_InitTypeDef sConfig;

    /* Compute the prescaler value to counter clock equal to 10000 Hz */
    uwPrescalerValue = (uint32_t) ((SystemCoreClock / 10000) - 1);
 80030aa:	4b23      	ldr	r3, [pc, #140]	@ (8003138 <timersInit+0x94>)
 80030ac:	681b      	ldr	r3, [r3, #0]
 80030ae:	4a23      	ldr	r2, [pc, #140]	@ (800313c <timersInit+0x98>)
 80030b0:	fba2 2303 	umull	r2, r3, r2, r3
 80030b4:	0b5b      	lsrs	r3, r3, #13
 80030b6:	3b01      	subs	r3, #1
 80030b8:	61fb      	str	r3, [r7, #28]

    /* Set TIM1 instance */
    TIM_CC_HANDLE.Instance = TIM_CC_INSTANCE;
 80030ba:	4b21      	ldr	r3, [pc, #132]	@ (8003140 <timersInit+0x9c>)
 80030bc:	4a21      	ldr	r2, [pc, #132]	@ (8003144 <timersInit+0xa0>)
 80030be:	601a      	str	r2, [r3, #0]
    TIM_CC_HANDLE.Init.Period        = 65535;
 80030c0:	4b1f      	ldr	r3, [pc, #124]	@ (8003140 <timersInit+0x9c>)
 80030c2:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 80030c6:	60da      	str	r2, [r3, #12]
    TIM_CC_HANDLE.Init.Prescaler     = uwPrescalerValue;
 80030c8:	4a1d      	ldr	r2, [pc, #116]	@ (8003140 <timersInit+0x9c>)
 80030ca:	69fb      	ldr	r3, [r7, #28]
 80030cc:	6053      	str	r3, [r2, #4]
    TIM_CC_HANDLE.Init.ClockDivision = 0;
 80030ce:	4b1c      	ldr	r3, [pc, #112]	@ (8003140 <timersInit+0x9c>)
 80030d0:	2200      	movs	r2, #0
 80030d2:	611a      	str	r2, [r3, #16]
    TIM_CC_HANDLE.Init.CounterMode   = TIM_COUNTERMODE_UP;
 80030d4:	4b1a      	ldr	r3, [pc, #104]	@ (8003140 <timersInit+0x9c>)
 80030d6:	2200      	movs	r2, #0
 80030d8:	609a      	str	r2, [r3, #8]

    if(HAL_TIM_OC_DeInit(&TIM_CC_HANDLE) != HAL_OK) {
 80030da:	4819      	ldr	r0, [pc, #100]	@ (8003140 <timersInit+0x9c>)
 80030dc:	f013 faf1 	bl	80166c2 <HAL_TIM_OC_DeInit>
 80030e0:	4603      	mov	r3, r0
 80030e2:	2b00      	cmp	r3, #0
 80030e4:	d004      	beq.n	80030f0 <timersInit+0x4c>
    /* Initialization Error */
    STBOX1_Error_Handler(STBOX1_ERROR_HW_INIT,__FILE__,__LINE__);
 80030e6:	2258      	movs	r2, #88	@ 0x58
 80030e8:	4917      	ldr	r1, [pc, #92]	@ (8003148 <timersInit+0xa4>)
 80030ea:	2004      	movs	r0, #4
 80030ec:	f001 fb9e 	bl	800482c <STBOX1_Error_Handler>
    }

    if(HAL_TIM_OC_Init(&TIM_CC_HANDLE) != HAL_OK) {
 80030f0:	4813      	ldr	r0, [pc, #76]	@ (8003140 <timersInit+0x9c>)
 80030f2:	f013 fa8f 	bl	8016614 <HAL_TIM_OC_Init>
 80030f6:	4603      	mov	r3, r0
 80030f8:	2b00      	cmp	r3, #0
 80030fa:	d004      	beq.n	8003106 <timersInit+0x62>
    /* Initialization Error */
    STBOX1_Error_Handler(STBOX1_ERROR_HW_INIT,__FILE__,__LINE__);
 80030fc:	225d      	movs	r2, #93	@ 0x5d
 80030fe:	4912      	ldr	r1, [pc, #72]	@ (8003148 <timersInit+0xa4>)
 8003100:	2004      	movs	r0, #4
 8003102:	f001 fb93 	bl	800482c <STBOX1_Error_Handler>
    }

    /* Configure the Output Compare channels */

    /* Common configuration for all channels */
    sConfig.OCMode     = TIM_OCMODE_TOGGLE;
 8003106:	2330      	movs	r3, #48	@ 0x30
 8003108:	603b      	str	r3, [r7, #0]
    sConfig.OCPolarity = TIM_OCPOLARITY_LOW;
 800310a:	2302      	movs	r3, #2
 800310c:	60bb      	str	r3, [r7, #8]

    /* Conf TIM1 to hande communication timing */
    sConfig.Pulse = 10000;
 800310e:	f242 7310 	movw	r3, #10000	@ 0x2710
 8003112:	607b      	str	r3, [r7, #4]
    if(HAL_TIM_OC_ConfigChannel(&TIM_CC_HANDLE, &sConfig, TIM_CHANNEL_1) != HAL_OK) {
 8003114:	463b      	mov	r3, r7
 8003116:	2200      	movs	r2, #0
 8003118:	4619      	mov	r1, r3
 800311a:	4809      	ldr	r0, [pc, #36]	@ (8003140 <timersInit+0x9c>)
 800311c:	f013 ff24 	bl	8016f68 <HAL_TIM_OC_ConfigChannel>
 8003120:	4603      	mov	r3, r0
 8003122:	2b00      	cmp	r3, #0
 8003124:	d004      	beq.n	8003130 <timersInit+0x8c>
    /* Configuration Error */
    STBOX1_Error_Handler(STBOX1_ERROR_HW_INIT,__FILE__,__LINE__);
 8003126:	226a      	movs	r2, #106	@ 0x6a
 8003128:	4907      	ldr	r1, [pc, #28]	@ (8003148 <timersInit+0xa4>)
 800312a:	2004      	movs	r0, #4
 800312c:	f001 fb7e 	bl	800482c <STBOX1_Error_Handler>
    }

}
 8003130:	bf00      	nop
 8003132:	3720      	adds	r7, #32
 8003134:	46bd      	mov	sp, r7
 8003136:	bd80      	pop	{r7, pc}
 8003138:	200001e0 	.word	0x200001e0
 800313c:	d1b71759 	.word	0xd1b71759
 8003140:	20000854 	.word	0x20000854
 8003144:	40012c00 	.word	0x40012c00
 8003148:	08027728 	.word	0x08027728

0800314c <HAL_TIM_OC_DelayElapsedCallback>:

void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
{
 800314c:	b580      	push	{r7, lr}
 800314e:	b084      	sub	sp, #16
 8003150:	af00      	add	r7, sp, #0
 8003152:	6078      	str	r0, [r7, #4]
  uint32_t uhCapture=0;
 8003154:	2300      	movs	r3, #0
 8003156:	60fb      	str	r3, [r7, #12]
  /* TIM1_CH1 toggling with frequency = 0.5Hz */
  if(htim->Channel == HAL_TIM_ACTIVE_CHANNEL_1) {
 8003158:	687b      	ldr	r3, [r7, #4]
 800315a:	7f1b      	ldrb	r3, [r3, #28]
 800315c:	2b01      	cmp	r3, #1
 800315e:	d116      	bne.n	800318e <HAL_TIM_OC_DelayElapsedCallback+0x42>
    uhCapture = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_1);
 8003160:	2100      	movs	r1, #0
 8003162:	6878      	ldr	r0, [r7, #4]
 8003164:	f013 ff7a 	bl	801705c <HAL_TIM_ReadCapturedValue>
 8003168:	60f8      	str	r0, [r7, #12]
    /* Set the Capture Compare Register value */
    __HAL_TIM_SET_COMPARE(&TIM_CC_HANDLE, TIM_CHANNEL_1, (uhCapture + 10000));
 800316a:	4b0b      	ldr	r3, [pc, #44]	@ (8003198 <HAL_TIM_OC_DelayElapsedCallback+0x4c>)
 800316c:	681a      	ldr	r2, [r3, #0]
 800316e:	68fb      	ldr	r3, [r7, #12]
 8003170:	f503 531c 	add.w	r3, r3, #9984	@ 0x2700
 8003174:	3310      	adds	r3, #16
 8003176:	6353      	str	r3, [r2, #52]	@ 0x34
    if (advState) {
 8003178:	4b08      	ldr	r3, [pc, #32]	@ (800319c <HAL_TIM_OC_DelayElapsedCallback+0x50>)
 800317a:	781b      	ldrb	r3, [r3, #0]
 800317c:	2b00      	cmp	r3, #0
 800317e:	d003      	beq.n	8003188 <HAL_TIM_OC_DelayElapsedCallback+0x3c>
        advStopFlag = TRUE;
 8003180:	4b07      	ldr	r3, [pc, #28]	@ (80031a0 <HAL_TIM_OC_DelayElapsedCallback+0x54>)
 8003182:	2201      	movs	r2, #1
 8003184:	701a      	strb	r2, [r3, #0]
//         __HAL_TIM_SET_COMPARE(&TIM_CC_HANDLE, TIM_CHANNEL_3, (uhCapture + 333));
//       break;
//     }
//     SendAccGyroMag=1;
//   }
 8003186:	e002      	b.n	800318e <HAL_TIM_OC_DelayElapsedCallback+0x42>
        advStartFlag = TRUE;
 8003188:	4b06      	ldr	r3, [pc, #24]	@ (80031a4 <HAL_TIM_OC_DelayElapsedCallback+0x58>)
 800318a:	2201      	movs	r2, #1
 800318c:	701a      	strb	r2, [r3, #0]
 800318e:	bf00      	nop
 8003190:	3710      	adds	r7, #16
 8003192:	46bd      	mov	sp, r7
 8003194:	bd80      	pop	{r7, pc}
 8003196:	bf00      	nop
 8003198:	20000854 	.word	0x20000854
 800319c:	200004aa 	.word	0x200004aa
 80031a0:	200004a9 	.word	0x200004a9
 80031a4:	200004a8 	.word	0x200004a8

080031a8 <Deviceinformation_PnPLAlloc>:
/* Objects instance ----------------------------------------------------------*/
static Deviceinformation_PnPL sDeviceinformation_PnPL;

/* Public API definition -----------------------------------------------------*/
IPnPLComponent_t *Deviceinformation_PnPLAlloc()
{
 80031a8:	b480      	push	{r7}
 80031aa:	b083      	sub	sp, #12
 80031ac:	af00      	add	r7, sp, #0
  IPnPLComponent_t *pxObj = (IPnPLComponent_t *) &sDeviceinformation_PnPL;
 80031ae:	4b07      	ldr	r3, [pc, #28]	@ (80031cc <Deviceinformation_PnPLAlloc+0x24>)
 80031b0:	607b      	str	r3, [r7, #4]
  if (pxObj != NULL)
 80031b2:	687b      	ldr	r3, [r7, #4]
 80031b4:	2b00      	cmp	r3, #0
 80031b6:	d002      	beq.n	80031be <Deviceinformation_PnPLAlloc+0x16>
  {
    pxObj->vptr = &sDeviceinformation_PnPL_CompIF_vtbl;
 80031b8:	687b      	ldr	r3, [r7, #4]
 80031ba:	4a05      	ldr	r2, [pc, #20]	@ (80031d0 <Deviceinformation_PnPLAlloc+0x28>)
 80031bc:	601a      	str	r2, [r3, #0]
  }
  return pxObj;
 80031be:	687b      	ldr	r3, [r7, #4]
}
 80031c0:	4618      	mov	r0, r3
 80031c2:	370c      	adds	r7, #12
 80031c4:	46bd      	mov	sp, r7
 80031c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80031ca:	4770      	bx	lr
 80031cc:	20000500 	.word	0x20000500
 80031d0:	0802a458 	.word	0x0802a458

080031d4 <Deviceinformation_PnPLInit>:

uint8_t Deviceinformation_PnPLInit(IPnPLComponent_t *_this)
{
 80031d4:	b580      	push	{r7, lr}
 80031d6:	b084      	sub	sp, #16
 80031d8:	af00      	add	r7, sp, #0
 80031da:	6078      	str	r0, [r7, #4]
  IPnPLComponent_t *component_if = _this;
 80031dc:	687b      	ldr	r3, [r7, #4]
 80031de:	60fb      	str	r3, [r7, #12]
  PnPLAddComponent(component_if);
 80031e0:	68f8      	ldr	r0, [r7, #12]
 80031e2:	f019 f9e7 	bl	801c5b4 <PnPLAddComponent>
  DeviceInformation_comp_init();
 80031e6:	f7fe fa2b 	bl	8001640 <DeviceInformation_comp_init>
  return 0;
 80031ea:	2300      	movs	r3, #0
}
 80031ec:	4618      	mov	r0, r3
 80031ee:	3710      	adds	r7, #16
 80031f0:	46bd      	mov	sp, r7
 80031f2:	bd80      	pop	{r7, pc}

080031f4 <Deviceinformation_PnPL_vtblGetKey>:

/* IPnPLComponent virtual functions definition -------------------------------*/
char *Deviceinformation_PnPL_vtblGetKey(IPnPLComponent_t *_this)
{
 80031f4:	b580      	push	{r7, lr}
 80031f6:	b082      	sub	sp, #8
 80031f8:	af00      	add	r7, sp, #0
 80031fa:	6078      	str	r0, [r7, #4]
  return DeviceInformation_get_key();
 80031fc:	f7fe fa28 	bl	8001650 <DeviceInformation_get_key>
 8003200:	4603      	mov	r3, r0
}
 8003202:	4618      	mov	r0, r3
 8003204:	3708      	adds	r7, #8
 8003206:	46bd      	mov	sp, r7
 8003208:	bd80      	pop	{r7, pc}

0800320a <Deviceinformation_PnPL_vtblGetNCommands>:

uint8_t Deviceinformation_PnPL_vtblGetNCommands(IPnPLComponent_t *_this)
{
 800320a:	b480      	push	{r7}
 800320c:	b083      	sub	sp, #12
 800320e:	af00      	add	r7, sp, #0
 8003210:	6078      	str	r0, [r7, #4]
  return 0;
 8003212:	2300      	movs	r3, #0
}
 8003214:	4618      	mov	r0, r3
 8003216:	370c      	adds	r7, #12
 8003218:	46bd      	mov	sp, r7
 800321a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800321e:	4770      	bx	lr

08003220 <Deviceinformation_PnPL_vtblGetCommandKey>:

char *Deviceinformation_PnPL_vtblGetCommandKey(IPnPLComponent_t *_this, uint8_t id)
{
 8003220:	b480      	push	{r7}
 8003222:	b083      	sub	sp, #12
 8003224:	af00      	add	r7, sp, #0
 8003226:	6078      	str	r0, [r7, #4]
 8003228:	460b      	mov	r3, r1
 800322a:	70fb      	strb	r3, [r7, #3]
  return "";
 800322c:	4b03      	ldr	r3, [pc, #12]	@ (800323c <Deviceinformation_PnPL_vtblGetCommandKey+0x1c>)
}
 800322e:	4618      	mov	r0, r3
 8003230:	370c      	adds	r7, #12
 8003232:	46bd      	mov	sp, r7
 8003234:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003238:	4770      	bx	lr
 800323a:	bf00      	nop
 800323c:	080277b4 	.word	0x080277b4

08003240 <Deviceinformation_PnPL_vtblGetStatus>:

uint8_t Deviceinformation_PnPL_vtblGetStatus(IPnPLComponent_t *_this, char **serializedJSON, uint32_t *size, uint8_t pretty)
{
 8003240:	b580      	push	{r7, lr}
 8003242:	b088      	sub	sp, #32
 8003244:	af00      	add	r7, sp, #0
 8003246:	60f8      	str	r0, [r7, #12]
 8003248:	60b9      	str	r1, [r7, #8]
 800324a:	607a      	str	r2, [r7, #4]
 800324c:	70fb      	strb	r3, [r7, #3]
  JSON_Value *tempJSON;
  JSON_Object *JSON_Status;

  tempJSON = json_value_init_object();
 800324e:	f01e faa3 	bl	8021798 <json_value_init_object>
 8003252:	61f8      	str	r0, [r7, #28]
  JSON_Status = json_value_get_object(tempJSON);
 8003254:	69f8      	ldr	r0, [r7, #28]
 8003256:	f01e f9da 	bl	802160e <json_value_get_object>
 800325a:	61b8      	str	r0, [r7, #24]

  char *temp_s = "";
 800325c:	4b44      	ldr	r3, [pc, #272]	@ (8003370 <Deviceinformation_PnPL_vtblGetStatus+0x130>)
 800325e:	617b      	str	r3, [r7, #20]
  DeviceInformation_get_manufacturer(&temp_s);
 8003260:	f107 0314 	add.w	r3, r7, #20
 8003264:	4618      	mov	r0, r3
 8003266:	f7fe f9fd 	bl	8001664 <DeviceInformation_get_manufacturer>
  json_object_dotset_string(JSON_Status, "DeviceInformation.manufacturer", temp_s);
 800326a:	697b      	ldr	r3, [r7, #20]
 800326c:	461a      	mov	r2, r3
 800326e:	4941      	ldr	r1, [pc, #260]	@ (8003374 <Deviceinformation_PnPL_vtblGetStatus+0x134>)
 8003270:	69b8      	ldr	r0, [r7, #24]
 8003272:	f01e fe3d 	bl	8021ef0 <json_object_dotset_string>
  DeviceInformation_get_model(&temp_s);
 8003276:	f107 0314 	add.w	r3, r7, #20
 800327a:	4618      	mov	r0, r3
 800327c:	f7fe fa06 	bl	800168c <DeviceInformation_get_model>
  json_object_dotset_string(JSON_Status, "DeviceInformation.model", temp_s);
 8003280:	697b      	ldr	r3, [r7, #20]
 8003282:	461a      	mov	r2, r3
 8003284:	493c      	ldr	r1, [pc, #240]	@ (8003378 <Deviceinformation_PnPL_vtblGetStatus+0x138>)
 8003286:	69b8      	ldr	r0, [r7, #24]
 8003288:	f01e fe32 	bl	8021ef0 <json_object_dotset_string>
  DeviceInformation_get_swVersion(&temp_s);
 800328c:	f107 0314 	add.w	r3, r7, #20
 8003290:	4618      	mov	r0, r3
 8003292:	f7fe fa0f 	bl	80016b4 <DeviceInformation_get_swVersion>
  json_object_dotset_string(JSON_Status, "DeviceInformation.swVersion", temp_s);
 8003296:	697b      	ldr	r3, [r7, #20]
 8003298:	461a      	mov	r2, r3
 800329a:	4938      	ldr	r1, [pc, #224]	@ (800337c <Deviceinformation_PnPL_vtblGetStatus+0x13c>)
 800329c:	69b8      	ldr	r0, [r7, #24]
 800329e:	f01e fe27 	bl	8021ef0 <json_object_dotset_string>
  DeviceInformation_get_osName(&temp_s);
 80032a2:	f107 0314 	add.w	r3, r7, #20
 80032a6:	4618      	mov	r0, r3
 80032a8:	f7fe fa24 	bl	80016f4 <DeviceInformation_get_osName>
  json_object_dotset_string(JSON_Status, "DeviceInformation.osName", temp_s);
 80032ac:	697b      	ldr	r3, [r7, #20]
 80032ae:	461a      	mov	r2, r3
 80032b0:	4933      	ldr	r1, [pc, #204]	@ (8003380 <Deviceinformation_PnPL_vtblGetStatus+0x140>)
 80032b2:	69b8      	ldr	r0, [r7, #24]
 80032b4:	f01e fe1c 	bl	8021ef0 <json_object_dotset_string>
  DeviceInformation_get_processorArchitecture(&temp_s);
 80032b8:	f107 0314 	add.w	r3, r7, #20
 80032bc:	4618      	mov	r0, r3
 80032be:	f7fe fa2d 	bl	800171c <DeviceInformation_get_processorArchitecture>
  json_object_dotset_string(JSON_Status, "DeviceInformation.processorArchitecture", temp_s);
 80032c2:	697b      	ldr	r3, [r7, #20]
 80032c4:	461a      	mov	r2, r3
 80032c6:	492f      	ldr	r1, [pc, #188]	@ (8003384 <Deviceinformation_PnPL_vtblGetStatus+0x144>)
 80032c8:	69b8      	ldr	r0, [r7, #24]
 80032ca:	f01e fe11 	bl	8021ef0 <json_object_dotset_string>
  DeviceInformation_get_processorManufacturer(&temp_s);
 80032ce:	f107 0314 	add.w	r3, r7, #20
 80032d2:	4618      	mov	r0, r3
 80032d4:	f7fe fa36 	bl	8001744 <DeviceInformation_get_processorManufacturer>
  json_object_dotset_string(JSON_Status, "DeviceInformation.processorManufacturer", temp_s);
 80032d8:	697b      	ldr	r3, [r7, #20]
 80032da:	461a      	mov	r2, r3
 80032dc:	492a      	ldr	r1, [pc, #168]	@ (8003388 <Deviceinformation_PnPL_vtblGetStatus+0x148>)
 80032de:	69b8      	ldr	r0, [r7, #24]
 80032e0:	f01e fe06 	bl	8021ef0 <json_object_dotset_string>
  float temp_f = 0;
 80032e4:	f04f 0300 	mov.w	r3, #0
 80032e8:	613b      	str	r3, [r7, #16]
  DeviceInformation_get_totalStorage(&temp_f);
 80032ea:	f107 0310 	add.w	r3, r7, #16
 80032ee:	4618      	mov	r0, r3
 80032f0:	f7fe fa3c 	bl	800176c <DeviceInformation_get_totalStorage>
  json_object_dotset_number(JSON_Status, "DeviceInformation.totalStorage", temp_f);
 80032f4:	693b      	ldr	r3, [r7, #16]
 80032f6:	4618      	mov	r0, r3
 80032f8:	f7fd f934 	bl	8000564 <__aeabi_f2d>
 80032fc:	4602      	mov	r2, r0
 80032fe:	460b      	mov	r3, r1
 8003300:	4922      	ldr	r1, [pc, #136]	@ (800338c <Deviceinformation_PnPL_vtblGetStatus+0x14c>)
 8003302:	69b8      	ldr	r0, [r7, #24]
 8003304:	f01e fe17 	bl	8021f36 <json_object_dotset_number>
  DeviceInformation_get_totalMemory(&temp_f);
 8003308:	f107 0310 	add.w	r3, r7, #16
 800330c:	4618      	mov	r0, r3
 800330e:	f7fe fa3d 	bl	800178c <DeviceInformation_get_totalMemory>
  json_object_dotset_number(JSON_Status, "DeviceInformation.totalMemory", temp_f);
 8003312:	693b      	ldr	r3, [r7, #16]
 8003314:	4618      	mov	r0, r3
 8003316:	f7fd f925 	bl	8000564 <__aeabi_f2d>
 800331a:	4602      	mov	r2, r0
 800331c:	460b      	mov	r3, r1
 800331e:	491c      	ldr	r1, [pc, #112]	@ (8003390 <Deviceinformation_PnPL_vtblGetStatus+0x150>)
 8003320:	69b8      	ldr	r0, [r7, #24]
 8003322:	f01e fe08 	bl	8021f36 <json_object_dotset_number>

  if (pretty == 1)
 8003326:	78fb      	ldrb	r3, [r7, #3]
 8003328:	2b01      	cmp	r3, #1
 800332a:	d10c      	bne.n	8003346 <Deviceinformation_PnPL_vtblGetStatus+0x106>
  {
    *serializedJSON = json_serialize_to_string_pretty(tempJSON);
 800332c:	69f8      	ldr	r0, [r7, #28]
 800332e:	f01e fc1d 	bl	8021b6c <json_serialize_to_string_pretty>
 8003332:	4602      	mov	r2, r0
 8003334:	68bb      	ldr	r3, [r7, #8]
 8003336:	601a      	str	r2, [r3, #0]
    *size = json_serialization_size_pretty(tempJSON);
 8003338:	69f8      	ldr	r0, [r7, #28]
 800333a:	f01e fbd3 	bl	8021ae4 <json_serialization_size_pretty>
 800333e:	4602      	mov	r2, r0
 8003340:	687b      	ldr	r3, [r7, #4]
 8003342:	601a      	str	r2, [r3, #0]
 8003344:	e00b      	b.n	800335e <Deviceinformation_PnPL_vtblGetStatus+0x11e>
  }
  else
  {
    *serializedJSON = json_serialize_to_string(tempJSON);
 8003346:	69f8      	ldr	r0, [r7, #28]
 8003348:	f01e fb9a 	bl	8021a80 <json_serialize_to_string>
 800334c:	4602      	mov	r2, r0
 800334e:	68bb      	ldr	r3, [r7, #8]
 8003350:	601a      	str	r2, [r3, #0]
    *size = json_serialization_size(tempJSON);
 8003352:	69f8      	ldr	r0, [r7, #28]
 8003354:	f01e fb50 	bl	80219f8 <json_serialization_size>
 8003358:	4602      	mov	r2, r0
 800335a:	687b      	ldr	r3, [r7, #4]
 800335c:	601a      	str	r2, [r3, #0]
  }

  /* No need to free temp_j as it is part of tempJSON */
  json_value_free(tempJSON);
 800335e:	69f8      	ldr	r0, [r7, #28]
 8003360:	f01e f9ec 	bl	802173c <json_value_free>

  return 0;
 8003364:	2300      	movs	r3, #0
}
 8003366:	4618      	mov	r0, r3
 8003368:	3720      	adds	r7, #32
 800336a:	46bd      	mov	sp, r7
 800336c:	bd80      	pop	{r7, pc}
 800336e:	bf00      	nop
 8003370:	080277b4 	.word	0x080277b4
 8003374:	080277b8 	.word	0x080277b8
 8003378:	080277d8 	.word	0x080277d8
 800337c:	080277f0 	.word	0x080277f0
 8003380:	0802780c 	.word	0x0802780c
 8003384:	08027828 	.word	0x08027828
 8003388:	08027850 	.word	0x08027850
 800338c:	08027878 	.word	0x08027878
 8003390:	08027898 	.word	0x08027898

08003394 <Deviceinformation_PnPL_vtblSetProperty>:

uint8_t Deviceinformation_PnPL_vtblSetProperty(IPnPLComponent_t *_this, char *serializedJSON)
{
 8003394:	b480      	push	{r7}
 8003396:	b083      	sub	sp, #12
 8003398:	af00      	add	r7, sp, #0
 800339a:	6078      	str	r0, [r7, #4]
 800339c:	6039      	str	r1, [r7, #0]
  return 0;
 800339e:	2300      	movs	r3, #0
}
 80033a0:	4618      	mov	r0, r3
 80033a2:	370c      	adds	r7, #12
 80033a4:	46bd      	mov	sp, r7
 80033a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80033aa:	4770      	bx	lr

080033ac <Deviceinformation_PnPL_vtblExecuteFunction>:

uint8_t Deviceinformation_PnPL_vtblExecuteFunction(IPnPLComponent_t *_this, char *serializedJSON)
{
 80033ac:	b480      	push	{r7}
 80033ae:	b083      	sub	sp, #12
 80033b0:	af00      	add	r7, sp, #0
 80033b2:	6078      	str	r0, [r7, #4]
 80033b4:	6039      	str	r1, [r7, #0]
  return 1;
 80033b6:	2301      	movs	r3, #1
}
 80033b8:	4618      	mov	r0, r3
 80033ba:	370c      	adds	r7, #12
 80033bc:	46bd      	mov	sp, r7
 80033be:	f85d 7b04 	ldr.w	r7, [sp], #4
 80033c2:	4770      	bx	lr

080033c4 <Environmental_PnPLAlloc>:
/* Objects instance ----------------------------------------------------------*/
static Environmental_PnPL sEnvironmental_PnPL;

/* Public API definition -----------------------------------------------------*/
IPnPLComponent_t *Environmental_PnPLAlloc()
{
 80033c4:	b480      	push	{r7}
 80033c6:	b083      	sub	sp, #12
 80033c8:	af00      	add	r7, sp, #0
  IPnPLComponent_t *pxObj = (IPnPLComponent_t *) &sEnvironmental_PnPL;
 80033ca:	4b07      	ldr	r3, [pc, #28]	@ (80033e8 <Environmental_PnPLAlloc+0x24>)
 80033cc:	607b      	str	r3, [r7, #4]
  if (pxObj != NULL)
 80033ce:	687b      	ldr	r3, [r7, #4]
 80033d0:	2b00      	cmp	r3, #0
 80033d2:	d002      	beq.n	80033da <Environmental_PnPLAlloc+0x16>
  {
    pxObj->vptr = &sEnvironmental_PnPL_CompIF_vtbl;
 80033d4:	687b      	ldr	r3, [r7, #4]
 80033d6:	4a05      	ldr	r2, [pc, #20]	@ (80033ec <Environmental_PnPLAlloc+0x28>)
 80033d8:	601a      	str	r2, [r3, #0]
  }
  return pxObj;
 80033da:	687b      	ldr	r3, [r7, #4]
}
 80033dc:	4618      	mov	r0, r3
 80033de:	370c      	adds	r7, #12
 80033e0:	46bd      	mov	sp, r7
 80033e2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80033e6:	4770      	bx	lr
 80033e8:	20000504 	.word	0x20000504
 80033ec:	0802a470 	.word	0x0802a470

080033f0 <Environmental_PnPLInit>:

uint8_t Environmental_PnPLInit(IPnPLComponent_t *_this)
{
 80033f0:	b580      	push	{r7, lr}
 80033f2:	b084      	sub	sp, #16
 80033f4:	af00      	add	r7, sp, #0
 80033f6:	6078      	str	r0, [r7, #4]
  IPnPLComponent_t *component_if = _this;
 80033f8:	687b      	ldr	r3, [r7, #4]
 80033fa:	60fb      	str	r3, [r7, #12]
  PnPLAddComponent(component_if);
 80033fc:	68f8      	ldr	r0, [r7, #12]
 80033fe:	f019 f8d9 	bl	801c5b4 <PnPLAddComponent>
  environmental_comp_init();
 8003402:	f7fd fe6d 	bl	80010e0 <environmental_comp_init>
  return 0;
 8003406:	2300      	movs	r3, #0
}
 8003408:	4618      	mov	r0, r3
 800340a:	3710      	adds	r7, #16
 800340c:	46bd      	mov	sp, r7
 800340e:	bd80      	pop	{r7, pc}

08003410 <Environmental_PnPL_vtblGetKey>:

/* IPnPLComponent virtual functions definition -------------------------------*/
char *Environmental_PnPL_vtblGetKey(IPnPLComponent_t *_this)
{
 8003410:	b580      	push	{r7, lr}
 8003412:	b082      	sub	sp, #8
 8003414:	af00      	add	r7, sp, #0
 8003416:	6078      	str	r0, [r7, #4]
  return environmental_get_key();
 8003418:	f7fd fe6e 	bl	80010f8 <environmental_get_key>
 800341c:	4603      	mov	r3, r0
}
 800341e:	4618      	mov	r0, r3
 8003420:	3708      	adds	r7, #8
 8003422:	46bd      	mov	sp, r7
 8003424:	bd80      	pop	{r7, pc}

08003426 <Environmental_PnPL_vtblGetNCommands>:

uint8_t Environmental_PnPL_vtblGetNCommands(IPnPLComponent_t *_this)
{
 8003426:	b480      	push	{r7}
 8003428:	b083      	sub	sp, #12
 800342a:	af00      	add	r7, sp, #0
 800342c:	6078      	str	r0, [r7, #4]
  return 0;
 800342e:	2300      	movs	r3, #0
}
 8003430:	4618      	mov	r0, r3
 8003432:	370c      	adds	r7, #12
 8003434:	46bd      	mov	sp, r7
 8003436:	f85d 7b04 	ldr.w	r7, [sp], #4
 800343a:	4770      	bx	lr

0800343c <Environmental_PnPL_vtblGetCommandKey>:

char *Environmental_PnPL_vtblGetCommandKey(IPnPLComponent_t *_this, uint8_t id)
{
 800343c:	b480      	push	{r7}
 800343e:	b083      	sub	sp, #12
 8003440:	af00      	add	r7, sp, #0
 8003442:	6078      	str	r0, [r7, #4]
 8003444:	460b      	mov	r3, r1
 8003446:	70fb      	strb	r3, [r7, #3]
  return "";
 8003448:	4b03      	ldr	r3, [pc, #12]	@ (8003458 <Environmental_PnPL_vtblGetCommandKey+0x1c>)
}
 800344a:	4618      	mov	r0, r3
 800344c:	370c      	adds	r7, #12
 800344e:	46bd      	mov	sp, r7
 8003450:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003454:	4770      	bx	lr
 8003456:	bf00      	nop
 8003458:	080278b8 	.word	0x080278b8

0800345c <Environmental_PnPL_vtblGetStatus>:

uint8_t Environmental_PnPL_vtblGetStatus(IPnPLComponent_t *_this, char **serializedJSON, uint32_t *size, uint8_t pretty)
{
 800345c:	b580      	push	{r7, lr}
 800345e:	b088      	sub	sp, #32
 8003460:	af00      	add	r7, sp, #0
 8003462:	60f8      	str	r0, [r7, #12]
 8003464:	60b9      	str	r1, [r7, #8]
 8003466:	607a      	str	r2, [r7, #4]
 8003468:	70fb      	strb	r3, [r7, #3]
  JSON_Value *tempJSON;
  JSON_Object *JSON_Status;

  tempJSON = json_value_init_object();
 800346a:	f01e f995 	bl	8021798 <json_value_init_object>
 800346e:	61b8      	str	r0, [r7, #24]
  JSON_Status = json_value_get_object(tempJSON);
 8003470:	69b8      	ldr	r0, [r7, #24]
 8003472:	f01e f8cc 	bl	802160e <json_value_get_object>
 8003476:	6178      	str	r0, [r7, #20]

  float temp_f = 0;
 8003478:	f04f 0300 	mov.w	r3, #0
 800347c:	613b      	str	r3, [r7, #16]
  environmental_get_samplerate(&temp_f);
 800347e:	f107 0310 	add.w	r3, r7, #16
 8003482:	4618      	mov	r0, r3
 8003484:	f7fd fe42 	bl	800110c <environmental_get_samplerate>
  uint8_t enum_id = 0;
 8003488:	2300      	movs	r3, #0
 800348a:	77fb      	strb	r3, [r7, #31]
  if(temp_f == n1)
 800348c:	edd7 7a04 	vldr	s15, [r7, #16]
 8003490:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 8003494:	eef4 7a47 	vcmp.f32	s15, s14
 8003498:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800349c:	d102      	bne.n	80034a4 <Environmental_PnPL_vtblGetStatus+0x48>
  {
    enum_id = 0;
 800349e:	2300      	movs	r3, #0
 80034a0:	77fb      	strb	r3, [r7, #31]
 80034a2:	e016      	b.n	80034d2 <Environmental_PnPL_vtblGetStatus+0x76>
  }
  else if(temp_f == n10)
 80034a4:	edd7 7a04 	vldr	s15, [r7, #16]
 80034a8:	eeb2 7a04 	vmov.f32	s14, #36	@ 0x41200000  10.0
 80034ac:	eef4 7a47 	vcmp.f32	s15, s14
 80034b0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80034b4:	d102      	bne.n	80034bc <Environmental_PnPL_vtblGetStatus+0x60>
  {
    enum_id = 1;
 80034b6:	2301      	movs	r3, #1
 80034b8:	77fb      	strb	r3, [r7, #31]
 80034ba:	e00a      	b.n	80034d2 <Environmental_PnPL_vtblGetStatus+0x76>
  }
  else if(temp_f == n20)
 80034bc:	edd7 7a04 	vldr	s15, [r7, #16]
 80034c0:	eeb3 7a04 	vmov.f32	s14, #52	@ 0x41a00000  20.0
 80034c4:	eef4 7a47 	vcmp.f32	s15, s14
 80034c8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80034cc:	d101      	bne.n	80034d2 <Environmental_PnPL_vtblGetStatus+0x76>
  {
    enum_id = 2;
 80034ce:	2302      	movs	r3, #2
 80034d0:	77fb      	strb	r3, [r7, #31]
  }
  json_object_dotset_number(JSON_Status, "environmental.samplerate", enum_id);
 80034d2:	7ffb      	ldrb	r3, [r7, #31]
 80034d4:	4618      	mov	r0, r3
 80034d6:	f7fd f823 	bl	8000520 <__aeabi_ui2d>
 80034da:	4602      	mov	r2, r0
 80034dc:	460b      	mov	r3, r1
 80034de:	4918      	ldr	r1, [pc, #96]	@ (8003540 <Environmental_PnPL_vtblGetStatus+0xe4>)
 80034e0:	6978      	ldr	r0, [r7, #20]
 80034e2:	f01e fd28 	bl	8021f36 <json_object_dotset_number>
  json_object_dotset_number(JSON_Status, "environmental.c_type", COMP_TYPE_OTHER);
 80034e6:	f04f 0200 	mov.w	r2, #0
 80034ea:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 80034ee:	4915      	ldr	r1, [pc, #84]	@ (8003544 <Environmental_PnPL_vtblGetStatus+0xe8>)
 80034f0:	6978      	ldr	r0, [r7, #20]
 80034f2:	f01e fd20 	bl	8021f36 <json_object_dotset_number>

  if (pretty == 1)
 80034f6:	78fb      	ldrb	r3, [r7, #3]
 80034f8:	2b01      	cmp	r3, #1
 80034fa:	d10c      	bne.n	8003516 <Environmental_PnPL_vtblGetStatus+0xba>
  {
    *serializedJSON = json_serialize_to_string_pretty(tempJSON);
 80034fc:	69b8      	ldr	r0, [r7, #24]
 80034fe:	f01e fb35 	bl	8021b6c <json_serialize_to_string_pretty>
 8003502:	4602      	mov	r2, r0
 8003504:	68bb      	ldr	r3, [r7, #8]
 8003506:	601a      	str	r2, [r3, #0]
    *size = json_serialization_size_pretty(tempJSON);
 8003508:	69b8      	ldr	r0, [r7, #24]
 800350a:	f01e faeb 	bl	8021ae4 <json_serialization_size_pretty>
 800350e:	4602      	mov	r2, r0
 8003510:	687b      	ldr	r3, [r7, #4]
 8003512:	601a      	str	r2, [r3, #0]
 8003514:	e00b      	b.n	800352e <Environmental_PnPL_vtblGetStatus+0xd2>
  }
  else
  {
    *serializedJSON = json_serialize_to_string(tempJSON);
 8003516:	69b8      	ldr	r0, [r7, #24]
 8003518:	f01e fab2 	bl	8021a80 <json_serialize_to_string>
 800351c:	4602      	mov	r2, r0
 800351e:	68bb      	ldr	r3, [r7, #8]
 8003520:	601a      	str	r2, [r3, #0]
    *size = json_serialization_size(tempJSON);
 8003522:	69b8      	ldr	r0, [r7, #24]
 8003524:	f01e fa68 	bl	80219f8 <json_serialization_size>
 8003528:	4602      	mov	r2, r0
 800352a:	687b      	ldr	r3, [r7, #4]
 800352c:	601a      	str	r2, [r3, #0]
  }

  /* No need to free temp_j as it is part of tempJSON */
  json_value_free(tempJSON);
 800352e:	69b8      	ldr	r0, [r7, #24]
 8003530:	f01e f904 	bl	802173c <json_value_free>

  return 0;
 8003534:	2300      	movs	r3, #0
}
 8003536:	4618      	mov	r0, r3
 8003538:	3720      	adds	r7, #32
 800353a:	46bd      	mov	sp, r7
 800353c:	bd80      	pop	{r7, pc}
 800353e:	bf00      	nop
 8003540:	080278bc 	.word	0x080278bc
 8003544:	080278d8 	.word	0x080278d8

08003548 <Environmental_PnPL_vtblSetProperty>:

uint8_t Environmental_PnPL_vtblSetProperty(IPnPLComponent_t *_this, char *serializedJSON)
{
 8003548:	b580      	push	{r7, lr}
 800354a:	b086      	sub	sp, #24
 800354c:	af00      	add	r7, sp, #0
 800354e:	6078      	str	r0, [r7, #4]
 8003550:	6039      	str	r1, [r7, #0]
  JSON_Value *tempJSON = json_parse_string(serializedJSON);
 8003552:	6838      	ldr	r0, [r7, #0]
 8003554:	f01d fea4 	bl	80212a0 <json_parse_string>
 8003558:	6178      	str	r0, [r7, #20]
  JSON_Object *tempJSONObject = json_value_get_object(tempJSON);
 800355a:	6978      	ldr	r0, [r7, #20]
 800355c:	f01e f857 	bl	802160e <json_value_get_object>
 8003560:	6138      	str	r0, [r7, #16]

  uint8_t ret = 0;
 8003562:	2300      	movs	r3, #0
 8003564:	73fb      	strb	r3, [r7, #15]
  if(json_object_dothas_value(tempJSONObject, "environmental.samplerate"))
 8003566:	491a      	ldr	r1, [pc, #104]	@ (80035d0 <Environmental_PnPL_vtblSetProperty+0x88>)
 8003568:	6938      	ldr	r0, [r7, #16]
 800356a:	f01d ffdc 	bl	8021526 <json_object_dothas_value>
 800356e:	4603      	mov	r3, r0
 8003570:	2b00      	cmp	r3, #0
 8003572:	d025      	beq.n	80035c0 <Environmental_PnPL_vtblSetProperty+0x78>
  {
    int samplerate = (int)json_object_dotget_number(tempJSONObject, "environmental.samplerate");
 8003574:	4916      	ldr	r1, [pc, #88]	@ (80035d0 <Environmental_PnPL_vtblSetProperty+0x88>)
 8003576:	6938      	ldr	r0, [r7, #16]
 8003578:	f01d ff44 	bl	8021404 <json_object_dotget_number>
 800357c:	4602      	mov	r2, r0
 800357e:	460b      	mov	r3, r1
 8003580:	4610      	mov	r0, r2
 8003582:	4619      	mov	r1, r3
 8003584:	f7fd faf6 	bl	8000b74 <__aeabi_d2iz>
 8003588:	4603      	mov	r3, r0
 800358a:	60bb      	str	r3, [r7, #8]
    switch(samplerate)
 800358c:	68bb      	ldr	r3, [r7, #8]
 800358e:	2b02      	cmp	r3, #2
 8003590:	d012      	beq.n	80035b8 <Environmental_PnPL_vtblSetProperty+0x70>
 8003592:	68bb      	ldr	r3, [r7, #8]
 8003594:	2b02      	cmp	r3, #2
 8003596:	dc13      	bgt.n	80035c0 <Environmental_PnPL_vtblSetProperty+0x78>
 8003598:	68bb      	ldr	r3, [r7, #8]
 800359a:	2b00      	cmp	r3, #0
 800359c:	d003      	beq.n	80035a6 <Environmental_PnPL_vtblSetProperty+0x5e>
 800359e:	68bb      	ldr	r3, [r7, #8]
 80035a0:	2b01      	cmp	r3, #1
 80035a2:	d005      	beq.n	80035b0 <Environmental_PnPL_vtblSetProperty+0x68>
 80035a4:	e00c      	b.n	80035c0 <Environmental_PnPL_vtblSetProperty+0x78>
    {
    case 0:
      environmental_set_samplerate(n1);
 80035a6:	f04f 507e 	mov.w	r0, #1065353216	@ 0x3f800000
 80035aa:	f7fd fdc5 	bl	8001138 <environmental_set_samplerate>
      break;
 80035ae:	e007      	b.n	80035c0 <Environmental_PnPL_vtblSetProperty+0x78>
    case 1:
      environmental_set_samplerate(n10);
 80035b0:	4808      	ldr	r0, [pc, #32]	@ (80035d4 <Environmental_PnPL_vtblSetProperty+0x8c>)
 80035b2:	f7fd fdc1 	bl	8001138 <environmental_set_samplerate>
      break;
 80035b6:	e003      	b.n	80035c0 <Environmental_PnPL_vtblSetProperty+0x78>
    case 2:
      environmental_set_samplerate(n20);
 80035b8:	4807      	ldr	r0, [pc, #28]	@ (80035d8 <Environmental_PnPL_vtblSetProperty+0x90>)
 80035ba:	f7fd fdbd 	bl	8001138 <environmental_set_samplerate>
      break;
 80035be:	bf00      	nop
    }
  }
  json_value_free(tempJSON);
 80035c0:	6978      	ldr	r0, [r7, #20]
 80035c2:	f01e f8bb 	bl	802173c <json_value_free>
  return ret;
 80035c6:	7bfb      	ldrb	r3, [r7, #15]
}
 80035c8:	4618      	mov	r0, r3
 80035ca:	3718      	adds	r7, #24
 80035cc:	46bd      	mov	sp, r7
 80035ce:	bd80      	pop	{r7, pc}
 80035d0:	080278bc 	.word	0x080278bc
 80035d4:	41200000 	.word	0x41200000
 80035d8:	41a00000 	.word	0x41a00000

080035dc <Environmental_PnPL_vtblExecuteFunction>:

uint8_t Environmental_PnPL_vtblExecuteFunction(IPnPLComponent_t *_this, char *serializedJSON)
{
 80035dc:	b480      	push	{r7}
 80035de:	b083      	sub	sp, #12
 80035e0:	af00      	add	r7, sp, #0
 80035e2:	6078      	str	r0, [r7, #4]
 80035e4:	6039      	str	r1, [r7, #0]
  return 1;
 80035e6:	2301      	movs	r3, #1
}
 80035e8:	4618      	mov	r0, r3
 80035ea:	370c      	adds	r7, #12
 80035ec:	46bd      	mov	sp, r7
 80035ee:	f85d 7b04 	ldr.w	r7, [sp], #4
 80035f2:	4770      	bx	lr

080035f4 <Inertial_PnPLAlloc>:
/* Objects instance ----------------------------------------------------------*/
static Inertial_PnPL sInertial_PnPL;

/* Public API definition -----------------------------------------------------*/
IPnPLComponent_t *Inertial_PnPLAlloc()
{
 80035f4:	b480      	push	{r7}
 80035f6:	b083      	sub	sp, #12
 80035f8:	af00      	add	r7, sp, #0
  IPnPLComponent_t *pxObj = (IPnPLComponent_t *) &sInertial_PnPL;
 80035fa:	4b07      	ldr	r3, [pc, #28]	@ (8003618 <Inertial_PnPLAlloc+0x24>)
 80035fc:	607b      	str	r3, [r7, #4]
  if (pxObj != NULL)
 80035fe:	687b      	ldr	r3, [r7, #4]
 8003600:	2b00      	cmp	r3, #0
 8003602:	d002      	beq.n	800360a <Inertial_PnPLAlloc+0x16>
  {
    pxObj->vptr = &sInertial_PnPL_CompIF_vtbl;
 8003604:	687b      	ldr	r3, [r7, #4]
 8003606:	4a05      	ldr	r2, [pc, #20]	@ (800361c <Inertial_PnPLAlloc+0x28>)
 8003608:	601a      	str	r2, [r3, #0]
  }
  return pxObj;
 800360a:	687b      	ldr	r3, [r7, #4]
}
 800360c:	4618      	mov	r0, r3
 800360e:	370c      	adds	r7, #12
 8003610:	46bd      	mov	sp, r7
 8003612:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003616:	4770      	bx	lr
 8003618:	20000508 	.word	0x20000508
 800361c:	0802a488 	.word	0x0802a488

08003620 <Inertial_PnPLInit>:

uint8_t Inertial_PnPLInit(IPnPLComponent_t *_this)
{
 8003620:	b580      	push	{r7, lr}
 8003622:	b084      	sub	sp, #16
 8003624:	af00      	add	r7, sp, #0
 8003626:	6078      	str	r0, [r7, #4]
  IPnPLComponent_t *component_if = _this;
 8003628:	687b      	ldr	r3, [r7, #4]
 800362a:	60fb      	str	r3, [r7, #12]
  PnPLAddComponent(component_if);
 800362c:	68f8      	ldr	r0, [r7, #12]
 800362e:	f018 ffc1 	bl	801c5b4 <PnPLAddComponent>
  inertial_comp_init();
 8003632:	f7fd fde3 	bl	80011fc <inertial_comp_init>
  return 0;
 8003636:	2300      	movs	r3, #0
}
 8003638:	4618      	mov	r0, r3
 800363a:	3710      	adds	r7, #16
 800363c:	46bd      	mov	sp, r7
 800363e:	bd80      	pop	{r7, pc}

08003640 <Inertial_PnPL_vtblGetKey>:

/* IPnPLComponent virtual functions definition -------------------------------*/
char *Inertial_PnPL_vtblGetKey(IPnPLComponent_t *_this)
{
 8003640:	b580      	push	{r7, lr}
 8003642:	b082      	sub	sp, #8
 8003644:	af00      	add	r7, sp, #0
 8003646:	6078      	str	r0, [r7, #4]
  return inertial_get_key();
 8003648:	f7fd fde4 	bl	8001214 <inertial_get_key>
 800364c:	4603      	mov	r3, r0
}
 800364e:	4618      	mov	r0, r3
 8003650:	3708      	adds	r7, #8
 8003652:	46bd      	mov	sp, r7
 8003654:	bd80      	pop	{r7, pc}

08003656 <Inertial_PnPL_vtblGetNCommands>:

uint8_t Inertial_PnPL_vtblGetNCommands(IPnPLComponent_t *_this)
{
 8003656:	b480      	push	{r7}
 8003658:	b083      	sub	sp, #12
 800365a:	af00      	add	r7, sp, #0
 800365c:	6078      	str	r0, [r7, #4]
  return 0;
 800365e:	2300      	movs	r3, #0
}
 8003660:	4618      	mov	r0, r3
 8003662:	370c      	adds	r7, #12
 8003664:	46bd      	mov	sp, r7
 8003666:	f85d 7b04 	ldr.w	r7, [sp], #4
 800366a:	4770      	bx	lr

0800366c <Inertial_PnPL_vtblGetCommandKey>:

char *Inertial_PnPL_vtblGetCommandKey(IPnPLComponent_t *_this, uint8_t id)
{
 800366c:	b480      	push	{r7}
 800366e:	b083      	sub	sp, #12
 8003670:	af00      	add	r7, sp, #0
 8003672:	6078      	str	r0, [r7, #4]
 8003674:	460b      	mov	r3, r1
 8003676:	70fb      	strb	r3, [r7, #3]
  return "";
 8003678:	4b03      	ldr	r3, [pc, #12]	@ (8003688 <Inertial_PnPL_vtblGetCommandKey+0x1c>)
}
 800367a:	4618      	mov	r0, r3
 800367c:	370c      	adds	r7, #12
 800367e:	46bd      	mov	sp, r7
 8003680:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003684:	4770      	bx	lr
 8003686:	bf00      	nop
 8003688:	080278f0 	.word	0x080278f0

0800368c <Inertial_PnPL_vtblGetStatus>:

uint8_t Inertial_PnPL_vtblGetStatus(IPnPLComponent_t *_this, char **serializedJSON, uint32_t *size, uint8_t pretty)
{
 800368c:	b580      	push	{r7, lr}
 800368e:	b088      	sub	sp, #32
 8003690:	af00      	add	r7, sp, #0
 8003692:	60f8      	str	r0, [r7, #12]
 8003694:	60b9      	str	r1, [r7, #8]
 8003696:	607a      	str	r2, [r7, #4]
 8003698:	70fb      	strb	r3, [r7, #3]
  JSON_Value *tempJSON;
  JSON_Object *JSON_Status;

  tempJSON = json_value_init_object();
 800369a:	f01e f87d 	bl	8021798 <json_value_init_object>
 800369e:	61b8      	str	r0, [r7, #24]
  JSON_Status = json_value_get_object(tempJSON);
 80036a0:	69b8      	ldr	r0, [r7, #24]
 80036a2:	f01d ffb4 	bl	802160e <json_value_get_object>
 80036a6:	6178      	str	r0, [r7, #20]

  float temp_f = 0;
 80036a8:	f04f 0300 	mov.w	r3, #0
 80036ac:	613b      	str	r3, [r7, #16]
  inertial_get_samplerate(&temp_f);
 80036ae:	f107 0310 	add.w	r3, r7, #16
 80036b2:	4618      	mov	r0, r3
 80036b4:	f7fd fdb8 	bl	8001228 <inertial_get_samplerate>
  uint8_t enum_id = 0;
 80036b8:	2300      	movs	r3, #0
 80036ba:	77fb      	strb	r3, [r7, #31]
  if(temp_f == n10)
 80036bc:	edd7 7a04 	vldr	s15, [r7, #16]
 80036c0:	eeb2 7a04 	vmov.f32	s14, #36	@ 0x41200000  10.0
 80036c4:	eef4 7a47 	vcmp.f32	s15, s14
 80036c8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80036cc:	d102      	bne.n	80036d4 <Inertial_PnPL_vtblGetStatus+0x48>
  {
    enum_id = 0;
 80036ce:	2300      	movs	r3, #0
 80036d0:	77fb      	strb	r3, [r7, #31]
 80036d2:	e016      	b.n	8003702 <Inertial_PnPL_vtblGetStatus+0x76>
  }
  else if(temp_f == n20)
 80036d4:	edd7 7a04 	vldr	s15, [r7, #16]
 80036d8:	eeb3 7a04 	vmov.f32	s14, #52	@ 0x41a00000  20.0
 80036dc:	eef4 7a47 	vcmp.f32	s15, s14
 80036e0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80036e4:	d102      	bne.n	80036ec <Inertial_PnPL_vtblGetStatus+0x60>
  {
    enum_id = 1;
 80036e6:	2301      	movs	r3, #1
 80036e8:	77fb      	strb	r3, [r7, #31]
 80036ea:	e00a      	b.n	8003702 <Inertial_PnPL_vtblGetStatus+0x76>
  }
  else if(temp_f == n30)
 80036ec:	edd7 7a04 	vldr	s15, [r7, #16]
 80036f0:	eeb3 7a0e 	vmov.f32	s14, #62	@ 0x41f00000  30.0
 80036f4:	eef4 7a47 	vcmp.f32	s15, s14
 80036f8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80036fc:	d101      	bne.n	8003702 <Inertial_PnPL_vtblGetStatus+0x76>
  {
    enum_id = 2;
 80036fe:	2302      	movs	r3, #2
 8003700:	77fb      	strb	r3, [r7, #31]
  }
  json_object_dotset_number(JSON_Status, "inertial.samplerate", enum_id);
 8003702:	7ffb      	ldrb	r3, [r7, #31]
 8003704:	4618      	mov	r0, r3
 8003706:	f7fc ff0b 	bl	8000520 <__aeabi_ui2d>
 800370a:	4602      	mov	r2, r0
 800370c:	460b      	mov	r3, r1
 800370e:	492b      	ldr	r1, [pc, #172]	@ (80037bc <Inertial_PnPL_vtblGetStatus+0x130>)
 8003710:	6978      	ldr	r0, [r7, #20]
 8003712:	f01e fc10 	bl	8021f36 <json_object_dotset_number>
  inertial_get_change_acc(&temp_f);
 8003716:	f107 0310 	add.w	r3, r7, #16
 800371a:	4618      	mov	r0, r3
 800371c:	f7fd fd9a 	bl	8001254 <inertial_get_change_acc>
  enum_id = 0;
 8003720:	2300      	movs	r3, #0
 8003722:	77fb      	strb	r3, [r7, #31]
  if(temp_f ==  LSM6DSV16X)
 8003724:	edd7 7a04 	vldr	s15, [r7, #16]
 8003728:	eef5 7a40 	vcmp.f32	s15, #0.0
 800372c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8003730:	d102      	bne.n	8003738 <Inertial_PnPL_vtblGetStatus+0xac>
  {
    enum_id = 0;
 8003732:	2300      	movs	r3, #0
 8003734:	77fb      	strb	r3, [r7, #31]
 8003736:	e00a      	b.n	800374e <Inertial_PnPL_vtblGetStatus+0xc2>
  }
  else if(temp_f == LIS2DU12)
 8003738:	edd7 7a04 	vldr	s15, [r7, #16]
 800373c:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 8003740:	eef4 7a47 	vcmp.f32	s15, s14
 8003744:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8003748:	d101      	bne.n	800374e <Inertial_PnPL_vtblGetStatus+0xc2>
  {
    enum_id = 1;
 800374a:	2301      	movs	r3, #1
 800374c:	77fb      	strb	r3, [r7, #31]
  }
  json_object_dotset_number(JSON_Status, "inertial.change_acc", enum_id);
 800374e:	7ffb      	ldrb	r3, [r7, #31]
 8003750:	4618      	mov	r0, r3
 8003752:	f7fc fee5 	bl	8000520 <__aeabi_ui2d>
 8003756:	4602      	mov	r2, r0
 8003758:	460b      	mov	r3, r1
 800375a:	4919      	ldr	r1, [pc, #100]	@ (80037c0 <Inertial_PnPL_vtblGetStatus+0x134>)
 800375c:	6978      	ldr	r0, [r7, #20]
 800375e:	f01e fbea 	bl	8021f36 <json_object_dotset_number>
  json_object_dotset_number(JSON_Status, "inertial.c_type", COMP_TYPE_OTHER);
 8003762:	f04f 0200 	mov.w	r2, #0
 8003766:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 800376a:	4916      	ldr	r1, [pc, #88]	@ (80037c4 <Inertial_PnPL_vtblGetStatus+0x138>)
 800376c:	6978      	ldr	r0, [r7, #20]
 800376e:	f01e fbe2 	bl	8021f36 <json_object_dotset_number>

  if (pretty == 1)
 8003772:	78fb      	ldrb	r3, [r7, #3]
 8003774:	2b01      	cmp	r3, #1
 8003776:	d10c      	bne.n	8003792 <Inertial_PnPL_vtblGetStatus+0x106>
  {
    *serializedJSON = json_serialize_to_string_pretty(tempJSON);
 8003778:	69b8      	ldr	r0, [r7, #24]
 800377a:	f01e f9f7 	bl	8021b6c <json_serialize_to_string_pretty>
 800377e:	4602      	mov	r2, r0
 8003780:	68bb      	ldr	r3, [r7, #8]
 8003782:	601a      	str	r2, [r3, #0]
    *size = json_serialization_size_pretty(tempJSON);
 8003784:	69b8      	ldr	r0, [r7, #24]
 8003786:	f01e f9ad 	bl	8021ae4 <json_serialization_size_pretty>
 800378a:	4602      	mov	r2, r0
 800378c:	687b      	ldr	r3, [r7, #4]
 800378e:	601a      	str	r2, [r3, #0]
 8003790:	e00b      	b.n	80037aa <Inertial_PnPL_vtblGetStatus+0x11e>
  }
  else
  {
    *serializedJSON = json_serialize_to_string(tempJSON);
 8003792:	69b8      	ldr	r0, [r7, #24]
 8003794:	f01e f974 	bl	8021a80 <json_serialize_to_string>
 8003798:	4602      	mov	r2, r0
 800379a:	68bb      	ldr	r3, [r7, #8]
 800379c:	601a      	str	r2, [r3, #0]
    *size = json_serialization_size(tempJSON);
 800379e:	69b8      	ldr	r0, [r7, #24]
 80037a0:	f01e f92a 	bl	80219f8 <json_serialization_size>
 80037a4:	4602      	mov	r2, r0
 80037a6:	687b      	ldr	r3, [r7, #4]
 80037a8:	601a      	str	r2, [r3, #0]
  }

  /* No need to free temp_j as it is part of tempJSON */
  json_value_free(tempJSON);
 80037aa:	69b8      	ldr	r0, [r7, #24]
 80037ac:	f01d ffc6 	bl	802173c <json_value_free>

  return 0;
 80037b0:	2300      	movs	r3, #0
}
 80037b2:	4618      	mov	r0, r3
 80037b4:	3720      	adds	r7, #32
 80037b6:	46bd      	mov	sp, r7
 80037b8:	bd80      	pop	{r7, pc}
 80037ba:	bf00      	nop
 80037bc:	080278f4 	.word	0x080278f4
 80037c0:	08027908 	.word	0x08027908
 80037c4:	0802791c 	.word	0x0802791c

080037c8 <Inertial_PnPL_vtblSetProperty>:

uint8_t Inertial_PnPL_vtblSetProperty(IPnPLComponent_t *_this, char *serializedJSON)
{
 80037c8:	b580      	push	{r7, lr}
 80037ca:	b088      	sub	sp, #32
 80037cc:	af00      	add	r7, sp, #0
 80037ce:	6078      	str	r0, [r7, #4]
 80037d0:	6039      	str	r1, [r7, #0]
  JSON_Value *tempJSON = json_parse_string(serializedJSON);
 80037d2:	6838      	ldr	r0, [r7, #0]
 80037d4:	f01d fd64 	bl	80212a0 <json_parse_string>
 80037d8:	61f8      	str	r0, [r7, #28]
  JSON_Object *tempJSONObject = json_value_get_object(tempJSON);
 80037da:	69f8      	ldr	r0, [r7, #28]
 80037dc:	f01d ff17 	bl	802160e <json_value_get_object>
 80037e0:	61b8      	str	r0, [r7, #24]

  uint8_t ret = 0;
 80037e2:	2300      	movs	r3, #0
 80037e4:	75fb      	strb	r3, [r7, #23]
  if(json_object_dothas_value(tempJSONObject, "inertial.samplerate"))
 80037e6:	492c      	ldr	r1, [pc, #176]	@ (8003898 <Inertial_PnPL_vtblSetProperty+0xd0>)
 80037e8:	69b8      	ldr	r0, [r7, #24]
 80037ea:	f01d fe9c 	bl	8021526 <json_object_dothas_value>
 80037ee:	4603      	mov	r3, r0
 80037f0:	2b00      	cmp	r3, #0
 80037f2:	d024      	beq.n	800383e <Inertial_PnPL_vtblSetProperty+0x76>
  {
    int samplerate = (int)json_object_dotget_number(tempJSONObject, "inertial.samplerate");
 80037f4:	4928      	ldr	r1, [pc, #160]	@ (8003898 <Inertial_PnPL_vtblSetProperty+0xd0>)
 80037f6:	69b8      	ldr	r0, [r7, #24]
 80037f8:	f01d fe04 	bl	8021404 <json_object_dotget_number>
 80037fc:	4602      	mov	r2, r0
 80037fe:	460b      	mov	r3, r1
 8003800:	4610      	mov	r0, r2
 8003802:	4619      	mov	r1, r3
 8003804:	f7fd f9b6 	bl	8000b74 <__aeabi_d2iz>
 8003808:	4603      	mov	r3, r0
 800380a:	613b      	str	r3, [r7, #16]
    switch(samplerate)
 800380c:	693b      	ldr	r3, [r7, #16]
 800380e:	2b02      	cmp	r3, #2
 8003810:	d011      	beq.n	8003836 <Inertial_PnPL_vtblSetProperty+0x6e>
 8003812:	693b      	ldr	r3, [r7, #16]
 8003814:	2b02      	cmp	r3, #2
 8003816:	dc12      	bgt.n	800383e <Inertial_PnPL_vtblSetProperty+0x76>
 8003818:	693b      	ldr	r3, [r7, #16]
 800381a:	2b00      	cmp	r3, #0
 800381c:	d003      	beq.n	8003826 <Inertial_PnPL_vtblSetProperty+0x5e>
 800381e:	693b      	ldr	r3, [r7, #16]
 8003820:	2b01      	cmp	r3, #1
 8003822:	d004      	beq.n	800382e <Inertial_PnPL_vtblSetProperty+0x66>
 8003824:	e00b      	b.n	800383e <Inertial_PnPL_vtblSetProperty+0x76>
    {
    case 0:
      inertial_set_samplerate(n10);
 8003826:	481d      	ldr	r0, [pc, #116]	@ (800389c <Inertial_PnPL_vtblSetProperty+0xd4>)
 8003828:	f7fd fd2e 	bl	8001288 <inertial_set_samplerate>
      break;
 800382c:	e007      	b.n	800383e <Inertial_PnPL_vtblSetProperty+0x76>
    case 1:
      inertial_set_samplerate(n20);
 800382e:	481c      	ldr	r0, [pc, #112]	@ (80038a0 <Inertial_PnPL_vtblSetProperty+0xd8>)
 8003830:	f7fd fd2a 	bl	8001288 <inertial_set_samplerate>
      break;
 8003834:	e003      	b.n	800383e <Inertial_PnPL_vtblSetProperty+0x76>
    case 2:
      inertial_set_samplerate(n30);
 8003836:	481b      	ldr	r0, [pc, #108]	@ (80038a4 <Inertial_PnPL_vtblSetProperty+0xdc>)
 8003838:	f7fd fd26 	bl	8001288 <inertial_set_samplerate>
      break;
 800383c:	bf00      	nop
    }
  }
  if(json_object_dothas_value(tempJSONObject, "inertial.change_acc"))
 800383e:	491a      	ldr	r1, [pc, #104]	@ (80038a8 <Inertial_PnPL_vtblSetProperty+0xe0>)
 8003840:	69b8      	ldr	r0, [r7, #24]
 8003842:	f01d fe70 	bl	8021526 <json_object_dothas_value>
 8003846:	4603      	mov	r3, r0
 8003848:	2b00      	cmp	r3, #0
 800384a:	d01c      	beq.n	8003886 <Inertial_PnPL_vtblSetProperty+0xbe>
  {
    int change_acc = (int)json_object_dotget_number(tempJSONObject, "inertial.change_acc");
 800384c:	4916      	ldr	r1, [pc, #88]	@ (80038a8 <Inertial_PnPL_vtblSetProperty+0xe0>)
 800384e:	69b8      	ldr	r0, [r7, #24]
 8003850:	f01d fdd8 	bl	8021404 <json_object_dotget_number>
 8003854:	4602      	mov	r2, r0
 8003856:	460b      	mov	r3, r1
 8003858:	4610      	mov	r0, r2
 800385a:	4619      	mov	r1, r3
 800385c:	f7fd f98a 	bl	8000b74 <__aeabi_d2iz>
 8003860:	4603      	mov	r3, r0
 8003862:	60fb      	str	r3, [r7, #12]
    switch(change_acc)
 8003864:	68fb      	ldr	r3, [r7, #12]
 8003866:	2b00      	cmp	r3, #0
 8003868:	d003      	beq.n	8003872 <Inertial_PnPL_vtblSetProperty+0xaa>
 800386a:	68fb      	ldr	r3, [r7, #12]
 800386c:	2b01      	cmp	r3, #1
 800386e:	d005      	beq.n	800387c <Inertial_PnPL_vtblSetProperty+0xb4>
 8003870:	e009      	b.n	8003886 <Inertial_PnPL_vtblSetProperty+0xbe>
    {
    case 0:
      inertial_set_change_acc(LSM6DSV16X);
 8003872:	f04f 0000 	mov.w	r0, #0
 8003876:	f7fd fd69 	bl	800134c <inertial_set_change_acc>
      break;
 800387a:	e004      	b.n	8003886 <Inertial_PnPL_vtblSetProperty+0xbe>
    case 1:
      inertial_set_change_acc(LIS2DU12);
 800387c:	f04f 507e 	mov.w	r0, #1065353216	@ 0x3f800000
 8003880:	f7fd fd64 	bl	800134c <inertial_set_change_acc>
      break;
 8003884:	bf00      	nop
    }
  }
  json_value_free(tempJSON);
 8003886:	69f8      	ldr	r0, [r7, #28]
 8003888:	f01d ff58 	bl	802173c <json_value_free>
  return ret;
 800388c:	7dfb      	ldrb	r3, [r7, #23]
}
 800388e:	4618      	mov	r0, r3
 8003890:	3720      	adds	r7, #32
 8003892:	46bd      	mov	sp, r7
 8003894:	bd80      	pop	{r7, pc}
 8003896:	bf00      	nop
 8003898:	080278f4 	.word	0x080278f4
 800389c:	41200000 	.word	0x41200000
 80038a0:	41a00000 	.word	0x41a00000
 80038a4:	41f00000 	.word	0x41f00000
 80038a8:	08027908 	.word	0x08027908

080038ac <Inertial_PnPL_vtblExecuteFunction>:

uint8_t Inertial_PnPL_vtblExecuteFunction(IPnPLComponent_t *_this, char *serializedJSON)
{
 80038ac:	b480      	push	{r7}
 80038ae:	b083      	sub	sp, #12
 80038b0:	af00      	add	r7, sp, #0
 80038b2:	6078      	str	r0, [r7, #4]
 80038b4:	6039      	str	r1, [r7, #0]
  return 1;
 80038b6:	2301      	movs	r3, #1
}
 80038b8:	4618      	mov	r0, r3
 80038ba:	370c      	adds	r7, #12
 80038bc:	46bd      	mov	sp, r7
 80038be:	f85d 7b04 	ldr.w	r7, [sp], #4
 80038c2:	4770      	bx	lr

080038c4 <UpdateFWBlueMS>:
 * @param int32_t data_length length of the data
 * @param uint8_t WriteMagicNum 1/0 for writing or not the magic number
 * @retval int8_t Return value for checking purpouse (1/-1 == Ok/Error)
 */
int8_t UpdateFWBlueMS(uint32_t *SizeOfUpdate, uint8_t *att_data, int32_t data_length, uint8_t WriteMagicNum)
{
 80038c4:	b580      	push	{r7, lr}
 80038c6:	b08a      	sub	sp, #40	@ 0x28
 80038c8:	af00      	add	r7, sp, #0
 80038ca:	60f8      	str	r0, [r7, #12]
 80038cc:	60b9      	str	r1, [r7, #8]
 80038ce:	607a      	str	r2, [r7, #4]
 80038d0:	70fb      	strb	r3, [r7, #3]
  int8_t ReturnValue=0;
 80038d2:	2300      	movs	r3, #0
 80038d4:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  /* Save the Packed received */

  if(data_length>(*SizeOfUpdate)){
 80038d8:	68fb      	ldr	r3, [r7, #12]
 80038da:	681a      	ldr	r2, [r3, #0]
 80038dc:	687b      	ldr	r3, [r7, #4]
 80038de:	429a      	cmp	r2, r3
 80038e0:	d20d      	bcs.n	80038fe <UpdateFWBlueMS+0x3a>
    /* Too many bytes...Something wrong... necessity to send it again... */
    OTA_PRINTF("OTA something wrong data_length=%lu RemSizeOfUpdate=%ld....\r\nPlease Try again\r\n",data_length,(*SizeOfUpdate));
 80038e2:	68fb      	ldr	r3, [r7, #12]
 80038e4:	681b      	ldr	r3, [r3, #0]
 80038e6:	461a      	mov	r2, r3
 80038e8:	6879      	ldr	r1, [r7, #4]
 80038ea:	4891      	ldr	r0, [pc, #580]	@ (8003b30 <UpdateFWBlueMS+0x26c>)
 80038ec:	f020 fa36 	bl	8023d5c <iprintf>
    ReturnValue = -1;
 80038f0:	23ff      	movs	r3, #255	@ 0xff
 80038f2:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    /* Reset for Restarting again */
    *SizeOfUpdate=0;
 80038f6:	68fb      	ldr	r3, [r7, #12]
 80038f8:	2200      	movs	r2, #0
 80038fa:	601a      	str	r2, [r3, #0]
 80038fc:	e155      	b.n	8003baa <UpdateFWBlueMS+0x2e6>
  } else {
    int32_t Counter;
    int32_t FirstChunk=0;
 80038fe:	2300      	movs	r3, #0
 8003900:	61fb      	str	r3, [r7, #28]
    int32_t LastMult16=0;
 8003902:	2300      	movs	r3, #0
 8003904:	613b      	str	r3, [r7, #16]
    int32_t Written=0;
 8003906:	2300      	movs	r3, #0
 8003908:	61bb      	str	r3, [r7, #24]
    //OTA_PRINTF("OTA chunck length=%ld RemSize=%ld\r\n",data_length,(*SizeOfUpdate));
    /* Save the received OTA packed ad save it to flash */
    /* Disable instruction cache prior to internal cacheable memory update */
    if (HAL_ICACHE_Disable() != HAL_OK) {
 800390a:	f00d ff03 	bl	8011714 <HAL_ICACHE_Disable>
 800390e:	4603      	mov	r3, r0
 8003910:	2b00      	cmp	r3, #0
 8003912:	d004      	beq.n	800391e <UpdateFWBlueMS+0x5a>
      STBOX1_Error_Handler(STBOX1_ERROR_FLASH,__FILE__,__LINE__);
 8003914:	2271      	movs	r2, #113	@ 0x71
 8003916:	4987      	ldr	r1, [pc, #540]	@ (8003b34 <UpdateFWBlueMS+0x270>)
 8003918:	2002      	movs	r0, #2
 800391a:	f000 ff87 	bl	800482c <STBOX1_Error_Handler>
    }
    /* Unlock the Flash to enable the flash control register access *************/
    HAL_FLASH_Unlock();
 800391e:	f00b fc15 	bl	800f14c <HAL_FLASH_Unlock>

    /* Fill Remaming bytes for reaching 16bytes */
    if(ValuesSavedOnBuffer!=0) {
 8003922:	4b85      	ldr	r3, [pc, #532]	@ (8003b38 <UpdateFWBlueMS+0x274>)
 8003924:	681b      	ldr	r3, [r3, #0]
 8003926:	2b00      	cmp	r3, #0
 8003928:	d03a      	beq.n	80039a0 <UpdateFWBlueMS+0xdc>
      FirstChunk = (16-ValuesSavedOnBuffer);
 800392a:	4b83      	ldr	r3, [pc, #524]	@ (8003b38 <UpdateFWBlueMS+0x274>)
 800392c:	681b      	ldr	r3, [r3, #0]
 800392e:	f1c3 0310 	rsb	r3, r3, #16
 8003932:	61fb      	str	r3, [r7, #28]
      if(FirstChunk>data_length) {
 8003934:	69fa      	ldr	r2, [r7, #28]
 8003936:	687b      	ldr	r3, [r7, #4]
 8003938:	429a      	cmp	r2, r3
 800393a:	dd01      	ble.n	8003940 <UpdateFWBlueMS+0x7c>
        FirstChunk = data_length;
 800393c:	687b      	ldr	r3, [r7, #4]
 800393e:	61fb      	str	r3, [r7, #28]
      }
      memcpy(PointerToBuffer,att_data,FirstChunk);
 8003940:	4b7e      	ldr	r3, [pc, #504]	@ (8003b3c <UpdateFWBlueMS+0x278>)
 8003942:	681b      	ldr	r3, [r3, #0]
 8003944:	69fa      	ldr	r2, [r7, #28]
 8003946:	68b9      	ldr	r1, [r7, #8]
 8003948:	4618      	mov	r0, r3
 800394a:	f020 fc50 	bl	80241ee <memcpy>
      Written+=FirstChunk;
 800394e:	69ba      	ldr	r2, [r7, #24]
 8003950:	69fb      	ldr	r3, [r7, #28]
 8003952:	4413      	add	r3, r2
 8003954:	61bb      	str	r3, [r7, #24]
      ValuesSavedOnBuffer+=FirstChunk;
 8003956:	4b78      	ldr	r3, [pc, #480]	@ (8003b38 <UpdateFWBlueMS+0x274>)
 8003958:	681a      	ldr	r2, [r3, #0]
 800395a:	69fb      	ldr	r3, [r7, #28]
 800395c:	4413      	add	r3, r2
 800395e:	4a76      	ldr	r2, [pc, #472]	@ (8003b38 <UpdateFWBlueMS+0x274>)
 8003960:	6013      	str	r3, [r2, #0]

      /* If we have enough data */
      if(ValuesSavedOnBuffer==16) {
 8003962:	4b75      	ldr	r3, [pc, #468]	@ (8003b38 <UpdateFWBlueMS+0x274>)
 8003964:	681b      	ldr	r3, [r3, #0]
 8003966:	2b10      	cmp	r3, #16
 8003968:	d11a      	bne.n	80039a0 <UpdateFWBlueMS+0xdc>
        ValuesSavedOnBuffer=0;
 800396a:	4b73      	ldr	r3, [pc, #460]	@ (8003b38 <UpdateFWBlueMS+0x274>)
 800396c:	2200      	movs	r2, #0
 800396e:	601a      	str	r2, [r3, #0]
        PointerToBuffer= (uint8_t *) BufferValueToWrite;
 8003970:	4b72      	ldr	r3, [pc, #456]	@ (8003b3c <UpdateFWBlueMS+0x278>)
 8003972:	4a73      	ldr	r2, [pc, #460]	@ (8003b40 <UpdateFWBlueMS+0x27c>)
 8003974:	601a      	str	r2, [r3, #0]
       if(HAL_FLASH_Program(FLASH_TYPEPROGRAM_QUADWORD, WritingAddress,((uint32_t)BufferValueToWrite))==HAL_OK) {
 8003976:	4b73      	ldr	r3, [pc, #460]	@ (8003b44 <UpdateFWBlueMS+0x280>)
 8003978:	681b      	ldr	r3, [r3, #0]
 800397a:	4a71      	ldr	r2, [pc, #452]	@ (8003b40 <UpdateFWBlueMS+0x27c>)
 800397c:	4619      	mov	r1, r3
 800397e:	2001      	movs	r0, #1
 8003980:	f00b fb9a 	bl	800f0b8 <HAL_FLASH_Program>
 8003984:	4603      	mov	r3, r0
 8003986:	2b00      	cmp	r3, #0
 8003988:	d105      	bne.n	8003996 <UpdateFWBlueMS+0xd2>
         WritingAddress+=16;
 800398a:	4b6e      	ldr	r3, [pc, #440]	@ (8003b44 <UpdateFWBlueMS+0x280>)
 800398c:	681b      	ldr	r3, [r3, #0]
 800398e:	3310      	adds	r3, #16
 8003990:	4a6c      	ldr	r2, [pc, #432]	@ (8003b44 <UpdateFWBlueMS+0x280>)
 8003992:	6013      	str	r3, [r2, #0]
 8003994:	e004      	b.n	80039a0 <UpdateFWBlueMS+0xdc>
        } else {
          /* Error occurred while writing data in Flash memory.
             User can add here some code to deal with this error
             FLASH_ErrorTypeDef errorcode = HAL_FLASH_GetError(); */
          OTA_ERROR_FUNCTION();
 8003996:	228a      	movs	r2, #138	@ 0x8a
 8003998:	4966      	ldr	r1, [pc, #408]	@ (8003b34 <UpdateFWBlueMS+0x270>)
 800399a:	2002      	movs	r0, #2
 800399c:	f000 ff46 	bl	800482c <STBOX1_Error_Handler>
        }
      }
    }

    /* We move at steps of 16 */
    LastMult16= ((uint32_t)(data_length-FirstChunk)) & (~(((uint32_t)0xF)));
 80039a0:	687a      	ldr	r2, [r7, #4]
 80039a2:	69fb      	ldr	r3, [r7, #28]
 80039a4:	1ad3      	subs	r3, r2, r3
 80039a6:	f023 030f 	bic.w	r3, r3, #15
 80039aa:	613b      	str	r3, [r7, #16]
    for(Counter=FirstChunk;Counter<LastMult16;Counter+=16) {
 80039ac:	69fb      	ldr	r3, [r7, #28]
 80039ae:	623b      	str	r3, [r7, #32]
 80039b0:	e023      	b.n	80039fa <UpdateFWBlueMS+0x136>
      memcpy(PointerToBuffer,att_data+Counter,16);
 80039b2:	4b62      	ldr	r3, [pc, #392]	@ (8003b3c <UpdateFWBlueMS+0x278>)
 80039b4:	6818      	ldr	r0, [r3, #0]
 80039b6:	6a3b      	ldr	r3, [r7, #32]
 80039b8:	68ba      	ldr	r2, [r7, #8]
 80039ba:	4413      	add	r3, r2
 80039bc:	2210      	movs	r2, #16
 80039be:	4619      	mov	r1, r3
 80039c0:	f020 fc15 	bl	80241ee <memcpy>
      Written+=16;
 80039c4:	69bb      	ldr	r3, [r7, #24]
 80039c6:	3310      	adds	r3, #16
 80039c8:	61bb      	str	r3, [r7, #24]
      if(HAL_FLASH_Program(FLASH_TYPEPROGRAM_QUADWORD, WritingAddress,((uint32_t)BufferValueToWrite))==HAL_OK) {
 80039ca:	4b5e      	ldr	r3, [pc, #376]	@ (8003b44 <UpdateFWBlueMS+0x280>)
 80039cc:	681b      	ldr	r3, [r3, #0]
 80039ce:	4a5c      	ldr	r2, [pc, #368]	@ (8003b40 <UpdateFWBlueMS+0x27c>)
 80039d0:	4619      	mov	r1, r3
 80039d2:	2001      	movs	r0, #1
 80039d4:	f00b fb70 	bl	800f0b8 <HAL_FLASH_Program>
 80039d8:	4603      	mov	r3, r0
 80039da:	2b00      	cmp	r3, #0
 80039dc:	d105      	bne.n	80039ea <UpdateFWBlueMS+0x126>
       WritingAddress+=16;
 80039de:	4b59      	ldr	r3, [pc, #356]	@ (8003b44 <UpdateFWBlueMS+0x280>)
 80039e0:	681b      	ldr	r3, [r3, #0]
 80039e2:	3310      	adds	r3, #16
 80039e4:	4a57      	ldr	r2, [pc, #348]	@ (8003b44 <UpdateFWBlueMS+0x280>)
 80039e6:	6013      	str	r3, [r2, #0]
 80039e8:	e004      	b.n	80039f4 <UpdateFWBlueMS+0x130>
      } else {
        /* Error occurred while writing data in Flash memory.
           User can add here some code to deal with this error
           FLASH_ErrorTypeDef errorcode = HAL_FLASH_GetError(); */
        OTA_ERROR_FUNCTION();
 80039ea:	229a      	movs	r2, #154	@ 0x9a
 80039ec:	4951      	ldr	r1, [pc, #324]	@ (8003b34 <UpdateFWBlueMS+0x270>)
 80039ee:	2002      	movs	r0, #2
 80039f0:	f000 ff1c 	bl	800482c <STBOX1_Error_Handler>
    for(Counter=FirstChunk;Counter<LastMult16;Counter+=16) {
 80039f4:	6a3b      	ldr	r3, [r7, #32]
 80039f6:	3310      	adds	r3, #16
 80039f8:	623b      	str	r3, [r7, #32]
 80039fa:	6a3a      	ldr	r2, [r7, #32]
 80039fc:	693b      	ldr	r3, [r7, #16]
 80039fe:	429a      	cmp	r2, r3
 8003a00:	dbd7      	blt.n	80039b2 <UpdateFWBlueMS+0xee>
      }
    }

    /* Last Section of this chunk */
    if(Written<data_length) {
 8003a02:	69ba      	ldr	r2, [r7, #24]
 8003a04:	687b      	ldr	r3, [r7, #4]
 8003a06:	429a      	cmp	r2, r3
 8003a08:	da1b      	bge.n	8003a42 <UpdateFWBlueMS+0x17e>
       memcpy(PointerToBuffer,att_data+Written,(data_length-Written));
 8003a0a:	4b4c      	ldr	r3, [pc, #304]	@ (8003b3c <UpdateFWBlueMS+0x278>)
 8003a0c:	6818      	ldr	r0, [r3, #0]
 8003a0e:	69bb      	ldr	r3, [r7, #24]
 8003a10:	68ba      	ldr	r2, [r7, #8]
 8003a12:	18d1      	adds	r1, r2, r3
 8003a14:	687a      	ldr	r2, [r7, #4]
 8003a16:	69bb      	ldr	r3, [r7, #24]
 8003a18:	1ad3      	subs	r3, r2, r3
 8003a1a:	461a      	mov	r2, r3
 8003a1c:	f020 fbe7 	bl	80241ee <memcpy>
       ValuesSavedOnBuffer+=(data_length-Written);
 8003a20:	687a      	ldr	r2, [r7, #4]
 8003a22:	69bb      	ldr	r3, [r7, #24]
 8003a24:	1ad3      	subs	r3, r2, r3
 8003a26:	461a      	mov	r2, r3
 8003a28:	4b43      	ldr	r3, [pc, #268]	@ (8003b38 <UpdateFWBlueMS+0x274>)
 8003a2a:	681b      	ldr	r3, [r3, #0]
 8003a2c:	4413      	add	r3, r2
 8003a2e:	4a42      	ldr	r2, [pc, #264]	@ (8003b38 <UpdateFWBlueMS+0x274>)
 8003a30:	6013      	str	r3, [r2, #0]
       PointerToBuffer+=(data_length-Written);
 8003a32:	4b42      	ldr	r3, [pc, #264]	@ (8003b3c <UpdateFWBlueMS+0x278>)
 8003a34:	681b      	ldr	r3, [r3, #0]
 8003a36:	6879      	ldr	r1, [r7, #4]
 8003a38:	69ba      	ldr	r2, [r7, #24]
 8003a3a:	1a8a      	subs	r2, r1, r2
 8003a3c:	4413      	add	r3, r2
 8003a3e:	4a3f      	ldr	r2, [pc, #252]	@ (8003b3c <UpdateFWBlueMS+0x278>)
 8003a40:	6013      	str	r3, [r2, #0]
    }

    /* Reduce the remaing bytes for OTA completition */
    *SizeOfUpdate -= data_length;
 8003a42:	68fb      	ldr	r3, [r7, #12]
 8003a44:	681a      	ldr	r2, [r3, #0]
 8003a46:	687b      	ldr	r3, [r7, #4]
 8003a48:	1ad2      	subs	r2, r2, r3
 8003a4a:	68fb      	ldr	r3, [r7, #12]
 8003a4c:	601a      	str	r2, [r3, #0]

    if(*SizeOfUpdate==0) {
 8003a4e:	68fb      	ldr	r3, [r7, #12]
 8003a50:	681b      	ldr	r3, [r3, #0]
 8003a52:	2b00      	cmp	r3, #0
 8003a54:	f040 809d 	bne.w	8003b92 <UpdateFWBlueMS+0x2ce>
      //Check if we need to dump the last bytes
      if(ValuesSavedOnBuffer!=0) {
 8003a58:	4b37      	ldr	r3, [pc, #220]	@ (8003b38 <UpdateFWBlueMS+0x274>)
 8003a5a:	681b      	ldr	r3, [r3, #0]
 8003a5c:	2b00      	cmp	r3, #0
 8003a5e:	d014      	beq.n	8003a8a <UpdateFWBlueMS+0x1c6>
        ValuesSavedOnBuffer=0;
 8003a60:	4b35      	ldr	r3, [pc, #212]	@ (8003b38 <UpdateFWBlueMS+0x274>)
 8003a62:	2200      	movs	r2, #0
 8003a64:	601a      	str	r2, [r3, #0]
        PointerToBuffer= (uint8_t *) BufferValueToWrite;
 8003a66:	4b35      	ldr	r3, [pc, #212]	@ (8003b3c <UpdateFWBlueMS+0x278>)
 8003a68:	4a35      	ldr	r2, [pc, #212]	@ (8003b40 <UpdateFWBlueMS+0x27c>)
 8003a6a:	601a      	str	r2, [r3, #0]
         if(HAL_FLASH_Program(FLASH_TYPEPROGRAM_QUADWORD, WritingAddress,((uint32_t)BufferValueToWrite))!=HAL_OK) {
 8003a6c:	4b35      	ldr	r3, [pc, #212]	@ (8003b44 <UpdateFWBlueMS+0x280>)
 8003a6e:	681b      	ldr	r3, [r3, #0]
 8003a70:	4a33      	ldr	r2, [pc, #204]	@ (8003b40 <UpdateFWBlueMS+0x27c>)
 8003a72:	4619      	mov	r1, r3
 8003a74:	2001      	movs	r0, #1
 8003a76:	f00b fb1f 	bl	800f0b8 <HAL_FLASH_Program>
 8003a7a:	4603      	mov	r3, r0
 8003a7c:	2b00      	cmp	r3, #0
 8003a7e:	d004      	beq.n	8003a8a <UpdateFWBlueMS+0x1c6>
            /* Error occurred while writing data in Flash memory.
               User can add here some code to deal with this error
               FLASH_ErrorTypeDef errorcode = HAL_FLASH_GetError(); */
            OTA_ERROR_FUNCTION();
 8003a80:	22b1      	movs	r2, #177	@ 0xb1
 8003a82:	492c      	ldr	r1, [pc, #176]	@ (8003b34 <UpdateFWBlueMS+0x270>)
 8003a84:	2002      	movs	r0, #2
 8003a86:	f000 fed1 	bl	800482c <STBOX1_Error_Handler>
          }
      }

      /* We had received the whole firmware and we have saved it in Flash */
      OTA_PRINTF("OTA Update saved\r\n");
 8003a8a:	482f      	ldr	r0, [pc, #188]	@ (8003b48 <UpdateFWBlueMS+0x284>)
 8003a8c:	f020 f9ce 	bl	8023e2c <puts>

      if(WriteMagicNum) {
 8003a90:	78fb      	ldrb	r3, [r7, #3]
 8003a92:	2b00      	cmp	r3, #0
 8003a94:	d07d      	beq.n	8003b92 <UpdateFWBlueMS+0x2ce>
        uint32_t uwCRCValue = 0;
 8003a96:	2300      	movs	r3, #0
 8003a98:	617b      	str	r3, [r7, #20]

        /* Make the CRC integrety check */
        if(AspecteduwCRCValue) {
 8003a9a:	4b2c      	ldr	r3, [pc, #176]	@ (8003b4c <UpdateFWBlueMS+0x288>)
 8003a9c:	681b      	ldr	r3, [r3, #0]
 8003a9e:	2b00      	cmp	r3, #0
 8003aa0:	d062      	beq.n	8003b68 <UpdateFWBlueMS+0x2a4>
          /* Init CRC for OTA-integrity check */
          CrcHandle.Instance = CRC;
 8003aa2:	4b2b      	ldr	r3, [pc, #172]	@ (8003b50 <UpdateFWBlueMS+0x28c>)
 8003aa4:	4a2b      	ldr	r2, [pc, #172]	@ (8003b54 <UpdateFWBlueMS+0x290>)
 8003aa6:	601a      	str	r2, [r3, #0]
          /* The default polynomial is used */
          CrcHandle.Init.DefaultPolynomialUse    = DEFAULT_POLYNOMIAL_ENABLE;
 8003aa8:	4b29      	ldr	r3, [pc, #164]	@ (8003b50 <UpdateFWBlueMS+0x28c>)
 8003aaa:	2200      	movs	r2, #0
 8003aac:	711a      	strb	r2, [r3, #4]

          /* The default init value is used */
          CrcHandle.Init.DefaultInitValueUse     = DEFAULT_INIT_VALUE_ENABLE;
 8003aae:	4b28      	ldr	r3, [pc, #160]	@ (8003b50 <UpdateFWBlueMS+0x28c>)
 8003ab0:	2200      	movs	r2, #0
 8003ab2:	715a      	strb	r2, [r3, #5]

          /* The input data are not inverted */
          CrcHandle.Init.InputDataInversionMode  = CRC_INPUTDATA_INVERSION_NONE;
 8003ab4:	4b26      	ldr	r3, [pc, #152]	@ (8003b50 <UpdateFWBlueMS+0x28c>)
 8003ab6:	2200      	movs	r2, #0
 8003ab8:	615a      	str	r2, [r3, #20]

          /* The output data are not inverted */
          CrcHandle.Init.OutputDataInversionMode = CRC_OUTPUTDATA_INVERSION_DISABLE;
 8003aba:	4b25      	ldr	r3, [pc, #148]	@ (8003b50 <UpdateFWBlueMS+0x28c>)
 8003abc:	2200      	movs	r2, #0
 8003abe:	619a      	str	r2, [r3, #24]

          /*  32-bit CRC lengt */
          CrcHandle.Init.CRCLength = CRC_POLYLENGTH_32B;
 8003ac0:	4b23      	ldr	r3, [pc, #140]	@ (8003b50 <UpdateFWBlueMS+0x28c>)
 8003ac2:	2200      	movs	r2, #0
 8003ac4:	60da      	str	r2, [r3, #12]

          /* The input data are 32-bit long words */
          CrcHandle.InputDataFormat              = CRC_INPUTDATA_FORMAT_WORDS;
 8003ac6:	4b22      	ldr	r3, [pc, #136]	@ (8003b50 <UpdateFWBlueMS+0x28c>)
 8003ac8:	2203      	movs	r2, #3
 8003aca:	621a      	str	r2, [r3, #32]

          if(HAL_CRC_GetState(&CrcHandle) != HAL_CRC_STATE_RESET) {
 8003acc:	4820      	ldr	r0, [pc, #128]	@ (8003b50 <UpdateFWBlueMS+0x28c>)
 8003ace:	f00a fa9c 	bl	800e00a <HAL_CRC_GetState>
 8003ad2:	4603      	mov	r3, r0
 8003ad4:	2b00      	cmp	r3, #0
 8003ad6:	d002      	beq.n	8003ade <UpdateFWBlueMS+0x21a>
            HAL_CRC_DeInit(&CrcHandle);
 8003ad8:	481d      	ldr	r0, [pc, #116]	@ (8003b50 <UpdateFWBlueMS+0x28c>)
 8003ada:	f00a fa1d 	bl	800df18 <HAL_CRC_DeInit>
          }

          if (HAL_CRC_Init(&CrcHandle) != HAL_OK) {
 8003ade:	481c      	ldr	r0, [pc, #112]	@ (8003b50 <UpdateFWBlueMS+0x28c>)
 8003ae0:	f00a f9b6 	bl	800de50 <HAL_CRC_Init>
 8003ae4:	4603      	mov	r3, r0
 8003ae6:	2b00      	cmp	r3, #0
 8003ae8:	d005      	beq.n	8003af6 <UpdateFWBlueMS+0x232>
            /* Initialization Error */
            OTA_ERROR_FUNCTION();
 8003aea:	22d7      	movs	r2, #215	@ 0xd7
 8003aec:	4911      	ldr	r1, [pc, #68]	@ (8003b34 <UpdateFWBlueMS+0x270>)
 8003aee:	2002      	movs	r0, #2
 8003af0:	f000 fe9c 	bl	800482c <STBOX1_Error_Handler>
 8003af4:	e002      	b.n	8003afc <UpdateFWBlueMS+0x238>
          } else {
            OTA_PRINTF("CRC  Initialized\n\r");
 8003af6:	4818      	ldr	r0, [pc, #96]	@ (8003b58 <UpdateFWBlueMS+0x294>)
 8003af8:	f020 f930 	bl	8023d5c <iprintf>
          }
          /* Compute the CRC */
          uwCRCValue = HAL_CRC_Calculate(&CrcHandle, (uint32_t *)OTA_ADDRESS_START_BANK, SizeOfUpdateBlueFW>>2);
 8003afc:	4b17      	ldr	r3, [pc, #92]	@ (8003b5c <UpdateFWBlueMS+0x298>)
 8003afe:	681b      	ldr	r3, [r3, #0]
 8003b00:	089b      	lsrs	r3, r3, #2
 8003b02:	461a      	mov	r2, r3
 8003b04:	f04f 6101 	mov.w	r1, #135266304	@ 0x8100000
 8003b08:	4811      	ldr	r0, [pc, #68]	@ (8003b50 <UpdateFWBlueMS+0x28c>)
 8003b0a:	f00a fa32 	bl	800df72 <HAL_CRC_Calculate>
 8003b0e:	6178      	str	r0, [r7, #20]

          if(uwCRCValue==AspecteduwCRCValue) {
 8003b10:	4b0e      	ldr	r3, [pc, #56]	@ (8003b4c <UpdateFWBlueMS+0x288>)
 8003b12:	681b      	ldr	r3, [r3, #0]
 8003b14:	697a      	ldr	r2, [r7, #20]
 8003b16:	429a      	cmp	r2, r3
 8003b18:	d106      	bne.n	8003b28 <UpdateFWBlueMS+0x264>
            ReturnValue=1;
 8003b1a:	2301      	movs	r3, #1
 8003b1c:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
            OTA_PRINTF("OTA CRC-checked\r\n");
 8003b20:	480f      	ldr	r0, [pc, #60]	@ (8003b60 <UpdateFWBlueMS+0x29c>)
 8003b22:	f020 f983 	bl	8023e2c <puts>
 8003b26:	e022      	b.n	8003b6e <UpdateFWBlueMS+0x2aa>
          } else {
            OTA_PRINTF("OTA Error CRC-checking\r\n");
 8003b28:	480e      	ldr	r0, [pc, #56]	@ (8003b64 <UpdateFWBlueMS+0x2a0>)
 8003b2a:	f020 f97f 	bl	8023e2c <puts>
 8003b2e:	e01e      	b.n	8003b6e <UpdateFWBlueMS+0x2aa>
 8003b30:	0802792c 	.word	0x0802792c
 8003b34:	0802797c 	.word	0x0802797c
 8003b38:	20000528 	.word	0x20000528
 8003b3c:	2000000c 	.word	0x2000000c
 8003b40:	20000518 	.word	0x20000518
 8003b44:	20000514 	.word	0x20000514
 8003b48:	08027a00 	.word	0x08027a00
 8003b4c:	20000510 	.word	0x20000510
 8003b50:	2000056c 	.word	0x2000056c
 8003b54:	40023000 	.word	0x40023000
 8003b58:	08027a14 	.word	0x08027a14
 8003b5c:	2000050c 	.word	0x2000050c
 8003b60:	08027a28 	.word	0x08027a28
 8003b64:	08027a3c 	.word	0x08027a3c
          }
        } else {
          ReturnValue=1;
 8003b68:	2301      	movs	r3, #1
 8003b6a:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27

        }
        if(ReturnValue!=1) {
 8003b6e:	f997 3027 	ldrsb.w	r3, [r7, #39]	@ 0x27
 8003b72:	2b01      	cmp	r3, #1
 8003b74:	d00d      	beq.n	8003b92 <UpdateFWBlueMS+0x2ce>
          ReturnValue=-1;
 8003b76:	23ff      	movs	r3, #255	@ 0xff
 8003b78:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
          if(AspecteduwCRCValue) {
 8003b7c:	4b0e      	ldr	r3, [pc, #56]	@ (8003bb8 <UpdateFWBlueMS+0x2f4>)
 8003b7e:	681b      	ldr	r3, [r3, #0]
 8003b80:	2b00      	cmp	r3, #0
 8003b82:	d006      	beq.n	8003b92 <UpdateFWBlueMS+0x2ce>
            OTA_PRINTF("Wrong CRC! Computed=%lx  aspected=%lx ... Try again\r\n",uwCRCValue,AspecteduwCRCValue);
 8003b84:	4b0c      	ldr	r3, [pc, #48]	@ (8003bb8 <UpdateFWBlueMS+0x2f4>)
 8003b86:	681b      	ldr	r3, [r3, #0]
 8003b88:	461a      	mov	r2, r3
 8003b8a:	6979      	ldr	r1, [r7, #20]
 8003b8c:	480b      	ldr	r0, [pc, #44]	@ (8003bbc <UpdateFWBlueMS+0x2f8>)
 8003b8e:	f020 f8e5 	bl	8023d5c <iprintf>
      }
    }

    /* Lock the Flash to disable the flash control register access (recommended
     to protect the FLASH memory against possible unwanted operation) *********/
    HAL_FLASH_Lock();
 8003b92:	f00b fafd 	bl	800f190 <HAL_FLASH_Lock>

    /* Re-enable instruction cache */
    if (HAL_ICACHE_Enable() != HAL_OK)
 8003b96:	f00d fdad 	bl	80116f4 <HAL_ICACHE_Enable>
 8003b9a:	4603      	mov	r3, r0
 8003b9c:	2b00      	cmp	r3, #0
 8003b9e:	d004      	beq.n	8003baa <UpdateFWBlueMS+0x2e6>
    {
      STBOX1_Error_Handler(STBOX1_ERROR_FLASH,__FILE__,__LINE__);
 8003ba0:	22f8      	movs	r2, #248	@ 0xf8
 8003ba2:	4907      	ldr	r1, [pc, #28]	@ (8003bc0 <UpdateFWBlueMS+0x2fc>)
 8003ba4:	2002      	movs	r0, #2
 8003ba6:	f000 fe41 	bl	800482c <STBOX1_Error_Handler>
    }
  }
  return ReturnValue;
 8003baa:	f997 3027 	ldrsb.w	r3, [r7, #39]	@ 0x27
}
 8003bae:	4618      	mov	r0, r3
 8003bb0:	3728      	adds	r7, #40	@ 0x28
 8003bb2:	46bd      	mov	sp, r7
 8003bb4:	bd80      	pop	{r7, pc}
 8003bb6:	bf00      	nop
 8003bb8:	20000510 	.word	0x20000510
 8003bbc:	08027a54 	.word	0x08027a54
 8003bc0:	0802797c 	.word	0x0802797c

08003bc4 <StartUpdateFWBlueMS>:
 * @param uint32_t SizeOfUpdate  size of the firmware image [bytes]
 * @param uint32_t uwCRCValue aspected CRV value
 * @retval None
 */
void StartUpdateFWBlueMS(uint32_t SizeOfUpdate, uint32_t uwCRCValue)
{
 8003bc4:	b580      	push	{r7, lr}
 8003bc6:	b088      	sub	sp, #32
 8003bc8:	af00      	add	r7, sp, #0
 8003bca:	6078      	str	r0, [r7, #4]
 8003bcc:	6039      	str	r1, [r7, #0]
  FLASH_EraseInitTypeDef EraseInitStruct;
  uint32_t SectorError = 0;
 8003bce:	2300      	movs	r3, #0
 8003bd0:	60fb      	str	r3, [r7, #12]
  OTA_PRINTF("Start FLASH Erase\r\n");
 8003bd2:	482f      	ldr	r0, [pc, #188]	@ (8003c90 <StartUpdateFWBlueMS+0xcc>)
 8003bd4:	f020 f92a 	bl	8023e2c <puts>

  SizeOfUpdateBlueFW = SizeOfUpdate;
 8003bd8:	4a2e      	ldr	r2, [pc, #184]	@ (8003c94 <StartUpdateFWBlueMS+0xd0>)
 8003bda:	687b      	ldr	r3, [r7, #4]
 8003bdc:	6013      	str	r3, [r2, #0]
  AspecteduwCRCValue = uwCRCValue;
 8003bde:	4a2e      	ldr	r2, [pc, #184]	@ (8003c98 <StartUpdateFWBlueMS+0xd4>)
 8003be0:	683b      	ldr	r3, [r7, #0]
 8003be2:	6013      	str	r3, [r2, #0]
  ValuesSavedOnBuffer=0;
 8003be4:	4b2d      	ldr	r3, [pc, #180]	@ (8003c9c <StartUpdateFWBlueMS+0xd8>)
 8003be6:	2200      	movs	r2, #0
 8003be8:	601a      	str	r2, [r3, #0]
  PointerToBuffer = (uint8_t *) BufferValueToWrite;
 8003bea:	4b2d      	ldr	r3, [pc, #180]	@ (8003ca0 <StartUpdateFWBlueMS+0xdc>)
 8003bec:	4a2d      	ldr	r2, [pc, #180]	@ (8003ca4 <StartUpdateFWBlueMS+0xe0>)
 8003bee:	601a      	str	r2, [r3, #0]

  WritingAddress = OTA_ADDRESS_START_BANK;
 8003bf0:	4b2d      	ldr	r3, [pc, #180]	@ (8003ca8 <StartUpdateFWBlueMS+0xe4>)
 8003bf2:	f04f 6201 	mov.w	r2, #135266304	@ 0x8100000
 8003bf6:	601a      	str	r2, [r3, #0]

  if(CurrentActiveBank==1) {
 8003bf8:	4b2c      	ldr	r3, [pc, #176]	@ (8003cac <StartUpdateFWBlueMS+0xe8>)
 8003bfa:	681b      	ldr	r3, [r3, #0]
 8003bfc:	2b01      	cmp	r3, #1
 8003bfe:	d102      	bne.n	8003c06 <StartUpdateFWBlueMS+0x42>
    EraseInitStruct.Banks       = FLASH_BANK_2;
 8003c00:	2302      	movs	r3, #2
 8003c02:	617b      	str	r3, [r7, #20]
 8003c04:	e001      	b.n	8003c0a <StartUpdateFWBlueMS+0x46>
  } else {
    EraseInitStruct.Banks       = FLASH_BANK_1;
 8003c06:	2301      	movs	r3, #1
 8003c08:	617b      	str	r3, [r7, #20]
  }

  EraseInitStruct.Page        = 0;
 8003c0a:	2300      	movs	r3, #0
 8003c0c:	61bb      	str	r3, [r7, #24]
  EraseInitStruct.TypeErase   = FLASH_TYPEERASE_PAGES;
 8003c0e:	2302      	movs	r3, #2
 8003c10:	613b      	str	r3, [r7, #16]
  EraseInitStruct.NbPages     = (SizeOfUpdate+16+FLASH_PAGE_SIZE-1)/FLASH_PAGE_SIZE;
 8003c12:	687b      	ldr	r3, [r7, #4]
 8003c14:	f503 5300 	add.w	r3, r3, #8192	@ 0x2000
 8003c18:	330f      	adds	r3, #15
 8003c1a:	0b5b      	lsrs	r3, r3, #13
 8003c1c:	61fb      	str	r3, [r7, #28]

  /* Disable instruction cache prior to internal cacheable memory update */
  if (HAL_ICACHE_Disable() != HAL_OK)
 8003c1e:	f00d fd79 	bl	8011714 <HAL_ICACHE_Disable>
 8003c22:	4603      	mov	r3, r0
 8003c24:	2b00      	cmp	r3, #0
 8003c26:	d005      	beq.n	8003c34 <StartUpdateFWBlueMS+0x70>
  {
    STBOX1_Error_Handler(STBOX1_ERROR_FLASH,__FILE__,__LINE__);
 8003c28:	f44f 728f 	mov.w	r2, #286	@ 0x11e
 8003c2c:	4920      	ldr	r1, [pc, #128]	@ (8003cb0 <StartUpdateFWBlueMS+0xec>)
 8003c2e:	2002      	movs	r0, #2
 8003c30:	f000 fdfc 	bl	800482c <STBOX1_Error_Handler>
  }

  /* Unlock the Flash to enable the flash control register access *************/
  HAL_FLASH_Unlock();
 8003c34:	f00b fa8a 	bl	800f14c <HAL_FLASH_Unlock>

  if(HAL_FLASHEx_Erase(&EraseInitStruct, &SectorError) != HAL_OK){
 8003c38:	f107 020c 	add.w	r2, r7, #12
 8003c3c:	f107 0310 	add.w	r3, r7, #16
 8003c40:	4611      	mov	r1, r2
 8003c42:	4618      	mov	r0, r3
 8003c44:	f00b fbb8 	bl	800f3b8 <HAL_FLASHEx_Erase>
 8003c48:	4603      	mov	r3, r0
 8003c4a:	2b00      	cmp	r3, #0
 8003c4c:	d006      	beq.n	8003c5c <StartUpdateFWBlueMS+0x98>
    /* Error occurred while sector erase.
      User can add here some code to deal with this error.
      SectorError will contain the faulty sector and then to know the code error on this sector,
      user can call function 'HAL_FLASH_GetError()'
      FLASH_ErrorTypeDef errorcode = HAL_FLASH_GetError(); */
    OTA_ERROR_FUNCTION();
 8003c4e:	f44f 7295 	mov.w	r2, #298	@ 0x12a
 8003c52:	4917      	ldr	r1, [pc, #92]	@ (8003cb0 <StartUpdateFWBlueMS+0xec>)
 8003c54:	2002      	movs	r0, #2
 8003c56:	f000 fde9 	bl	800482c <STBOX1_Error_Handler>
 8003c5a:	e006      	b.n	8003c6a <StartUpdateFWBlueMS+0xa6>
  } else {
    OTA_PRINTF("End FLASH Erase %lu Pages of %dBytes\r\n",EraseInitStruct.NbPages,FLASH_PAGE_SIZE);
 8003c5c:	69fb      	ldr	r3, [r7, #28]
 8003c5e:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
 8003c62:	4619      	mov	r1, r3
 8003c64:	4813      	ldr	r0, [pc, #76]	@ (8003cb4 <StartUpdateFWBlueMS+0xf0>)
 8003c66:	f020 f879 	bl	8023d5c <iprintf>
  }

  /* Lock the Flash to disable the flash control register access (recommended
  to protect the FLASH memory against possible unwanted operation) *********/
  HAL_FLASH_Lock();
 8003c6a:	f00b fa91 	bl	800f190 <HAL_FLASH_Lock>

  /* Re-enable instruction cache */
  if (HAL_ICACHE_Enable() != HAL_OK)
 8003c6e:	f00d fd41 	bl	80116f4 <HAL_ICACHE_Enable>
 8003c72:	4603      	mov	r3, r0
 8003c74:	2b00      	cmp	r3, #0
 8003c76:	d005      	beq.n	8003c84 <StartUpdateFWBlueMS+0xc0>
  {
    STBOX1_Error_Handler(STBOX1_ERROR_FLASH,__FILE__,__LINE__);
 8003c78:	f44f 729b 	mov.w	r2, #310	@ 0x136
 8003c7c:	490c      	ldr	r1, [pc, #48]	@ (8003cb0 <StartUpdateFWBlueMS+0xec>)
 8003c7e:	2002      	movs	r0, #2
 8003c80:	f000 fdd4 	bl	800482c <STBOX1_Error_Handler>
  }

  /* Delete Fw Id saved on the bank where we will make the FOTA */
  DeleteOtherFlashBankFwId();
 8003c84:	f000 f85c 	bl	8003d40 <DeleteOtherFlashBankFwId>
}
 8003c88:	bf00      	nop
 8003c8a:	3720      	adds	r7, #32
 8003c8c:	46bd      	mov	sp, r7
 8003c8e:	bd80      	pop	{r7, pc}
 8003c90:	08027a8c 	.word	0x08027a8c
 8003c94:	2000050c 	.word	0x2000050c
 8003c98:	20000510 	.word	0x20000510
 8003c9c:	20000528 	.word	0x20000528
 8003ca0:	2000000c 	.word	0x2000000c
 8003ca4:	20000518 	.word	0x20000518
 8003ca8:	20000514 	.word	0x20000514
 8003cac:	20000590 	.word	0x20000590
 8003cb0:	0802797c 	.word	0x0802797c
 8003cb4:	08027aa0 	.word	0x08027aa0

08003cb8 <ReadFlashBanksFwId>:
 * @param uint16_t *FwId1 Firmware Id of the Current Bank
 * @param uint16_t *FwId2 Firmware Id of the Other Bank
 * @retval None
 */
void ReadFlashBanksFwId(uint16_t *FwId1,uint16_t *FwId2)
{
 8003cb8:	b4b0      	push	{r4, r5, r7}
 8003cba:	b083      	sub	sp, #12
 8003cbc:	af00      	add	r7, sp, #0
 8003cbe:	6078      	str	r0, [r7, #4]
 8003cc0:	6039      	str	r1, [r7, #0]
  /* Current Bank */
  memcpy((void *)&CurrentFwInfo,(void *)FW_ID_BOARD_NAME_BANK1,sizeof(FwId_BoardName_t));
 8003cc2:	4a1a      	ldr	r2, [pc, #104]	@ (8003d2c <ReadFlashBanksFwId+0x74>)
 8003cc4:	4b1a      	ldr	r3, [pc, #104]	@ (8003d30 <ReadFlashBanksFwId+0x78>)
 8003cc6:	4614      	mov	r4, r2
 8003cc8:	461d      	mov	r5, r3
 8003cca:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8003ccc:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8003cce:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 8003cd2:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
  if(CurrentFwInfo.FwIdMagicNum==FW_ID_BOARD_NAME_MAGIC_NUM) {
 8003cd6:	4b15      	ldr	r3, [pc, #84]	@ (8003d2c <ReadFlashBanksFwId+0x74>)
 8003cd8:	681b      	ldr	r3, [r3, #0]
 8003cda:	4a16      	ldr	r2, [pc, #88]	@ (8003d34 <ReadFlashBanksFwId+0x7c>)
 8003cdc:	4293      	cmp	r3, r2
 8003cde:	d104      	bne.n	8003cea <ReadFlashBanksFwId+0x32>
    *FwId1= CurrentFwInfo.FwId;
 8003ce0:	4b12      	ldr	r3, [pc, #72]	@ (8003d2c <ReadFlashBanksFwId+0x74>)
 8003ce2:	8a1a      	ldrh	r2, [r3, #16]
 8003ce4:	687b      	ldr	r3, [r7, #4]
 8003ce6:	801a      	strh	r2, [r3, #0]
 8003ce8:	e003      	b.n	8003cf2 <ReadFlashBanksFwId+0x3a>
  } else {
    *FwId1= OTA_OTA_FW_ID_NOT_VALID;
 8003cea:	687b      	ldr	r3, [r7, #4]
 8003cec:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 8003cf0:	801a      	strh	r2, [r3, #0]
  }

  /* Other Bank */
  memcpy((void *)&OtherBankFwInfo,(void *)FW_ID_BOARD_NAME_BANK2,sizeof(FwId_BoardName_t));
 8003cf2:	4a11      	ldr	r2, [pc, #68]	@ (8003d38 <ReadFlashBanksFwId+0x80>)
 8003cf4:	4b11      	ldr	r3, [pc, #68]	@ (8003d3c <ReadFlashBanksFwId+0x84>)
 8003cf6:	4614      	mov	r4, r2
 8003cf8:	461d      	mov	r5, r3
 8003cfa:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8003cfc:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8003cfe:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 8003d02:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
  if(OtherBankFwInfo.FwIdMagicNum==FW_ID_BOARD_NAME_MAGIC_NUM) {
 8003d06:	4b0c      	ldr	r3, [pc, #48]	@ (8003d38 <ReadFlashBanksFwId+0x80>)
 8003d08:	681b      	ldr	r3, [r3, #0]
 8003d0a:	4a0a      	ldr	r2, [pc, #40]	@ (8003d34 <ReadFlashBanksFwId+0x7c>)
 8003d0c:	4293      	cmp	r3, r2
 8003d0e:	d104      	bne.n	8003d1a <ReadFlashBanksFwId+0x62>
    *FwId2= OtherBankFwInfo.FwId;
 8003d10:	4b09      	ldr	r3, [pc, #36]	@ (8003d38 <ReadFlashBanksFwId+0x80>)
 8003d12:	8a1a      	ldrh	r2, [r3, #16]
 8003d14:	683b      	ldr	r3, [r7, #0]
 8003d16:	801a      	strh	r2, [r3, #0]
  } else {
    *FwId2= OTA_OTA_FW_ID_NOT_VALID;
  }
}
 8003d18:	e003      	b.n	8003d22 <ReadFlashBanksFwId+0x6a>
    *FwId2= OTA_OTA_FW_ID_NOT_VALID;
 8003d1a:	683b      	ldr	r3, [r7, #0]
 8003d1c:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 8003d20:	801a      	strh	r2, [r3, #0]
}
 8003d22:	bf00      	nop
 8003d24:	370c      	adds	r7, #12
 8003d26:	46bd      	mov	sp, r7
 8003d28:	bcb0      	pop	{r4, r5, r7}
 8003d2a:	4770      	bx	lr
 8003d2c:	2000052c 	.word	0x2000052c
 8003d30:	080fe000 	.word	0x080fe000
 8003d34:	deadbeef 	.word	0xdeadbeef
 8003d38:	2000054c 	.word	0x2000054c
 8003d3c:	081fe000 	.word	0x081fe000

08003d40 <DeleteOtherFlashBankFwId>:
 * @brief Function for deleting the Fw Id of the other Bank Before Fota
 * @param None
 * @retval None
 */
static void DeleteOtherFlashBankFwId(void)
{
 8003d40:	b5b0      	push	{r4, r5, r7, lr}
 8003d42:	b088      	sub	sp, #32
 8003d44:	af00      	add	r7, sp, #0
  FLASH_EraseInitTypeDef EraseInitStruct;
  uint32_t SectorError = 0;
 8003d46:	2300      	movs	r3, #0
 8003d48:	607b      	str	r3, [r7, #4]
  uint32_t LocalWritingAddress;

  /* Read the Other Bank's info */
  if(CurrentActiveBank==1) {
 8003d4a:	4b47      	ldr	r3, [pc, #284]	@ (8003e68 <DeleteOtherFlashBankFwId+0x128>)
 8003d4c:	681b      	ldr	r3, [r3, #0]
 8003d4e:	2b01      	cmp	r3, #1
 8003d50:	d102      	bne.n	8003d58 <DeleteOtherFlashBankFwId+0x18>
    EraseInitStruct.Banks  = FLASH_BANK_2;
 8003d52:	2302      	movs	r3, #2
 8003d54:	60fb      	str	r3, [r7, #12]
 8003d56:	e001      	b.n	8003d5c <DeleteOtherFlashBankFwId+0x1c>
  } else {
    EraseInitStruct.Banks  = FLASH_BANK_1;
 8003d58:	2301      	movs	r3, #1
 8003d5a:	60fb      	str	r3, [r7, #12]
  }

  memcpy((void *)&OtherBankFwInfo,(void *)FW_ID_BOARD_NAME_BANK2,sizeof(FwId_BoardName_t));
 8003d5c:	4a43      	ldr	r2, [pc, #268]	@ (8003e6c <DeleteOtherFlashBankFwId+0x12c>)
 8003d5e:	4b44      	ldr	r3, [pc, #272]	@ (8003e70 <DeleteOtherFlashBankFwId+0x130>)
 8003d60:	4614      	mov	r4, r2
 8003d62:	461d      	mov	r5, r3
 8003d64:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8003d66:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8003d68:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 8003d6c:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
  LocalWritingAddress = FW_ID_BOARD_NAME_BANK2;
 8003d70:	4b3f      	ldr	r3, [pc, #252]	@ (8003e70 <DeleteOtherFlashBankFwId+0x130>)
 8003d72:	61fb      	str	r3, [r7, #28]

  EraseInitStruct.Page        = FLASH_PAGE_NB-1;
 8003d74:	4b3f      	ldr	r3, [pc, #252]	@ (8003e74 <DeleteOtherFlashBankFwId+0x134>)
 8003d76:	881b      	ldrh	r3, [r3, #0]
 8003d78:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 8003d7c:	4293      	cmp	r3, r2
 8003d7e:	d00c      	beq.n	8003d9a <DeleteOtherFlashBankFwId+0x5a>
 8003d80:	4b3c      	ldr	r3, [pc, #240]	@ (8003e74 <DeleteOtherFlashBankFwId+0x134>)
 8003d82:	881b      	ldrh	r3, [r3, #0]
 8003d84:	2b00      	cmp	r3, #0
 8003d86:	d006      	beq.n	8003d96 <DeleteOtherFlashBankFwId+0x56>
 8003d88:	4b3a      	ldr	r3, [pc, #232]	@ (8003e74 <DeleteOtherFlashBankFwId+0x134>)
 8003d8a:	881b      	ldrh	r3, [r3, #0]
 8003d8c:	029b      	lsls	r3, r3, #10
 8003d8e:	085b      	lsrs	r3, r3, #1
 8003d90:	0b5b      	lsrs	r3, r3, #13
 8003d92:	3b01      	subs	r3, #1
 8003d94:	e002      	b.n	8003d9c <DeleteOtherFlashBankFwId+0x5c>
 8003d96:	237f      	movs	r3, #127	@ 0x7f
 8003d98:	e000      	b.n	8003d9c <DeleteOtherFlashBankFwId+0x5c>
 8003d9a:	237f      	movs	r3, #127	@ 0x7f
 8003d9c:	613b      	str	r3, [r7, #16]
  EraseInitStruct.TypeErase   = FLASH_TYPEERASE_PAGES;
 8003d9e:	2302      	movs	r3, #2
 8003da0:	60bb      	str	r3, [r7, #8]
  EraseInitStruct.NbPages     = 1;
 8003da2:	2301      	movs	r3, #1
 8003da4:	617b      	str	r3, [r7, #20]

  /* Disable instruction cache prior to internal cacheable memory update */
  if (HAL_ICACHE_Disable() != HAL_OK)
 8003da6:	f00d fcb5 	bl	8011714 <HAL_ICACHE_Disable>
 8003daa:	4603      	mov	r3, r0
 8003dac:	2b00      	cmp	r3, #0
 8003dae:	d005      	beq.n	8003dbc <DeleteOtherFlashBankFwId+0x7c>
  {
    STBOX1_Error_Handler(STBOX1_ERROR_FLASH,__FILE__,__LINE__);
 8003db0:	f44f 72b9 	mov.w	r2, #370	@ 0x172
 8003db4:	4930      	ldr	r1, [pc, #192]	@ (8003e78 <DeleteOtherFlashBankFwId+0x138>)
 8003db6:	2002      	movs	r0, #2
 8003db8:	f000 fd38 	bl	800482c <STBOX1_Error_Handler>
  }

  /* Unlock the Flash to enable the flash control register access *************/
  HAL_FLASH_Unlock();
 8003dbc:	f00b f9c6 	bl	800f14c <HAL_FLASH_Unlock>

  if(HAL_FLASHEx_Erase(&EraseInitStruct, &SectorError) != HAL_OK){
 8003dc0:	1d3a      	adds	r2, r7, #4
 8003dc2:	f107 0308 	add.w	r3, r7, #8
 8003dc6:	4611      	mov	r1, r2
 8003dc8:	4618      	mov	r0, r3
 8003dca:	f00b faf5 	bl	800f3b8 <HAL_FLASHEx_Erase>
 8003dce:	4603      	mov	r3, r0
 8003dd0:	2b00      	cmp	r3, #0
 8003dd2:	d006      	beq.n	8003de2 <DeleteOtherFlashBankFwId+0xa2>
    /* Error occurred while sector erase.
      User can add here some code to deal with this error.
      SectorError will contain the faulty sector and then to know the code error on this sector,
      user can call function 'HAL_FLASH_GetError()'
      FLASH_ErrorTypeDef errorcode = HAL_FLASH_GetError(); */
    OTA_ERROR_FUNCTION();
 8003dd4:	f44f 72bf 	mov.w	r2, #382	@ 0x17e
 8003dd8:	4927      	ldr	r1, [pc, #156]	@ (8003e78 <DeleteOtherFlashBankFwId+0x138>)
 8003dda:	2002      	movs	r0, #2
 8003ddc:	f000 fd26 	bl	800482c <STBOX1_Error_Handler>
 8003de0:	e006      	b.n	8003df0 <DeleteOtherFlashBankFwId+0xb0>
  } else {
    OTA_PRINTF("End FLASH Erase %lu Pages of %dBytes\r\n",EraseInitStruct.NbPages,FLASH_PAGE_SIZE);
 8003de2:	697b      	ldr	r3, [r7, #20]
 8003de4:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
 8003de8:	4619      	mov	r1, r3
 8003dea:	4824      	ldr	r0, [pc, #144]	@ (8003e7c <DeleteOtherFlashBankFwId+0x13c>)
 8003dec:	f01f ffb6 	bl	8023d5c <iprintf>
  }

  /* Save the updated Bank's info */
  {
    uint32_t BankInfoAddress = (uint32_t)&OtherBankFwInfo;
 8003df0:	4b1e      	ldr	r3, [pc, #120]	@ (8003e6c <DeleteOtherFlashBankFwId+0x12c>)
 8003df2:	61bb      	str	r3, [r7, #24]

    /* Change the Fw Id to Not Valid */
    OtherBankFwInfo.FwIdMagicNum = 0x00;
 8003df4:	4b1d      	ldr	r3, [pc, #116]	@ (8003e6c <DeleteOtherFlashBankFwId+0x12c>)
 8003df6:	2200      	movs	r2, #0
 8003df8:	601a      	str	r2, [r3, #0]
    OtherBankFwInfo.FwId = OTA_OTA_FW_ID_NOT_VALID;
 8003dfa:	4b1c      	ldr	r3, [pc, #112]	@ (8003e6c <DeleteOtherFlashBankFwId+0x12c>)
 8003dfc:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 8003e00:	821a      	strh	r2, [r3, #16]
    /* We Don't Delete any Eventual Board Name Saved */

    if(HAL_FLASH_Program(FLASH_TYPEPROGRAM_QUADWORD, LocalWritingAddress,BankInfoAddress)==HAL_OK) {
 8003e02:	69ba      	ldr	r2, [r7, #24]
 8003e04:	69f9      	ldr	r1, [r7, #28]
 8003e06:	2001      	movs	r0, #1
 8003e08:	f00b f956 	bl	800f0b8 <HAL_FLASH_Program>
 8003e0c:	4603      	mov	r3, r0
 8003e0e:	2b00      	cmp	r3, #0
 8003e10:	d112      	bne.n	8003e38 <DeleteOtherFlashBankFwId+0xf8>
      if(HAL_FLASH_Program(FLASH_TYPEPROGRAM_QUADWORD, LocalWritingAddress+16,BankInfoAddress+16)==HAL_OK) {
 8003e12:	69fb      	ldr	r3, [r7, #28]
 8003e14:	f103 0110 	add.w	r1, r3, #16
 8003e18:	69bb      	ldr	r3, [r7, #24]
 8003e1a:	3310      	adds	r3, #16
 8003e1c:	461a      	mov	r2, r3
 8003e1e:	2001      	movs	r0, #1
 8003e20:	f00b f94a 	bl	800f0b8 <HAL_FLASH_Program>
 8003e24:	4603      	mov	r3, r0
 8003e26:	2b00      	cmp	r3, #0
 8003e28:	d00c      	beq.n	8003e44 <DeleteOtherFlashBankFwId+0x104>
      } else {
        OTA_ERROR_FUNCTION();
 8003e2a:	f240 128f 	movw	r2, #399	@ 0x18f
 8003e2e:	4912      	ldr	r1, [pc, #72]	@ (8003e78 <DeleteOtherFlashBankFwId+0x138>)
 8003e30:	2002      	movs	r0, #2
 8003e32:	f000 fcfb 	bl	800482c <STBOX1_Error_Handler>
 8003e36:	e005      	b.n	8003e44 <DeleteOtherFlashBankFwId+0x104>
      }
    } else {
      OTA_ERROR_FUNCTION();
 8003e38:	f44f 72c9 	mov.w	r2, #402	@ 0x192
 8003e3c:	490e      	ldr	r1, [pc, #56]	@ (8003e78 <DeleteOtherFlashBankFwId+0x138>)
 8003e3e:	2002      	movs	r0, #2
 8003e40:	f000 fcf4 	bl	800482c <STBOX1_Error_Handler>
    }
  }
  /* Lock the Flash to disable the flash control register access (recommended
  to protect the FLASH memory against possible unwanted operation) *********/
  HAL_FLASH_Lock();
 8003e44:	f00b f9a4 	bl	800f190 <HAL_FLASH_Lock>

  /* Re-enable instruction cache */
  if (HAL_ICACHE_Enable() != HAL_OK)
 8003e48:	f00d fc54 	bl	80116f4 <HAL_ICACHE_Enable>
 8003e4c:	4603      	mov	r3, r0
 8003e4e:	2b00      	cmp	r3, #0
 8003e50:	d005      	beq.n	8003e5e <DeleteOtherFlashBankFwId+0x11e>
  {
    STBOX1_Error_Handler(STBOX1_ERROR_FLASH,__FILE__,__LINE__);
 8003e52:	f44f 72ce 	mov.w	r2, #412	@ 0x19c
 8003e56:	4908      	ldr	r1, [pc, #32]	@ (8003e78 <DeleteOtherFlashBankFwId+0x138>)
 8003e58:	2002      	movs	r0, #2
 8003e5a:	f000 fce7 	bl	800482c <STBOX1_Error_Handler>
  }
}
 8003e5e:	bf00      	nop
 8003e60:	3720      	adds	r7, #32
 8003e62:	46bd      	mov	sp, r7
 8003e64:	bdb0      	pop	{r4, r5, r7, pc}
 8003e66:	bf00      	nop
 8003e68:	20000590 	.word	0x20000590
 8003e6c:	2000054c 	.word	0x2000054c
 8003e70:	081fe000 	.word	0x081fe000
 8003e74:	0bfa07a0 	.word	0x0bfa07a0
 8003e78:	0802797c 	.word	0x0802797c
 8003e7c:	08027aa0 	.word	0x08027aa0

08003e80 <UpdateCurrFlashBankFwIdBoardName>:
 * @param uint16_t CurrFwId Current FwId
 * @param uint8_t *NewName Current Board's Name (if it's == NULL don't change it)
 * @retval None
 */
void UpdateCurrFlashBankFwIdBoardName(uint16_t FwId, uint8_t *NewName)
{
 8003e80:	b5b0      	push	{r4, r5, r7, lr}
 8003e82:	b090      	sub	sp, #64	@ 0x40
 8003e84:	af00      	add	r7, sp, #0
 8003e86:	4603      	mov	r3, r0
 8003e88:	6039      	str	r1, [r7, #0]
 8003e8a:	80fb      	strh	r3, [r7, #6]
  /* Read the Actual Banks' Info */
  memcpy((void *)&CurrentFwInfo,(void *)FW_ID_BOARD_NAME_BANK1,sizeof(FwId_BoardName_t));
 8003e8c:	4aab      	ldr	r2, [pc, #684]	@ (800413c <UpdateCurrFlashBankFwIdBoardName+0x2bc>)
 8003e8e:	4bac      	ldr	r3, [pc, #688]	@ (8004140 <UpdateCurrFlashBankFwIdBoardName+0x2c0>)
 8003e90:	4614      	mov	r4, r2
 8003e92:	461d      	mov	r5, r3
 8003e94:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8003e96:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8003e98:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 8003e9c:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}

  if(NewName!=NULL) {
 8003ea0:	683b      	ldr	r3, [r7, #0]
 8003ea2:	2b00      	cmp	r3, #0
 8003ea4:	f000 80f7 	beq.w	8004096 <UpdateCurrFlashBankFwIdBoardName+0x216>
    /* We need to change both the Banks' info */
    FLASH_EraseInitTypeDef EraseInitStruct;
    uint32_t SectorError = 0;
 8003ea8:	2300      	movs	r3, #0
 8003eaa:	61fb      	str	r3, [r7, #28]
    uint32_t LocalWritingAddress;
    uint32_t BankInfoAddress;

    /* Read the Other Banks' Info */
    memcpy((void *)&OtherBankFwInfo,(void *)FW_ID_BOARD_NAME_BANK2,sizeof(FwId_BoardName_t));
 8003eac:	4aa5      	ldr	r2, [pc, #660]	@ (8004144 <UpdateCurrFlashBankFwIdBoardName+0x2c4>)
 8003eae:	4ba6      	ldr	r3, [pc, #664]	@ (8004148 <UpdateCurrFlashBankFwIdBoardName+0x2c8>)
 8003eb0:	4614      	mov	r4, r2
 8003eb2:	461d      	mov	r5, r3
 8003eb4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8003eb6:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8003eb8:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 8003ebc:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}

    /* Updated the Board Name and the Fw Id for the current Bank */
    CurrentFwInfo.BoardNameMagicNum = FW_ID_BOARD_NAME_MAGIC_NUM;
 8003ec0:	4b9e      	ldr	r3, [pc, #632]	@ (800413c <UpdateCurrFlashBankFwIdBoardName+0x2bc>)
 8003ec2:	4aa2      	ldr	r2, [pc, #648]	@ (800414c <UpdateCurrFlashBankFwIdBoardName+0x2cc>)
 8003ec4:	605a      	str	r2, [r3, #4]
    memcpy(CurrentFwInfo.BoardName,NewName,7);
 8003ec6:	2207      	movs	r2, #7
 8003ec8:	6839      	ldr	r1, [r7, #0]
 8003eca:	48a1      	ldr	r0, [pc, #644]	@ (8004150 <UpdateCurrFlashBankFwIdBoardName+0x2d0>)
 8003ecc:	f020 f98f 	bl	80241ee <memcpy>
    CurrentFwInfo.BoardName[7] ='\0';
 8003ed0:	4b9a      	ldr	r3, [pc, #616]	@ (800413c <UpdateCurrFlashBankFwIdBoardName+0x2bc>)
 8003ed2:	2200      	movs	r2, #0
 8003ed4:	73da      	strb	r2, [r3, #15]
    CurrentFwInfo.FwId = FwId;
 8003ed6:	4a99      	ldr	r2, [pc, #612]	@ (800413c <UpdateCurrFlashBankFwIdBoardName+0x2bc>)
 8003ed8:	88fb      	ldrh	r3, [r7, #6]
 8003eda:	8213      	strh	r3, [r2, #16]
    CurrentFwInfo.FwIdMagicNum = FW_ID_BOARD_NAME_MAGIC_NUM;
 8003edc:	4b97      	ldr	r3, [pc, #604]	@ (800413c <UpdateCurrFlashBankFwIdBoardName+0x2bc>)
 8003ede:	4a9b      	ldr	r2, [pc, #620]	@ (800414c <UpdateCurrFlashBankFwIdBoardName+0x2cc>)
 8003ee0:	601a      	str	r2, [r3, #0]

    /* Update the Board Name also for Other Bank */
    OtherBankFwInfo.BoardNameMagicNum = FW_ID_BOARD_NAME_MAGIC_NUM;
 8003ee2:	4b98      	ldr	r3, [pc, #608]	@ (8004144 <UpdateCurrFlashBankFwIdBoardName+0x2c4>)
 8003ee4:	4a99      	ldr	r2, [pc, #612]	@ (800414c <UpdateCurrFlashBankFwIdBoardName+0x2cc>)
 8003ee6:	605a      	str	r2, [r3, #4]
    memcpy(OtherBankFwInfo.BoardName,NewName,7);
 8003ee8:	2207      	movs	r2, #7
 8003eea:	6839      	ldr	r1, [r7, #0]
 8003eec:	4899      	ldr	r0, [pc, #612]	@ (8004154 <UpdateCurrFlashBankFwIdBoardName+0x2d4>)
 8003eee:	f020 f97e 	bl	80241ee <memcpy>
    OtherBankFwInfo.BoardName[7] ='\0';
 8003ef2:	4b94      	ldr	r3, [pc, #592]	@ (8004144 <UpdateCurrFlashBankFwIdBoardName+0x2c4>)
 8003ef4:	2200      	movs	r2, #0
 8003ef6:	73da      	strb	r2, [r3, #15]
    /* We don't change any Eventual FwId Present on the Other Banks */

    /* Disable instruction cache prior to internal cacheable memory update */
    if (HAL_ICACHE_Disable() != HAL_OK)
 8003ef8:	f00d fc0c 	bl	8011714 <HAL_ICACHE_Disable>
 8003efc:	4603      	mov	r3, r0
 8003efe:	2b00      	cmp	r3, #0
 8003f00:	d005      	beq.n	8003f0e <UpdateCurrFlashBankFwIdBoardName+0x8e>
    {
      STBOX1_Error_Handler(STBOX1_ERROR_FLASH,__FILE__,__LINE__);
 8003f02:	f240 12c5 	movw	r2, #453	@ 0x1c5
 8003f06:	4994      	ldr	r1, [pc, #592]	@ (8004158 <UpdateCurrFlashBankFwIdBoardName+0x2d8>)
 8003f08:	2002      	movs	r0, #2
 8003f0a:	f000 fc8f 	bl	800482c <STBOX1_Error_Handler>
    }

    /* Unlock the Flash to enable the flash control register access *************/
    HAL_FLASH_Unlock();
 8003f0e:	f00b f91d 	bl	800f14c <HAL_FLASH_Unlock>

    EraseInitStruct.Page        = FLASH_PAGE_NB-1;
 8003f12:	4b92      	ldr	r3, [pc, #584]	@ (800415c <UpdateCurrFlashBankFwIdBoardName+0x2dc>)
 8003f14:	881b      	ldrh	r3, [r3, #0]
 8003f16:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 8003f1a:	4293      	cmp	r3, r2
 8003f1c:	d00c      	beq.n	8003f38 <UpdateCurrFlashBankFwIdBoardName+0xb8>
 8003f1e:	4b8f      	ldr	r3, [pc, #572]	@ (800415c <UpdateCurrFlashBankFwIdBoardName+0x2dc>)
 8003f20:	881b      	ldrh	r3, [r3, #0]
 8003f22:	2b00      	cmp	r3, #0
 8003f24:	d006      	beq.n	8003f34 <UpdateCurrFlashBankFwIdBoardName+0xb4>
 8003f26:	4b8d      	ldr	r3, [pc, #564]	@ (800415c <UpdateCurrFlashBankFwIdBoardName+0x2dc>)
 8003f28:	881b      	ldrh	r3, [r3, #0]
 8003f2a:	029b      	lsls	r3, r3, #10
 8003f2c:	085b      	lsrs	r3, r3, #1
 8003f2e:	0b5b      	lsrs	r3, r3, #13
 8003f30:	3b01      	subs	r3, #1
 8003f32:	e002      	b.n	8003f3a <UpdateCurrFlashBankFwIdBoardName+0xba>
 8003f34:	237f      	movs	r3, #127	@ 0x7f
 8003f36:	e000      	b.n	8003f3a <UpdateCurrFlashBankFwIdBoardName+0xba>
 8003f38:	237f      	movs	r3, #127	@ 0x7f
 8003f3a:	62bb      	str	r3, [r7, #40]	@ 0x28
    EraseInitStruct.TypeErase   = FLASH_TYPEERASE_PAGES;
 8003f3c:	2302      	movs	r3, #2
 8003f3e:	623b      	str	r3, [r7, #32]
    EraseInitStruct.NbPages     = 1;
 8003f40:	2301      	movs	r3, #1
 8003f42:	62fb      	str	r3, [r7, #44]	@ 0x2c

    OTA_PRINTF("Start FLASH Erase Current Bank\r\n");
 8003f44:	4886      	ldr	r0, [pc, #536]	@ (8004160 <UpdateCurrFlashBankFwIdBoardName+0x2e0>)
 8003f46:	f01f ff71 	bl	8023e2c <puts>

    if(CurrentActiveBank==1) {
 8003f4a:	4b86      	ldr	r3, [pc, #536]	@ (8004164 <UpdateCurrFlashBankFwIdBoardName+0x2e4>)
 8003f4c:	681b      	ldr	r3, [r3, #0]
 8003f4e:	2b01      	cmp	r3, #1
 8003f50:	d102      	bne.n	8003f58 <UpdateCurrFlashBankFwIdBoardName+0xd8>
      EraseInitStruct.Banks  = FLASH_BANK_1;
 8003f52:	2301      	movs	r3, #1
 8003f54:	627b      	str	r3, [r7, #36]	@ 0x24
 8003f56:	e001      	b.n	8003f5c <UpdateCurrFlashBankFwIdBoardName+0xdc>
    } else {
      EraseInitStruct.Banks  = FLASH_BANK_2;
 8003f58:	2302      	movs	r3, #2
 8003f5a:	627b      	str	r3, [r7, #36]	@ 0x24
    }

    if(HAL_FLASHEx_Erase(&EraseInitStruct, &SectorError) != HAL_OK){
 8003f5c:	f107 021c 	add.w	r2, r7, #28
 8003f60:	f107 0320 	add.w	r3, r7, #32
 8003f64:	4611      	mov	r1, r2
 8003f66:	4618      	mov	r0, r3
 8003f68:	f00b fa26 	bl	800f3b8 <HAL_FLASHEx_Erase>
 8003f6c:	4603      	mov	r3, r0
 8003f6e:	2b00      	cmp	r3, #0
 8003f70:	d006      	beq.n	8003f80 <UpdateCurrFlashBankFwIdBoardName+0x100>
      /* Error occurred while sector erase.
        User can add here some code to deal with this error.
        SectorError will contain the faulty sector and then to know the code error on this sector,
        user can call function 'HAL_FLASH_GetError()'
        FLASH_ErrorTypeDef errorcode = HAL_FLASH_GetError(); */
      OTA_ERROR_FUNCTION();
 8003f72:	f240 12dd 	movw	r2, #477	@ 0x1dd
 8003f76:	4978      	ldr	r1, [pc, #480]	@ (8004158 <UpdateCurrFlashBankFwIdBoardName+0x2d8>)
 8003f78:	2002      	movs	r0, #2
 8003f7a:	f000 fc57 	bl	800482c <STBOX1_Error_Handler>
 8003f7e:	e006      	b.n	8003f8e <UpdateCurrFlashBankFwIdBoardName+0x10e>
    } else {
      OTA_PRINTF("End FLASH Erase %lu Pages of %dBytes\r\n",EraseInitStruct.NbPages,FLASH_PAGE_SIZE);
 8003f80:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8003f82:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
 8003f86:	4619      	mov	r1, r3
 8003f88:	4877      	ldr	r0, [pc, #476]	@ (8004168 <UpdateCurrFlashBankFwIdBoardName+0x2e8>)
 8003f8a:	f01f fee7 	bl	8023d5c <iprintf>
    }

    OTA_PRINTF("Update Current Bank Info\r\n");
 8003f8e:	4877      	ldr	r0, [pc, #476]	@ (800416c <UpdateCurrFlashBankFwIdBoardName+0x2ec>)
 8003f90:	f01f ff4c 	bl	8023e2c <puts>

    LocalWritingAddress = FW_ID_BOARD_NAME_BANK1;
 8003f94:	4b6a      	ldr	r3, [pc, #424]	@ (8004140 <UpdateCurrFlashBankFwIdBoardName+0x2c0>)
 8003f96:	637b      	str	r3, [r7, #52]	@ 0x34
    BankInfoAddress = (uint32_t)&CurrentFwInfo;
 8003f98:	4b68      	ldr	r3, [pc, #416]	@ (800413c <UpdateCurrFlashBankFwIdBoardName+0x2bc>)
 8003f9a:	633b      	str	r3, [r7, #48]	@ 0x30
    if(HAL_FLASH_Program(FLASH_TYPEPROGRAM_QUADWORD, LocalWritingAddress,BankInfoAddress)==HAL_OK) {
 8003f9c:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8003f9e:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 8003fa0:	2001      	movs	r0, #1
 8003fa2:	f00b f889 	bl	800f0b8 <HAL_FLASH_Program>
 8003fa6:	4603      	mov	r3, r0
 8003fa8:	2b00      	cmp	r3, #0
 8003faa:	d112      	bne.n	8003fd2 <UpdateCurrFlashBankFwIdBoardName+0x152>
      if(HAL_FLASH_Program(FLASH_TYPEPROGRAM_QUADWORD, LocalWritingAddress+16,BankInfoAddress+16)==HAL_OK) {
 8003fac:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8003fae:	f103 0110 	add.w	r1, r3, #16
 8003fb2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8003fb4:	3310      	adds	r3, #16
 8003fb6:	461a      	mov	r2, r3
 8003fb8:	2001      	movs	r0, #1
 8003fba:	f00b f87d 	bl	800f0b8 <HAL_FLASH_Program>
 8003fbe:	4603      	mov	r3, r0
 8003fc0:	2b00      	cmp	r3, #0
 8003fc2:	d00c      	beq.n	8003fde <UpdateCurrFlashBankFwIdBoardName+0x15e>
      } else {
        OTA_ERROR_FUNCTION();
 8003fc4:	f240 12e9 	movw	r2, #489	@ 0x1e9
 8003fc8:	4963      	ldr	r1, [pc, #396]	@ (8004158 <UpdateCurrFlashBankFwIdBoardName+0x2d8>)
 8003fca:	2002      	movs	r0, #2
 8003fcc:	f000 fc2e 	bl	800482c <STBOX1_Error_Handler>
 8003fd0:	e005      	b.n	8003fde <UpdateCurrFlashBankFwIdBoardName+0x15e>
      }
    } else {
      OTA_ERROR_FUNCTION();
 8003fd2:	f44f 72f6 	mov.w	r2, #492	@ 0x1ec
 8003fd6:	4960      	ldr	r1, [pc, #384]	@ (8004158 <UpdateCurrFlashBankFwIdBoardName+0x2d8>)
 8003fd8:	2002      	movs	r0, #2
 8003fda:	f000 fc27 	bl	800482c <STBOX1_Error_Handler>
    }

    OTA_PRINTF("Start FLASH Erase Other Bank\r\n");
 8003fde:	4864      	ldr	r0, [pc, #400]	@ (8004170 <UpdateCurrFlashBankFwIdBoardName+0x2f0>)
 8003fe0:	f01f ff24 	bl	8023e2c <puts>

    if(CurrentActiveBank==1) {
 8003fe4:	4b5f      	ldr	r3, [pc, #380]	@ (8004164 <UpdateCurrFlashBankFwIdBoardName+0x2e4>)
 8003fe6:	681b      	ldr	r3, [r3, #0]
 8003fe8:	2b01      	cmp	r3, #1
 8003fea:	d102      	bne.n	8003ff2 <UpdateCurrFlashBankFwIdBoardName+0x172>
      EraseInitStruct.Banks  = FLASH_BANK_2;
 8003fec:	2302      	movs	r3, #2
 8003fee:	627b      	str	r3, [r7, #36]	@ 0x24
 8003ff0:	e001      	b.n	8003ff6 <UpdateCurrFlashBankFwIdBoardName+0x176>
    } else {
      EraseInitStruct.Banks  = FLASH_BANK_1;
 8003ff2:	2301      	movs	r3, #1
 8003ff4:	627b      	str	r3, [r7, #36]	@ 0x24
    }

    if(HAL_FLASHEx_Erase(&EraseInitStruct, &SectorError) != HAL_OK){
 8003ff6:	f107 021c 	add.w	r2, r7, #28
 8003ffa:	f107 0320 	add.w	r3, r7, #32
 8003ffe:	4611      	mov	r1, r2
 8004000:	4618      	mov	r0, r3
 8004002:	f00b f9d9 	bl	800f3b8 <HAL_FLASHEx_Erase>
 8004006:	4603      	mov	r3, r0
 8004008:	2b00      	cmp	r3, #0
 800400a:	d006      	beq.n	800401a <UpdateCurrFlashBankFwIdBoardName+0x19a>
      /* Error occurred while sector erase.
        User can add here some code to deal with this error.
        SectorError will contain the faulty sector and then to know the code error on this sector,
        user can call function 'HAL_FLASH_GetError()'
        FLASH_ErrorTypeDef errorcode = HAL_FLASH_GetError(); */
      OTA_ERROR_FUNCTION();
 800400c:	f240 12fd 	movw	r2, #509	@ 0x1fd
 8004010:	4951      	ldr	r1, [pc, #324]	@ (8004158 <UpdateCurrFlashBankFwIdBoardName+0x2d8>)
 8004012:	2002      	movs	r0, #2
 8004014:	f000 fc0a 	bl	800482c <STBOX1_Error_Handler>
 8004018:	e006      	b.n	8004028 <UpdateCurrFlashBankFwIdBoardName+0x1a8>
    } else {
      OTA_PRINTF("End FLASH Erase %lu Pages of %dBytes\r\n",EraseInitStruct.NbPages,FLASH_PAGE_SIZE);
 800401a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800401c:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
 8004020:	4619      	mov	r1, r3
 8004022:	4851      	ldr	r0, [pc, #324]	@ (8004168 <UpdateCurrFlashBankFwIdBoardName+0x2e8>)
 8004024:	f01f fe9a 	bl	8023d5c <iprintf>
    }

    OTA_PRINTF("Update Other Bank Info\r\n");
 8004028:	4852      	ldr	r0, [pc, #328]	@ (8004174 <UpdateCurrFlashBankFwIdBoardName+0x2f4>)
 800402a:	f01f feff 	bl	8023e2c <puts>

    LocalWritingAddress = FW_ID_BOARD_NAME_BANK2;
 800402e:	4b46      	ldr	r3, [pc, #280]	@ (8004148 <UpdateCurrFlashBankFwIdBoardName+0x2c8>)
 8004030:	637b      	str	r3, [r7, #52]	@ 0x34
    BankInfoAddress = (uint32_t)&OtherBankFwInfo;
 8004032:	4b44      	ldr	r3, [pc, #272]	@ (8004144 <UpdateCurrFlashBankFwIdBoardName+0x2c4>)
 8004034:	633b      	str	r3, [r7, #48]	@ 0x30
    if(HAL_FLASH_Program(FLASH_TYPEPROGRAM_QUADWORD, LocalWritingAddress,BankInfoAddress)==HAL_OK) {
 8004036:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8004038:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 800403a:	2001      	movs	r0, #1
 800403c:	f00b f83c 	bl	800f0b8 <HAL_FLASH_Program>
 8004040:	4603      	mov	r3, r0
 8004042:	2b00      	cmp	r3, #0
 8004044:	d112      	bne.n	800406c <UpdateCurrFlashBankFwIdBoardName+0x1ec>
      if(HAL_FLASH_Program(FLASH_TYPEPROGRAM_QUADWORD, LocalWritingAddress+16,BankInfoAddress+16)==HAL_OK) {
 8004046:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8004048:	f103 0110 	add.w	r1, r3, #16
 800404c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800404e:	3310      	adds	r3, #16
 8004050:	461a      	mov	r2, r3
 8004052:	2001      	movs	r0, #1
 8004054:	f00b f830 	bl	800f0b8 <HAL_FLASH_Program>
 8004058:	4603      	mov	r3, r0
 800405a:	2b00      	cmp	r3, #0
 800405c:	d00c      	beq.n	8004078 <UpdateCurrFlashBankFwIdBoardName+0x1f8>
      } else {
        OTA_ERROR_FUNCTION();
 800405e:	f240 2209 	movw	r2, #521	@ 0x209
 8004062:	493d      	ldr	r1, [pc, #244]	@ (8004158 <UpdateCurrFlashBankFwIdBoardName+0x2d8>)
 8004064:	2002      	movs	r0, #2
 8004066:	f000 fbe1 	bl	800482c <STBOX1_Error_Handler>
 800406a:	e005      	b.n	8004078 <UpdateCurrFlashBankFwIdBoardName+0x1f8>
      }
    } else {
      OTA_ERROR_FUNCTION();
 800406c:	f44f 7203 	mov.w	r2, #524	@ 0x20c
 8004070:	4939      	ldr	r1, [pc, #228]	@ (8004158 <UpdateCurrFlashBankFwIdBoardName+0x2d8>)
 8004072:	2002      	movs	r0, #2
 8004074:	f000 fbda 	bl	800482c <STBOX1_Error_Handler>
    }

    /* Lock the Flash to disable the flash control register access (recommended
    to protect the FLASH memory against possible unwanted operation) *********/
    HAL_FLASH_Lock();
 8004078:	f00b f88a 	bl	800f190 <HAL_FLASH_Lock>

    /* Re-enable instruction cache */
    if (HAL_ICACHE_Enable() != HAL_OK)
 800407c:	f00d fb3a 	bl	80116f4 <HAL_ICACHE_Enable>
 8004080:	4603      	mov	r3, r0
 8004082:	2b00      	cmp	r3, #0
 8004084:	f000 80b4 	beq.w	80041f0 <UpdateCurrFlashBankFwIdBoardName+0x370>
    {
      STBOX1_Error_Handler(STBOX1_ERROR_FLASH,__FILE__,__LINE__);
 8004088:	f240 2216 	movw	r2, #534	@ 0x216
 800408c:	4932      	ldr	r1, [pc, #200]	@ (8004158 <UpdateCurrFlashBankFwIdBoardName+0x2d8>)
 800408e:	2002      	movs	r0, #2
 8004090:	f000 fbcc 	bl	800482c <STBOX1_Error_Handler>
    if (HAL_ICACHE_Enable() != HAL_OK)
    {
      STBOX1_Error_Handler(STBOX1_ERROR_FLASH,__FILE__,__LINE__);
    }
  }
}
 8004094:	e0ac      	b.n	80041f0 <UpdateCurrFlashBankFwIdBoardName+0x370>
  } else if(CurrentFwInfo.FwId!=FwId) {
 8004096:	4b29      	ldr	r3, [pc, #164]	@ (800413c <UpdateCurrFlashBankFwIdBoardName+0x2bc>)
 8004098:	8a1b      	ldrh	r3, [r3, #16]
 800409a:	88fa      	ldrh	r2, [r7, #6]
 800409c:	429a      	cmp	r2, r3
 800409e:	f000 80a7 	beq.w	80041f0 <UpdateCurrFlashBankFwIdBoardName+0x370>
    uint32_t SectorError = 0;
 80040a2:	2300      	movs	r3, #0
 80040a4:	60bb      	str	r3, [r7, #8]
    CurrentFwInfo.FwId = FwId;
 80040a6:	4a25      	ldr	r2, [pc, #148]	@ (800413c <UpdateCurrFlashBankFwIdBoardName+0x2bc>)
 80040a8:	88fb      	ldrh	r3, [r7, #6]
 80040aa:	8213      	strh	r3, [r2, #16]
    CurrentFwInfo.FwIdMagicNum = FW_ID_BOARD_NAME_MAGIC_NUM;
 80040ac:	4b23      	ldr	r3, [pc, #140]	@ (800413c <UpdateCurrFlashBankFwIdBoardName+0x2bc>)
 80040ae:	4a27      	ldr	r2, [pc, #156]	@ (800414c <UpdateCurrFlashBankFwIdBoardName+0x2cc>)
 80040b0:	601a      	str	r2, [r3, #0]
    if (HAL_ICACHE_Disable() != HAL_OK)
 80040b2:	f00d fb2f 	bl	8011714 <HAL_ICACHE_Disable>
 80040b6:	4603      	mov	r3, r0
 80040b8:	2b00      	cmp	r3, #0
 80040ba:	d005      	beq.n	80040c8 <UpdateCurrFlashBankFwIdBoardName+0x248>
      STBOX1_Error_Handler(STBOX1_ERROR_FLASH,__FILE__,__LINE__);
 80040bc:	f240 2227 	movw	r2, #551	@ 0x227
 80040c0:	4925      	ldr	r1, [pc, #148]	@ (8004158 <UpdateCurrFlashBankFwIdBoardName+0x2d8>)
 80040c2:	2002      	movs	r0, #2
 80040c4:	f000 fbb2 	bl	800482c <STBOX1_Error_Handler>
    HAL_FLASH_Unlock();
 80040c8:	f00b f840 	bl	800f14c <HAL_FLASH_Unlock>
    EraseInitStruct.Page        = FLASH_PAGE_NB-1;
 80040cc:	4b23      	ldr	r3, [pc, #140]	@ (800415c <UpdateCurrFlashBankFwIdBoardName+0x2dc>)
 80040ce:	881b      	ldrh	r3, [r3, #0]
 80040d0:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 80040d4:	4293      	cmp	r3, r2
 80040d6:	d00c      	beq.n	80040f2 <UpdateCurrFlashBankFwIdBoardName+0x272>
 80040d8:	4b20      	ldr	r3, [pc, #128]	@ (800415c <UpdateCurrFlashBankFwIdBoardName+0x2dc>)
 80040da:	881b      	ldrh	r3, [r3, #0]
 80040dc:	2b00      	cmp	r3, #0
 80040de:	d006      	beq.n	80040ee <UpdateCurrFlashBankFwIdBoardName+0x26e>
 80040e0:	4b1e      	ldr	r3, [pc, #120]	@ (800415c <UpdateCurrFlashBankFwIdBoardName+0x2dc>)
 80040e2:	881b      	ldrh	r3, [r3, #0]
 80040e4:	029b      	lsls	r3, r3, #10
 80040e6:	085b      	lsrs	r3, r3, #1
 80040e8:	0b5b      	lsrs	r3, r3, #13
 80040ea:	3b01      	subs	r3, #1
 80040ec:	e002      	b.n	80040f4 <UpdateCurrFlashBankFwIdBoardName+0x274>
 80040ee:	237f      	movs	r3, #127	@ 0x7f
 80040f0:	e000      	b.n	80040f4 <UpdateCurrFlashBankFwIdBoardName+0x274>
 80040f2:	237f      	movs	r3, #127	@ 0x7f
 80040f4:	617b      	str	r3, [r7, #20]
    EraseInitStruct.TypeErase   = FLASH_TYPEERASE_PAGES;
 80040f6:	2302      	movs	r3, #2
 80040f8:	60fb      	str	r3, [r7, #12]
    EraseInitStruct.NbPages     = 1;
 80040fa:	2301      	movs	r3, #1
 80040fc:	61bb      	str	r3, [r7, #24]
    OTA_PRINTF("Start FLASH Erase Current Bank\r\n");
 80040fe:	4818      	ldr	r0, [pc, #96]	@ (8004160 <UpdateCurrFlashBankFwIdBoardName+0x2e0>)
 8004100:	f01f fe94 	bl	8023e2c <puts>
    if(CurrentActiveBank==1) {
 8004104:	4b17      	ldr	r3, [pc, #92]	@ (8004164 <UpdateCurrFlashBankFwIdBoardName+0x2e4>)
 8004106:	681b      	ldr	r3, [r3, #0]
 8004108:	2b01      	cmp	r3, #1
 800410a:	d102      	bne.n	8004112 <UpdateCurrFlashBankFwIdBoardName+0x292>
      EraseInitStruct.Banks  = FLASH_BANK_1;
 800410c:	2301      	movs	r3, #1
 800410e:	613b      	str	r3, [r7, #16]
 8004110:	e001      	b.n	8004116 <UpdateCurrFlashBankFwIdBoardName+0x296>
      EraseInitStruct.Banks  = FLASH_BANK_2;
 8004112:	2302      	movs	r3, #2
 8004114:	613b      	str	r3, [r7, #16]
    if(HAL_FLASHEx_Erase(&EraseInitStruct, &SectorError) != HAL_OK){
 8004116:	f107 0208 	add.w	r2, r7, #8
 800411a:	f107 030c 	add.w	r3, r7, #12
 800411e:	4611      	mov	r1, r2
 8004120:	4618      	mov	r0, r3
 8004122:	f00b f949 	bl	800f3b8 <HAL_FLASHEx_Erase>
 8004126:	4603      	mov	r3, r0
 8004128:	2b00      	cmp	r3, #0
 800412a:	d025      	beq.n	8004178 <UpdateCurrFlashBankFwIdBoardName+0x2f8>
      OTA_ERROR_FUNCTION();
 800412c:	f240 223f 	movw	r2, #575	@ 0x23f
 8004130:	4909      	ldr	r1, [pc, #36]	@ (8004158 <UpdateCurrFlashBankFwIdBoardName+0x2d8>)
 8004132:	2002      	movs	r0, #2
 8004134:	f000 fb7a 	bl	800482c <STBOX1_Error_Handler>
 8004138:	e025      	b.n	8004186 <UpdateCurrFlashBankFwIdBoardName+0x306>
 800413a:	bf00      	nop
 800413c:	2000052c 	.word	0x2000052c
 8004140:	080fe000 	.word	0x080fe000
 8004144:	2000054c 	.word	0x2000054c
 8004148:	081fe000 	.word	0x081fe000
 800414c:	deadbeef 	.word	0xdeadbeef
 8004150:	20000534 	.word	0x20000534
 8004154:	20000554 	.word	0x20000554
 8004158:	0802797c 	.word	0x0802797c
 800415c:	0bfa07a0 	.word	0x0bfa07a0
 8004160:	08027ac8 	.word	0x08027ac8
 8004164:	20000590 	.word	0x20000590
 8004168:	08027aa0 	.word	0x08027aa0
 800416c:	08027ae8 	.word	0x08027ae8
 8004170:	08027b04 	.word	0x08027b04
 8004174:	08027b24 	.word	0x08027b24
      OTA_PRINTF("End FLASH Erase %lu Pages of %dBytes\r\n",EraseInitStruct.NbPages,FLASH_PAGE_SIZE);
 8004178:	69bb      	ldr	r3, [r7, #24]
 800417a:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
 800417e:	4619      	mov	r1, r3
 8004180:	481d      	ldr	r0, [pc, #116]	@ (80041f8 <UpdateCurrFlashBankFwIdBoardName+0x378>)
 8004182:	f01f fdeb 	bl	8023d5c <iprintf>
    OTA_PRINTF("Update Current Bank Info\r\n");
 8004186:	481d      	ldr	r0, [pc, #116]	@ (80041fc <UpdateCurrFlashBankFwIdBoardName+0x37c>)
 8004188:	f01f fe50 	bl	8023e2c <puts>
    LocalWritingAddress = FW_ID_BOARD_NAME_BANK1;
 800418c:	4b1c      	ldr	r3, [pc, #112]	@ (8004200 <UpdateCurrFlashBankFwIdBoardName+0x380>)
 800418e:	63fb      	str	r3, [r7, #60]	@ 0x3c
    BankInfoAddress = (uint32_t)&CurrentFwInfo;
 8004190:	4b1c      	ldr	r3, [pc, #112]	@ (8004204 <UpdateCurrFlashBankFwIdBoardName+0x384>)
 8004192:	63bb      	str	r3, [r7, #56]	@ 0x38
    if(HAL_FLASH_Program(FLASH_TYPEPROGRAM_QUADWORD, LocalWritingAddress,BankInfoAddress)==HAL_OK) {
 8004194:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8004196:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
 8004198:	2001      	movs	r0, #1
 800419a:	f00a ff8d 	bl	800f0b8 <HAL_FLASH_Program>
 800419e:	4603      	mov	r3, r0
 80041a0:	2b00      	cmp	r3, #0
 80041a2:	d112      	bne.n	80041ca <UpdateCurrFlashBankFwIdBoardName+0x34a>
      if(HAL_FLASH_Program(FLASH_TYPEPROGRAM_QUADWORD, LocalWritingAddress+16,BankInfoAddress+16)==HAL_OK) {
 80041a4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80041a6:	f103 0110 	add.w	r1, r3, #16
 80041aa:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80041ac:	3310      	adds	r3, #16
 80041ae:	461a      	mov	r2, r3
 80041b0:	2001      	movs	r0, #1
 80041b2:	f00a ff81 	bl	800f0b8 <HAL_FLASH_Program>
 80041b6:	4603      	mov	r3, r0
 80041b8:	2b00      	cmp	r3, #0
 80041ba:	d00c      	beq.n	80041d6 <UpdateCurrFlashBankFwIdBoardName+0x356>
        OTA_ERROR_FUNCTION();
 80041bc:	f240 224b 	movw	r2, #587	@ 0x24b
 80041c0:	4911      	ldr	r1, [pc, #68]	@ (8004208 <UpdateCurrFlashBankFwIdBoardName+0x388>)
 80041c2:	2002      	movs	r0, #2
 80041c4:	f000 fb32 	bl	800482c <STBOX1_Error_Handler>
 80041c8:	e005      	b.n	80041d6 <UpdateCurrFlashBankFwIdBoardName+0x356>
      OTA_ERROR_FUNCTION();
 80041ca:	f240 224e 	movw	r2, #590	@ 0x24e
 80041ce:	490e      	ldr	r1, [pc, #56]	@ (8004208 <UpdateCurrFlashBankFwIdBoardName+0x388>)
 80041d0:	2002      	movs	r0, #2
 80041d2:	f000 fb2b 	bl	800482c <STBOX1_Error_Handler>
    HAL_FLASH_Lock();
 80041d6:	f00a ffdb 	bl	800f190 <HAL_FLASH_Lock>
    if (HAL_ICACHE_Enable() != HAL_OK)
 80041da:	f00d fa8b 	bl	80116f4 <HAL_ICACHE_Enable>
 80041de:	4603      	mov	r3, r0
 80041e0:	2b00      	cmp	r3, #0
 80041e2:	d005      	beq.n	80041f0 <UpdateCurrFlashBankFwIdBoardName+0x370>
      STBOX1_Error_Handler(STBOX1_ERROR_FLASH,__FILE__,__LINE__);
 80041e4:	f44f 7216 	mov.w	r2, #600	@ 0x258
 80041e8:	4907      	ldr	r1, [pc, #28]	@ (8004208 <UpdateCurrFlashBankFwIdBoardName+0x388>)
 80041ea:	2002      	movs	r0, #2
 80041ec:	f000 fb1e 	bl	800482c <STBOX1_Error_Handler>
}
 80041f0:	bf00      	nop
 80041f2:	3740      	adds	r7, #64	@ 0x40
 80041f4:	46bd      	mov	sp, r7
 80041f6:	bdb0      	pop	{r4, r5, r7, pc}
 80041f8:	08027aa0 	.word	0x08027aa0
 80041fc:	08027ae8 	.word	0x08027ae8
 8004200:	080fe000 	.word	0x080fe000
 8004204:	2000052c 	.word	0x2000052c
 8004208:	0802797c 	.word	0x0802797c

0800420c <MX_BLESensorsPnPL_Init>:
/**
  * @brief  The application entry point.
  * @retval none
  */
void MX_BLESensorsPnPL_Init(void)
{
 800420c:	b580      	push	{r7, lr}
 800420e:	b084      	sub	sp, #16
 8004210:	af00      	add	r7, sp, #0
  /* Set a random seed */
  srand(HAL_GetTick());
 8004212:	f009 fc25 	bl	800da60 <HAL_GetTick>
 8004216:	4603      	mov	r3, r0
 8004218:	4618      	mov	r0, r3
 800421a:	f01d ff93 	bl	8022144 <srand>

  User_Init();
 800421e:	f000 f9ef 	bl	8004600 <User_Init>

  STBOX1_PRINTF("\033[2J"); /* serial console clear screen */
 8004222:	4859      	ldr	r0, [pc, #356]	@ (8004388 <MX_BLESensorsPnPL_Init+0x17c>)
 8004224:	f01f fd9a 	bl	8023d5c <iprintf>
  STBOX1_PRINTF("\033[H");  /* serial console cursor to home */
 8004228:	4858      	ldr	r0, [pc, #352]	@ (800438c <MX_BLESensorsPnPL_Init+0x180>)
 800422a:	f01f fd97 	bl	8023d5c <iprintf>
  PrintInfo();
 800422e:	f000 fa8f 	bl	8004750 <PrintInfo>

  BSP_LED_On(LED_BLUE);
 8004232:	2000      	movs	r0, #0
 8004234:	f000 fe3a 	bl	8004eac <BSP_LED_On>

  /* Init Mems Sensors */
  InitMemsSensors();
 8004238:	f000 f8d4 	bl	80043e4 <InitMemsSensors>

  /* Init Gas Gouge */
  {
   uint32_t flag;
    DrvStatusTypeDef InitType = BSP_GG_Init(&HandleGGComponent);
 800423c:	4854      	ldr	r0, [pc, #336]	@ (8004390 <MX_BLESensorsPnPL_Init+0x184>)
 800423e:	f008 fedb 	bl	800cff8 <BSP_GG_Init>
 8004242:	4603      	mov	r3, r0
 8004244:	73fb      	strb	r3, [r7, #15]

    switch(InitType) {
 8004246:	7bfb      	ldrb	r3, [r7, #15]
 8004248:	2b00      	cmp	r3, #0
 800424a:	d002      	beq.n	8004252 <MX_BLESensorsPnPL_Init+0x46>
 800424c:	2b04      	cmp	r3, #4
 800424e:	d01c      	beq.n	800428a <MX_BLESensorsPnPL_Init+0x7e>
 8004250:	e025      	b.n	800429e <MX_BLESensorsPnPL_Init+0x92>
      case COMPONENT_OK:
        STBOX1_PRINTF("Gas Gouge Component OK\n\r");
 8004252:	4850      	ldr	r0, [pc, #320]	@ (8004394 <MX_BLESensorsPnPL_Init+0x188>)
 8004254:	f01f fd82 	bl	8023d5c <iprintf>
        BSP_GG_GetPresence(HandleGGComponent,&flag);
 8004258:	4b4d      	ldr	r3, [pc, #308]	@ (8004390 <MX_BLESensorsPnPL_Init+0x184>)
 800425a:	681b      	ldr	r3, [r3, #0]
 800425c:	f107 0208 	add.w	r2, r7, #8
 8004260:	4611      	mov	r1, r2
 8004262:	4618      	mov	r0, r3
 8004264:	f008 ff22 	bl	800d0ac <BSP_GG_GetPresence>
        if(flag) {
 8004268:	68bb      	ldr	r3, [r7, #8]
 800426a:	2b00      	cmp	r3, #0
 800426c:	d006      	beq.n	800427c <MX_BLESensorsPnPL_Init+0x70>
          STBOX1_PRINTF("\tBattery present\n\r");
 800426e:	484a      	ldr	r0, [pc, #296]	@ (8004398 <MX_BLESensorsPnPL_Init+0x18c>)
 8004270:	f01f fd74 	bl	8023d5c <iprintf>
          BatteryPresent=1;
 8004274:	4b49      	ldr	r3, [pc, #292]	@ (800439c <MX_BLESensorsPnPL_Init+0x190>)
 8004276:	2201      	movs	r2, #1
 8004278:	701a      	strb	r2, [r3, #0]
        } else {
          STBOX1_PRINTF("\tBattery not present\n\r");
          BatteryPresent=0;
        }
      break;
 800427a:	e016      	b.n	80042aa <MX_BLESensorsPnPL_Init+0x9e>
          STBOX1_PRINTF("\tBattery not present\n\r");
 800427c:	4848      	ldr	r0, [pc, #288]	@ (80043a0 <MX_BLESensorsPnPL_Init+0x194>)
 800427e:	f01f fd6d 	bl	8023d5c <iprintf>
          BatteryPresent=0;
 8004282:	4b46      	ldr	r3, [pc, #280]	@ (800439c <MX_BLESensorsPnPL_Init+0x190>)
 8004284:	2200      	movs	r2, #0
 8004286:	701a      	strb	r2, [r3, #0]
      break;
 8004288:	e00f      	b.n	80042aa <MX_BLESensorsPnPL_Init+0x9e>
      case COMPONENT_BATT_FAIL:
        STBOX1_PRINTF("Gas Gouge Component OK\n\r");
 800428a:	4842      	ldr	r0, [pc, #264]	@ (8004394 <MX_BLESensorsPnPL_Init+0x188>)
 800428c:	f01f fd66 	bl	8023d5c <iprintf>
        STBOX1_PRINTF("\tBattery not present\n\r");
 8004290:	4843      	ldr	r0, [pc, #268]	@ (80043a0 <MX_BLESensorsPnPL_Init+0x194>)
 8004292:	f01f fd63 	bl	8023d5c <iprintf>
        BatteryPresent=0;
 8004296:	4b41      	ldr	r3, [pc, #260]	@ (800439c <MX_BLESensorsPnPL_Init+0x190>)
 8004298:	2200      	movs	r2, #0
 800429a:	701a      	strb	r2, [r3, #0]
      break;
 800429c:	e005      	b.n	80042aa <MX_BLESensorsPnPL_Init+0x9e>
      default:
        STBOX1_PRINTF("Gas Gouge Component ERROR\n\r");
 800429e:	4841      	ldr	r0, [pc, #260]	@ (80043a4 <MX_BLESensorsPnPL_Init+0x198>)
 80042a0:	f01f fd5c 	bl	8023d5c <iprintf>
        BatteryPresent=0;
 80042a4:	4b3d      	ldr	r3, [pc, #244]	@ (800439c <MX_BLESensorsPnPL_Init+0x190>)
 80042a6:	2200      	movs	r2, #0
 80042a8:	701a      	strb	r2, [r3, #0]
    }
  }

  /* Init BLE */
  STBOX1_PRINTF("\r\nInitializing Bluetooth\r\n");
 80042aa:	483f      	ldr	r0, [pc, #252]	@ (80043a8 <MX_BLESensorsPnPL_Init+0x19c>)
 80042ac:	f01f fdbe 	bl	8023e2c <puts>
  BluetoothInit();
 80042b0:	f7fe fb9a 	bl	80029e8 <BluetoothInit>
  /* For Receiving information on Response Event for a MTU Exchange Event */
  CustomMTUExchangeRespEvent = MTUExcahngeRespEvent;
 80042b4:	4b3d      	ldr	r3, [pc, #244]	@ (80043ac <MX_BLESensorsPnPL_Init+0x1a0>)
 80042b6:	4a3e      	ldr	r2, [pc, #248]	@ (80043b0 <MX_BLESensorsPnPL_Init+0x1a4>)
 80042b8:	601a      	str	r2, [r3, #0]
  /* For Receiving information on aci_gatt_tx_pool_available_event */
  CustomAciGattTxPoolAvailableEvent = TxPoolAvailableEvent;
 80042ba:	4b3e      	ldr	r3, [pc, #248]	@ (80043b4 <MX_BLESensorsPnPL_Init+0x1a8>)
 80042bc:	4a3e      	ldr	r2, [pc, #248]	@ (80043b8 <MX_BLESensorsPnPL_Init+0x1ac>)
 80042be:	601a      	str	r2, [r3, #0]

  /* PnP-L Components Allocation */
  pConfigurationPnPLObj = Configuration_PnPLAlloc();
 80042c0:	f7fe fd06 	bl	8002cd0 <Configuration_PnPLAlloc>
 80042c4:	4603      	mov	r3, r0
 80042c6:	4a3d      	ldr	r2, [pc, #244]	@ (80043bc <MX_BLESensorsPnPL_Init+0x1b0>)
 80042c8:	6013      	str	r3, [r2, #0]
  pControlPnPLObj = Control_PnPLAlloc();
 80042ca:	f7fe fddb 	bl	8002e84 <Control_PnPLAlloc>
 80042ce:	4603      	mov	r3, r0
 80042d0:	4a3b      	ldr	r2, [pc, #236]	@ (80043c0 <MX_BLESensorsPnPL_Init+0x1b4>)
 80042d2:	6013      	str	r3, [r2, #0]
  pEnvironmentalPnPLObj = Environmental_PnPLAlloc();
 80042d4:	f7ff f876 	bl	80033c4 <Environmental_PnPLAlloc>
 80042d8:	4603      	mov	r3, r0
 80042da:	4a3a      	ldr	r2, [pc, #232]	@ (80043c4 <MX_BLESensorsPnPL_Init+0x1b8>)
 80042dc:	6013      	str	r3, [r2, #0]
  pInertialPnPLObj = Inertial_PnPLAlloc();
 80042de:	f7ff f989 	bl	80035f4 <Inertial_PnPLAlloc>
 80042e2:	4603      	mov	r3, r0
 80042e4:	4a38      	ldr	r2, [pc, #224]	@ (80043c8 <MX_BLESensorsPnPL_Init+0x1bc>)
 80042e6:	6013      	str	r3, [r2, #0]
  pDeviceInformationPnPLObj = Deviceinformation_PnPLAlloc();
 80042e8:	f7fe ff5e 	bl	80031a8 <Deviceinformation_PnPLAlloc>
 80042ec:	4603      	mov	r3, r0
 80042ee:	4a37      	ldr	r2, [pc, #220]	@ (80043cc <MX_BLESensorsPnPL_Init+0x1c0>)
 80042f0:	6013      	str	r3, [r2, #0]

  /* Init&Add PnP-L Components */
  Configuration_PnPLInit(pConfigurationPnPLObj);
 80042f2:	4b32      	ldr	r3, [pc, #200]	@ (80043bc <MX_BLESensorsPnPL_Init+0x1b0>)
 80042f4:	681b      	ldr	r3, [r3, #0]
 80042f6:	4618      	mov	r0, r3
 80042f8:	f7fe fd00 	bl	8002cfc <Configuration_PnPLInit>
  Control_PnPLInit(pControlPnPLObj, &iControl);
 80042fc:	4b30      	ldr	r3, [pc, #192]	@ (80043c0 <MX_BLESensorsPnPL_Init+0x1b4>)
 80042fe:	681b      	ldr	r3, [r3, #0]
 8004300:	4933      	ldr	r1, [pc, #204]	@ (80043d0 <MX_BLESensorsPnPL_Init+0x1c4>)
 8004302:	4618      	mov	r0, r3
 8004304:	f7fe fdd4 	bl	8002eb0 <Control_PnPLInit>
  Environmental_PnPLInit(pEnvironmentalPnPLObj);
 8004308:	4b2e      	ldr	r3, [pc, #184]	@ (80043c4 <MX_BLESensorsPnPL_Init+0x1b8>)
 800430a:	681b      	ldr	r3, [r3, #0]
 800430c:	4618      	mov	r0, r3
 800430e:	f7ff f86f 	bl	80033f0 <Environmental_PnPLInit>
  Inertial_PnPLInit(pInertialPnPLObj);
 8004312:	4b2d      	ldr	r3, [pc, #180]	@ (80043c8 <MX_BLESensorsPnPL_Init+0x1bc>)
 8004314:	681b      	ldr	r3, [r3, #0]
 8004316:	4618      	mov	r0, r3
 8004318:	f7ff f982 	bl	8003620 <Inertial_PnPLInit>
  Deviceinformation_PnPLInit(pDeviceInformationPnPLObj);
 800431c:	4b2b      	ldr	r3, [pc, #172]	@ (80043cc <MX_BLESensorsPnPL_Init+0x1c0>)
 800431e:	681b      	ldr	r3, [r3, #0]
 8004320:	4618      	mov	r0, r3
 8004322:	f7fe ff57 	bl	80031d4 <Deviceinformation_PnPLInit>

  if(FinishGood==FINISHA) {
 8004326:	4b2b      	ldr	r3, [pc, #172]	@ (80043d4 <MX_BLESensorsPnPL_Init+0x1c8>)
 8004328:	781b      	ldrb	r3, [r3, #0]
 800432a:	2b00      	cmp	r3, #0
 800432c:	d106      	bne.n	800433c <MX_BLESensorsPnPL_Init+0x130>
    PnPLSetBOARDID(BLE_MANAGER_SENSOR_TILE_BOX_PRO_PLATFORM);
 800432e:	200d      	movs	r0, #13
 8004330:	f018 f8fe 	bl	801c530 <PnPLSetBOARDID>
    PnPLSetFWID(STBOX1A_BLUEST_SDK_FW_ID);
 8004334:	2032      	movs	r0, #50	@ 0x32
 8004336:	f018 f8eb 	bl	801c510 <PnPLSetFWID>
 800433a:	e005      	b.n	8004348 <MX_BLESensorsPnPL_Init+0x13c>
  } else {
    PnPLSetBOARDID(BLE_MANAGER_SENSOR_TILE_BOX_PRO_B_PLATFORM);
 800433c:	2011      	movs	r0, #17
 800433e:	f018 f8f7 	bl	801c530 <PnPLSetBOARDID>
    PnPLSetFWID(STBOX1B_BLUEST_SDK_FW_ID);
 8004342:	2012      	movs	r0, #18
 8004344:	f018 f8e4 	bl	801c510 <PnPLSetFWID>

  /* FOTA and Dual Banks Section */
  {
    uint16_t FwId1,FwId2;

    ReadFlashBanksFwId(&FwId1,&FwId2);
 8004348:	1d3a      	adds	r2, r7, #4
 800434a:	1dbb      	adds	r3, r7, #6
 800434c:	4611      	mov	r1, r2
 800434e:	4618      	mov	r0, r3
 8004350:	f7ff fcb2 	bl	8003cb8 <ReadFlashBanksFwId>
    if(FwId2!=OTA_OTA_FW_ID_NOT_VALID) {
 8004354:	88bb      	ldrh	r3, [r7, #4]
 8004356:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 800435a:	4293      	cmp	r3, r2
 800435c:	d002      	beq.n	8004364 <MX_BLESensorsPnPL_Init+0x158>
      /* Enable the Banks Swap only if there is a valid fw on second bank */
      CustomExtConfigBanksSwapCommandCallback           = ExtConfigBanksSwapCommandCallback;
 800435e:	4b1e      	ldr	r3, [pc, #120]	@ (80043d8 <MX_BLESensorsPnPL_Init+0x1cc>)
 8004360:	4a1e      	ldr	r2, [pc, #120]	@ (80043dc <MX_BLESensorsPnPL_Init+0x1d0>)
 8004362:	601a      	str	r2, [r3, #0]
    }
  }

  BSP_LED_Off(LED_BLUE);
 8004364:	2000      	movs	r0, #0
 8004366:	f000 fdbb 	bl	8004ee0 <BSP_LED_Off>
  BSP_LED_On(LED_GREEN);
 800436a:	2003      	movs	r0, #3
 800436c:	f000 fd9e 	bl	8004eac <BSP_LED_On>

  /* Short delay before starting the user application process */
  HAL_Delay(500);
 8004370:	f44f 70fa 	mov.w	r0, #500	@ 0x1f4
 8004374:	f000 fa42 	bl	80047fc <HAL_Delay>
  STBOX1_PRINTF("BLE Stack Initialized & Device Configured\r\n");
 8004378:	4819      	ldr	r0, [pc, #100]	@ (80043e0 <MX_BLESensorsPnPL_Init+0x1d4>)
 800437a:	f01f fd57 	bl	8023e2c <puts>
}
 800437e:	bf00      	nop
 8004380:	3710      	adds	r7, #16
 8004382:	46bd      	mov	sp, r7
 8004384:	bd80      	pop	{r7, pc}
 8004386:	bf00      	nop
 8004388:	08027b3c 	.word	0x08027b3c
 800438c:	08027b44 	.word	0x08027b44
 8004390:	20000594 	.word	0x20000594
 8004394:	08027b48 	.word	0x08027b48
 8004398:	08027b64 	.word	0x08027b64
 800439c:	20000598 	.word	0x20000598
 80043a0:	08027b78 	.word	0x08027b78
 80043a4:	08027b90 	.word	0x08027b90
 80043a8:	08027bac 	.word	0x08027bac
 80043ac:	20001b3c 	.word	0x20001b3c
 80043b0:	08001d35 	.word	0x08001d35
 80043b4:	20001b4c 	.word	0x20001b4c
 80043b8:	08001d69 	.word	0x08001d69
 80043bc:	200004d8 	.word	0x200004d8
 80043c0:	200004dc 	.word	0x200004dc
 80043c4:	200004e0 	.word	0x200004e0
 80043c8:	200004e4 	.word	0x200004e4
 80043cc:	200004e8 	.word	0x200004e8
 80043d0:	200004ec 	.word	0x200004ec
 80043d4:	2000059a 	.word	0x2000059a
 80043d8:	20001b84 	.word	0x20001b84
 80043dc:	08002935 	.word	0x08002935
 80043e0:	08027bc8 	.word	0x08027bc8

080043e4 <InitMemsSensors>:
* @brief  Init Mems Sensors
* @param  None
* @retval None
*/
static void InitMemsSensors(void)
{
 80043e4:	b580      	push	{r7, lr}
 80043e6:	b086      	sub	sp, #24
 80043e8:	af00      	add	r7, sp, #0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80043ea:	1d3b      	adds	r3, r7, #4
 80043ec:	2200      	movs	r2, #0
 80043ee:	601a      	str	r2, [r3, #0]
 80043f0:	605a      	str	r2, [r3, #4]
 80043f2:	609a      	str	r2, [r3, #8]
 80043f4:	60da      	str	r2, [r3, #12]
 80043f6:	611a      	str	r2, [r3, #16]

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOI_CLK_ENABLE();
 80043f8:	4b72      	ldr	r3, [pc, #456]	@ (80045c4 <InitMemsSensors+0x1e0>)
 80043fa:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 80043fe:	4a71      	ldr	r2, [pc, #452]	@ (80045c4 <InitMemsSensors+0x1e0>)
 8004400:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8004404:	f8c2 308c 	str.w	r3, [r2, #140]	@ 0x8c
 8004408:	4b6e      	ldr	r3, [pc, #440]	@ (80045c4 <InitMemsSensors+0x1e0>)
 800440a:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800440e:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8004412:	603b      	str	r3, [r7, #0]
 8004414:	683b      	ldr	r3, [r7, #0]

  /*Configure GPIO pin Output Level 5-> BSP_LSM6DSV16X_CS_PIN 7-> BSP_LIS2DU12_CS_PIN*/
  HAL_GPIO_WritePin(GPIOI, GPIO_PIN_5|GPIO_PIN_7, GPIO_PIN_SET);
 8004416:	2201      	movs	r2, #1
 8004418:	21a0      	movs	r1, #160	@ 0xa0
 800441a:	486b      	ldr	r0, [pc, #428]	@ (80045c8 <InitMemsSensors+0x1e4>)
 800441c:	f00b fc70 	bl	800fd00 <HAL_GPIO_WritePin>

  /*Configure GPIO pins : PI5 PI7 */
  GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_7;
 8004420:	23a0      	movs	r3, #160	@ 0xa0
 8004422:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8004424:	2301      	movs	r3, #1
 8004426:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8004428:	2300      	movs	r3, #0
 800442a:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800442c:	2300      	movs	r3, #0
 800442e:	613b      	str	r3, [r7, #16]
  HAL_GPIO_Init(GPIOI, &GPIO_InitStruct);
 8004430:	1d3b      	adds	r3, r7, #4
 8004432:	4619      	mov	r1, r3
 8004434:	4864      	ldr	r0, [pc, #400]	@ (80045c8 <InitMemsSensors+0x1e4>)
 8004436:	f00b f995 	bl	800f764 <HAL_GPIO_Init>
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOI, &GPIO_InitStruct);
#endif

  /* Magneto */
  if(BSP_MOTION_SENSOR_Init(LIS2MDL_0, MOTION_MAGNETO)==BSP_ERROR_NONE) {
 800443a:	2104      	movs	r1, #4
 800443c:	2000      	movs	r0, #0
 800443e:	f008 fe93 	bl	800d168 <BSP_MOTION_SENSOR_Init>
 8004442:	4603      	mov	r3, r0
 8004444:	2b00      	cmp	r3, #0
 8004446:	d11b      	bne.n	8004480 <InitMemsSensors+0x9c>
    if(BSP_MOTION_SENSOR_SetOutputDataRate(LIS2MDL_0, MOTION_MAGNETO, LIS2MDL_MAG_ODR)==BSP_ERROR_NONE) {
 8004448:	4a60      	ldr	r2, [pc, #384]	@ (80045cc <InitMemsSensors+0x1e8>)
 800444a:	2104      	movs	r1, #4
 800444c:	2000      	movs	r0, #0
 800444e:	f008 ff87 	bl	800d360 <BSP_MOTION_SENSOR_SetOutputDataRate>
 8004452:	4603      	mov	r3, r0
 8004454:	2b00      	cmp	r3, #0
 8004456:	d10f      	bne.n	8004478 <InitMemsSensors+0x94>
      if(BSP_MOTION_SENSOR_SetFullScale(LIS2MDL_0, MOTION_MAGNETO, LIS2MDL_MAG_FS)==BSP_ERROR_NONE) {
 8004458:	2232      	movs	r2, #50	@ 0x32
 800445a:	2104      	movs	r1, #4
 800445c:	2000      	movs	r0, #0
 800445e:	f008 ffc3 	bl	800d3e8 <BSP_MOTION_SENSOR_SetFullScale>
 8004462:	4603      	mov	r3, r0
 8004464:	2b00      	cmp	r3, #0
 8004466:	d103      	bne.n	8004470 <InitMemsSensors+0x8c>
        STBOX1_PRINTF("LIS2MDL_0 OK\r\n");
 8004468:	4859      	ldr	r0, [pc, #356]	@ (80045d0 <InitMemsSensors+0x1ec>)
 800446a:	f01f fcdf 	bl	8023e2c <puts>
 800446e:	e00a      	b.n	8004486 <InitMemsSensors+0xa2>
      } else {
        STBOX1_PRINTF("Error: LIS2MDL_0 KO\r\n");
 8004470:	4858      	ldr	r0, [pc, #352]	@ (80045d4 <InitMemsSensors+0x1f0>)
 8004472:	f01f fcdb 	bl	8023e2c <puts>
 8004476:	e006      	b.n	8004486 <InitMemsSensors+0xa2>
      }
    }else {
      STBOX1_PRINTF("Error: LIS2MDL_0 KO\r\n");
 8004478:	4856      	ldr	r0, [pc, #344]	@ (80045d4 <InitMemsSensors+0x1f0>)
 800447a:	f01f fcd7 	bl	8023e2c <puts>
 800447e:	e002      	b.n	8004486 <InitMemsSensors+0xa2>
    }
  } else {
    STBOX1_PRINTF("Error: LIS2MDL_0 KO\r\n");
 8004480:	4854      	ldr	r0, [pc, #336]	@ (80045d4 <InitMemsSensors+0x1f0>)
 8004482:	f01f fcd3 	bl	8023e2c <puts>
  }

  /* Acc/Gyro */
  if(BSP_MOTION_SENSOR_Init(LSM6DSV16X_0, MOTION_ACCELERO | MOTION_GYRO)==BSP_ERROR_NONE) {
 8004486:	2103      	movs	r1, #3
 8004488:	2002      	movs	r0, #2
 800448a:	f008 fe6d 	bl	800d168 <BSP_MOTION_SENSOR_Init>
 800448e:	4603      	mov	r3, r0
 8004490:	2b00      	cmp	r3, #0
 8004492:	d134      	bne.n	80044fe <InitMemsSensors+0x11a>
    if(BSP_MOTION_SENSOR_SetOutputDataRate(LSM6DSV16X_0, MOTION_ACCELERO, LSM6DSV16X_ACC_ODR)==BSP_ERROR_NONE) {
 8004494:	4a50      	ldr	r2, [pc, #320]	@ (80045d8 <InitMemsSensors+0x1f4>)
 8004496:	2102      	movs	r1, #2
 8004498:	2002      	movs	r0, #2
 800449a:	f008 ff61 	bl	800d360 <BSP_MOTION_SENSOR_SetOutputDataRate>
 800449e:	4603      	mov	r3, r0
 80044a0:	2b00      	cmp	r3, #0
 80044a2:	d128      	bne.n	80044f6 <InitMemsSensors+0x112>
      if(BSP_MOTION_SENSOR_SetFullScale(LSM6DSV16X_0, MOTION_ACCELERO, LSM6DSV16X_ACC_FS)==BSP_ERROR_NONE) {
 80044a4:	2204      	movs	r2, #4
 80044a6:	2102      	movs	r1, #2
 80044a8:	2002      	movs	r0, #2
 80044aa:	f008 ff9d 	bl	800d3e8 <BSP_MOTION_SENSOR_SetFullScale>
 80044ae:	4603      	mov	r3, r0
 80044b0:	2b00      	cmp	r3, #0
 80044b2:	d11c      	bne.n	80044ee <InitMemsSensors+0x10a>
        if(BSP_MOTION_SENSOR_SetOutputDataRate(LSM6DSV16X_0, MOTION_GYRO, LSM6DSV16X_GYRO_ODR)==BSP_ERROR_NONE) {
 80044b4:	4a48      	ldr	r2, [pc, #288]	@ (80045d8 <InitMemsSensors+0x1f4>)
 80044b6:	2101      	movs	r1, #1
 80044b8:	2002      	movs	r0, #2
 80044ba:	f008 ff51 	bl	800d360 <BSP_MOTION_SENSOR_SetOutputDataRate>
 80044be:	4603      	mov	r3, r0
 80044c0:	2b00      	cmp	r3, #0
 80044c2:	d110      	bne.n	80044e6 <InitMemsSensors+0x102>
          if(BSP_MOTION_SENSOR_SetFullScale(LSM6DSV16X_0, MOTION_GYRO, LSM6DSV16X_GYRO_FS)==BSP_ERROR_NONE) {
 80044c4:	f44f 62fa 	mov.w	r2, #2000	@ 0x7d0
 80044c8:	2101      	movs	r1, #1
 80044ca:	2002      	movs	r0, #2
 80044cc:	f008 ff8c 	bl	800d3e8 <BSP_MOTION_SENSOR_SetFullScale>
 80044d0:	4603      	mov	r3, r0
 80044d2:	2b00      	cmp	r3, #0
 80044d4:	d103      	bne.n	80044de <InitMemsSensors+0xfa>
            STBOX1_PRINTF("LSM6DSV16X_0 OK\r\n");
 80044d6:	4841      	ldr	r0, [pc, #260]	@ (80045dc <InitMemsSensors+0x1f8>)
 80044d8:	f01f fca8 	bl	8023e2c <puts>
 80044dc:	e012      	b.n	8004504 <InitMemsSensors+0x120>
          } else {
            STBOX1_PRINTF("Error: LSM6DSV16X_0 KO\r\n");
 80044de:	4840      	ldr	r0, [pc, #256]	@ (80045e0 <InitMemsSensors+0x1fc>)
 80044e0:	f01f fca4 	bl	8023e2c <puts>
 80044e4:	e00e      	b.n	8004504 <InitMemsSensors+0x120>
          }
        } else {
          STBOX1_PRINTF("Error: LSM6DSV16X_0 KO\r\n");
 80044e6:	483e      	ldr	r0, [pc, #248]	@ (80045e0 <InitMemsSensors+0x1fc>)
 80044e8:	f01f fca0 	bl	8023e2c <puts>
 80044ec:	e00a      	b.n	8004504 <InitMemsSensors+0x120>
        }
      } else {
        STBOX1_PRINTF("Error: LSM6DSV16X_0 KO\r\n");
 80044ee:	483c      	ldr	r0, [pc, #240]	@ (80045e0 <InitMemsSensors+0x1fc>)
 80044f0:	f01f fc9c 	bl	8023e2c <puts>
 80044f4:	e006      	b.n	8004504 <InitMemsSensors+0x120>
      }
    } else {
      STBOX1_PRINTF("Error: LSM6DSV16X_0 KO\r\n");
 80044f6:	483a      	ldr	r0, [pc, #232]	@ (80045e0 <InitMemsSensors+0x1fc>)
 80044f8:	f01f fc98 	bl	8023e2c <puts>
 80044fc:	e002      	b.n	8004504 <InitMemsSensors+0x120>
    }
  } else {
    STBOX1_PRINTF("Error: LSM6DSV16X_0 KO\r\n");
 80044fe:	4838      	ldr	r0, [pc, #224]	@ (80045e0 <InitMemsSensors+0x1fc>)
 8004500:	f01f fc94 	bl	8023e2c <puts>
  }

  /* Acc2 */
  if(BSP_MOTION_SENSOR_Init(LIS2DU12_0, MOTION_ACCELERO)==BSP_ERROR_NONE) {
 8004504:	2102      	movs	r1, #2
 8004506:	2001      	movs	r0, #1
 8004508:	f008 fe2e 	bl	800d168 <BSP_MOTION_SENSOR_Init>
 800450c:	4603      	mov	r3, r0
 800450e:	2b00      	cmp	r3, #0
 8004510:	d11b      	bne.n	800454a <InitMemsSensors+0x166>
    if(BSP_MOTION_SENSOR_SetOutputDataRate(LIS2DU12_0, MOTION_ACCELERO, LIS2DU12_ACC_ODR)==BSP_ERROR_NONE) {
 8004512:	4a2e      	ldr	r2, [pc, #184]	@ (80045cc <InitMemsSensors+0x1e8>)
 8004514:	2102      	movs	r1, #2
 8004516:	2001      	movs	r0, #1
 8004518:	f008 ff22 	bl	800d360 <BSP_MOTION_SENSOR_SetOutputDataRate>
 800451c:	4603      	mov	r3, r0
 800451e:	2b00      	cmp	r3, #0
 8004520:	d10f      	bne.n	8004542 <InitMemsSensors+0x15e>
      if(BSP_MOTION_SENSOR_SetFullScale(LIS2DU12_0, MOTION_ACCELERO, LIS2DU12_ACC_FS)==BSP_ERROR_NONE) {
 8004522:	2204      	movs	r2, #4
 8004524:	2102      	movs	r1, #2
 8004526:	2001      	movs	r0, #1
 8004528:	f008 ff5e 	bl	800d3e8 <BSP_MOTION_SENSOR_SetFullScale>
 800452c:	4603      	mov	r3, r0
 800452e:	2b00      	cmp	r3, #0
 8004530:	d103      	bne.n	800453a <InitMemsSensors+0x156>
         STBOX1_PRINTF("LIS2DU12_0 OK\r\n");
 8004532:	482c      	ldr	r0, [pc, #176]	@ (80045e4 <InitMemsSensors+0x200>)
 8004534:	f01f fc7a 	bl	8023e2c <puts>
 8004538:	e00a      	b.n	8004550 <InitMemsSensors+0x16c>
      } else {
        STBOX1_PRINTF("Error: LIS2DU12_0 KO\r\n");
 800453a:	482b      	ldr	r0, [pc, #172]	@ (80045e8 <InitMemsSensors+0x204>)
 800453c:	f01f fc76 	bl	8023e2c <puts>
 8004540:	e006      	b.n	8004550 <InitMemsSensors+0x16c>
      }
    } else {
      STBOX1_PRINTF("Error: LIS2DU12_0 KO\r\n");
 8004542:	4829      	ldr	r0, [pc, #164]	@ (80045e8 <InitMemsSensors+0x204>)
 8004544:	f01f fc72 	bl	8023e2c <puts>
 8004548:	e002      	b.n	8004550 <InitMemsSensors+0x16c>
    }
  } else {
    STBOX1_PRINTF("Error: LIS2DU12_0 KO\r\n");
 800454a:	4827      	ldr	r0, [pc, #156]	@ (80045e8 <InitMemsSensors+0x204>)
 800454c:	f01f fc6e 	bl	8023e2c <puts>
  }

  /* Pressure */
  if(BSP_ENV_SENSOR_Init(LPS22DF_0, ENV_PRESSURE)==BSP_ERROR_NONE) {
 8004550:	2102      	movs	r1, #2
 8004552:	2001      	movs	r0, #1
 8004554:	f008 fad2 	bl	800cafc <BSP_ENV_SENSOR_Init>
 8004558:	4603      	mov	r3, r0
 800455a:	2b00      	cmp	r3, #0
 800455c:	d10f      	bne.n	800457e <InitMemsSensors+0x19a>
    if(BSP_ENV_SENSOR_SetOutputDataRate(LPS22DF_0, ENV_PRESSURE, LPS22DF_ODR)==BSP_ERROR_NONE) {
 800455e:	4a23      	ldr	r2, [pc, #140]	@ (80045ec <InitMemsSensors+0x208>)
 8004560:	2102      	movs	r1, #2
 8004562:	2001      	movs	r0, #1
 8004564:	f008 fb7a 	bl	800cc5c <BSP_ENV_SENSOR_SetOutputDataRate>
 8004568:	4603      	mov	r3, r0
 800456a:	2b00      	cmp	r3, #0
 800456c:	d103      	bne.n	8004576 <InitMemsSensors+0x192>
      STBOX1_PRINTF("LPS22DF_0 OK\r\n");
 800456e:	4820      	ldr	r0, [pc, #128]	@ (80045f0 <InitMemsSensors+0x20c>)
 8004570:	f01f fc5c 	bl	8023e2c <puts>
 8004574:	e006      	b.n	8004584 <InitMemsSensors+0x1a0>
    } else {
      STBOX1_PRINTF("Error: LPS22DF_0 KO\r\n");
 8004576:	481f      	ldr	r0, [pc, #124]	@ (80045f4 <InitMemsSensors+0x210>)
 8004578:	f01f fc58 	bl	8023e2c <puts>
 800457c:	e002      	b.n	8004584 <InitMemsSensors+0x1a0>
    }
  } else {
    STBOX1_PRINTF("Error: LPS22DF_0 KO\r\n");
 800457e:	481d      	ldr	r0, [pc, #116]	@ (80045f4 <InitMemsSensors+0x210>)
 8004580:	f01f fc54 	bl	8023e2c <puts>
  }

  /* Temperature 2 */
  if(BSP_ENV_SENSOR_Init(STTS22H_0, ENV_TEMPERATURE)==BSP_ERROR_NONE) {
 8004584:	2101      	movs	r1, #1
 8004586:	2000      	movs	r0, #0
 8004588:	f008 fab8 	bl	800cafc <BSP_ENV_SENSOR_Init>
 800458c:	4603      	mov	r3, r0
 800458e:	2b00      	cmp	r3, #0
 8004590:	d110      	bne.n	80045b4 <InitMemsSensors+0x1d0>
    if(BSP_ENV_SENSOR_SetOutputDataRate(STTS22H_0, ENV_TEMPERATURE, STTS22H_ODR)==BSP_ERROR_NONE) {
 8004592:	f04f 527e 	mov.w	r2, #1065353216	@ 0x3f800000
 8004596:	2101      	movs	r1, #1
 8004598:	2000      	movs	r0, #0
 800459a:	f008 fb5f 	bl	800cc5c <BSP_ENV_SENSOR_SetOutputDataRate>
 800459e:	4603      	mov	r3, r0
 80045a0:	2b00      	cmp	r3, #0
 80045a2:	d103      	bne.n	80045ac <InitMemsSensors+0x1c8>
      STBOX1_PRINTF("STTS22H_0 OK\r\n");
 80045a4:	4814      	ldr	r0, [pc, #80]	@ (80045f8 <InitMemsSensors+0x214>)
 80045a6:	f01f fc41 	bl	8023e2c <puts>
      STBOX1_PRINTF("Error: STTS22H_0 KO\r\n");
    }
  } else {
    STBOX1_PRINTF("Error: STTS22H_0 KO\r\n");
  }
}
 80045aa:	e006      	b.n	80045ba <InitMemsSensors+0x1d6>
      STBOX1_PRINTF("Error: STTS22H_0 KO\r\n");
 80045ac:	4813      	ldr	r0, [pc, #76]	@ (80045fc <InitMemsSensors+0x218>)
 80045ae:	f01f fc3d 	bl	8023e2c <puts>
}
 80045b2:	e002      	b.n	80045ba <InitMemsSensors+0x1d6>
    STBOX1_PRINTF("Error: STTS22H_0 KO\r\n");
 80045b4:	4811      	ldr	r0, [pc, #68]	@ (80045fc <InitMemsSensors+0x218>)
 80045b6:	f01f fc39 	bl	8023e2c <puts>
}
 80045ba:	bf00      	nop
 80045bc:	3718      	adds	r7, #24
 80045be:	46bd      	mov	sp, r7
 80045c0:	bd80      	pop	{r7, pc}
 80045c2:	bf00      	nop
 80045c4:	46020c00 	.word	0x46020c00
 80045c8:	42022000 	.word	0x42022000
 80045cc:	42c80000 	.word	0x42c80000
 80045d0:	08027c9c 	.word	0x08027c9c
 80045d4:	08027cac 	.word	0x08027cac
 80045d8:	42f00000 	.word	0x42f00000
 80045dc:	08027cc4 	.word	0x08027cc4
 80045e0:	08027cd8 	.word	0x08027cd8
 80045e4:	08027cf0 	.word	0x08027cf0
 80045e8:	08027d00 	.word	0x08027d00
 80045ec:	41c80000 	.word	0x41c80000
 80045f0:	08027d18 	.word	0x08027d18
 80045f4:	08027d28 	.word	0x08027d28
 80045f8:	08027d40 	.word	0x08027d40
 80045fc:	08027d50 	.word	0x08027d50

08004600 <User_Init>:
*
* @param  None
* @retval None
*/
static void User_Init(void)
{
 8004600:	b580      	push	{r7, lr}
 8004602:	b08e      	sub	sp, #56	@ 0x38
 8004604:	af00      	add	r7, sp, #0
  /* Enable Button in Interrupt mode */
  BSP_PB_Init(BUTTON_KEY, BUTTON_MODE_EXTI);
 8004606:	2101      	movs	r1, #1
 8004608:	2000      	movs	r0, #0
 800460a:	f000 fd99 	bl	8005140 <BSP_PB_Init>

  /* Init the Led */
  BSP_LED_Init(LED_GREEN);
 800460e:	2003      	movs	r0, #3
 8004610:	f000 fc3a 	bl	8004e88 <BSP_LED_Init>
  BSP_LED_Init(LED_RED);
 8004614:	2001      	movs	r0, #1
 8004616:	f000 fc37 	bl	8004e88 <BSP_LED_Init>
  BSP_LED_Init(LED_YELLOW);
 800461a:	2002      	movs	r0, #2
 800461c:	f000 fc34 	bl	8004e88 <BSP_LED_Init>
  BSP_LED_Init(LED_BLUE);
 8004620:	2000      	movs	r0, #0
 8004622:	f000 fc31 	bl	8004e88 <BSP_LED_Init>

  /* why RED is activated by default? */
  BSP_LED_Off(LED_RED);
 8004626:	2001      	movs	r0, #1
 8004628:	f000 fc5a 	bl	8004ee0 <BSP_LED_Off>

  /* Check if we are running from Bank1 or Bank2 */
  {
    FLASH_OBProgramInitTypeDef    OBInit;
    /* Allow Access to Flash control registers and user Flash */
    HAL_FLASH_Unlock();
 800462c:	f00a fd8e 	bl	800f14c <HAL_FLASH_Unlock>
    /* Allow Access to option bytes sector */
    HAL_FLASH_OB_Unlock();
 8004630:	f00a fdc8 	bl	800f1c4 <HAL_FLASH_OB_Unlock>
    /* Get the Dual boot configuration status */
    HAL_FLASHEx_OBGetConfig(&OBInit);
 8004634:	1d3b      	adds	r3, r7, #4
 8004636:	4618      	mov	r0, r3
 8004638:	f00a ff2e 	bl	800f498 <HAL_FLASHEx_OBGetConfig>
    if (((OBInit.USERConfig) & (OB_SWAP_BANK_ENABLE)) == OB_SWAP_BANK_ENABLE) {
 800463c:	6a3b      	ldr	r3, [r7, #32]
 800463e:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
 8004642:	2b00      	cmp	r3, #0
 8004644:	d029      	beq.n	800469a <User_Init+0x9a>
      CurrentActiveBank= 2;
 8004646:	4b38      	ldr	r3, [pc, #224]	@ (8004728 <User_Init+0x128>)
 8004648:	2202      	movs	r2, #2
 800464a:	601a      	str	r2, [r3, #0]
      MCR_HEART_BIT2();
 800464c:	2002      	movs	r0, #2
 800464e:	f000 fc2d 	bl	8004eac <BSP_LED_On>
 8004652:	2001      	movs	r0, #1
 8004654:	f000 fc2a 	bl	8004eac <BSP_LED_On>
 8004658:	20c8      	movs	r0, #200	@ 0xc8
 800465a:	f000 f8cf 	bl	80047fc <HAL_Delay>
 800465e:	2002      	movs	r0, #2
 8004660:	f000 fc3e 	bl	8004ee0 <BSP_LED_Off>
 8004664:	2001      	movs	r0, #1
 8004666:	f000 fc3b 	bl	8004ee0 <BSP_LED_Off>
 800466a:	f44f 70c8 	mov.w	r0, #400	@ 0x190
 800466e:	f000 f8c5 	bl	80047fc <HAL_Delay>
 8004672:	2002      	movs	r0, #2
 8004674:	f000 fc1a 	bl	8004eac <BSP_LED_On>
 8004678:	2001      	movs	r0, #1
 800467a:	f000 fc17 	bl	8004eac <BSP_LED_On>
 800467e:	20c8      	movs	r0, #200	@ 0xc8
 8004680:	f000 f8bc 	bl	80047fc <HAL_Delay>
 8004684:	2002      	movs	r0, #2
 8004686:	f000 fc2b 	bl	8004ee0 <BSP_LED_Off>
 800468a:	2001      	movs	r0, #1
 800468c:	f000 fc28 	bl	8004ee0 <BSP_LED_Off>
 8004690:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
 8004694:	f000 f8b2 	bl	80047fc <HAL_Delay>
 8004698:	e028      	b.n	80046ec <User_Init+0xec>
    } else {
      CurrentActiveBank= 1;
 800469a:	4b23      	ldr	r3, [pc, #140]	@ (8004728 <User_Init+0x128>)
 800469c:	2201      	movs	r2, #1
 800469e:	601a      	str	r2, [r3, #0]
      MCR_HEART_BIT();
 80046a0:	2002      	movs	r0, #2
 80046a2:	f000 fc03 	bl	8004eac <BSP_LED_On>
 80046a6:	2003      	movs	r0, #3
 80046a8:	f000 fc00 	bl	8004eac <BSP_LED_On>
 80046ac:	20c8      	movs	r0, #200	@ 0xc8
 80046ae:	f000 f8a5 	bl	80047fc <HAL_Delay>
 80046b2:	2002      	movs	r0, #2
 80046b4:	f000 fc14 	bl	8004ee0 <BSP_LED_Off>
 80046b8:	2003      	movs	r0, #3
 80046ba:	f000 fc11 	bl	8004ee0 <BSP_LED_Off>
 80046be:	f44f 70c8 	mov.w	r0, #400	@ 0x190
 80046c2:	f000 f89b 	bl	80047fc <HAL_Delay>
 80046c6:	2002      	movs	r0, #2
 80046c8:	f000 fbf0 	bl	8004eac <BSP_LED_On>
 80046cc:	2003      	movs	r0, #3
 80046ce:	f000 fbed 	bl	8004eac <BSP_LED_On>
 80046d2:	20c8      	movs	r0, #200	@ 0xc8
 80046d4:	f000 f892 	bl	80047fc <HAL_Delay>
 80046d8:	2002      	movs	r0, #2
 80046da:	f000 fc01 	bl	8004ee0 <BSP_LED_Off>
 80046de:	2003      	movs	r0, #3
 80046e0:	f000 fbfe 	bl	8004ee0 <BSP_LED_Off>
 80046e4:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
 80046e8:	f000 f888 	bl	80047fc <HAL_Delay>
    }
    HAL_FLASH_OB_Lock();
 80046ec:	f00a fd8c 	bl	800f208 <HAL_FLASH_OB_Lock>
    HAL_FLASH_Lock();
 80046f0:	f00a fd4e 	bl	800f190 <HAL_FLASH_Lock>
  }

  BSP_COM_Init(COM1);
 80046f4:	2000      	movs	r0, #0
 80046f6:	f000 fdd5 	bl	80052a4 <BSP_COM_Init>

  /* Check the board Type */
  FinishGood = BSP_CheckFinishGood();
 80046fa:	f000 f8d1 	bl	80048a0 <BSP_CheckFinishGood>
 80046fe:	4603      	mov	r3, r0
 8004700:	461a      	mov	r2, r3
 8004702:	4b0a      	ldr	r3, [pc, #40]	@ (800472c <User_Init+0x12c>)
 8004704:	701a      	strb	r2, [r3, #0]

  //Update the Current Fw ID saved in flash if it's neceessary
  if(FinishGood==FINISHA) {
 8004706:	4b09      	ldr	r3, [pc, #36]	@ (800472c <User_Init+0x12c>)
 8004708:	781b      	ldrb	r3, [r3, #0]
 800470a:	2b00      	cmp	r3, #0
 800470c:	d104      	bne.n	8004718 <User_Init+0x118>
    UpdateCurrFlashBankFwIdBoardName(STBOX1A_BLUEST_SDK_FW_ID,NULL);
 800470e:	2100      	movs	r1, #0
 8004710:	2032      	movs	r0, #50	@ 0x32
 8004712:	f7ff fbb5 	bl	8003e80 <UpdateCurrFlashBankFwIdBoardName>
    UpdateCurrFlashBankFwIdBoardName(STBOX1B_BLUEST_SDK_FW_ID,NULL);
  }

  /* Custom Code - Dante: Uncomment Below for original functionality */
  // InitTimers();
}
 8004716:	e003      	b.n	8004720 <User_Init+0x120>
    UpdateCurrFlashBankFwIdBoardName(STBOX1B_BLUEST_SDK_FW_ID,NULL);
 8004718:	2100      	movs	r1, #0
 800471a:	2012      	movs	r0, #18
 800471c:	f7ff fbb0 	bl	8003e80 <UpdateCurrFlashBankFwIdBoardName>
}
 8004720:	bf00      	nop
 8004722:	3738      	adds	r7, #56	@ 0x38
 8004724:	46bd      	mov	sp, r7
 8004726:	bd80      	pop	{r7, pc}
 8004728:	20000590 	.word	0x20000590
 800472c:	2000059a 	.word	0x2000059a

08004730 <BSP_PB_Callback>:
*
* @param  Button Specifies the pin connected EXTI line
* @retval None
*/
void BSP_PB_Callback(Button_TypeDef Button)
{
 8004730:	b480      	push	{r7}
 8004732:	b083      	sub	sp, #12
 8004734:	af00      	add	r7, sp, #0
 8004736:	4603      	mov	r3, r0
 8004738:	71fb      	strb	r3, [r7, #7]
  /* Set the User Button flag */
  user_button_pressed = 1;
 800473a:	4b04      	ldr	r3, [pc, #16]	@ (800474c <BSP_PB_Callback+0x1c>)
 800473c:	2201      	movs	r2, #1
 800473e:	601a      	str	r2, [r3, #0]
}
 8004740:	bf00      	nop
 8004742:	370c      	adds	r7, #12
 8004744:	46bd      	mov	sp, r7
 8004746:	f85d 7b04 	ldr.w	r7, [sp], #4
 800474a:	4770      	bx	lr
 800474c:	200005a0 	.word	0x200005a0

08004750 <PrintInfo>:
* @brief  Print Bunner
* @param  None
* @retval None
*/
static void PrintInfo(void)
{
 8004750:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004752:	b085      	sub	sp, #20
 8004754:	af04      	add	r7, sp, #16
  if(FinishGood==FINISH_ERROR) {
 8004756:	4b20      	ldr	r3, [pc, #128]	@ (80047d8 <PrintInfo+0x88>)
 8004758:	781b      	ldrb	r3, [r3, #0]
 800475a:	2b02      	cmp	r3, #2
 800475c:	d105      	bne.n	800476a <PrintInfo+0x1a>
   STBOX1_Error_Handler(STBOX1_ERROR_HW_INIT,__FILE__,__LINE__);
 800475e:	f240 3256 	movw	r2, #854	@ 0x356
 8004762:	491e      	ldr	r1, [pc, #120]	@ (80047dc <PrintInfo+0x8c>)
 8004764:	2004      	movs	r0, #4
 8004766:	f000 f861 	bl	800482c <STBOX1_Error_Handler>
  }

  STBOX1_PRINTF("\r\nSTMicroelectronics %s:\r\n"
 800476a:	4b1b      	ldr	r3, [pc, #108]	@ (80047d8 <PrintInfo+0x88>)
 800476c:	781b      	ldrb	r3, [r3, #0]
 800476e:	2b00      	cmp	r3, #0
 8004770:	d101      	bne.n	8004776 <PrintInfo+0x26>
 8004772:	2341      	movs	r3, #65	@ 0x41
 8004774:	e000      	b.n	8004778 <PrintInfo+0x28>
 8004776:	2342      	movs	r3, #66	@ 0x42
 8004778:	9301      	str	r3, [sp, #4]
 800477a:	2330      	movs	r3, #48	@ 0x30
 800477c:	9300      	str	r3, [sp, #0]
 800477e:	2330      	movs	r3, #48	@ 0x30
 8004780:	2232      	movs	r2, #50	@ 0x32
 8004782:	4917      	ldr	r1, [pc, #92]	@ (80047e0 <PrintInfo+0x90>)
 8004784:	4817      	ldr	r0, [pc, #92]	@ (80047e4 <PrintInfo+0x94>)
 8004786:	f01f fae9 	bl	8023d5c <iprintf>
              "\tSTM32U585AI-SensorTile.box-Pro (%c) board"
                "\r\n",
                STBOX1_PACKAGENAME,
                STBOX1_VERSION_MAJOR,STBOX1_VERSION_MINOR,STBOX1_VERSION_PATCH,
                  (FinishGood==FINISHA) ? 'A' : 'B');
  STBOX1_PRINTF("\t(HAL %ld.%ld.%ld_%ld)\r\n"
 800478a:	f009 f975 	bl	800da78 <HAL_GetHalVersion>
 800478e:	4603      	mov	r3, r0
 8004790:	0e1c      	lsrs	r4, r3, #24
 8004792:	f009 f971 	bl	800da78 <HAL_GetHalVersion>
 8004796:	4603      	mov	r3, r0
 8004798:	0c1b      	lsrs	r3, r3, #16
 800479a:	b2dd      	uxtb	r5, r3
 800479c:	f009 f96c 	bl	800da78 <HAL_GetHalVersion>
 80047a0:	4603      	mov	r3, r0
 80047a2:	0a1b      	lsrs	r3, r3, #8
 80047a4:	b2de      	uxtb	r6, r3
 80047a6:	f009 f967 	bl	800da78 <HAL_GetHalVersion>
 80047aa:	4603      	mov	r3, r0
 80047ac:	b2db      	uxtb	r3, r3
 80047ae:	4a0e      	ldr	r2, [pc, #56]	@ (80047e8 <PrintInfo+0x98>)
 80047b0:	9202      	str	r2, [sp, #8]
 80047b2:	4a0e      	ldr	r2, [pc, #56]	@ (80047ec <PrintInfo+0x9c>)
 80047b4:	9201      	str	r2, [sp, #4]
 80047b6:	9300      	str	r3, [sp, #0]
 80047b8:	4633      	mov	r3, r6
 80047ba:	462a      	mov	r2, r5
 80047bc:	4621      	mov	r1, r4
 80047be:	480c      	ldr	r0, [pc, #48]	@ (80047f0 <PrintInfo+0xa0>)
 80047c0:	f01f facc 	bl	8023d5c <iprintf>
              HAL_GetHalVersion() >>24,
              (HAL_GetHalVersion() >>16)&0xFF,
              (HAL_GetHalVersion() >> 8)&0xFF,
              HAL_GetHalVersion()      &0xFF,
              __DATE__,__TIME__);
   STBOX1_PRINTF("Current Bank =%ld\r\n",CurrentActiveBank);
 80047c4:	4b0b      	ldr	r3, [pc, #44]	@ (80047f4 <PrintInfo+0xa4>)
 80047c6:	681b      	ldr	r3, [r3, #0]
 80047c8:	4619      	mov	r1, r3
 80047ca:	480b      	ldr	r0, [pc, #44]	@ (80047f8 <PrintInfo+0xa8>)
 80047cc:	f01f fac6 	bl	8023d5c <iprintf>
}
 80047d0:	bf00      	nop
 80047d2:	3704      	adds	r7, #4
 80047d4:	46bd      	mov	sp, r7
 80047d6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80047d8:	2000059a 	.word	0x2000059a
 80047dc:	08027bf4 	.word	0x08027bf4
 80047e0:	08027d68 	.word	0x08027d68
 80047e4:	08027d78 	.word	0x08027d78
 80047e8:	08027e10 	.word	0x08027e10
 80047ec:	08027e1c 	.word	0x08027e1c
 80047f0:	08027dd4 	.word	0x08027dd4
 80047f4:	20000590 	.word	0x20000590
 80047f8:	08027e28 	.word	0x08027e28

080047fc <HAL_Delay>:
  * @note This is a user implementation using WFI state
  * @param Delay: specifies the delay time length, in milliseconds.
  * @retval None
  */
void HAL_Delay(__IO uint32_t Delay)
{
 80047fc:	b580      	push	{r7, lr}
 80047fe:	b084      	sub	sp, #16
 8004800:	af00      	add	r7, sp, #0
 8004802:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = 0;
 8004804:	2300      	movs	r3, #0
 8004806:	60fb      	str	r3, [r7, #12]
  tickstart = HAL_GetTick();
 8004808:	f009 f92a 	bl	800da60 <HAL_GetTick>
 800480c:	60f8      	str	r0, [r7, #12]
  while((HAL_GetTick() - tickstart) < Delay){
 800480e:	e000      	b.n	8004812 <HAL_Delay+0x16>
    __WFI();
 8004810:	bf30      	wfi
  while((HAL_GetTick() - tickstart) < Delay){
 8004812:	f009 f925 	bl	800da60 <HAL_GetTick>
 8004816:	4602      	mov	r2, r0
 8004818:	68fb      	ldr	r3, [r7, #12]
 800481a:	1ad2      	subs	r2, r2, r3
 800481c:	687b      	ldr	r3, [r7, #4]
 800481e:	429a      	cmp	r2, r3
 8004820:	d3f6      	bcc.n	8004810 <HAL_Delay+0x14>
  }
}
 8004822:	bf00      	nop
 8004824:	bf00      	nop
 8004826:	3710      	adds	r7, #16
 8004828:	46bd      	mov	sp, r7
 800482a:	bd80      	pop	{r7, pc}

0800482c <STBOX1_Error_Handler>:
  * @brief  This function is executed in case of error occurrence.
  * @param int32_t ErrorCode Error Code
  * @retval None
  */
void STBOX1_Error_Handler(int32_t ErrorCode,char *File,int32_t Line)
{
 800482c:	b580      	push	{r7, lr}
 800482e:	b086      	sub	sp, #24
 8004830:	af00      	add	r7, sp, #0
 8004832:	60f8      	str	r0, [r7, #12]
 8004834:	60b9      	str	r1, [r7, #8]
 8004836:	607a      	str	r2, [r7, #4]
  /* User can add his own implementation to report the HAL error return state */
  BSP_LED_Off(LED_RED);
 8004838:	2001      	movs	r0, #1
 800483a:	f000 fb51 	bl	8004ee0 <BSP_LED_Off>
  STBOX1_PRINTF("Error at %ld at %s\r\n",Line,File);
 800483e:	68ba      	ldr	r2, [r7, #8]
 8004840:	6879      	ldr	r1, [r7, #4]
 8004842:	4816      	ldr	r0, [pc, #88]	@ (800489c <STBOX1_Error_Handler+0x70>)
 8004844:	f01f fa8a 	bl	8023d5c <iprintf>
  while (1){
    int count;
    for(count=0;count<ErrorCode;count++) {
 8004848:	2300      	movs	r3, #0
 800484a:	617b      	str	r3, [r7, #20]
 800484c:	e010      	b.n	8004870 <STBOX1_Error_Handler+0x44>
      BSP_LED_On(LED_RED);
 800484e:	2001      	movs	r0, #1
 8004850:	f000 fb2c 	bl	8004eac <BSP_LED_On>
      HAL_Delay(500);
 8004854:	f44f 70fa 	mov.w	r0, #500	@ 0x1f4
 8004858:	f7ff ffd0 	bl	80047fc <HAL_Delay>
      BSP_LED_Off(LED_RED);
 800485c:	2001      	movs	r0, #1
 800485e:	f000 fb3f 	bl	8004ee0 <BSP_LED_Off>
      HAL_Delay(2000);
 8004862:	f44f 60fa 	mov.w	r0, #2000	@ 0x7d0
 8004866:	f7ff ffc9 	bl	80047fc <HAL_Delay>
    for(count=0;count<ErrorCode;count++) {
 800486a:	697b      	ldr	r3, [r7, #20]
 800486c:	3301      	adds	r3, #1
 800486e:	617b      	str	r3, [r7, #20]
 8004870:	697a      	ldr	r2, [r7, #20]
 8004872:	68fb      	ldr	r3, [r7, #12]
 8004874:	429a      	cmp	r2, r3
 8004876:	dbea      	blt.n	800484e <STBOX1_Error_Handler+0x22>
    }
    BSP_LED_On(LED_GREEN);
 8004878:	2003      	movs	r0, #3
 800487a:	f000 fb17 	bl	8004eac <BSP_LED_On>
    BSP_LED_On(LED_YELLOW);
 800487e:	2002      	movs	r0, #2
 8004880:	f000 fb14 	bl	8004eac <BSP_LED_On>
    HAL_Delay(2000);
 8004884:	f44f 60fa 	mov.w	r0, #2000	@ 0x7d0
 8004888:	f7ff ffb8 	bl	80047fc <HAL_Delay>
    BSP_LED_Off(LED_GREEN);
 800488c:	2003      	movs	r0, #3
 800488e:	f000 fb27 	bl	8004ee0 <BSP_LED_Off>
    BSP_LED_Off(LED_YELLOW);
 8004892:	2002      	movs	r0, #2
 8004894:	f000 fb24 	bl	8004ee0 <BSP_LED_Off>
  while (1){
 8004898:	e7d6      	b.n	8004848 <STBOX1_Error_Handler+0x1c>
 800489a:	bf00      	nop
 800489c:	08027e3c 	.word	0x08027e3c

080048a0 <BSP_CheckFinishGood>:

/**
 * @brief  This method the Finish Good type
 * @retval FinishGood value
 */
FinishGood_TypeDef BSP_CheckFinishGood(void) {
 80048a0:	b580      	push	{r7, lr}
 80048a2:	b082      	sub	sp, #8
 80048a4:	af00      	add	r7, sp, #0
  /* @brief ST25DV 4Kbits ICref */
  #define IAM_ST25DV04                        0x24
  /* @brief ST25DV 16/64Kbits ICref */
  #define IAM_ST25DV64                        0x26

  FinishGood_TypeDef FinishGood = FINISH_ERROR;
 80048a6:	2302      	movs	r3, #2
 80048a8:	71fb      	strb	r3, [r7, #7]
  uint8_t nfctag_id;
  BSP_ST25DV_I2C_INIT();
 80048aa:	f000 fe0b 	bl	80054c4 <BSP_I2C2_Init>

  BSP_ST25DV_I2C_READ_REG_16(ST25_ADDR_DATA_I2C, ST25_ICREF_REG, &nfctag_id, 1);
 80048ae:	1dba      	adds	r2, r7, #6
 80048b0:	2301      	movs	r3, #1
 80048b2:	2117      	movs	r1, #23
 80048b4:	20ae      	movs	r0, #174	@ 0xae
 80048b6:	f000 fe6b 	bl	8005590 <BSP_I2C2_ReadReg16>

  if((nfctag_id == IAM_ST25DV04KC) | (nfctag_id == IAM_ST25DV64KC)) {
 80048ba:	79bb      	ldrb	r3, [r7, #6]
 80048bc:	2b50      	cmp	r3, #80	@ 0x50
 80048be:	bf0c      	ite	eq
 80048c0:	2301      	moveq	r3, #1
 80048c2:	2300      	movne	r3, #0
 80048c4:	b2da      	uxtb	r2, r3
 80048c6:	79bb      	ldrb	r3, [r7, #6]
 80048c8:	2b51      	cmp	r3, #81	@ 0x51
 80048ca:	bf0c      	ite	eq
 80048cc:	2301      	moveq	r3, #1
 80048ce:	2300      	movne	r3, #0
 80048d0:	b2db      	uxtb	r3, r3
 80048d2:	4313      	orrs	r3, r2
 80048d4:	b2db      	uxtb	r3, r3
 80048d6:	2b00      	cmp	r3, #0
 80048d8:	d002      	beq.n	80048e0 <BSP_CheckFinishGood+0x40>
    FinishGood = FINISHB;
 80048da:	2301      	movs	r3, #1
 80048dc:	71fb      	strb	r3, [r7, #7]
 80048de:	e011      	b.n	8004904 <BSP_CheckFinishGood+0x64>
  } else if((nfctag_id == IAM_ST25DV04) | (nfctag_id == IAM_ST25DV64)) {
 80048e0:	79bb      	ldrb	r3, [r7, #6]
 80048e2:	2b24      	cmp	r3, #36	@ 0x24
 80048e4:	bf0c      	ite	eq
 80048e6:	2301      	moveq	r3, #1
 80048e8:	2300      	movne	r3, #0
 80048ea:	b2da      	uxtb	r2, r3
 80048ec:	79bb      	ldrb	r3, [r7, #6]
 80048ee:	2b26      	cmp	r3, #38	@ 0x26
 80048f0:	bf0c      	ite	eq
 80048f2:	2301      	moveq	r3, #1
 80048f4:	2300      	movne	r3, #0
 80048f6:	b2db      	uxtb	r3, r3
 80048f8:	4313      	orrs	r3, r2
 80048fa:	b2db      	uxtb	r3, r3
 80048fc:	2b00      	cmp	r3, #0
 80048fe:	d001      	beq.n	8004904 <BSP_CheckFinishGood+0x64>
    FinishGood = FINISHA;
 8004900:	2300      	movs	r3, #0
 8004902:	71fb      	strb	r3, [r7, #7]
  }

  BSP_ST25DV_I2C_DEINIT();
 8004904:	f000 fe1c 	bl	8005540 <BSP_I2C2_DeInit>
  #undef IAM_ST25DV04KC
  #undef IAM_ST25DV64KC
  #undef IAM_ST25DV04
  #undef IAM_ST25DV64

  return FinishGood;
 8004908:	79fb      	ldrb	r3, [r7, #7]
}
 800490a:	4618      	mov	r0, r3
 800490c:	3708      	adds	r7, #8
 800490e:	46bd      	mov	sp, r7
 8004910:	bd80      	pop	{r7, pc}

08004912 <HCI_TL_SPI_Enable_IRQ>:
  * @brief  Enable SPI IRQ.
  * @param  None
  * @retval None
  */
static void HCI_TL_SPI_Enable_IRQ(void)
{
 8004912:	b580      	push	{r7, lr}
 8004914:	af00      	add	r7, sp, #0
  HAL_NVIC_EnableIRQ(HCI_TL_SPI_EXTI_IRQn);
 8004916:	2016      	movs	r0, #22
 8004918:	f009 f9c5 	bl	800dca6 <HAL_NVIC_EnableIRQ>
}
 800491c:	bf00      	nop
 800491e:	bd80      	pop	{r7, pc}

08004920 <HCI_TL_SPI_Disable_IRQ>:
  * @brief  Disable SPI IRQ.
  * @param  None
  * @retval None
  */
static void HCI_TL_SPI_Disable_IRQ(void)
{
 8004920:	b580      	push	{r7, lr}
 8004922:	af00      	add	r7, sp, #0
  HAL_NVIC_DisableIRQ(HCI_TL_SPI_EXTI_IRQn);
 8004924:	2016      	movs	r0, #22
 8004926:	f009 f9cc 	bl	800dcc2 <HAL_NVIC_DisableIRQ>
}
 800492a:	bf00      	nop
 800492c:	bd80      	pop	{r7, pc}
	...

08004930 <HCI_TL_SPI_Init>:
  *
  * @param  void* Pointer to configuration struct
  * @retval int32_t Status
  */
int32_t HCI_TL_SPI_Init(void *pConf)
{
 8004930:	b580      	push	{r7, lr}
 8004932:	b08a      	sub	sp, #40	@ 0x28
 8004934:	af00      	add	r7, sp, #0
 8004936:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct;

  BUS_EXTI_GPIO_CLK_ENABLE();
 8004938:	4b30      	ldr	r3, [pc, #192]	@ (80049fc <HCI_TL_SPI_Init+0xcc>)
 800493a:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800493e:	4a2f      	ldr	r2, [pc, #188]	@ (80049fc <HCI_TL_SPI_Init+0xcc>)
 8004940:	f043 0302 	orr.w	r3, r3, #2
 8004944:	f8c2 308c 	str.w	r3, [r2, #140]	@ 0x8c
 8004948:	4b2c      	ldr	r3, [pc, #176]	@ (80049fc <HCI_TL_SPI_Init+0xcc>)
 800494a:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800494e:	f003 0302 	and.w	r3, r3, #2
 8004952:	613b      	str	r3, [r7, #16]
 8004954:	693b      	ldr	r3, [r7, #16]
  BUS_CS_GPIO_CLK_ENABLE();
 8004956:	4b29      	ldr	r3, [pc, #164]	@ (80049fc <HCI_TL_SPI_Init+0xcc>)
 8004958:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800495c:	4a27      	ldr	r2, [pc, #156]	@ (80049fc <HCI_TL_SPI_Init+0xcc>)
 800495e:	f043 0301 	orr.w	r3, r3, #1
 8004962:	f8c2 308c 	str.w	r3, [r2, #140]	@ 0x8c
 8004966:	4b25      	ldr	r3, [pc, #148]	@ (80049fc <HCI_TL_SPI_Init+0xcc>)
 8004968:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800496c:	f003 0301 	and.w	r3, r3, #1
 8004970:	60fb      	str	r3, [r7, #12]
 8004972:	68fb      	ldr	r3, [r7, #12]
  BUS_RST_GPIO_CLK_ENABLE();
 8004974:	4b21      	ldr	r3, [pc, #132]	@ (80049fc <HCI_TL_SPI_Init+0xcc>)
 8004976:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800497a:	4a20      	ldr	r2, [pc, #128]	@ (80049fc <HCI_TL_SPI_Init+0xcc>)
 800497c:	f043 0308 	orr.w	r3, r3, #8
 8004980:	f8c2 308c 	str.w	r3, [r2, #140]	@ 0x8c
 8004984:	4b1d      	ldr	r3, [pc, #116]	@ (80049fc <HCI_TL_SPI_Init+0xcc>)
 8004986:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800498a:	f003 0308 	and.w	r3, r3, #8
 800498e:	60bb      	str	r3, [r7, #8]
 8004990:	68bb      	ldr	r3, [r7, #8]

  /* Configure EXTI Line */
  GPIO_InitStruct.Pin = HCI_TL_SPI_EXTI_PIN;
 8004992:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 8004996:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
 8004998:	4b19      	ldr	r3, [pc, #100]	@ (8004a00 <HCI_TL_SPI_Init+0xd0>)
 800499a:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800499c:	2300      	movs	r3, #0
 800499e:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(HCI_TL_SPI_EXTI_PORT, &GPIO_InitStruct);
 80049a0:	f107 0314 	add.w	r3, r7, #20
 80049a4:	4619      	mov	r1, r3
 80049a6:	4817      	ldr	r0, [pc, #92]	@ (8004a04 <HCI_TL_SPI_Init+0xd4>)
 80049a8:	f00a fedc 	bl	800f764 <HAL_GPIO_Init>

  /* Configure RESET Line */
  GPIO_InitStruct.Pin =  HCI_TL_RST_PIN ;
 80049ac:	2310      	movs	r3, #16
 80049ae:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80049b0:	2301      	movs	r3, #1
 80049b2:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80049b4:	2300      	movs	r3, #0
 80049b6:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80049b8:	2300      	movs	r3, #0
 80049ba:	623b      	str	r3, [r7, #32]
  HAL_GPIO_Init(HCI_TL_RST_PORT, &GPIO_InitStruct);
 80049bc:	f107 0314 	add.w	r3, r7, #20
 80049c0:	4619      	mov	r1, r3
 80049c2:	4811      	ldr	r0, [pc, #68]	@ (8004a08 <HCI_TL_SPI_Init+0xd8>)
 80049c4:	f00a fece 	bl	800f764 <HAL_GPIO_Init>

  /* Configure CS */
  GPIO_InitStruct.Pin = HCI_TL_SPI_CS_PIN ;
 80049c8:	2304      	movs	r3, #4
 80049ca:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80049cc:	2301      	movs	r3, #1
 80049ce:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80049d0:	2300      	movs	r3, #0
 80049d2:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80049d4:	2300      	movs	r3, #0
 80049d6:	623b      	str	r3, [r7, #32]
  HAL_GPIO_Init(HCI_TL_SPI_CS_PORT, &GPIO_InitStruct);
 80049d8:	f107 0314 	add.w	r3, r7, #20
 80049dc:	4619      	mov	r1, r3
 80049de:	480b      	ldr	r0, [pc, #44]	@ (8004a0c <HCI_TL_SPI_Init+0xdc>)
 80049e0:	f00a fec0 	bl	800f764 <HAL_GPIO_Init>
  /* Deselect CS PIN for BlueNRG at startup to avoid spurious commands */
  HAL_GPIO_WritePin(HCI_TL_SPI_CS_PORT, HCI_TL_SPI_CS_PIN, GPIO_PIN_SET);
 80049e4:	2201      	movs	r2, #1
 80049e6:	2104      	movs	r1, #4
 80049e8:	4808      	ldr	r0, [pc, #32]	@ (8004a0c <HCI_TL_SPI_Init+0xdc>)
 80049ea:	f00b f989 	bl	800fd00 <HAL_GPIO_WritePin>

  return BSP_SPI1_Init();
 80049ee:	f000 fea3 	bl	8005738 <BSP_SPI1_Init>
 80049f2:	4603      	mov	r3, r0
}
 80049f4:	4618      	mov	r0, r3
 80049f6:	3728      	adds	r7, #40	@ 0x28
 80049f8:	46bd      	mov	sp, r7
 80049fa:	bd80      	pop	{r7, pc}
 80049fc:	46020c00 	.word	0x46020c00
 8004a00:	10110000 	.word	0x10110000
 8004a04:	42020400 	.word	0x42020400
 8004a08:	42020c00 	.word	0x42020c00
 8004a0c:	42020000 	.word	0x42020000

08004a10 <HCI_TL_SPI_DeInit>:
  *
  * @param  None
  * @retval int32_t 0
  */
int32_t HCI_TL_SPI_DeInit(void)
{
 8004a10:	b580      	push	{r7, lr}
 8004a12:	af00      	add	r7, sp, #0
  HAL_GPIO_DeInit(HCI_TL_SPI_EXTI_PORT, HCI_TL_SPI_EXTI_PIN);
 8004a14:	f44f 6100 	mov.w	r1, #2048	@ 0x800
 8004a18:	4806      	ldr	r0, [pc, #24]	@ (8004a34 <HCI_TL_SPI_DeInit+0x24>)
 8004a1a:	f00b f87b 	bl	800fb14 <HAL_GPIO_DeInit>
  HAL_GPIO_DeInit(HCI_TL_SPI_CS_PORT, HCI_TL_SPI_CS_PIN);
 8004a1e:	2104      	movs	r1, #4
 8004a20:	4805      	ldr	r0, [pc, #20]	@ (8004a38 <HCI_TL_SPI_DeInit+0x28>)
 8004a22:	f00b f877 	bl	800fb14 <HAL_GPIO_DeInit>
  HAL_GPIO_DeInit(HCI_TL_RST_PORT, HCI_TL_RST_PIN);
 8004a26:	2110      	movs	r1, #16
 8004a28:	4804      	ldr	r0, [pc, #16]	@ (8004a3c <HCI_TL_SPI_DeInit+0x2c>)
 8004a2a:	f00b f873 	bl	800fb14 <HAL_GPIO_DeInit>
  return 0;
 8004a2e:	2300      	movs	r3, #0
}
 8004a30:	4618      	mov	r0, r3
 8004a32:	bd80      	pop	{r7, pc}
 8004a34:	42020400 	.word	0x42020400
 8004a38:	42020000 	.word	0x42020000
 8004a3c:	42020c00 	.word	0x42020c00

08004a40 <HCI_TL_SPI_Reset>:
  *
  * @param  None
  * @retval int32_t 0
  */
int32_t HCI_TL_SPI_Reset(void)
{
 8004a40:	b580      	push	{r7, lr}
 8004a42:	af00      	add	r7, sp, #0
  /* Deselect CS PIN for BlueNRG to avoid spurious commands */
  HAL_GPIO_WritePin(HCI_TL_SPI_CS_PORT, HCI_TL_SPI_CS_PIN, GPIO_PIN_SET);
 8004a44:	2201      	movs	r2, #1
 8004a46:	2104      	movs	r1, #4
 8004a48:	480a      	ldr	r0, [pc, #40]	@ (8004a74 <HCI_TL_SPI_Reset+0x34>)
 8004a4a:	f00b f959 	bl	800fd00 <HAL_GPIO_WritePin>

  HAL_GPIO_WritePin(HCI_TL_RST_PORT, HCI_TL_RST_PIN, GPIO_PIN_RESET);
 8004a4e:	2200      	movs	r2, #0
 8004a50:	2110      	movs	r1, #16
 8004a52:	4809      	ldr	r0, [pc, #36]	@ (8004a78 <HCI_TL_SPI_Reset+0x38>)
 8004a54:	f00b f954 	bl	800fd00 <HAL_GPIO_WritePin>
  HAL_Delay(5);
 8004a58:	2005      	movs	r0, #5
 8004a5a:	f7ff fecf 	bl	80047fc <HAL_Delay>
  HAL_GPIO_WritePin(HCI_TL_RST_PORT, HCI_TL_RST_PIN, GPIO_PIN_SET);
 8004a5e:	2201      	movs	r2, #1
 8004a60:	2110      	movs	r1, #16
 8004a62:	4805      	ldr	r0, [pc, #20]	@ (8004a78 <HCI_TL_SPI_Reset+0x38>)
 8004a64:	f00b f94c 	bl	800fd00 <HAL_GPIO_WritePin>
  HAL_Delay(150);
 8004a68:	2096      	movs	r0, #150	@ 0x96
 8004a6a:	f7ff fec7 	bl	80047fc <HAL_Delay>
  return 0;
 8004a6e:	2300      	movs	r3, #0
}
 8004a70:	4618      	mov	r0, r3
 8004a72:	bd80      	pop	{r7, pc}
 8004a74:	42020000 	.word	0x42020000
 8004a78:	42020c00 	.word	0x42020c00

08004a7c <HCI_TL_SPI_Receive>:
  * @param  buffer : Buffer where data from SPI are stored
  * @param  size   : Buffer size
  * @retval int32_t: Number of read bytes
  */
int32_t HCI_TL_SPI_Receive(uint8_t *buffer, uint16_t size)
{
 8004a7c:	b580      	push	{r7, lr}
 8004a7e:	b088      	sub	sp, #32
 8004a80:	af00      	add	r7, sp, #0
 8004a82:	6078      	str	r0, [r7, #4]
 8004a84:	460b      	mov	r3, r1
 8004a86:	807b      	strh	r3, [r7, #2]
  uint16_t byte_count;
  uint16_t len = 0;
 8004a88:	2300      	movs	r3, #0
 8004a8a:	83bb      	strh	r3, [r7, #28]
  uint8_t char_00 = 0x00;
 8004a8c:	2300      	movs	r3, #0
 8004a8e:	75fb      	strb	r3, [r7, #23]
  volatile uint8_t read_char;

  uint8_t header_master[HEADER_SIZE] = {0x0b, 0x00, 0x00, 0x00, 0x00};
 8004a90:	230b      	movs	r3, #11
 8004a92:	613b      	str	r3, [r7, #16]
 8004a94:	2300      	movs	r3, #0
 8004a96:	753b      	strb	r3, [r7, #20]
  uint8_t header_slave[HEADER_SIZE];

  if (HAL_GPIO_ReadPin(HCI_TL_SPI_IRQ_PORT, HCI_TL_SPI_IRQ_PIN) != GPIO_PIN_SET)
 8004a98:	f44f 6100 	mov.w	r1, #2048	@ 0x800
 8004a9c:	4831      	ldr	r0, [pc, #196]	@ (8004b64 <HCI_TL_SPI_Receive+0xe8>)
 8004a9e:	f00b f917 	bl	800fcd0 <HAL_GPIO_ReadPin>
 8004aa2:	4603      	mov	r3, r0
 8004aa4:	2b01      	cmp	r3, #1
 8004aa6:	d001      	beq.n	8004aac <HCI_TL_SPI_Receive+0x30>
  {
    return 0;
 8004aa8:	2300      	movs	r3, #0
 8004aaa:	e056      	b.n	8004b5a <HCI_TL_SPI_Receive+0xde>
  }

  HCI_TL_SPI_Disable_IRQ();
 8004aac:	f7ff ff38 	bl	8004920 <HCI_TL_SPI_Disable_IRQ>

  /* CS reset */
  HAL_GPIO_WritePin(HCI_TL_SPI_CS_PORT, HCI_TL_SPI_CS_PIN, GPIO_PIN_RESET);
 8004ab0:	2200      	movs	r2, #0
 8004ab2:	2104      	movs	r1, #4
 8004ab4:	482c      	ldr	r0, [pc, #176]	@ (8004b68 <HCI_TL_SPI_Receive+0xec>)
 8004ab6:	f00b f923 	bl	800fd00 <HAL_GPIO_WritePin>

  /* Read the header */
  BSP_SPI1_SendRecv(header_master, header_slave, HEADER_SIZE);
 8004aba:	f107 0108 	add.w	r1, r7, #8
 8004abe:	f107 0310 	add.w	r3, r7, #16
 8004ac2:	2205      	movs	r2, #5
 8004ac4:	4618      	mov	r0, r3
 8004ac6:	f000 fe67 	bl	8005798 <BSP_SPI1_SendRecv>

  /* device is ready */
  byte_count = (header_slave[4] << 8) | header_slave[3];
 8004aca:	7b3b      	ldrb	r3, [r7, #12]
 8004acc:	b21b      	sxth	r3, r3
 8004ace:	021b      	lsls	r3, r3, #8
 8004ad0:	b21a      	sxth	r2, r3
 8004ad2:	7afb      	ldrb	r3, [r7, #11]
 8004ad4:	b21b      	sxth	r3, r3
 8004ad6:	4313      	orrs	r3, r2
 8004ad8:	b21b      	sxth	r3, r3
 8004ada:	83fb      	strh	r3, [r7, #30]

  if (byte_count > 0)
 8004adc:	8bfb      	ldrh	r3, [r7, #30]
 8004ade:	2b00      	cmp	r3, #0
 8004ae0:	d01d      	beq.n	8004b1e <HCI_TL_SPI_Receive+0xa2>
  {
    /* avoid to read more data than the size of the buffer */
    if (byte_count > size)
 8004ae2:	8bfa      	ldrh	r2, [r7, #30]
 8004ae4:	887b      	ldrh	r3, [r7, #2]
 8004ae6:	429a      	cmp	r2, r3
 8004ae8:	d901      	bls.n	8004aee <HCI_TL_SPI_Receive+0x72>
    {
      byte_count = size;
 8004aea:	887b      	ldrh	r3, [r7, #2]
 8004aec:	83fb      	strh	r3, [r7, #30]
    }

    for (len = 0; len < byte_count; len++)
 8004aee:	2300      	movs	r3, #0
 8004af0:	83bb      	strh	r3, [r7, #28]
 8004af2:	e010      	b.n	8004b16 <HCI_TL_SPI_Receive+0x9a>
    {
      BSP_SPI1_SendRecv(&char_00, (uint8_t *)&read_char, 1);
 8004af4:	f107 0116 	add.w	r1, r7, #22
 8004af8:	f107 0317 	add.w	r3, r7, #23
 8004afc:	2201      	movs	r2, #1
 8004afe:	4618      	mov	r0, r3
 8004b00:	f000 fe4a 	bl	8005798 <BSP_SPI1_SendRecv>
      buffer[len] = read_char;
 8004b04:	8bbb      	ldrh	r3, [r7, #28]
 8004b06:	687a      	ldr	r2, [r7, #4]
 8004b08:	4413      	add	r3, r2
 8004b0a:	7dba      	ldrb	r2, [r7, #22]
 8004b0c:	b2d2      	uxtb	r2, r2
 8004b0e:	701a      	strb	r2, [r3, #0]
    for (len = 0; len < byte_count; len++)
 8004b10:	8bbb      	ldrh	r3, [r7, #28]
 8004b12:	3301      	adds	r3, #1
 8004b14:	83bb      	strh	r3, [r7, #28]
 8004b16:	8bba      	ldrh	r2, [r7, #28]
 8004b18:	8bfb      	ldrh	r3, [r7, #30]
 8004b1a:	429a      	cmp	r2, r3
 8004b1c:	d3ea      	bcc.n	8004af4 <HCI_TL_SPI_Receive+0x78>
  /**
    * To be aligned to the SPI protocol.
    * Can bring to a delay inside the frame, due to the BlueNRG that needs
    * to check if the header is received or not.
    */
  uint32_t tickstart = HAL_GetTick();
 8004b1e:	f008 ff9f 	bl	800da60 <HAL_GetTick>
 8004b22:	61b8      	str	r0, [r7, #24]
  while ((HAL_GetTick() - tickstart) < TIMEOUT_IRQ_HIGH)
 8004b24:	e007      	b.n	8004b36 <HCI_TL_SPI_Receive+0xba>
  {
    if (HAL_GPIO_ReadPin(HCI_TL_SPI_IRQ_PORT, HCI_TL_SPI_IRQ_PIN)==GPIO_PIN_RESET)
 8004b26:	f44f 6100 	mov.w	r1, #2048	@ 0x800
 8004b2a:	480e      	ldr	r0, [pc, #56]	@ (8004b64 <HCI_TL_SPI_Receive+0xe8>)
 8004b2c:	f00b f8d0 	bl	800fcd0 <HAL_GPIO_ReadPin>
 8004b30:	4603      	mov	r3, r0
 8004b32:	2b00      	cmp	r3, #0
 8004b34:	d008      	beq.n	8004b48 <HCI_TL_SPI_Receive+0xcc>
  while ((HAL_GetTick() - tickstart) < TIMEOUT_IRQ_HIGH)
 8004b36:	f008 ff93 	bl	800da60 <HAL_GetTick>
 8004b3a:	4602      	mov	r2, r0
 8004b3c:	69bb      	ldr	r3, [r7, #24]
 8004b3e:	1ad3      	subs	r3, r2, r3
 8004b40:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 8004b44:	d3ef      	bcc.n	8004b26 <HCI_TL_SPI_Receive+0xaa>
 8004b46:	e000      	b.n	8004b4a <HCI_TL_SPI_Receive+0xce>
    {
      break;
 8004b48:	bf00      	nop
    }
  }

  HCI_TL_SPI_Enable_IRQ();
 8004b4a:	f7ff fee2 	bl	8004912 <HCI_TL_SPI_Enable_IRQ>

  /* Release CS line */
  HAL_GPIO_WritePin(HCI_TL_SPI_CS_PORT, HCI_TL_SPI_CS_PIN, GPIO_PIN_SET);
 8004b4e:	2201      	movs	r2, #1
 8004b50:	2104      	movs	r1, #4
 8004b52:	4805      	ldr	r0, [pc, #20]	@ (8004b68 <HCI_TL_SPI_Receive+0xec>)
 8004b54:	f00b f8d4 	bl	800fd00 <HAL_GPIO_WritePin>

  return len;
 8004b58:	8bbb      	ldrh	r3, [r7, #28]
}
 8004b5a:	4618      	mov	r0, r3
 8004b5c:	3720      	adds	r7, #32
 8004b5e:	46bd      	mov	sp, r7
 8004b60:	bd80      	pop	{r7, pc}
 8004b62:	bf00      	nop
 8004b64:	42020400 	.word	0x42020400
 8004b68:	42020000 	.word	0x42020000

08004b6c <HCI_TL_SPI_Send>:
  * @param  buffer : data buffer to be written
  * @param  size   : size of first data buffer to be written
  * @retval int32_t: Number of read bytes
  */
int32_t HCI_TL_SPI_Send(uint8_t *buffer, uint16_t size)
{
 8004b6c:	b580      	push	{r7, lr}
 8004b6e:	b08a      	sub	sp, #40	@ 0x28
 8004b70:	af00      	add	r7, sp, #0
 8004b72:	6078      	str	r0, [r7, #4]
 8004b74:	460b      	mov	r3, r1
 8004b76:	807b      	strh	r3, [r7, #2]
  int32_t result;
  uint16_t rx_bytes;

  uint8_t header_master[HEADER_SIZE] = {0x0a, 0x00, 0x00, 0x00, 0x00};
 8004b78:	230a      	movs	r3, #10
 8004b7a:	617b      	str	r3, [r7, #20]
 8004b7c:	2300      	movs	r3, #0
 8004b7e:	763b      	strb	r3, [r7, #24]
  uint8_t header_slave[HEADER_SIZE];

  static uint8_t read_char_buf[MAX_BUFFER_SIZE];
  uint32_t tickstart = HAL_GetTick();
 8004b80:	f008 ff6e 	bl	800da60 <HAL_GetTick>
 8004b84:	6238      	str	r0, [r7, #32]

  HCI_TL_SPI_Disable_IRQ();
 8004b86:	f7ff fecb 	bl	8004920 <HCI_TL_SPI_Disable_IRQ>

  do
  {
    uint32_t tickstart_data_available = HAL_GetTick();
 8004b8a:	f008 ff69 	bl	800da60 <HAL_GetTick>
 8004b8e:	61f8      	str	r0, [r7, #28]

    result = 0;
 8004b90:	2300      	movs	r3, #0
 8004b92:	627b      	str	r3, [r7, #36]	@ 0x24

    /* CS reset */
    HAL_GPIO_WritePin(HCI_TL_SPI_CS_PORT, HCI_TL_SPI_CS_PIN, GPIO_PIN_RESET);
 8004b94:	2200      	movs	r2, #0
 8004b96:	2104      	movs	r1, #4
 8004b98:	4836      	ldr	r0, [pc, #216]	@ (8004c74 <HCI_TL_SPI_Send+0x108>)
 8004b9a:	f00b f8b1 	bl	800fd00 <HAL_GPIO_WritePin>

    /*
     * Wait until BlueNRG-LP is ready.
     * When ready it will raise the IRQ pin.
     */
    while (!IsDataAvailable())
 8004b9e:	e00a      	b.n	8004bb6 <HCI_TL_SPI_Send+0x4a>
    {
      if ((HAL_GetTick() - tickstart_data_available) > TIMEOUT_DURATION)
 8004ba0:	f008 ff5e 	bl	800da60 <HAL_GetTick>
 8004ba4:	4602      	mov	r2, r0
 8004ba6:	69fb      	ldr	r3, [r7, #28]
 8004ba8:	1ad3      	subs	r3, r2, r3
 8004baa:	2b0f      	cmp	r3, #15
 8004bac:	d903      	bls.n	8004bb6 <HCI_TL_SPI_Send+0x4a>
      {
        result = -3;
 8004bae:	f06f 0302 	mvn.w	r3, #2
 8004bb2:	627b      	str	r3, [r7, #36]	@ 0x24
        break;
 8004bb4:	e004      	b.n	8004bc0 <HCI_TL_SPI_Send+0x54>
    while (!IsDataAvailable())
 8004bb6:	f000 f863 	bl	8004c80 <IsDataAvailable>
 8004bba:	4603      	mov	r3, r0
 8004bbc:	2b00      	cmp	r3, #0
 8004bbe:	d0ef      	beq.n	8004ba0 <HCI_TL_SPI_Send+0x34>
      }
    }
    if (result == -3)
 8004bc0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8004bc2:	f113 0f03 	cmn.w	r3, #3
 8004bc6:	d105      	bne.n	8004bd4 <HCI_TL_SPI_Send+0x68>
    {
      /* The break causes the exiting from the "while", so the CS line must be released */
      HAL_GPIO_WritePin(HCI_TL_SPI_CS_PORT, HCI_TL_SPI_CS_PIN, GPIO_PIN_SET);
 8004bc8:	2201      	movs	r2, #1
 8004bca:	2104      	movs	r1, #4
 8004bcc:	4829      	ldr	r0, [pc, #164]	@ (8004c74 <HCI_TL_SPI_Send+0x108>)
 8004bce:	f00b f897 	bl	800fd00 <HAL_GPIO_WritePin>
      break;
 8004bd2:	e031      	b.n	8004c38 <HCI_TL_SPI_Send+0xcc>
    }

    /* Read header */
    BSP_SPI1_SendRecv(header_master, header_slave, HEADER_SIZE);
 8004bd4:	f107 010c 	add.w	r1, r7, #12
 8004bd8:	f107 0314 	add.w	r3, r7, #20
 8004bdc:	2205      	movs	r2, #5
 8004bde:	4618      	mov	r0, r3
 8004be0:	f000 fdda 	bl	8005798 <BSP_SPI1_SendRecv>

    rx_bytes = (((uint16_t)header_slave[2]) << 8) | ((uint16_t)header_slave[1]);
 8004be4:	7bbb      	ldrb	r3, [r7, #14]
 8004be6:	b21b      	sxth	r3, r3
 8004be8:	021b      	lsls	r3, r3, #8
 8004bea:	b21a      	sxth	r2, r3
 8004bec:	7b7b      	ldrb	r3, [r7, #13]
 8004bee:	b21b      	sxth	r3, r3
 8004bf0:	4313      	orrs	r3, r2
 8004bf2:	b21b      	sxth	r3, r3
 8004bf4:	837b      	strh	r3, [r7, #26]

    if (rx_bytes >= size)
 8004bf6:	8b7a      	ldrh	r2, [r7, #26]
 8004bf8:	887b      	ldrh	r3, [r7, #2]
 8004bfa:	429a      	cmp	r2, r3
 8004bfc:	d306      	bcc.n	8004c0c <HCI_TL_SPI_Send+0xa0>
    {
      /* Buffer is big enough */
      BSP_SPI1_SendRecv(buffer, read_char_buf, size);
 8004bfe:	887b      	ldrh	r3, [r7, #2]
 8004c00:	461a      	mov	r2, r3
 8004c02:	491d      	ldr	r1, [pc, #116]	@ (8004c78 <HCI_TL_SPI_Send+0x10c>)
 8004c04:	6878      	ldr	r0, [r7, #4]
 8004c06:	f000 fdc7 	bl	8005798 <BSP_SPI1_SendRecv>
 8004c0a:	e002      	b.n	8004c12 <HCI_TL_SPI_Send+0xa6>
    }
    else
    {
      /* Buffer is too small */
      result = -2;
 8004c0c:	f06f 0301 	mvn.w	r3, #1
 8004c10:	627b      	str	r3, [r7, #36]	@ 0x24
    }

    /* Release CS line */
    HAL_GPIO_WritePin(HCI_TL_SPI_CS_PORT, HCI_TL_SPI_CS_PIN, GPIO_PIN_SET);
 8004c12:	2201      	movs	r2, #1
 8004c14:	2104      	movs	r1, #4
 8004c16:	4817      	ldr	r0, [pc, #92]	@ (8004c74 <HCI_TL_SPI_Send+0x108>)
 8004c18:	f00b f872 	bl	800fd00 <HAL_GPIO_WritePin>

    if ((HAL_GetTick() - tickstart) > TIMEOUT_DURATION)
 8004c1c:	f008 ff20 	bl	800da60 <HAL_GetTick>
 8004c20:	4602      	mov	r2, r0
 8004c22:	6a3b      	ldr	r3, [r7, #32]
 8004c24:	1ad3      	subs	r3, r2, r3
 8004c26:	2b0f      	cmp	r3, #15
 8004c28:	d903      	bls.n	8004c32 <HCI_TL_SPI_Send+0xc6>
    {
      result = -3;
 8004c2a:	f06f 0302 	mvn.w	r3, #2
 8004c2e:	627b      	str	r3, [r7, #36]	@ 0x24
      break;
 8004c30:	e002      	b.n	8004c38 <HCI_TL_SPI_Send+0xcc>
    }
  } while (result < 0);
 8004c32:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8004c34:	2b00      	cmp	r3, #0
 8004c36:	dba8      	blt.n	8004b8a <HCI_TL_SPI_Send+0x1e>
  /**
    * To be aligned to the SPI protocol.
    * Can bring to a delay inside the frame, due to the BlueNRG that needs
    * to check if the header is received or not.
    */
  tickstart = HAL_GetTick();
 8004c38:	f008 ff12 	bl	800da60 <HAL_GetTick>
 8004c3c:	6238      	str	r0, [r7, #32]
  while ((HAL_GetTick() - tickstart) < TIMEOUT_IRQ_HIGH)
 8004c3e:	e007      	b.n	8004c50 <HCI_TL_SPI_Send+0xe4>
  {
    if (HAL_GPIO_ReadPin(HCI_TL_SPI_IRQ_PORT, HCI_TL_SPI_IRQ_PIN)==GPIO_PIN_RESET)
 8004c40:	f44f 6100 	mov.w	r1, #2048	@ 0x800
 8004c44:	480d      	ldr	r0, [pc, #52]	@ (8004c7c <HCI_TL_SPI_Send+0x110>)
 8004c46:	f00b f843 	bl	800fcd0 <HAL_GPIO_ReadPin>
 8004c4a:	4603      	mov	r3, r0
 8004c4c:	2b00      	cmp	r3, #0
 8004c4e:	d008      	beq.n	8004c62 <HCI_TL_SPI_Send+0xf6>
  while ((HAL_GetTick() - tickstart) < TIMEOUT_IRQ_HIGH)
 8004c50:	f008 ff06 	bl	800da60 <HAL_GetTick>
 8004c54:	4602      	mov	r2, r0
 8004c56:	6a3b      	ldr	r3, [r7, #32]
 8004c58:	1ad3      	subs	r3, r2, r3
 8004c5a:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 8004c5e:	d3ef      	bcc.n	8004c40 <HCI_TL_SPI_Send+0xd4>
 8004c60:	e000      	b.n	8004c64 <HCI_TL_SPI_Send+0xf8>
	{
      break;
 8004c62:	bf00      	nop
    }
  }

  HCI_TL_SPI_Enable_IRQ();
 8004c64:	f7ff fe55 	bl	8004912 <HCI_TL_SPI_Enable_IRQ>

  return result;
 8004c68:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 8004c6a:	4618      	mov	r0, r3
 8004c6c:	3728      	adds	r7, #40	@ 0x28
 8004c6e:	46bd      	mov	sp, r7
 8004c70:	bd80      	pop	{r7, pc}
 8004c72:	bf00      	nop
 8004c74:	42020000 	.word	0x42020000
 8004c78:	200005b0 	.word	0x200005b0
 8004c7c:	42020400 	.word	0x42020400

08004c80 <IsDataAvailable>:
  *
  * @param  None
  * @retval int32_t: 1 if data are present, 0 otherwise
  */
static int32_t IsDataAvailable(void)
{
 8004c80:	b580      	push	{r7, lr}
 8004c82:	af00      	add	r7, sp, #0
  return (HAL_GPIO_ReadPin(HCI_TL_SPI_EXTI_PORT, HCI_TL_SPI_EXTI_PIN) == GPIO_PIN_SET);
 8004c84:	f44f 6100 	mov.w	r1, #2048	@ 0x800
 8004c88:	4805      	ldr	r0, [pc, #20]	@ (8004ca0 <IsDataAvailable+0x20>)
 8004c8a:	f00b f821 	bl	800fcd0 <HAL_GPIO_ReadPin>
 8004c8e:	4603      	mov	r3, r0
 8004c90:	2b01      	cmp	r3, #1
 8004c92:	bf0c      	ite	eq
 8004c94:	2301      	moveq	r3, #1
 8004c96:	2300      	movne	r3, #0
 8004c98:	b2db      	uxtb	r3, r3
}
 8004c9a:	4618      	mov	r0, r3
 8004c9c:	bd80      	pop	{r7, pc}
 8004c9e:	bf00      	nop
 8004ca0:	42020400 	.word	0x42020400

08004ca4 <hci_tl_lowlevel_init>:
  *
  * @param  None
  * @retval None
  */
void hci_tl_lowlevel_init(void)
{
 8004ca4:	b580      	push	{r7, lr}
 8004ca6:	b088      	sub	sp, #32
 8004ca8:	af00      	add	r7, sp, #0

  /* USER CODE END hci_tl_lowlevel_init 1 */
  tHciIO fops;

  /* Register IO bus services */
  fops.Init    = HCI_TL_SPI_Init;
 8004caa:	4b0a      	ldr	r3, [pc, #40]	@ (8004cd4 <hci_tl_lowlevel_init+0x30>)
 8004cac:	607b      	str	r3, [r7, #4]
  fops.DeInit  = HCI_TL_SPI_DeInit;
 8004cae:	4b0a      	ldr	r3, [pc, #40]	@ (8004cd8 <hci_tl_lowlevel_init+0x34>)
 8004cb0:	60bb      	str	r3, [r7, #8]
  fops.Send    = HCI_TL_SPI_Send;
 8004cb2:	4b0a      	ldr	r3, [pc, #40]	@ (8004cdc <hci_tl_lowlevel_init+0x38>)
 8004cb4:	617b      	str	r3, [r7, #20]
  fops.Receive = HCI_TL_SPI_Receive;
 8004cb6:	4b0a      	ldr	r3, [pc, #40]	@ (8004ce0 <hci_tl_lowlevel_init+0x3c>)
 8004cb8:	613b      	str	r3, [r7, #16]
  fops.Reset   = HCI_TL_SPI_Reset;
 8004cba:	4b0a      	ldr	r3, [pc, #40]	@ (8004ce4 <hci_tl_lowlevel_init+0x40>)
 8004cbc:	60fb      	str	r3, [r7, #12]
  fops.GetTick = BSP_GetTick;
 8004cbe:	4b0a      	ldr	r3, [pc, #40]	@ (8004ce8 <hci_tl_lowlevel_init+0x44>)
 8004cc0:	61fb      	str	r3, [r7, #28]

  hci_register_io_bus(&fops);
 8004cc2:	1d3b      	adds	r3, r7, #4
 8004cc4:	4618      	mov	r0, r3
 8004cc6:	f017 f8f3 	bl	801beb0 <hci_register_io_bus>
  /* USER CODE END hci_tl_lowlevel_init 2 */

  /* USER CODE BEGIN hci_tl_lowlevel_init 3 */

  /* USER CODE END hci_tl_lowlevel_init 3 */
}
 8004cca:	bf00      	nop
 8004ccc:	3720      	adds	r7, #32
 8004cce:	46bd      	mov	sp, r7
 8004cd0:	bd80      	pop	{r7, pc}
 8004cd2:	bf00      	nop
 8004cd4:	08004931 	.word	0x08004931
 8004cd8:	08004a11 	.word	0x08004a11
 8004cdc:	08004b6d 	.word	0x08004b6d
 8004ce0:	08004a7d 	.word	0x08004a7d
 8004ce4:	08004a41 	.word	0x08004a41
 8004ce8:	0800596d 	.word	0x0800596d

08004cec <hci_tl_lowlevel_isr>:
  *
  * @param  None
  * @retval None
  */
void hci_tl_lowlevel_isr(void)
{
 8004cec:	b580      	push	{r7, lr}
 8004cee:	af00      	add	r7, sp, #0
  /* Call hci_notify_asynch_evt() */
  while (IsDataAvailable())
 8004cf0:	e005      	b.n	8004cfe <hci_tl_lowlevel_isr+0x12>
  {
    if (hci_notify_asynch_evt(NULL))
 8004cf2:	2000      	movs	r0, #0
 8004cf4:	f017 fa44 	bl	801c180 <hci_notify_asynch_evt>
 8004cf8:	4603      	mov	r3, r0
 8004cfa:	2b00      	cmp	r3, #0
 8004cfc:	d105      	bne.n	8004d0a <hci_tl_lowlevel_isr+0x1e>
  while (IsDataAvailable())
 8004cfe:	f7ff ffbf 	bl	8004c80 <IsDataAvailable>
 8004d02:	4603      	mov	r3, r0
 8004d04:	2b00      	cmp	r3, #0
 8004d06:	d1f4      	bne.n	8004cf2 <hci_tl_lowlevel_isr+0x6>
 8004d08:	e000      	b.n	8004d0c <hci_tl_lowlevel_isr+0x20>
    {
      return;
 8004d0a:	bf00      	nop
  }

  /* USER CODE BEGIN hci_tl_lowlevel_isr */

  /* USER CODE END hci_tl_lowlevel_isr */
}
 8004d0c:	bd80      	pop	{r7, pc}

08004d0e <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
 8004d0e:	b580      	push	{r7, lr}
 8004d10:	af00      	add	r7, sp, #0
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 8004d12:	f008 fdeb 	bl	800d8ec <HAL_Init>
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
 8004d16:	f000 f80d 	bl	8004d34 <SystemClock_Config>

  /* Configure the System Power */
  SystemPower_Config();
 8004d1a:	f000 f86b 	bl	8004df4 <SystemPower_Config>
  //     Error_Handler();
  // }
  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_ICACHE_Init();
 8004d1e:	f000 f89b 	bl	8004e58 <MX_ICACHE_Init>
  MX_CRC_Init();
 8004d22:	f000 f877 	bl	8004e14 <MX_CRC_Init>
  MX_BLESensorsPnPL_Init();
 8004d26:	f7ff fa71 	bl	800420c <MX_BLESensorsPnPL_Init>
  /* USER CODE BEGIN 2 */
  DLC_Init();
 8004d2a:	f7fe f981 	bl	8003030 <DLC_Init>
  {
    // BLE_Periodic_Beacon_Process(); // MODIFIED CALL
    /* USER CODE END WHILE */
  
  // MX_BLESensorsPnPL_Process();
  DLC_mainProcess();
 8004d2e:	f7fe f995 	bl	800305c <DLC_mainProcess>
  {
 8004d32:	e7fc      	b.n	8004d2e <main+0x20>

08004d34 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 8004d34:	b580      	push	{r7, lr}
 8004d36:	b09e      	sub	sp, #120	@ 0x78
 8004d38:	af00      	add	r7, sp, #0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 8004d3a:	f107 0318 	add.w	r3, r7, #24
 8004d3e:	2260      	movs	r2, #96	@ 0x60
 8004d40:	2100      	movs	r1, #0
 8004d42:	4618      	mov	r0, r3
 8004d44:	f01f f98e 	bl	8024064 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8004d48:	463b      	mov	r3, r7
 8004d4a:	2200      	movs	r2, #0
 8004d4c:	601a      	str	r2, [r3, #0]
 8004d4e:	605a      	str	r2, [r3, #4]
 8004d50:	609a      	str	r2, [r3, #8]
 8004d52:	60da      	str	r2, [r3, #12]
 8004d54:	611a      	str	r2, [r3, #16]
 8004d56:	615a      	str	r2, [r3, #20]

  /** Configure the main internal regulator output voltage
  */
  if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1) != HAL_OK)
 8004d58:	f44f 3040 	mov.w	r0, #196608	@ 0x30000
 8004d5c:	f00c fd0a 	bl	8011774 <HAL_PWREx_ControlVoltageScaling>
 8004d60:	4603      	mov	r3, r0
 8004d62:	2b00      	cmp	r3, #0
 8004d64:	d001      	beq.n	8004d6a <SystemClock_Config+0x36>
  {
    Error_Handler();
 8004d66:	f000 f88a 	bl	8004e7e <Error_Handler>
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI48|RCC_OSCILLATORTYPE_LSI
 8004d6a:	2329      	movs	r3, #41	@ 0x29
 8004d6c:	61bb      	str	r3, [r7, #24]
                              |RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 8004d6e:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
 8004d72:	61fb      	str	r3, [r7, #28]
  RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
 8004d74:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 8004d78:	647b      	str	r3, [r7, #68]	@ 0x44
  RCC_OscInitStruct.LSIState = RCC_LSI_ON;
 8004d7a:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
 8004d7e:	62fb      	str	r3, [r7, #44]	@ 0x2c
  RCC_OscInitStruct.LSIDiv = RCC_LSI_DIV1;
 8004d80:	2300      	movs	r3, #0
 8004d82:	633b      	str	r3, [r7, #48]	@ 0x30
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8004d84:	2302      	movs	r3, #2
 8004d86:	653b      	str	r3, [r7, #80]	@ 0x50
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8004d88:	2303      	movs	r3, #3
 8004d8a:	657b      	str	r3, [r7, #84]	@ 0x54
  RCC_OscInitStruct.PLL.PLLMBOOST = RCC_PLLMBOOST_DIV1;
 8004d8c:	2300      	movs	r3, #0
 8004d8e:	65fb      	str	r3, [r7, #92]	@ 0x5c
  RCC_OscInitStruct.PLL.PLLM = 1;
 8004d90:	2301      	movs	r3, #1
 8004d92:	65bb      	str	r3, [r7, #88]	@ 0x58
  RCC_OscInitStruct.PLL.PLLN = 10;
 8004d94:	230a      	movs	r3, #10
 8004d96:	663b      	str	r3, [r7, #96]	@ 0x60
  RCC_OscInitStruct.PLL.PLLP = 1;
 8004d98:	2301      	movs	r3, #1
 8004d9a:	667b      	str	r3, [r7, #100]	@ 0x64
  RCC_OscInitStruct.PLL.PLLQ = 2;
 8004d9c:	2302      	movs	r3, #2
 8004d9e:	66bb      	str	r3, [r7, #104]	@ 0x68
  RCC_OscInitStruct.PLL.PLLR = 1;
 8004da0:	2301      	movs	r3, #1
 8004da2:	66fb      	str	r3, [r7, #108]	@ 0x6c
  RCC_OscInitStruct.PLL.PLLRGE = RCC_PLLVCIRANGE_1;
 8004da4:	230c      	movs	r3, #12
 8004da6:	673b      	str	r3, [r7, #112]	@ 0x70
  RCC_OscInitStruct.PLL.PLLFRACN = 0;
 8004da8:	2300      	movs	r3, #0
 8004daa:	677b      	str	r3, [r7, #116]	@ 0x74
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8004dac:	f107 0318 	add.w	r3, r7, #24
 8004db0:	4618      	mov	r0, r3
 8004db2:	f00c fddb 	bl	801196c <HAL_RCC_OscConfig>
 8004db6:	4603      	mov	r3, r0
 8004db8:	2b00      	cmp	r3, #0
 8004dba:	d001      	beq.n	8004dc0 <SystemClock_Config+0x8c>
  {
    Error_Handler();
 8004dbc:	f000 f85f 	bl	8004e7e <Error_Handler>
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8004dc0:	231f      	movs	r3, #31
 8004dc2:	603b      	str	r3, [r7, #0]
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2
                              |RCC_CLOCKTYPE_PCLK3;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 8004dc4:	2303      	movs	r3, #3
 8004dc6:	607b      	str	r3, [r7, #4]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8004dc8:	2300      	movs	r3, #0
 8004dca:	60bb      	str	r3, [r7, #8]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 8004dcc:	2300      	movs	r3, #0
 8004dce:	60fb      	str	r3, [r7, #12]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 8004dd0:	2300      	movs	r3, #0
 8004dd2:	613b      	str	r3, [r7, #16]
  RCC_ClkInitStruct.APB3CLKDivider = RCC_HCLK_DIV1;
 8004dd4:	2300      	movs	r3, #0
 8004dd6:	617b      	str	r3, [r7, #20]

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
 8004dd8:	463b      	mov	r3, r7
 8004dda:	2104      	movs	r1, #4
 8004ddc:	4618      	mov	r0, r3
 8004dde:	f00d fca1 	bl	8012724 <HAL_RCC_ClockConfig>
 8004de2:	4603      	mov	r3, r0
 8004de4:	2b00      	cmp	r3, #0
 8004de6:	d001      	beq.n	8004dec <SystemClock_Config+0xb8>
  {
    Error_Handler();
 8004de8:	f000 f849 	bl	8004e7e <Error_Handler>
  }
}
 8004dec:	bf00      	nop
 8004dee:	3778      	adds	r7, #120	@ 0x78
 8004df0:	46bd      	mov	sp, r7
 8004df2:	bd80      	pop	{r7, pc}

08004df4 <SystemPower_Config>:
/**
  * @brief Power Configuration
  * @retval None
  */
static void SystemPower_Config(void)
{
 8004df4:	b580      	push	{r7, lr}
 8004df6:	af00      	add	r7, sp, #0
  HAL_PWREx_EnableVddIO2();
 8004df8:	f00c fd98 	bl	801192c <HAL_PWREx_EnableVddIO2>

  /*
   * Disable the internal Pull-Up in Dead Battery pins of UCPD peripheral
   */
  HAL_PWREx_DisableUCPDDeadBattery();
 8004dfc:	f00c fda6 	bl	801194c <HAL_PWREx_DisableUCPDDeadBattery>

  /*
   * Switch to SMPS regulator instead of LDO
   */
  if (HAL_PWREx_ConfigSupply(PWR_SMPS_SUPPLY) != HAL_OK)
 8004e00:	2002      	movs	r0, #2
 8004e02:	f00c fd43 	bl	801188c <HAL_PWREx_ConfigSupply>
 8004e06:	4603      	mov	r3, r0
 8004e08:	2b00      	cmp	r3, #0
 8004e0a:	d001      	beq.n	8004e10 <SystemPower_Config+0x1c>
  {
    Error_Handler();
 8004e0c:	f000 f837 	bl	8004e7e <Error_Handler>
  }
/* USER CODE BEGIN PWR */
/* USER CODE END PWR */
}
 8004e10:	bf00      	nop
 8004e12:	bd80      	pop	{r7, pc}

08004e14 <MX_CRC_Init>:
  * @brief CRC Initialization Function
  * @param None
  * @retval None
  */
static void MX_CRC_Init(void)
{
 8004e14:	b580      	push	{r7, lr}
 8004e16:	af00      	add	r7, sp, #0
  /* USER CODE END CRC_Init 0 */

  /* USER CODE BEGIN CRC_Init 1 */

  /* USER CODE END CRC_Init 1 */
  hcrc.Instance = CRC;
 8004e18:	4b0d      	ldr	r3, [pc, #52]	@ (8004e50 <MX_CRC_Init+0x3c>)
 8004e1a:	4a0e      	ldr	r2, [pc, #56]	@ (8004e54 <MX_CRC_Init+0x40>)
 8004e1c:	601a      	str	r2, [r3, #0]
  hcrc.Init.DefaultPolynomialUse = DEFAULT_POLYNOMIAL_ENABLE;
 8004e1e:	4b0c      	ldr	r3, [pc, #48]	@ (8004e50 <MX_CRC_Init+0x3c>)
 8004e20:	2200      	movs	r2, #0
 8004e22:	711a      	strb	r2, [r3, #4]
  hcrc.Init.DefaultInitValueUse = DEFAULT_INIT_VALUE_ENABLE;
 8004e24:	4b0a      	ldr	r3, [pc, #40]	@ (8004e50 <MX_CRC_Init+0x3c>)
 8004e26:	2200      	movs	r2, #0
 8004e28:	715a      	strb	r2, [r3, #5]
  hcrc.Init.InputDataInversionMode = CRC_INPUTDATA_INVERSION_NONE;
 8004e2a:	4b09      	ldr	r3, [pc, #36]	@ (8004e50 <MX_CRC_Init+0x3c>)
 8004e2c:	2200      	movs	r2, #0
 8004e2e:	615a      	str	r2, [r3, #20]
  hcrc.Init.OutputDataInversionMode = CRC_OUTPUTDATA_INVERSION_DISABLE;
 8004e30:	4b07      	ldr	r3, [pc, #28]	@ (8004e50 <MX_CRC_Init+0x3c>)
 8004e32:	2200      	movs	r2, #0
 8004e34:	619a      	str	r2, [r3, #24]
  hcrc.InputDataFormat = CRC_INPUTDATA_FORMAT_BYTES;
 8004e36:	4b06      	ldr	r3, [pc, #24]	@ (8004e50 <MX_CRC_Init+0x3c>)
 8004e38:	2201      	movs	r2, #1
 8004e3a:	621a      	str	r2, [r3, #32]
  if (HAL_CRC_Init(&hcrc) != HAL_OK)
 8004e3c:	4804      	ldr	r0, [pc, #16]	@ (8004e50 <MX_CRC_Init+0x3c>)
 8004e3e:	f009 f807 	bl	800de50 <HAL_CRC_Init>
 8004e42:	4603      	mov	r3, r0
 8004e44:	2b00      	cmp	r3, #0
 8004e46:	d001      	beq.n	8004e4c <MX_CRC_Init+0x38>
  {
    Error_Handler();
 8004e48:	f000 f819 	bl	8004e7e <Error_Handler>
  }
  /* USER CODE BEGIN CRC_Init 2 */

  /* USER CODE END CRC_Init 2 */

}
 8004e4c:	bf00      	nop
 8004e4e:	bd80      	pop	{r7, pc}
 8004e50:	200006b0 	.word	0x200006b0
 8004e54:	40023000 	.word	0x40023000

08004e58 <MX_ICACHE_Init>:
  * @brief ICACHE Initialization Function
  * @param None
  * @retval None
  */
static void MX_ICACHE_Init(void)
{
 8004e58:	b580      	push	{r7, lr}
 8004e5a:	af00      	add	r7, sp, #0

  /* USER CODE END ICACHE_Init 1 */

  /** Enable instruction cache in 1-way (direct mapped cache)
  */
  if (HAL_ICACHE_ConfigAssociativityMode(ICACHE_1WAY) != HAL_OK)
 8004e5c:	2000      	movs	r0, #0
 8004e5e:	f00c fc29 	bl	80116b4 <HAL_ICACHE_ConfigAssociativityMode>
 8004e62:	4603      	mov	r3, r0
 8004e64:	2b00      	cmp	r3, #0
 8004e66:	d001      	beq.n	8004e6c <MX_ICACHE_Init+0x14>
  {
    Error_Handler();
 8004e68:	f000 f809 	bl	8004e7e <Error_Handler>
  }
  if (HAL_ICACHE_Enable() != HAL_OK)
 8004e6c:	f00c fc42 	bl	80116f4 <HAL_ICACHE_Enable>
 8004e70:	4603      	mov	r3, r0
 8004e72:	2b00      	cmp	r3, #0
 8004e74:	d001      	beq.n	8004e7a <MX_ICACHE_Init+0x22>
  {
    Error_Handler();
 8004e76:	f000 f802 	bl	8004e7e <Error_Handler>
  }
  /* USER CODE BEGIN ICACHE_Init 2 */

  /* USER CODE END ICACHE_Init 2 */

}
 8004e7a:	bf00      	nop
 8004e7c:	bd80      	pop	{r7, pc}

08004e7e <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
 8004e7e:	b480      	push	{r7}
 8004e80:	af00      	add	r7, sp, #0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004e82:	b672      	cpsid	i
}
 8004e84:	bf00      	nop
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 8004e86:	e7fe      	b.n	8004e86 <Error_Handler+0x8>

08004e88 <BSP_LED_Init>:
 *              This parameter can be one of the following values:
 *              @arg  LED2, LED4, ...
 * @retval HAL status
 */
int32_t BSP_LED_Init(Led_TypeDef Led)
{
 8004e88:	b580      	push	{r7, lr}
 8004e8a:	b082      	sub	sp, #8
 8004e8c:	af00      	add	r7, sp, #0
 8004e8e:	4603      	mov	r3, r0
 8004e90:	71fb      	strb	r3, [r7, #7]
  static const BSP_LED_GPIO_Init LedGpioInit[LEDn] = {LED_USER__BLUE_GPIO_Init,LED_USER__RED_GPIO_Init,LED_USER__YELLOW_GPIO_Init,LED_USER__GREEN_GPIO_Init,};
  LedGpioInit[Led]();
 8004e92:	79fb      	ldrb	r3, [r7, #7]
 8004e94:	4a04      	ldr	r2, [pc, #16]	@ (8004ea8 <BSP_LED_Init+0x20>)
 8004e96:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8004e9a:	4798      	blx	r3
  return BSP_ERROR_NONE;
 8004e9c:	2300      	movs	r3, #0
}
 8004e9e:	4618      	mov	r0, r3
 8004ea0:	3708      	adds	r7, #8
 8004ea2:	46bd      	mov	sp, r7
 8004ea4:	bd80      	pop	{r7, pc}
 8004ea6:	bf00      	nop
 8004ea8:	0802a4a8 	.word	0x0802a4a8

08004eac <BSP_LED_On>:
 *              @arg  LED3
 *              @arg  LED4
 * @retval HAL status
 */
int32_t BSP_LED_On(Led_TypeDef Led)
{
 8004eac:	b580      	push	{r7, lr}
 8004eae:	b082      	sub	sp, #8
 8004eb0:	af00      	add	r7, sp, #0
 8004eb2:	4603      	mov	r3, r0
 8004eb4:	71fb      	strb	r3, [r7, #7]
  HAL_GPIO_WritePin(LED_PORT [Led], LED_PIN [Led], GPIO_PIN_SET);
 8004eb6:	79fb      	ldrb	r3, [r7, #7]
 8004eb8:	4a07      	ldr	r2, [pc, #28]	@ (8004ed8 <BSP_LED_On+0x2c>)
 8004eba:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 8004ebe:	79fb      	ldrb	r3, [r7, #7]
 8004ec0:	4a06      	ldr	r2, [pc, #24]	@ (8004edc <BSP_LED_On+0x30>)
 8004ec2:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8004ec6:	2201      	movs	r2, #1
 8004ec8:	4619      	mov	r1, r3
 8004eca:	f00a ff19 	bl	800fd00 <HAL_GPIO_WritePin>

  return BSP_ERROR_NONE;
 8004ece:	2300      	movs	r3, #0
}
 8004ed0:	4618      	mov	r0, r3
 8004ed2:	3708      	adds	r7, #8
 8004ed4:	46bd      	mov	sp, r7
 8004ed6:	bd80      	pop	{r7, pc}
 8004ed8:	20000010 	.word	0x20000010
 8004edc:	0802a4a0 	.word	0x0802a4a0

08004ee0 <BSP_LED_Off>:
 *              @arg  LED3
 *              @arg  LED4
 * @retval HAL status
 */
int32_t BSP_LED_Off(Led_TypeDef Led)
{
 8004ee0:	b580      	push	{r7, lr}
 8004ee2:	b082      	sub	sp, #8
 8004ee4:	af00      	add	r7, sp, #0
 8004ee6:	4603      	mov	r3, r0
 8004ee8:	71fb      	strb	r3, [r7, #7]
  HAL_GPIO_WritePin(LED_PORT [Led], LED_PIN [Led], GPIO_PIN_RESET);
 8004eea:	79fb      	ldrb	r3, [r7, #7]
 8004eec:	4a07      	ldr	r2, [pc, #28]	@ (8004f0c <BSP_LED_Off+0x2c>)
 8004eee:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 8004ef2:	79fb      	ldrb	r3, [r7, #7]
 8004ef4:	4a06      	ldr	r2, [pc, #24]	@ (8004f10 <BSP_LED_Off+0x30>)
 8004ef6:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8004efa:	2200      	movs	r2, #0
 8004efc:	4619      	mov	r1, r3
 8004efe:	f00a feff 	bl	800fd00 <HAL_GPIO_WritePin>

  return BSP_ERROR_NONE;
 8004f02:	2300      	movs	r3, #0
}
 8004f04:	4618      	mov	r0, r3
 8004f06:	3708      	adds	r7, #8
 8004f08:	46bd      	mov	sp, r7
 8004f0a:	bd80      	pop	{r7, pc}
 8004f0c:	20000010 	.word	0x20000010
 8004f10:	0802a4a0 	.word	0x0802a4a0

08004f14 <LED_USER__BLUE_GPIO_Init>:
  */
/**
  * @brief
  * @retval None
  */
static void LED_USER__BLUE_GPIO_Init(void) {
 8004f14:	b580      	push	{r7, lr}
 8004f16:	b088      	sub	sp, #32
 8004f18:	af00      	add	r7, sp, #0

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOF_CLK_ENABLE();
 8004f1a:	4b1f      	ldr	r3, [pc, #124]	@ (8004f98 <LED_USER__BLUE_GPIO_Init+0x84>)
 8004f1c:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8004f20:	4a1d      	ldr	r2, [pc, #116]	@ (8004f98 <LED_USER__BLUE_GPIO_Init+0x84>)
 8004f22:	f043 0320 	orr.w	r3, r3, #32
 8004f26:	f8c2 308c 	str.w	r3, [r2, #140]	@ 0x8c
 8004f2a:	4b1b      	ldr	r3, [pc, #108]	@ (8004f98 <LED_USER__BLUE_GPIO_Init+0x84>)
 8004f2c:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8004f30:	f003 0320 	and.w	r3, r3, #32
 8004f34:	60bb      	str	r3, [r7, #8]
 8004f36:	68bb      	ldr	r3, [r7, #8]

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8004f38:	f107 030c 	add.w	r3, r7, #12
 8004f3c:	2200      	movs	r2, #0
 8004f3e:	601a      	str	r2, [r3, #0]
 8004f40:	605a      	str	r2, [r3, #4]
 8004f42:	609a      	str	r2, [r3, #8]
 8004f44:	60da      	str	r2, [r3, #12]
 8004f46:	611a      	str	r2, [r3, #16]

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOF_CLK_ENABLE();
 8004f48:	4b13      	ldr	r3, [pc, #76]	@ (8004f98 <LED_USER__BLUE_GPIO_Init+0x84>)
 8004f4a:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8004f4e:	4a12      	ldr	r2, [pc, #72]	@ (8004f98 <LED_USER__BLUE_GPIO_Init+0x84>)
 8004f50:	f043 0320 	orr.w	r3, r3, #32
 8004f54:	f8c2 308c 	str.w	r3, [r2, #140]	@ 0x8c
 8004f58:	4b0f      	ldr	r3, [pc, #60]	@ (8004f98 <LED_USER__BLUE_GPIO_Init+0x84>)
 8004f5a:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8004f5e:	f003 0320 	and.w	r3, r3, #32
 8004f62:	607b      	str	r3, [r7, #4]
 8004f64:	687b      	ldr	r3, [r7, #4]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(BUS_BSP_LED__BLUE_GPIO_PORT, BUS_BSP_LED__BLUE_GPIO_PIN, GPIO_PIN_RESET);
 8004f66:	2200      	movs	r2, #0
 8004f68:	f44f 7100 	mov.w	r1, #512	@ 0x200
 8004f6c:	480b      	ldr	r0, [pc, #44]	@ (8004f9c <LED_USER__BLUE_GPIO_Init+0x88>)
 8004f6e:	f00a fec7 	bl	800fd00 <HAL_GPIO_WritePin>

  /*Configure GPIO pin : PTPIN */
  GPIO_InitStruct.Pin = BUS_BSP_LED__BLUE_GPIO_PIN;
 8004f72:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8004f76:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8004f78:	2301      	movs	r3, #1
 8004f7a:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8004f7c:	2300      	movs	r3, #0
 8004f7e:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8004f80:	2300      	movs	r3, #0
 8004f82:	61bb      	str	r3, [r7, #24]
  HAL_GPIO_Init(BUS_BSP_LED__BLUE_GPIO_PORT, &GPIO_InitStruct);
 8004f84:	f107 030c 	add.w	r3, r7, #12
 8004f88:	4619      	mov	r1, r3
 8004f8a:	4804      	ldr	r0, [pc, #16]	@ (8004f9c <LED_USER__BLUE_GPIO_Init+0x88>)
 8004f8c:	f00a fbea 	bl	800f764 <HAL_GPIO_Init>

}
 8004f90:	bf00      	nop
 8004f92:	3720      	adds	r7, #32
 8004f94:	46bd      	mov	sp, r7
 8004f96:	bd80      	pop	{r7, pc}
 8004f98:	46020c00 	.word	0x46020c00
 8004f9c:	42021400 	.word	0x42021400

08004fa0 <LED_USER__RED_GPIO_Init>:

/**
  * @brief
  * @retval None
  */
static void LED_USER__RED_GPIO_Init(void) {
 8004fa0:	b580      	push	{r7, lr}
 8004fa2:	b088      	sub	sp, #32
 8004fa4:	af00      	add	r7, sp, #0

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOH_CLK_ENABLE();
 8004fa6:	4b1f      	ldr	r3, [pc, #124]	@ (8005024 <LED_USER__RED_GPIO_Init+0x84>)
 8004fa8:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8004fac:	4a1d      	ldr	r2, [pc, #116]	@ (8005024 <LED_USER__RED_GPIO_Init+0x84>)
 8004fae:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8004fb2:	f8c2 308c 	str.w	r3, [r2, #140]	@ 0x8c
 8004fb6:	4b1b      	ldr	r3, [pc, #108]	@ (8005024 <LED_USER__RED_GPIO_Init+0x84>)
 8004fb8:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8004fbc:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8004fc0:	60bb      	str	r3, [r7, #8]
 8004fc2:	68bb      	ldr	r3, [r7, #8]

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8004fc4:	f107 030c 	add.w	r3, r7, #12
 8004fc8:	2200      	movs	r2, #0
 8004fca:	601a      	str	r2, [r3, #0]
 8004fcc:	605a      	str	r2, [r3, #4]
 8004fce:	609a      	str	r2, [r3, #8]
 8004fd0:	60da      	str	r2, [r3, #12]
 8004fd2:	611a      	str	r2, [r3, #16]

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOH_CLK_ENABLE();
 8004fd4:	4b13      	ldr	r3, [pc, #76]	@ (8005024 <LED_USER__RED_GPIO_Init+0x84>)
 8004fd6:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8004fda:	4a12      	ldr	r2, [pc, #72]	@ (8005024 <LED_USER__RED_GPIO_Init+0x84>)
 8004fdc:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8004fe0:	f8c2 308c 	str.w	r3, [r2, #140]	@ 0x8c
 8004fe4:	4b0f      	ldr	r3, [pc, #60]	@ (8005024 <LED_USER__RED_GPIO_Init+0x84>)
 8004fe6:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8004fea:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8004fee:	607b      	str	r3, [r7, #4]
 8004ff0:	687b      	ldr	r3, [r7, #4]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(BUS_BSP_LED__RED_GPIO_PORT, BUS_BSP_LED__RED_GPIO_PIN, GPIO_PIN_RESET);
 8004ff2:	2200      	movs	r2, #0
 8004ff4:	f44f 6100 	mov.w	r1, #2048	@ 0x800
 8004ff8:	480b      	ldr	r0, [pc, #44]	@ (8005028 <LED_USER__RED_GPIO_Init+0x88>)
 8004ffa:	f00a fe81 	bl	800fd00 <HAL_GPIO_WritePin>

  /*Configure GPIO pin : PTPIN */
  GPIO_InitStruct.Pin = BUS_BSP_LED__RED_GPIO_PIN;
 8004ffe:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 8005002:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8005004:	2301      	movs	r3, #1
 8005006:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8005008:	2300      	movs	r3, #0
 800500a:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800500c:	2300      	movs	r3, #0
 800500e:	61bb      	str	r3, [r7, #24]
  HAL_GPIO_Init(BUS_BSP_LED__RED_GPIO_PORT, &GPIO_InitStruct);
 8005010:	f107 030c 	add.w	r3, r7, #12
 8005014:	4619      	mov	r1, r3
 8005016:	4804      	ldr	r0, [pc, #16]	@ (8005028 <LED_USER__RED_GPIO_Init+0x88>)
 8005018:	f00a fba4 	bl	800f764 <HAL_GPIO_Init>

}
 800501c:	bf00      	nop
 800501e:	3720      	adds	r7, #32
 8005020:	46bd      	mov	sp, r7
 8005022:	bd80      	pop	{r7, pc}
 8005024:	46020c00 	.word	0x46020c00
 8005028:	42021c00 	.word	0x42021c00

0800502c <LED_USER__YELLOW_GPIO_Init>:

/**
  * @brief
  * @retval None
  */
static void LED_USER__YELLOW_GPIO_Init(void) {
 800502c:	b580      	push	{r7, lr}
 800502e:	b088      	sub	sp, #32
 8005030:	af00      	add	r7, sp, #0

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOH_CLK_ENABLE();
 8005032:	4b1f      	ldr	r3, [pc, #124]	@ (80050b0 <LED_USER__YELLOW_GPIO_Init+0x84>)
 8005034:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8005038:	4a1d      	ldr	r2, [pc, #116]	@ (80050b0 <LED_USER__YELLOW_GPIO_Init+0x84>)
 800503a:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 800503e:	f8c2 308c 	str.w	r3, [r2, #140]	@ 0x8c
 8005042:	4b1b      	ldr	r3, [pc, #108]	@ (80050b0 <LED_USER__YELLOW_GPIO_Init+0x84>)
 8005044:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8005048:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 800504c:	60bb      	str	r3, [r7, #8]
 800504e:	68bb      	ldr	r3, [r7, #8]

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8005050:	f107 030c 	add.w	r3, r7, #12
 8005054:	2200      	movs	r2, #0
 8005056:	601a      	str	r2, [r3, #0]
 8005058:	605a      	str	r2, [r3, #4]
 800505a:	609a      	str	r2, [r3, #8]
 800505c:	60da      	str	r2, [r3, #12]
 800505e:	611a      	str	r2, [r3, #16]

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOH_CLK_ENABLE();
 8005060:	4b13      	ldr	r3, [pc, #76]	@ (80050b0 <LED_USER__YELLOW_GPIO_Init+0x84>)
 8005062:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8005066:	4a12      	ldr	r2, [pc, #72]	@ (80050b0 <LED_USER__YELLOW_GPIO_Init+0x84>)
 8005068:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 800506c:	f8c2 308c 	str.w	r3, [r2, #140]	@ 0x8c
 8005070:	4b0f      	ldr	r3, [pc, #60]	@ (80050b0 <LED_USER__YELLOW_GPIO_Init+0x84>)
 8005072:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8005076:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 800507a:	607b      	str	r3, [r7, #4]
 800507c:	687b      	ldr	r3, [r7, #4]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(BUS_BSP_LED__YELLOW_GPIO_PORT, BUS_BSP_LED__YELLOW_GPIO_PIN, GPIO_PIN_RESET);
 800507e:	2200      	movs	r2, #0
 8005080:	f44f 5180 	mov.w	r1, #4096	@ 0x1000
 8005084:	480b      	ldr	r0, [pc, #44]	@ (80050b4 <LED_USER__YELLOW_GPIO_Init+0x88>)
 8005086:	f00a fe3b 	bl	800fd00 <HAL_GPIO_WritePin>

  /*Configure GPIO pin : PTPIN */
  GPIO_InitStruct.Pin = BUS_BSP_LED__YELLOW_GPIO_PIN;
 800508a:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 800508e:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8005090:	2301      	movs	r3, #1
 8005092:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8005094:	2300      	movs	r3, #0
 8005096:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8005098:	2300      	movs	r3, #0
 800509a:	61bb      	str	r3, [r7, #24]
  HAL_GPIO_Init(BUS_BSP_LED__YELLOW_GPIO_PORT, &GPIO_InitStruct);
 800509c:	f107 030c 	add.w	r3, r7, #12
 80050a0:	4619      	mov	r1, r3
 80050a2:	4804      	ldr	r0, [pc, #16]	@ (80050b4 <LED_USER__YELLOW_GPIO_Init+0x88>)
 80050a4:	f00a fb5e 	bl	800f764 <HAL_GPIO_Init>

}
 80050a8:	bf00      	nop
 80050aa:	3720      	adds	r7, #32
 80050ac:	46bd      	mov	sp, r7
 80050ae:	bd80      	pop	{r7, pc}
 80050b0:	46020c00 	.word	0x46020c00
 80050b4:	42021c00 	.word	0x42021c00

080050b8 <LED_USER__GREEN_GPIO_Init>:

/**
  * @brief
  * @retval None
  */
static void LED_USER__GREEN_GPIO_Init(void) {
 80050b8:	b580      	push	{r7, lr}
 80050ba:	b088      	sub	sp, #32
 80050bc:	af00      	add	r7, sp, #0

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOF_CLK_ENABLE();
 80050be:	4b1e      	ldr	r3, [pc, #120]	@ (8005138 <LED_USER__GREEN_GPIO_Init+0x80>)
 80050c0:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 80050c4:	4a1c      	ldr	r2, [pc, #112]	@ (8005138 <LED_USER__GREEN_GPIO_Init+0x80>)
 80050c6:	f043 0320 	orr.w	r3, r3, #32
 80050ca:	f8c2 308c 	str.w	r3, [r2, #140]	@ 0x8c
 80050ce:	4b1a      	ldr	r3, [pc, #104]	@ (8005138 <LED_USER__GREEN_GPIO_Init+0x80>)
 80050d0:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 80050d4:	f003 0320 	and.w	r3, r3, #32
 80050d8:	60bb      	str	r3, [r7, #8]
 80050da:	68bb      	ldr	r3, [r7, #8]

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80050dc:	f107 030c 	add.w	r3, r7, #12
 80050e0:	2200      	movs	r2, #0
 80050e2:	601a      	str	r2, [r3, #0]
 80050e4:	605a      	str	r2, [r3, #4]
 80050e6:	609a      	str	r2, [r3, #8]
 80050e8:	60da      	str	r2, [r3, #12]
 80050ea:	611a      	str	r2, [r3, #16]

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOF_CLK_ENABLE();
 80050ec:	4b12      	ldr	r3, [pc, #72]	@ (8005138 <LED_USER__GREEN_GPIO_Init+0x80>)
 80050ee:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 80050f2:	4a11      	ldr	r2, [pc, #68]	@ (8005138 <LED_USER__GREEN_GPIO_Init+0x80>)
 80050f4:	f043 0320 	orr.w	r3, r3, #32
 80050f8:	f8c2 308c 	str.w	r3, [r2, #140]	@ 0x8c
 80050fc:	4b0e      	ldr	r3, [pc, #56]	@ (8005138 <LED_USER__GREEN_GPIO_Init+0x80>)
 80050fe:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8005102:	f003 0320 	and.w	r3, r3, #32
 8005106:	607b      	str	r3, [r7, #4]
 8005108:	687b      	ldr	r3, [r7, #4]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(BUS_BSP_LED__GREEN_GPIO_PORT, BUS_BSP_LED__GREEN_GPIO_PIN, GPIO_PIN_RESET);
 800510a:	2200      	movs	r2, #0
 800510c:	2140      	movs	r1, #64	@ 0x40
 800510e:	480b      	ldr	r0, [pc, #44]	@ (800513c <LED_USER__GREEN_GPIO_Init+0x84>)
 8005110:	f00a fdf6 	bl	800fd00 <HAL_GPIO_WritePin>

  /*Configure GPIO pin : PTPIN */
  GPIO_InitStruct.Pin = BUS_BSP_LED__GREEN_GPIO_PIN;
 8005114:	2340      	movs	r3, #64	@ 0x40
 8005116:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8005118:	2301      	movs	r3, #1
 800511a:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800511c:	2300      	movs	r3, #0
 800511e:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8005120:	2300      	movs	r3, #0
 8005122:	61bb      	str	r3, [r7, #24]
  HAL_GPIO_Init(BUS_BSP_LED__GREEN_GPIO_PORT, &GPIO_InitStruct);
 8005124:	f107 030c 	add.w	r3, r7, #12
 8005128:	4619      	mov	r1, r3
 800512a:	4804      	ldr	r0, [pc, #16]	@ (800513c <LED_USER__GREEN_GPIO_Init+0x84>)
 800512c:	f00a fb1a 	bl	800f764 <HAL_GPIO_Init>

}
 8005130:	bf00      	nop
 8005132:	3720      	adds	r7, #32
 8005134:	46bd      	mov	sp, r7
 8005136:	bd80      	pop	{r7, pc}
 8005138:	46020c00 	.word	0x46020c00
 800513c:	42021400 	.word	0x42021400

08005140 <BSP_PB_Init>:
  *                    @arg  BUTTON_MODE_EXTI: Button will be connected to EXTI line
  *                                            with interrupt generation capability
  * @retval BSP status
  */
int32_t BSP_PB_Init(Button_TypeDef Button, ButtonMode_TypeDef ButtonMode)
{
 8005140:	b580      	push	{r7, lr}
 8005142:	b084      	sub	sp, #16
 8005144:	af00      	add	r7, sp, #0
 8005146:	4603      	mov	r3, r0
 8005148:	460a      	mov	r2, r1
 800514a:	71fb      	strb	r3, [r7, #7]
 800514c:	4613      	mov	r3, r2
 800514e:	71bb      	strb	r3, [r7, #6]
  int32_t ret = BSP_ERROR_NONE;
 8005150:	2300      	movs	r3, #0
 8005152:	60fb      	str	r3, [r7, #12]
  static const BSP_EXTI_LineCallback ButtonCallback[BUTTONn] ={BUTTON_USER_EXTI_Callback};
  static const uint32_t  BSP_BUTTON_PRIO [BUTTONn] ={BSP_BUTTON_USER_IT_PRIORITY};
  static const uint32_t BUTTON_EXTI_LINE[BUTTONn] ={USER_BUTTON_EXTI_LINE};
  static const BSP_BUTTON_GPIO_Init ButtonGpioInit[BUTTONn] = {BUTTON_USER_GPIO_Init};

  ButtonGpioInit[Button]();
 8005154:	79fb      	ldrb	r3, [r7, #7]
 8005156:	4a22      	ldr	r2, [pc, #136]	@ (80051e0 <BSP_PB_Init+0xa0>)
 8005158:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800515c:	4798      	blx	r3

  if (ButtonMode == BUTTON_MODE_EXTI)
 800515e:	79bb      	ldrb	r3, [r7, #6]
 8005160:	2b01      	cmp	r3, #1
 8005162:	d138      	bne.n	80051d6 <BSP_PB_Init+0x96>
  {
    if(HAL_EXTI_GetHandle(&hpb_exti[Button], BUTTON_EXTI_LINE[Button]) != HAL_OK)
 8005164:	79fa      	ldrb	r2, [r7, #7]
 8005166:	4613      	mov	r3, r2
 8005168:	005b      	lsls	r3, r3, #1
 800516a:	4413      	add	r3, r2
 800516c:	009b      	lsls	r3, r3, #2
 800516e:	4a1d      	ldr	r2, [pc, #116]	@ (80051e4 <BSP_PB_Init+0xa4>)
 8005170:	441a      	add	r2, r3
 8005172:	79fb      	ldrb	r3, [r7, #7]
 8005174:	491c      	ldr	r1, [pc, #112]	@ (80051e8 <BSP_PB_Init+0xa8>)
 8005176:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800517a:	4619      	mov	r1, r3
 800517c:	4610      	mov	r0, r2
 800517e:	f009 ff3e 	bl	800effe <HAL_EXTI_GetHandle>
 8005182:	4603      	mov	r3, r0
 8005184:	2b00      	cmp	r3, #0
 8005186:	d003      	beq.n	8005190 <BSP_PB_Init+0x50>
    {
      ret = BSP_ERROR_PERIPH_FAILURE;
 8005188:	f06f 0303 	mvn.w	r3, #3
 800518c:	60fb      	str	r3, [r7, #12]
 800518e:	e022      	b.n	80051d6 <BSP_PB_Init+0x96>
    }
    else if (HAL_EXTI_RegisterCallback(&hpb_exti[Button],  HAL_EXTI_COMMON_CB_ID, ButtonCallback[Button]) != HAL_OK)
 8005190:	79fa      	ldrb	r2, [r7, #7]
 8005192:	4613      	mov	r3, r2
 8005194:	005b      	lsls	r3, r3, #1
 8005196:	4413      	add	r3, r2
 8005198:	009b      	lsls	r3, r3, #2
 800519a:	4a12      	ldr	r2, [pc, #72]	@ (80051e4 <BSP_PB_Init+0xa4>)
 800519c:	1898      	adds	r0, r3, r2
 800519e:	79fb      	ldrb	r3, [r7, #7]
 80051a0:	4a12      	ldr	r2, [pc, #72]	@ (80051ec <BSP_PB_Init+0xac>)
 80051a2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80051a6:	461a      	mov	r2, r3
 80051a8:	2100      	movs	r1, #0
 80051aa:	f009 fefc 	bl	800efa6 <HAL_EXTI_RegisterCallback>
 80051ae:	4603      	mov	r3, r0
 80051b0:	2b00      	cmp	r3, #0
 80051b2:	d003      	beq.n	80051bc <BSP_PB_Init+0x7c>
    {
      ret = BSP_ERROR_PERIPH_FAILURE;
 80051b4:	f06f 0303 	mvn.w	r3, #3
 80051b8:	60fb      	str	r3, [r7, #12]
 80051ba:	e00c      	b.n	80051d6 <BSP_PB_Init+0x96>
    }
	else
    {
      /* Enable and set Button EXTI Interrupt to the lowest priority */
      HAL_NVIC_SetPriority((BUTTON_IRQn[Button]), BSP_BUTTON_PRIO[Button], 0x00);
 80051bc:	2018      	movs	r0, #24
 80051be:	79fb      	ldrb	r3, [r7, #7]
 80051c0:	4a0b      	ldr	r2, [pc, #44]	@ (80051f0 <BSP_PB_Init+0xb0>)
 80051c2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80051c6:	2200      	movs	r2, #0
 80051c8:	4619      	mov	r1, r3
 80051ca:	f008 fd52 	bl	800dc72 <HAL_NVIC_SetPriority>
      HAL_NVIC_EnableIRQ((BUTTON_IRQn[Button]));
 80051ce:	2318      	movs	r3, #24
 80051d0:	4618      	mov	r0, r3
 80051d2:	f008 fd68 	bl	800dca6 <HAL_NVIC_EnableIRQ>
    }
  }

  return ret;
 80051d6:	68fb      	ldr	r3, [r7, #12]
}
 80051d8:	4618      	mov	r0, r3
 80051da:	3710      	adds	r7, #16
 80051dc:	46bd      	mov	sp, r7
 80051de:	bd80      	pop	{r7, pc}
 80051e0:	0802a4b8 	.word	0x0802a4b8
 80051e4:	20000020 	.word	0x20000020
 80051e8:	0802a4bc 	.word	0x0802a4bc
 80051ec:	0802a4c0 	.word	0x0802a4c0
 80051f0:	0802a4c4 	.word	0x0802a4c4

080051f4 <BUTTON_USER_EXTI_Callback>:
/**
  * @brief  User EXTI line detection callbacks.
  * @retval None
  */
static void BUTTON_USER_EXTI_Callback(void)
{
 80051f4:	b580      	push	{r7, lr}
 80051f6:	af00      	add	r7, sp, #0
  BSP_PB_Callback(BUTTON_USER);
 80051f8:	2000      	movs	r0, #0
 80051fa:	f7ff fa99 	bl	8004730 <BSP_PB_Callback>
}
 80051fe:	bf00      	nop
 8005200:	bd80      	pop	{r7, pc}
	...

08005204 <BUTTON_USER_GPIO_Init>:

/**
  * @brief
  * @retval None
  */
static void BUTTON_USER_GPIO_Init(void) {
 8005204:	b580      	push	{r7, lr}
 8005206:	b088      	sub	sp, #32
 8005208:	af00      	add	r7, sp, #0

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
 800520a:	4b23      	ldr	r3, [pc, #140]	@ (8005298 <BUTTON_USER_GPIO_Init+0x94>)
 800520c:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8005210:	4a21      	ldr	r2, [pc, #132]	@ (8005298 <BUTTON_USER_GPIO_Init+0x94>)
 8005212:	f043 0304 	orr.w	r3, r3, #4
 8005216:	f8c2 308c 	str.w	r3, [r2, #140]	@ 0x8c
 800521a:	4b1f      	ldr	r3, [pc, #124]	@ (8005298 <BUTTON_USER_GPIO_Init+0x94>)
 800521c:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8005220:	f003 0304 	and.w	r3, r3, #4
 8005224:	60bb      	str	r3, [r7, #8]
 8005226:	68bb      	ldr	r3, [r7, #8]

  /* EXTI interrupt init*/
  HAL_NVIC_SetPriority(EXTI13_IRQn, 0, 0);
 8005228:	2200      	movs	r2, #0
 800522a:	2100      	movs	r1, #0
 800522c:	2018      	movs	r0, #24
 800522e:	f008 fd20 	bl	800dc72 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(EXTI13_IRQn);
 8005232:	2018      	movs	r0, #24
 8005234:	f008 fd37 	bl	800dca6 <HAL_NVIC_EnableIRQ>

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8005238:	f107 030c 	add.w	r3, r7, #12
 800523c:	2200      	movs	r2, #0
 800523e:	601a      	str	r2, [r3, #0]
 8005240:	605a      	str	r2, [r3, #4]
 8005242:	609a      	str	r2, [r3, #8]
 8005244:	60da      	str	r2, [r3, #12]
 8005246:	611a      	str	r2, [r3, #16]

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8005248:	4b13      	ldr	r3, [pc, #76]	@ (8005298 <BUTTON_USER_GPIO_Init+0x94>)
 800524a:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800524e:	4a12      	ldr	r2, [pc, #72]	@ (8005298 <BUTTON_USER_GPIO_Init+0x94>)
 8005250:	f043 0304 	orr.w	r3, r3, #4
 8005254:	f8c2 308c 	str.w	r3, [r2, #140]	@ 0x8c
 8005258:	4b0f      	ldr	r3, [pc, #60]	@ (8005298 <BUTTON_USER_GPIO_Init+0x94>)
 800525a:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800525e:	f003 0304 	and.w	r3, r3, #4
 8005262:	607b      	str	r3, [r7, #4]
 8005264:	687b      	ldr	r3, [r7, #4]

  /*Configure GPIO pin : PTPIN */
  GPIO_InitStruct.Pin = BUS_BSP_BUTTON_GPIO_PIN;
 8005266:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
 800526a:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
 800526c:	4b0b      	ldr	r3, [pc, #44]	@ (800529c <BUTTON_USER_GPIO_Init+0x98>)
 800526e:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8005270:	2300      	movs	r3, #0
 8005272:	617b      	str	r3, [r7, #20]
  HAL_GPIO_Init(BUS_BSP_BUTTON_GPIO_PORT, &GPIO_InitStruct);
 8005274:	f107 030c 	add.w	r3, r7, #12
 8005278:	4619      	mov	r1, r3
 800527a:	4809      	ldr	r0, [pc, #36]	@ (80052a0 <BUTTON_USER_GPIO_Init+0x9c>)
 800527c:	f00a fa72 	bl	800f764 <HAL_GPIO_Init>

  /* EXTI interrupt init*/
  HAL_NVIC_SetPriority(EXTI13_IRQn, 0, 0);
 8005280:	2200      	movs	r2, #0
 8005282:	2100      	movs	r1, #0
 8005284:	2018      	movs	r0, #24
 8005286:	f008 fcf4 	bl	800dc72 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(EXTI13_IRQn);
 800528a:	2018      	movs	r0, #24
 800528c:	f008 fd0b 	bl	800dca6 <HAL_NVIC_EnableIRQ>

}
 8005290:	bf00      	nop
 8005292:	3720      	adds	r7, #32
 8005294:	46bd      	mov	sp, r7
 8005296:	bd80      	pop	{r7, pc}
 8005298:	46020c00 	.word	0x46020c00
 800529c:	10110000 	.word	0x10110000
 80052a0:	42020800 	.word	0x42020800

080052a4 <BSP_COM_Init>:
 * @param  UART_Init: Pointer to a UART_HandleTypeDef structure that contains the
 *                    configuration information for the specified USART peripheral.
 * @retval BSP error code
 */
int32_t BSP_COM_Init(COM_TypeDef COM)
{
 80052a4:	b580      	push	{r7, lr}
 80052a6:	b084      	sub	sp, #16
 80052a8:	af00      	add	r7, sp, #0
 80052aa:	4603      	mov	r3, r0
 80052ac:	71fb      	strb	r3, [r7, #7]
  int32_t ret = BSP_ERROR_NONE;
 80052ae:	2300      	movs	r3, #0
 80052b0:	60fb      	str	r3, [r7, #12]

  if(COM > COMn)
 80052b2:	79fb      	ldrb	r3, [r7, #7]
 80052b4:	2b01      	cmp	r3, #1
 80052b6:	d903      	bls.n	80052c0 <BSP_COM_Init+0x1c>
  {
    ret = BSP_ERROR_WRONG_PARAM;
 80052b8:	f06f 0301 	mvn.w	r3, #1
 80052bc:	60fb      	str	r3, [r7, #12]
 80052be:	e022      	b.n	8005306 <BSP_COM_Init+0x62>
  }
  else
  {
     hcom_uart[COM].Instance = COM_USART[COM];
 80052c0:	79fa      	ldrb	r2, [r7, #7]
 80052c2:	79fb      	ldrb	r3, [r7, #7]
 80052c4:	4912      	ldr	r1, [pc, #72]	@ (8005310 <BSP_COM_Init+0x6c>)
 80052c6:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 80052ca:	4912      	ldr	r1, [pc, #72]	@ (8005314 <BSP_COM_Init+0x70>)
 80052cc:	2094      	movs	r0, #148	@ 0x94
 80052ce:	fb00 f303 	mul.w	r3, r0, r3
 80052d2:	440b      	add	r3, r1
 80052d4:	601a      	str	r2, [r3, #0]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 0U)
    /* Init the UART Msp */
    UART4_MspInit(&hcom_uart[COM]);
 80052d6:	79fb      	ldrb	r3, [r7, #7]
 80052d8:	2294      	movs	r2, #148	@ 0x94
 80052da:	fb02 f303 	mul.w	r3, r2, r3
 80052de:	4a0d      	ldr	r2, [pc, #52]	@ (8005314 <BSP_COM_Init+0x70>)
 80052e0:	4413      	add	r3, r2
 80052e2:	4618      	mov	r0, r3
 80052e4:	f000 f886 	bl	80053f4 <UART4_MspInit>
      {
        return BSP_ERROR_MSP_FAILURE;
      }
    }
#endif
    if (MX_UART4_Init(&hcom_uart[COM]))
 80052e8:	79fb      	ldrb	r3, [r7, #7]
 80052ea:	2294      	movs	r2, #148	@ 0x94
 80052ec:	fb02 f303 	mul.w	r3, r2, r3
 80052f0:	4a08      	ldr	r2, [pc, #32]	@ (8005314 <BSP_COM_Init+0x70>)
 80052f2:	4413      	add	r3, r2
 80052f4:	4618      	mov	r0, r3
 80052f6:	f000 f80f 	bl	8005318 <MX_UART4_Init>
 80052fa:	4603      	mov	r3, r0
 80052fc:	2b00      	cmp	r3, #0
 80052fe:	d002      	beq.n	8005306 <BSP_COM_Init+0x62>
    {
      ret = BSP_ERROR_PERIPH_FAILURE;
 8005300:	f06f 0303 	mvn.w	r3, #3
 8005304:	60fb      	str	r3, [r7, #12]
    }
  }

  return ret;
 8005306:	68fb      	ldr	r3, [r7, #12]
}
 8005308:	4618      	mov	r0, r3
 800530a:	3710      	adds	r7, #16
 800530c:	46bd      	mov	sp, r7
 800530e:	bd80      	pop	{r7, pc}
 8005310:	2000002c 	.word	0x2000002c
 8005314:	200008a0 	.word	0x200008a0

08005318 <MX_UART4_Init>:
 */

/* UART4 init function */

__weak HAL_StatusTypeDef MX_UART4_Init(UART_HandleTypeDef* huart)
{
 8005318:	b580      	push	{r7, lr}
 800531a:	b084      	sub	sp, #16
 800531c:	af00      	add	r7, sp, #0
 800531e:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef ret = HAL_OK;
 8005320:	2300      	movs	r3, #0
 8005322:	73fb      	strb	r3, [r7, #15]

  huart->Instance = BUS_UART4_INSTANCE;
 8005324:	687b      	ldr	r3, [r7, #4]
 8005326:	4a24      	ldr	r2, [pc, #144]	@ (80053b8 <MX_UART4_Init+0xa0>)
 8005328:	601a      	str	r2, [r3, #0]
  huart->Init.BaudRate = 115200;
 800532a:	687b      	ldr	r3, [r7, #4]
 800532c:	f44f 32e1 	mov.w	r2, #115200	@ 0x1c200
 8005330:	605a      	str	r2, [r3, #4]
  huart->Init.WordLength = UART_WORDLENGTH_8B;
 8005332:	687b      	ldr	r3, [r7, #4]
 8005334:	2200      	movs	r2, #0
 8005336:	609a      	str	r2, [r3, #8]
  huart->Init.StopBits = UART_STOPBITS_1;
 8005338:	687b      	ldr	r3, [r7, #4]
 800533a:	2200      	movs	r2, #0
 800533c:	60da      	str	r2, [r3, #12]
  huart->Init.Parity = UART_PARITY_NONE;
 800533e:	687b      	ldr	r3, [r7, #4]
 8005340:	2200      	movs	r2, #0
 8005342:	611a      	str	r2, [r3, #16]
  huart->Init.Mode = UART_MODE_TX_RX;
 8005344:	687b      	ldr	r3, [r7, #4]
 8005346:	220c      	movs	r2, #12
 8005348:	615a      	str	r2, [r3, #20]
  huart->Init.HwFlowCtl = UART_HWCONTROL_NONE;
 800534a:	687b      	ldr	r3, [r7, #4]
 800534c:	2200      	movs	r2, #0
 800534e:	619a      	str	r2, [r3, #24]
  huart->Init.OverSampling = UART_OVERSAMPLING_16;
 8005350:	687b      	ldr	r3, [r7, #4]
 8005352:	2200      	movs	r2, #0
 8005354:	61da      	str	r2, [r3, #28]
  huart->Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 8005356:	687b      	ldr	r3, [r7, #4]
 8005358:	2200      	movs	r2, #0
 800535a:	621a      	str	r2, [r3, #32]
  huart->Init.ClockPrescaler = UART_PRESCALER_DIV1;
 800535c:	687b      	ldr	r3, [r7, #4]
 800535e:	2200      	movs	r2, #0
 8005360:	625a      	str	r2, [r3, #36]	@ 0x24
  huart->AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 8005362:	687b      	ldr	r3, [r7, #4]
 8005364:	2200      	movs	r2, #0
 8005366:	629a      	str	r2, [r3, #40]	@ 0x28
  if (HAL_UART_Init(huart) != HAL_OK)
 8005368:	6878      	ldr	r0, [r7, #4]
 800536a:	f012 fc2a 	bl	8017bc2 <HAL_UART_Init>
 800536e:	4603      	mov	r3, r0
 8005370:	2b00      	cmp	r3, #0
 8005372:	d001      	beq.n	8005378 <MX_UART4_Init+0x60>
  {
    ret = HAL_ERROR;
 8005374:	2301      	movs	r3, #1
 8005376:	73fb      	strb	r3, [r7, #15]
  }

  if (HAL_UARTEx_SetTxFifoThreshold(huart, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
 8005378:	2100      	movs	r1, #0
 800537a:	6878      	ldr	r0, [r7, #4]
 800537c:	f013 f914 	bl	80185a8 <HAL_UARTEx_SetTxFifoThreshold>
 8005380:	4603      	mov	r3, r0
 8005382:	2b00      	cmp	r3, #0
 8005384:	d001      	beq.n	800538a <MX_UART4_Init+0x72>
  {
    ret = HAL_ERROR;
 8005386:	2301      	movs	r3, #1
 8005388:	73fb      	strb	r3, [r7, #15]
  }

  if (HAL_UARTEx_SetRxFifoThreshold(huart, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
 800538a:	2100      	movs	r1, #0
 800538c:	6878      	ldr	r0, [r7, #4]
 800538e:	f013 f949 	bl	8018624 <HAL_UARTEx_SetRxFifoThreshold>
 8005392:	4603      	mov	r3, r0
 8005394:	2b00      	cmp	r3, #0
 8005396:	d001      	beq.n	800539c <MX_UART4_Init+0x84>
  {
    ret = HAL_ERROR;
 8005398:	2301      	movs	r3, #1
 800539a:	73fb      	strb	r3, [r7, #15]
  }

  if (HAL_UARTEx_DisableFifoMode(huart) != HAL_OK)
 800539c:	6878      	ldr	r0, [r7, #4]
 800539e:	f013 f8ca 	bl	8018536 <HAL_UARTEx_DisableFifoMode>
 80053a2:	4603      	mov	r3, r0
 80053a4:	2b00      	cmp	r3, #0
 80053a6:	d001      	beq.n	80053ac <MX_UART4_Init+0x94>
  {
    ret = HAL_ERROR;
 80053a8:	2301      	movs	r3, #1
 80053aa:	73fb      	strb	r3, [r7, #15]
  }

  return ret;
 80053ac:	7bfb      	ldrb	r3, [r7, #15]
}
 80053ae:	4618      	mov	r0, r3
 80053b0:	3710      	adds	r7, #16
 80053b2:	46bd      	mov	sp, r7
 80053b4:	bd80      	pop	{r7, pc}
 80053b6:	bf00      	nop
 80053b8:	40004c00 	.word	0x40004c00

080053bc <__io_putchar>:
  (void)HAL_UART_Transmit(&hcom_uart[COM_ActiveLogPort], (uint8_t *)&ch, 1, COM_POLL_TIMEOUT);
  return ch;
}
#else /* For GCC Toolchains */
int __io_putchar (int ch)
{
 80053bc:	b580      	push	{r7, lr}
 80053be:	b082      	sub	sp, #8
 80053c0:	af00      	add	r7, sp, #0
 80053c2:	6078      	str	r0, [r7, #4]
  (void)HAL_UART_Transmit(&hcom_uart[COM_ActiveLogPort], (uint8_t *)&ch, 1, COM_POLL_TIMEOUT);
 80053c4:	4b09      	ldr	r3, [pc, #36]	@ (80053ec <__io_putchar+0x30>)
 80053c6:	781b      	ldrb	r3, [r3, #0]
 80053c8:	461a      	mov	r2, r3
 80053ca:	2394      	movs	r3, #148	@ 0x94
 80053cc:	fb02 f303 	mul.w	r3, r2, r3
 80053d0:	4a07      	ldr	r2, [pc, #28]	@ (80053f0 <__io_putchar+0x34>)
 80053d2:	1898      	adds	r0, r3, r2
 80053d4:	1d39      	adds	r1, r7, #4
 80053d6:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
 80053da:	2201      	movs	r2, #1
 80053dc:	f012 fc4b 	bl	8017c76 <HAL_UART_Transmit>
  return ch;
 80053e0:	687b      	ldr	r3, [r7, #4]
}
 80053e2:	4618      	mov	r0, r3
 80053e4:	3708      	adds	r7, #8
 80053e6:	46bd      	mov	sp, r7
 80053e8:	bd80      	pop	{r7, pc}
 80053ea:	bf00      	nop
 80053ec:	20000934 	.word	0x20000934
 80053f0:	200008a0 	.word	0x200008a0

080053f4 <UART4_MspInit>:
 * @param  huart UART4 handle
 * @retval None
 */

static void UART4_MspInit(UART_HandleTypeDef* uartHandle)
{
 80053f4:	b580      	push	{r7, lr}
 80053f6:	b0bc      	sub	sp, #240	@ 0xf0
 80053f8:	af00      	add	r7, sp, #0
 80053fa:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct;
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 80053fc:	f107 0310 	add.w	r3, r7, #16
 8005400:	22c8      	movs	r2, #200	@ 0xc8
 8005402:	2100      	movs	r1, #0
 8005404:	4618      	mov	r0, r3
 8005406:	f01e fe2d 	bl	8024064 <memset>

  /* USER CODE END UART4_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_UART4;
 800540a:	f04f 0208 	mov.w	r2, #8
 800540e:	f04f 0300 	mov.w	r3, #0
 8005412:	e9c7 2304 	strd	r2, r3, [r7, #16]
    PeriphClkInit.Uart4ClockSelection = RCC_UART4CLKSOURCE_PCLK1;
 8005416:	2300      	movs	r3, #0
 8005418:	66fb      	str	r3, [r7, #108]	@ 0x6c
    HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit);
 800541a:	f107 0310 	add.w	r3, r7, #16
 800541e:	4618      	mov	r0, r3
 8005420:	f00d fd50 	bl	8012ec4 <HAL_RCCEx_PeriphCLKConfig>

    /* Enable Peripheral clock */
    __HAL_RCC_UART4_CLK_ENABLE();
 8005424:	4b25      	ldr	r3, [pc, #148]	@ (80054bc <UART4_MspInit+0xc8>)
 8005426:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
 800542a:	4a24      	ldr	r2, [pc, #144]	@ (80054bc <UART4_MspInit+0xc8>)
 800542c:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
 8005430:	f8c2 309c 	str.w	r3, [r2, #156]	@ 0x9c
 8005434:	4b21      	ldr	r3, [pc, #132]	@ (80054bc <UART4_MspInit+0xc8>)
 8005436:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
 800543a:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
 800543e:	60fb      	str	r3, [r7, #12]
 8005440:	68fb      	ldr	r3, [r7, #12]

    __HAL_RCC_GPIOA_CLK_ENABLE();
 8005442:	4b1e      	ldr	r3, [pc, #120]	@ (80054bc <UART4_MspInit+0xc8>)
 8005444:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8005448:	4a1c      	ldr	r2, [pc, #112]	@ (80054bc <UART4_MspInit+0xc8>)
 800544a:	f043 0301 	orr.w	r3, r3, #1
 800544e:	f8c2 308c 	str.w	r3, [r2, #140]	@ 0x8c
 8005452:	4b1a      	ldr	r3, [pc, #104]	@ (80054bc <UART4_MspInit+0xc8>)
 8005454:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8005458:	f003 0301 	and.w	r3, r3, #1
 800545c:	60bb      	str	r3, [r7, #8]
 800545e:	68bb      	ldr	r3, [r7, #8]
    /**UART4 GPIO Configuration
    PA0     ------> UART4_TX
    PA1     ------> UART4_RX
    */
    GPIO_InitStruct.Pin = BUS_UART4_TX_GPIO_PIN;
 8005460:	2301      	movs	r3, #1
 8005462:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8005466:	2302      	movs	r3, #2
 8005468:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800546c:	2300      	movs	r3, #0
 800546e:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8005472:	2300      	movs	r3, #0
 8005474:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
    GPIO_InitStruct.Alternate = BUS_UART4_TX_GPIO_AF;
 8005478:	2308      	movs	r3, #8
 800547a:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
    HAL_GPIO_Init(BUS_UART4_TX_GPIO_PORT, &GPIO_InitStruct);
 800547e:	f107 03dc 	add.w	r3, r7, #220	@ 0xdc
 8005482:	4619      	mov	r1, r3
 8005484:	480e      	ldr	r0, [pc, #56]	@ (80054c0 <UART4_MspInit+0xcc>)
 8005486:	f00a f96d 	bl	800f764 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = BUS_UART4_RX_GPIO_PIN;
 800548a:	2302      	movs	r3, #2
 800548c:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8005490:	2302      	movs	r3, #2
 8005492:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8005496:	2300      	movs	r3, #0
 8005498:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800549c:	2300      	movs	r3, #0
 800549e:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
    GPIO_InitStruct.Alternate = BUS_UART4_RX_GPIO_AF;
 80054a2:	2308      	movs	r3, #8
 80054a4:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
    HAL_GPIO_Init(BUS_UART4_RX_GPIO_PORT, &GPIO_InitStruct);
 80054a8:	f107 03dc 	add.w	r3, r7, #220	@ 0xdc
 80054ac:	4619      	mov	r1, r3
 80054ae:	4804      	ldr	r0, [pc, #16]	@ (80054c0 <UART4_MspInit+0xcc>)
 80054b0:	f00a f958 	bl	800f764 <HAL_GPIO_Init>

  /* USER CODE BEGIN UART4_MspInit 1 */

  /* USER CODE END UART4_MspInit 1 */
}
 80054b4:	bf00      	nop
 80054b6:	37f0      	adds	r7, #240	@ 0xf0
 80054b8:	46bd      	mov	sp, r7
 80054ba:	bd80      	pop	{r7, pc}
 80054bc:	46020c00 	.word	0x46020c00
 80054c0:	42020000 	.word	0x42020000

080054c4 <BSP_I2C2_Init>:
/**
  * @brief  Initialize I2C HAL
  * @retval BSP status
  */
int32_t BSP_I2C2_Init(void)
{
 80054c4:	b580      	push	{r7, lr}
 80054c6:	b082      	sub	sp, #8
 80054c8:	af00      	add	r7, sp, #0

  int32_t ret = BSP_ERROR_NONE;
 80054ca:	2300      	movs	r3, #0
 80054cc:	607b      	str	r3, [r7, #4]

  hi2c2.Instance  = I2C2;
 80054ce:	4b19      	ldr	r3, [pc, #100]	@ (8005534 <BSP_I2C2_Init+0x70>)
 80054d0:	4a19      	ldr	r2, [pc, #100]	@ (8005538 <BSP_I2C2_Init+0x74>)
 80054d2:	601a      	str	r2, [r3, #0]

  if(I2C2InitCounter++ == 0)
 80054d4:	4b19      	ldr	r3, [pc, #100]	@ (800553c <BSP_I2C2_Init+0x78>)
 80054d6:	681b      	ldr	r3, [r3, #0]
 80054d8:	1c5a      	adds	r2, r3, #1
 80054da:	4918      	ldr	r1, [pc, #96]	@ (800553c <BSP_I2C2_Init+0x78>)
 80054dc:	600a      	str	r2, [r1, #0]
 80054de:	2b00      	cmp	r3, #0
 80054e0:	d122      	bne.n	8005528 <BSP_I2C2_Init+0x64>
  {
    if (HAL_I2C_GetState(&hi2c2) == HAL_I2C_STATE_RESET)
 80054e2:	4814      	ldr	r0, [pc, #80]	@ (8005534 <BSP_I2C2_Init+0x70>)
 80054e4:	f00b f827 	bl	8010536 <HAL_I2C_GetState>
 80054e8:	4603      	mov	r3, r0
 80054ea:	2b00      	cmp	r3, #0
 80054ec:	d11c      	bne.n	8005528 <BSP_I2C2_Init+0x64>
    {
    #if (USE_HAL_I2C_REGISTER_CALLBACKS == 0U)
      /* Init the I2C Msp */
      I2C2_MspInit(&hi2c2);
 80054ee:	4811      	ldr	r0, [pc, #68]	@ (8005534 <BSP_I2C2_Init+0x70>)
 80054f0:	f000 fb7c 	bl	8005bec <I2C2_MspInit>
        {
          return BSP_ERROR_MSP_FAILURE;
        }
      }
    #endif
      if(ret == BSP_ERROR_NONE)
 80054f4:	687b      	ldr	r3, [r7, #4]
 80054f6:	2b00      	cmp	r3, #0
 80054f8:	d116      	bne.n	8005528 <BSP_I2C2_Init+0x64>
      {
        /* Init the I2C */
        if(MX_I2C2_Init(&hi2c2) != HAL_OK)
 80054fa:	480e      	ldr	r0, [pc, #56]	@ (8005534 <BSP_I2C2_Init+0x70>)
 80054fc:	f000 fb32 	bl	8005b64 <MX_I2C2_Init>
 8005500:	4603      	mov	r3, r0
 8005502:	2b00      	cmp	r3, #0
 8005504:	d003      	beq.n	800550e <BSP_I2C2_Init+0x4a>
        {
          ret = BSP_ERROR_BUS_FAILURE;
 8005506:	f06f 0307 	mvn.w	r3, #7
 800550a:	607b      	str	r3, [r7, #4]
 800550c:	e00c      	b.n	8005528 <BSP_I2C2_Init+0x64>
        }
        else if(HAL_I2CEx_ConfigAnalogFilter(&hi2c2, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
 800550e:	2100      	movs	r1, #0
 8005510:	4808      	ldr	r0, [pc, #32]	@ (8005534 <BSP_I2C2_Init+0x70>)
 8005512:	f00c f837 	bl	8011584 <HAL_I2CEx_ConfigAnalogFilter>
 8005516:	4603      	mov	r3, r0
 8005518:	2b00      	cmp	r3, #0
 800551a:	d003      	beq.n	8005524 <BSP_I2C2_Init+0x60>
        {
          ret = BSP_ERROR_BUS_FAILURE;
 800551c:	f06f 0307 	mvn.w	r3, #7
 8005520:	607b      	str	r3, [r7, #4]
 8005522:	e001      	b.n	8005528 <BSP_I2C2_Init+0x64>
        }
        else
        {
          ret = BSP_ERROR_NONE;
 8005524:	2300      	movs	r3, #0
 8005526:	607b      	str	r3, [r7, #4]
        }
      }
    }
  }
  return ret;
 8005528:	687b      	ldr	r3, [r7, #4]
}
 800552a:	4618      	mov	r0, r3
 800552c:	3708      	adds	r7, #8
 800552e:	46bd      	mov	sp, r7
 8005530:	bd80      	pop	{r7, pc}
 8005532:	bf00      	nop
 8005534:	20000938 	.word	0x20000938
 8005538:	40005800 	.word	0x40005800
 800553c:	20000ac4 	.word	0x20000ac4

08005540 <BSP_I2C2_DeInit>:
/**
  * @brief  DeInitialize I2C HAL.
  * @retval BSP status
  */
int32_t BSP_I2C2_DeInit(void)
{
 8005540:	b580      	push	{r7, lr}
 8005542:	b082      	sub	sp, #8
 8005544:	af00      	add	r7, sp, #0
  int32_t ret = BSP_ERROR_NONE;
 8005546:	2300      	movs	r3, #0
 8005548:	607b      	str	r3, [r7, #4]

  if (I2C2InitCounter > 0)
 800554a:	4b0f      	ldr	r3, [pc, #60]	@ (8005588 <BSP_I2C2_DeInit+0x48>)
 800554c:	681b      	ldr	r3, [r3, #0]
 800554e:	2b00      	cmp	r3, #0
 8005550:	d014      	beq.n	800557c <BSP_I2C2_DeInit+0x3c>
  {
    if (--I2C2InitCounter == 0)
 8005552:	4b0d      	ldr	r3, [pc, #52]	@ (8005588 <BSP_I2C2_DeInit+0x48>)
 8005554:	681b      	ldr	r3, [r3, #0]
 8005556:	3b01      	subs	r3, #1
 8005558:	4a0b      	ldr	r2, [pc, #44]	@ (8005588 <BSP_I2C2_DeInit+0x48>)
 800555a:	6013      	str	r3, [r2, #0]
 800555c:	4b0a      	ldr	r3, [pc, #40]	@ (8005588 <BSP_I2C2_DeInit+0x48>)
 800555e:	681b      	ldr	r3, [r3, #0]
 8005560:	2b00      	cmp	r3, #0
 8005562:	d10b      	bne.n	800557c <BSP_I2C2_DeInit+0x3c>
    {
  #if (USE_HAL_I2C_REGISTER_CALLBACKS == 0U)
      /* DeInit the I2C */
      I2C2_MspDeInit(&hi2c2);
 8005564:	4809      	ldr	r0, [pc, #36]	@ (800558c <BSP_I2C2_DeInit+0x4c>)
 8005566:	f000 fbbb 	bl	8005ce0 <I2C2_MspDeInit>
  #endif
      /* DeInit the I2C */
      if (HAL_I2C_DeInit(&hi2c2) != HAL_OK)
 800556a:	4808      	ldr	r0, [pc, #32]	@ (800558c <BSP_I2C2_DeInit+0x4c>)
 800556c:	f00a fcb7 	bl	800fede <HAL_I2C_DeInit>
 8005570:	4603      	mov	r3, r0
 8005572:	2b00      	cmp	r3, #0
 8005574:	d002      	beq.n	800557c <BSP_I2C2_DeInit+0x3c>
      {
        ret = BSP_ERROR_BUS_FAILURE;
 8005576:	f06f 0307 	mvn.w	r3, #7
 800557a:	607b      	str	r3, [r7, #4]
      }
    }
  }
  return ret;
 800557c:	687b      	ldr	r3, [r7, #4]
}
 800557e:	4618      	mov	r0, r3
 8005580:	3708      	adds	r7, #8
 8005582:	46bd      	mov	sp, r7
 8005584:	bd80      	pop	{r7, pc}
 8005586:	bf00      	nop
 8005588:	20000ac4 	.word	0x20000ac4
 800558c:	20000938 	.word	0x20000938

08005590 <BSP_I2C2_ReadReg16>:
  * @param  Reg: The target register address to read
  * @param  Length Data Length
  * @retval BSP status
  */
int32_t  BSP_I2C2_ReadReg16(uint16_t DevAddr, uint16_t Reg, uint8_t *pData, uint16_t Length)
{
 8005590:	b580      	push	{r7, lr}
 8005592:	b08a      	sub	sp, #40	@ 0x28
 8005594:	af04      	add	r7, sp, #16
 8005596:	60ba      	str	r2, [r7, #8]
 8005598:	461a      	mov	r2, r3
 800559a:	4603      	mov	r3, r0
 800559c:	81fb      	strh	r3, [r7, #14]
 800559e:	460b      	mov	r3, r1
 80055a0:	81bb      	strh	r3, [r7, #12]
 80055a2:	4613      	mov	r3, r2
 80055a4:	80fb      	strh	r3, [r7, #6]
  int32_t ret = BSP_ERROR_NONE;
 80055a6:	2300      	movs	r3, #0
 80055a8:	617b      	str	r3, [r7, #20]

  if (HAL_I2C_Mem_Read(&hi2c2, DevAddr, Reg, I2C_MEMADD_SIZE_16BIT, pData, Length, BUS_I2C2_POLL_TIMEOUT) != HAL_OK)
 80055aa:	89ba      	ldrh	r2, [r7, #12]
 80055ac:	89f9      	ldrh	r1, [r7, #14]
 80055ae:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 80055b2:	9302      	str	r3, [sp, #8]
 80055b4:	88fb      	ldrh	r3, [r7, #6]
 80055b6:	9301      	str	r3, [sp, #4]
 80055b8:	68bb      	ldr	r3, [r7, #8]
 80055ba:	9300      	str	r3, [sp, #0]
 80055bc:	2302      	movs	r3, #2
 80055be:	480c      	ldr	r0, [pc, #48]	@ (80055f0 <BSP_I2C2_ReadReg16+0x60>)
 80055c0:	f00a fde4 	bl	801018c <HAL_I2C_Mem_Read>
 80055c4:	4603      	mov	r3, r0
 80055c6:	2b00      	cmp	r3, #0
 80055c8:	d00c      	beq.n	80055e4 <BSP_I2C2_ReadReg16+0x54>
  {
    if (HAL_I2C_GetError(&hi2c2) != HAL_I2C_ERROR_AF)
 80055ca:	4809      	ldr	r0, [pc, #36]	@ (80055f0 <BSP_I2C2_ReadReg16+0x60>)
 80055cc:	f00a ffc1 	bl	8010552 <HAL_I2C_GetError>
 80055d0:	4603      	mov	r3, r0
 80055d2:	2b04      	cmp	r3, #4
 80055d4:	d003      	beq.n	80055de <BSP_I2C2_ReadReg16+0x4e>
    {
      ret =  BSP_ERROR_BUS_ACKNOWLEDGE_FAILURE;
 80055d6:	f06f 0365 	mvn.w	r3, #101	@ 0x65
 80055da:	617b      	str	r3, [r7, #20]
 80055dc:	e002      	b.n	80055e4 <BSP_I2C2_ReadReg16+0x54>
    }
    else
    {
      ret =  BSP_ERROR_PERIPH_FAILURE;
 80055de:	f06f 0303 	mvn.w	r3, #3
 80055e2:	617b      	str	r3, [r7, #20]
    }
  }
  return ret;
 80055e4:	697b      	ldr	r3, [r7, #20]
}
 80055e6:	4618      	mov	r0, r3
 80055e8:	3718      	adds	r7, #24
 80055ea:	46bd      	mov	sp, r7
 80055ec:	bd80      	pop	{r7, pc}
 80055ee:	bf00      	nop
 80055f0:	20000938 	.word	0x20000938

080055f4 <BSP_I2C4_Init>:
/**
  * @brief  Initialize I2C HAL
  * @retval BSP status
  */
int32_t BSP_I2C4_Init(void)
{
 80055f4:	b580      	push	{r7, lr}
 80055f6:	b082      	sub	sp, #8
 80055f8:	af00      	add	r7, sp, #0

  int32_t ret = BSP_ERROR_NONE;
 80055fa:	2300      	movs	r3, #0
 80055fc:	607b      	str	r3, [r7, #4]

  hi2c4.Instance  = I2C4;
 80055fe:	4b19      	ldr	r3, [pc, #100]	@ (8005664 <BSP_I2C4_Init+0x70>)
 8005600:	4a19      	ldr	r2, [pc, #100]	@ (8005668 <BSP_I2C4_Init+0x74>)
 8005602:	601a      	str	r2, [r3, #0]

  if(I2C4InitCounter++ == 0)
 8005604:	4b19      	ldr	r3, [pc, #100]	@ (800566c <BSP_I2C4_Init+0x78>)
 8005606:	681b      	ldr	r3, [r3, #0]
 8005608:	1c5a      	adds	r2, r3, #1
 800560a:	4918      	ldr	r1, [pc, #96]	@ (800566c <BSP_I2C4_Init+0x78>)
 800560c:	600a      	str	r2, [r1, #0]
 800560e:	2b00      	cmp	r3, #0
 8005610:	d122      	bne.n	8005658 <BSP_I2C4_Init+0x64>
  {
    if (HAL_I2C_GetState(&hi2c4) == HAL_I2C_STATE_RESET)
 8005612:	4814      	ldr	r0, [pc, #80]	@ (8005664 <BSP_I2C4_Init+0x70>)
 8005614:	f00a ff8f 	bl	8010536 <HAL_I2C_GetState>
 8005618:	4603      	mov	r3, r0
 800561a:	2b00      	cmp	r3, #0
 800561c:	d11c      	bne.n	8005658 <BSP_I2C4_Init+0x64>
    {
    #if (USE_HAL_I2C_REGISTER_CALLBACKS == 0U)
      /* Init the I2C Msp */
      I2C4_MspInit(&hi2c4);
 800561e:	4811      	ldr	r0, [pc, #68]	@ (8005664 <BSP_I2C4_Init+0x70>)
 8005620:	f000 fbc6 	bl	8005db0 <I2C4_MspInit>
        {
          return BSP_ERROR_MSP_FAILURE;
        }
      }
    #endif
      if(ret == BSP_ERROR_NONE)
 8005624:	687b      	ldr	r3, [r7, #4]
 8005626:	2b00      	cmp	r3, #0
 8005628:	d116      	bne.n	8005658 <BSP_I2C4_Init+0x64>
      {
        /* Init the I2C */
        if(MX_I2C4_Init(&hi2c4) != HAL_OK)
 800562a:	480e      	ldr	r0, [pc, #56]	@ (8005664 <BSP_I2C4_Init+0x70>)
 800562c:	f000 fb7c 	bl	8005d28 <MX_I2C4_Init>
 8005630:	4603      	mov	r3, r0
 8005632:	2b00      	cmp	r3, #0
 8005634:	d003      	beq.n	800563e <BSP_I2C4_Init+0x4a>
        {
          ret = BSP_ERROR_BUS_FAILURE;
 8005636:	f06f 0307 	mvn.w	r3, #7
 800563a:	607b      	str	r3, [r7, #4]
 800563c:	e00c      	b.n	8005658 <BSP_I2C4_Init+0x64>
        }
        else if(HAL_I2CEx_ConfigAnalogFilter(&hi2c4, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
 800563e:	2100      	movs	r1, #0
 8005640:	4808      	ldr	r0, [pc, #32]	@ (8005664 <BSP_I2C4_Init+0x70>)
 8005642:	f00b ff9f 	bl	8011584 <HAL_I2CEx_ConfigAnalogFilter>
 8005646:	4603      	mov	r3, r0
 8005648:	2b00      	cmp	r3, #0
 800564a:	d003      	beq.n	8005654 <BSP_I2C4_Init+0x60>
        {
          ret = BSP_ERROR_BUS_FAILURE;
 800564c:	f06f 0307 	mvn.w	r3, #7
 8005650:	607b      	str	r3, [r7, #4]
 8005652:	e001      	b.n	8005658 <BSP_I2C4_Init+0x64>
        }
        else
        {
          ret = BSP_ERROR_NONE;
 8005654:	2300      	movs	r3, #0
 8005656:	607b      	str	r3, [r7, #4]
        }
      }
    }
  }
  return ret;
 8005658:	687b      	ldr	r3, [r7, #4]
}
 800565a:	4618      	mov	r0, r3
 800565c:	3708      	adds	r7, #8
 800565e:	46bd      	mov	sp, r7
 8005660:	bd80      	pop	{r7, pc}
 8005662:	bf00      	nop
 8005664:	2000098c 	.word	0x2000098c
 8005668:	40008400 	.word	0x40008400
 800566c:	20000ac8 	.word	0x20000ac8

08005670 <BSP_I2C4_WriteReg>:
  * @param  Length Data Length
  * @retval BSP status
  */

int32_t BSP_I2C4_WriteReg(uint16_t DevAddr, uint16_t Reg, uint8_t *pData, uint16_t Length)
{
 8005670:	b580      	push	{r7, lr}
 8005672:	b08a      	sub	sp, #40	@ 0x28
 8005674:	af04      	add	r7, sp, #16
 8005676:	60ba      	str	r2, [r7, #8]
 8005678:	461a      	mov	r2, r3
 800567a:	4603      	mov	r3, r0
 800567c:	81fb      	strh	r3, [r7, #14]
 800567e:	460b      	mov	r3, r1
 8005680:	81bb      	strh	r3, [r7, #12]
 8005682:	4613      	mov	r3, r2
 8005684:	80fb      	strh	r3, [r7, #6]
  int32_t ret = BSP_ERROR_NONE;
 8005686:	2300      	movs	r3, #0
 8005688:	617b      	str	r3, [r7, #20]

  if (HAL_I2C_Mem_Write(&hi2c4, DevAddr,Reg, I2C_MEMADD_SIZE_8BIT,pData, Length, BUS_I2C4_POLL_TIMEOUT) != HAL_OK)
 800568a:	89ba      	ldrh	r2, [r7, #12]
 800568c:	89f9      	ldrh	r1, [r7, #14]
 800568e:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 8005692:	9302      	str	r3, [sp, #8]
 8005694:	88fb      	ldrh	r3, [r7, #6]
 8005696:	9301      	str	r3, [sp, #4]
 8005698:	68bb      	ldr	r3, [r7, #8]
 800569a:	9300      	str	r3, [sp, #0]
 800569c:	2301      	movs	r3, #1
 800569e:	480c      	ldr	r0, [pc, #48]	@ (80056d0 <BSP_I2C4_WriteReg+0x60>)
 80056a0:	f00a fc60 	bl	800ff64 <HAL_I2C_Mem_Write>
 80056a4:	4603      	mov	r3, r0
 80056a6:	2b00      	cmp	r3, #0
 80056a8:	d00c      	beq.n	80056c4 <BSP_I2C4_WriteReg+0x54>
  {
    if (HAL_I2C_GetError(&hi2c4) == HAL_I2C_ERROR_AF)
 80056aa:	4809      	ldr	r0, [pc, #36]	@ (80056d0 <BSP_I2C4_WriteReg+0x60>)
 80056ac:	f00a ff51 	bl	8010552 <HAL_I2C_GetError>
 80056b0:	4603      	mov	r3, r0
 80056b2:	2b04      	cmp	r3, #4
 80056b4:	d103      	bne.n	80056be <BSP_I2C4_WriteReg+0x4e>
    {
      ret = BSP_ERROR_BUS_ACKNOWLEDGE_FAILURE;
 80056b6:	f06f 0365 	mvn.w	r3, #101	@ 0x65
 80056ba:	617b      	str	r3, [r7, #20]
 80056bc:	e002      	b.n	80056c4 <BSP_I2C4_WriteReg+0x54>
    }
    else
    {
      ret =  BSP_ERROR_PERIPH_FAILURE;
 80056be:	f06f 0303 	mvn.w	r3, #3
 80056c2:	617b      	str	r3, [r7, #20]
    }
  }
  return ret;
 80056c4:	697b      	ldr	r3, [r7, #20]
}
 80056c6:	4618      	mov	r0, r3
 80056c8:	3718      	adds	r7, #24
 80056ca:	46bd      	mov	sp, r7
 80056cc:	bd80      	pop	{r7, pc}
 80056ce:	bf00      	nop
 80056d0:	2000098c 	.word	0x2000098c

080056d4 <BSP_I2C4_ReadReg>:
  * @param  pData  Pointer to data buffer to read
  * @param  Length Data Length
  * @retval BSP status
  */
int32_t  BSP_I2C4_ReadReg(uint16_t DevAddr, uint16_t Reg, uint8_t *pData, uint16_t Length)
{
 80056d4:	b580      	push	{r7, lr}
 80056d6:	b08a      	sub	sp, #40	@ 0x28
 80056d8:	af04      	add	r7, sp, #16
 80056da:	60ba      	str	r2, [r7, #8]
 80056dc:	461a      	mov	r2, r3
 80056de:	4603      	mov	r3, r0
 80056e0:	81fb      	strh	r3, [r7, #14]
 80056e2:	460b      	mov	r3, r1
 80056e4:	81bb      	strh	r3, [r7, #12]
 80056e6:	4613      	mov	r3, r2
 80056e8:	80fb      	strh	r3, [r7, #6]
  int32_t ret = BSP_ERROR_NONE;
 80056ea:	2300      	movs	r3, #0
 80056ec:	617b      	str	r3, [r7, #20]

  if (HAL_I2C_Mem_Read(&hi2c4, DevAddr, Reg, I2C_MEMADD_SIZE_8BIT, pData, Length, BUS_I2C4_POLL_TIMEOUT) != HAL_OK)
 80056ee:	89ba      	ldrh	r2, [r7, #12]
 80056f0:	89f9      	ldrh	r1, [r7, #14]
 80056f2:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 80056f6:	9302      	str	r3, [sp, #8]
 80056f8:	88fb      	ldrh	r3, [r7, #6]
 80056fa:	9301      	str	r3, [sp, #4]
 80056fc:	68bb      	ldr	r3, [r7, #8]
 80056fe:	9300      	str	r3, [sp, #0]
 8005700:	2301      	movs	r3, #1
 8005702:	480c      	ldr	r0, [pc, #48]	@ (8005734 <BSP_I2C4_ReadReg+0x60>)
 8005704:	f00a fd42 	bl	801018c <HAL_I2C_Mem_Read>
 8005708:	4603      	mov	r3, r0
 800570a:	2b00      	cmp	r3, #0
 800570c:	d00c      	beq.n	8005728 <BSP_I2C4_ReadReg+0x54>
  {
    if (HAL_I2C_GetError(&hi2c4) == HAL_I2C_ERROR_AF)
 800570e:	4809      	ldr	r0, [pc, #36]	@ (8005734 <BSP_I2C4_ReadReg+0x60>)
 8005710:	f00a ff1f 	bl	8010552 <HAL_I2C_GetError>
 8005714:	4603      	mov	r3, r0
 8005716:	2b04      	cmp	r3, #4
 8005718:	d103      	bne.n	8005722 <BSP_I2C4_ReadReg+0x4e>
    {
      ret = BSP_ERROR_BUS_ACKNOWLEDGE_FAILURE;
 800571a:	f06f 0365 	mvn.w	r3, #101	@ 0x65
 800571e:	617b      	str	r3, [r7, #20]
 8005720:	e002      	b.n	8005728 <BSP_I2C4_ReadReg+0x54>
    }
    else
    {
      ret = BSP_ERROR_PERIPH_FAILURE;
 8005722:	f06f 0303 	mvn.w	r3, #3
 8005726:	617b      	str	r3, [r7, #20]
    }
  }
  return ret;
 8005728:	697b      	ldr	r3, [r7, #20]
}
 800572a:	4618      	mov	r0, r3
 800572c:	3718      	adds	r7, #24
 800572e:	46bd      	mov	sp, r7
 8005730:	bd80      	pop	{r7, pc}
 8005732:	bf00      	nop
 8005734:	2000098c 	.word	0x2000098c

08005738 <BSP_SPI1_Init>:
/**
  * @brief  Initializes SPI HAL.
  * @retval BSP status
  */
int32_t BSP_SPI1_Init(void)
{
 8005738:	b580      	push	{r7, lr}
 800573a:	b082      	sub	sp, #8
 800573c:	af00      	add	r7, sp, #0
  int32_t ret = BSP_ERROR_NONE;
 800573e:	2300      	movs	r3, #0
 8005740:	607b      	str	r3, [r7, #4]

  hspi1.Instance  = SPI1;
 8005742:	4b12      	ldr	r3, [pc, #72]	@ (800578c <BSP_SPI1_Init+0x54>)
 8005744:	4a12      	ldr	r2, [pc, #72]	@ (8005790 <BSP_SPI1_Init+0x58>)
 8005746:	601a      	str	r2, [r3, #0]

  if(SPI1InitCounter++ == 0)
 8005748:	4b12      	ldr	r3, [pc, #72]	@ (8005794 <BSP_SPI1_Init+0x5c>)
 800574a:	681b      	ldr	r3, [r3, #0]
 800574c:	1c5a      	adds	r2, r3, #1
 800574e:	4911      	ldr	r1, [pc, #68]	@ (8005794 <BSP_SPI1_Init+0x5c>)
 8005750:	600a      	str	r2, [r1, #0]
 8005752:	2b00      	cmp	r3, #0
 8005754:	d114      	bne.n	8005780 <BSP_SPI1_Init+0x48>
  {
    if (HAL_SPI_GetState(&hspi1) == HAL_SPI_STATE_RESET)
 8005756:	480d      	ldr	r0, [pc, #52]	@ (800578c <BSP_SPI1_Init+0x54>)
 8005758:	f010 fe0a 	bl	8016370 <HAL_SPI_GetState>
 800575c:	4603      	mov	r3, r0
 800575e:	2b00      	cmp	r3, #0
 8005760:	d10e      	bne.n	8005780 <BSP_SPI1_Init+0x48>
    {
#if (USE_HAL_SPI_REGISTER_CALLBACKS == 0U)
        /* Init the SPI Msp */
        SPI1_MspInit(&hspi1);
 8005762:	480a      	ldr	r0, [pc, #40]	@ (800578c <BSP_SPI1_Init+0x54>)
 8005764:	f000 f97e 	bl	8005a64 <SPI1_MspInit>
            {
                return BSP_ERROR_MSP_FAILURE;
            }
        }
#endif
        if(ret == BSP_ERROR_NONE)
 8005768:	687b      	ldr	r3, [r7, #4]
 800576a:	2b00      	cmp	r3, #0
 800576c:	d108      	bne.n	8005780 <BSP_SPI1_Init+0x48>
        {
            /* Init the SPI */
            if (MX_SPI1_Init(&hspi1) != HAL_OK)
 800576e:	4807      	ldr	r0, [pc, #28]	@ (800578c <BSP_SPI1_Init+0x54>)
 8005770:	f000 f904 	bl	800597c <MX_SPI1_Init>
 8005774:	4603      	mov	r3, r0
 8005776:	2b00      	cmp	r3, #0
 8005778:	d002      	beq.n	8005780 <BSP_SPI1_Init+0x48>
            {
                ret = BSP_ERROR_BUS_FAILURE;
 800577a:	f06f 0307 	mvn.w	r3, #7
 800577e:	607b      	str	r3, [r7, #4]
            }
        }
    }
  }

  return ret;
 8005780:	687b      	ldr	r3, [r7, #4]
}
 8005782:	4618      	mov	r0, r3
 8005784:	3708      	adds	r7, #8
 8005786:	46bd      	mov	sp, r7
 8005788:	bd80      	pop	{r7, pc}
 800578a:	bf00      	nop
 800578c:	200009e0 	.word	0x200009e0
 8005790:	40013000 	.word	0x40013000
 8005794:	20000acc 	.word	0x20000acc

08005798 <BSP_SPI1_SendRecv>:
  * @param  pData: Pointer to data buffer to send/receive
  * @param  Length: Length of data in byte
  * @retval BSP status
  */
int32_t BSP_SPI1_SendRecv(uint8_t *pTxData, uint8_t *pRxData, uint16_t Length)
{
 8005798:	b580      	push	{r7, lr}
 800579a:	b088      	sub	sp, #32
 800579c:	af02      	add	r7, sp, #8
 800579e:	60f8      	str	r0, [r7, #12]
 80057a0:	60b9      	str	r1, [r7, #8]
 80057a2:	4613      	mov	r3, r2
 80057a4:	80fb      	strh	r3, [r7, #6]
  int32_t ret = BSP_ERROR_NONE;
 80057a6:	2300      	movs	r3, #0
 80057a8:	617b      	str	r3, [r7, #20]

  if(HAL_SPI_TransmitReceive(&hspi1, pTxData, pRxData, Length, BUS_SPI1_POLL_TIMEOUT) != HAL_OK)
 80057aa:	88fb      	ldrh	r3, [r7, #6]
 80057ac:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
 80057b0:	9200      	str	r2, [sp, #0]
 80057b2:	68ba      	ldr	r2, [r7, #8]
 80057b4:	68f9      	ldr	r1, [r7, #12]
 80057b6:	4807      	ldr	r0, [pc, #28]	@ (80057d4 <BSP_SPI1_SendRecv+0x3c>)
 80057b8:	f010 f97a 	bl	8015ab0 <HAL_SPI_TransmitReceive>
 80057bc:	4603      	mov	r3, r0
 80057be:	2b00      	cmp	r3, #0
 80057c0:	d002      	beq.n	80057c8 <BSP_SPI1_SendRecv+0x30>
  {
      ret = BSP_ERROR_UNKNOWN_FAILURE;
 80057c2:	f06f 0305 	mvn.w	r3, #5
 80057c6:	617b      	str	r3, [r7, #20]
  }
  return ret;
 80057c8:	697b      	ldr	r3, [r7, #20]
}
 80057ca:	4618      	mov	r0, r3
 80057cc:	3718      	adds	r7, #24
 80057ce:	46bd      	mov	sp, r7
 80057d0:	bd80      	pop	{r7, pc}
 80057d2:	bf00      	nop
 80057d4:	200009e0 	.word	0x200009e0

080057d8 <BSP_I2C1_Init>:
/**
  * @brief  Initialize I2C HAL
  * @retval BSP status
  */
int32_t BSP_I2C1_Init(void)
{
 80057d8:	b580      	push	{r7, lr}
 80057da:	b082      	sub	sp, #8
 80057dc:	af00      	add	r7, sp, #0

  int32_t ret = BSP_ERROR_NONE;
 80057de:	2300      	movs	r3, #0
 80057e0:	607b      	str	r3, [r7, #4]

  hi2c1.Instance  = I2C1;
 80057e2:	4b19      	ldr	r3, [pc, #100]	@ (8005848 <BSP_I2C1_Init+0x70>)
 80057e4:	4a19      	ldr	r2, [pc, #100]	@ (800584c <BSP_I2C1_Init+0x74>)
 80057e6:	601a      	str	r2, [r3, #0]

  if(I2C1InitCounter++ == 0)
 80057e8:	4b19      	ldr	r3, [pc, #100]	@ (8005850 <BSP_I2C1_Init+0x78>)
 80057ea:	681b      	ldr	r3, [r3, #0]
 80057ec:	1c5a      	adds	r2, r3, #1
 80057ee:	4918      	ldr	r1, [pc, #96]	@ (8005850 <BSP_I2C1_Init+0x78>)
 80057f0:	600a      	str	r2, [r1, #0]
 80057f2:	2b00      	cmp	r3, #0
 80057f4:	d122      	bne.n	800583c <BSP_I2C1_Init+0x64>
  {
    if (HAL_I2C_GetState(&hi2c1) == HAL_I2C_STATE_RESET)
 80057f6:	4814      	ldr	r0, [pc, #80]	@ (8005848 <BSP_I2C1_Init+0x70>)
 80057f8:	f00a fe9d 	bl	8010536 <HAL_I2C_GetState>
 80057fc:	4603      	mov	r3, r0
 80057fe:	2b00      	cmp	r3, #0
 8005800:	d11c      	bne.n	800583c <BSP_I2C1_Init+0x64>
    {
    #if (USE_HAL_I2C_REGISTER_CALLBACKS == 0U)
      /* Init the I2C Msp */
      I2C1_MspInit(&hi2c1);
 8005802:	4811      	ldr	r0, [pc, #68]	@ (8005848 <BSP_I2C1_Init+0x70>)
 8005804:	f000 fb94 	bl	8005f30 <I2C1_MspInit>
        {
          return BSP_ERROR_MSP_FAILURE;
        }
      }
    #endif
      if(ret == BSP_ERROR_NONE)
 8005808:	687b      	ldr	r3, [r7, #4]
 800580a:	2b00      	cmp	r3, #0
 800580c:	d116      	bne.n	800583c <BSP_I2C1_Init+0x64>
      {
        /* Init the I2C */
        if(MX_I2C1_Init(&hi2c1) != HAL_OK)
 800580e:	480e      	ldr	r0, [pc, #56]	@ (8005848 <BSP_I2C1_Init+0x70>)
 8005810:	f000 fb4a 	bl	8005ea8 <MX_I2C1_Init>
 8005814:	4603      	mov	r3, r0
 8005816:	2b00      	cmp	r3, #0
 8005818:	d003      	beq.n	8005822 <BSP_I2C1_Init+0x4a>
        {
          ret = BSP_ERROR_BUS_FAILURE;
 800581a:	f06f 0307 	mvn.w	r3, #7
 800581e:	607b      	str	r3, [r7, #4]
 8005820:	e00c      	b.n	800583c <BSP_I2C1_Init+0x64>
        }
        else if(HAL_I2CEx_ConfigAnalogFilter(&hi2c1, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
 8005822:	2100      	movs	r1, #0
 8005824:	4808      	ldr	r0, [pc, #32]	@ (8005848 <BSP_I2C1_Init+0x70>)
 8005826:	f00b fead 	bl	8011584 <HAL_I2CEx_ConfigAnalogFilter>
 800582a:	4603      	mov	r3, r0
 800582c:	2b00      	cmp	r3, #0
 800582e:	d003      	beq.n	8005838 <BSP_I2C1_Init+0x60>
        {
          ret = BSP_ERROR_BUS_FAILURE;
 8005830:	f06f 0307 	mvn.w	r3, #7
 8005834:	607b      	str	r3, [r7, #4]
 8005836:	e001      	b.n	800583c <BSP_I2C1_Init+0x64>
        }
        else
        {
          ret = BSP_ERROR_NONE;
 8005838:	2300      	movs	r3, #0
 800583a:	607b      	str	r3, [r7, #4]
        }
      }
    }
  }
  return ret;
 800583c:	687b      	ldr	r3, [r7, #4]
}
 800583e:	4618      	mov	r0, r3
 8005840:	3708      	adds	r7, #8
 8005842:	46bd      	mov	sp, r7
 8005844:	bd80      	pop	{r7, pc}
 8005846:	bf00      	nop
 8005848:	20000a70 	.word	0x20000a70
 800584c:	40005400 	.word	0x40005400
 8005850:	20000ad0 	.word	0x20000ad0

08005854 <BSP_I2C1_DeInit>:
/**
  * @brief  DeInitialize I2C HAL.
  * @retval BSP status
  */
int32_t BSP_I2C1_DeInit(void)
{
 8005854:	b580      	push	{r7, lr}
 8005856:	b082      	sub	sp, #8
 8005858:	af00      	add	r7, sp, #0
  int32_t ret = BSP_ERROR_NONE;
 800585a:	2300      	movs	r3, #0
 800585c:	607b      	str	r3, [r7, #4]

  if (I2C1InitCounter > 0)
 800585e:	4b0f      	ldr	r3, [pc, #60]	@ (800589c <BSP_I2C1_DeInit+0x48>)
 8005860:	681b      	ldr	r3, [r3, #0]
 8005862:	2b00      	cmp	r3, #0
 8005864:	d014      	beq.n	8005890 <BSP_I2C1_DeInit+0x3c>
  {
    if (--I2C1InitCounter == 0)
 8005866:	4b0d      	ldr	r3, [pc, #52]	@ (800589c <BSP_I2C1_DeInit+0x48>)
 8005868:	681b      	ldr	r3, [r3, #0]
 800586a:	3b01      	subs	r3, #1
 800586c:	4a0b      	ldr	r2, [pc, #44]	@ (800589c <BSP_I2C1_DeInit+0x48>)
 800586e:	6013      	str	r3, [r2, #0]
 8005870:	4b0a      	ldr	r3, [pc, #40]	@ (800589c <BSP_I2C1_DeInit+0x48>)
 8005872:	681b      	ldr	r3, [r3, #0]
 8005874:	2b00      	cmp	r3, #0
 8005876:	d10b      	bne.n	8005890 <BSP_I2C1_DeInit+0x3c>
    {
  #if (USE_HAL_I2C_REGISTER_CALLBACKS == 0U)
      /* DeInit the I2C */
      I2C1_MspDeInit(&hi2c1);
 8005878:	4809      	ldr	r0, [pc, #36]	@ (80058a0 <BSP_I2C1_DeInit+0x4c>)
 800587a:	f000 fc49 	bl	8006110 <I2C1_MspDeInit>
  #endif
      /* DeInit the I2C */
      if (HAL_I2C_DeInit(&hi2c1) != HAL_OK)
 800587e:	4808      	ldr	r0, [pc, #32]	@ (80058a0 <BSP_I2C1_DeInit+0x4c>)
 8005880:	f00a fb2d 	bl	800fede <HAL_I2C_DeInit>
 8005884:	4603      	mov	r3, r0
 8005886:	2b00      	cmp	r3, #0
 8005888:	d002      	beq.n	8005890 <BSP_I2C1_DeInit+0x3c>
      {
        ret = BSP_ERROR_BUS_FAILURE;
 800588a:	f06f 0307 	mvn.w	r3, #7
 800588e:	607b      	str	r3, [r7, #4]
      }
    }
  }
  return ret;
 8005890:	687b      	ldr	r3, [r7, #4]
}
 8005892:	4618      	mov	r0, r3
 8005894:	3708      	adds	r7, #8
 8005896:	46bd      	mov	sp, r7
 8005898:	bd80      	pop	{r7, pc}
 800589a:	bf00      	nop
 800589c:	20000ad0 	.word	0x20000ad0
 80058a0:	20000a70 	.word	0x20000a70

080058a4 <BSP_I2C1_WriteReg>:
  * @param  Length Data Length
  * @retval BSP status
  */

int32_t BSP_I2C1_WriteReg(uint16_t DevAddr, uint16_t Reg, uint8_t *pData, uint16_t Length)
{
 80058a4:	b580      	push	{r7, lr}
 80058a6:	b08a      	sub	sp, #40	@ 0x28
 80058a8:	af04      	add	r7, sp, #16
 80058aa:	60ba      	str	r2, [r7, #8]
 80058ac:	461a      	mov	r2, r3
 80058ae:	4603      	mov	r3, r0
 80058b0:	81fb      	strh	r3, [r7, #14]
 80058b2:	460b      	mov	r3, r1
 80058b4:	81bb      	strh	r3, [r7, #12]
 80058b6:	4613      	mov	r3, r2
 80058b8:	80fb      	strh	r3, [r7, #6]
  int32_t ret = BSP_ERROR_NONE;
 80058ba:	2300      	movs	r3, #0
 80058bc:	617b      	str	r3, [r7, #20]

  if (HAL_I2C_Mem_Write(&hi2c1, DevAddr,Reg, I2C_MEMADD_SIZE_8BIT,pData, Length, BUS_I2C1_POLL_TIMEOUT) != HAL_OK)
 80058be:	89ba      	ldrh	r2, [r7, #12]
 80058c0:	89f9      	ldrh	r1, [r7, #14]
 80058c2:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 80058c6:	9302      	str	r3, [sp, #8]
 80058c8:	88fb      	ldrh	r3, [r7, #6]
 80058ca:	9301      	str	r3, [sp, #4]
 80058cc:	68bb      	ldr	r3, [r7, #8]
 80058ce:	9300      	str	r3, [sp, #0]
 80058d0:	2301      	movs	r3, #1
 80058d2:	480c      	ldr	r0, [pc, #48]	@ (8005904 <BSP_I2C1_WriteReg+0x60>)
 80058d4:	f00a fb46 	bl	800ff64 <HAL_I2C_Mem_Write>
 80058d8:	4603      	mov	r3, r0
 80058da:	2b00      	cmp	r3, #0
 80058dc:	d00c      	beq.n	80058f8 <BSP_I2C1_WriteReg+0x54>
  {
    if (HAL_I2C_GetError(&hi2c1) == HAL_I2C_ERROR_AF)
 80058de:	4809      	ldr	r0, [pc, #36]	@ (8005904 <BSP_I2C1_WriteReg+0x60>)
 80058e0:	f00a fe37 	bl	8010552 <HAL_I2C_GetError>
 80058e4:	4603      	mov	r3, r0
 80058e6:	2b04      	cmp	r3, #4
 80058e8:	d103      	bne.n	80058f2 <BSP_I2C1_WriteReg+0x4e>
    {
      ret = BSP_ERROR_BUS_ACKNOWLEDGE_FAILURE;
 80058ea:	f06f 0365 	mvn.w	r3, #101	@ 0x65
 80058ee:	617b      	str	r3, [r7, #20]
 80058f0:	e002      	b.n	80058f8 <BSP_I2C1_WriteReg+0x54>
    }
    else
    {
      ret =  BSP_ERROR_PERIPH_FAILURE;
 80058f2:	f06f 0303 	mvn.w	r3, #3
 80058f6:	617b      	str	r3, [r7, #20]
    }
  }
  return ret;
 80058f8:	697b      	ldr	r3, [r7, #20]
}
 80058fa:	4618      	mov	r0, r3
 80058fc:	3718      	adds	r7, #24
 80058fe:	46bd      	mov	sp, r7
 8005900:	bd80      	pop	{r7, pc}
 8005902:	bf00      	nop
 8005904:	20000a70 	.word	0x20000a70

08005908 <BSP_I2C1_ReadReg>:
  * @param  pData  Pointer to data buffer to read
  * @param  Length Data Length
  * @retval BSP status
  */
int32_t  BSP_I2C1_ReadReg(uint16_t DevAddr, uint16_t Reg, uint8_t *pData, uint16_t Length)
{
 8005908:	b580      	push	{r7, lr}
 800590a:	b08a      	sub	sp, #40	@ 0x28
 800590c:	af04      	add	r7, sp, #16
 800590e:	60ba      	str	r2, [r7, #8]
 8005910:	461a      	mov	r2, r3
 8005912:	4603      	mov	r3, r0
 8005914:	81fb      	strh	r3, [r7, #14]
 8005916:	460b      	mov	r3, r1
 8005918:	81bb      	strh	r3, [r7, #12]
 800591a:	4613      	mov	r3, r2
 800591c:	80fb      	strh	r3, [r7, #6]
  int32_t ret = BSP_ERROR_NONE;
 800591e:	2300      	movs	r3, #0
 8005920:	617b      	str	r3, [r7, #20]

  if (HAL_I2C_Mem_Read(&hi2c1, DevAddr, Reg, I2C_MEMADD_SIZE_8BIT, pData, Length, BUS_I2C1_POLL_TIMEOUT) != HAL_OK)
 8005922:	89ba      	ldrh	r2, [r7, #12]
 8005924:	89f9      	ldrh	r1, [r7, #14]
 8005926:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 800592a:	9302      	str	r3, [sp, #8]
 800592c:	88fb      	ldrh	r3, [r7, #6]
 800592e:	9301      	str	r3, [sp, #4]
 8005930:	68bb      	ldr	r3, [r7, #8]
 8005932:	9300      	str	r3, [sp, #0]
 8005934:	2301      	movs	r3, #1
 8005936:	480c      	ldr	r0, [pc, #48]	@ (8005968 <BSP_I2C1_ReadReg+0x60>)
 8005938:	f00a fc28 	bl	801018c <HAL_I2C_Mem_Read>
 800593c:	4603      	mov	r3, r0
 800593e:	2b00      	cmp	r3, #0
 8005940:	d00c      	beq.n	800595c <BSP_I2C1_ReadReg+0x54>
  {
    if (HAL_I2C_GetError(&hi2c1) == HAL_I2C_ERROR_AF)
 8005942:	4809      	ldr	r0, [pc, #36]	@ (8005968 <BSP_I2C1_ReadReg+0x60>)
 8005944:	f00a fe05 	bl	8010552 <HAL_I2C_GetError>
 8005948:	4603      	mov	r3, r0
 800594a:	2b04      	cmp	r3, #4
 800594c:	d103      	bne.n	8005956 <BSP_I2C1_ReadReg+0x4e>
    {
      ret = BSP_ERROR_BUS_ACKNOWLEDGE_FAILURE;
 800594e:	f06f 0365 	mvn.w	r3, #101	@ 0x65
 8005952:	617b      	str	r3, [r7, #20]
 8005954:	e002      	b.n	800595c <BSP_I2C1_ReadReg+0x54>
    }
    else
    {
      ret = BSP_ERROR_PERIPH_FAILURE;
 8005956:	f06f 0303 	mvn.w	r3, #3
 800595a:	617b      	str	r3, [r7, #20]
    }
  }
  return ret;
 800595c:	697b      	ldr	r3, [r7, #20]
}
 800595e:	4618      	mov	r0, r3
 8005960:	3718      	adds	r7, #24
 8005962:	46bd      	mov	sp, r7
 8005964:	bd80      	pop	{r7, pc}
 8005966:	bf00      	nop
 8005968:	20000a70 	.word	0x20000a70

0800596c <BSP_GetTick>:

/**
  * @brief  Return system tick in ms
  * @retval Current HAL time base time stamp
  */
int32_t BSP_GetTick(void) {
 800596c:	b580      	push	{r7, lr}
 800596e:	af00      	add	r7, sp, #0
  return HAL_GetTick();
 8005970:	f008 f876 	bl	800da60 <HAL_GetTick>
 8005974:	4603      	mov	r3, r0
}
 8005976:	4618      	mov	r0, r3
 8005978:	bd80      	pop	{r7, pc}
	...

0800597c <MX_SPI1_Init>:

/* SPI1 init function */

__weak HAL_StatusTypeDef MX_SPI1_Init(SPI_HandleTypeDef* hspi)
{
 800597c:	b580      	push	{r7, lr}
 800597e:	b086      	sub	sp, #24
 8005980:	af00      	add	r7, sp, #0
 8005982:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef ret = HAL_OK;
 8005984:	2300      	movs	r3, #0
 8005986:	75fb      	strb	r3, [r7, #23]
  SPI_AutonomousModeConfTypeDef HAL_SPI_AutonomousMode_Cfg_Struct = {0};
 8005988:	f107 0308 	add.w	r3, r7, #8
 800598c:	2200      	movs	r2, #0
 800598e:	601a      	str	r2, [r3, #0]
 8005990:	605a      	str	r2, [r3, #4]
 8005992:	609a      	str	r2, [r3, #8]

  hspi->Instance = SPI1;
 8005994:	687b      	ldr	r3, [r7, #4]
 8005996:	4a32      	ldr	r2, [pc, #200]	@ (8005a60 <MX_SPI1_Init+0xe4>)
 8005998:	601a      	str	r2, [r3, #0]
  hspi->Init.Mode = SPI_MODE_MASTER;
 800599a:	687b      	ldr	r3, [r7, #4]
 800599c:	f44f 0280 	mov.w	r2, #4194304	@ 0x400000
 80059a0:	605a      	str	r2, [r3, #4]
  hspi->Init.Direction = SPI_DIRECTION_2LINES;
 80059a2:	687b      	ldr	r3, [r7, #4]
 80059a4:	2200      	movs	r2, #0
 80059a6:	609a      	str	r2, [r3, #8]
  hspi->Init.DataSize = SPI_DATASIZE_8BIT;
 80059a8:	687b      	ldr	r3, [r7, #4]
 80059aa:	2207      	movs	r2, #7
 80059ac:	60da      	str	r2, [r3, #12]
  hspi->Init.CLKPolarity = SPI_POLARITY_HIGH;
 80059ae:	687b      	ldr	r3, [r7, #4]
 80059b0:	f04f 7200 	mov.w	r2, #33554432	@ 0x2000000
 80059b4:	611a      	str	r2, [r3, #16]
  hspi->Init.CLKPhase = SPI_PHASE_2EDGE;
 80059b6:	687b      	ldr	r3, [r7, #4]
 80059b8:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
 80059bc:	615a      	str	r2, [r3, #20]
  hspi->Init.NSS = SPI_NSS_SOFT;
 80059be:	687b      	ldr	r3, [r7, #4]
 80059c0:	f04f 6280 	mov.w	r2, #67108864	@ 0x4000000
 80059c4:	619a      	str	r2, [r3, #24]
  hspi->Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_128;
 80059c6:	687b      	ldr	r3, [r7, #4]
 80059c8:	f04f 42c0 	mov.w	r2, #1610612736	@ 0x60000000
 80059cc:	61da      	str	r2, [r3, #28]
  hspi->Init.FirstBit = SPI_FIRSTBIT_MSB;
 80059ce:	687b      	ldr	r3, [r7, #4]
 80059d0:	2200      	movs	r2, #0
 80059d2:	621a      	str	r2, [r3, #32]
  hspi->Init.TIMode = SPI_TIMODE_DISABLE;
 80059d4:	687b      	ldr	r3, [r7, #4]
 80059d6:	2200      	movs	r2, #0
 80059d8:	625a      	str	r2, [r3, #36]	@ 0x24
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 80059da:	687b      	ldr	r3, [r7, #4]
 80059dc:	2200      	movs	r2, #0
 80059de:	629a      	str	r2, [r3, #40]	@ 0x28
  hspi->Init.CRCPolynomial = 0x7;
 80059e0:	687b      	ldr	r3, [r7, #4]
 80059e2:	2207      	movs	r2, #7
 80059e4:	62da      	str	r2, [r3, #44]	@ 0x2c
  hspi->Init.NSSPMode = SPI_NSS_PULSE_DISABLE;
 80059e6:	687b      	ldr	r3, [r7, #4]
 80059e8:	2200      	movs	r2, #0
 80059ea:	635a      	str	r2, [r3, #52]	@ 0x34
  hspi->Init.NSSPolarity = SPI_NSS_POLARITY_LOW;
 80059ec:	687b      	ldr	r3, [r7, #4]
 80059ee:	2200      	movs	r2, #0
 80059f0:	639a      	str	r2, [r3, #56]	@ 0x38
  hspi->Init.FifoThreshold = SPI_FIFO_THRESHOLD_01DATA;
 80059f2:	687b      	ldr	r3, [r7, #4]
 80059f4:	2200      	movs	r2, #0
 80059f6:	63da      	str	r2, [r3, #60]	@ 0x3c
  hspi->Init.MasterSSIdleness = SPI_MASTER_SS_IDLENESS_00CYCLE;
 80059f8:	687b      	ldr	r3, [r7, #4]
 80059fa:	2200      	movs	r2, #0
 80059fc:	649a      	str	r2, [r3, #72]	@ 0x48
  hspi->Init.MasterInterDataIdleness = SPI_MASTER_INTERDATA_IDLENESS_00CYCLE;
 80059fe:	687b      	ldr	r3, [r7, #4]
 8005a00:	2200      	movs	r2, #0
 8005a02:	64da      	str	r2, [r3, #76]	@ 0x4c
  hspi->Init.MasterReceiverAutoSusp = SPI_MASTER_RX_AUTOSUSP_DISABLE;
 8005a04:	687b      	ldr	r3, [r7, #4]
 8005a06:	2200      	movs	r2, #0
 8005a08:	651a      	str	r2, [r3, #80]	@ 0x50
  hspi->Init.MasterKeepIOState = SPI_MASTER_KEEP_IO_STATE_DISABLE;
 8005a0a:	687b      	ldr	r3, [r7, #4]
 8005a0c:	2200      	movs	r2, #0
 8005a0e:	655a      	str	r2, [r3, #84]	@ 0x54
  hspi->Init.IOSwap = SPI_IO_SWAP_DISABLE;
 8005a10:	687b      	ldr	r3, [r7, #4]
 8005a12:	2200      	movs	r2, #0
 8005a14:	659a      	str	r2, [r3, #88]	@ 0x58
  hspi->Init.ReadyMasterManagement = SPI_RDY_MASTER_MANAGEMENT_INTERNALLY;
 8005a16:	687b      	ldr	r3, [r7, #4]
 8005a18:	2200      	movs	r2, #0
 8005a1a:	65da      	str	r2, [r3, #92]	@ 0x5c
  hspi->Init.ReadyPolarity = SPI_RDY_POLARITY_HIGH;
 8005a1c:	687b      	ldr	r3, [r7, #4]
 8005a1e:	2200      	movs	r2, #0
 8005a20:	661a      	str	r2, [r3, #96]	@ 0x60
  if (HAL_SPI_Init(hspi) != HAL_OK)
 8005a22:	6878      	ldr	r0, [r7, #4]
 8005a24:	f00f ff2e 	bl	8015884 <HAL_SPI_Init>
 8005a28:	4603      	mov	r3, r0
 8005a2a:	2b00      	cmp	r3, #0
 8005a2c:	d001      	beq.n	8005a32 <MX_SPI1_Init+0xb6>
  {
    ret = HAL_ERROR;
 8005a2e:	2301      	movs	r3, #1
 8005a30:	75fb      	strb	r3, [r7, #23]
  }

  HAL_SPI_AutonomousMode_Cfg_Struct.TriggerState = SPI_AUTO_MODE_DISABLE;
 8005a32:	2300      	movs	r3, #0
 8005a34:	60bb      	str	r3, [r7, #8]
  HAL_SPI_AutonomousMode_Cfg_Struct.TriggerSelection = SPI_GRP1_GPDMA_CH0_TCF_TRG;
 8005a36:	f04f 5380 	mov.w	r3, #268435456	@ 0x10000000
 8005a3a:	60fb      	str	r3, [r7, #12]
  HAL_SPI_AutonomousMode_Cfg_Struct.TriggerPolarity = SPI_TRIG_POLARITY_RISING;
 8005a3c:	2300      	movs	r3, #0
 8005a3e:	613b      	str	r3, [r7, #16]
  if (HAL_SPIEx_SetConfigAutonomousMode(hspi, &HAL_SPI_AutonomousMode_Cfg_Struct) != HAL_OK)
 8005a40:	f107 0308 	add.w	r3, r7, #8
 8005a44:	4619      	mov	r1, r3
 8005a46:	6878      	ldr	r0, [r7, #4]
 8005a48:	f010 fda3 	bl	8016592 <HAL_SPIEx_SetConfigAutonomousMode>
 8005a4c:	4603      	mov	r3, r0
 8005a4e:	2b00      	cmp	r3, #0
 8005a50:	d001      	beq.n	8005a56 <MX_SPI1_Init+0xda>
  {
    ret = HAL_ERROR;
 8005a52:	2301      	movs	r3, #1
 8005a54:	75fb      	strb	r3, [r7, #23]
  }

  return ret;
 8005a56:	7dfb      	ldrb	r3, [r7, #23]
}
 8005a58:	4618      	mov	r0, r3
 8005a5a:	3718      	adds	r7, #24
 8005a5c:	46bd      	mov	sp, r7
 8005a5e:	bd80      	pop	{r7, pc}
 8005a60:	40013000 	.word	0x40013000

08005a64 <SPI1_MspInit>:

static void SPI1_MspInit(SPI_HandleTypeDef* spiHandle)
{
 8005a64:	b580      	push	{r7, lr}
 8005a66:	b0bc      	sub	sp, #240	@ 0xf0
 8005a68:	af00      	add	r7, sp, #0
 8005a6a:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct;
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 8005a6c:	f107 0310 	add.w	r3, r7, #16
 8005a70:	22c8      	movs	r2, #200	@ 0xc8
 8005a72:	2100      	movs	r1, #0
 8005a74:	4618      	mov	r0, r3
 8005a76:	f01e faf5 	bl	8024064 <memset>

  /* USER CODE END SPI1_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_SPI1;
 8005a7a:	f44f 0200 	mov.w	r2, #8388608	@ 0x800000
 8005a7e:	f04f 0300 	mov.w	r3, #0
 8005a82:	e9c7 2304 	strd	r2, r3, [r7, #16]
    PeriphClkInit.Spi1ClockSelection = RCC_SPI1CLKSOURCE_SYSCLK;
 8005a86:	f44f 1380 	mov.w	r3, #1048576	@ 0x100000
 8005a8a:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
    HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit);
 8005a8e:	f107 0310 	add.w	r3, r7, #16
 8005a92:	4618      	mov	r0, r3
 8005a94:	f00d fa16 	bl	8012ec4 <HAL_RCCEx_PeriphCLKConfig>

    /* Enable Peripheral clock */
    __HAL_RCC_SPI1_CLK_ENABLE();
 8005a98:	4b30      	ldr	r3, [pc, #192]	@ (8005b5c <SPI1_MspInit+0xf8>)
 8005a9a:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
 8005a9e:	4a2f      	ldr	r2, [pc, #188]	@ (8005b5c <SPI1_MspInit+0xf8>)
 8005aa0:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
 8005aa4:	f8c2 30a4 	str.w	r3, [r2, #164]	@ 0xa4
 8005aa8:	4b2c      	ldr	r3, [pc, #176]	@ (8005b5c <SPI1_MspInit+0xf8>)
 8005aaa:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
 8005aae:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
 8005ab2:	60fb      	str	r3, [r7, #12]
 8005ab4:	68fb      	ldr	r3, [r7, #12]

    __HAL_RCC_GPIOA_CLK_ENABLE();
 8005ab6:	4b29      	ldr	r3, [pc, #164]	@ (8005b5c <SPI1_MspInit+0xf8>)
 8005ab8:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8005abc:	4a27      	ldr	r2, [pc, #156]	@ (8005b5c <SPI1_MspInit+0xf8>)
 8005abe:	f043 0301 	orr.w	r3, r3, #1
 8005ac2:	f8c2 308c 	str.w	r3, [r2, #140]	@ 0x8c
 8005ac6:	4b25      	ldr	r3, [pc, #148]	@ (8005b5c <SPI1_MspInit+0xf8>)
 8005ac8:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8005acc:	f003 0301 	and.w	r3, r3, #1
 8005ad0:	60bb      	str	r3, [r7, #8]
 8005ad2:	68bb      	ldr	r3, [r7, #8]
    /**SPI1 GPIO Configuration
    PA7     ------> SPI1_MOSI
    PA5     ------> SPI1_SCK
    PA6     ------> SPI1_MISO
    */
    GPIO_InitStruct.Pin = BUS_SPI1_MOSI_GPIO_PIN;
 8005ad4:	2380      	movs	r3, #128	@ 0x80
 8005ad6:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8005ada:	2302      	movs	r3, #2
 8005adc:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8005ae0:	2300      	movs	r3, #0
 8005ae2:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8005ae6:	2302      	movs	r3, #2
 8005ae8:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
    GPIO_InitStruct.Alternate = BUS_SPI1_MOSI_GPIO_AF;
 8005aec:	2305      	movs	r3, #5
 8005aee:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
    HAL_GPIO_Init(BUS_SPI1_MOSI_GPIO_PORT, &GPIO_InitStruct);
 8005af2:	f107 03dc 	add.w	r3, r7, #220	@ 0xdc
 8005af6:	4619      	mov	r1, r3
 8005af8:	4819      	ldr	r0, [pc, #100]	@ (8005b60 <SPI1_MspInit+0xfc>)
 8005afa:	f009 fe33 	bl	800f764 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = BUS_SPI1_SCK_GPIO_PIN;
 8005afe:	2320      	movs	r3, #32
 8005b00:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8005b04:	2302      	movs	r3, #2
 8005b06:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 8005b0a:	2301      	movs	r3, #1
 8005b0c:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8005b10:	2302      	movs	r3, #2
 8005b12:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
    GPIO_InitStruct.Alternate = BUS_SPI1_SCK_GPIO_AF;
 8005b16:	2305      	movs	r3, #5
 8005b18:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
    HAL_GPIO_Init(BUS_SPI1_SCK_GPIO_PORT, &GPIO_InitStruct);
 8005b1c:	f107 03dc 	add.w	r3, r7, #220	@ 0xdc
 8005b20:	4619      	mov	r1, r3
 8005b22:	480f      	ldr	r0, [pc, #60]	@ (8005b60 <SPI1_MspInit+0xfc>)
 8005b24:	f009 fe1e 	bl	800f764 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = BUS_SPI1_MISO_GPIO_PIN;
 8005b28:	2340      	movs	r3, #64	@ 0x40
 8005b2a:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8005b2e:	2302      	movs	r3, #2
 8005b30:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8005b34:	2300      	movs	r3, #0
 8005b36:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8005b3a:	2302      	movs	r3, #2
 8005b3c:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
    GPIO_InitStruct.Alternate = BUS_SPI1_MISO_GPIO_AF;
 8005b40:	2305      	movs	r3, #5
 8005b42:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
    HAL_GPIO_Init(BUS_SPI1_MISO_GPIO_PORT, &GPIO_InitStruct);
 8005b46:	f107 03dc 	add.w	r3, r7, #220	@ 0xdc
 8005b4a:	4619      	mov	r1, r3
 8005b4c:	4804      	ldr	r0, [pc, #16]	@ (8005b60 <SPI1_MspInit+0xfc>)
 8005b4e:	f009 fe09 	bl	800f764 <HAL_GPIO_Init>

  /* USER CODE BEGIN SPI1_MspInit 1 */

  /* USER CODE END SPI1_MspInit 1 */
}
 8005b52:	bf00      	nop
 8005b54:	37f0      	adds	r7, #240	@ 0xf0
 8005b56:	46bd      	mov	sp, r7
 8005b58:	bd80      	pop	{r7, pc}
 8005b5a:	bf00      	nop
 8005b5c:	46020c00 	.word	0x46020c00
 8005b60:	42020000 	.word	0x42020000

08005b64 <MX_I2C2_Init>:
}

/* I2C2 init function */

__weak HAL_StatusTypeDef MX_I2C2_Init(I2C_HandleTypeDef* hi2c)
{
 8005b64:	b580      	push	{r7, lr}
 8005b66:	b084      	sub	sp, #16
 8005b68:	af00      	add	r7, sp, #0
 8005b6a:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef ret = HAL_OK;
 8005b6c:	2300      	movs	r3, #0
 8005b6e:	73fb      	strb	r3, [r7, #15]

  hi2c->Instance = I2C2;
 8005b70:	687b      	ldr	r3, [r7, #4]
 8005b72:	4a1c      	ldr	r2, [pc, #112]	@ (8005be4 <MX_I2C2_Init+0x80>)
 8005b74:	601a      	str	r2, [r3, #0]
  hi2c->Init.Timing = 0x00F07BFF;
 8005b76:	687b      	ldr	r3, [r7, #4]
 8005b78:	4a1b      	ldr	r2, [pc, #108]	@ (8005be8 <MX_I2C2_Init+0x84>)
 8005b7a:	605a      	str	r2, [r3, #4]
  hi2c->Init.OwnAddress1 = 0;
 8005b7c:	687b      	ldr	r3, [r7, #4]
 8005b7e:	2200      	movs	r2, #0
 8005b80:	609a      	str	r2, [r3, #8]
  hi2c->Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 8005b82:	687b      	ldr	r3, [r7, #4]
 8005b84:	2201      	movs	r2, #1
 8005b86:	60da      	str	r2, [r3, #12]
  hi2c->Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
 8005b88:	687b      	ldr	r3, [r7, #4]
 8005b8a:	2200      	movs	r2, #0
 8005b8c:	611a      	str	r2, [r3, #16]
  hi2c->Init.OwnAddress2 = 0;
 8005b8e:	687b      	ldr	r3, [r7, #4]
 8005b90:	2200      	movs	r2, #0
 8005b92:	615a      	str	r2, [r3, #20]
  hi2c->Init.OwnAddress2Masks = I2C_OA2_NOMASK;
 8005b94:	687b      	ldr	r3, [r7, #4]
 8005b96:	2200      	movs	r2, #0
 8005b98:	619a      	str	r2, [r3, #24]
  hi2c->Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
 8005b9a:	687b      	ldr	r3, [r7, #4]
 8005b9c:	2200      	movs	r2, #0
 8005b9e:	61da      	str	r2, [r3, #28]
  hi2c->Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
 8005ba0:	687b      	ldr	r3, [r7, #4]
 8005ba2:	2200      	movs	r2, #0
 8005ba4:	621a      	str	r2, [r3, #32]
  if (HAL_I2C_Init(hi2c) != HAL_OK)
 8005ba6:	6878      	ldr	r0, [r7, #4]
 8005ba8:	f00a f8fe 	bl	800fda8 <HAL_I2C_Init>
 8005bac:	4603      	mov	r3, r0
 8005bae:	2b00      	cmp	r3, #0
 8005bb0:	d001      	beq.n	8005bb6 <MX_I2C2_Init+0x52>
  {
    ret = HAL_ERROR;
 8005bb2:	2301      	movs	r3, #1
 8005bb4:	73fb      	strb	r3, [r7, #15]
  }

  if (HAL_I2CEx_ConfigAnalogFilter(hi2c, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
 8005bb6:	2100      	movs	r1, #0
 8005bb8:	6878      	ldr	r0, [r7, #4]
 8005bba:	f00b fce3 	bl	8011584 <HAL_I2CEx_ConfigAnalogFilter>
 8005bbe:	4603      	mov	r3, r0
 8005bc0:	2b00      	cmp	r3, #0
 8005bc2:	d001      	beq.n	8005bc8 <MX_I2C2_Init+0x64>
  {
    ret = HAL_ERROR;
 8005bc4:	2301      	movs	r3, #1
 8005bc6:	73fb      	strb	r3, [r7, #15]
  }

  if (HAL_I2CEx_ConfigDigitalFilter(hi2c, 0) != HAL_OK)
 8005bc8:	2100      	movs	r1, #0
 8005bca:	6878      	ldr	r0, [r7, #4]
 8005bcc:	f00b fd25 	bl	801161a <HAL_I2CEx_ConfigDigitalFilter>
 8005bd0:	4603      	mov	r3, r0
 8005bd2:	2b00      	cmp	r3, #0
 8005bd4:	d001      	beq.n	8005bda <MX_I2C2_Init+0x76>
  {
    ret = HAL_ERROR;
 8005bd6:	2301      	movs	r3, #1
 8005bd8:	73fb      	strb	r3, [r7, #15]
  }

  return ret;
 8005bda:	7bfb      	ldrb	r3, [r7, #15]
}
 8005bdc:	4618      	mov	r0, r3
 8005bde:	3710      	adds	r7, #16
 8005be0:	46bd      	mov	sp, r7
 8005be2:	bd80      	pop	{r7, pc}
 8005be4:	40005800 	.word	0x40005800
 8005be8:	00f07bff 	.word	0x00f07bff

08005bec <I2C2_MspInit>:

static void I2C2_MspInit(I2C_HandleTypeDef* i2cHandle)
{
 8005bec:	b580      	push	{r7, lr}
 8005bee:	b0bc      	sub	sp, #240	@ 0xf0
 8005bf0:	af00      	add	r7, sp, #0
 8005bf2:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct;
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 8005bf4:	f107 0310 	add.w	r3, r7, #16
 8005bf8:	22c8      	movs	r2, #200	@ 0xc8
 8005bfa:	2100      	movs	r1, #0
 8005bfc:	4618      	mov	r0, r3
 8005bfe:	f01e fa31 	bl	8024064 <memset>

  /* USER CODE END I2C2_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_I2C2;
 8005c02:	f04f 0280 	mov.w	r2, #128	@ 0x80
 8005c06:	f04f 0300 	mov.w	r3, #0
 8005c0a:	e9c7 2304 	strd	r2, r3, [r7, #16]
    PeriphClkInit.I2c2ClockSelection = RCC_I2C2CLKSOURCE_PCLK1;
 8005c0e:	2300      	movs	r3, #0
 8005c10:	67fb      	str	r3, [r7, #124]	@ 0x7c
    HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit);
 8005c12:	f107 0310 	add.w	r3, r7, #16
 8005c16:	4618      	mov	r0, r3
 8005c18:	f00d f954 	bl	8012ec4 <HAL_RCCEx_PeriphCLKConfig>

    __HAL_RCC_GPIOB_CLK_ENABLE();
 8005c1c:	4b2e      	ldr	r3, [pc, #184]	@ (8005cd8 <I2C2_MspInit+0xec>)
 8005c1e:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8005c22:	4a2d      	ldr	r2, [pc, #180]	@ (8005cd8 <I2C2_MspInit+0xec>)
 8005c24:	f043 0302 	orr.w	r3, r3, #2
 8005c28:	f8c2 308c 	str.w	r3, [r2, #140]	@ 0x8c
 8005c2c:	4b2a      	ldr	r3, [pc, #168]	@ (8005cd8 <I2C2_MspInit+0xec>)
 8005c2e:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8005c32:	f003 0302 	and.w	r3, r3, #2
 8005c36:	60fb      	str	r3, [r7, #12]
 8005c38:	68fb      	ldr	r3, [r7, #12]
    /**I2C2 GPIO Configuration
    PB14     ------> I2C2_SDA
    PB13     ------> I2C2_SCL
    */
    GPIO_InitStruct.Pin = BUS_I2C2_SDA_GPIO_PIN;
 8005c3a:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
 8005c3e:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 8005c42:	2312      	movs	r3, #18
 8005c44:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8005c48:	2300      	movs	r3, #0
 8005c4a:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8005c4e:	2300      	movs	r3, #0
 8005c50:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
    GPIO_InitStruct.Alternate = BUS_I2C2_SDA_GPIO_AF;
 8005c54:	2304      	movs	r3, #4
 8005c56:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
    HAL_GPIO_Init(BUS_I2C2_SDA_GPIO_PORT, &GPIO_InitStruct);
 8005c5a:	f107 03dc 	add.w	r3, r7, #220	@ 0xdc
 8005c5e:	4619      	mov	r1, r3
 8005c60:	481e      	ldr	r0, [pc, #120]	@ (8005cdc <I2C2_MspInit+0xf0>)
 8005c62:	f009 fd7f 	bl	800f764 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = BUS_I2C2_SCL_GPIO_PIN;
 8005c66:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
 8005c6a:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 8005c6e:	2312      	movs	r3, #18
 8005c70:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8005c74:	2300      	movs	r3, #0
 8005c76:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8005c7a:	2300      	movs	r3, #0
 8005c7c:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
    GPIO_InitStruct.Alternate = BUS_I2C2_SCL_GPIO_AF;
 8005c80:	2304      	movs	r3, #4
 8005c82:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
    HAL_GPIO_Init(BUS_I2C2_SCL_GPIO_PORT, &GPIO_InitStruct);
 8005c86:	f107 03dc 	add.w	r3, r7, #220	@ 0xdc
 8005c8a:	4619      	mov	r1, r3
 8005c8c:	4813      	ldr	r0, [pc, #76]	@ (8005cdc <I2C2_MspInit+0xf0>)
 8005c8e:	f009 fd69 	bl	800f764 <HAL_GPIO_Init>

    /* Peripheral clock enable */
    __HAL_RCC_I2C2_CLK_ENABLE();
 8005c92:	4b11      	ldr	r3, [pc, #68]	@ (8005cd8 <I2C2_MspInit+0xec>)
 8005c94:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
 8005c98:	4a0f      	ldr	r2, [pc, #60]	@ (8005cd8 <I2C2_MspInit+0xec>)
 8005c9a:	f443 0380 	orr.w	r3, r3, #4194304	@ 0x400000
 8005c9e:	f8c2 309c 	str.w	r3, [r2, #156]	@ 0x9c
 8005ca2:	4b0d      	ldr	r3, [pc, #52]	@ (8005cd8 <I2C2_MspInit+0xec>)
 8005ca4:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
 8005ca8:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
 8005cac:	60bb      	str	r3, [r7, #8]
 8005cae:	68bb      	ldr	r3, [r7, #8]

    /* Peripheral interrupt init */
    HAL_NVIC_SetPriority(I2C2_EV_IRQn, 0, 0);
 8005cb0:	2200      	movs	r2, #0
 8005cb2:	2100      	movs	r1, #0
 8005cb4:	2039      	movs	r0, #57	@ 0x39
 8005cb6:	f007 ffdc 	bl	800dc72 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(I2C2_EV_IRQn);
 8005cba:	2039      	movs	r0, #57	@ 0x39
 8005cbc:	f007 fff3 	bl	800dca6 <HAL_NVIC_EnableIRQ>
    HAL_NVIC_SetPriority(I2C2_ER_IRQn, 0, 0);
 8005cc0:	2200      	movs	r2, #0
 8005cc2:	2100      	movs	r1, #0
 8005cc4:	203a      	movs	r0, #58	@ 0x3a
 8005cc6:	f007 ffd4 	bl	800dc72 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(I2C2_ER_IRQn);
 8005cca:	203a      	movs	r0, #58	@ 0x3a
 8005ccc:	f007 ffeb 	bl	800dca6 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN I2C2_MspInit 1 */

  /* USER CODE END I2C2_MspInit 1 */
}
 8005cd0:	bf00      	nop
 8005cd2:	37f0      	adds	r7, #240	@ 0xf0
 8005cd4:	46bd      	mov	sp, r7
 8005cd6:	bd80      	pop	{r7, pc}
 8005cd8:	46020c00 	.word	0x46020c00
 8005cdc:	42020400 	.word	0x42020400

08005ce0 <I2C2_MspDeInit>:

static void I2C2_MspDeInit(I2C_HandleTypeDef* i2cHandle)
{
 8005ce0:	b580      	push	{r7, lr}
 8005ce2:	b082      	sub	sp, #8
 8005ce4:	af00      	add	r7, sp, #0
 8005ce6:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN I2C2_MspDeInit 0 */

  /* USER CODE END I2C2_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_I2C2_CLK_DISABLE();
 8005ce8:	4b0d      	ldr	r3, [pc, #52]	@ (8005d20 <I2C2_MspDeInit+0x40>)
 8005cea:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
 8005cee:	4a0c      	ldr	r2, [pc, #48]	@ (8005d20 <I2C2_MspDeInit+0x40>)
 8005cf0:	f423 0380 	bic.w	r3, r3, #4194304	@ 0x400000
 8005cf4:	f8c2 309c 	str.w	r3, [r2, #156]	@ 0x9c

    /**I2C2 GPIO Configuration
    PB14     ------> I2C2_SDA
    PB13     ------> I2C2_SCL
    */
    HAL_GPIO_DeInit(BUS_I2C2_SDA_GPIO_PORT, BUS_I2C2_SDA_GPIO_PIN);
 8005cf8:	f44f 4180 	mov.w	r1, #16384	@ 0x4000
 8005cfc:	4809      	ldr	r0, [pc, #36]	@ (8005d24 <I2C2_MspDeInit+0x44>)
 8005cfe:	f009 ff09 	bl	800fb14 <HAL_GPIO_DeInit>

    HAL_GPIO_DeInit(BUS_I2C2_SCL_GPIO_PORT, BUS_I2C2_SCL_GPIO_PIN);
 8005d02:	f44f 5100 	mov.w	r1, #8192	@ 0x2000
 8005d06:	4807      	ldr	r0, [pc, #28]	@ (8005d24 <I2C2_MspDeInit+0x44>)
 8005d08:	f009 ff04 	bl	800fb14 <HAL_GPIO_DeInit>

    /* Peripheral interrupt Deinit*/
    HAL_NVIC_DisableIRQ(I2C2_EV_IRQn);
 8005d0c:	2039      	movs	r0, #57	@ 0x39
 8005d0e:	f007 ffd8 	bl	800dcc2 <HAL_NVIC_DisableIRQ>

    HAL_NVIC_DisableIRQ(I2C2_ER_IRQn);
 8005d12:	203a      	movs	r0, #58	@ 0x3a
 8005d14:	f007 ffd5 	bl	800dcc2 <HAL_NVIC_DisableIRQ>

  /* USER CODE BEGIN I2C2_MspDeInit 1 */

  /* USER CODE END I2C2_MspDeInit 1 */
}
 8005d18:	bf00      	nop
 8005d1a:	3708      	adds	r7, #8
 8005d1c:	46bd      	mov	sp, r7
 8005d1e:	bd80      	pop	{r7, pc}
 8005d20:	46020c00 	.word	0x46020c00
 8005d24:	42020400 	.word	0x42020400

08005d28 <MX_I2C4_Init>:

/* I2C4 init function */

__weak HAL_StatusTypeDef MX_I2C4_Init(I2C_HandleTypeDef* hi2c)
{
 8005d28:	b580      	push	{r7, lr}
 8005d2a:	b084      	sub	sp, #16
 8005d2c:	af00      	add	r7, sp, #0
 8005d2e:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef ret = HAL_OK;
 8005d30:	2300      	movs	r3, #0
 8005d32:	73fb      	strb	r3, [r7, #15]

  hi2c->Instance = I2C4;
 8005d34:	687b      	ldr	r3, [r7, #4]
 8005d36:	4a1c      	ldr	r2, [pc, #112]	@ (8005da8 <MX_I2C4_Init+0x80>)
 8005d38:	601a      	str	r2, [r3, #0]
  hi2c->Init.Timing = 0x00F07BFF;
 8005d3a:	687b      	ldr	r3, [r7, #4]
 8005d3c:	4a1b      	ldr	r2, [pc, #108]	@ (8005dac <MX_I2C4_Init+0x84>)
 8005d3e:	605a      	str	r2, [r3, #4]
  hi2c->Init.OwnAddress1 = 0;
 8005d40:	687b      	ldr	r3, [r7, #4]
 8005d42:	2200      	movs	r2, #0
 8005d44:	609a      	str	r2, [r3, #8]
  hi2c->Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 8005d46:	687b      	ldr	r3, [r7, #4]
 8005d48:	2201      	movs	r2, #1
 8005d4a:	60da      	str	r2, [r3, #12]
  hi2c->Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
 8005d4c:	687b      	ldr	r3, [r7, #4]
 8005d4e:	2200      	movs	r2, #0
 8005d50:	611a      	str	r2, [r3, #16]
  hi2c->Init.OwnAddress2 = 0;
 8005d52:	687b      	ldr	r3, [r7, #4]
 8005d54:	2200      	movs	r2, #0
 8005d56:	615a      	str	r2, [r3, #20]
  hi2c->Init.OwnAddress2Masks = I2C_OA2_NOMASK;
 8005d58:	687b      	ldr	r3, [r7, #4]
 8005d5a:	2200      	movs	r2, #0
 8005d5c:	619a      	str	r2, [r3, #24]
  hi2c->Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
 8005d5e:	687b      	ldr	r3, [r7, #4]
 8005d60:	2200      	movs	r2, #0
 8005d62:	61da      	str	r2, [r3, #28]
  hi2c->Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
 8005d64:	687b      	ldr	r3, [r7, #4]
 8005d66:	2200      	movs	r2, #0
 8005d68:	621a      	str	r2, [r3, #32]
  if (HAL_I2C_Init(hi2c) != HAL_OK)
 8005d6a:	6878      	ldr	r0, [r7, #4]
 8005d6c:	f00a f81c 	bl	800fda8 <HAL_I2C_Init>
 8005d70:	4603      	mov	r3, r0
 8005d72:	2b00      	cmp	r3, #0
 8005d74:	d001      	beq.n	8005d7a <MX_I2C4_Init+0x52>
  {
    ret = HAL_ERROR;
 8005d76:	2301      	movs	r3, #1
 8005d78:	73fb      	strb	r3, [r7, #15]
  }

  if (HAL_I2CEx_ConfigAnalogFilter(hi2c, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
 8005d7a:	2100      	movs	r1, #0
 8005d7c:	6878      	ldr	r0, [r7, #4]
 8005d7e:	f00b fc01 	bl	8011584 <HAL_I2CEx_ConfigAnalogFilter>
 8005d82:	4603      	mov	r3, r0
 8005d84:	2b00      	cmp	r3, #0
 8005d86:	d001      	beq.n	8005d8c <MX_I2C4_Init+0x64>
  {
    ret = HAL_ERROR;
 8005d88:	2301      	movs	r3, #1
 8005d8a:	73fb      	strb	r3, [r7, #15]
  }

  if (HAL_I2CEx_ConfigDigitalFilter(hi2c, 0) != HAL_OK)
 8005d8c:	2100      	movs	r1, #0
 8005d8e:	6878      	ldr	r0, [r7, #4]
 8005d90:	f00b fc43 	bl	801161a <HAL_I2CEx_ConfigDigitalFilter>
 8005d94:	4603      	mov	r3, r0
 8005d96:	2b00      	cmp	r3, #0
 8005d98:	d001      	beq.n	8005d9e <MX_I2C4_Init+0x76>
  {
    ret = HAL_ERROR;
 8005d9a:	2301      	movs	r3, #1
 8005d9c:	73fb      	strb	r3, [r7, #15]
  }

  return ret;
 8005d9e:	7bfb      	ldrb	r3, [r7, #15]
}
 8005da0:	4618      	mov	r0, r3
 8005da2:	3710      	adds	r7, #16
 8005da4:	46bd      	mov	sp, r7
 8005da6:	bd80      	pop	{r7, pc}
 8005da8:	40008400 	.word	0x40008400
 8005dac:	00f07bff 	.word	0x00f07bff

08005db0 <I2C4_MspInit>:

static void I2C4_MspInit(I2C_HandleTypeDef* i2cHandle)
{
 8005db0:	b580      	push	{r7, lr}
 8005db2:	b0bc      	sub	sp, #240	@ 0xf0
 8005db4:	af00      	add	r7, sp, #0
 8005db6:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct;
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 8005db8:	f107 0310 	add.w	r3, r7, #16
 8005dbc:	22c8      	movs	r2, #200	@ 0xc8
 8005dbe:	2100      	movs	r1, #0
 8005dc0:	4618      	mov	r0, r3
 8005dc2:	f01e f94f 	bl	8024064 <memset>

  /* USER CODE END I2C4_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_I2C4;
 8005dc6:	f44f 0280 	mov.w	r2, #4194304	@ 0x400000
 8005dca:	f04f 0300 	mov.w	r3, #0
 8005dce:	e9c7 2304 	strd	r2, r3, [r7, #16]
    PeriphClkInit.I2c4ClockSelection = RCC_I2C4CLKSOURCE_PCLK1;
 8005dd2:	2300      	movs	r3, #0
 8005dd4:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
    HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit);
 8005dd8:	f107 0310 	add.w	r3, r7, #16
 8005ddc:	4618      	mov	r0, r3
 8005dde:	f00d f871 	bl	8012ec4 <HAL_RCCEx_PeriphCLKConfig>

    __HAL_RCC_GPIOD_CLK_ENABLE();
 8005de2:	4b2f      	ldr	r3, [pc, #188]	@ (8005ea0 <I2C4_MspInit+0xf0>)
 8005de4:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8005de8:	4a2d      	ldr	r2, [pc, #180]	@ (8005ea0 <I2C4_MspInit+0xf0>)
 8005dea:	f043 0308 	orr.w	r3, r3, #8
 8005dee:	f8c2 308c 	str.w	r3, [r2, #140]	@ 0x8c
 8005df2:	4b2b      	ldr	r3, [pc, #172]	@ (8005ea0 <I2C4_MspInit+0xf0>)
 8005df4:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8005df8:	f003 0308 	and.w	r3, r3, #8
 8005dfc:	60fb      	str	r3, [r7, #12]
 8005dfe:	68fb      	ldr	r3, [r7, #12]
    /**I2C4 GPIO Configuration
    PD12     ------> I2C4_SCL
    PD13     ------> I2C4_SDA
    */
    GPIO_InitStruct.Pin = BUS_I2C4_SCL_GPIO_PIN;
 8005e00:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 8005e04:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 8005e08:	2312      	movs	r3, #18
 8005e0a:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8005e0e:	2300      	movs	r3, #0
 8005e10:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8005e14:	2300      	movs	r3, #0
 8005e16:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
    GPIO_InitStruct.Alternate = BUS_I2C4_SCL_GPIO_AF;
 8005e1a:	2304      	movs	r3, #4
 8005e1c:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
    HAL_GPIO_Init(BUS_I2C4_SCL_GPIO_PORT, &GPIO_InitStruct);
 8005e20:	f107 03dc 	add.w	r3, r7, #220	@ 0xdc
 8005e24:	4619      	mov	r1, r3
 8005e26:	481f      	ldr	r0, [pc, #124]	@ (8005ea4 <I2C4_MspInit+0xf4>)
 8005e28:	f009 fc9c 	bl	800f764 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = BUS_I2C4_SDA_GPIO_PIN;
 8005e2c:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
 8005e30:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 8005e34:	2312      	movs	r3, #18
 8005e36:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8005e3a:	2300      	movs	r3, #0
 8005e3c:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8005e40:	2300      	movs	r3, #0
 8005e42:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
    GPIO_InitStruct.Alternate = BUS_I2C4_SDA_GPIO_AF;
 8005e46:	2304      	movs	r3, #4
 8005e48:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
    HAL_GPIO_Init(BUS_I2C4_SDA_GPIO_PORT, &GPIO_InitStruct);
 8005e4c:	f107 03dc 	add.w	r3, r7, #220	@ 0xdc
 8005e50:	4619      	mov	r1, r3
 8005e52:	4814      	ldr	r0, [pc, #80]	@ (8005ea4 <I2C4_MspInit+0xf4>)
 8005e54:	f009 fc86 	bl	800f764 <HAL_GPIO_Init>

    /* Peripheral clock enable */
    __HAL_RCC_I2C4_CLK_ENABLE();
 8005e58:	4b11      	ldr	r3, [pc, #68]	@ (8005ea0 <I2C4_MspInit+0xf0>)
 8005e5a:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
 8005e5e:	4a10      	ldr	r2, [pc, #64]	@ (8005ea0 <I2C4_MspInit+0xf0>)
 8005e60:	f043 0302 	orr.w	r3, r3, #2
 8005e64:	f8c2 30a0 	str.w	r3, [r2, #160]	@ 0xa0
 8005e68:	4b0d      	ldr	r3, [pc, #52]	@ (8005ea0 <I2C4_MspInit+0xf0>)
 8005e6a:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
 8005e6e:	f003 0302 	and.w	r3, r3, #2
 8005e72:	60bb      	str	r3, [r7, #8]
 8005e74:	68bb      	ldr	r3, [r7, #8]

    /* Peripheral interrupt init */
    HAL_NVIC_SetPriority(I2C4_EV_IRQn, 0, 0);
 8005e76:	2200      	movs	r2, #0
 8005e78:	2100      	movs	r1, #0
 8005e7a:	2065      	movs	r0, #101	@ 0x65
 8005e7c:	f007 fef9 	bl	800dc72 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(I2C4_EV_IRQn);
 8005e80:	2065      	movs	r0, #101	@ 0x65
 8005e82:	f007 ff10 	bl	800dca6 <HAL_NVIC_EnableIRQ>
    HAL_NVIC_SetPriority(I2C4_ER_IRQn, 0, 0);
 8005e86:	2200      	movs	r2, #0
 8005e88:	2100      	movs	r1, #0
 8005e8a:	2064      	movs	r0, #100	@ 0x64
 8005e8c:	f007 fef1 	bl	800dc72 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(I2C4_ER_IRQn);
 8005e90:	2064      	movs	r0, #100	@ 0x64
 8005e92:	f007 ff08 	bl	800dca6 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN I2C4_MspInit 1 */

  /* USER CODE END I2C4_MspInit 1 */
}
 8005e96:	bf00      	nop
 8005e98:	37f0      	adds	r7, #240	@ 0xf0
 8005e9a:	46bd      	mov	sp, r7
 8005e9c:	bd80      	pop	{r7, pc}
 8005e9e:	bf00      	nop
 8005ea0:	46020c00 	.word	0x46020c00
 8005ea4:	42020c00 	.word	0x42020c00

08005ea8 <MX_I2C1_Init>:
}

/* I2C1 init function */

__weak HAL_StatusTypeDef MX_I2C1_Init(I2C_HandleTypeDef* hi2c)
{
 8005ea8:	b580      	push	{r7, lr}
 8005eaa:	b084      	sub	sp, #16
 8005eac:	af00      	add	r7, sp, #0
 8005eae:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef ret = HAL_OK;
 8005eb0:	2300      	movs	r3, #0
 8005eb2:	73fb      	strb	r3, [r7, #15]

  hi2c->Instance = I2C1;
 8005eb4:	687b      	ldr	r3, [r7, #4]
 8005eb6:	4a1c      	ldr	r2, [pc, #112]	@ (8005f28 <MX_I2C1_Init+0x80>)
 8005eb8:	601a      	str	r2, [r3, #0]
  hi2c->Init.Timing = 0x00F07BFF;
 8005eba:	687b      	ldr	r3, [r7, #4]
 8005ebc:	4a1b      	ldr	r2, [pc, #108]	@ (8005f2c <MX_I2C1_Init+0x84>)
 8005ebe:	605a      	str	r2, [r3, #4]
  hi2c->Init.OwnAddress1 = 0;
 8005ec0:	687b      	ldr	r3, [r7, #4]
 8005ec2:	2200      	movs	r2, #0
 8005ec4:	609a      	str	r2, [r3, #8]
  hi2c->Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 8005ec6:	687b      	ldr	r3, [r7, #4]
 8005ec8:	2201      	movs	r2, #1
 8005eca:	60da      	str	r2, [r3, #12]
  hi2c->Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
 8005ecc:	687b      	ldr	r3, [r7, #4]
 8005ece:	2200      	movs	r2, #0
 8005ed0:	611a      	str	r2, [r3, #16]
  hi2c->Init.OwnAddress2 = 0;
 8005ed2:	687b      	ldr	r3, [r7, #4]
 8005ed4:	2200      	movs	r2, #0
 8005ed6:	615a      	str	r2, [r3, #20]
  hi2c->Init.OwnAddress2Masks = I2C_OA2_NOMASK;
 8005ed8:	687b      	ldr	r3, [r7, #4]
 8005eda:	2200      	movs	r2, #0
 8005edc:	619a      	str	r2, [r3, #24]
  hi2c->Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
 8005ede:	687b      	ldr	r3, [r7, #4]
 8005ee0:	2200      	movs	r2, #0
 8005ee2:	61da      	str	r2, [r3, #28]
  hi2c->Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
 8005ee4:	687b      	ldr	r3, [r7, #4]
 8005ee6:	2200      	movs	r2, #0
 8005ee8:	621a      	str	r2, [r3, #32]
  if (HAL_I2C_Init(hi2c) != HAL_OK)
 8005eea:	6878      	ldr	r0, [r7, #4]
 8005eec:	f009 ff5c 	bl	800fda8 <HAL_I2C_Init>
 8005ef0:	4603      	mov	r3, r0
 8005ef2:	2b00      	cmp	r3, #0
 8005ef4:	d001      	beq.n	8005efa <MX_I2C1_Init+0x52>
  {
    ret = HAL_ERROR;
 8005ef6:	2301      	movs	r3, #1
 8005ef8:	73fb      	strb	r3, [r7, #15]
  }

  if (HAL_I2CEx_ConfigAnalogFilter(hi2c, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
 8005efa:	2100      	movs	r1, #0
 8005efc:	6878      	ldr	r0, [r7, #4]
 8005efe:	f00b fb41 	bl	8011584 <HAL_I2CEx_ConfigAnalogFilter>
 8005f02:	4603      	mov	r3, r0
 8005f04:	2b00      	cmp	r3, #0
 8005f06:	d001      	beq.n	8005f0c <MX_I2C1_Init+0x64>
  {
    ret = HAL_ERROR;
 8005f08:	2301      	movs	r3, #1
 8005f0a:	73fb      	strb	r3, [r7, #15]
  }

  if (HAL_I2CEx_ConfigDigitalFilter(hi2c, 0) != HAL_OK)
 8005f0c:	2100      	movs	r1, #0
 8005f0e:	6878      	ldr	r0, [r7, #4]
 8005f10:	f00b fb83 	bl	801161a <HAL_I2CEx_ConfigDigitalFilter>
 8005f14:	4603      	mov	r3, r0
 8005f16:	2b00      	cmp	r3, #0
 8005f18:	d001      	beq.n	8005f1e <MX_I2C1_Init+0x76>
  {
    ret = HAL_ERROR;
 8005f1a:	2301      	movs	r3, #1
 8005f1c:	73fb      	strb	r3, [r7, #15]
  }

  return ret;
 8005f1e:	7bfb      	ldrb	r3, [r7, #15]
}
 8005f20:	4618      	mov	r0, r3
 8005f22:	3710      	adds	r7, #16
 8005f24:	46bd      	mov	sp, r7
 8005f26:	bd80      	pop	{r7, pc}
 8005f28:	40005400 	.word	0x40005400
 8005f2c:	00f07bff 	.word	0x00f07bff

08005f30 <I2C1_MspInit>:
DMA_HandleTypeDef handle_GPDMA1_Channel3;
DMA_HandleTypeDef handle_GPDMA1_Channel2;

static void I2C1_MspInit(I2C_HandleTypeDef* i2cHandle)
{
 8005f30:	b580      	push	{r7, lr}
 8005f32:	b0bc      	sub	sp, #240	@ 0xf0
 8005f34:	af00      	add	r7, sp, #0
 8005f36:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct;
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 8005f38:	f107 0310 	add.w	r3, r7, #16
 8005f3c:	22c8      	movs	r2, #200	@ 0xc8
 8005f3e:	2100      	movs	r1, #0
 8005f40:	4618      	mov	r0, r3
 8005f42:	f01e f88f 	bl	8024064 <memset>

  /* USER CODE END I2C1_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_I2C1;
 8005f46:	f04f 0240 	mov.w	r2, #64	@ 0x40
 8005f4a:	f04f 0300 	mov.w	r3, #0
 8005f4e:	e9c7 2304 	strd	r2, r3, [r7, #16]
    PeriphClkInit.I2c1ClockSelection = RCC_I2C1CLKSOURCE_PCLK1;
 8005f52:	2300      	movs	r3, #0
 8005f54:	67bb      	str	r3, [r7, #120]	@ 0x78
    HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit);
 8005f56:	f107 0310 	add.w	r3, r7, #16
 8005f5a:	4618      	mov	r0, r3
 8005f5c:	f00c ffb2 	bl	8012ec4 <HAL_RCCEx_PeriphCLKConfig>

    __HAL_RCC_GPIOB_CLK_ENABLE();
 8005f60:	4b65      	ldr	r3, [pc, #404]	@ (80060f8 <I2C1_MspInit+0x1c8>)
 8005f62:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8005f66:	4a64      	ldr	r2, [pc, #400]	@ (80060f8 <I2C1_MspInit+0x1c8>)
 8005f68:	f043 0302 	orr.w	r3, r3, #2
 8005f6c:	f8c2 308c 	str.w	r3, [r2, #140]	@ 0x8c
 8005f70:	4b61      	ldr	r3, [pc, #388]	@ (80060f8 <I2C1_MspInit+0x1c8>)
 8005f72:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8005f76:	f003 0302 	and.w	r3, r3, #2
 8005f7a:	60fb      	str	r3, [r7, #12]
 8005f7c:	68fb      	ldr	r3, [r7, #12]
    /**I2C1 GPIO Configuration
    PB6     ------> I2C1_SCL
    PB7     ------> I2C1_SDA
    */
    GPIO_InitStruct.Pin = BUS_I2C1_SCL_GPIO_PIN;
 8005f7e:	2340      	movs	r3, #64	@ 0x40
 8005f80:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 8005f84:	2312      	movs	r3, #18
 8005f86:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8005f8a:	2300      	movs	r3, #0
 8005f8c:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8005f90:	2300      	movs	r3, #0
 8005f92:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
    GPIO_InitStruct.Alternate = BUS_I2C1_SCL_GPIO_AF;
 8005f96:	2304      	movs	r3, #4
 8005f98:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
    HAL_GPIO_Init(BUS_I2C1_SCL_GPIO_PORT, &GPIO_InitStruct);
 8005f9c:	f107 03dc 	add.w	r3, r7, #220	@ 0xdc
 8005fa0:	4619      	mov	r1, r3
 8005fa2:	4856      	ldr	r0, [pc, #344]	@ (80060fc <I2C1_MspInit+0x1cc>)
 8005fa4:	f009 fbde 	bl	800f764 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = BUS_I2C1_SDA_GPIO_PIN;
 8005fa8:	2380      	movs	r3, #128	@ 0x80
 8005faa:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 8005fae:	2312      	movs	r3, #18
 8005fb0:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8005fb4:	2300      	movs	r3, #0
 8005fb6:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8005fba:	2300      	movs	r3, #0
 8005fbc:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
    GPIO_InitStruct.Alternate = BUS_I2C1_SDA_GPIO_AF;
 8005fc0:	2304      	movs	r3, #4
 8005fc2:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
    HAL_GPIO_Init(BUS_I2C1_SDA_GPIO_PORT, &GPIO_InitStruct);
 8005fc6:	f107 03dc 	add.w	r3, r7, #220	@ 0xdc
 8005fca:	4619      	mov	r1, r3
 8005fcc:	484b      	ldr	r0, [pc, #300]	@ (80060fc <I2C1_MspInit+0x1cc>)
 8005fce:	f009 fbc9 	bl	800f764 <HAL_GPIO_Init>

    /* Peripheral clock enable */
    __HAL_RCC_I2C1_CLK_ENABLE();
 8005fd2:	4b49      	ldr	r3, [pc, #292]	@ (80060f8 <I2C1_MspInit+0x1c8>)
 8005fd4:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
 8005fd8:	4a47      	ldr	r2, [pc, #284]	@ (80060f8 <I2C1_MspInit+0x1c8>)
 8005fda:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
 8005fde:	f8c2 309c 	str.w	r3, [r2, #156]	@ 0x9c
 8005fe2:	4b45      	ldr	r3, [pc, #276]	@ (80060f8 <I2C1_MspInit+0x1c8>)
 8005fe4:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
 8005fe8:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
 8005fec:	60bb      	str	r3, [r7, #8]
 8005fee:	68bb      	ldr	r3, [r7, #8]

    /* Peripheral DMA init*/

    handle_GPDMA1_Channel3.Instance = GPDMA1_Channel3;
 8005ff0:	4b43      	ldr	r3, [pc, #268]	@ (8006100 <I2C1_MspInit+0x1d0>)
 8005ff2:	4a44      	ldr	r2, [pc, #272]	@ (8006104 <I2C1_MspInit+0x1d4>)
 8005ff4:	601a      	str	r2, [r3, #0]
    handle_GPDMA1_Channel3.Init.Request = GPDMA1_REQUEST_I2C1_TX;
 8005ff6:	4b42      	ldr	r3, [pc, #264]	@ (8006100 <I2C1_MspInit+0x1d0>)
 8005ff8:	220d      	movs	r2, #13
 8005ffa:	605a      	str	r2, [r3, #4]
    handle_GPDMA1_Channel3.Init.BlkHWRequest = DMA_BREQ_SINGLE_BURST;
 8005ffc:	4b40      	ldr	r3, [pc, #256]	@ (8006100 <I2C1_MspInit+0x1d0>)
 8005ffe:	2200      	movs	r2, #0
 8006000:	609a      	str	r2, [r3, #8]
    handle_GPDMA1_Channel3.Init.Direction = DMA_MEMORY_TO_PERIPH;
 8006002:	4b3f      	ldr	r3, [pc, #252]	@ (8006100 <I2C1_MspInit+0x1d0>)
 8006004:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 8006008:	60da      	str	r2, [r3, #12]
    handle_GPDMA1_Channel3.Init.SrcInc = DMA_SINC_INCREMENTED;
 800600a:	4b3d      	ldr	r3, [pc, #244]	@ (8006100 <I2C1_MspInit+0x1d0>)
 800600c:	2208      	movs	r2, #8
 800600e:	611a      	str	r2, [r3, #16]
    handle_GPDMA1_Channel3.Init.DestInc = DMA_DINC_FIXED;
 8006010:	4b3b      	ldr	r3, [pc, #236]	@ (8006100 <I2C1_MspInit+0x1d0>)
 8006012:	2200      	movs	r2, #0
 8006014:	615a      	str	r2, [r3, #20]
    handle_GPDMA1_Channel3.Init.SrcDataWidth = DMA_SRC_DATAWIDTH_BYTE;
 8006016:	4b3a      	ldr	r3, [pc, #232]	@ (8006100 <I2C1_MspInit+0x1d0>)
 8006018:	2200      	movs	r2, #0
 800601a:	619a      	str	r2, [r3, #24]
    handle_GPDMA1_Channel3.Init.DestDataWidth = DMA_DEST_DATAWIDTH_BYTE;
 800601c:	4b38      	ldr	r3, [pc, #224]	@ (8006100 <I2C1_MspInit+0x1d0>)
 800601e:	2200      	movs	r2, #0
 8006020:	61da      	str	r2, [r3, #28]
    handle_GPDMA1_Channel3.Init.Priority = DMA_LOW_PRIORITY_LOW_WEIGHT;
 8006022:	4b37      	ldr	r3, [pc, #220]	@ (8006100 <I2C1_MspInit+0x1d0>)
 8006024:	2200      	movs	r2, #0
 8006026:	621a      	str	r2, [r3, #32]
    handle_GPDMA1_Channel3.Init.SrcBurstLength = 1;
 8006028:	4b35      	ldr	r3, [pc, #212]	@ (8006100 <I2C1_MspInit+0x1d0>)
 800602a:	2201      	movs	r2, #1
 800602c:	625a      	str	r2, [r3, #36]	@ 0x24
    handle_GPDMA1_Channel3.Init.DestBurstLength = 1;
 800602e:	4b34      	ldr	r3, [pc, #208]	@ (8006100 <I2C1_MspInit+0x1d0>)
 8006030:	2201      	movs	r2, #1
 8006032:	629a      	str	r2, [r3, #40]	@ 0x28
    handle_GPDMA1_Channel3.Init.TransferAllocatedPort = DMA_SRC_ALLOCATED_PORT0|DMA_DEST_ALLOCATED_PORT0;
 8006034:	4b32      	ldr	r3, [pc, #200]	@ (8006100 <I2C1_MspInit+0x1d0>)
 8006036:	2200      	movs	r2, #0
 8006038:	62da      	str	r2, [r3, #44]	@ 0x2c
    handle_GPDMA1_Channel3.Init.TransferEventMode = DMA_TCEM_BLOCK_TRANSFER;
 800603a:	4b31      	ldr	r3, [pc, #196]	@ (8006100 <I2C1_MspInit+0x1d0>)
 800603c:	2200      	movs	r2, #0
 800603e:	631a      	str	r2, [r3, #48]	@ 0x30
    handle_GPDMA1_Channel3.Init.Mode = DMA_NORMAL;
 8006040:	4b2f      	ldr	r3, [pc, #188]	@ (8006100 <I2C1_MspInit+0x1d0>)
 8006042:	2200      	movs	r2, #0
 8006044:	635a      	str	r2, [r3, #52]	@ 0x34
    HAL_DMA_Init(&handle_GPDMA1_Channel3);
 8006046:	482e      	ldr	r0, [pc, #184]	@ (8006100 <I2C1_MspInit+0x1d0>)
 8006048:	f008 f944 	bl	800e2d4 <HAL_DMA_Init>

    __HAL_LINKDMA(i2cHandle, hdmatx, handle_GPDMA1_Channel3);
 800604c:	687b      	ldr	r3, [r7, #4]
 800604e:	4a2c      	ldr	r2, [pc, #176]	@ (8006100 <I2C1_MspInit+0x1d0>)
 8006050:	639a      	str	r2, [r3, #56]	@ 0x38
 8006052:	4a2b      	ldr	r2, [pc, #172]	@ (8006100 <I2C1_MspInit+0x1d0>)
 8006054:	687b      	ldr	r3, [r7, #4]
 8006056:	65d3      	str	r3, [r2, #92]	@ 0x5c

    HAL_DMA_ConfigChannelAttributes(&handle_GPDMA1_Channel3, DMA_CHANNEL_NPRIV);
 8006058:	2110      	movs	r1, #16
 800605a:	4829      	ldr	r0, [pc, #164]	@ (8006100 <I2C1_MspInit+0x1d0>)
 800605c:	f008 fcd8 	bl	800ea10 <HAL_DMA_ConfigChannelAttributes>

    handle_GPDMA1_Channel2.Instance = GPDMA1_Channel2;
 8006060:	4b29      	ldr	r3, [pc, #164]	@ (8006108 <I2C1_MspInit+0x1d8>)
 8006062:	4a2a      	ldr	r2, [pc, #168]	@ (800610c <I2C1_MspInit+0x1dc>)
 8006064:	601a      	str	r2, [r3, #0]
    handle_GPDMA1_Channel2.Init.Request = GPDMA1_REQUEST_I2C1_RX;
 8006066:	4b28      	ldr	r3, [pc, #160]	@ (8006108 <I2C1_MspInit+0x1d8>)
 8006068:	220c      	movs	r2, #12
 800606a:	605a      	str	r2, [r3, #4]
    handle_GPDMA1_Channel2.Init.BlkHWRequest = DMA_BREQ_SINGLE_BURST;
 800606c:	4b26      	ldr	r3, [pc, #152]	@ (8006108 <I2C1_MspInit+0x1d8>)
 800606e:	2200      	movs	r2, #0
 8006070:	609a      	str	r2, [r3, #8]
    handle_GPDMA1_Channel2.Init.Direction = DMA_PERIPH_TO_MEMORY;
 8006072:	4b25      	ldr	r3, [pc, #148]	@ (8006108 <I2C1_MspInit+0x1d8>)
 8006074:	2200      	movs	r2, #0
 8006076:	60da      	str	r2, [r3, #12]
    handle_GPDMA1_Channel2.Init.SrcInc = DMA_SINC_FIXED;
 8006078:	4b23      	ldr	r3, [pc, #140]	@ (8006108 <I2C1_MspInit+0x1d8>)
 800607a:	2200      	movs	r2, #0
 800607c:	611a      	str	r2, [r3, #16]
    handle_GPDMA1_Channel2.Init.DestInc = DMA_DINC_INCREMENTED;
 800607e:	4b22      	ldr	r3, [pc, #136]	@ (8006108 <I2C1_MspInit+0x1d8>)
 8006080:	f44f 2200 	mov.w	r2, #524288	@ 0x80000
 8006084:	615a      	str	r2, [r3, #20]
    handle_GPDMA1_Channel2.Init.SrcDataWidth = DMA_SRC_DATAWIDTH_BYTE;
 8006086:	4b20      	ldr	r3, [pc, #128]	@ (8006108 <I2C1_MspInit+0x1d8>)
 8006088:	2200      	movs	r2, #0
 800608a:	619a      	str	r2, [r3, #24]
    handle_GPDMA1_Channel2.Init.DestDataWidth = DMA_DEST_DATAWIDTH_BYTE;
 800608c:	4b1e      	ldr	r3, [pc, #120]	@ (8006108 <I2C1_MspInit+0x1d8>)
 800608e:	2200      	movs	r2, #0
 8006090:	61da      	str	r2, [r3, #28]
    handle_GPDMA1_Channel2.Init.Priority = DMA_LOW_PRIORITY_LOW_WEIGHT;
 8006092:	4b1d      	ldr	r3, [pc, #116]	@ (8006108 <I2C1_MspInit+0x1d8>)
 8006094:	2200      	movs	r2, #0
 8006096:	621a      	str	r2, [r3, #32]
    handle_GPDMA1_Channel2.Init.SrcBurstLength = 1;
 8006098:	4b1b      	ldr	r3, [pc, #108]	@ (8006108 <I2C1_MspInit+0x1d8>)
 800609a:	2201      	movs	r2, #1
 800609c:	625a      	str	r2, [r3, #36]	@ 0x24
    handle_GPDMA1_Channel2.Init.DestBurstLength = 1;
 800609e:	4b1a      	ldr	r3, [pc, #104]	@ (8006108 <I2C1_MspInit+0x1d8>)
 80060a0:	2201      	movs	r2, #1
 80060a2:	629a      	str	r2, [r3, #40]	@ 0x28
    handle_GPDMA1_Channel2.Init.TransferAllocatedPort = DMA_SRC_ALLOCATED_PORT0|DMA_DEST_ALLOCATED_PORT0;
 80060a4:	4b18      	ldr	r3, [pc, #96]	@ (8006108 <I2C1_MspInit+0x1d8>)
 80060a6:	2200      	movs	r2, #0
 80060a8:	62da      	str	r2, [r3, #44]	@ 0x2c
    handle_GPDMA1_Channel2.Init.TransferEventMode = DMA_TCEM_BLOCK_TRANSFER;
 80060aa:	4b17      	ldr	r3, [pc, #92]	@ (8006108 <I2C1_MspInit+0x1d8>)
 80060ac:	2200      	movs	r2, #0
 80060ae:	631a      	str	r2, [r3, #48]	@ 0x30
    handle_GPDMA1_Channel2.Init.Mode = DMA_NORMAL;
 80060b0:	4b15      	ldr	r3, [pc, #84]	@ (8006108 <I2C1_MspInit+0x1d8>)
 80060b2:	2200      	movs	r2, #0
 80060b4:	635a      	str	r2, [r3, #52]	@ 0x34
    HAL_DMA_Init(&handle_GPDMA1_Channel2);
 80060b6:	4814      	ldr	r0, [pc, #80]	@ (8006108 <I2C1_MspInit+0x1d8>)
 80060b8:	f008 f90c 	bl	800e2d4 <HAL_DMA_Init>

    __HAL_LINKDMA(i2cHandle, hdmarx, handle_GPDMA1_Channel2);
 80060bc:	687b      	ldr	r3, [r7, #4]
 80060be:	4a12      	ldr	r2, [pc, #72]	@ (8006108 <I2C1_MspInit+0x1d8>)
 80060c0:	63da      	str	r2, [r3, #60]	@ 0x3c
 80060c2:	4a11      	ldr	r2, [pc, #68]	@ (8006108 <I2C1_MspInit+0x1d8>)
 80060c4:	687b      	ldr	r3, [r7, #4]
 80060c6:	65d3      	str	r3, [r2, #92]	@ 0x5c

    HAL_DMA_ConfigChannelAttributes(&handle_GPDMA1_Channel2, DMA_CHANNEL_NPRIV);
 80060c8:	2110      	movs	r1, #16
 80060ca:	480f      	ldr	r0, [pc, #60]	@ (8006108 <I2C1_MspInit+0x1d8>)
 80060cc:	f008 fca0 	bl	800ea10 <HAL_DMA_ConfigChannelAttributes>

    /* Peripheral interrupt init */
    HAL_NVIC_SetPriority(I2C1_EV_IRQn, 0, 0);
 80060d0:	2200      	movs	r2, #0
 80060d2:	2100      	movs	r1, #0
 80060d4:	2037      	movs	r0, #55	@ 0x37
 80060d6:	f007 fdcc 	bl	800dc72 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(I2C1_EV_IRQn);
 80060da:	2037      	movs	r0, #55	@ 0x37
 80060dc:	f007 fde3 	bl	800dca6 <HAL_NVIC_EnableIRQ>
    HAL_NVIC_SetPriority(I2C1_ER_IRQn, 0, 0);
 80060e0:	2200      	movs	r2, #0
 80060e2:	2100      	movs	r1, #0
 80060e4:	2038      	movs	r0, #56	@ 0x38
 80060e6:	f007 fdc4 	bl	800dc72 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(I2C1_ER_IRQn);
 80060ea:	2038      	movs	r0, #56	@ 0x38
 80060ec:	f007 fddb 	bl	800dca6 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN I2C1_MspInit 1 */

  /* USER CODE END I2C1_MspInit 1 */
}
 80060f0:	bf00      	nop
 80060f2:	37f0      	adds	r7, #240	@ 0xf0
 80060f4:	46bd      	mov	sp, r7
 80060f6:	bd80      	pop	{r7, pc}
 80060f8:	46020c00 	.word	0x46020c00
 80060fc:	42020400 	.word	0x42020400
 8006100:	20000ad4 	.word	0x20000ad4
 8006104:	400201d0 	.word	0x400201d0
 8006108:	20000b4c 	.word	0x20000b4c
 800610c:	40020150 	.word	0x40020150

08006110 <I2C1_MspDeInit>:

static void I2C1_MspDeInit(I2C_HandleTypeDef* i2cHandle)
{
 8006110:	b580      	push	{r7, lr}
 8006112:	b082      	sub	sp, #8
 8006114:	af00      	add	r7, sp, #0
 8006116:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN I2C1_MspDeInit 0 */

  /* USER CODE END I2C1_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_I2C1_CLK_DISABLE();
 8006118:	4b11      	ldr	r3, [pc, #68]	@ (8006160 <I2C1_MspDeInit+0x50>)
 800611a:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
 800611e:	4a10      	ldr	r2, [pc, #64]	@ (8006160 <I2C1_MspDeInit+0x50>)
 8006120:	f423 1300 	bic.w	r3, r3, #2097152	@ 0x200000
 8006124:	f8c2 309c 	str.w	r3, [r2, #156]	@ 0x9c

    /**I2C1 GPIO Configuration
    PB6     ------> I2C1_SCL
    PB7     ------> I2C1_SDA
    */
    HAL_GPIO_DeInit(BUS_I2C1_SCL_GPIO_PORT, BUS_I2C1_SCL_GPIO_PIN);
 8006128:	2140      	movs	r1, #64	@ 0x40
 800612a:	480e      	ldr	r0, [pc, #56]	@ (8006164 <I2C1_MspDeInit+0x54>)
 800612c:	f009 fcf2 	bl	800fb14 <HAL_GPIO_DeInit>

    HAL_GPIO_DeInit(BUS_I2C1_SDA_GPIO_PORT, BUS_I2C1_SDA_GPIO_PIN);
 8006130:	2180      	movs	r1, #128	@ 0x80
 8006132:	480c      	ldr	r0, [pc, #48]	@ (8006164 <I2C1_MspDeInit+0x54>)
 8006134:	f009 fcee 	bl	800fb14 <HAL_GPIO_DeInit>

    /* Peripheral DMA DeInit*/
    HAL_DMA_DeInit(i2cHandle->hdmatx);
 8006138:	687b      	ldr	r3, [r7, #4]
 800613a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800613c:	4618      	mov	r0, r3
 800613e:	f008 f9f5 	bl	800e52c <HAL_DMA_DeInit>
    HAL_DMA_DeInit(i2cHandle->hdmarx);
 8006142:	687b      	ldr	r3, [r7, #4]
 8006144:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8006146:	4618      	mov	r0, r3
 8006148:	f008 f9f0 	bl	800e52c <HAL_DMA_DeInit>

    /* Peripheral interrupt Deinit*/
    HAL_NVIC_DisableIRQ(I2C1_EV_IRQn);
 800614c:	2037      	movs	r0, #55	@ 0x37
 800614e:	f007 fdb8 	bl	800dcc2 <HAL_NVIC_DisableIRQ>

    HAL_NVIC_DisableIRQ(I2C1_ER_IRQn);
 8006152:	2038      	movs	r0, #56	@ 0x38
 8006154:	f007 fdb5 	bl	800dcc2 <HAL_NVIC_DisableIRQ>

  /* USER CODE BEGIN I2C1_MspDeInit 1 */

  /* USER CODE END I2C1_MspDeInit 1 */
}
 8006158:	bf00      	nop
 800615a:	3708      	adds	r7, #8
 800615c:	46bd      	mov	sp, r7
 800615e:	bd80      	pop	{r7, pc}
 8006160:	46020c00 	.word	0x46020c00
 8006164:	42020400 	.word	0x42020400

08006168 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 8006168:	b480      	push	{r7}
 800616a:	b083      	sub	sp, #12
 800616c:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_PWR_CLK_ENABLE();
 800616e:	4b0a      	ldr	r3, [pc, #40]	@ (8006198 <HAL_MspInit+0x30>)
 8006170:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 8006174:	4a08      	ldr	r2, [pc, #32]	@ (8006198 <HAL_MspInit+0x30>)
 8006176:	f043 0304 	orr.w	r3, r3, #4
 800617a:	f8c2 3094 	str.w	r3, [r2, #148]	@ 0x94
 800617e:	4b06      	ldr	r3, [pc, #24]	@ (8006198 <HAL_MspInit+0x30>)
 8006180:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 8006184:	f003 0304 	and.w	r3, r3, #4
 8006188:	607b      	str	r3, [r7, #4]
 800618a:	687b      	ldr	r3, [r7, #4]
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 800618c:	bf00      	nop
 800618e:	370c      	adds	r7, #12
 8006190:	46bd      	mov	sp, r7
 8006192:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006196:	4770      	bx	lr
 8006198:	46020c00 	.word	0x46020c00

0800619c <HAL_CRC_MspInit>:
* This function configures the hardware resources used in this example
* @param hcrc: CRC handle pointer
* @retval None
*/
void HAL_CRC_MspInit(CRC_HandleTypeDef* hcrc)
{
 800619c:	b480      	push	{r7}
 800619e:	b085      	sub	sp, #20
 80061a0:	af00      	add	r7, sp, #0
 80061a2:	6078      	str	r0, [r7, #4]
  if(hcrc->Instance==CRC)
 80061a4:	687b      	ldr	r3, [r7, #4]
 80061a6:	681b      	ldr	r3, [r3, #0]
 80061a8:	4a0b      	ldr	r2, [pc, #44]	@ (80061d8 <HAL_CRC_MspInit+0x3c>)
 80061aa:	4293      	cmp	r3, r2
 80061ac:	d10e      	bne.n	80061cc <HAL_CRC_MspInit+0x30>
  {
  /* USER CODE BEGIN CRC_MspInit 0 */

  /* USER CODE END CRC_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_CRC_CLK_ENABLE();
 80061ae:	4b0b      	ldr	r3, [pc, #44]	@ (80061dc <HAL_CRC_MspInit+0x40>)
 80061b0:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 80061b4:	4a09      	ldr	r2, [pc, #36]	@ (80061dc <HAL_CRC_MspInit+0x40>)
 80061b6:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
 80061ba:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88
 80061be:	4b07      	ldr	r3, [pc, #28]	@ (80061dc <HAL_CRC_MspInit+0x40>)
 80061c0:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 80061c4:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
 80061c8:	60fb      	str	r3, [r7, #12]
 80061ca:	68fb      	ldr	r3, [r7, #12]
  /* USER CODE BEGIN CRC_MspInit 1 */

  /* USER CODE END CRC_MspInit 1 */
  }

}
 80061cc:	bf00      	nop
 80061ce:	3714      	adds	r7, #20
 80061d0:	46bd      	mov	sp, r7
 80061d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80061d6:	4770      	bx	lr
 80061d8:	40023000 	.word	0x40023000
 80061dc:	46020c00 	.word	0x46020c00

080061e0 <HAL_CRC_MspDeInit>:
* This function freeze the hardware resources used in this example
* @param hcrc: CRC handle pointer
* @retval None
*/
void HAL_CRC_MspDeInit(CRC_HandleTypeDef* hcrc)
{
 80061e0:	b480      	push	{r7}
 80061e2:	b083      	sub	sp, #12
 80061e4:	af00      	add	r7, sp, #0
 80061e6:	6078      	str	r0, [r7, #4]
  if(hcrc->Instance==CRC)
 80061e8:	687b      	ldr	r3, [r7, #4]
 80061ea:	681b      	ldr	r3, [r3, #0]
 80061ec:	4a08      	ldr	r2, [pc, #32]	@ (8006210 <HAL_CRC_MspDeInit+0x30>)
 80061ee:	4293      	cmp	r3, r2
 80061f0:	d107      	bne.n	8006202 <HAL_CRC_MspDeInit+0x22>
  {
  /* USER CODE BEGIN CRC_MspDeInit 0 */

  /* USER CODE END CRC_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_CRC_CLK_DISABLE();
 80061f2:	4b08      	ldr	r3, [pc, #32]	@ (8006214 <HAL_CRC_MspDeInit+0x34>)
 80061f4:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 80061f8:	4a06      	ldr	r2, [pc, #24]	@ (8006214 <HAL_CRC_MspDeInit+0x34>)
 80061fa:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
 80061fe:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88
  /* USER CODE BEGIN CRC_MspDeInit 1 */

  /* USER CODE END CRC_MspDeInit 1 */
  }

}
 8006202:	bf00      	nop
 8006204:	370c      	adds	r7, #12
 8006206:	46bd      	mov	sp, r7
 8006208:	f85d 7b04 	ldr.w	r7, [sp], #4
 800620c:	4770      	bx	lr
 800620e:	bf00      	nop
 8006210:	40023000 	.word	0x40023000
 8006214:	46020c00 	.word	0x46020c00

08006218 <HAL_SPI_MspInit>:
* This function configures the hardware resources used in this example
* @param hspi: SPI handle pointer
* @retval None
*/
void HAL_SPI_MspInit(SPI_HandleTypeDef* hspi)
{
 8006218:	b580      	push	{r7, lr}
 800621a:	b0bc      	sub	sp, #240	@ 0xf0
 800621c:	af00      	add	r7, sp, #0
 800621e:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8006220:	f107 03dc 	add.w	r3, r7, #220	@ 0xdc
 8006224:	2200      	movs	r2, #0
 8006226:	601a      	str	r2, [r3, #0]
 8006228:	605a      	str	r2, [r3, #4]
 800622a:	609a      	str	r2, [r3, #8]
 800622c:	60da      	str	r2, [r3, #12]
 800622e:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 8006230:	f107 0310 	add.w	r3, r7, #16
 8006234:	22c8      	movs	r2, #200	@ 0xc8
 8006236:	2100      	movs	r1, #0
 8006238:	4618      	mov	r0, r3
 800623a:	f01d ff13 	bl	8024064 <memset>
  if(hspi->Instance==SPI2)
 800623e:	687b      	ldr	r3, [r7, #4]
 8006240:	681b      	ldr	r3, [r3, #0]
 8006242:	4a79      	ldr	r2, [pc, #484]	@ (8006428 <HAL_SPI_MspInit+0x210>)
 8006244:	4293      	cmp	r3, r2
 8006246:	f040 80eb 	bne.w	8006420 <HAL_SPI_MspInit+0x208>

  /* USER CODE END SPI2_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_SPI2;
 800624a:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
 800624e:	f04f 0300 	mov.w	r3, #0
 8006252:	e9c7 2304 	strd	r2, r3, [r7, #16]
    PeriphClkInit.Spi2ClockSelection = RCC_SPI2CLKSOURCE_PCLK1;
 8006256:	2300      	movs	r3, #0
 8006258:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 800625c:	f107 0310 	add.w	r3, r7, #16
 8006260:	4618      	mov	r0, r3
 8006262:	f00c fe2f 	bl	8012ec4 <HAL_RCCEx_PeriphCLKConfig>
 8006266:	4603      	mov	r3, r0
 8006268:	2b00      	cmp	r3, #0
 800626a:	d001      	beq.n	8006270 <HAL_SPI_MspInit+0x58>
    {
      Error_Handler();
 800626c:	f7fe fe07 	bl	8004e7e <Error_Handler>
    }

    /* Peripheral clock enable */
    __HAL_RCC_SPI2_CLK_ENABLE();
 8006270:	4b6e      	ldr	r3, [pc, #440]	@ (800642c <HAL_SPI_MspInit+0x214>)
 8006272:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
 8006276:	4a6d      	ldr	r2, [pc, #436]	@ (800642c <HAL_SPI_MspInit+0x214>)
 8006278:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 800627c:	f8c2 309c 	str.w	r3, [r2, #156]	@ 0x9c
 8006280:	4b6a      	ldr	r3, [pc, #424]	@ (800642c <HAL_SPI_MspInit+0x214>)
 8006282:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
 8006286:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
 800628a:	60fb      	str	r3, [r7, #12]
 800628c:	68fb      	ldr	r3, [r7, #12]

    __HAL_RCC_GPIOI_CLK_ENABLE();
 800628e:	4b67      	ldr	r3, [pc, #412]	@ (800642c <HAL_SPI_MspInit+0x214>)
 8006290:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8006294:	4a65      	ldr	r2, [pc, #404]	@ (800642c <HAL_SPI_MspInit+0x214>)
 8006296:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 800629a:	f8c2 308c 	str.w	r3, [r2, #140]	@ 0x8c
 800629e:	4b63      	ldr	r3, [pc, #396]	@ (800642c <HAL_SPI_MspInit+0x214>)
 80062a0:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 80062a4:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 80062a8:	60bb      	str	r3, [r7, #8]
 80062aa:	68bb      	ldr	r3, [r7, #8]
    /**SPI2 GPIO Configuration
    PI1     ------> SPI2_SCK
    PI3     ------> SPI2_MOSI
    PI2     ------> SPI2_MISO
    */
    GPIO_InitStruct.Pin = GPIO_PIN_1;
 80062ac:	2302      	movs	r3, #2
 80062ae:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80062b2:	2302      	movs	r3, #2
 80062b4:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 80062b8:	2301      	movs	r3, #1
 80062ba:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 80062be:	2302      	movs	r3, #2
 80062c0:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
 80062c4:	2305      	movs	r3, #5
 80062c6:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
    HAL_GPIO_Init(GPIOI, &GPIO_InitStruct);
 80062ca:	f107 03dc 	add.w	r3, r7, #220	@ 0xdc
 80062ce:	4619      	mov	r1, r3
 80062d0:	4857      	ldr	r0, [pc, #348]	@ (8006430 <HAL_SPI_MspInit+0x218>)
 80062d2:	f009 fa47 	bl	800f764 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_2;
 80062d6:	230c      	movs	r3, #12
 80062d8:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80062dc:	2302      	movs	r3, #2
 80062de:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80062e2:	2300      	movs	r3, #0
 80062e4:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 80062e8:	2302      	movs	r3, #2
 80062ea:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
 80062ee:	2305      	movs	r3, #5
 80062f0:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
    HAL_GPIO_Init(GPIOI, &GPIO_InitStruct);
 80062f4:	f107 03dc 	add.w	r3, r7, #220	@ 0xdc
 80062f8:	4619      	mov	r1, r3
 80062fa:	484d      	ldr	r0, [pc, #308]	@ (8006430 <HAL_SPI_MspInit+0x218>)
 80062fc:	f009 fa32 	bl	800f764 <HAL_GPIO_Init>

    /* SPI2 DMA Init */
    /* GPDMA1_REQUEST_SPI2_TX Init */
    handle_GPDMA1_Channel1.Instance = GPDMA1_Channel1;
 8006300:	4b4c      	ldr	r3, [pc, #304]	@ (8006434 <HAL_SPI_MspInit+0x21c>)
 8006302:	4a4d      	ldr	r2, [pc, #308]	@ (8006438 <HAL_SPI_MspInit+0x220>)
 8006304:	601a      	str	r2, [r3, #0]
    handle_GPDMA1_Channel1.Init.Request = GPDMA1_REQUEST_SPI2_TX;
 8006306:	4b4b      	ldr	r3, [pc, #300]	@ (8006434 <HAL_SPI_MspInit+0x21c>)
 8006308:	2209      	movs	r2, #9
 800630a:	605a      	str	r2, [r3, #4]
    handle_GPDMA1_Channel1.Init.BlkHWRequest = DMA_BREQ_SINGLE_BURST;
 800630c:	4b49      	ldr	r3, [pc, #292]	@ (8006434 <HAL_SPI_MspInit+0x21c>)
 800630e:	2200      	movs	r2, #0
 8006310:	609a      	str	r2, [r3, #8]
    handle_GPDMA1_Channel1.Init.Direction = DMA_MEMORY_TO_PERIPH;
 8006312:	4b48      	ldr	r3, [pc, #288]	@ (8006434 <HAL_SPI_MspInit+0x21c>)
 8006314:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 8006318:	60da      	str	r2, [r3, #12]
    handle_GPDMA1_Channel1.Init.SrcInc = DMA_SINC_INCREMENTED;
 800631a:	4b46      	ldr	r3, [pc, #280]	@ (8006434 <HAL_SPI_MspInit+0x21c>)
 800631c:	2208      	movs	r2, #8
 800631e:	611a      	str	r2, [r3, #16]
    handle_GPDMA1_Channel1.Init.DestInc = DMA_DINC_FIXED;
 8006320:	4b44      	ldr	r3, [pc, #272]	@ (8006434 <HAL_SPI_MspInit+0x21c>)
 8006322:	2200      	movs	r2, #0
 8006324:	615a      	str	r2, [r3, #20]
    handle_GPDMA1_Channel1.Init.SrcDataWidth = DMA_SRC_DATAWIDTH_BYTE;
 8006326:	4b43      	ldr	r3, [pc, #268]	@ (8006434 <HAL_SPI_MspInit+0x21c>)
 8006328:	2200      	movs	r2, #0
 800632a:	619a      	str	r2, [r3, #24]
    handle_GPDMA1_Channel1.Init.DestDataWidth = DMA_DEST_DATAWIDTH_BYTE;
 800632c:	4b41      	ldr	r3, [pc, #260]	@ (8006434 <HAL_SPI_MspInit+0x21c>)
 800632e:	2200      	movs	r2, #0
 8006330:	61da      	str	r2, [r3, #28]
    handle_GPDMA1_Channel1.Init.Priority = DMA_LOW_PRIORITY_MID_WEIGHT;
 8006332:	4b40      	ldr	r3, [pc, #256]	@ (8006434 <HAL_SPI_MspInit+0x21c>)
 8006334:	f44f 0280 	mov.w	r2, #4194304	@ 0x400000
 8006338:	621a      	str	r2, [r3, #32]
    handle_GPDMA1_Channel1.Init.SrcBurstLength = 1;
 800633a:	4b3e      	ldr	r3, [pc, #248]	@ (8006434 <HAL_SPI_MspInit+0x21c>)
 800633c:	2201      	movs	r2, #1
 800633e:	625a      	str	r2, [r3, #36]	@ 0x24
    handle_GPDMA1_Channel1.Init.DestBurstLength = 1;
 8006340:	4b3c      	ldr	r3, [pc, #240]	@ (8006434 <HAL_SPI_MspInit+0x21c>)
 8006342:	2201      	movs	r2, #1
 8006344:	629a      	str	r2, [r3, #40]	@ 0x28
    handle_GPDMA1_Channel1.Init.TransferAllocatedPort = DMA_SRC_ALLOCATED_PORT0|DMA_DEST_ALLOCATED_PORT0;
 8006346:	4b3b      	ldr	r3, [pc, #236]	@ (8006434 <HAL_SPI_MspInit+0x21c>)
 8006348:	2200      	movs	r2, #0
 800634a:	62da      	str	r2, [r3, #44]	@ 0x2c
    handle_GPDMA1_Channel1.Init.TransferEventMode = DMA_TCEM_BLOCK_TRANSFER;
 800634c:	4b39      	ldr	r3, [pc, #228]	@ (8006434 <HAL_SPI_MspInit+0x21c>)
 800634e:	2200      	movs	r2, #0
 8006350:	631a      	str	r2, [r3, #48]	@ 0x30
    handle_GPDMA1_Channel1.Init.Mode = DMA_NORMAL;
 8006352:	4b38      	ldr	r3, [pc, #224]	@ (8006434 <HAL_SPI_MspInit+0x21c>)
 8006354:	2200      	movs	r2, #0
 8006356:	635a      	str	r2, [r3, #52]	@ 0x34
    if (HAL_DMA_Init(&handle_GPDMA1_Channel1) != HAL_OK)
 8006358:	4836      	ldr	r0, [pc, #216]	@ (8006434 <HAL_SPI_MspInit+0x21c>)
 800635a:	f007 ffbb 	bl	800e2d4 <HAL_DMA_Init>
 800635e:	4603      	mov	r3, r0
 8006360:	2b00      	cmp	r3, #0
 8006362:	d001      	beq.n	8006368 <HAL_SPI_MspInit+0x150>
    {
      Error_Handler();
 8006364:	f7fe fd8b 	bl	8004e7e <Error_Handler>
    }

    __HAL_LINKDMA(hspi, hdmatx, handle_GPDMA1_Channel1);
 8006368:	687b      	ldr	r3, [r7, #4]
 800636a:	4a32      	ldr	r2, [pc, #200]	@ (8006434 <HAL_SPI_MspInit+0x21c>)
 800636c:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
 8006370:	4a30      	ldr	r2, [pc, #192]	@ (8006434 <HAL_SPI_MspInit+0x21c>)
 8006372:	687b      	ldr	r3, [r7, #4]
 8006374:	65d3      	str	r3, [r2, #92]	@ 0x5c

    if (HAL_DMA_ConfigChannelAttributes(&handle_GPDMA1_Channel1, DMA_CHANNEL_NPRIV) != HAL_OK)
 8006376:	2110      	movs	r1, #16
 8006378:	482e      	ldr	r0, [pc, #184]	@ (8006434 <HAL_SPI_MspInit+0x21c>)
 800637a:	f008 fb49 	bl	800ea10 <HAL_DMA_ConfigChannelAttributes>
 800637e:	4603      	mov	r3, r0
 8006380:	2b00      	cmp	r3, #0
 8006382:	d001      	beq.n	8006388 <HAL_SPI_MspInit+0x170>
    {
      Error_Handler();
 8006384:	f7fe fd7b 	bl	8004e7e <Error_Handler>
    }

    /* GPDMA1_REQUEST_SPI2_RX Init */
    handle_GPDMA1_Channel0.Instance = GPDMA1_Channel0;
 8006388:	4b2c      	ldr	r3, [pc, #176]	@ (800643c <HAL_SPI_MspInit+0x224>)
 800638a:	4a2d      	ldr	r2, [pc, #180]	@ (8006440 <HAL_SPI_MspInit+0x228>)
 800638c:	601a      	str	r2, [r3, #0]
    handle_GPDMA1_Channel0.Init.Request = GPDMA1_REQUEST_SPI2_RX;
 800638e:	4b2b      	ldr	r3, [pc, #172]	@ (800643c <HAL_SPI_MspInit+0x224>)
 8006390:	2208      	movs	r2, #8
 8006392:	605a      	str	r2, [r3, #4]
    handle_GPDMA1_Channel0.Init.BlkHWRequest = DMA_BREQ_SINGLE_BURST;
 8006394:	4b29      	ldr	r3, [pc, #164]	@ (800643c <HAL_SPI_MspInit+0x224>)
 8006396:	2200      	movs	r2, #0
 8006398:	609a      	str	r2, [r3, #8]
    handle_GPDMA1_Channel0.Init.Direction = DMA_PERIPH_TO_MEMORY;
 800639a:	4b28      	ldr	r3, [pc, #160]	@ (800643c <HAL_SPI_MspInit+0x224>)
 800639c:	2200      	movs	r2, #0
 800639e:	60da      	str	r2, [r3, #12]
    handle_GPDMA1_Channel0.Init.SrcInc = DMA_SINC_FIXED;
 80063a0:	4b26      	ldr	r3, [pc, #152]	@ (800643c <HAL_SPI_MspInit+0x224>)
 80063a2:	2200      	movs	r2, #0
 80063a4:	611a      	str	r2, [r3, #16]
    handle_GPDMA1_Channel0.Init.DestInc = DMA_DINC_INCREMENTED;
 80063a6:	4b25      	ldr	r3, [pc, #148]	@ (800643c <HAL_SPI_MspInit+0x224>)
 80063a8:	f44f 2200 	mov.w	r2, #524288	@ 0x80000
 80063ac:	615a      	str	r2, [r3, #20]
    handle_GPDMA1_Channel0.Init.SrcDataWidth = DMA_SRC_DATAWIDTH_BYTE;
 80063ae:	4b23      	ldr	r3, [pc, #140]	@ (800643c <HAL_SPI_MspInit+0x224>)
 80063b0:	2200      	movs	r2, #0
 80063b2:	619a      	str	r2, [r3, #24]
    handle_GPDMA1_Channel0.Init.DestDataWidth = DMA_DEST_DATAWIDTH_BYTE;
 80063b4:	4b21      	ldr	r3, [pc, #132]	@ (800643c <HAL_SPI_MspInit+0x224>)
 80063b6:	2200      	movs	r2, #0
 80063b8:	61da      	str	r2, [r3, #28]
    handle_GPDMA1_Channel0.Init.Priority = DMA_LOW_PRIORITY_MID_WEIGHT;
 80063ba:	4b20      	ldr	r3, [pc, #128]	@ (800643c <HAL_SPI_MspInit+0x224>)
 80063bc:	f44f 0280 	mov.w	r2, #4194304	@ 0x400000
 80063c0:	621a      	str	r2, [r3, #32]
    handle_GPDMA1_Channel0.Init.SrcBurstLength = 1;
 80063c2:	4b1e      	ldr	r3, [pc, #120]	@ (800643c <HAL_SPI_MspInit+0x224>)
 80063c4:	2201      	movs	r2, #1
 80063c6:	625a      	str	r2, [r3, #36]	@ 0x24
    handle_GPDMA1_Channel0.Init.DestBurstLength = 1;
 80063c8:	4b1c      	ldr	r3, [pc, #112]	@ (800643c <HAL_SPI_MspInit+0x224>)
 80063ca:	2201      	movs	r2, #1
 80063cc:	629a      	str	r2, [r3, #40]	@ 0x28
    handle_GPDMA1_Channel0.Init.TransferAllocatedPort = DMA_SRC_ALLOCATED_PORT0|DMA_DEST_ALLOCATED_PORT0;
 80063ce:	4b1b      	ldr	r3, [pc, #108]	@ (800643c <HAL_SPI_MspInit+0x224>)
 80063d0:	2200      	movs	r2, #0
 80063d2:	62da      	str	r2, [r3, #44]	@ 0x2c
    handle_GPDMA1_Channel0.Init.TransferEventMode = DMA_TCEM_BLOCK_TRANSFER;
 80063d4:	4b19      	ldr	r3, [pc, #100]	@ (800643c <HAL_SPI_MspInit+0x224>)
 80063d6:	2200      	movs	r2, #0
 80063d8:	631a      	str	r2, [r3, #48]	@ 0x30
    handle_GPDMA1_Channel0.Init.Mode = DMA_NORMAL;
 80063da:	4b18      	ldr	r3, [pc, #96]	@ (800643c <HAL_SPI_MspInit+0x224>)
 80063dc:	2200      	movs	r2, #0
 80063de:	635a      	str	r2, [r3, #52]	@ 0x34
    if (HAL_DMA_Init(&handle_GPDMA1_Channel0) != HAL_OK)
 80063e0:	4816      	ldr	r0, [pc, #88]	@ (800643c <HAL_SPI_MspInit+0x224>)
 80063e2:	f007 ff77 	bl	800e2d4 <HAL_DMA_Init>
 80063e6:	4603      	mov	r3, r0
 80063e8:	2b00      	cmp	r3, #0
 80063ea:	d001      	beq.n	80063f0 <HAL_SPI_MspInit+0x1d8>
    {
      Error_Handler();
 80063ec:	f7fe fd47 	bl	8004e7e <Error_Handler>
    }

    __HAL_LINKDMA(hspi, hdmarx, handle_GPDMA1_Channel0);
 80063f0:	687b      	ldr	r3, [r7, #4]
 80063f2:	4a12      	ldr	r2, [pc, #72]	@ (800643c <HAL_SPI_MspInit+0x224>)
 80063f4:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
 80063f8:	4a10      	ldr	r2, [pc, #64]	@ (800643c <HAL_SPI_MspInit+0x224>)
 80063fa:	687b      	ldr	r3, [r7, #4]
 80063fc:	65d3      	str	r3, [r2, #92]	@ 0x5c

    if (HAL_DMA_ConfigChannelAttributes(&handle_GPDMA1_Channel0, DMA_CHANNEL_NPRIV) != HAL_OK)
 80063fe:	2110      	movs	r1, #16
 8006400:	480e      	ldr	r0, [pc, #56]	@ (800643c <HAL_SPI_MspInit+0x224>)
 8006402:	f008 fb05 	bl	800ea10 <HAL_DMA_ConfigChannelAttributes>
 8006406:	4603      	mov	r3, r0
 8006408:	2b00      	cmp	r3, #0
 800640a:	d001      	beq.n	8006410 <HAL_SPI_MspInit+0x1f8>
    {
      Error_Handler();
 800640c:	f7fe fd37 	bl	8004e7e <Error_Handler>
    }

    /* SPI2 interrupt Init */
    HAL_NVIC_SetPriority(SPI2_IRQn, 0, 0);
 8006410:	2200      	movs	r2, #0
 8006412:	2100      	movs	r1, #0
 8006414:	203c      	movs	r0, #60	@ 0x3c
 8006416:	f007 fc2c 	bl	800dc72 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(SPI2_IRQn);
 800641a:	203c      	movs	r0, #60	@ 0x3c
 800641c:	f007 fc43 	bl	800dca6 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN SPI2_MspInit 1 */

  /* USER CODE END SPI2_MspInit 1 */
  }

}
 8006420:	bf00      	nop
 8006422:	37f0      	adds	r7, #240	@ 0xf0
 8006424:	46bd      	mov	sp, r7
 8006426:	bd80      	pop	{r7, pc}
 8006428:	40003800 	.word	0x40003800
 800642c:	46020c00 	.word	0x46020c00
 8006430:	42022000 	.word	0x42022000
 8006434:	20000764 	.word	0x20000764
 8006438:	400200d0 	.word	0x400200d0
 800643c:	200007dc 	.word	0x200007dc
 8006440:	40020050 	.word	0x40020050

08006444 <HAL_TIM_OC_MspInit>:
* This function configures the hardware resources used in this example
* @param htim_oc: TIM_OC handle pointer
* @retval None
*/
void HAL_TIM_OC_MspInit(TIM_HandleTypeDef* htim_oc)
{
 8006444:	b580      	push	{r7, lr}
 8006446:	b084      	sub	sp, #16
 8006448:	af00      	add	r7, sp, #0
 800644a:	6078      	str	r0, [r7, #4]
  if(htim_oc->Instance==TIM1)
 800644c:	687b      	ldr	r3, [r7, #4]
 800644e:	681b      	ldr	r3, [r3, #0]
 8006450:	4a0e      	ldr	r2, [pc, #56]	@ (800648c <HAL_TIM_OC_MspInit+0x48>)
 8006452:	4293      	cmp	r3, r2
 8006454:	d116      	bne.n	8006484 <HAL_TIM_OC_MspInit+0x40>
  {
  /* USER CODE BEGIN TIM1_MspInit 0 */

  /* USER CODE END TIM1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_TIM1_CLK_ENABLE();
 8006456:	4b0e      	ldr	r3, [pc, #56]	@ (8006490 <HAL_TIM_OC_MspInit+0x4c>)
 8006458:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
 800645c:	4a0c      	ldr	r2, [pc, #48]	@ (8006490 <HAL_TIM_OC_MspInit+0x4c>)
 800645e:	f443 6300 	orr.w	r3, r3, #2048	@ 0x800
 8006462:	f8c2 30a4 	str.w	r3, [r2, #164]	@ 0xa4
 8006466:	4b0a      	ldr	r3, [pc, #40]	@ (8006490 <HAL_TIM_OC_MspInit+0x4c>)
 8006468:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
 800646c:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 8006470:	60fb      	str	r3, [r7, #12]
 8006472:	68fb      	ldr	r3, [r7, #12]
    /* TIM1 interrupt Init */
    HAL_NVIC_SetPriority(TIM1_CC_IRQn, 0, 0);
 8006474:	2200      	movs	r2, #0
 8006476:	2100      	movs	r1, #0
 8006478:	202c      	movs	r0, #44	@ 0x2c
 800647a:	f007 fbfa 	bl	800dc72 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(TIM1_CC_IRQn);
 800647e:	202c      	movs	r0, #44	@ 0x2c
 8006480:	f007 fc11 	bl	800dca6 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN TIM1_MspInit 1 */

  /* USER CODE END TIM1_MspInit 1 */
  }

}
 8006484:	bf00      	nop
 8006486:	3710      	adds	r7, #16
 8006488:	46bd      	mov	sp, r7
 800648a:	bd80      	pop	{r7, pc}
 800648c:	40012c00 	.word	0x40012c00
 8006490:	46020c00 	.word	0x46020c00

08006494 <HAL_TIM_OC_MspDeInit>:
* This function freeze the hardware resources used in this example
* @param htim_oc: TIM_OC handle pointer
* @retval None
*/
void HAL_TIM_OC_MspDeInit(TIM_HandleTypeDef* htim_oc)
{
 8006494:	b580      	push	{r7, lr}
 8006496:	b082      	sub	sp, #8
 8006498:	af00      	add	r7, sp, #0
 800649a:	6078      	str	r0, [r7, #4]
  if(htim_oc->Instance==TIM1)
 800649c:	687b      	ldr	r3, [r7, #4]
 800649e:	681b      	ldr	r3, [r3, #0]
 80064a0:	4a08      	ldr	r2, [pc, #32]	@ (80064c4 <HAL_TIM_OC_MspDeInit+0x30>)
 80064a2:	4293      	cmp	r3, r2
 80064a4:	d10a      	bne.n	80064bc <HAL_TIM_OC_MspDeInit+0x28>
  {
  /* USER CODE BEGIN TIM1_MspDeInit 0 */

  /* USER CODE END TIM1_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_TIM1_CLK_DISABLE();
 80064a6:	4b08      	ldr	r3, [pc, #32]	@ (80064c8 <HAL_TIM_OC_MspDeInit+0x34>)
 80064a8:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
 80064ac:	4a06      	ldr	r2, [pc, #24]	@ (80064c8 <HAL_TIM_OC_MspDeInit+0x34>)
 80064ae:	f423 6300 	bic.w	r3, r3, #2048	@ 0x800
 80064b2:	f8c2 30a4 	str.w	r3, [r2, #164]	@ 0xa4

    /* TIM1 interrupt DeInit */
    HAL_NVIC_DisableIRQ(TIM1_CC_IRQn);
 80064b6:	202c      	movs	r0, #44	@ 0x2c
 80064b8:	f007 fc03 	bl	800dcc2 <HAL_NVIC_DisableIRQ>
  /* USER CODE BEGIN TIM1_MspDeInit 1 */

  /* USER CODE END TIM1_MspDeInit 1 */
  }

}
 80064bc:	bf00      	nop
 80064be:	3708      	adds	r7, #8
 80064c0:	46bd      	mov	sp, r7
 80064c2:	bd80      	pop	{r7, pc}
 80064c4:	40012c00 	.word	0x40012c00
 80064c8:	46020c00 	.word	0x46020c00

080064cc <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
 80064cc:	b480      	push	{r7}
 80064ce:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
   while (1)
 80064d0:	e7fe      	b.n	80064d0 <NMI_Handler+0x4>

080064d2 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 80064d2:	b480      	push	{r7}
 80064d4:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 80064d6:	e7fe      	b.n	80064d6 <HardFault_Handler+0x4>

080064d8 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 80064d8:	b480      	push	{r7}
 80064da:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 80064dc:	e7fe      	b.n	80064dc <MemManage_Handler+0x4>

080064de <BusFault_Handler>:

/**
  * @brief This function handles Prefetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 80064de:	b480      	push	{r7}
 80064e0:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 80064e2:	e7fe      	b.n	80064e2 <BusFault_Handler+0x4>

080064e4 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 80064e4:	b480      	push	{r7}
 80064e6:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 80064e8:	e7fe      	b.n	80064e8 <UsageFault_Handler+0x4>

080064ea <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
 80064ea:	b480      	push	{r7}
 80064ec:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
 80064ee:	bf00      	nop
 80064f0:	46bd      	mov	sp, r7
 80064f2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80064f6:	4770      	bx	lr

080064f8 <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
 80064f8:	b480      	push	{r7}
 80064fa:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 80064fc:	bf00      	nop
 80064fe:	46bd      	mov	sp, r7
 8006500:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006504:	4770      	bx	lr

08006506 <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
 8006506:	b480      	push	{r7}
 8006508:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
 800650a:	bf00      	nop
 800650c:	46bd      	mov	sp, r7
 800650e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006512:	4770      	bx	lr

08006514 <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 8006514:	b580      	push	{r7, lr}
 8006516:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 8006518:	f007 fa8e 	bl	800da38 <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 800651c:	bf00      	nop
 800651e:	bd80      	pop	{r7, pc}

08006520 <EXTI0_IRQHandler>:

/**
  * @brief This function handles EXTI Line0 interrupt.
  */
void EXTI0_IRQHandler(void)
{
 8006520:	b580      	push	{r7, lr}
 8006522:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN EXTI0_IRQn 0 */

  /* USER CODE END EXTI0_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(SW2_Pin);
 8006524:	2001      	movs	r0, #1
 8006526:	f009 fc03 	bl	800fd30 <HAL_GPIO_EXTI_IRQHandler>
  /* USER CODE BEGIN EXTI0_IRQn 1 */

  /* USER CODE END EXTI0_IRQn 1 */
}
 800652a:	bf00      	nop
 800652c:	bd80      	pop	{r7, pc}

0800652e <EXTI1_IRQHandler>:

/**
  * @brief This function handles EXTI Line1 interrupt.
  */
void EXTI1_IRQHandler(void)
{
 800652e:	b580      	push	{r7, lr}
 8006530:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN EXTI1_IRQn 0 */

  /* USER CODE END EXTI1_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(BUTTON_PWR_Pin);
 8006532:	2002      	movs	r0, #2
 8006534:	f009 fbfc 	bl	800fd30 <HAL_GPIO_EXTI_IRQHandler>
  /* USER CODE BEGIN EXTI1_IRQn 1 */

  /* USER CODE END EXTI1_IRQn 1 */
}
 8006538:	bf00      	nop
 800653a:	bd80      	pop	{r7, pc}

0800653c <EXTI2_IRQHandler>:

/**
  * @brief This function handles EXTI Line2 interrupt.
  */
void EXTI2_IRQHandler(void)
{
 800653c:	b580      	push	{r7, lr}
 800653e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN EXTI2_IRQn 0 */

  /* USER CODE END EXTI2_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(ACC_INT1_Pin);
 8006540:	2004      	movs	r0, #4
 8006542:	f009 fbf5 	bl	800fd30 <HAL_GPIO_EXTI_IRQHandler>
  /* USER CODE BEGIN EXTI2_IRQn 1 */

  /* USER CODE END EXTI2_IRQn 1 */
}
 8006546:	bf00      	nop
 8006548:	bd80      	pop	{r7, pc}

0800654a <EXTI3_IRQHandler>:

/**
  * @brief This function handles EXTI Line3 interrupt.
  */
void EXTI3_IRQHandler(void)
{
 800654a:	b580      	push	{r7, lr}
 800654c:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN EXTI3_IRQn 0 */

  /* USER CODE END EXTI3_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(WC_INTB_Pin);
 800654e:	2008      	movs	r0, #8
 8006550:	f009 fbee 	bl	800fd30 <HAL_GPIO_EXTI_IRQHandler>
  /* USER CODE BEGIN EXTI3_IRQn 1 */

  /* USER CODE END EXTI3_IRQn 1 */
}
 8006554:	bf00      	nop
 8006556:	bd80      	pop	{r7, pc}

08006558 <EXTI4_IRQHandler>:

/**
  * @brief This function handles EXTI Line4 interrupt.
  */
void EXTI4_IRQHandler(void)
{
 8006558:	b580      	push	{r7, lr}
 800655a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN EXTI4_IRQn 0 */

  /* USER CODE END EXTI4_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(IMU_INT1_Pin);
 800655c:	2010      	movs	r0, #16
 800655e:	f009 fbe7 	bl	800fd30 <HAL_GPIO_EXTI_IRQHandler>
  /* USER CODE BEGIN EXTI4_IRQn 1 */

  /* USER CODE END EXTI4_IRQn 1 */
}
 8006562:	bf00      	nop
 8006564:	bd80      	pop	{r7, pc}
	...

08006568 <EXTI5_IRQHandler>:

/**
  * @brief This function handles EXTI Line5 interrupt.
  */
void EXTI5_IRQHandler(void)
{
 8006568:	b580      	push	{r7, lr}
 800656a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN EXTI5_IRQn 0 */

  /* USER CODE END EXTI5_IRQn 0 */
  HAL_EXTI_IRQHandler(&H_EXTI_5);
 800656c:	4802      	ldr	r0, [pc, #8]	@ (8006578 <EXTI5_IRQHandler+0x10>)
 800656e:	f008 fd5b 	bl	800f028 <HAL_EXTI_IRQHandler>
  /* USER CODE BEGIN EXTI5_IRQn 1 */

  /* USER CODE END EXTI5_IRQn 1 */
}
 8006572:	bf00      	nop
 8006574:	bd80      	pop	{r7, pc}
 8006576:	bf00      	nop
 8006578:	200001d4 	.word	0x200001d4

0800657c <EXTI6_IRQHandler>:

/**
  * @brief This function handles EXTI Line6 interrupt.
  */
void EXTI6_IRQHandler(void)
{
 800657c:	b580      	push	{r7, lr}
 800657e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN EXTI6_IRQn 0 */

  /* USER CODE END EXTI6_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(MAG_DRDY_Pin);
 8006580:	2040      	movs	r0, #64	@ 0x40
 8006582:	f009 fbd5 	bl	800fd30 <HAL_GPIO_EXTI_IRQHandler>
  /* USER CODE BEGIN EXTI6_IRQn 1 */

  /* USER CODE END EXTI6_IRQn 1 */
}
 8006586:	bf00      	nop
 8006588:	bd80      	pop	{r7, pc}

0800658a <EXTI8_IRQHandler>:

/**
  * @brief This function handles EXTI Line8 interrupt.
  */
void EXTI8_IRQHandler(void)
{
 800658a:	b580      	push	{r7, lr}
 800658c:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN EXTI8_IRQn 0 */

  /* USER CODE END EXTI8_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(PRESS_INT_Pin);
 800658e:	f44f 7080 	mov.w	r0, #256	@ 0x100
 8006592:	f009 fbcd 	bl	800fd30 <HAL_GPIO_EXTI_IRQHandler>
  /* USER CODE BEGIN EXTI8_IRQn 1 */

  /* USER CODE END EXTI8_IRQn 1 */
}
 8006596:	bf00      	nop
 8006598:	bd80      	pop	{r7, pc}
	...

0800659c <EXTI11_IRQHandler>:

/**
  * @brief This function handles EXTI Line11 interrupt.
  */
void EXTI11_IRQHandler(void)
{
 800659c:	b580      	push	{r7, lr}
 800659e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN EXTI11_IRQn 0 */

  /* USER CODE END EXTI11_IRQn 0 */
  HAL_EXTI_IRQHandler(&H_EXTI_11);
 80065a0:	4802      	ldr	r0, [pc, #8]	@ (80065ac <EXTI11_IRQHandler+0x10>)
 80065a2:	f008 fd41 	bl	800f028 <HAL_EXTI_IRQHandler>
  /* USER CODE BEGIN EXTI11_IRQn 1 */

  /* USER CODE END EXTI11_IRQn 1 */
}
 80065a6:	bf00      	nop
 80065a8:	bd80      	pop	{r7, pc}
 80065aa:	bf00      	nop
 80065ac:	200005a4 	.word	0x200005a4

080065b0 <EXTI13_IRQHandler>:

/**
  * @brief This function handles EXTI Line13 interrupt.
  */
void EXTI13_IRQHandler(void)
{
 80065b0:	b580      	push	{r7, lr}
 80065b2:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN EXTI13_IRQn 0 */

  /* USER CODE END EXTI13_IRQn 0 */
  HAL_EXTI_IRQHandler(&H_EXTI_13);
 80065b4:	4802      	ldr	r0, [pc, #8]	@ (80065c0 <EXTI13_IRQHandler+0x10>)
 80065b6:	f008 fd37 	bl	800f028 <HAL_EXTI_IRQHandler>
  /* USER CODE BEGIN EXTI13_IRQn 1 */

  /* USER CODE END EXTI13_IRQn 1 */
}
 80065ba:	bf00      	nop
 80065bc:	bd80      	pop	{r7, pc}
 80065be:	bf00      	nop
 80065c0:	20000020 	.word	0x20000020

080065c4 <EXTI15_IRQHandler>:

/**
  * @brief This function handles EXTI Line15 interrupt.
  */
void EXTI15_IRQHandler(void)
{
 80065c4:	b580      	push	{r7, lr}
 80065c6:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN EXTI15_IRQn 0 */

  /* USER CODE END EXTI15_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(ACC_INT2_Pin);
 80065c8:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
 80065cc:	f009 fbb0 	bl	800fd30 <HAL_GPIO_EXTI_IRQHandler>
  /* USER CODE BEGIN EXTI15_IRQn 1 */

  /* USER CODE END EXTI15_IRQn 1 */
}
 80065d0:	bf00      	nop
 80065d2:	bd80      	pop	{r7, pc}

080065d4 <GPDMA1_Channel0_IRQHandler>:

/**
  * @brief This function handles GPDMA1 Channel 0 global interrupt.
  */
void GPDMA1_Channel0_IRQHandler(void)
{
 80065d4:	b580      	push	{r7, lr}
 80065d6:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN GPDMA1_Channel0_IRQn 0 */

  /* USER CODE END GPDMA1_Channel0_IRQn 0 */
  HAL_DMA_IRQHandler(&handle_GPDMA1_Channel0);
 80065d8:	4802      	ldr	r0, [pc, #8]	@ (80065e4 <GPDMA1_Channel0_IRQHandler+0x10>)
 80065da:	f008 f8aa 	bl	800e732 <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN GPDMA1_Channel0_IRQn 1 */

  /* USER CODE END GPDMA1_Channel0_IRQn 1 */
}
 80065de:	bf00      	nop
 80065e0:	bd80      	pop	{r7, pc}
 80065e2:	bf00      	nop
 80065e4:	200007dc 	.word	0x200007dc

080065e8 <GPDMA1_Channel1_IRQHandler>:

/**
  * @brief This function handles GPDMA1 Channel 1 global interrupt.
  */
void GPDMA1_Channel1_IRQHandler(void)
{
 80065e8:	b580      	push	{r7, lr}
 80065ea:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN GPDMA1_Channel1_IRQn 0 */

  /* USER CODE END GPDMA1_Channel1_IRQn 0 */
  HAL_DMA_IRQHandler(&handle_GPDMA1_Channel1);
 80065ec:	4802      	ldr	r0, [pc, #8]	@ (80065f8 <GPDMA1_Channel1_IRQHandler+0x10>)
 80065ee:	f008 f8a0 	bl	800e732 <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN GPDMA1_Channel1_IRQn 1 */

  /* USER CODE END GPDMA1_Channel1_IRQn 1 */
}
 80065f2:	bf00      	nop
 80065f4:	bd80      	pop	{r7, pc}
 80065f6:	bf00      	nop
 80065f8:	20000764 	.word	0x20000764

080065fc <GPDMA1_Channel2_IRQHandler>:

/**
  * @brief This function handles GPDMA1 Channel 2 global interrupt.
  */
void GPDMA1_Channel2_IRQHandler(void)
{
 80065fc:	b580      	push	{r7, lr}
 80065fe:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN GPDMA1_Channel2_IRQn 0 */

  /* USER CODE END GPDMA1_Channel2_IRQn 0 */
  HAL_DMA_IRQHandler(&handle_GPDMA1_Channel2);
 8006600:	4802      	ldr	r0, [pc, #8]	@ (800660c <GPDMA1_Channel2_IRQHandler+0x10>)
 8006602:	f008 f896 	bl	800e732 <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN GPDMA1_Channel2_IRQn 1 */

  /* USER CODE END GPDMA1_Channel2_IRQn 1 */
}
 8006606:	bf00      	nop
 8006608:	bd80      	pop	{r7, pc}
 800660a:	bf00      	nop
 800660c:	20000b4c 	.word	0x20000b4c

08006610 <GPDMA1_Channel3_IRQHandler>:

/**
  * @brief This function handles GPDMA1 Channel 3 global interrupt.
  */
void GPDMA1_Channel3_IRQHandler(void)
{
 8006610:	b580      	push	{r7, lr}
 8006612:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN GPDMA1_Channel3_IRQn 0 */

  /* USER CODE END GPDMA1_Channel3_IRQn 0 */
  HAL_DMA_IRQHandler(&handle_GPDMA1_Channel3);
 8006614:	4802      	ldr	r0, [pc, #8]	@ (8006620 <GPDMA1_Channel3_IRQHandler+0x10>)
 8006616:	f008 f88c 	bl	800e732 <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN GPDMA1_Channel3_IRQn 1 */

  /* USER CODE END GPDMA1_Channel3_IRQn 1 */
}
 800661a:	bf00      	nop
 800661c:	bd80      	pop	{r7, pc}
 800661e:	bf00      	nop
 8006620:	20000ad4 	.word	0x20000ad4

08006624 <TIM1_CC_IRQHandler>:

/**
  * @brief This function handles TIM1 Capture Compare interrupt.
  */
void TIM1_CC_IRQHandler(void)
{
 8006624:	b580      	push	{r7, lr}
 8006626:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN TIM1_CC_IRQn 0 */

  /* USER CODE END TIM1_CC_IRQn 0 */
  HAL_TIM_IRQHandler(&htim1);
 8006628:	4802      	ldr	r0, [pc, #8]	@ (8006634 <TIM1_CC_IRQHandler+0x10>)
 800662a:	f010 fb4d 	bl	8016cc8 <HAL_TIM_IRQHandler>
  /* USER CODE BEGIN TIM1_CC_IRQn 1 */

  /* USER CODE END TIM1_CC_IRQn 1 */
}
 800662e:	bf00      	nop
 8006630:	bd80      	pop	{r7, pc}
 8006632:	bf00      	nop
 8006634:	20000854 	.word	0x20000854

08006638 <I2C1_EV_IRQHandler>:

/**
  * @brief This function handles I2C1 Event interrupt.
  */
void I2C1_EV_IRQHandler(void)
{
 8006638:	b580      	push	{r7, lr}
 800663a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN I2C1_EV_IRQn 0 */

  /* USER CODE END I2C1_EV_IRQn 0 */
  HAL_I2C_EV_IRQHandler(&hi2c1);
 800663c:	4802      	ldr	r0, [pc, #8]	@ (8006648 <I2C1_EV_IRQHandler+0x10>)
 800663e:	f009 febf 	bl	80103c0 <HAL_I2C_EV_IRQHandler>
  /* USER CODE BEGIN I2C1_EV_IRQn 1 */

  /* USER CODE END I2C1_EV_IRQn 1 */
}
 8006642:	bf00      	nop
 8006644:	bd80      	pop	{r7, pc}
 8006646:	bf00      	nop
 8006648:	20000a70 	.word	0x20000a70

0800664c <I2C1_ER_IRQHandler>:

/**
  * @brief This function handles I2C1 Error interrupt.
  */
void I2C1_ER_IRQHandler(void)
{
 800664c:	b580      	push	{r7, lr}
 800664e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN I2C1_ER_IRQn 0 */

  /* USER CODE END I2C1_ER_IRQn 0 */
  HAL_I2C_ER_IRQHandler(&hi2c1);
 8006650:	4802      	ldr	r0, [pc, #8]	@ (800665c <I2C1_ER_IRQHandler+0x10>)
 8006652:	f009 fecf 	bl	80103f4 <HAL_I2C_ER_IRQHandler>
  /* USER CODE BEGIN I2C1_ER_IRQn 1 */

  /* USER CODE END I2C1_ER_IRQn 1 */
}
 8006656:	bf00      	nop
 8006658:	bd80      	pop	{r7, pc}
 800665a:	bf00      	nop
 800665c:	20000a70 	.word	0x20000a70

08006660 <I2C2_EV_IRQHandler>:

/**
  * @brief This function handles I2C2 Event interrupt.
  */
void I2C2_EV_IRQHandler(void)
{
 8006660:	b580      	push	{r7, lr}
 8006662:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN I2C2_EV_IRQn 0 */

  /* USER CODE END I2C2_EV_IRQn 0 */
  HAL_I2C_EV_IRQHandler(&hi2c2);
 8006664:	4802      	ldr	r0, [pc, #8]	@ (8006670 <I2C2_EV_IRQHandler+0x10>)
 8006666:	f009 feab 	bl	80103c0 <HAL_I2C_EV_IRQHandler>
  /* USER CODE BEGIN I2C2_EV_IRQn 1 */

  /* USER CODE END I2C2_EV_IRQn 1 */
}
 800666a:	bf00      	nop
 800666c:	bd80      	pop	{r7, pc}
 800666e:	bf00      	nop
 8006670:	20000938 	.word	0x20000938

08006674 <I2C2_ER_IRQHandler>:

/**
  * @brief This function handles I2C2 Error interrupt.
  */
void I2C2_ER_IRQHandler(void)
{
 8006674:	b580      	push	{r7, lr}
 8006676:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN I2C2_ER_IRQn 0 */

  /* USER CODE END I2C2_ER_IRQn 0 */
  HAL_I2C_ER_IRQHandler(&hi2c2);
 8006678:	4802      	ldr	r0, [pc, #8]	@ (8006684 <I2C2_ER_IRQHandler+0x10>)
 800667a:	f009 febb 	bl	80103f4 <HAL_I2C_ER_IRQHandler>
  /* USER CODE BEGIN I2C2_ER_IRQn 1 */

  /* USER CODE END I2C2_ER_IRQn 1 */
}
 800667e:	bf00      	nop
 8006680:	bd80      	pop	{r7, pc}
 8006682:	bf00      	nop
 8006684:	20000938 	.word	0x20000938

08006688 <SPI2_IRQHandler>:

/**
  * @brief This function handles SPI2 global interrupt.
  */
void SPI2_IRQHandler(void)
{
 8006688:	b580      	push	{r7, lr}
 800668a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SPI2_IRQn 0 */

  /* USER CODE END SPI2_IRQn 0 */
  HAL_SPI_IRQHandler(&hspi2);
 800668c:	4802      	ldr	r0, [pc, #8]	@ (8006698 <SPI2_IRQHandler+0x10>)
 800668e:	f00f fc69 	bl	8015f64 <HAL_SPI_IRQHandler>
  /* USER CODE BEGIN SPI2_IRQn 1 */

  /* USER CODE END SPI2_IRQn 1 */
}
 8006692:	bf00      	nop
 8006694:	bd80      	pop	{r7, pc}
 8006696:	bf00      	nop
 8006698:	200006d4 	.word	0x200006d4

0800669c <I2C4_EV_IRQHandler>:

/**
  * @brief This function handles I2C4 Error interrupt.
  */
void I2C4_EV_IRQHandler(void)
{
 800669c:	b580      	push	{r7, lr}
 800669e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN I2C4_EV_IRQn 0 */

  /* USER CODE END I2C4_EV_IRQn 0 */
  HAL_I2C_EV_IRQHandler(&hi2c4);
 80066a0:	4802      	ldr	r0, [pc, #8]	@ (80066ac <I2C4_EV_IRQHandler+0x10>)
 80066a2:	f009 fe8d 	bl	80103c0 <HAL_I2C_EV_IRQHandler>
  /* USER CODE BEGIN I2C4_EV_IRQn 1 */

  /* USER CODE END I2C4_EV_IRQn 1 */
}
 80066a6:	bf00      	nop
 80066a8:	bd80      	pop	{r7, pc}
 80066aa:	bf00      	nop
 80066ac:	2000098c 	.word	0x2000098c

080066b0 <I2C4_ER_IRQHandler>:

/**
  * @brief This function handles I2C4 Event interrupt.
  */
void I2C4_ER_IRQHandler(void)
{
 80066b0:	b580      	push	{r7, lr}
 80066b2:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN I2C4_ER_IRQn 0 */

  /* USER CODE END I2C4_ER_IRQn 0 */
  HAL_I2C_ER_IRQHandler(&hi2c4);
 80066b4:	4802      	ldr	r0, [pc, #8]	@ (80066c0 <I2C4_ER_IRQHandler+0x10>)
 80066b6:	f009 fe9d 	bl	80103f4 <HAL_I2C_ER_IRQHandler>
  /* USER CODE BEGIN I2C4_ER_IRQn 1 */

  /* USER CODE END I2C4_ER_IRQn 1 */
}
 80066ba:	bf00      	nop
 80066bc:	bd80      	pop	{r7, pc}
 80066be:	bf00      	nop
 80066c0:	2000098c 	.word	0x2000098c

080066c4 <_getpid>:
void initialise_monitor_handles()
{
}

int _getpid(void)
{
 80066c4:	b480      	push	{r7}
 80066c6:	af00      	add	r7, sp, #0
  return 1;
 80066c8:	2301      	movs	r3, #1
}
 80066ca:	4618      	mov	r0, r3
 80066cc:	46bd      	mov	sp, r7
 80066ce:	f85d 7b04 	ldr.w	r7, [sp], #4
 80066d2:	4770      	bx	lr

080066d4 <_kill>:

int _kill(int pid, int sig)
{
 80066d4:	b580      	push	{r7, lr}
 80066d6:	b082      	sub	sp, #8
 80066d8:	af00      	add	r7, sp, #0
 80066da:	6078      	str	r0, [r7, #4]
 80066dc:	6039      	str	r1, [r7, #0]
  (void)pid;
  (void)sig;
  errno = EINVAL;
 80066de:	f01d fd43 	bl	8024168 <__errno>
 80066e2:	4603      	mov	r3, r0
 80066e4:	2216      	movs	r2, #22
 80066e6:	601a      	str	r2, [r3, #0]
  return -1;
 80066e8:	f04f 33ff 	mov.w	r3, #4294967295
}
 80066ec:	4618      	mov	r0, r3
 80066ee:	3708      	adds	r7, #8
 80066f0:	46bd      	mov	sp, r7
 80066f2:	bd80      	pop	{r7, pc}

080066f4 <_exit>:

void _exit (int status)
{
 80066f4:	b580      	push	{r7, lr}
 80066f6:	b082      	sub	sp, #8
 80066f8:	af00      	add	r7, sp, #0
 80066fa:	6078      	str	r0, [r7, #4]
  _kill(status, -1);
 80066fc:	f04f 31ff 	mov.w	r1, #4294967295
 8006700:	6878      	ldr	r0, [r7, #4]
 8006702:	f7ff ffe7 	bl	80066d4 <_kill>
  while (1) {}    /* Make sure we hang here */
 8006706:	e7fe      	b.n	8006706 <_exit+0x12>

08006708 <_read>:
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
 8006708:	b580      	push	{r7, lr}
 800670a:	b086      	sub	sp, #24
 800670c:	af00      	add	r7, sp, #0
 800670e:	60f8      	str	r0, [r7, #12]
 8006710:	60b9      	str	r1, [r7, #8]
 8006712:	607a      	str	r2, [r7, #4]
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
 8006714:	2300      	movs	r3, #0
 8006716:	617b      	str	r3, [r7, #20]
 8006718:	e00a      	b.n	8006730 <_read+0x28>
  {
    *ptr++ = __io_getchar();
 800671a:	f3af 8000 	nop.w
 800671e:	4601      	mov	r1, r0
 8006720:	68bb      	ldr	r3, [r7, #8]
 8006722:	1c5a      	adds	r2, r3, #1
 8006724:	60ba      	str	r2, [r7, #8]
 8006726:	b2ca      	uxtb	r2, r1
 8006728:	701a      	strb	r2, [r3, #0]
  for (DataIdx = 0; DataIdx < len; DataIdx++)
 800672a:	697b      	ldr	r3, [r7, #20]
 800672c:	3301      	adds	r3, #1
 800672e:	617b      	str	r3, [r7, #20]
 8006730:	697a      	ldr	r2, [r7, #20]
 8006732:	687b      	ldr	r3, [r7, #4]
 8006734:	429a      	cmp	r2, r3
 8006736:	dbf0      	blt.n	800671a <_read+0x12>
  }

  return len;
 8006738:	687b      	ldr	r3, [r7, #4]
}
 800673a:	4618      	mov	r0, r3
 800673c:	3718      	adds	r7, #24
 800673e:	46bd      	mov	sp, r7
 8006740:	bd80      	pop	{r7, pc}

08006742 <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
 8006742:	b580      	push	{r7, lr}
 8006744:	b086      	sub	sp, #24
 8006746:	af00      	add	r7, sp, #0
 8006748:	60f8      	str	r0, [r7, #12]
 800674a:	60b9      	str	r1, [r7, #8]
 800674c:	607a      	str	r2, [r7, #4]
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
 800674e:	2300      	movs	r3, #0
 8006750:	617b      	str	r3, [r7, #20]
 8006752:	e009      	b.n	8006768 <_write+0x26>
  {
    __io_putchar(*ptr++);
 8006754:	68bb      	ldr	r3, [r7, #8]
 8006756:	1c5a      	adds	r2, r3, #1
 8006758:	60ba      	str	r2, [r7, #8]
 800675a:	781b      	ldrb	r3, [r3, #0]
 800675c:	4618      	mov	r0, r3
 800675e:	f7fe fe2d 	bl	80053bc <__io_putchar>
  for (DataIdx = 0; DataIdx < len; DataIdx++)
 8006762:	697b      	ldr	r3, [r7, #20]
 8006764:	3301      	adds	r3, #1
 8006766:	617b      	str	r3, [r7, #20]
 8006768:	697a      	ldr	r2, [r7, #20]
 800676a:	687b      	ldr	r3, [r7, #4]
 800676c:	429a      	cmp	r2, r3
 800676e:	dbf1      	blt.n	8006754 <_write+0x12>
  }
  return len;
 8006770:	687b      	ldr	r3, [r7, #4]
}
 8006772:	4618      	mov	r0, r3
 8006774:	3718      	adds	r7, #24
 8006776:	46bd      	mov	sp, r7
 8006778:	bd80      	pop	{r7, pc}

0800677a <_close>:

int _close(int file)
{
 800677a:	b480      	push	{r7}
 800677c:	b083      	sub	sp, #12
 800677e:	af00      	add	r7, sp, #0
 8006780:	6078      	str	r0, [r7, #4]
  (void)file;
  return -1;
 8006782:	f04f 33ff 	mov.w	r3, #4294967295
}
 8006786:	4618      	mov	r0, r3
 8006788:	370c      	adds	r7, #12
 800678a:	46bd      	mov	sp, r7
 800678c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006790:	4770      	bx	lr

08006792 <_fstat>:


int _fstat(int file, struct stat *st)
{
 8006792:	b480      	push	{r7}
 8006794:	b083      	sub	sp, #12
 8006796:	af00      	add	r7, sp, #0
 8006798:	6078      	str	r0, [r7, #4]
 800679a:	6039      	str	r1, [r7, #0]
  (void)file;
  st->st_mode = S_IFCHR;
 800679c:	683b      	ldr	r3, [r7, #0]
 800679e:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
 80067a2:	605a      	str	r2, [r3, #4]
  return 0;
 80067a4:	2300      	movs	r3, #0
}
 80067a6:	4618      	mov	r0, r3
 80067a8:	370c      	adds	r7, #12
 80067aa:	46bd      	mov	sp, r7
 80067ac:	f85d 7b04 	ldr.w	r7, [sp], #4
 80067b0:	4770      	bx	lr

080067b2 <_isatty>:

int _isatty(int file)
{
 80067b2:	b480      	push	{r7}
 80067b4:	b083      	sub	sp, #12
 80067b6:	af00      	add	r7, sp, #0
 80067b8:	6078      	str	r0, [r7, #4]
  (void)file;
  return 1;
 80067ba:	2301      	movs	r3, #1
}
 80067bc:	4618      	mov	r0, r3
 80067be:	370c      	adds	r7, #12
 80067c0:	46bd      	mov	sp, r7
 80067c2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80067c6:	4770      	bx	lr

080067c8 <_lseek>:

int _lseek(int file, int ptr, int dir)
{
 80067c8:	b480      	push	{r7}
 80067ca:	b085      	sub	sp, #20
 80067cc:	af00      	add	r7, sp, #0
 80067ce:	60f8      	str	r0, [r7, #12]
 80067d0:	60b9      	str	r1, [r7, #8]
 80067d2:	607a      	str	r2, [r7, #4]
  (void)file;
  (void)ptr;
  (void)dir;
  return 0;
 80067d4:	2300      	movs	r3, #0
}
 80067d6:	4618      	mov	r0, r3
 80067d8:	3714      	adds	r7, #20
 80067da:	46bd      	mov	sp, r7
 80067dc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80067e0:	4770      	bx	lr
	...

080067e4 <_sbrk>:
 *
 * @param incr Memory size
 * @return Pointer to allocated memory
 */
void *_sbrk(ptrdiff_t incr)
{
 80067e4:	b580      	push	{r7, lr}
 80067e6:	b086      	sub	sp, #24
 80067e8:	af00      	add	r7, sp, #0
 80067ea:	6078      	str	r0, [r7, #4]
  extern uint8_t _end; /* Symbol defined in the linker script */
  extern uint8_t _estack; /* Symbol defined in the linker script */
  extern uint32_t _Min_Stack_Size; /* Symbol defined in the linker script */
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 80067ec:	4a14      	ldr	r2, [pc, #80]	@ (8006840 <_sbrk+0x5c>)
 80067ee:	4b15      	ldr	r3, [pc, #84]	@ (8006844 <_sbrk+0x60>)
 80067f0:	1ad3      	subs	r3, r2, r3
 80067f2:	617b      	str	r3, [r7, #20]
  const uint8_t *max_heap = (uint8_t *)stack_limit;
 80067f4:	697b      	ldr	r3, [r7, #20]
 80067f6:	613b      	str	r3, [r7, #16]
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
 80067f8:	4b13      	ldr	r3, [pc, #76]	@ (8006848 <_sbrk+0x64>)
 80067fa:	681b      	ldr	r3, [r3, #0]
 80067fc:	2b00      	cmp	r3, #0
 80067fe:	d102      	bne.n	8006806 <_sbrk+0x22>
  {
    __sbrk_heap_end = &_end;
 8006800:	4b11      	ldr	r3, [pc, #68]	@ (8006848 <_sbrk+0x64>)
 8006802:	4a12      	ldr	r2, [pc, #72]	@ (800684c <_sbrk+0x68>)
 8006804:	601a      	str	r2, [r3, #0]
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
 8006806:	4b10      	ldr	r3, [pc, #64]	@ (8006848 <_sbrk+0x64>)
 8006808:	681a      	ldr	r2, [r3, #0]
 800680a:	687b      	ldr	r3, [r7, #4]
 800680c:	4413      	add	r3, r2
 800680e:	693a      	ldr	r2, [r7, #16]
 8006810:	429a      	cmp	r2, r3
 8006812:	d207      	bcs.n	8006824 <_sbrk+0x40>
  {
    errno = ENOMEM;
 8006814:	f01d fca8 	bl	8024168 <__errno>
 8006818:	4603      	mov	r3, r0
 800681a:	220c      	movs	r2, #12
 800681c:	601a      	str	r2, [r3, #0]
    return (void *)-1;
 800681e:	f04f 33ff 	mov.w	r3, #4294967295
 8006822:	e009      	b.n	8006838 <_sbrk+0x54>
  }

  prev_heap_end = __sbrk_heap_end;
 8006824:	4b08      	ldr	r3, [pc, #32]	@ (8006848 <_sbrk+0x64>)
 8006826:	681b      	ldr	r3, [r3, #0]
 8006828:	60fb      	str	r3, [r7, #12]
  __sbrk_heap_end += incr;
 800682a:	4b07      	ldr	r3, [pc, #28]	@ (8006848 <_sbrk+0x64>)
 800682c:	681a      	ldr	r2, [r3, #0]
 800682e:	687b      	ldr	r3, [r7, #4]
 8006830:	4413      	add	r3, r2
 8006832:	4a05      	ldr	r2, [pc, #20]	@ (8006848 <_sbrk+0x64>)
 8006834:	6013      	str	r3, [r2, #0]

  return (void *)prev_heap_end;
 8006836:	68fb      	ldr	r3, [r7, #12]
}
 8006838:	4618      	mov	r0, r3
 800683a:	3718      	adds	r7, #24
 800683c:	46bd      	mov	sp, r7
 800683e:	bd80      	pop	{r7, pc}
 8006840:	200c0000 	.word	0x200c0000
 8006844:	00008000 	.word	0x00008000
 8006848:	20000bc4 	.word	0x20000bc4
 800684c:	20001ff0 	.word	0x20001ff0

08006850 <STC3115_Init>:
 * @brief Initializes STC3115 Gas Gauge. Hides low level device and battery details
 * @param None
 * @retval None
 */
static DrvStatusTypeDef STC3115_Init( DrvContextTypeDef* handle )
{
 8006850:	b5b0      	push	{r4, r5, r7, lr}
 8006852:	b098      	sub	sp, #96	@ 0x60
 8006854:	af00      	add	r7, sp, #0
 8006856:	6078      	str	r0, [r7, #4]
  int32_t res, loop;
  int32_t OCVOffset[16] = OCV_OFFSET_TAB;
 8006858:	4b6e      	ldr	r3, [pc, #440]	@ (8006a14 <STC3115_Init+0x1c4>)
 800685a:	f107 040c 	add.w	r4, r7, #12
 800685e:	461d      	mov	r5, r3
 8006860:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8006862:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8006864:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8006866:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8006868:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800686a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 800686c:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 8006870:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
  uint8_t res8;
  
  STC3115_ConfigData_TypeDef *ConfigData = &(( STC3115_Data_t * )(( GG_Data_t * )handle->pData)->pComponentData)->configData;
 8006874:	687b      	ldr	r3, [r7, #4]
 8006876:	689b      	ldr	r3, [r3, #8]
 8006878:	681b      	ldr	r3, [r3, #0]
 800687a:	65bb      	str	r3, [r7, #88]	@ 0x58
  STC3115_BatteryData_TypeDef *BatteryData = &(( STC3115_Data_t * )(( GG_Data_t * )handle->pData)->pComponentData)->batteryData;
 800687c:	687b      	ldr	r3, [r7, #4]
 800687e:	689b      	ldr	r3, [r3, #8]
 8006880:	681b      	ldr	r3, [r3, #0]
 8006882:	3330      	adds	r3, #48	@ 0x30
 8006884:	657b      	str	r3, [r7, #84]	@ 0x54
  RAMData_TypeDef *RAMData = &(( STC3115_Data_t * )(( GG_Data_t * )handle->pData)->pComponentData)->ramData;
 8006886:	687b      	ldr	r3, [r7, #4]
 8006888:	689b      	ldr	r3, [r3, #8]
 800688a:	681b      	ldr	r3, [r3, #0]
 800688c:	335c      	adds	r3, #92	@ 0x5c
 800688e:	653b      	str	r3, [r7, #80]	@ 0x50
  
  /*** Fill configuration structure parameters ***/
  ConfigData->Vmode = VMODE;
 8006890:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8006892:	2200      	movs	r2, #0
 8006894:	601a      	str	r2, [r3, #0]
  
  if(RSENSE != 0)
  {
    ConfigData->Rsense = RSENSE;
 8006896:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8006898:	2232      	movs	r2, #50	@ 0x32
 800689a:	619a      	str	r2, [r3, #24]
  else
  {
    ConfigData->Rsense = 10; // default value to avoid division by 0
  }
  
  ConfigData->CC_cnf = (CAPACITY * ConfigData->Rsense * 250 + 6194) / 12389;
 800689c:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 800689e:	699b      	ldr	r3, [r3, #24]
 80068a0:	4a5d      	ldr	r2, [pc, #372]	@ (8006a18 <STC3115_Init+0x1c8>)
 80068a2:	fb02 f303 	mul.w	r3, r2, r3
 80068a6:	f503 53c1 	add.w	r3, r3, #6176	@ 0x1820
 80068aa:	3312      	adds	r3, #18
 80068ac:	4a5b      	ldr	r2, [pc, #364]	@ (8006a1c <STC3115_Init+0x1cc>)
 80068ae:	fb82 1203 	smull	r1, r2, r2, r3
 80068b2:	1312      	asrs	r2, r2, #12
 80068b4:	17db      	asrs	r3, r3, #31
 80068b6:	1ad2      	subs	r2, r2, r3
 80068b8:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80068ba:	60da      	str	r2, [r3, #12]
  
  if(RINT != 0)
  {
    ConfigData->VM_cnf = (CAPACITY * RINT * 50 + 24444) / 48889;
 80068bc:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80068be:	224f      	movs	r2, #79	@ 0x4f
 80068c0:	611a      	str	r2, [r3, #16]
  else
  {
    ConfigData->VM_cnf = (CAPACITY * 200 * 50 + 24444) / 48889; // default value
  }
  
  for(loop = 0; loop < 16; loop++)
 80068c2:	2300      	movs	r3, #0
 80068c4:	65fb      	str	r3, [r7, #92]	@ 0x5c
 80068c6:	e02f      	b.n	8006928 <STC3115_Init+0xd8>
  {
    if(OCVOffset[loop] > 127)
 80068c8:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80068ca:	009b      	lsls	r3, r3, #2
 80068cc:	3360      	adds	r3, #96	@ 0x60
 80068ce:	443b      	add	r3, r7
 80068d0:	f853 3c54 	ldr.w	r3, [r3, #-84]
 80068d4:	2b7f      	cmp	r3, #127	@ 0x7f
 80068d6:	dd06      	ble.n	80068e6 <STC3115_Init+0x96>
    {
      OCVOffset[loop] = 127;
 80068d8:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80068da:	009b      	lsls	r3, r3, #2
 80068dc:	3360      	adds	r3, #96	@ 0x60
 80068de:	443b      	add	r3, r7
 80068e0:	227f      	movs	r2, #127	@ 0x7f
 80068e2:	f843 2c54 	str.w	r2, [r3, #-84]
    }
    if(OCVOffset[loop] < -127)
 80068e6:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80068e8:	009b      	lsls	r3, r3, #2
 80068ea:	3360      	adds	r3, #96	@ 0x60
 80068ec:	443b      	add	r3, r7
 80068ee:	f853 3c54 	ldr.w	r3, [r3, #-84]
 80068f2:	f113 0f7f 	cmn.w	r3, #127	@ 0x7f
 80068f6:	da07      	bge.n	8006908 <STC3115_Init+0xb8>
    {
      OCVOffset[loop] = -127;
 80068f8:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80068fa:	009b      	lsls	r3, r3, #2
 80068fc:	3360      	adds	r3, #96	@ 0x60
 80068fe:	443b      	add	r3, r7
 8006900:	f06f 027e 	mvn.w	r2, #126	@ 0x7e
 8006904:	f843 2c54 	str.w	r2, [r3, #-84]
    }
    ConfigData->OCVOffset[loop] = OCVOffset[loop];
 8006908:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 800690a:	009b      	lsls	r3, r3, #2
 800690c:	3360      	adds	r3, #96	@ 0x60
 800690e:	443b      	add	r3, r7
 8006910:	f853 3c54 	ldr.w	r3, [r3, #-84]
 8006914:	b2d9      	uxtb	r1, r3
 8006916:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 8006918:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 800691a:	4413      	add	r3, r2
 800691c:	3320      	adds	r3, #32
 800691e:	460a      	mov	r2, r1
 8006920:	701a      	strb	r2, [r3, #0]
  for(loop = 0; loop < 16; loop++)
 8006922:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8006924:	3301      	adds	r3, #1
 8006926:	65fb      	str	r3, [r7, #92]	@ 0x5c
 8006928:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 800692a:	2b0f      	cmp	r3, #15
 800692c:	ddcc      	ble.n	80068c8 <STC3115_Init+0x78>
  }
  
  ConfigData->Cnom = CAPACITY;
 800692e:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8006930:	f44f 72f0 	mov.w	r2, #480	@ 0x1e0
 8006934:	615a      	str	r2, [r3, #20]
  ConfigData->RelaxCurrent = CAPACITY / 20;
 8006936:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8006938:	2218      	movs	r2, #24
 800693a:	61da      	str	r2, [r3, #28]
  
  ConfigData->Alm_SOC = ALM_SOC;
 800693c:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 800693e:	220a      	movs	r2, #10
 8006940:	605a      	str	r2, [r3, #4]
  ConfigData->Alm_Vbat = ALM_VBAT;
 8006942:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8006944:	f640 3222 	movw	r2, #2850	@ 0xb22
 8006948:	609a      	str	r2, [r3, #8]
  
  /*** Initialize Gas Gauge system ***/
  
  /* check STC3115 status */
  res = STC3115_Status(handle);
 800694a:	6878      	ldr	r0, [r7, #4]
 800694c:	f000 fadb 	bl	8006f06 <STC3115_Status>
 8006950:	64f8      	str	r0, [r7, #76]	@ 0x4c
  if(res < 0)
 8006952:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8006954:	2b00      	cmp	r3, #0
 8006956:	da01      	bge.n	800695c <STC3115_Init+0x10c>
  {
    return COMPONENT_ERROR;
 8006958:	2301      	movs	r3, #1
 800695a:	e056      	b.n	8006a0a <STC3115_Init+0x1ba>
  }
    
  /*Battery presence status init*/
  BatteryData->Presence = 1;
 800695c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 800695e:	2201      	movs	r2, #1
 8006960:	621a      	str	r2, [r3, #32]
  
  /* check RAM data validity */
  STC3115_ReadRamData(handle, RAMData->db);
 8006962:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8006964:	4619      	mov	r1, r3
 8006966:	6878      	ldr	r0, [r7, #4]
 8006968:	f000 fb8e 	bl	8007088 <STC3115_ReadRamData>
  /*new driver*/
  if ( (RAMData->reg.TstWord != RAM_TSTWORD) || (STC3115_CalcRamCRC8(RAMData->db,RAM_SIZE)!=0) )
 800696c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800696e:	f9b3 3000 	ldrsh.w	r3, [r3]
 8006972:	f245 32a9 	movw	r2, #21417	@ 0x53a9
 8006976:	4293      	cmp	r3, r2
 8006978:	d107      	bne.n	800698a <STC3115_Init+0x13a>
 800697a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800697c:	2110      	movs	r1, #16
 800697e:	4618      	mov	r0, r3
 8006980:	f000 faf1 	bl	8006f66 <STC3115_CalcRamCRC8>
 8006984:	4603      	mov	r3, r0
 8006986:	2b00      	cmp	r3, #0
 8006988:	d008      	beq.n	800699c <STC3115_Init+0x14c>
  {
    /* RAM invalid */
    STC3115_InitRamData(handle,ConfigData);
 800698a:	6db9      	ldr	r1, [r7, #88]	@ 0x58
 800698c:	6878      	ldr	r0, [r7, #4]
 800698e:	f000 fb38 	bl	8007002 <STC3115_InitRamData>
    res=STC3115_Startup(handle,ConfigData);  /* return -1 if I2C error or STC3115 not present */
 8006992:	6db9      	ldr	r1, [r7, #88]	@ 0x58
 8006994:	6878      	ldr	r0, [r7, #4]
 8006996:	f000 fca5 	bl	80072e4 <STC3115_Startup>
 800699a:	64f8      	str	r0, [r7, #76]	@ 0x4c
  }
  
  HAL_Delay(1200);//to avoid false positive
 800699c:	f44f 6096 	mov.w	r0, #1200	@ 0x4b0
 80069a0:	f7fd ff2c 	bl	80047fc <HAL_Delay>
  STC3115_Read(handle,STC3115_REG_CTRL,&res8,1);
 80069a4:	f107 020b 	add.w	r2, r7, #11
 80069a8:	2301      	movs	r3, #1
 80069aa:	2101      	movs	r1, #1
 80069ac:	6878      	ldr	r0, [r7, #4]
 80069ae:	f000 fccb 	bl	8007348 <STC3115_Read>
  /* check STC3115 status */    
  if ( (res8 & (STC3115_BATFAIL | STC3115_PORDET)) != 0 )
 80069b2:	7afb      	ldrb	r3, [r7, #11]
 80069b4:	f003 0318 	and.w	r3, r3, #24
 80069b8:	2b00      	cmp	r3, #0
 80069ba:	d00a      	beq.n	80069d2 <STC3115_Init+0x182>
  {
    STC3115_Reset(handle);
 80069bc:	6878      	ldr	r0, [r7, #4]
 80069be:	f000 f99f 	bl	8006d00 <STC3115_Reset>
    handle->isInitialized = 1;
 80069c2:	687b      	ldr	r3, [r7, #4]
 80069c4:	2201      	movs	r2, #1
 80069c6:	715a      	strb	r2, [r3, #5]
    BatteryData->Presence = 0;
 80069c8:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80069ca:	2200      	movs	r2, #0
 80069cc:	621a      	str	r2, [r3, #32]
    return COMPONENT_BATT_FAIL ; //no battery
 80069ce:	2304      	movs	r3, #4
 80069d0:	e01b      	b.n	8006a0a <STC3115_Init+0x1ba>
  } else {        
     res=STC3115_Startup(handle,ConfigData);  /* return -1 if I2C error or STC3115 not present */
 80069d2:	6db9      	ldr	r1, [r7, #88]	@ 0x58
 80069d4:	6878      	ldr	r0, [r7, #4]
 80069d6:	f000 fc85 	bl	80072e4 <STC3115_Startup>
 80069da:	64f8      	str	r0, [r7, #76]	@ 0x4c
  }
  
  if(res<0)
 80069dc:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80069de:	2b00      	cmp	r3, #0
 80069e0:	da04      	bge.n	80069ec <STC3115_Init+0x19c>
  { 
    handle->isInitialized = 0; 
 80069e2:	687b      	ldr	r3, [r7, #4]
 80069e4:	2200      	movs	r2, #0
 80069e6:	715a      	strb	r2, [r3, #5]
    return COMPONENT_ERROR;
 80069e8:	2301      	movs	r3, #1
 80069ea:	e00e      	b.n	8006a0a <STC3115_Init+0x1ba>
  }
  //Update RAM status
  RAMData->reg.STC3115_Status = STC3115_INIT;
 80069ec:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80069ee:	2249      	movs	r2, #73	@ 0x49
 80069f0:	725a      	strb	r2, [r3, #9]
  STC3115_UpdateRamCRC(handle);
 80069f2:	6878      	ldr	r0, [r7, #4]
 80069f4:	f000 faed 	bl	8006fd2 <STC3115_UpdateRamCRC>
  STC3115_WriteRamData(handle,RAMData->db);
 80069f8:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80069fa:	4619      	mov	r1, r3
 80069fc:	6878      	ldr	r0, [r7, #4]
 80069fe:	f000 fb2d 	bl	800705c <STC3115_WriteRamData>
  handle->isInitialized = 1;
 8006a02:	687b      	ldr	r3, [r7, #4]
 8006a04:	2201      	movs	r2, #1
 8006a06:	715a      	strb	r2, [r3, #5]
  
  return COMPONENT_OK;
 8006a08:	2300      	movs	r3, #0

}
 8006a0a:	4618      	mov	r0, r3
 8006a0c:	3760      	adds	r7, #96	@ 0x60
 8006a0e:	46bd      	mov	sp, r7
 8006a10:	bdb0      	pop	{r4, r5, r7, pc}
 8006a12:	bf00      	nop
 8006a14:	08027e54 	.word	0x08027e54
 8006a18:	0001d4c0 	.word	0x0001d4c0
 8006a1c:	54a33dd9 	.word	0x54a33dd9

08006a20 <STC3115_DeInit>:
 * @param handle the device handle
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef STC3115_DeInit( DrvContextTypeDef *handle )
{
 8006a20:	b480      	push	{r7}
 8006a22:	b083      	sub	sp, #12
 8006a24:	af00      	add	r7, sp, #0
 8006a26:	6078      	str	r0, [r7, #4]
  handle->isInitialized = 0;
 8006a28:	687b      	ldr	r3, [r7, #4]
 8006a2a:	2200      	movs	r2, #0
 8006a2c:	715a      	strb	r2, [r3, #5]

  return COMPONENT_OK;
 8006a2e:	2300      	movs	r3, #0
}
 8006a30:	4618      	mov	r0, r3
 8006a32:	370c      	adds	r7, #12
 8006a34:	46bd      	mov	sp, r7
 8006a36:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006a3a:	4770      	bx	lr

08006a3c <STC3115_Get_WhoAmI>:
 * @param who_am_i pointer to the value of WHO_AM_I register
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef STC3115_Get_WhoAmI( DrvContextTypeDef *handle, uint8_t *who_am_i )
{
 8006a3c:	b580      	push	{r7, lr}
 8006a3e:	b082      	sub	sp, #8
 8006a40:	af00      	add	r7, sp, #0
 8006a42:	6078      	str	r0, [r7, #4]
 8006a44:	6039      	str	r1, [r7, #0]
  if (STC3115_Read(handle, STC3115_REG_ID, who_am_i, 1) == 0)
 8006a46:	2301      	movs	r3, #1
 8006a48:	683a      	ldr	r2, [r7, #0]
 8006a4a:	2118      	movs	r1, #24
 8006a4c:	6878      	ldr	r0, [r7, #4]
 8006a4e:	f000 fc7b 	bl	8007348 <STC3115_Read>
 8006a52:	4603      	mov	r3, r0
 8006a54:	2b00      	cmp	r3, #0
 8006a56:	d101      	bne.n	8006a5c <STC3115_Get_WhoAmI+0x20>
  {
    return COMPONENT_OK;
 8006a58:	2300      	movs	r3, #0
 8006a5a:	e000      	b.n	8006a5e <STC3115_Get_WhoAmI+0x22>
  }
  else
  {
    return COMPONENT_ERROR;
 8006a5c:	2301      	movs	r3, #1
  }
}
 8006a5e:	4618      	mov	r0, r3
 8006a60:	3708      	adds	r7, #8
 8006a62:	46bd      	mov	sp, r7
 8006a64:	bd80      	pop	{r7, pc}
	...

08006a68 <STC3115_Task>:
 * @brief Task function for STC3115 Gas Gauge. Hides low level device and battery details
 * @param None
 * @retval Same as GasGauge_Task
 */
static DrvStatusTypeDef STC3115_Task( DrvContextTypeDef* handle, uint8_t *vm_mode)
{
 8006a68:	b580      	push	{r7, lr}
 8006a6a:	b086      	sub	sp, #24
 8006a6c:	af00      	add	r7, sp, #0
 8006a6e:	6078      	str	r0, [r7, #4]
 8006a70:	6039      	str	r1, [r7, #0]
  int res;

  STC3115_ConfigData_TypeDef *ConfigData = &(( STC3115_Data_t * )(( GG_Data_t * )handle->pData)->pComponentData)->configData;
 8006a72:	687b      	ldr	r3, [r7, #4]
 8006a74:	689b      	ldr	r3, [r3, #8]
 8006a76:	681b      	ldr	r3, [r3, #0]
 8006a78:	617b      	str	r3, [r7, #20]
  STC3115_BatteryData_TypeDef *BatteryData = &(( STC3115_Data_t * )(( GG_Data_t * )handle->pData)->pComponentData)->batteryData;
 8006a7a:	687b      	ldr	r3, [r7, #4]
 8006a7c:	689b      	ldr	r3, [r3, #8]
 8006a7e:	681b      	ldr	r3, [r3, #0]
 8006a80:	3330      	adds	r3, #48	@ 0x30
 8006a82:	613b      	str	r3, [r7, #16]
  RAMData_TypeDef *RAMData = &(( STC3115_Data_t * )(( GG_Data_t * )handle->pData)->pComponentData)->ramData;
 8006a84:	687b      	ldr	r3, [r7, #4]
 8006a86:	689b      	ldr	r3, [r3, #8]
 8006a88:	681b      	ldr	r3, [r3, #0]
 8006a8a:	335c      	adds	r3, #92	@ 0x5c
 8006a8c:	60fb      	str	r3, [r7, #12]
  
  /* ----------------------------- System state verification ---------------------------- */
  /*Read STC3115 status registers */
  res = STC3115_Status(handle);
 8006a8e:	6878      	ldr	r0, [r7, #4]
 8006a90:	f000 fa39 	bl	8006f06 <STC3115_Status>
 8006a94:	60b8      	str	r0, [r7, #8]
  
  if (res < 0) return(COMPONENT_ERROR); /* return if I2C error or STC3115 not responding */
 8006a96:	68bb      	ldr	r3, [r7, #8]
 8006a98:	2b00      	cmp	r3, #0
 8006a9a:	da01      	bge.n	8006aa0 <STC3115_Task+0x38>
 8006a9c:	2301      	movs	r3, #1
 8006a9e:	e122      	b.n	8006ce6 <STC3115_Task+0x27e>
  BatteryData->status = res;
 8006aa0:	693b      	ldr	r3, [r7, #16]
 8006aa2:	68ba      	ldr	r2, [r7, #8]
 8006aa4:	601a      	str	r2, [r3, #0]
  
  /* check STC3115 RAM status (battery has not been changed) */
  STC3115_ReadRamData(handle, RAMData->db);
 8006aa6:	68fb      	ldr	r3, [r7, #12]
 8006aa8:	4619      	mov	r1, r3
 8006aaa:	6878      	ldr	r0, [r7, #4]
 8006aac:	f000 faec 	bl	8007088 <STC3115_ReadRamData>
  if ( (RAMData->reg.TstWord != RAM_TSTWORD) || (STC3115_CalcRamCRC8(RAMData->db, RAM_SIZE) != 0) )
 8006ab0:	68fb      	ldr	r3, [r7, #12]
 8006ab2:	f9b3 3000 	ldrsh.w	r3, [r3]
 8006ab6:	f245 32a9 	movw	r2, #21417	@ 0x53a9
 8006aba:	4293      	cmp	r3, r2
 8006abc:	d107      	bne.n	8006ace <STC3115_Task+0x66>
 8006abe:	68fb      	ldr	r3, [r7, #12]
 8006ac0:	2110      	movs	r1, #16
 8006ac2:	4618      	mov	r0, r3
 8006ac4:	f000 fa4f 	bl	8006f66 <STC3115_CalcRamCRC8>
 8006ac8:	4603      	mov	r3, r0
 8006aca:	2b00      	cmp	r3, #0
 8006acc:	d006      	beq.n	8006adc <STC3115_Task+0x74>
  {
    /* if RAM non ok, reset it and set init state */
    STC3115_InitRamData(handle, ConfigData);
 8006ace:	6979      	ldr	r1, [r7, #20]
 8006ad0:	6878      	ldr	r0, [r7, #4]
 8006ad2:	f000 fa96 	bl	8007002 <STC3115_InitRamData>
    RAMData->reg.STC3115_Status = STC3115_INIT;
 8006ad6:	68fb      	ldr	r3, [r7, #12]
 8006ad8:	2249      	movs	r2, #73	@ 0x49
 8006ada:	725a      	strb	r2, [r3, #9]
  }
  
  /* check battery presence status */
  if ((BatteryData->status & (STC3115_BATFAIL << 8)) != 0)
 8006adc:	693b      	ldr	r3, [r7, #16]
 8006ade:	681b      	ldr	r3, [r3, #0]
 8006ae0:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 8006ae4:	2b00      	cmp	r3, #0
 8006ae6:	d007      	beq.n	8006af8 <STC3115_Task+0x90>
  {
    /*Battery disconnection has been detected     */
    
    /*BATD pin level is over 1.61 or Vcc is below 2.7V  */
    BatteryData->Presence = 0;
 8006ae8:	693b      	ldr	r3, [r7, #16]
 8006aea:	2200      	movs	r2, #0
 8006aec:	621a      	str	r2, [r3, #32]
    
    /*HW and SW state machine reset*/
    STC3115_Reset(handle);
 8006aee:	6878      	ldr	r0, [r7, #4]
 8006af0:	f000 f906 	bl	8006d00 <STC3115_Reset>
    
    return (COMPONENT_ERROR);
 8006af4:	2301      	movs	r3, #1
 8006af6:	e0f6      	b.n	8006ce6 <STC3115_Task+0x27e>
  }
  
  /* check STC3115 running mode*/
  if ((BatteryData->status & STC3115_GG_RUN) == 0)
 8006af8:	693b      	ldr	r3, [r7, #16]
 8006afa:	681b      	ldr	r3, [r3, #0]
 8006afc:	f003 0310 	and.w	r3, r3, #16
 8006b00:	2b00      	cmp	r3, #0
 8006b02:	d10f      	bne.n	8006b24 <STC3115_Task+0xbc>
  {
    if(RAMData->reg.STC3115_Status == (STC3115_RUNNING | STC3115_POWERDN))
 8006b04:	68fb      	ldr	r3, [r7, #12]
 8006b06:	7a5b      	ldrb	r3, [r3, #9]
 8006b08:	2b56      	cmp	r3, #86	@ 0x56
 8006b0a:	d104      	bne.n	8006b16 <STC3115_Task+0xae>
    {
      STC3115_Restore(handle, ConfigData);  /* if RUNNING state, restore STC3115*/
 8006b0c:	6979      	ldr	r1, [r7, #20]
 8006b0e:	6878      	ldr	r0, [r7, #4]
 8006b10:	f000 fb7b 	bl	800720a <STC3115_Restore>
 8006b14:	e003      	b.n	8006b1e <STC3115_Task+0xb6>
    }
    else
    {
      STC3115_Startup(handle, ConfigData);  /* if INIT state, initialize STC3115*/
 8006b16:	6979      	ldr	r1, [r7, #20]
 8006b18:	6878      	ldr	r0, [r7, #4]
 8006b1a:	f000 fbe3 	bl	80072e4 <STC3115_Startup>
    }
    
    RAMData->reg.STC3115_Status = STC3115_INIT;
 8006b1e:	68fb      	ldr	r3, [r7, #12]
 8006b20:	2249      	movs	r2, #73	@ 0x49
 8006b22:	725a      	strb	r2, [r3, #9]
  }
  
  /* --------------------------------- Read battery data ------------------------------- */
  
  res = STC3115_ReadBatteryData(handle, BatteryData);
 8006b24:	6939      	ldr	r1, [r7, #16]
 8006b26:	6878      	ldr	r0, [r7, #4]
 8006b28:	f000 fac4 	bl	80070b4 <STC3115_ReadBatteryData>
 8006b2c:	60b8      	str	r0, [r7, #8]
  if (res != 0) return(COMPONENT_ERROR); /* abort in case of I2C failure */
 8006b2e:	68bb      	ldr	r3, [r7, #8]
 8006b30:	2b00      	cmp	r3, #0
 8006b32:	d001      	beq.n	8006b38 <STC3115_Task+0xd0>
 8006b34:	2301      	movs	r3, #1
 8006b36:	e0d6      	b.n	8006ce6 <STC3115_Task+0x27e>
  
  
  /* ------------------------------- battery data report ------------------------------- */
  /* check INIT state */
  if (RAMData->reg.STC3115_Status == STC3115_INIT)
 8006b38:	68fb      	ldr	r3, [r7, #12]
 8006b3a:	7a5b      	ldrb	r3, [r3, #9]
 8006b3c:	2b49      	cmp	r3, #73	@ 0x49
 8006b3e:	d109      	bne.n	8006b54 <STC3115_Task+0xec>
  {
    /* INIT state, wait for current & temperature value available: */
    if (BatteryData->ConvCounter > VCOUNT)
 8006b40:	693b      	ldr	r3, [r7, #16]
 8006b42:	699b      	ldr	r3, [r3, #24]
 8006b44:	2b04      	cmp	r3, #4
 8006b46:	dd05      	ble.n	8006b54 <STC3115_Task+0xec>
    {
      RAMData->reg.STC3115_Status = STC3115_RUNNING;
 8006b48:	68fb      	ldr	r3, [r7, #12]
 8006b4a:	2252      	movs	r2, #82	@ 0x52
 8006b4c:	725a      	strb	r2, [r3, #9]
      /*Battery is connected*/
      BatteryData->Presence = 1;
 8006b4e:	693b      	ldr	r3, [r7, #16]
 8006b50:	2201      	movs	r2, #1
 8006b52:	621a      	str	r2, [r3, #32]
    }
  }
  
  if (RAMData->reg.STC3115_Status != STC3115_RUNNING)   /* not running : data partially availalble*/
 8006b54:	68fb      	ldr	r3, [r7, #12]
 8006b56:	7a5b      	ldrb	r3, [r3, #9]
 8006b58:	2b52      	cmp	r3, #82	@ 0x52
 8006b5a:	d018      	beq.n	8006b8e <STC3115_Task+0x126>
  {
    BatteryData->ChargeValue = ConfigData->Cnom * BatteryData->SOC / MAX_SOC;
 8006b5c:	697b      	ldr	r3, [r7, #20]
 8006b5e:	695b      	ldr	r3, [r3, #20]
 8006b60:	693a      	ldr	r2, [r7, #16]
 8006b62:	6892      	ldr	r2, [r2, #8]
 8006b64:	fb02 f303 	mul.w	r3, r2, r3
 8006b68:	4a61      	ldr	r2, [pc, #388]	@ (8006cf0 <STC3115_Task+0x288>)
 8006b6a:	fb82 1203 	smull	r1, r2, r2, r3
 8006b6e:	1192      	asrs	r2, r2, #6
 8006b70:	17db      	asrs	r3, r3, #31
 8006b72:	1ad2      	subs	r2, r2, r3
 8006b74:	693b      	ldr	r3, [r7, #16]
 8006b76:	625a      	str	r2, [r3, #36]	@ 0x24
    BatteryData->Current = 0;
 8006b78:	693b      	ldr	r3, [r7, #16]
 8006b7a:	2200      	movs	r2, #0
 8006b7c:	611a      	str	r2, [r3, #16]
    BatteryData->Temperature = 250;
 8006b7e:	693b      	ldr	r3, [r7, #16]
 8006b80:	22fa      	movs	r2, #250	@ 0xfa
 8006b82:	615a      	str	r2, [r3, #20]
    BatteryData->RemTime = -1;
 8006b84:	693b      	ldr	r3, [r7, #16]
 8006b86:	f04f 32ff 	mov.w	r2, #4294967295
 8006b8a:	629a      	str	r2, [r3, #40]	@ 0x28
 8006b8c:	e080      	b.n	8006c90 <STC3115_Task+0x228>
  {
  
    /* ---------- process SW algorithms -------- */
    
    /*early empty compensation*/
    if (BatteryData->Voltage < APP_CUTOFF_VOLTAGE)
 8006b8e:	693b      	ldr	r3, [r7, #16]
 8006b90:	68db      	ldr	r3, [r3, #12]
 8006b92:	f640 32b7 	movw	r2, #2999	@ 0xbb7
 8006b96:	4293      	cmp	r3, r2
 8006b98:	dc03      	bgt.n	8006ba2 <STC3115_Task+0x13a>
      BatteryData->SOC = 0;
 8006b9a:	693b      	ldr	r3, [r7, #16]
 8006b9c:	2200      	movs	r2, #0
 8006b9e:	609a      	str	r2, [r3, #8]
 8006ba0:	e014      	b.n	8006bcc <STC3115_Task+0x164>
    else if (BatteryData->Voltage < (APP_CUTOFF_VOLTAGE + 200))
 8006ba2:	693b      	ldr	r3, [r7, #16]
 8006ba4:	68db      	ldr	r3, [r3, #12]
 8006ba6:	f5b3 6f48 	cmp.w	r3, #3200	@ 0xc80
 8006baa:	da0f      	bge.n	8006bcc <STC3115_Task+0x164>
      BatteryData->SOC = BatteryData->SOC * (BatteryData->Voltage - APP_CUTOFF_VOLTAGE) / 200;
 8006bac:	693b      	ldr	r3, [r7, #16]
 8006bae:	689b      	ldr	r3, [r3, #8]
 8006bb0:	693a      	ldr	r2, [r7, #16]
 8006bb2:	68d2      	ldr	r2, [r2, #12]
 8006bb4:	f6a2 32b8 	subw	r2, r2, #3000	@ 0xbb8
 8006bb8:	fb02 f303 	mul.w	r3, r2, r3
 8006bbc:	4a4d      	ldr	r2, [pc, #308]	@ (8006cf4 <STC3115_Task+0x28c>)
 8006bbe:	fb82 1203 	smull	r1, r2, r2, r3
 8006bc2:	1192      	asrs	r2, r2, #6
 8006bc4:	17db      	asrs	r3, r3, #31
 8006bc6:	1ad2      	subs	r2, r2, r3
 8006bc8:	693b      	ldr	r3, [r7, #16]
 8006bca:	609a      	str	r2, [r3, #8]
      
    /* Battery charge value calculation */
    
    BatteryData->ChargeValue = ConfigData->Cnom * BatteryData->SOC / MAX_SOC;
 8006bcc:	697b      	ldr	r3, [r7, #20]
 8006bce:	695b      	ldr	r3, [r3, #20]
 8006bd0:	693a      	ldr	r2, [r7, #16]
 8006bd2:	6892      	ldr	r2, [r2, #8]
 8006bd4:	fb02 f303 	mul.w	r3, r2, r3
 8006bd8:	4a45      	ldr	r2, [pc, #276]	@ (8006cf0 <STC3115_Task+0x288>)
 8006bda:	fb82 1203 	smull	r1, r2, r2, r3
 8006bde:	1192      	asrs	r2, r2, #6
 8006be0:	17db      	asrs	r3, r3, #31
 8006be2:	1ad2      	subs	r2, r2, r3
 8006be4:	693b      	ldr	r3, [r7, #16]
 8006be6:	625a      	str	r2, [r3, #36]	@ 0x24
    
    if ((BatteryData->status & STC3115_VMODE) == 0) /* mixed mode only*/
 8006be8:	693b      	ldr	r3, [r7, #16]
 8006bea:	681b      	ldr	r3, [r3, #0]
 8006bec:	f003 0301 	and.w	r3, r3, #1
 8006bf0:	2b00      	cmp	r3, #0
 8006bf2:	d136      	bne.n	8006c62 <STC3115_Task+0x1fa>
    {
    
      /*Lately fully compensation*/
      if ((BatteryData->status & STC3115_VMODE) == 0) /*running in mixed mode*/
 8006bf4:	693b      	ldr	r3, [r7, #16]
 8006bf6:	681b      	ldr	r3, [r3, #0]
 8006bf8:	f003 0301 	and.w	r3, r3, #1
 8006bfc:	2b00      	cmp	r3, #0
 8006bfe:	d113      	bne.n	8006c28 <STC3115_Task+0x1c0>
      {
      
        if(BatteryData->Current > APP_EOC_CURRENT && BatteryData->SOC > 990)
 8006c00:	693b      	ldr	r3, [r7, #16]
 8006c02:	691b      	ldr	r3, [r3, #16]
 8006c04:	2b0e      	cmp	r3, #14
 8006c06:	dd0f      	ble.n	8006c28 <STC3115_Task+0x1c0>
 8006c08:	693b      	ldr	r3, [r7, #16]
 8006c0a:	689b      	ldr	r3, [r3, #8]
 8006c0c:	f240 32de 	movw	r2, #990	@ 0x3de
 8006c10:	4293      	cmp	r3, r2
 8006c12:	dd09      	ble.n	8006c28 <STC3115_Task+0x1c0>
        {
          BatteryData->SOC = 990;
 8006c14:	693b      	ldr	r3, [r7, #16]
 8006c16:	f240 32de 	movw	r2, #990	@ 0x3de
 8006c1a:	609a      	str	r2, [r3, #8]
          STC3115_WriteWord(handle, STC3115_REG_SOC, 50688);  /* 99% */
 8006c1c:	f44f 4246 	mov.w	r2, #50688	@ 0xc600
 8006c20:	2102      	movs	r1, #2
 8006c22:	6878      	ldr	r0, [r7, #4]
 8006c24:	f000 fbe3 	bl	80073ee <STC3115_WriteWord>
        }
      }
      
      /*Remaining time calculation*/
      if(BatteryData->Current < 0)
 8006c28:	693b      	ldr	r3, [r7, #16]
 8006c2a:	691b      	ldr	r3, [r3, #16]
 8006c2c:	2b00      	cmp	r3, #0
 8006c2e:	da13      	bge.n	8006c58 <STC3115_Task+0x1f0>
      {
        BatteryData->RemTime = (BatteryData->ChargeValue * CAPACITY * 6)/(-BatteryData->Current);                          //driver sensortile
 8006c30:	693b      	ldr	r3, [r7, #16]
 8006c32:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8006c34:	4a30      	ldr	r2, [pc, #192]	@ (8006cf8 <STC3115_Task+0x290>)
 8006c36:	fb03 f202 	mul.w	r2, r3, r2
 8006c3a:	693b      	ldr	r3, [r7, #16]
 8006c3c:	691b      	ldr	r3, [r3, #16]
 8006c3e:	fb92 f2f3 	sdiv	r2, r2, r3
 8006c42:	693b      	ldr	r3, [r7, #16]
 8006c44:	629a      	str	r2, [r3, #40]	@ 0x28
//        BatteryData->RemTime = (BatteryData->RemTime * 4 + BatteryData->ChargeValue / BatteryData->Current * 60 ) / 5;  //? new driver
        if(BatteryData->RemTime  < 0)
 8006c46:	693b      	ldr	r3, [r7, #16]
 8006c48:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8006c4a:	2b00      	cmp	r3, #0
 8006c4c:	da10      	bge.n	8006c70 <STC3115_Task+0x208>
          BatteryData->RemTime = -1; /* means no estimated time available */
 8006c4e:	693b      	ldr	r3, [r7, #16]
 8006c50:	f04f 32ff 	mov.w	r2, #4294967295
 8006c54:	629a      	str	r2, [r3, #40]	@ 0x28
 8006c56:	e00b      	b.n	8006c70 <STC3115_Task+0x208>
      }
      else
        BatteryData->RemTime = -1; /* means no estimated time available */
 8006c58:	693b      	ldr	r3, [r7, #16]
 8006c5a:	f04f 32ff 	mov.w	r2, #4294967295
 8006c5e:	629a      	str	r2, [r3, #40]	@ 0x28
 8006c60:	e006      	b.n	8006c70 <STC3115_Task+0x208>
        
    }
    else /* voltage mode only */
    {
      BatteryData->Current = 0;
 8006c62:	693b      	ldr	r3, [r7, #16]
 8006c64:	2200      	movs	r2, #0
 8006c66:	611a      	str	r2, [r3, #16]
      BatteryData->RemTime = -1;
 8006c68:	693b      	ldr	r3, [r7, #16]
 8006c6a:	f04f 32ff 	mov.w	r2, #4294967295
 8006c6e:	629a      	str	r2, [r3, #40]	@ 0x28
    }
    
    //SOC min/max clamping
    if(BatteryData->SOC > 1000) BatteryData->SOC = MAX_SOC;
 8006c70:	693b      	ldr	r3, [r7, #16]
 8006c72:	689b      	ldr	r3, [r3, #8]
 8006c74:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 8006c78:	dd03      	ble.n	8006c82 <STC3115_Task+0x21a>
 8006c7a:	693b      	ldr	r3, [r7, #16]
 8006c7c:	f44f 727a 	mov.w	r2, #1000	@ 0x3e8
 8006c80:	609a      	str	r2, [r3, #8]
    if(BatteryData->SOC < 0) BatteryData->SOC = 0;
 8006c82:	693b      	ldr	r3, [r7, #16]
 8006c84:	689b      	ldr	r3, [r3, #8]
 8006c86:	2b00      	cmp	r3, #0
 8006c88:	da02      	bge.n	8006c90 <STC3115_Task+0x228>
 8006c8a:	693b      	ldr	r3, [r7, #16]
 8006c8c:	2200      	movs	r2, #0
 8006c8e:	609a      	str	r2, [r3, #8]
    
  }
  /* save SOC */
  RAMData->reg.HRSOC = BatteryData->HRSOC;
 8006c90:	693b      	ldr	r3, [r7, #16]
 8006c92:	685b      	ldr	r3, [r3, #4]
 8006c94:	b21a      	sxth	r2, r3
 8006c96:	68fb      	ldr	r3, [r7, #12]
 8006c98:	805a      	strh	r2, [r3, #2]
  RAMData->reg.SOC = (BatteryData->SOC + 5) / 10;
 8006c9a:	693b      	ldr	r3, [r7, #16]
 8006c9c:	689b      	ldr	r3, [r3, #8]
 8006c9e:	3305      	adds	r3, #5
 8006ca0:	4a16      	ldr	r2, [pc, #88]	@ (8006cfc <STC3115_Task+0x294>)
 8006ca2:	fb82 1203 	smull	r1, r2, r2, r3
 8006ca6:	1092      	asrs	r2, r2, #2
 8006ca8:	17db      	asrs	r3, r3, #31
 8006caa:	1ad3      	subs	r3, r2, r3
 8006cac:	b2da      	uxtb	r2, r3
 8006cae:	68fb      	ldr	r3, [r7, #12]
 8006cb0:	721a      	strb	r2, [r3, #8]
  STC3115_UpdateRamCRC(handle);
 8006cb2:	6878      	ldr	r0, [r7, #4]
 8006cb4:	f000 f98d 	bl	8006fd2 <STC3115_UpdateRamCRC>
  STC3115_WriteRamData(handle, RAMData->db);
 8006cb8:	68fb      	ldr	r3, [r7, #12]
 8006cba:	4619      	mov	r1, r3
 8006cbc:	6878      	ldr	r0, [r7, #4]
 8006cbe:	f000 f9cd 	bl	800705c <STC3115_WriteRamData>
  
  if (RAMData->reg.STC3115_Status == STC3115_RUNNING)
 8006cc2:	68fb      	ldr	r3, [r7, #12]
 8006cc4:	7a5b      	ldrb	r3, [r3, #9]
 8006cc6:	2b52      	cmp	r3, #82	@ 0x52
 8006cc8:	d10c      	bne.n	8006ce4 <STC3115_Task+0x27c>
  {
    if((BatteryData->status & (STC3115_GG_VM << 8)) == 0)
 8006cca:	693b      	ldr	r3, [r7, #16]
 8006ccc:	681b      	ldr	r3, [r3, #0]
 8006cce:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8006cd2:	2b00      	cmp	r3, #0
 8006cd4:	d103      	bne.n	8006cde <STC3115_Task+0x276>
      *vm_mode=MIXED_MODE; //return(2); // Coulomb counter mode
 8006cd6:	683b      	ldr	r3, [r7, #0]
 8006cd8:	2200      	movs	r2, #0
 8006cda:	701a      	strb	r2, [r3, #0]
 8006cdc:	e002      	b.n	8006ce4 <STC3115_Task+0x27c>
    else
      *vm_mode=VM_MODE; //return(1); // Voltage mode
 8006cde:	683b      	ldr	r3, [r7, #0]
 8006ce0:	2201      	movs	r2, #1
 8006ce2:	701a      	strb	r2, [r3, #0]
  }
  return COMPONENT_OK;
 8006ce4:	2300      	movs	r3, #0
}
 8006ce6:	4618      	mov	r0, r3
 8006ce8:	3718      	adds	r7, #24
 8006cea:	46bd      	mov	sp, r7
 8006cec:	bd80      	pop	{r7, pc}
 8006cee:	bf00      	nop
 8006cf0:	10624dd3 	.word	0x10624dd3
 8006cf4:	51eb851f 	.word	0x51eb851f
 8006cf8:	fffff4c0 	.word	0xfffff4c0
 8006cfc:	66666667 	.word	0x66666667

08006d00 <STC3115_Reset>:
 * @brief Resets Gas Gauge
 * @param None
 * @retval None
 */
static DrvStatusTypeDef STC3115_Reset(DrvContextTypeDef* handle)
{
 8006d00:	b580      	push	{r7, lr}
 8006d02:	b086      	sub	sp, #24
 8006d04:	af00      	add	r7, sp, #0
 8006d06:	6078      	str	r0, [r7, #4]
  int res;
  RAMData_TypeDef *RAMData = &(( STC3115_Data_t * )(( GG_Data_t * )handle->pData)->pComponentData)->ramData;
 8006d08:	687b      	ldr	r3, [r7, #4]
 8006d0a:	689b      	ldr	r3, [r3, #8]
 8006d0c:	681b      	ldr	r3, [r3, #0]
 8006d0e:	335c      	adds	r3, #92	@ 0x5c
 8006d10:	617b      	str	r3, [r7, #20]
  
  /* reset RAM */
  RAMData->reg.TstWord = 0;
 8006d12:	697b      	ldr	r3, [r7, #20]
 8006d14:	2200      	movs	r2, #0
 8006d16:	801a      	strh	r2, [r3, #0]
  RAMData->reg.STC3115_Status = 0;
 8006d18:	697b      	ldr	r3, [r7, #20]
 8006d1a:	2200      	movs	r2, #0
 8006d1c:	725a      	strb	r2, [r3, #9]
  res = STC3115_WriteRamData(handle, RAMData->db);
 8006d1e:	697b      	ldr	r3, [r7, #20]
 8006d20:	4619      	mov	r1, r3
 8006d22:	6878      	ldr	r0, [r7, #4]
 8006d24:	f000 f99a 	bl	800705c <STC3115_WriteRamData>
 8006d28:	6138      	str	r0, [r7, #16]
  if(res != OK) return COMPONENT_ERROR;
 8006d2a:	693b      	ldr	r3, [r7, #16]
 8006d2c:	2b00      	cmp	r3, #0
 8006d2e:	d001      	beq.n	8006d34 <STC3115_Reset+0x34>
 8006d30:	2301      	movs	r3, #1
 8006d32:	e00a      	b.n	8006d4a <STC3115_Reset+0x4a>
  /* reset STC3115*/
  uint8_t data = STC3115_PORDET;
 8006d34:	2310      	movs	r3, #16
 8006d36:	73fb      	strb	r3, [r7, #15]
  res = STC3115_Write(handle, STC3115_REG_CTRL, &data, 1);  /*   set soft POR */
 8006d38:	f107 020f 	add.w	r2, r7, #15
 8006d3c:	2301      	movs	r3, #1
 8006d3e:	2101      	movs	r1, #1
 8006d40:	6878      	ldr	r0, [r7, #4]
 8006d42:	f000 fb1c 	bl	800737e <STC3115_Write>
 8006d46:	6138      	str	r0, [r7, #16]
  
  return COMPONENT_OK;
 8006d48:	2300      	movs	r3, #0
}
 8006d4a:	4618      	mov	r0, r3
 8006d4c:	3718      	adds	r7, #24
 8006d4e:	46bd      	mov	sp, r7
 8006d50:	bd80      	pop	{r7, pc}

08006d52 <STC3115_Stop>:
 * @brief Stops Gas Gauge
 * @param None
 * @retval Same as GasGauge_Stop
 */
static DrvStatusTypeDef STC3115_Stop(DrvContextTypeDef* handle)
{
 8006d52:	b580      	push	{r7, lr}
 8006d54:	b084      	sub	sp, #16
 8006d56:	af00      	add	r7, sp, #0
 8006d58:	6078      	str	r0, [r7, #4]
  int res;
  RAMData_TypeDef *RAMData = &(( STC3115_Data_t * )(( GG_Data_t * )handle->pData)->pComponentData)->ramData;
 8006d5a:	687b      	ldr	r3, [r7, #4]
 8006d5c:	689b      	ldr	r3, [r3, #8]
 8006d5e:	681b      	ldr	r3, [r3, #0]
 8006d60:	335c      	adds	r3, #92	@ 0x5c
 8006d62:	60fb      	str	r3, [r7, #12]
  
  /*Save context in RAM*/
  STC3115_ReadRamData(handle, RAMData->db);
 8006d64:	68fb      	ldr	r3, [r7, #12]
 8006d66:	4619      	mov	r1, r3
 8006d68:	6878      	ldr	r0, [r7, #4]
 8006d6a:	f000 f98d 	bl	8007088 <STC3115_ReadRamData>
  RAMData->reg.STC3115_Status = STC3115_POWERDN;
 8006d6e:	68fb      	ldr	r3, [r7, #12]
 8006d70:	2244      	movs	r2, #68	@ 0x44
 8006d72:	725a      	strb	r2, [r3, #9]
  /* update the crc */
  STC3115_UpdateRamCRC(handle);
 8006d74:	6878      	ldr	r0, [r7, #4]
 8006d76:	f000 f92c 	bl	8006fd2 <STC3115_UpdateRamCRC>
  STC3115_WriteRamData(handle, RAMData->db);
 8006d7a:	68fb      	ldr	r3, [r7, #12]
 8006d7c:	4619      	mov	r1, r3
 8006d7e:	6878      	ldr	r0, [r7, #4]
 8006d80:	f000 f96c 	bl	800705c <STC3115_WriteRamData>
  
  /*STC3115 Power down*/
  res = STC3115_Powerdown(handle);
 8006d84:	6878      	ldr	r0, [r7, #4]
 8006d86:	f000 fa70 	bl	800726a <STC3115_Powerdown>
 8006d8a:	60b8      	str	r0, [r7, #8]
  if (res != 0) return (COMPONENT_ERROR); /* error */
 8006d8c:	68bb      	ldr	r3, [r7, #8]
 8006d8e:	2b00      	cmp	r3, #0
 8006d90:	d001      	beq.n	8006d96 <STC3115_Stop+0x44>
 8006d92:	2301      	movs	r3, #1
 8006d94:	e000      	b.n	8006d98 <STC3115_Stop+0x46>
  
  return(COMPONENT_OK);
 8006d96:	2300      	movs	r3, #0
}
 8006d98:	4618      	mov	r0, r3
 8006d9a:	3710      	adds	r7, #16
 8006d9c:	46bd      	mov	sp, r7
 8006d9e:	bd80      	pop	{r7, pc}

08006da0 <STC3115_GetSOC>:
 * @brief Returns battery State of Charge
 * @param None
 * @retval Battery State of Charge value
 */
static DrvStatusTypeDef STC3115_GetSOC( DrvContextTypeDef* handle, uint32_t* SOC)
{
 8006da0:	b480      	push	{r7}
 8006da2:	b083      	sub	sp, #12
 8006da4:	af00      	add	r7, sp, #0
 8006da6:	6078      	str	r0, [r7, #4]
 8006da8:	6039      	str	r1, [r7, #0]
  *SOC = ((( STC3115_Data_t * )(( GG_Data_t * )handle->pData)->pComponentData)->batteryData.SOC + 5) / 10;
 8006daa:	687b      	ldr	r3, [r7, #4]
 8006dac:	689b      	ldr	r3, [r3, #8]
 8006dae:	681b      	ldr	r3, [r3, #0]
 8006db0:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8006db2:	3305      	adds	r3, #5
 8006db4:	4a07      	ldr	r2, [pc, #28]	@ (8006dd4 <STC3115_GetSOC+0x34>)
 8006db6:	fb82 1203 	smull	r1, r2, r2, r3
 8006dba:	1092      	asrs	r2, r2, #2
 8006dbc:	17db      	asrs	r3, r3, #31
 8006dbe:	1ad3      	subs	r3, r2, r3
 8006dc0:	461a      	mov	r2, r3
 8006dc2:	683b      	ldr	r3, [r7, #0]
 8006dc4:	601a      	str	r2, [r3, #0]
  return COMPONENT_OK;
 8006dc6:	2300      	movs	r3, #0
}
 8006dc8:	4618      	mov	r0, r3
 8006dca:	370c      	adds	r7, #12
 8006dcc:	46bd      	mov	sp, r7
 8006dce:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006dd2:	4770      	bx	lr
 8006dd4:	66666667 	.word	0x66666667

08006dd8 <STC3115_GetOCV>:
 * @brief Returns battery Open circuit Voltage
 * @param None
 * @retval Open circuit Voltage value
 */
static DrvStatusTypeDef STC3115_GetOCV(DrvContextTypeDef* handle, uint32_t* OCV)
{
 8006dd8:	b480      	push	{r7}
 8006dda:	b083      	sub	sp, #12
 8006ddc:	af00      	add	r7, sp, #0
 8006dde:	6078      	str	r0, [r7, #4]
 8006de0:	6039      	str	r1, [r7, #0]
  *OCV = (( STC3115_Data_t * )(( GG_Data_t * )handle->pData)->pComponentData)->batteryData.OCV;
 8006de2:	687b      	ldr	r3, [r7, #4]
 8006de4:	689b      	ldr	r3, [r3, #8]
 8006de6:	681b      	ldr	r3, [r3, #0]
 8006de8:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8006dea:	461a      	mov	r2, r3
 8006dec:	683b      	ldr	r3, [r7, #0]
 8006dee:	601a      	str	r2, [r3, #0]
  return COMPONENT_OK;
 8006df0:	2300      	movs	r3, #0
}
 8006df2:	4618      	mov	r0, r3
 8006df4:	370c      	adds	r7, #12
 8006df6:	46bd      	mov	sp, r7
 8006df8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006dfc:	4770      	bx	lr

08006dfe <STC3115_GetCurrent>:
 * @brief Returns absorbed current
 * @param None
 * @retval Current value
 */
static DrvStatusTypeDef STC3115_GetCurrent(DrvContextTypeDef* handle, int32_t* Current)
{
 8006dfe:	b480      	push	{r7}
 8006e00:	b083      	sub	sp, #12
 8006e02:	af00      	add	r7, sp, #0
 8006e04:	6078      	str	r0, [r7, #4]
 8006e06:	6039      	str	r1, [r7, #0]
  *Current = (( STC3115_Data_t * )(( GG_Data_t * )handle->pData)->pComponentData)->batteryData.Current;
 8006e08:	687b      	ldr	r3, [r7, #4]
 8006e0a:	689b      	ldr	r3, [r3, #8]
 8006e0c:	681b      	ldr	r3, [r3, #0]
 8006e0e:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
 8006e10:	683b      	ldr	r3, [r7, #0]
 8006e12:	601a      	str	r2, [r3, #0]
  return COMPONENT_OK;
 8006e14:	2300      	movs	r3, #0
}
 8006e16:	4618      	mov	r0, r3
 8006e18:	370c      	adds	r7, #12
 8006e1a:	46bd      	mov	sp, r7
 8006e1c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006e20:	4770      	bx	lr

08006e22 <STC3115_GetTemperature>:
 * @brief Returns temperature value
 * @param None
 * @retval Temperature value
 */
static DrvStatusTypeDef STC3115_GetTemperature(DrvContextTypeDef* handle, int32_t* Temperature)
{
 8006e22:	b480      	push	{r7}
 8006e24:	b083      	sub	sp, #12
 8006e26:	af00      	add	r7, sp, #0
 8006e28:	6078      	str	r0, [r7, #4]
 8006e2a:	6039      	str	r1, [r7, #0]
  *Temperature = (( STC3115_Data_t * )(( GG_Data_t * )handle->pData)->pComponentData)->batteryData.Temperature;
 8006e2c:	687b      	ldr	r3, [r7, #4]
 8006e2e:	689b      	ldr	r3, [r3, #8]
 8006e30:	681b      	ldr	r3, [r3, #0]
 8006e32:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 8006e34:	683b      	ldr	r3, [r7, #0]
 8006e36:	601a      	str	r2, [r3, #0]
  return COMPONENT_OK;
 8006e38:	2300      	movs	r3, #0
}
 8006e3a:	4618      	mov	r0, r3
 8006e3c:	370c      	adds	r7, #12
 8006e3e:	46bd      	mov	sp, r7
 8006e40:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006e44:	4770      	bx	lr

08006e46 <STC3115_GetVoltage>:
 * @brief Returns battery voltage
 * @param None
 * @retval Battery voltage value
 */
static DrvStatusTypeDef STC3115_GetVoltage(DrvContextTypeDef* handle, uint32_t* Voltage)
{
 8006e46:	b480      	push	{r7}
 8006e48:	b083      	sub	sp, #12
 8006e4a:	af00      	add	r7, sp, #0
 8006e4c:	6078      	str	r0, [r7, #4]
 8006e4e:	6039      	str	r1, [r7, #0]
  *Voltage = (( STC3115_Data_t * )(( GG_Data_t * )handle->pData)->pComponentData)->batteryData.Voltage;
 8006e50:	687b      	ldr	r3, [r7, #4]
 8006e52:	689b      	ldr	r3, [r3, #8]
 8006e54:	681b      	ldr	r3, [r3, #0]
 8006e56:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8006e58:	461a      	mov	r2, r3
 8006e5a:	683b      	ldr	r3, [r7, #0]
 8006e5c:	601a      	str	r2, [r3, #0]
  return COMPONENT_OK;
 8006e5e:	2300      	movs	r3, #0
}
 8006e60:	4618      	mov	r0, r3
 8006e62:	370c      	adds	r7, #12
 8006e64:	46bd      	mov	sp, r7
 8006e66:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006e6a:	4770      	bx	lr

08006e6c <STC3115_GetChargeValue>:
 * @brief Returns remaining battery charge value
 * @param None
 * @retval battery charge value
 */
static DrvStatusTypeDef STC3115_GetChargeValue(DrvContextTypeDef* handle, uint32_t* ChargeValue)
{
 8006e6c:	b480      	push	{r7}
 8006e6e:	b083      	sub	sp, #12
 8006e70:	af00      	add	r7, sp, #0
 8006e72:	6078      	str	r0, [r7, #4]
 8006e74:	6039      	str	r1, [r7, #0]
  *ChargeValue = (( STC3115_Data_t * )(( GG_Data_t * )handle->pData)->pComponentData)->batteryData.ChargeValue;
 8006e76:	687b      	ldr	r3, [r7, #4]
 8006e78:	689b      	ldr	r3, [r3, #8]
 8006e7a:	681b      	ldr	r3, [r3, #0]
 8006e7c:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8006e7e:	461a      	mov	r2, r3
 8006e80:	683b      	ldr	r3, [r7, #0]
 8006e82:	601a      	str	r2, [r3, #0]
  return COMPONENT_OK;
 8006e84:	2300      	movs	r3, #0
}
 8006e86:	4618      	mov	r0, r3
 8006e88:	370c      	adds	r7, #12
 8006e8a:	46bd      	mov	sp, r7
 8006e8c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006e90:	4770      	bx	lr

08006e92 <STC3115_GetPresence>:
 * @brief Tells whether battery is present or not
 * @param None
 * @retval 0 if battery is not present, 1 if present
 */
static DrvStatusTypeDef STC3115_GetPresence(DrvContextTypeDef* handle, uint32_t* Presence)
{
 8006e92:	b480      	push	{r7}
 8006e94:	b083      	sub	sp, #12
 8006e96:	af00      	add	r7, sp, #0
 8006e98:	6078      	str	r0, [r7, #4]
 8006e9a:	6039      	str	r1, [r7, #0]
  *Presence = (( STC3115_Data_t * )(( GG_Data_t * )handle->pData)->pComponentData)->batteryData.Presence;
 8006e9c:	687b      	ldr	r3, [r7, #4]
 8006e9e:	689b      	ldr	r3, [r3, #8]
 8006ea0:	681b      	ldr	r3, [r3, #0]
 8006ea2:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8006ea4:	461a      	mov	r2, r3
 8006ea6:	683b      	ldr	r3, [r7, #0]
 8006ea8:	601a      	str	r2, [r3, #0]
  return COMPONENT_OK;
 8006eaa:	2300      	movs	r3, #0
}
 8006eac:	4618      	mov	r0, r3
 8006eae:	370c      	adds	r7, #12
 8006eb0:	46bd      	mov	sp, r7
 8006eb2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006eb6:	4770      	bx	lr

08006eb8 <STC3115_GetAlarmStatus>:
 * @brief Returns Alarm bits status
 * @param None
 * @retval STC3115 Alarm bits status
 */
static DrvStatusTypeDef STC3115_GetAlarmStatus(DrvContextTypeDef* handle, uint32_t* status)
{
 8006eb8:	b480      	push	{r7}
 8006eba:	b083      	sub	sp, #12
 8006ebc:	af00      	add	r7, sp, #0
 8006ebe:	6078      	str	r0, [r7, #4]
 8006ec0:	6039      	str	r1, [r7, #0]
  *status = ((( STC3115_Data_t * )(( GG_Data_t * )handle->pData)->pComponentData)->batteryData.status >> 13) & 0x3;
 8006ec2:	687b      	ldr	r3, [r7, #4]
 8006ec4:	689b      	ldr	r3, [r3, #8]
 8006ec6:	681b      	ldr	r3, [r3, #0]
 8006ec8:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8006eca:	135b      	asrs	r3, r3, #13
 8006ecc:	f003 0203 	and.w	r2, r3, #3
 8006ed0:	683b      	ldr	r3, [r7, #0]
 8006ed2:	601a      	str	r2, [r3, #0]
  return COMPONENT_OK;
 8006ed4:	2300      	movs	r3, #0
}
 8006ed6:	4618      	mov	r0, r3
 8006ed8:	370c      	adds	r7, #12
 8006eda:	46bd      	mov	sp, r7
 8006edc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006ee0:	4770      	bx	lr

08006ee2 <STC3115_GetRemTime>:
 * @brief Returns estimated Remaining Time
 * @param None
 * @retval RemTime value
 */
static DrvStatusTypeDef STC3115_GetRemTime(DrvContextTypeDef* handle, int32_t* RemTime)
{
 8006ee2:	b480      	push	{r7}
 8006ee4:	b083      	sub	sp, #12
 8006ee6:	af00      	add	r7, sp, #0
 8006ee8:	6078      	str	r0, [r7, #4]
 8006eea:	6039      	str	r1, [r7, #0]
  *RemTime = (( STC3115_Data_t * )(( GG_Data_t * )handle->pData)->pComponentData)->batteryData.RemTime;
 8006eec:	687b      	ldr	r3, [r7, #4]
 8006eee:	689b      	ldr	r3, [r3, #8]
 8006ef0:	681b      	ldr	r3, [r3, #0]
 8006ef2:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
 8006ef4:	683b      	ldr	r3, [r7, #0]
 8006ef6:	601a      	str	r2, [r3, #0]
  return COMPONENT_OK;
 8006ef8:	2300      	movs	r3, #0
}
 8006efa:	4618      	mov	r0, r3
 8006efc:	370c      	adds	r7, #12
 8006efe:	46bd      	mov	sp, r7
 8006f00:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006f04:	4770      	bx	lr

08006f06 <STC3115_Status>:
 * @brief Read the STC3115 status
 * @param None
 * @retval status word (REG_MODE / REG_CTRL), -1 if error
 */
static int STC3115_Status( DrvContextTypeDef* handle )
{
 8006f06:	b580      	push	{r7, lr}
 8006f08:	b084      	sub	sp, #16
 8006f0a:	af00      	add	r7, sp, #0
 8006f0c:	6078      	str	r0, [r7, #4]
  int value;
  uint8_t data;
  
  /* First, check the presence of the STC3115 by reading first byte of dev. ID */
  if(STC3115_Read(handle, STC3115_REG_ID, &data, 1) == -1)
 8006f0e:	f107 020b 	add.w	r2, r7, #11
 8006f12:	2301      	movs	r3, #1
 8006f14:	2118      	movs	r1, #24
 8006f16:	6878      	ldr	r0, [r7, #4]
 8006f18:	f000 fa16 	bl	8007348 <STC3115_Read>
 8006f1c:	4603      	mov	r3, r0
 8006f1e:	f1b3 3fff 	cmp.w	r3, #4294967295
 8006f22:	d102      	bne.n	8006f2a <STC3115_Status+0x24>
    return -1;
 8006f24:	f04f 33ff 	mov.w	r3, #4294967295
 8006f28:	e019      	b.n	8006f5e <STC3115_Status+0x58>
  if (data != STC3115_ID)
 8006f2a:	7afb      	ldrb	r3, [r7, #11]
 8006f2c:	2b14      	cmp	r3, #20
 8006f2e:	d002      	beq.n	8006f36 <STC3115_Status+0x30>
    return -1;
 8006f30:	f04f 33ff 	mov.w	r3, #4294967295
 8006f34:	e013      	b.n	8006f5e <STC3115_Status+0x58>
    
  /* read REG_MODE and REG_CTRL */
  if(STC3115_ReadWord(handle, STC3115_REG_MODE, &value) == -1)
 8006f36:	f107 030c 	add.w	r3, r7, #12
 8006f3a:	461a      	mov	r2, r3
 8006f3c:	2100      	movs	r1, #0
 8006f3e:	6878      	ldr	r0, [r7, #4]
 8006f40:	f000 fa38 	bl	80073b4 <STC3115_ReadWord>
 8006f44:	4603      	mov	r3, r0
 8006f46:	f1b3 3fff 	cmp.w	r3, #4294967295
 8006f4a:	d102      	bne.n	8006f52 <STC3115_Status+0x4c>
  {
	return -1;
 8006f4c:	f04f 33ff 	mov.w	r3, #4294967295
 8006f50:	e005      	b.n	8006f5e <STC3115_Status+0x58>
  }
  else
  {
	value &= 0x7f7f;
 8006f52:	68fa      	ldr	r2, [r7, #12]
 8006f54:	f647 737f 	movw	r3, #32639	@ 0x7f7f
 8006f58:	4013      	ands	r3, r2
 8006f5a:	60fb      	str	r3, [r7, #12]
  }
  
  return value;
 8006f5c:	68fb      	ldr	r3, [r7, #12]
}
 8006f5e:	4618      	mov	r0, r3
 8006f60:	3710      	adds	r7, #16
 8006f62:	46bd      	mov	sp, r7
 8006f64:	bd80      	pop	{r7, pc}

08006f66 <STC3115_CalcRamCRC8>:
 * @param pointer to byte array,
 * @param n: number of bytes
 * @retval CRC value
 */
static int STC3115_CalcRamCRC8(unsigned char *data, int n)
{
 8006f66:	b480      	push	{r7}
 8006f68:	b087      	sub	sp, #28
 8006f6a:	af00      	add	r7, sp, #0
 8006f6c:	6078      	str	r0, [r7, #4]
 8006f6e:	6039      	str	r1, [r7, #0]
  int crc = 0; /* initial value */
 8006f70:	2300      	movs	r3, #0
 8006f72:	617b      	str	r3, [r7, #20]
  int i, j;
  
  for (i = 0; i < n; i++)
 8006f74:	2300      	movs	r3, #0
 8006f76:	613b      	str	r3, [r7, #16]
 8006f78:	e01f      	b.n	8006fba <STC3115_CalcRamCRC8+0x54>
  {
    crc ^= data[i];
 8006f7a:	693b      	ldr	r3, [r7, #16]
 8006f7c:	687a      	ldr	r2, [r7, #4]
 8006f7e:	4413      	add	r3, r2
 8006f80:	781b      	ldrb	r3, [r3, #0]
 8006f82:	461a      	mov	r2, r3
 8006f84:	697b      	ldr	r3, [r7, #20]
 8006f86:	4053      	eors	r3, r2
 8006f88:	617b      	str	r3, [r7, #20]
    for (j = 0; j < 8; j++)
 8006f8a:	2300      	movs	r3, #0
 8006f8c:	60fb      	str	r3, [r7, #12]
 8006f8e:	e00e      	b.n	8006fae <STC3115_CalcRamCRC8+0x48>
    {
      crc <<= 1;
 8006f90:	697b      	ldr	r3, [r7, #20]
 8006f92:	005b      	lsls	r3, r3, #1
 8006f94:	617b      	str	r3, [r7, #20]
      if (crc & 0x100)  crc ^= 7;
 8006f96:	697b      	ldr	r3, [r7, #20]
 8006f98:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8006f9c:	2b00      	cmp	r3, #0
 8006f9e:	d003      	beq.n	8006fa8 <STC3115_CalcRamCRC8+0x42>
 8006fa0:	697b      	ldr	r3, [r7, #20]
 8006fa2:	f083 0307 	eor.w	r3, r3, #7
 8006fa6:	617b      	str	r3, [r7, #20]
    for (j = 0; j < 8; j++)
 8006fa8:	68fb      	ldr	r3, [r7, #12]
 8006faa:	3301      	adds	r3, #1
 8006fac:	60fb      	str	r3, [r7, #12]
 8006fae:	68fb      	ldr	r3, [r7, #12]
 8006fb0:	2b07      	cmp	r3, #7
 8006fb2:	dded      	ble.n	8006f90 <STC3115_CalcRamCRC8+0x2a>
  for (i = 0; i < n; i++)
 8006fb4:	693b      	ldr	r3, [r7, #16]
 8006fb6:	3301      	adds	r3, #1
 8006fb8:	613b      	str	r3, [r7, #16]
 8006fba:	693a      	ldr	r2, [r7, #16]
 8006fbc:	683b      	ldr	r3, [r7, #0]
 8006fbe:	429a      	cmp	r2, r3
 8006fc0:	dbdb      	blt.n	8006f7a <STC3115_CalcRamCRC8+0x14>
    }
  }
  return(crc & 255);
 8006fc2:	697b      	ldr	r3, [r7, #20]
 8006fc4:	b2db      	uxtb	r3, r3
}
 8006fc6:	4618      	mov	r0, r3
 8006fc8:	371c      	adds	r7, #28
 8006fca:	46bd      	mov	sp, r7
 8006fcc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006fd0:	4770      	bx	lr

08006fd2 <STC3115_UpdateRamCRC>:
 * @brief calculate the RAM CRC
 * @param None
 * @retval CRC value
 */
static int STC3115_UpdateRamCRC( DrvContextTypeDef* handle )
{
 8006fd2:	b580      	push	{r7, lr}
 8006fd4:	b084      	sub	sp, #16
 8006fd6:	af00      	add	r7, sp, #0
 8006fd8:	6078      	str	r0, [r7, #4]
  int res;
  RAMData_TypeDef *RAMData = &(( STC3115_Data_t * )(( GG_Data_t * )handle->pData)->pComponentData)->ramData;
 8006fda:	687b      	ldr	r3, [r7, #4]
 8006fdc:	689b      	ldr	r3, [r3, #8]
 8006fde:	681b      	ldr	r3, [r3, #0]
 8006fe0:	335c      	adds	r3, #92	@ 0x5c
 8006fe2:	60fb      	str	r3, [r7, #12]
  
  res = STC3115_CalcRamCRC8(RAMData->db, RAM_SIZE - 1);
 8006fe4:	68fb      	ldr	r3, [r7, #12]
 8006fe6:	210f      	movs	r1, #15
 8006fe8:	4618      	mov	r0, r3
 8006fea:	f7ff ffbc 	bl	8006f66 <STC3115_CalcRamCRC8>
 8006fee:	60b8      	str	r0, [r7, #8]
  RAMData->db[RAM_SIZE - 1] = res; /* last byte holds the CRC */
 8006ff0:	68bb      	ldr	r3, [r7, #8]
 8006ff2:	b2da      	uxtb	r2, r3
 8006ff4:	68fb      	ldr	r3, [r7, #12]
 8006ff6:	73da      	strb	r2, [r3, #15]
  return(res);
 8006ff8:	68bb      	ldr	r3, [r7, #8]
}
 8006ffa:	4618      	mov	r0, r3
 8006ffc:	3710      	adds	r7, #16
 8006ffe:	46bd      	mov	sp, r7
 8007000:	bd80      	pop	{r7, pc}

08007002 <STC3115_InitRamData>:
 * @brief Initialize the STC3115 RAM registers with valid test word and CRC
 * @param ConfigData Pointer to STC3115_ConfigData_TypeDef structure
 * @retval None
 */
static void STC3115_InitRamData(DrvContextTypeDef* handle, STC3115_ConfigData_TypeDef *ConfigData)
{
 8007002:	b580      	push	{r7, lr}
 8007004:	b084      	sub	sp, #16
 8007006:	af00      	add	r7, sp, #0
 8007008:	6078      	str	r0, [r7, #4]
 800700a:	6039      	str	r1, [r7, #0]
  int index;
  RAMData_TypeDef *RAMData = &(( STC3115_Data_t * )(( GG_Data_t * )handle->pData)->pComponentData)->ramData;
 800700c:	687b      	ldr	r3, [r7, #4]
 800700e:	689b      	ldr	r3, [r3, #8]
 8007010:	681b      	ldr	r3, [r3, #0]
 8007012:	335c      	adds	r3, #92	@ 0x5c
 8007014:	60bb      	str	r3, [r7, #8]
  
  //Set full RAM tab to 0
  for (index = 0; index < RAM_SIZE; index++)
 8007016:	2300      	movs	r3, #0
 8007018:	60fb      	str	r3, [r7, #12]
 800701a:	e007      	b.n	800702c <STC3115_InitRamData+0x2a>
  {
    RAMData->db[index] = 0;
 800701c:	68ba      	ldr	r2, [r7, #8]
 800701e:	68fb      	ldr	r3, [r7, #12]
 8007020:	4413      	add	r3, r2
 8007022:	2200      	movs	r2, #0
 8007024:	701a      	strb	r2, [r3, #0]
  for (index = 0; index < RAM_SIZE; index++)
 8007026:	68fb      	ldr	r3, [r7, #12]
 8007028:	3301      	adds	r3, #1
 800702a:	60fb      	str	r3, [r7, #12]
 800702c:	68fb      	ldr	r3, [r7, #12]
 800702e:	2b0f      	cmp	r3, #15
 8007030:	ddf4      	ble.n	800701c <STC3115_InitRamData+0x1a>
  }
  //Fill RAM regs
  RAMData->reg.TstWord = RAM_TSTWORD; /* Fixed word to check RAM integrity */
 8007032:	68bb      	ldr	r3, [r7, #8]
 8007034:	f245 32a9 	movw	r2, #21417	@ 0x53a9
 8007038:	801a      	strh	r2, [r3, #0]
  RAMData->reg.CC_cnf = ConfigData->CC_cnf;
 800703a:	683b      	ldr	r3, [r7, #0]
 800703c:	68db      	ldr	r3, [r3, #12]
 800703e:	b21a      	sxth	r2, r3
 8007040:	68bb      	ldr	r3, [r7, #8]
 8007042:	809a      	strh	r2, [r3, #4]
  RAMData->reg.VM_cnf = ConfigData->VM_cnf;
 8007044:	683b      	ldr	r3, [r7, #0]
 8007046:	691b      	ldr	r3, [r3, #16]
 8007048:	b21a      	sxth	r2, r3
 800704a:	68bb      	ldr	r3, [r7, #8]
 800704c:	80da      	strh	r2, [r3, #6]
  /* update the crc */
  STC3115_UpdateRamCRC(handle);
 800704e:	6878      	ldr	r0, [r7, #4]
 8007050:	f7ff ffbf 	bl	8006fd2 <STC3115_UpdateRamCRC>
}
 8007054:	bf00      	nop
 8007056:	3710      	adds	r7, #16
 8007058:	46bd      	mov	sp, r7
 800705a:	bd80      	pop	{r7, pc}

0800705c <STC3115_WriteRamData>:
 * @brief Utility function to write the RAM data into STC3115
 * @param RamData Pointer to read STC3115 RAM data array from
 * @retval I2C error code
 */
static int STC3115_WriteRamData(DrvContextTypeDef* handle, unsigned char *RamData)
{
 800705c:	b580      	push	{r7, lr}
 800705e:	b082      	sub	sp, #8
 8007060:	af00      	add	r7, sp, #0
 8007062:	6078      	str	r0, [r7, #4]
 8007064:	6039      	str	r1, [r7, #0]
  if (Sensor_IO_Write(handle, STC3115_REG_RAM, RamData, RAM_SIZE))
 8007066:	2310      	movs	r3, #16
 8007068:	683a      	ldr	r2, [r7, #0]
 800706a:	2120      	movs	r1, #32
 800706c:	6878      	ldr	r0, [r7, #4]
 800706e:	f006 f83e 	bl	800d0ee <Sensor_IO_Write>
 8007072:	4603      	mov	r3, r0
 8007074:	2b00      	cmp	r3, #0
 8007076:	d002      	beq.n	800707e <STC3115_WriteRamData+0x22>
  {
    return -1;
 8007078:	f04f 33ff 	mov.w	r3, #4294967295
 800707c:	e000      	b.n	8007080 <STC3115_WriteRamData+0x24>
  }
  else
  {
    return 0;
 800707e:	2300      	movs	r3, #0
  }
}
 8007080:	4618      	mov	r0, r3
 8007082:	3708      	adds	r7, #8
 8007084:	46bd      	mov	sp, r7
 8007086:	bd80      	pop	{r7, pc}

08007088 <STC3115_ReadRamData>:
 * @brief utility function to read the RAM data from STC3115
 * @param RamData Pointer to store STC3115 RAM data array to
 * @retval I2C error code
 */
static int STC3115_ReadRamData(DrvContextTypeDef* handle, unsigned char *RamData)
{
 8007088:	b580      	push	{r7, lr}
 800708a:	b082      	sub	sp, #8
 800708c:	af00      	add	r7, sp, #0
 800708e:	6078      	str	r0, [r7, #4]
 8007090:	6039      	str	r1, [r7, #0]
  if (Sensor_IO_Read(handle, STC3115_REG_RAM, RamData, RAM_SIZE))
 8007092:	2310      	movs	r3, #16
 8007094:	683a      	ldr	r2, [r7, #0]
 8007096:	2120      	movs	r1, #32
 8007098:	6878      	ldr	r0, [r7, #4]
 800709a:	f006 f846 	bl	800d12a <Sensor_IO_Read>
 800709e:	4603      	mov	r3, r0
 80070a0:	2b00      	cmp	r3, #0
 80070a2:	d002      	beq.n	80070aa <STC3115_ReadRamData+0x22>
  {
    return -1;
 80070a4:	f04f 33ff 	mov.w	r3, #4294967295
 80070a8:	e000      	b.n	80070ac <STC3115_ReadRamData+0x24>
  }
  else
  {
    return 0;
 80070aa:	2300      	movs	r3, #0
  }
}
 80070ac:	4618      	mov	r0, r3
 80070ae:	3708      	adds	r7, #8
 80070b0:	46bd      	mov	sp, r7
 80070b2:	bd80      	pop	{r7, pc}

080070b4 <STC3115_ReadBatteryData>:
 * @brief Utility function to read the battery data from STC3115 to be called every 5s or so
 * @param Pointer to STC3115_BatteryData_TypeDef structure
 * @retval error status (OK, !OK)
 */
static int STC3115_ReadBatteryData(DrvContextTypeDef* handle, STC3115_BatteryData_TypeDef *BatteryData)
{
 80070b4:	b580      	push	{r7, lr}
 80070b6:	b088      	sub	sp, #32
 80070b8:	af00      	add	r7, sp, #0
 80070ba:	6078      	str	r0, [r7, #4]
 80070bc:	6039      	str	r1, [r7, #0]
  int res;
  int value;
  
  //STC3115_Read(DrvContextTypeDef* handle, uint8_t RegAddress, uint8_t *data, uint16_t NumByteToWrite)
  /* read STC3115 registers 0 to 14 */
  res = STC3115_Read(handle, 0, data, 15);
 80070be:	f107 0208 	add.w	r2, r7, #8
 80070c2:	230f      	movs	r3, #15
 80070c4:	2100      	movs	r1, #0
 80070c6:	6878      	ldr	r0, [r7, #4]
 80070c8:	f000 f93e 	bl	8007348 <STC3115_Read>
 80070cc:	61b8      	str	r0, [r7, #24]
  
  if (res < 0) return(res); /* read failed */
 80070ce:	69bb      	ldr	r3, [r7, #24]
 80070d0:	2b00      	cmp	r3, #0
 80070d2:	da01      	bge.n	80070d8 <STC3115_ReadBatteryData+0x24>
 80070d4:	69bb      	ldr	r3, [r7, #24]
 80070d6:	e094      	b.n	8007202 <STC3115_ReadBatteryData+0x14e>
  
  /* fill the battery status data */
  /* SOC */
  value = data[3];
 80070d8:	7afb      	ldrb	r3, [r7, #11]
 80070da:	61fb      	str	r3, [r7, #28]
  value = (value << 8) + data[2];
 80070dc:	69fb      	ldr	r3, [r7, #28]
 80070de:	021b      	lsls	r3, r3, #8
 80070e0:	7aba      	ldrb	r2, [r7, #10]
 80070e2:	4413      	add	r3, r2
 80070e4:	61fb      	str	r3, [r7, #28]
  BatteryData->HRSOC = value;     /* result in 1/512% */
 80070e6:	683b      	ldr	r3, [r7, #0]
 80070e8:	69fa      	ldr	r2, [r7, #28]
 80070ea:	605a      	str	r2, [r3, #4]
  BatteryData->SOC = (value * 10 + 256) / 512; /* result in 0.1% */
 80070ec:	69fa      	ldr	r2, [r7, #28]
 80070ee:	4613      	mov	r3, r2
 80070f0:	009b      	lsls	r3, r3, #2
 80070f2:	4413      	add	r3, r2
 80070f4:	005b      	lsls	r3, r3, #1
 80070f6:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 80070fa:	2b00      	cmp	r3, #0
 80070fc:	da01      	bge.n	8007102 <STC3115_ReadBatteryData+0x4e>
 80070fe:	f203 13ff 	addw	r3, r3, #511	@ 0x1ff
 8007102:	125b      	asrs	r3, r3, #9
 8007104:	461a      	mov	r2, r3
 8007106:	683b      	ldr	r3, [r7, #0]
 8007108:	609a      	str	r2, [r3, #8]
  
  /* conversion counter */
  value = data[5];
 800710a:	7b7b      	ldrb	r3, [r7, #13]
 800710c:	61fb      	str	r3, [r7, #28]
  value = (value << 8) + data[4];
 800710e:	69fb      	ldr	r3, [r7, #28]
 8007110:	021b      	lsls	r3, r3, #8
 8007112:	7b3a      	ldrb	r2, [r7, #12]
 8007114:	4413      	add	r3, r2
 8007116:	61fb      	str	r3, [r7, #28]
  BatteryData->ConvCounter = value;
 8007118:	683b      	ldr	r3, [r7, #0]
 800711a:	69fa      	ldr	r2, [r7, #28]
 800711c:	619a      	str	r2, [r3, #24]
  
  /* current */
  value = data[7];
 800711e:	7bfb      	ldrb	r3, [r7, #15]
 8007120:	61fb      	str	r3, [r7, #28]
  value = (value << 8) + data[6];
 8007122:	69fb      	ldr	r3, [r7, #28]
 8007124:	021b      	lsls	r3, r3, #8
 8007126:	7bba      	ldrb	r2, [r7, #14]
 8007128:	4413      	add	r3, r2
 800712a:	61fb      	str	r3, [r7, #28]
  value &= 0x3fff;   /* mask unused bits */
 800712c:	69fb      	ldr	r3, [r7, #28]
 800712e:	f3c3 030d 	ubfx	r3, r3, #0, #14
 8007132:	61fb      	str	r3, [r7, #28]
  if (value >= 0x2000) value = value - 0x4000; /* convert to signed value */
 8007134:	69fb      	ldr	r3, [r7, #28]
 8007136:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 800713a:	db03      	blt.n	8007144 <STC3115_ReadBatteryData+0x90>
 800713c:	69fb      	ldr	r3, [r7, #28]
 800713e:	f5a3 4380 	sub.w	r3, r3, #16384	@ 0x4000
 8007142:	61fb      	str	r3, [r7, #28]
  // suggested modification
  BatteryData->Current = STC3115_conv(value, CurrentFactor / RSENSE); /* result inf mA */
 8007144:	69fb      	ldr	r3, [r7, #28]
 8007146:	b21b      	sxth	r3, r3
 8007148:	f240 11e1 	movw	r1, #481	@ 0x1e1
 800714c:	4618      	mov	r0, r3
 800714e:	f000 f8ad 	bl	80072ac <STC3115_conv>
 8007152:	4602      	mov	r2, r0
 8007154:	683b      	ldr	r3, [r7, #0]
 8007156:	611a      	str	r2, [r3, #16]
  //BatteryData->Current = (int)(value * 0.1176 * 10); /* result in hundreds of uA */
//  BatteryData->Current = STC3115_conv(value, 10*CurrentFactor / RSENSE); /* result in hundreds of uA */
  // suggested modification end

  /* voltage */
  value = data[9];
 8007158:	7c7b      	ldrb	r3, [r7, #17]
 800715a:	61fb      	str	r3, [r7, #28]
  value = (value << 8) + data[8];
 800715c:	69fb      	ldr	r3, [r7, #28]
 800715e:	021b      	lsls	r3, r3, #8
 8007160:	7c3a      	ldrb	r2, [r7, #16]
 8007162:	4413      	add	r3, r2
 8007164:	61fb      	str	r3, [r7, #28]
  value &= 0x0fff; /* mask unused bits */
 8007166:	69fb      	ldr	r3, [r7, #28]
 8007168:	f3c3 030b 	ubfx	r3, r3, #0, #12
 800716c:	61fb      	str	r3, [r7, #28]
  if (value >= 0x0800) value -= 0x1000; /* convert to signed value */
 800716e:	69fb      	ldr	r3, [r7, #28]
 8007170:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 8007174:	db03      	blt.n	800717e <STC3115_ReadBatteryData+0xca>
 8007176:	69fb      	ldr	r3, [r7, #28]
 8007178:	f5a3 5380 	sub.w	r3, r3, #4096	@ 0x1000
 800717c:	61fb      	str	r3, [r7, #28]
  value = STC3115_conv(value, VoltageFactor); /* result in mV */
 800717e:	69fb      	ldr	r3, [r7, #28]
 8007180:	b21b      	sxth	r3, r3
 8007182:	f242 3133 	movw	r1, #9011	@ 0x2333
 8007186:	4618      	mov	r0, r3
 8007188:	f000 f890 	bl	80072ac <STC3115_conv>
 800718c:	61f8      	str	r0, [r7, #28]
  BatteryData->Voltage = value;  /* result in mV */
 800718e:	683b      	ldr	r3, [r7, #0]
 8007190:	69fa      	ldr	r2, [r7, #28]
 8007192:	60da      	str	r2, [r3, #12]
  
  /* temperature */
  value = data[10];
 8007194:	7cbb      	ldrb	r3, [r7, #18]
 8007196:	61fb      	str	r3, [r7, #28]
  if (value >= 0x80) value -= 0x100; /* convert to signed value */
 8007198:	69fb      	ldr	r3, [r7, #28]
 800719a:	2b7f      	cmp	r3, #127	@ 0x7f
 800719c:	dd03      	ble.n	80071a6 <STC3115_ReadBatteryData+0xf2>
 800719e:	69fb      	ldr	r3, [r7, #28]
 80071a0:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 80071a4:	61fb      	str	r3, [r7, #28]
  BatteryData->Temperature = value * 10; /* result in 0.1C */
 80071a6:	69fa      	ldr	r2, [r7, #28]
 80071a8:	4613      	mov	r3, r2
 80071aa:	009b      	lsls	r3, r3, #2
 80071ac:	4413      	add	r3, r2
 80071ae:	005b      	lsls	r3, r3, #1
 80071b0:	461a      	mov	r2, r3
 80071b2:	683b      	ldr	r3, [r7, #0]
 80071b4:	615a      	str	r2, [r3, #20]
  
  /* OCV */
  value = data[14];
 80071b6:	7dbb      	ldrb	r3, [r7, #22]
 80071b8:	61fb      	str	r3, [r7, #28]
  value = (value << 8) + data[13];
 80071ba:	69fb      	ldr	r3, [r7, #28]
 80071bc:	021b      	lsls	r3, r3, #8
 80071be:	7d7a      	ldrb	r2, [r7, #21]
 80071c0:	4413      	add	r3, r2
 80071c2:	61fb      	str	r3, [r7, #28]
  value &= 0x3fff; /* mask unused bits */
 80071c4:	69fb      	ldr	r3, [r7, #28]
 80071c6:	f3c3 030d 	ubfx	r3, r3, #0, #14
 80071ca:	61fb      	str	r3, [r7, #28]
  if (value >= 0x02000) value -= 0x4000; /* convert to signed value */
 80071cc:	69fb      	ldr	r3, [r7, #28]
 80071ce:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 80071d2:	db03      	blt.n	80071dc <STC3115_ReadBatteryData+0x128>
 80071d4:	69fb      	ldr	r3, [r7, #28]
 80071d6:	f5a3 4380 	sub.w	r3, r3, #16384	@ 0x4000
 80071da:	61fb      	str	r3, [r7, #28]
  value = STC3115_conv(value, VoltageFactor);
 80071dc:	69fb      	ldr	r3, [r7, #28]
 80071de:	b21b      	sxth	r3, r3
 80071e0:	f242 3133 	movw	r1, #9011	@ 0x2333
 80071e4:	4618      	mov	r0, r3
 80071e6:	f000 f861 	bl	80072ac <STC3115_conv>
 80071ea:	61f8      	str	r0, [r7, #28]
  value = (value + 2) / 4; /* divide by 4 with rounding */
 80071ec:	69fb      	ldr	r3, [r7, #28]
 80071ee:	3302      	adds	r3, #2
 80071f0:	2b00      	cmp	r3, #0
 80071f2:	da00      	bge.n	80071f6 <STC3115_ReadBatteryData+0x142>
 80071f4:	3303      	adds	r3, #3
 80071f6:	109b      	asrs	r3, r3, #2
 80071f8:	61fb      	str	r3, [r7, #28]
  BatteryData->OCV = value;  /* result in mV */
 80071fa:	683b      	ldr	r3, [r7, #0]
 80071fc:	69fa      	ldr	r2, [r7, #28]
 80071fe:	61da      	str	r2, [r3, #28]
  
  return(OK);
 8007200:	2300      	movs	r3, #0
}
 8007202:	4618      	mov	r0, r3
 8007204:	3720      	adds	r7, #32
 8007206:	46bd      	mov	sp, r7
 8007208:	bd80      	pop	{r7, pc}

0800720a <STC3115_Restore>:
 * @brief Restore STC3115 state
 * @param Pointer to STC3115 Configuration Data structure
 * @retval Always 0
 */
static int STC3115_Restore(DrvContextTypeDef* handle, STC3115_ConfigData_TypeDef *ConfigData)
{
 800720a:	b580      	push	{r7, lr}
 800720c:	b084      	sub	sp, #16
 800720e:	af00      	add	r7, sp, #0
 8007210:	6078      	str	r0, [r7, #4]
 8007212:	6039      	str	r1, [r7, #0]
  int res;
  RAMData_TypeDef *RAMData = &(( STC3115_Data_t * )(( GG_Data_t * )handle->pData)->pComponentData)->ramData;
 8007214:	687b      	ldr	r3, [r7, #4]
 8007216:	689b      	ldr	r3, [r3, #8]
 8007218:	681b      	ldr	r3, [r3, #0]
 800721a:	335c      	adds	r3, #92	@ 0x5c
 800721c:	60bb      	str	r3, [r7, #8]
  
  /* check STC310x status */
  res = STC3115_Status(handle);
 800721e:	6878      	ldr	r0, [r7, #4]
 8007220:	f7ff fe71 	bl	8006f06 <STC3115_Status>
 8007224:	60f8      	str	r0, [r7, #12]
  if (res < 0) return(res);
 8007226:	68fb      	ldr	r3, [r7, #12]
 8007228:	2b00      	cmp	r3, #0
 800722a:	da01      	bge.n	8007230 <STC3115_Restore+0x26>
 800722c:	68fb      	ldr	r3, [r7, #12]
 800722e:	e018      	b.n	8007262 <STC3115_Restore+0x58>
  
  STC3115_SetParam(handle, ConfigData);  /* set STC3115 parameters  */
 8007230:	6839      	ldr	r1, [r7, #0]
 8007232:	6878      	ldr	r0, [r7, #4]
 8007234:	f000 f8f8 	bl	8007428 <STC3115_SetParam>
  
  /* restore SOC from RAM data */
  res = 0;
 8007238:	2300      	movs	r3, #0
 800723a:	60fb      	str	r3, [r7, #12]
  
  if (RAMData->reg.STC3115_Status == STC3115_RUNNING)
 800723c:	68bb      	ldr	r3, [r7, #8]
 800723e:	7a5b      	ldrb	r3, [r3, #9]
 8007240:	2b52      	cmp	r3, #82	@ 0x52
 8007242:	d10d      	bne.n	8007260 <STC3115_Restore+0x56>
  {
    if (RAMData->reg.HRSOC != 0)
 8007244:	68bb      	ldr	r3, [r7, #8]
 8007246:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 800724a:	2b00      	cmp	r3, #0
 800724c:	d008      	beq.n	8007260 <STC3115_Restore+0x56>
    {
      res = STC3115_WriteWord(handle, STC3115_REG_SOC, RAMData->reg.HRSOC);  /* restore HRSOC */
 800724e:	68bb      	ldr	r3, [r7, #8]
 8007250:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8007254:	461a      	mov	r2, r3
 8007256:	2102      	movs	r1, #2
 8007258:	6878      	ldr	r0, [r7, #4]
 800725a:	f000 f8c8 	bl	80073ee <STC3115_WriteWord>
 800725e:	60f8      	str	r0, [r7, #12]
    }
  }
  return(res);
 8007260:	68fb      	ldr	r3, [r7, #12]
}
 8007262:	4618      	mov	r0, r3
 8007264:	3710      	adds	r7, #16
 8007266:	46bd      	mov	sp, r7
 8007268:	bd80      	pop	{r7, pc}

0800726a <STC3115_Powerdown>:
 * @brief Stop the STC3115 at application power down
 * @param None
 * @retval Ok if success, error code otherwise
 */
static int STC3115_Powerdown(DrvContextTypeDef* handle)
{
 800726a:	b580      	push	{r7, lr}
 800726c:	b084      	sub	sp, #16
 800726e:	af00      	add	r7, sp, #0
 8007270:	6078      	str	r0, [r7, #4]
  int res;
  uint8_t data;
  
  /* write 0x01 into the REG_CTRL to release IO0 pin open, */
  data = 0x01;
 8007272:	2301      	movs	r3, #1
 8007274:	72fb      	strb	r3, [r7, #11]
  STC3115_Write(handle, STC3115_REG_CTRL, &data, 1);
 8007276:	f107 020b 	add.w	r2, r7, #11
 800727a:	2301      	movs	r3, #1
 800727c:	2101      	movs	r1, #1
 800727e:	6878      	ldr	r0, [r7, #4]
 8007280:	f000 f87d 	bl	800737e <STC3115_Write>
  
  /* write 0 into the REG_MODE register to put the STC3115 in standby mode */
  data = 0x00;
 8007284:	2300      	movs	r3, #0
 8007286:	72fb      	strb	r3, [r7, #11]
  res = STC3115_Write(handle, STC3115_REG_MODE, &data, 1);
 8007288:	f107 020b 	add.w	r2, r7, #11
 800728c:	2301      	movs	r3, #1
 800728e:	2100      	movs	r1, #0
 8007290:	6878      	ldr	r0, [r7, #4]
 8007292:	f000 f874 	bl	800737e <STC3115_Write>
 8007296:	60f8      	str	r0, [r7, #12]
  if (res!= OK) return (res);
 8007298:	68fb      	ldr	r3, [r7, #12]
 800729a:	2b00      	cmp	r3, #0
 800729c:	d001      	beq.n	80072a2 <STC3115_Powerdown+0x38>
 800729e:	68fb      	ldr	r3, [r7, #12]
 80072a0:	e000      	b.n	80072a4 <STC3115_Powerdown+0x3a>
  
  return (OK);
 80072a2:	2300      	movs	r3, #0
}
 80072a4:	4618      	mov	r0, r3
 80072a6:	3710      	adds	r7, #16
 80072a8:	46bd      	mov	sp, r7
 80072aa:	bd80      	pop	{r7, pc}

080072ac <STC3115_conv>:
 * @param value 
 * @param factor 
 * @retval Converted value (result = value * factor / 4096)
 */
static int STC3115_conv(short value, unsigned short factor)
{
 80072ac:	b480      	push	{r7}
 80072ae:	b085      	sub	sp, #20
 80072b0:	af00      	add	r7, sp, #0
 80072b2:	4603      	mov	r3, r0
 80072b4:	460a      	mov	r2, r1
 80072b6:	80fb      	strh	r3, [r7, #6]
 80072b8:	4613      	mov	r3, r2
 80072ba:	80bb      	strh	r3, [r7, #4]
  int v;
  
  v = ( (long) value * factor ) >> 11;
 80072bc:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 80072c0:	88ba      	ldrh	r2, [r7, #4]
 80072c2:	fb02 f303 	mul.w	r3, r2, r3
 80072c6:	12db      	asrs	r3, r3, #11
 80072c8:	60fb      	str	r3, [r7, #12]
  v = (v+1)/2;
 80072ca:	68fb      	ldr	r3, [r7, #12]
 80072cc:	3301      	adds	r3, #1
 80072ce:	0fda      	lsrs	r2, r3, #31
 80072d0:	4413      	add	r3, r2
 80072d2:	105b      	asrs	r3, r3, #1
 80072d4:	60fb      	str	r3, [r7, #12]
  
  return (v);
 80072d6:	68fb      	ldr	r3, [r7, #12]
}
 80072d8:	4618      	mov	r0, r3
 80072da:	3714      	adds	r7, #20
 80072dc:	46bd      	mov	sp, r7
 80072de:	f85d 7b04 	ldr.w	r7, [sp], #4
 80072e2:	4770      	bx	lr

080072e4 <STC3115_Startup>:
 * @brief Initialize and start the STC3115 at application startup
 * @param Pointer to STC3115 Configuration Data structure
 * @retval 0 if ok, -1 if error
 */
static int STC3115_Startup(DrvContextTypeDef* handle, STC3115_ConfigData_TypeDef *ConfigData)
{
 80072e4:	b580      	push	{r7, lr}
 80072e6:	b084      	sub	sp, #16
 80072e8:	af00      	add	r7, sp, #0
 80072ea:	6078      	str	r0, [r7, #4]
 80072ec:	6039      	str	r1, [r7, #0]
  int res;
  int ocv;
  
  /* check STC310x status */
  res = STC3115_Status(handle);
 80072ee:	6878      	ldr	r0, [r7, #4]
 80072f0:	f7ff fe09 	bl	8006f06 <STC3115_Status>
 80072f4:	60f8      	str	r0, [r7, #12]
  if (res < 0) return(res);
 80072f6:	68fb      	ldr	r3, [r7, #12]
 80072f8:	2b00      	cmp	r3, #0
 80072fa:	da01      	bge.n	8007300 <STC3115_Startup+0x1c>
 80072fc:	68fb      	ldr	r3, [r7, #12]
 80072fe:	e01f      	b.n	8007340 <STC3115_Startup+0x5c>
  
  /* read OCV */
  if (STC3115_ReadWord(handle, STC3115_REG_OCV, &ocv) == -1)
 8007300:	f107 0308 	add.w	r3, r7, #8
 8007304:	461a      	mov	r2, r3
 8007306:	210d      	movs	r1, #13
 8007308:	6878      	ldr	r0, [r7, #4]
 800730a:	f000 f853 	bl	80073b4 <STC3115_ReadWord>
 800730e:	4603      	mov	r3, r0
 8007310:	f1b3 3fff 	cmp.w	r3, #4294967295
 8007314:	d102      	bne.n	800731c <STC3115_Startup+0x38>
	return -1;
 8007316:	f04f 33ff 	mov.w	r3, #4294967295
 800731a:	e011      	b.n	8007340 <STC3115_Startup+0x5c>
  
  STC3115_SetParam(handle, ConfigData);  /* set STC3115 parameters  */
 800731c:	6839      	ldr	r1, [r7, #0]
 800731e:	6878      	ldr	r0, [r7, #4]
 8007320:	f000 f882 	bl	8007428 <STC3115_SetParam>
  
  /* rewrite ocv to start SOC with updated OCV curve */
  if (STC3115_WriteWord(handle, STC3115_REG_OCV, ocv) == -1)
 8007324:	68bb      	ldr	r3, [r7, #8]
 8007326:	461a      	mov	r2, r3
 8007328:	210d      	movs	r1, #13
 800732a:	6878      	ldr	r0, [r7, #4]
 800732c:	f000 f85f 	bl	80073ee <STC3115_WriteWord>
 8007330:	4603      	mov	r3, r0
 8007332:	f1b3 3fff 	cmp.w	r3, #4294967295
 8007336:	d102      	bne.n	800733e <STC3115_Startup+0x5a>
	return -1;
 8007338:	f04f 33ff 	mov.w	r3, #4294967295
 800733c:	e000      	b.n	8007340 <STC3115_Startup+0x5c>
  
  return 0;
 800733e:	2300      	movs	r3, #0
}
 8007340:	4618      	mov	r0, r3
 8007342:	3710      	adds	r7, #16
 8007344:	46bd      	mov	sp, r7
 8007346:	bd80      	pop	{r7, pc}

08007348 <STC3115_Read>:
 * @param  RegAddress STC3115 register to read
 * @param  value pointer to integer where to store data
 * @retval Error code: 0 ok, -1 error
 */
static int STC3115_Read(DrvContextTypeDef* handle, uint8_t RegAddress, uint8_t *data, uint16_t NumByteToRead)
{
 8007348:	b580      	push	{r7, lr}
 800734a:	b084      	sub	sp, #16
 800734c:	af00      	add	r7, sp, #0
 800734e:	60f8      	str	r0, [r7, #12]
 8007350:	607a      	str	r2, [r7, #4]
 8007352:	461a      	mov	r2, r3
 8007354:	460b      	mov	r3, r1
 8007356:	72fb      	strb	r3, [r7, #11]
 8007358:	4613      	mov	r3, r2
 800735a:	813b      	strh	r3, [r7, #8]
  if (Sensor_IO_Read(handle, RegAddress, data, NumByteToRead))
 800735c:	893b      	ldrh	r3, [r7, #8]
 800735e:	7af9      	ldrb	r1, [r7, #11]
 8007360:	687a      	ldr	r2, [r7, #4]
 8007362:	68f8      	ldr	r0, [r7, #12]
 8007364:	f005 fee1 	bl	800d12a <Sensor_IO_Read>
 8007368:	4603      	mov	r3, r0
 800736a:	2b00      	cmp	r3, #0
 800736c:	d002      	beq.n	8007374 <STC3115_Read+0x2c>
  {
    return -1;
 800736e:	f04f 33ff 	mov.w	r3, #4294967295
 8007372:	e000      	b.n	8007376 <STC3115_Read+0x2e>
  }
  else
  {
    return 0;
 8007374:	2300      	movs	r3, #0
  }
}
 8007376:	4618      	mov	r0, r3
 8007378:	3710      	adds	r7, #16
 800737a:	46bd      	mov	sp, r7
 800737c:	bd80      	pop	{r7, pc}

0800737e <STC3115_Write>:
 * @param RegAddress STC3115 register
 * @param value value to write
 * @retval Error code: 0 ok, -1 error
 */
static int STC3115_Write(DrvContextTypeDef* handle, uint8_t RegAddress, uint8_t *data, uint16_t NumByteToWrite)
{
 800737e:	b580      	push	{r7, lr}
 8007380:	b084      	sub	sp, #16
 8007382:	af00      	add	r7, sp, #0
 8007384:	60f8      	str	r0, [r7, #12]
 8007386:	607a      	str	r2, [r7, #4]
 8007388:	461a      	mov	r2, r3
 800738a:	460b      	mov	r3, r1
 800738c:	72fb      	strb	r3, [r7, #11]
 800738e:	4613      	mov	r3, r2
 8007390:	813b      	strh	r3, [r7, #8]
  if (Sensor_IO_Write(handle, RegAddress, data, NumByteToWrite))
 8007392:	893b      	ldrh	r3, [r7, #8]
 8007394:	7af9      	ldrb	r1, [r7, #11]
 8007396:	687a      	ldr	r2, [r7, #4]
 8007398:	68f8      	ldr	r0, [r7, #12]
 800739a:	f005 fea8 	bl	800d0ee <Sensor_IO_Write>
 800739e:	4603      	mov	r3, r0
 80073a0:	2b00      	cmp	r3, #0
 80073a2:	d002      	beq.n	80073aa <STC3115_Write+0x2c>
  {
    return -1;
 80073a4:	f04f 33ff 	mov.w	r3, #4294967295
 80073a8:	e000      	b.n	80073ac <STC3115_Write+0x2e>
  }
  else
  {
    return 0;
 80073aa:	2300      	movs	r3, #0
  }
}
 80073ac:	4618      	mov	r0, r3
 80073ae:	3710      	adds	r7, #16
 80073b0:	46bd      	mov	sp, r7
 80073b2:	bd80      	pop	{r7, pc}

080073b4 <STC3115_ReadWord>:
 * @param RegAddress STC3115 register
 * @param value pointer to integer value where to store data
 * @retval Error code: 0 ok, -1 error
 */
static int STC3115_ReadWord(DrvContextTypeDef* handle, uint8_t RegAddress, int* value)
{
 80073b4:	b580      	push	{r7, lr}
 80073b6:	b086      	sub	sp, #24
 80073b8:	af00      	add	r7, sp, #0
 80073ba:	60f8      	str	r0, [r7, #12]
 80073bc:	460b      	mov	r3, r1
 80073be:	607a      	str	r2, [r7, #4]
 80073c0:	72fb      	strb	r3, [r7, #11]
  uint16_t tmp;
  
  if (Sensor_IO_Read(handle, RegAddress, (uint8_t*)&tmp, 2))
 80073c2:	f107 0216 	add.w	r2, r7, #22
 80073c6:	7af9      	ldrb	r1, [r7, #11]
 80073c8:	2302      	movs	r3, #2
 80073ca:	68f8      	ldr	r0, [r7, #12]
 80073cc:	f005 fead 	bl	800d12a <Sensor_IO_Read>
 80073d0:	4603      	mov	r3, r0
 80073d2:	2b00      	cmp	r3, #0
 80073d4:	d002      	beq.n	80073dc <STC3115_ReadWord+0x28>
  {
    return -1;
 80073d6:	f04f 33ff 	mov.w	r3, #4294967295
 80073da:	e004      	b.n	80073e6 <STC3115_ReadWord+0x32>
  }
  else
  {
    *value = tmp & 0xffff;
 80073dc:	8afb      	ldrh	r3, [r7, #22]
 80073de:	461a      	mov	r2, r3
 80073e0:	687b      	ldr	r3, [r7, #4]
 80073e2:	601a      	str	r2, [r3, #0]
    return 0;
 80073e4:	2300      	movs	r3, #0
  }
}
 80073e6:	4618      	mov	r0, r3
 80073e8:	3718      	adds	r7, #24
 80073ea:	46bd      	mov	sp, r7
 80073ec:	bd80      	pop	{r7, pc}

080073ee <STC3115_WriteWord>:
 * @param RegAddress STC3115 register
 * @param value value to write
 * @retval Error code: 0 ok, -1 error
 */
static int STC3115_WriteWord(DrvContextTypeDef* handle, uint8_t RegAddress, int value)
{
 80073ee:	b580      	push	{r7, lr}
 80073f0:	b086      	sub	sp, #24
 80073f2:	af00      	add	r7, sp, #0
 80073f4:	60f8      	str	r0, [r7, #12]
 80073f6:	460b      	mov	r3, r1
 80073f8:	607a      	str	r2, [r7, #4]
 80073fa:	72fb      	strb	r3, [r7, #11]
  uint16_t tmp = value & 0xffff;
 80073fc:	687b      	ldr	r3, [r7, #4]
 80073fe:	b29b      	uxth	r3, r3
 8007400:	82fb      	strh	r3, [r7, #22]
  
  if (Sensor_IO_Write(handle, RegAddress, (uint8_t*)&tmp, 2))
 8007402:	f107 0216 	add.w	r2, r7, #22
 8007406:	7af9      	ldrb	r1, [r7, #11]
 8007408:	2302      	movs	r3, #2
 800740a:	68f8      	ldr	r0, [r7, #12]
 800740c:	f005 fe6f 	bl	800d0ee <Sensor_IO_Write>
 8007410:	4603      	mov	r3, r0
 8007412:	2b00      	cmp	r3, #0
 8007414:	d002      	beq.n	800741c <STC3115_WriteWord+0x2e>
  {
    return -1;
 8007416:	f04f 33ff 	mov.w	r3, #4294967295
 800741a:	e000      	b.n	800741e <STC3115_WriteWord+0x30>
  }
  else
  {
    return 0;
 800741c:	2300      	movs	r3, #0
  }
}
 800741e:	4618      	mov	r0, r3
 8007420:	3718      	adds	r7, #24
 8007422:	46bd      	mov	sp, r7
 8007424:	bd80      	pop	{r7, pc}
	...

08007428 <STC3115_SetParam>:
 * @brief Initialize the STC3115 parameters
 * @param ConfigData Pointer to STC3115 Configuration Data structure
 * @retval None
 */
static DrvStatusTypeDef STC3115_SetParam(DrvContextTypeDef* handle, STC3115_ConfigData_TypeDef *ConfigData)
{
 8007428:	b580      	push	{r7, lr}
 800742a:	b084      	sub	sp, #16
 800742c:	af00      	add	r7, sp, #0
 800742e:	6078      	str	r0, [r7, #4]
 8007430:	6039      	str	r1, [r7, #0]
  uint8_t data;
  RAMData_TypeDef *RAMData = &(( STC3115_Data_t * )(( GG_Data_t * )handle->pData)->pComponentData)->ramData;
 8007432:	687b      	ldr	r3, [r7, #4]
 8007434:	689b      	ldr	r3, [r3, #8]
 8007436:	681b      	ldr	r3, [r3, #0]
 8007438:	335c      	adds	r3, #92	@ 0x5c
 800743a:	60fb      	str	r3, [r7, #12]
  
  /* set GG_RUN=0 before changing algo parameters */
  data = STC3115_VMODE;
 800743c:	2301      	movs	r3, #1
 800743e:	72fb      	strb	r3, [r7, #11]
  STC3115_Write(handle, STC3115_REG_MODE, &data, 1);
 8007440:	f107 020b 	add.w	r2, r7, #11
 8007444:	2301      	movs	r3, #1
 8007446:	2100      	movs	r1, #0
 8007448:	6878      	ldr	r0, [r7, #4]
 800744a:	f7ff ff98 	bl	800737e <STC3115_Write>
  
  /* init OCV curve */
  STC3115_Write(handle, STC3115_REG_OCVTAB, (unsigned char *) ConfigData->OCVOffset, OCVTAB_SIZE);
 800744e:	683b      	ldr	r3, [r7, #0]
 8007450:	f103 0220 	add.w	r2, r3, #32
 8007454:	2310      	movs	r3, #16
 8007456:	2130      	movs	r1, #48	@ 0x30
 8007458:	6878      	ldr	r0, [r7, #4]
 800745a:	f7ff ff90 	bl	800737e <STC3115_Write>
  
  /* set alm level if different from default */
  if (ConfigData->Alm_SOC != 0 )
 800745e:	683b      	ldr	r3, [r7, #0]
 8007460:	685b      	ldr	r3, [r3, #4]
 8007462:	2b00      	cmp	r3, #0
 8007464:	d00c      	beq.n	8007480 <STC3115_SetParam+0x58>
  {
    data = ConfigData->Alm_SOC * 2;
 8007466:	683b      	ldr	r3, [r7, #0]
 8007468:	685b      	ldr	r3, [r3, #4]
 800746a:	b2db      	uxtb	r3, r3
 800746c:	005b      	lsls	r3, r3, #1
 800746e:	b2db      	uxtb	r3, r3
 8007470:	72fb      	strb	r3, [r7, #11]
    STC3115_Write(handle, STC3115_REG_ALARM_SOC, &data, 1);
 8007472:	f107 020b 	add.w	r2, r7, #11
 8007476:	2301      	movs	r3, #1
 8007478:	2113      	movs	r1, #19
 800747a:	6878      	ldr	r0, [r7, #4]
 800747c:	f7ff ff7f 	bl	800737e <STC3115_Write>
  }
  if (ConfigData->Alm_Vbat != 0 )
 8007480:	683b      	ldr	r3, [r7, #0]
 8007482:	689b      	ldr	r3, [r3, #8]
 8007484:	2b00      	cmp	r3, #0
 8007486:	d011      	beq.n	80074ac <STC3115_SetParam+0x84>
  {
    data = ((long)(ConfigData->Alm_Vbat << 9) / VoltageFactor); /* LSB=8*2.2mV */
 8007488:	683b      	ldr	r3, [r7, #0]
 800748a:	689b      	ldr	r3, [r3, #8]
 800748c:	025b      	lsls	r3, r3, #9
 800748e:	4a2f      	ldr	r2, [pc, #188]	@ (800754c <STC3115_SetParam+0x124>)
 8007490:	fb82 1203 	smull	r1, r2, r2, r3
 8007494:	1312      	asrs	r2, r2, #12
 8007496:	17db      	asrs	r3, r3, #31
 8007498:	1ad3      	subs	r3, r2, r3
 800749a:	b2db      	uxtb	r3, r3
 800749c:	72fb      	strb	r3, [r7, #11]
    STC3115_Write(handle, STC3115_REG_ALARM_VOLTAGE, &data, 1);
 800749e:	f107 020b 	add.w	r2, r7, #11
 80074a2:	2301      	movs	r3, #1
 80074a4:	2114      	movs	r1, #20
 80074a6:	6878      	ldr	r0, [r7, #4]
 80074a8:	f7ff ff69 	bl	800737e <STC3115_Write>
  }
  
  /* relaxation timer */
  if (ConfigData->Rsense != 0 )
 80074ac:	683b      	ldr	r3, [r7, #0]
 80074ae:	699b      	ldr	r3, [r3, #24]
 80074b0:	2b00      	cmp	r3, #0
 80074b2:	d013      	beq.n	80074dc <STC3115_SetParam+0xb4>
  {
    data = ((long)(ConfigData->RelaxCurrent << 9) / (CurrentFactor / ConfigData->Rsense));  /* LSB=8*5.88uV */
 80074b4:	683b      	ldr	r3, [r7, #0]
 80074b6:	69db      	ldr	r3, [r3, #28]
 80074b8:	025a      	lsls	r2, r3, #9
 80074ba:	683b      	ldr	r3, [r7, #0]
 80074bc:	699b      	ldr	r3, [r3, #24]
 80074be:	f645 6114 	movw	r1, #24084	@ 0x5e14
 80074c2:	fb91 f3f3 	sdiv	r3, r1, r3
 80074c6:	fb92 f3f3 	sdiv	r3, r2, r3
 80074ca:	b2db      	uxtb	r3, r3
 80074cc:	72fb      	strb	r3, [r7, #11]
    STC3115_Write(handle, STC3115_REG_CURRENT_THRES, &data, 1);
 80074ce:	f107 020b 	add.w	r2, r7, #11
 80074d2:	2301      	movs	r3, #1
 80074d4:	2115      	movs	r1, #21
 80074d6:	6878      	ldr	r0, [r7, #4]
 80074d8:	f7ff ff51 	bl	800737e <STC3115_Write>
  }
  
  /* set parameters if different from default, only if a restart is done (battery change) */
  if (RAMData->reg.CC_cnf != 0 ) STC3115_WriteWord(handle, STC3115_REG_CC_CNF, RAMData->reg.CC_cnf);
 80074dc:	68fb      	ldr	r3, [r7, #12]
 80074de:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 80074e2:	2b00      	cmp	r3, #0
 80074e4:	d007      	beq.n	80074f6 <STC3115_SetParam+0xce>
 80074e6:	68fb      	ldr	r3, [r7, #12]
 80074e8:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 80074ec:	461a      	mov	r2, r3
 80074ee:	210f      	movs	r1, #15
 80074f0:	6878      	ldr	r0, [r7, #4]
 80074f2:	f7ff ff7c 	bl	80073ee <STC3115_WriteWord>
  if (RAMData->reg.VM_cnf != 0 ) STC3115_WriteWord(handle, STC3115_REG_VM_CNF, RAMData->reg.VM_cnf);
 80074f6:	68fb      	ldr	r3, [r7, #12]
 80074f8:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 80074fc:	2b00      	cmp	r3, #0
 80074fe:	d007      	beq.n	8007510 <STC3115_SetParam+0xe8>
 8007500:	68fb      	ldr	r3, [r7, #12]
 8007502:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8007506:	461a      	mov	r2, r3
 8007508:	2111      	movs	r1, #17
 800750a:	6878      	ldr	r0, [r7, #4]
 800750c:	f7ff ff6f 	bl	80073ee <STC3115_WriteWord>
  
  data = 0x03;
 8007510:	2303      	movs	r3, #3
 8007512:	72fb      	strb	r3, [r7, #11]
  STC3115_Write(handle, STC3115_REG_CTRL, &data, 1); /*   clear PORDET, BATFAIL, free ALM pin, reset conv counter */
 8007514:	f107 020b 	add.w	r2, r7, #11
 8007518:	2301      	movs	r3, #1
 800751a:	2101      	movs	r1, #1
 800751c:	6878      	ldr	r0, [r7, #4]
 800751e:	f7ff ff2e 	bl	800737e <STC3115_Write>
  
  data = STC3115_GG_RUN | (STC3115_VMODE * ConfigData->Vmode) | (STC3115_ALM_ENA * ALM_EN);
 8007522:	683b      	ldr	r3, [r7, #0]
 8007524:	681b      	ldr	r3, [r3, #0]
 8007526:	b25b      	sxtb	r3, r3
 8007528:	f043 0310 	orr.w	r3, r3, #16
 800752c:	b25b      	sxtb	r3, r3
 800752e:	b2db      	uxtb	r3, r3
 8007530:	72fb      	strb	r3, [r7, #11]
  STC3115_Write(handle, STC3115_REG_MODE, &data, 1);  /*   set GG_RUN=1, set mode, set alm enable */
 8007532:	f107 020b 	add.w	r2, r7, #11
 8007536:	2301      	movs	r3, #1
 8007538:	2100      	movs	r1, #0
 800753a:	6878      	ldr	r0, [r7, #4]
 800753c:	f7ff ff1f 	bl	800737e <STC3115_Write>
  
  return COMPONENT_OK;
 8007540:	2300      	movs	r3, #0
}
 8007542:	4618      	mov	r0, r3
 8007544:	3710      	adds	r7, #16
 8007546:	46bd      	mov	sp, r7
 8007548:	bd80      	pop	{r7, pc}
 800754a:	bf00      	nop
 800754c:	745dc089 	.word	0x745dc089

08007550 <LIS2DU12_RegisterBusIO>:
  * @brief  Register Component Bus IO operations
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2DU12_RegisterBusIO(LIS2DU12_Object_t *pObj, LIS2DU12_IO_t *pIO)
{
 8007550:	b580      	push	{r7, lr}
 8007552:	b084      	sub	sp, #16
 8007554:	af00      	add	r7, sp, #0
 8007556:	6078      	str	r0, [r7, #4]
 8007558:	6039      	str	r1, [r7, #0]
  int32_t ret = LIS2DU12_OK;
 800755a:	2300      	movs	r3, #0
 800755c:	60fb      	str	r3, [r7, #12]

  if (pObj == NULL)
 800755e:	687b      	ldr	r3, [r7, #4]
 8007560:	2b00      	cmp	r3, #0
 8007562:	d103      	bne.n	800756c <LIS2DU12_RegisterBusIO+0x1c>
  {
    ret = LIS2DU12_ERROR;
 8007564:	f04f 33ff 	mov.w	r3, #4294967295
 8007568:	60fb      	str	r3, [r7, #12]
 800756a:	e051      	b.n	8007610 <LIS2DU12_RegisterBusIO+0xc0>
  }
  else
  {
    pObj->IO.Init      = pIO->Init;
 800756c:	683b      	ldr	r3, [r7, #0]
 800756e:	681a      	ldr	r2, [r3, #0]
 8007570:	687b      	ldr	r3, [r7, #4]
 8007572:	601a      	str	r2, [r3, #0]
    pObj->IO.DeInit    = pIO->DeInit;
 8007574:	683b      	ldr	r3, [r7, #0]
 8007576:	685a      	ldr	r2, [r3, #4]
 8007578:	687b      	ldr	r3, [r7, #4]
 800757a:	605a      	str	r2, [r3, #4]
    pObj->IO.BusType   = pIO->BusType;
 800757c:	683b      	ldr	r3, [r7, #0]
 800757e:	689a      	ldr	r2, [r3, #8]
 8007580:	687b      	ldr	r3, [r7, #4]
 8007582:	609a      	str	r2, [r3, #8]
    pObj->IO.Address   = pIO->Address;
 8007584:	683b      	ldr	r3, [r7, #0]
 8007586:	7b1a      	ldrb	r2, [r3, #12]
 8007588:	687b      	ldr	r3, [r7, #4]
 800758a:	731a      	strb	r2, [r3, #12]
    pObj->IO.WriteReg  = pIO->WriteReg;
 800758c:	683b      	ldr	r3, [r7, #0]
 800758e:	691a      	ldr	r2, [r3, #16]
 8007590:	687b      	ldr	r3, [r7, #4]
 8007592:	611a      	str	r2, [r3, #16]
    pObj->IO.ReadReg   = pIO->ReadReg;
 8007594:	683b      	ldr	r3, [r7, #0]
 8007596:	695a      	ldr	r2, [r3, #20]
 8007598:	687b      	ldr	r3, [r7, #4]
 800759a:	615a      	str	r2, [r3, #20]
    pObj->IO.GetTick   = pIO->GetTick;
 800759c:	683b      	ldr	r3, [r7, #0]
 800759e:	699a      	ldr	r2, [r3, #24]
 80075a0:	687b      	ldr	r3, [r7, #4]
 80075a2:	619a      	str	r2, [r3, #24]

    pObj->Ctx.read_reg  = ReadRegWrap;
 80075a4:	687b      	ldr	r3, [r7, #4]
 80075a6:	4a1d      	ldr	r2, [pc, #116]	@ (800761c <LIS2DU12_RegisterBusIO+0xcc>)
 80075a8:	625a      	str	r2, [r3, #36]	@ 0x24
    pObj->Ctx.write_reg = WriteRegWrap;
 80075aa:	687b      	ldr	r3, [r7, #4]
 80075ac:	4a1c      	ldr	r2, [pc, #112]	@ (8007620 <LIS2DU12_RegisterBusIO+0xd0>)
 80075ae:	621a      	str	r2, [r3, #32]
    pObj->Ctx.mdelay    = pIO->Delay;
 80075b0:	683b      	ldr	r3, [r7, #0]
 80075b2:	69da      	ldr	r2, [r3, #28]
 80075b4:	687b      	ldr	r3, [r7, #4]
 80075b6:	629a      	str	r2, [r3, #40]	@ 0x28
    pObj->Ctx.handle   = pObj;
 80075b8:	687b      	ldr	r3, [r7, #4]
 80075ba:	687a      	ldr	r2, [r7, #4]
 80075bc:	62da      	str	r2, [r3, #44]	@ 0x2c

    if (pObj->IO.Init == NULL)
 80075be:	687b      	ldr	r3, [r7, #4]
 80075c0:	681b      	ldr	r3, [r3, #0]
 80075c2:	2b00      	cmp	r3, #0
 80075c4:	d103      	bne.n	80075ce <LIS2DU12_RegisterBusIO+0x7e>
    {
      ret = LIS2DU12_ERROR;
 80075c6:	f04f 33ff 	mov.w	r3, #4294967295
 80075ca:	60fb      	str	r3, [r7, #12]
 80075cc:	e020      	b.n	8007610 <LIS2DU12_RegisterBusIO+0xc0>
    }
    else if (pObj->IO.Init() != LIS2DU12_OK)
 80075ce:	687b      	ldr	r3, [r7, #4]
 80075d0:	681b      	ldr	r3, [r3, #0]
 80075d2:	4798      	blx	r3
 80075d4:	4603      	mov	r3, r0
 80075d6:	2b00      	cmp	r3, #0
 80075d8:	d003      	beq.n	80075e2 <LIS2DU12_RegisterBusIO+0x92>
    {
      ret = LIS2DU12_ERROR;
 80075da:	f04f 33ff 	mov.w	r3, #4294967295
 80075de:	60fb      	str	r3, [r7, #12]
 80075e0:	e016      	b.n	8007610 <LIS2DU12_RegisterBusIO+0xc0>
    }
    else
    {
      if (pObj->IO.BusType == LIS2DU12_SPI_3WIRES_BUS) /* SPI 3-Wires */
 80075e2:	687b      	ldr	r3, [r7, #4]
 80075e4:	689b      	ldr	r3, [r3, #8]
 80075e6:	2b02      	cmp	r3, #2
 80075e8:	d112      	bne.n	8007610 <LIS2DU12_RegisterBusIO+0xc0>
      {
        /* Enable the SPI 3-Wires support only the first time */
        if (pObj->is_initialized == 0U)
 80075ea:	687b      	ldr	r3, [r7, #4]
 80075ec:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
 80075f0:	2b00      	cmp	r3, #0
 80075f2:	d10d      	bne.n	8007610 <LIS2DU12_RegisterBusIO+0xc0>
        {
          /* Enable SPI 3-Wires on the component */
          uint8_t data = 0x50;
 80075f4:	2350      	movs	r3, #80	@ 0x50
 80075f6:	72fb      	strb	r3, [r7, #11]

          if (LIS2DU12_Write_Reg(pObj, LIS2DU12_CTRL1, data) != LIS2DU12_OK)
 80075f8:	7afb      	ldrb	r3, [r7, #11]
 80075fa:	461a      	mov	r2, r3
 80075fc:	2110      	movs	r1, #16
 80075fe:	6878      	ldr	r0, [r7, #4]
 8007600:	f000 fb13 	bl	8007c2a <LIS2DU12_Write_Reg>
 8007604:	4603      	mov	r3, r0
 8007606:	2b00      	cmp	r3, #0
 8007608:	d002      	beq.n	8007610 <LIS2DU12_RegisterBusIO+0xc0>
          {
            ret = LIS2DU12_ERROR;
 800760a:	f04f 33ff 	mov.w	r3, #4294967295
 800760e:	60fb      	str	r3, [r7, #12]
        }
      }
    }
  }

  return ret;
 8007610:	68fb      	ldr	r3, [r7, #12]
}
 8007612:	4618      	mov	r0, r3
 8007614:	3710      	adds	r7, #16
 8007616:	46bd      	mov	sp, r7
 8007618:	bd80      	pop	{r7, pc}
 800761a:	bf00      	nop
 800761c:	08007f8d 	.word	0x08007f8d
 8007620:	08007fc3 	.word	0x08007fc3

08007624 <LIS2DU12_Init>:
  * @brief  Initialize the LIS2DU12 sensor
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2DU12_Init(LIS2DU12_Object_t *pObj)
{
 8007624:	b580      	push	{r7, lr}
 8007626:	b084      	sub	sp, #16
 8007628:	af00      	add	r7, sp, #0
 800762a:	6078      	str	r0, [r7, #4]
  if(pObj->IO.BusType != LIS2DU12_I3C_BUS)
 800762c:	687b      	ldr	r3, [r7, #4]
 800762e:	689b      	ldr	r3, [r3, #8]
 8007630:	2b03      	cmp	r3, #3
 8007632:	d00b      	beq.n	800764c <LIS2DU12_Init+0x28>
  {
    /* Disable I3C */
    if (lis2du12_bus_mode_set(&(pObj->Ctx), LIS2DU12_I3C_DISABLE) != LIS2DU12_OK)
 8007634:	687b      	ldr	r3, [r7, #4]
 8007636:	3320      	adds	r3, #32
 8007638:	2101      	movs	r1, #1
 800763a:	4618      	mov	r0, r3
 800763c:	f000 fdbd 	bl	80081ba <lis2du12_bus_mode_set>
 8007640:	4603      	mov	r3, r0
 8007642:	2b00      	cmp	r3, #0
 8007644:	d002      	beq.n	800764c <LIS2DU12_Init+0x28>
    {
      return LIS2DU12_ERROR;
 8007646:	f04f 33ff 	mov.w	r3, #4294967295
 800764a:	e040      	b.n	80076ce <LIS2DU12_Init+0xaa>
    }
  }

  /* Enable register address automatically incremented during a multiple byte
  access with a serial interface. Enable BDU. */
  if (lis2du12_init_set(&(pObj->Ctx), LIS2DU12_DRV_RDY) != LIS2DU12_OK)
 800764c:	687b      	ldr	r3, [r7, #4]
 800764e:	3320      	adds	r3, #32
 8007650:	2100      	movs	r1, #0
 8007652:	4618      	mov	r0, r3
 8007654:	f000 fdff 	bl	8008256 <lis2du12_init_set>
 8007658:	4603      	mov	r3, r0
 800765a:	2b00      	cmp	r3, #0
 800765c:	d002      	beq.n	8007664 <LIS2DU12_Init+0x40>
  {
    return LIS2DU12_ERROR;
 800765e:	f04f 33ff 	mov.w	r3, #4294967295
 8007662:	e034      	b.n	80076ce <LIS2DU12_Init+0xaa>
  }

  /* FIFO mode selection */
  lis2du12_fifo_md_t fifo_mode =
 8007664:	2300      	movs	r3, #0
 8007666:	733b      	strb	r3, [r7, #12]
 8007668:	2301      	movs	r3, #1
 800766a:	737b      	strb	r3, [r7, #13]
 800766c:	2300      	movs	r3, #0
 800766e:	73bb      	strb	r3, [r7, #14]
    .operation = LIS2DU12_BYPASS,
    .store     = LIS2DU12_16_BIT,
    .watermark = 0,
  };

  if (lis2du12_fifo_mode_set(&(pObj->Ctx), &fifo_mode) != LIS2DU12_OK)
 8007670:	687b      	ldr	r3, [r7, #4]
 8007672:	3320      	adds	r3, #32
 8007674:	f107 020c 	add.w	r2, r7, #12
 8007678:	4611      	mov	r1, r2
 800767a:	4618      	mov	r0, r3
 800767c:	f001 f816 	bl	80086ac <lis2du12_fifo_mode_set>
 8007680:	4603      	mov	r3, r0
 8007682:	2b00      	cmp	r3, #0
 8007684:	d002      	beq.n	800768c <LIS2DU12_Init+0x68>
  {
    return LIS2DU12_ERROR;
 8007686:	f04f 33ff 	mov.w	r3, #4294967295
 800768a:	e020      	b.n	80076ce <LIS2DU12_Init+0xaa>
  }

  /* Select default output data rate. */
  pObj->acc_odr = 100.0f;
 800768c:	687b      	ldr	r3, [r7, #4]
 800768e:	4a12      	ldr	r2, [pc, #72]	@ (80076d8 <LIS2DU12_Init+0xb4>)
 8007690:	635a      	str	r2, [r3, #52]	@ 0x34
  /* Select default ultra low power (disabled). */
  pObj->acc_ultra_low_power = LIS2DU12_ULTRA_LOW_POWER_DISABLE;
 8007692:	687b      	ldr	r3, [r7, #4]
 8007694:	2200      	movs	r2, #0
 8007696:	f883 2038 	strb.w	r2, [r3, #56]	@ 0x38

  /* Output data rate: power down, full scale: 2g */
  lis2du12_md_t mode =
 800769a:	f107 0308 	add.w	r3, r7, #8
 800769e:	2100      	movs	r1, #0
 80076a0:	460a      	mov	r2, r1
 80076a2:	801a      	strh	r2, [r3, #0]
 80076a4:	460a      	mov	r2, r1
 80076a6:	709a      	strb	r2, [r3, #2]
  {
    .odr = LIS2DU12_OFF,
    .fs  = LIS2DU12_2g,
  };

  if (lis2du12_mode_set(&(pObj->Ctx), &mode) != LIS2DU12_OK)
 80076a8:	687b      	ldr	r3, [r7, #4]
 80076aa:	3320      	adds	r3, #32
 80076ac:	f107 0208 	add.w	r2, r7, #8
 80076b0:	4611      	mov	r1, r2
 80076b2:	4618      	mov	r0, r3
 80076b4:	f000 fe37 	bl	8008326 <lis2du12_mode_set>
 80076b8:	4603      	mov	r3, r0
 80076ba:	2b00      	cmp	r3, #0
 80076bc:	d002      	beq.n	80076c4 <LIS2DU12_Init+0xa0>
  {
    return LIS2DU12_ERROR;
 80076be:	f04f 33ff 	mov.w	r3, #4294967295
 80076c2:	e004      	b.n	80076ce <LIS2DU12_Init+0xaa>
  }

  pObj->is_initialized = 1;
 80076c4:	687b      	ldr	r3, [r7, #4]
 80076c6:	2201      	movs	r2, #1
 80076c8:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30

  return LIS2DU12_OK;
 80076cc:	2300      	movs	r3, #0
}
 80076ce:	4618      	mov	r0, r3
 80076d0:	3710      	adds	r7, #16
 80076d2:	46bd      	mov	sp, r7
 80076d4:	bd80      	pop	{r7, pc}
 80076d6:	bf00      	nop
 80076d8:	42c80000 	.word	0x42c80000

080076dc <LIS2DU12_DeInit>:
  * @brief  Deinitialize the LIS2DU12 sensor
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2DU12_DeInit(LIS2DU12_Object_t *pObj)
{
 80076dc:	b580      	push	{r7, lr}
 80076de:	b082      	sub	sp, #8
 80076e0:	af00      	add	r7, sp, #0
 80076e2:	6078      	str	r0, [r7, #4]
  /* Disable the component */
  if (LIS2DU12_ACC_Disable(pObj) != LIS2DU12_OK)
 80076e4:	6878      	ldr	r0, [r7, #4]
 80076e6:	f000 f884 	bl	80077f2 <LIS2DU12_ACC_Disable>
 80076ea:	4603      	mov	r3, r0
 80076ec:	2b00      	cmp	r3, #0
 80076ee:	d002      	beq.n	80076f6 <LIS2DU12_DeInit+0x1a>
  {
    return LIS2DU12_ERROR;
 80076f0:	f04f 33ff 	mov.w	r3, #4294967295
 80076f4:	e00c      	b.n	8007710 <LIS2DU12_DeInit+0x34>
  }

  /* Reset output data rate. */
  pObj->acc_odr = 0.0f;
 80076f6:	687b      	ldr	r3, [r7, #4]
 80076f8:	f04f 0200 	mov.w	r2, #0
 80076fc:	635a      	str	r2, [r3, #52]	@ 0x34
  /* Reset ultra low power to default value (disabled). */
  pObj->acc_ultra_low_power = LIS2DU12_ULTRA_LOW_POWER_DISABLE;
 80076fe:	687b      	ldr	r3, [r7, #4]
 8007700:	2200      	movs	r2, #0
 8007702:	f883 2038 	strb.w	r2, [r3, #56]	@ 0x38

  pObj->is_initialized = 0;
 8007706:	687b      	ldr	r3, [r7, #4]
 8007708:	2200      	movs	r2, #0
 800770a:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30

  return LIS2DU12_OK;
 800770e:	2300      	movs	r3, #0
}
 8007710:	4618      	mov	r0, r3
 8007712:	3708      	adds	r7, #8
 8007714:	46bd      	mov	sp, r7
 8007716:	bd80      	pop	{r7, pc}

08007718 <LIS2DU12_ReadID>:
  * @param  pObj the device pObj
  * @param  Id the WHO_AM_I value
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2DU12_ReadID(LIS2DU12_Object_t *pObj, uint8_t *Id)
{
 8007718:	b580      	push	{r7, lr}
 800771a:	b084      	sub	sp, #16
 800771c:	af00      	add	r7, sp, #0
 800771e:	6078      	str	r0, [r7, #4]
 8007720:	6039      	str	r1, [r7, #0]
  lis2du12_id_t val;

  if (lis2du12_id_get(&(pObj->Ctx), &val) != LIS2DU12_OK)
 8007722:	687b      	ldr	r3, [r7, #4]
 8007724:	3320      	adds	r3, #32
 8007726:	f107 020c 	add.w	r2, r7, #12
 800772a:	4611      	mov	r1, r2
 800772c:	4618      	mov	r0, r3
 800772e:	f000 fd2f 	bl	8008190 <lis2du12_id_get>
 8007732:	4603      	mov	r3, r0
 8007734:	2b00      	cmp	r3, #0
 8007736:	d002      	beq.n	800773e <LIS2DU12_ReadID+0x26>
  {
    return LIS2DU12_ERROR;
 8007738:	f04f 33ff 	mov.w	r3, #4294967295
 800773c:	e003      	b.n	8007746 <LIS2DU12_ReadID+0x2e>
  }

  *Id = val.whoami;
 800773e:	7b3a      	ldrb	r2, [r7, #12]
 8007740:	683b      	ldr	r3, [r7, #0]
 8007742:	701a      	strb	r2, [r3, #0]

  return LIS2DU12_OK;
 8007744:	2300      	movs	r3, #0
}
 8007746:	4618      	mov	r0, r3
 8007748:	3710      	adds	r7, #16
 800774a:	46bd      	mov	sp, r7
 800774c:	bd80      	pop	{r7, pc}
	...

08007750 <LIS2DU12_GetCapabilities>:
  * @param  pObj Component object pointer
  * @param  Capabilities pointer to LIS2DU12 sensor capabilities
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2DU12_GetCapabilities(LIS2DU12_Object_t *pObj, LIS2DU12_Capabilities_t *Capabilities)
{
 8007750:	b480      	push	{r7}
 8007752:	b083      	sub	sp, #12
 8007754:	af00      	add	r7, sp, #0
 8007756:	6078      	str	r0, [r7, #4]
 8007758:	6039      	str	r1, [r7, #0]
  /* Prevent unused argument(s) compilation warning */
  (void)(pObj);

  Capabilities->Acc        = 1;
 800775a:	683b      	ldr	r3, [r7, #0]
 800775c:	2201      	movs	r2, #1
 800775e:	701a      	strb	r2, [r3, #0]
  Capabilities->Gyro       = 0;
 8007760:	683b      	ldr	r3, [r7, #0]
 8007762:	2200      	movs	r2, #0
 8007764:	705a      	strb	r2, [r3, #1]
  Capabilities->Magneto    = 0;
 8007766:	683b      	ldr	r3, [r7, #0]
 8007768:	2200      	movs	r2, #0
 800776a:	709a      	strb	r2, [r3, #2]
  Capabilities->LowPower   = 1;
 800776c:	683b      	ldr	r3, [r7, #0]
 800776e:	2201      	movs	r2, #1
 8007770:	70da      	strb	r2, [r3, #3]
  Capabilities->GyroMaxFS  = 0;
 8007772:	683b      	ldr	r3, [r7, #0]
 8007774:	2200      	movs	r2, #0
 8007776:	605a      	str	r2, [r3, #4]
  Capabilities->AccMaxFS   = 16;
 8007778:	683b      	ldr	r3, [r7, #0]
 800777a:	2210      	movs	r2, #16
 800777c:	609a      	str	r2, [r3, #8]
  Capabilities->MagMaxFS   = 0;
 800777e:	683b      	ldr	r3, [r7, #0]
 8007780:	2200      	movs	r2, #0
 8007782:	60da      	str	r2, [r3, #12]
  Capabilities->GyroMaxOdr = 0.0f;
 8007784:	683b      	ldr	r3, [r7, #0]
 8007786:	f04f 0200 	mov.w	r2, #0
 800778a:	611a      	str	r2, [r3, #16]
  Capabilities->AccMaxOdr  = 800.0f;
 800778c:	683b      	ldr	r3, [r7, #0]
 800778e:	4a06      	ldr	r2, [pc, #24]	@ (80077a8 <LIS2DU12_GetCapabilities+0x58>)
 8007790:	615a      	str	r2, [r3, #20]
  Capabilities->MagMaxOdr  = 0.0f;
 8007792:	683b      	ldr	r3, [r7, #0]
 8007794:	f04f 0200 	mov.w	r2, #0
 8007798:	619a      	str	r2, [r3, #24]
  return LIS2DU12_OK;
 800779a:	2300      	movs	r3, #0
}
 800779c:	4618      	mov	r0, r3
 800779e:	370c      	adds	r7, #12
 80077a0:	46bd      	mov	sp, r7
 80077a2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80077a6:	4770      	bx	lr
 80077a8:	44480000 	.word	0x44480000

080077ac <LIS2DU12_ACC_Enable>:
  * @brief  Enable the LIS2DU12 accelerometer sensor
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2DU12_ACC_Enable(LIS2DU12_Object_t *pObj)
{
 80077ac:	b580      	push	{r7, lr}
 80077ae:	b082      	sub	sp, #8
 80077b0:	af00      	add	r7, sp, #0
 80077b2:	6078      	str	r0, [r7, #4]
  /* Check if the component is already enabled */
  if (pObj->acc_is_enabled == 1U)
 80077b4:	687b      	ldr	r3, [r7, #4]
 80077b6:	f893 3031 	ldrb.w	r3, [r3, #49]	@ 0x31
 80077ba:	2b01      	cmp	r3, #1
 80077bc:	d101      	bne.n	80077c2 <LIS2DU12_ACC_Enable+0x16>
  {
    return LIS2DU12_OK;
 80077be:	2300      	movs	r3, #0
 80077c0:	e013      	b.n	80077ea <LIS2DU12_ACC_Enable+0x3e>
  }

  /* Output data rate selection. */
  if (LIS2DU12_ACC_SetOutputDataRate_When_Enabled(pObj, pObj->acc_odr, pObj->acc_ultra_low_power) != LIS2DU12_OK)
 80077c2:	687b      	ldr	r3, [r7, #4]
 80077c4:	6b59      	ldr	r1, [r3, #52]	@ 0x34
 80077c6:	687b      	ldr	r3, [r7, #4]
 80077c8:	f893 3038 	ldrb.w	r3, [r3, #56]	@ 0x38
 80077cc:	461a      	mov	r2, r3
 80077ce:	6878      	ldr	r0, [r7, #4]
 80077d0:	f000 fa46 	bl	8007c60 <LIS2DU12_ACC_SetOutputDataRate_When_Enabled>
 80077d4:	4603      	mov	r3, r0
 80077d6:	2b00      	cmp	r3, #0
 80077d8:	d002      	beq.n	80077e0 <LIS2DU12_ACC_Enable+0x34>
  {
    return LIS2DU12_ERROR;
 80077da:	f04f 33ff 	mov.w	r3, #4294967295
 80077de:	e004      	b.n	80077ea <LIS2DU12_ACC_Enable+0x3e>
  }

  pObj->acc_is_enabled = 1;
 80077e0:	687b      	ldr	r3, [r7, #4]
 80077e2:	2201      	movs	r2, #1
 80077e4:	f883 2031 	strb.w	r2, [r3, #49]	@ 0x31

  return LIS2DU12_OK;
 80077e8:	2300      	movs	r3, #0
}
 80077ea:	4618      	mov	r0, r3
 80077ec:	3708      	adds	r7, #8
 80077ee:	46bd      	mov	sp, r7
 80077f0:	bd80      	pop	{r7, pc}

080077f2 <LIS2DU12_ACC_Disable>:
  * @brief  Disable the LIS2DU12 accelerometer sensor
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2DU12_ACC_Disable(LIS2DU12_Object_t *pObj)
{
 80077f2:	b580      	push	{r7, lr}
 80077f4:	b084      	sub	sp, #16
 80077f6:	af00      	add	r7, sp, #0
 80077f8:	6078      	str	r0, [r7, #4]
  /* Check if the component is already disabled */
  if (pObj->acc_is_enabled == 0U)
 80077fa:	687b      	ldr	r3, [r7, #4]
 80077fc:	f893 3031 	ldrb.w	r3, [r3, #49]	@ 0x31
 8007800:	2b00      	cmp	r3, #0
 8007802:	d101      	bne.n	8007808 <LIS2DU12_ACC_Disable+0x16>
  {
    return LIS2DU12_OK;
 8007804:	2300      	movs	r3, #0
 8007806:	e022      	b.n	800784e <LIS2DU12_ACC_Disable+0x5c>
  }

  /* Output data rate selection - power down. */
  lis2du12_md_t mode;

  if (lis2du12_mode_get(&(pObj->Ctx), &mode) != LIS2DU12_OK)
 8007808:	687b      	ldr	r3, [r7, #4]
 800780a:	3320      	adds	r3, #32
 800780c:	f107 020c 	add.w	r2, r7, #12
 8007810:	4611      	mov	r1, r2
 8007812:	4618      	mov	r0, r3
 8007814:	f000 fdc0 	bl	8008398 <lis2du12_mode_get>
 8007818:	4603      	mov	r3, r0
 800781a:	2b00      	cmp	r3, #0
 800781c:	d002      	beq.n	8007824 <LIS2DU12_ACC_Disable+0x32>
  {
    return LIS2DU12_ERROR;
 800781e:	f04f 33ff 	mov.w	r3, #4294967295
 8007822:	e014      	b.n	800784e <LIS2DU12_ACC_Disable+0x5c>
  }

  mode.odr = LIS2DU12_OFF;
 8007824:	2300      	movs	r3, #0
 8007826:	733b      	strb	r3, [r7, #12]

  if (lis2du12_mode_set(&(pObj->Ctx), &mode) != LIS2DU12_OK)
 8007828:	687b      	ldr	r3, [r7, #4]
 800782a:	3320      	adds	r3, #32
 800782c:	f107 020c 	add.w	r2, r7, #12
 8007830:	4611      	mov	r1, r2
 8007832:	4618      	mov	r0, r3
 8007834:	f000 fd77 	bl	8008326 <lis2du12_mode_set>
 8007838:	4603      	mov	r3, r0
 800783a:	2b00      	cmp	r3, #0
 800783c:	d002      	beq.n	8007844 <LIS2DU12_ACC_Disable+0x52>
  {
    return LIS2DU12_ERROR;
 800783e:	f04f 33ff 	mov.w	r3, #4294967295
 8007842:	e004      	b.n	800784e <LIS2DU12_ACC_Disable+0x5c>
  }

  pObj->acc_is_enabled = 0;
 8007844:	687b      	ldr	r3, [r7, #4]
 8007846:	2200      	movs	r2, #0
 8007848:	f883 2031 	strb.w	r2, [r3, #49]	@ 0x31

  return LIS2DU12_OK;
 800784c:	2300      	movs	r3, #0
}
 800784e:	4618      	mov	r0, r3
 8007850:	3710      	adds	r7, #16
 8007852:	46bd      	mov	sp, r7
 8007854:	bd80      	pop	{r7, pc}
	...

08007858 <LIS2DU12_ACC_GetSensitivity>:
  * @param  pObj the device pObj
  * @param  Sensitivity pointer
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2DU12_ACC_GetSensitivity(LIS2DU12_Object_t *pObj, float *Sensitivity)
{
 8007858:	b580      	push	{r7, lr}
 800785a:	b084      	sub	sp, #16
 800785c:	af00      	add	r7, sp, #0
 800785e:	6078      	str	r0, [r7, #4]
 8007860:	6039      	str	r1, [r7, #0]
  lis2du12_md_t mode;

  if (lis2du12_mode_get(&(pObj->Ctx), &mode) != LIS2DU12_OK)
 8007862:	687b      	ldr	r3, [r7, #4]
 8007864:	3320      	adds	r3, #32
 8007866:	f107 020c 	add.w	r2, r7, #12
 800786a:	4611      	mov	r1, r2
 800786c:	4618      	mov	r0, r3
 800786e:	f000 fd93 	bl	8008398 <lis2du12_mode_get>
 8007872:	4603      	mov	r3, r0
 8007874:	2b00      	cmp	r3, #0
 8007876:	d002      	beq.n	800787e <LIS2DU12_ACC_GetSensitivity+0x26>
  {
    return LIS2DU12_ERROR;
 8007878:	f04f 33ff 	mov.w	r3, #4294967295
 800787c:	e025      	b.n	80078ca <LIS2DU12_ACC_GetSensitivity+0x72>
  }

  switch (mode.fs)
 800787e:	7b7b      	ldrb	r3, [r7, #13]
 8007880:	2b03      	cmp	r3, #3
 8007882:	d81b      	bhi.n	80078bc <LIS2DU12_ACC_GetSensitivity+0x64>
 8007884:	a201      	add	r2, pc, #4	@ (adr r2, 800788c <LIS2DU12_ACC_GetSensitivity+0x34>)
 8007886:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800788a:	bf00      	nop
 800788c:	0800789d 	.word	0x0800789d
 8007890:	080078a5 	.word	0x080078a5
 8007894:	080078ad 	.word	0x080078ad
 8007898:	080078b5 	.word	0x080078b5
  {
    case LIS2DU12_2g:
      *Sensitivity = LIS2DU12_ACC_SENSITIVITY_FOR_FS_2G;
 800789c:	683b      	ldr	r3, [r7, #0]
 800789e:	4a0d      	ldr	r2, [pc, #52]	@ (80078d4 <LIS2DU12_ACC_GetSensitivity+0x7c>)
 80078a0:	601a      	str	r2, [r3, #0]
      break;
 80078a2:	e011      	b.n	80078c8 <LIS2DU12_ACC_GetSensitivity+0x70>

    case LIS2DU12_4g:
      *Sensitivity = LIS2DU12_ACC_SENSITIVITY_FOR_FS_4G;
 80078a4:	683b      	ldr	r3, [r7, #0]
 80078a6:	4a0c      	ldr	r2, [pc, #48]	@ (80078d8 <LIS2DU12_ACC_GetSensitivity+0x80>)
 80078a8:	601a      	str	r2, [r3, #0]
      break;
 80078aa:	e00d      	b.n	80078c8 <LIS2DU12_ACC_GetSensitivity+0x70>

    case LIS2DU12_8g:
      *Sensitivity = LIS2DU12_ACC_SENSITIVITY_FOR_FS_8G;
 80078ac:	683b      	ldr	r3, [r7, #0]
 80078ae:	4a0b      	ldr	r2, [pc, #44]	@ (80078dc <LIS2DU12_ACC_GetSensitivity+0x84>)
 80078b0:	601a      	str	r2, [r3, #0]
      break;
 80078b2:	e009      	b.n	80078c8 <LIS2DU12_ACC_GetSensitivity+0x70>

    case LIS2DU12_16g:
      *Sensitivity = LIS2DU12_ACC_SENSITIVITY_FOR_FS_16G;
 80078b4:	683b      	ldr	r3, [r7, #0]
 80078b6:	4a0a      	ldr	r2, [pc, #40]	@ (80078e0 <LIS2DU12_ACC_GetSensitivity+0x88>)
 80078b8:	601a      	str	r2, [r3, #0]
      break;
 80078ba:	e005      	b.n	80078c8 <LIS2DU12_ACC_GetSensitivity+0x70>

    default:
      *Sensitivity = -1.0f;
 80078bc:	683b      	ldr	r3, [r7, #0]
 80078be:	4a09      	ldr	r2, [pc, #36]	@ (80078e4 <LIS2DU12_ACC_GetSensitivity+0x8c>)
 80078c0:	601a      	str	r2, [r3, #0]
      return LIS2DU12_ERROR;
 80078c2:	f04f 33ff 	mov.w	r3, #4294967295
 80078c6:	e000      	b.n	80078ca <LIS2DU12_ACC_GetSensitivity+0x72>
  }

  return LIS2DU12_OK;
 80078c8:	2300      	movs	r3, #0
}
 80078ca:	4618      	mov	r0, r3
 80078cc:	3710      	adds	r7, #16
 80078ce:	46bd      	mov	sp, r7
 80078d0:	bd80      	pop	{r7, pc}
 80078d2:	bf00      	nop
 80078d4:	3f79db23 	.word	0x3f79db23
 80078d8:	3ff9db23 	.word	0x3ff9db23
 80078dc:	4079db23 	.word	0x4079db23
 80078e0:	40f9db23 	.word	0x40f9db23
 80078e4:	bf800000 	.word	0xbf800000

080078e8 <LIS2DU12_ACC_GetOutputDataRate>:
  * @param  pObj the device pObj
  * @param  Odr pointer where the output data rate is written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2DU12_ACC_GetOutputDataRate(LIS2DU12_Object_t *pObj, float *Odr)
{
 80078e8:	b580      	push	{r7, lr}
 80078ea:	b084      	sub	sp, #16
 80078ec:	af00      	add	r7, sp, #0
 80078ee:	6078      	str	r0, [r7, #4]
 80078f0:	6039      	str	r1, [r7, #0]
  lis2du12_md_t mode;

  /* Read actual output data rate from sensor. */
  if (lis2du12_mode_get(&(pObj->Ctx), &mode) != LIS2DU12_OK)
 80078f2:	687b      	ldr	r3, [r7, #4]
 80078f4:	3320      	adds	r3, #32
 80078f6:	f107 020c 	add.w	r2, r7, #12
 80078fa:	4611      	mov	r1, r2
 80078fc:	4618      	mov	r0, r3
 80078fe:	f000 fd4b 	bl	8008398 <lis2du12_mode_get>
 8007902:	4603      	mov	r3, r0
 8007904:	2b00      	cmp	r3, #0
 8007906:	d002      	beq.n	800790e <LIS2DU12_ACC_GetOutputDataRate+0x26>
  {
    return LIS2DU12_ERROR;
 8007908:	f04f 33ff 	mov.w	r3, #4294967295
 800790c:	e05b      	b.n	80079c6 <LIS2DU12_ACC_GetOutputDataRate+0xde>
  }

  switch (mode.odr)
 800790e:	7b3b      	ldrb	r3, [r7, #12]
 8007910:	2b0f      	cmp	r3, #15
 8007912:	d851      	bhi.n	80079b8 <LIS2DU12_ACC_GetOutputDataRate+0xd0>
 8007914:	a201      	add	r2, pc, #4	@ (adr r2, 800791c <LIS2DU12_ACC_GetOutputDataRate+0x34>)
 8007916:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800791a:	bf00      	nop
 800791c:	0800795d 	.word	0x0800795d
 8007920:	08007967 	.word	0x08007967
 8007924:	08007971 	.word	0x08007971
 8007928:	08007979 	.word	0x08007979
 800792c:	08007979 	.word	0x08007979
 8007930:	08007981 	.word	0x08007981
 8007934:	08007989 	.word	0x08007989
 8007938:	08007991 	.word	0x08007991
 800793c:	08007999 	.word	0x08007999
 8007940:	080079a1 	.word	0x080079a1
 8007944:	080079a9 	.word	0x080079a9
 8007948:	080079b1 	.word	0x080079b1
 800794c:	080079b9 	.word	0x080079b9
 8007950:	080079b9 	.word	0x080079b9
 8007954:	0800795d 	.word	0x0800795d
 8007958:	0800795d 	.word	0x0800795d
  {
    case LIS2DU12_OFF:
    case LIS2DU12_TRIG_PIN:
    case LIS2DU12_TRIG_SW:
      *Odr = 0.0f;
 800795c:	683b      	ldr	r3, [r7, #0]
 800795e:	f04f 0200 	mov.w	r2, #0
 8007962:	601a      	str	r2, [r3, #0]
      break;
 8007964:	e02e      	b.n	80079c4 <LIS2DU12_ACC_GetOutputDataRate+0xdc>

    case LIS2DU12_1Hz5_ULP:
      *Odr = 1.5f;
 8007966:	683b      	ldr	r3, [r7, #0]
 8007968:	f04f 527f 	mov.w	r2, #1069547520	@ 0x3fc00000
 800796c:	601a      	str	r2, [r3, #0]
      break;
 800796e:	e029      	b.n	80079c4 <LIS2DU12_ACC_GetOutputDataRate+0xdc>

    case LIS2DU12_3Hz_ULP:
      *Odr = 3.0f;
 8007970:	683b      	ldr	r3, [r7, #0]
 8007972:	4a17      	ldr	r2, [pc, #92]	@ (80079d0 <LIS2DU12_ACC_GetOutputDataRate+0xe8>)
 8007974:	601a      	str	r2, [r3, #0]
      break;
 8007976:	e025      	b.n	80079c4 <LIS2DU12_ACC_GetOutputDataRate+0xdc>

    case LIS2DU12_6Hz_ULP:
    case LIS2DU12_6Hz:
      *Odr = 6.0f;
 8007978:	683b      	ldr	r3, [r7, #0]
 800797a:	4a16      	ldr	r2, [pc, #88]	@ (80079d4 <LIS2DU12_ACC_GetOutputDataRate+0xec>)
 800797c:	601a      	str	r2, [r3, #0]
      break;
 800797e:	e021      	b.n	80079c4 <LIS2DU12_ACC_GetOutputDataRate+0xdc>

    case LIS2DU12_12Hz5:
      *Odr = 12.5f;
 8007980:	683b      	ldr	r3, [r7, #0]
 8007982:	4a15      	ldr	r2, [pc, #84]	@ (80079d8 <LIS2DU12_ACC_GetOutputDataRate+0xf0>)
 8007984:	601a      	str	r2, [r3, #0]
      break;
 8007986:	e01d      	b.n	80079c4 <LIS2DU12_ACC_GetOutputDataRate+0xdc>

    case LIS2DU12_25Hz:
      *Odr = 25.0f;
 8007988:	683b      	ldr	r3, [r7, #0]
 800798a:	4a14      	ldr	r2, [pc, #80]	@ (80079dc <LIS2DU12_ACC_GetOutputDataRate+0xf4>)
 800798c:	601a      	str	r2, [r3, #0]
      break;
 800798e:	e019      	b.n	80079c4 <LIS2DU12_ACC_GetOutputDataRate+0xdc>

    case LIS2DU12_50Hz:
      *Odr = 50.0f;
 8007990:	683b      	ldr	r3, [r7, #0]
 8007992:	4a13      	ldr	r2, [pc, #76]	@ (80079e0 <LIS2DU12_ACC_GetOutputDataRate+0xf8>)
 8007994:	601a      	str	r2, [r3, #0]
      break;
 8007996:	e015      	b.n	80079c4 <LIS2DU12_ACC_GetOutputDataRate+0xdc>

    case LIS2DU12_100Hz:
      *Odr = 100.0f;
 8007998:	683b      	ldr	r3, [r7, #0]
 800799a:	4a12      	ldr	r2, [pc, #72]	@ (80079e4 <LIS2DU12_ACC_GetOutputDataRate+0xfc>)
 800799c:	601a      	str	r2, [r3, #0]
      break;
 800799e:	e011      	b.n	80079c4 <LIS2DU12_ACC_GetOutputDataRate+0xdc>

    case LIS2DU12_200Hz:
      *Odr = 200.0f;
 80079a0:	683b      	ldr	r3, [r7, #0]
 80079a2:	4a11      	ldr	r2, [pc, #68]	@ (80079e8 <LIS2DU12_ACC_GetOutputDataRate+0x100>)
 80079a4:	601a      	str	r2, [r3, #0]
      break;
 80079a6:	e00d      	b.n	80079c4 <LIS2DU12_ACC_GetOutputDataRate+0xdc>

    case LIS2DU12_400Hz:
      *Odr = 400.0f;
 80079a8:	683b      	ldr	r3, [r7, #0]
 80079aa:	4a10      	ldr	r2, [pc, #64]	@ (80079ec <LIS2DU12_ACC_GetOutputDataRate+0x104>)
 80079ac:	601a      	str	r2, [r3, #0]
      break;
 80079ae:	e009      	b.n	80079c4 <LIS2DU12_ACC_GetOutputDataRate+0xdc>

    case LIS2DU12_800Hz:
      *Odr = 800.0f;
 80079b0:	683b      	ldr	r3, [r7, #0]
 80079b2:	4a0f      	ldr	r2, [pc, #60]	@ (80079f0 <LIS2DU12_ACC_GetOutputDataRate+0x108>)
 80079b4:	601a      	str	r2, [r3, #0]
      break;
 80079b6:	e005      	b.n	80079c4 <LIS2DU12_ACC_GetOutputDataRate+0xdc>

    default:
      *Odr = -1.0f;
 80079b8:	683b      	ldr	r3, [r7, #0]
 80079ba:	4a0e      	ldr	r2, [pc, #56]	@ (80079f4 <LIS2DU12_ACC_GetOutputDataRate+0x10c>)
 80079bc:	601a      	str	r2, [r3, #0]
      return LIS2DU12_ERROR;
 80079be:	f04f 33ff 	mov.w	r3, #4294967295
 80079c2:	e000      	b.n	80079c6 <LIS2DU12_ACC_GetOutputDataRate+0xde>
  }

  return LIS2DU12_OK;
 80079c4:	2300      	movs	r3, #0
}
 80079c6:	4618      	mov	r0, r3
 80079c8:	3710      	adds	r7, #16
 80079ca:	46bd      	mov	sp, r7
 80079cc:	bd80      	pop	{r7, pc}
 80079ce:	bf00      	nop
 80079d0:	40400000 	.word	0x40400000
 80079d4:	40c00000 	.word	0x40c00000
 80079d8:	41480000 	.word	0x41480000
 80079dc:	41c80000 	.word	0x41c80000
 80079e0:	42480000 	.word	0x42480000
 80079e4:	42c80000 	.word	0x42c80000
 80079e8:	43480000 	.word	0x43480000
 80079ec:	43c80000 	.word	0x43c80000
 80079f0:	44480000 	.word	0x44480000
 80079f4:	bf800000 	.word	0xbf800000

080079f8 <LIS2DU12_ACC_SetOutputDataRate>:
  * @param  pObj the device pObj
  * @param  Odr the output data rate value to be set
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2DU12_ACC_SetOutputDataRate(LIS2DU12_Object_t *pObj, float Odr)
{
 80079f8:	b580      	push	{r7, lr}
 80079fa:	b082      	sub	sp, #8
 80079fc:	af00      	add	r7, sp, #0
 80079fe:	6078      	str	r0, [r7, #4]
 8007a00:	6039      	str	r1, [r7, #0]
  /* By default we use Ultra Low Power disabled */
  return LIS2DU12_ACC_SetOutputDataRate_With_Mode(pObj, Odr, LIS2DU12_ULTRA_LOW_POWER_DISABLE);
 8007a02:	2200      	movs	r2, #0
 8007a04:	6839      	ldr	r1, [r7, #0]
 8007a06:	6878      	ldr	r0, [r7, #4]
 8007a08:	f000 f805 	bl	8007a16 <LIS2DU12_ACC_SetOutputDataRate_With_Mode>
 8007a0c:	4603      	mov	r3, r0
}
 8007a0e:	4618      	mov	r0, r3
 8007a10:	3708      	adds	r7, #8
 8007a12:	46bd      	mov	sp, r7
 8007a14:	bd80      	pop	{r7, pc}

08007a16 <LIS2DU12_ACC_SetOutputDataRate_With_Mode>:
  * @param  Odr the output data rate value to be set
  * @param  Power the ultra low power option
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2DU12_ACC_SetOutputDataRate_With_Mode(LIS2DU12_Object_t *pObj, float Odr, LIS2DU12_Ultra_Low_Power_t Power)
{
 8007a16:	b580      	push	{r7, lr}
 8007a18:	b084      	sub	sp, #16
 8007a1a:	af00      	add	r7, sp, #0
 8007a1c:	60f8      	str	r0, [r7, #12]
 8007a1e:	60b9      	str	r1, [r7, #8]
 8007a20:	4613      	mov	r3, r2
 8007a22:	71fb      	strb	r3, [r7, #7]
  /* Check if the component is enabled */
  if (pObj->acc_is_enabled == 1U)
 8007a24:	68fb      	ldr	r3, [r7, #12]
 8007a26:	f893 3031 	ldrb.w	r3, [r3, #49]	@ 0x31
 8007a2a:	2b01      	cmp	r3, #1
 8007a2c:	d107      	bne.n	8007a3e <LIS2DU12_ACC_SetOutputDataRate_With_Mode+0x28>
  {
    return LIS2DU12_ACC_SetOutputDataRate_When_Enabled(pObj, Odr, Power);
 8007a2e:	79fb      	ldrb	r3, [r7, #7]
 8007a30:	461a      	mov	r2, r3
 8007a32:	68b9      	ldr	r1, [r7, #8]
 8007a34:	68f8      	ldr	r0, [r7, #12]
 8007a36:	f000 f913 	bl	8007c60 <LIS2DU12_ACC_SetOutputDataRate_When_Enabled>
 8007a3a:	4603      	mov	r3, r0
 8007a3c:	e006      	b.n	8007a4c <LIS2DU12_ACC_SetOutputDataRate_With_Mode+0x36>
  }
  else
  {
    return LIS2DU12_ACC_SetOutputDataRate_When_Disabled(pObj, Odr, Power);
 8007a3e:	79fb      	ldrb	r3, [r7, #7]
 8007a40:	461a      	mov	r2, r3
 8007a42:	68b9      	ldr	r1, [r7, #8]
 8007a44:	68f8      	ldr	r0, [r7, #12]
 8007a46:	f000 fa07 	bl	8007e58 <LIS2DU12_ACC_SetOutputDataRate_When_Disabled>
 8007a4a:	4603      	mov	r3, r0
  }
}
 8007a4c:	4618      	mov	r0, r3
 8007a4e:	3710      	adds	r7, #16
 8007a50:	46bd      	mov	sp, r7
 8007a52:	bd80      	pop	{r7, pc}

08007a54 <LIS2DU12_ACC_GetFullScale>:
  * @param  pObj the device pObj
  * @param  FullScale pointer where the full scale is written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2DU12_ACC_GetFullScale(LIS2DU12_Object_t *pObj, int32_t *FullScale)
{
 8007a54:	b580      	push	{r7, lr}
 8007a56:	b084      	sub	sp, #16
 8007a58:	af00      	add	r7, sp, #0
 8007a5a:	6078      	str	r0, [r7, #4]
 8007a5c:	6039      	str	r1, [r7, #0]
  int32_t ret = LIS2DU12_OK;
 8007a5e:	2300      	movs	r3, #0
 8007a60:	60fb      	str	r3, [r7, #12]
  lis2du12_md_t mode;

  /* Read actual full scale selection from sensor. */
  if (lis2du12_mode_get(&(pObj->Ctx), &mode) != LIS2DU12_OK)
 8007a62:	687b      	ldr	r3, [r7, #4]
 8007a64:	3320      	adds	r3, #32
 8007a66:	f107 0208 	add.w	r2, r7, #8
 8007a6a:	4611      	mov	r1, r2
 8007a6c:	4618      	mov	r0, r3
 8007a6e:	f000 fc93 	bl	8008398 <lis2du12_mode_get>
 8007a72:	4603      	mov	r3, r0
 8007a74:	2b00      	cmp	r3, #0
 8007a76:	d002      	beq.n	8007a7e <LIS2DU12_ACC_GetFullScale+0x2a>
  {
    return LIS2DU12_ERROR;
 8007a78:	f04f 33ff 	mov.w	r3, #4294967295
 8007a7c:	e027      	b.n	8007ace <LIS2DU12_ACC_GetFullScale+0x7a>
  }

  switch (mode.fs)
 8007a7e:	7a7b      	ldrb	r3, [r7, #9]
 8007a80:	2b03      	cmp	r3, #3
 8007a82:	d81b      	bhi.n	8007abc <LIS2DU12_ACC_GetFullScale+0x68>
 8007a84:	a201      	add	r2, pc, #4	@ (adr r2, 8007a8c <LIS2DU12_ACC_GetFullScale+0x38>)
 8007a86:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8007a8a:	bf00      	nop
 8007a8c:	08007a9d 	.word	0x08007a9d
 8007a90:	08007aa5 	.word	0x08007aa5
 8007a94:	08007aad 	.word	0x08007aad
 8007a98:	08007ab5 	.word	0x08007ab5
  {
    case LIS2DU12_2g:
      *FullScale =  2;
 8007a9c:	683b      	ldr	r3, [r7, #0]
 8007a9e:	2202      	movs	r2, #2
 8007aa0:	601a      	str	r2, [r3, #0]
      break;
 8007aa2:	e013      	b.n	8007acc <LIS2DU12_ACC_GetFullScale+0x78>

    case LIS2DU12_4g:
      *FullScale =  4;
 8007aa4:	683b      	ldr	r3, [r7, #0]
 8007aa6:	2204      	movs	r2, #4
 8007aa8:	601a      	str	r2, [r3, #0]
      break;
 8007aaa:	e00f      	b.n	8007acc <LIS2DU12_ACC_GetFullScale+0x78>

    case LIS2DU12_8g:
      *FullScale =  8;
 8007aac:	683b      	ldr	r3, [r7, #0]
 8007aae:	2208      	movs	r2, #8
 8007ab0:	601a      	str	r2, [r3, #0]
      break;
 8007ab2:	e00b      	b.n	8007acc <LIS2DU12_ACC_GetFullScale+0x78>

    case LIS2DU12_16g:
      *FullScale = 16;
 8007ab4:	683b      	ldr	r3, [r7, #0]
 8007ab6:	2210      	movs	r2, #16
 8007ab8:	601a      	str	r2, [r3, #0]
      break;
 8007aba:	e007      	b.n	8007acc <LIS2DU12_ACC_GetFullScale+0x78>

    default:
      *FullScale = -1;
 8007abc:	683b      	ldr	r3, [r7, #0]
 8007abe:	f04f 32ff 	mov.w	r2, #4294967295
 8007ac2:	601a      	str	r2, [r3, #0]
      ret = LIS2DU12_ERROR;
 8007ac4:	f04f 33ff 	mov.w	r3, #4294967295
 8007ac8:	60fb      	str	r3, [r7, #12]
      break;
 8007aca:	bf00      	nop
  }

  return ret;
 8007acc:	68fb      	ldr	r3, [r7, #12]
}
 8007ace:	4618      	mov	r0, r3
 8007ad0:	3710      	adds	r7, #16
 8007ad2:	46bd      	mov	sp, r7
 8007ad4:	bd80      	pop	{r7, pc}
 8007ad6:	bf00      	nop

08007ad8 <LIS2DU12_ACC_SetFullScale>:
  * @param  pObj the device pObj
  * @param  FullScale the functional full scale to be set
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2DU12_ACC_SetFullScale(LIS2DU12_Object_t *pObj, int32_t FullScale)
{
 8007ad8:	b580      	push	{r7, lr}
 8007ada:	b084      	sub	sp, #16
 8007adc:	af00      	add	r7, sp, #0
 8007ade:	6078      	str	r0, [r7, #4]
 8007ae0:	6039      	str	r1, [r7, #0]
  lis2du12_md_t mode;

  if (lis2du12_mode_get(&(pObj->Ctx), &mode) != LIS2DU12_OK)
 8007ae2:	687b      	ldr	r3, [r7, #4]
 8007ae4:	3320      	adds	r3, #32
 8007ae6:	f107 020c 	add.w	r2, r7, #12
 8007aea:	4611      	mov	r1, r2
 8007aec:	4618      	mov	r0, r3
 8007aee:	f000 fc53 	bl	8008398 <lis2du12_mode_get>
 8007af2:	4603      	mov	r3, r0
 8007af4:	2b00      	cmp	r3, #0
 8007af6:	d002      	beq.n	8007afe <LIS2DU12_ACC_SetFullScale+0x26>
  {
    return LIS2DU12_ERROR;
 8007af8:	f04f 33ff 	mov.w	r3, #4294967295
 8007afc:	e01f      	b.n	8007b3e <LIS2DU12_ACC_SetFullScale+0x66>
  }

  /* Seems like MISRA C-2012 rule 14.3a violation but only from single file statical analysis point of view because
     the parameter passed to the function is not known at the moment of analysis */
  mode.fs = (FullScale <= 2) ? LIS2DU12_2g
            : (FullScale <= 4) ? LIS2DU12_4g
 8007afe:	683b      	ldr	r3, [r7, #0]
 8007b00:	2b02      	cmp	r3, #2
 8007b02:	dd0b      	ble.n	8007b1c <LIS2DU12_ACC_SetFullScale+0x44>
 8007b04:	683b      	ldr	r3, [r7, #0]
 8007b06:	2b04      	cmp	r3, #4
 8007b08:	dd06      	ble.n	8007b18 <LIS2DU12_ACC_SetFullScale+0x40>
 8007b0a:	683b      	ldr	r3, [r7, #0]
 8007b0c:	2b08      	cmp	r3, #8
 8007b0e:	dc01      	bgt.n	8007b14 <LIS2DU12_ACC_SetFullScale+0x3c>
 8007b10:	2302      	movs	r3, #2
 8007b12:	e004      	b.n	8007b1e <LIS2DU12_ACC_SetFullScale+0x46>
 8007b14:	2303      	movs	r3, #3
 8007b16:	e002      	b.n	8007b1e <LIS2DU12_ACC_SetFullScale+0x46>
 8007b18:	2301      	movs	r3, #1
 8007b1a:	e000      	b.n	8007b1e <LIS2DU12_ACC_SetFullScale+0x46>
 8007b1c:	2300      	movs	r3, #0
  mode.fs = (FullScale <= 2) ? LIS2DU12_2g
 8007b1e:	737b      	strb	r3, [r7, #13]
            : (FullScale <= 8) ? LIS2DU12_8g
            :                    LIS2DU12_16g;

  if (lis2du12_mode_set(&(pObj->Ctx), &mode) != LIS2DU12_OK)
 8007b20:	687b      	ldr	r3, [r7, #4]
 8007b22:	3320      	adds	r3, #32
 8007b24:	f107 020c 	add.w	r2, r7, #12
 8007b28:	4611      	mov	r1, r2
 8007b2a:	4618      	mov	r0, r3
 8007b2c:	f000 fbfb 	bl	8008326 <lis2du12_mode_set>
 8007b30:	4603      	mov	r3, r0
 8007b32:	2b00      	cmp	r3, #0
 8007b34:	d002      	beq.n	8007b3c <LIS2DU12_ACC_SetFullScale+0x64>
  {
    return LIS2DU12_ERROR;
 8007b36:	f04f 33ff 	mov.w	r3, #4294967295
 8007b3a:	e000      	b.n	8007b3e <LIS2DU12_ACC_SetFullScale+0x66>
  }

  return LIS2DU12_OK;
 8007b3c:	2300      	movs	r3, #0
}
 8007b3e:	4618      	mov	r0, r3
 8007b40:	3710      	adds	r7, #16
 8007b42:	46bd      	mov	sp, r7
 8007b44:	bd80      	pop	{r7, pc}

08007b46 <LIS2DU12_ACC_GetAxesRaw>:
  * @param  pObj the device pObj
  * @param  Value pointer where the raw values of the axes are written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2DU12_ACC_GetAxesRaw(LIS2DU12_Object_t *pObj, LIS2DU12_AxesRaw_t *Value)
{
 8007b46:	b580      	push	{r7, lr}
 8007b48:	b08a      	sub	sp, #40	@ 0x28
 8007b4a:	af00      	add	r7, sp, #0
 8007b4c:	6078      	str	r0, [r7, #4]
 8007b4e:	6039      	str	r1, [r7, #0]
  lis2du12_md_t mode;
  lis2du12_data_t data;

  if (lis2du12_mode_get(&(pObj->Ctx), &mode) != LIS2DU12_OK)
 8007b50:	687b      	ldr	r3, [r7, #4]
 8007b52:	3320      	adds	r3, #32
 8007b54:	f107 0224 	add.w	r2, r7, #36	@ 0x24
 8007b58:	4611      	mov	r1, r2
 8007b5a:	4618      	mov	r0, r3
 8007b5c:	f000 fc1c 	bl	8008398 <lis2du12_mode_get>
 8007b60:	4603      	mov	r3, r0
 8007b62:	2b00      	cmp	r3, #0
 8007b64:	d002      	beq.n	8007b6c <LIS2DU12_ACC_GetAxesRaw+0x26>
  {
    return LIS2DU12_ERROR;
 8007b66:	f04f 33ff 	mov.w	r3, #4294967295
 8007b6a:	e01b      	b.n	8007ba4 <LIS2DU12_ACC_GetAxesRaw+0x5e>
  }

  if (lis2du12_data_get(&(pObj->Ctx), &mode, &data) != LIS2DU12_OK)
 8007b6c:	687b      	ldr	r3, [r7, #4]
 8007b6e:	3320      	adds	r3, #32
 8007b70:	f107 0208 	add.w	r2, r7, #8
 8007b74:	f107 0124 	add.w	r1, r7, #36	@ 0x24
 8007b78:	4618      	mov	r0, r3
 8007b7a:	f000 fcd1 	bl	8008520 <lis2du12_data_get>
 8007b7e:	4603      	mov	r3, r0
 8007b80:	2b00      	cmp	r3, #0
 8007b82:	d002      	beq.n	8007b8a <LIS2DU12_ACC_GetAxesRaw+0x44>
  {
    return LIS2DU12_ERROR;
 8007b84:	f04f 33ff 	mov.w	r3, #4294967295
 8007b88:	e00c      	b.n	8007ba4 <LIS2DU12_ACC_GetAxesRaw+0x5e>
  }

  Value->x = data.xl.raw[0];
 8007b8a:	f9b7 2014 	ldrsh.w	r2, [r7, #20]
 8007b8e:	683b      	ldr	r3, [r7, #0]
 8007b90:	801a      	strh	r2, [r3, #0]
  Value->y = data.xl.raw[1];
 8007b92:	f9b7 2016 	ldrsh.w	r2, [r7, #22]
 8007b96:	683b      	ldr	r3, [r7, #0]
 8007b98:	805a      	strh	r2, [r3, #2]
  Value->z = data.xl.raw[2];
 8007b9a:	f9b7 2018 	ldrsh.w	r2, [r7, #24]
 8007b9e:	683b      	ldr	r3, [r7, #0]
 8007ba0:	809a      	strh	r2, [r3, #4]

  return LIS2DU12_OK;
 8007ba2:	2300      	movs	r3, #0
}
 8007ba4:	4618      	mov	r0, r3
 8007ba6:	3728      	adds	r7, #40	@ 0x28
 8007ba8:	46bd      	mov	sp, r7
 8007baa:	bd80      	pop	{r7, pc}

08007bac <LIS2DU12_ACC_GetAxes>:
  * @param  pObj the device pObj
  * @param  Acceleration pointer where the values of the axes are written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2DU12_ACC_GetAxes(LIS2DU12_Object_t *pObj, LIS2DU12_Axes_t *Acceleration)
{
 8007bac:	b580      	push	{r7, lr}
 8007bae:	b08a      	sub	sp, #40	@ 0x28
 8007bb0:	af00      	add	r7, sp, #0
 8007bb2:	6078      	str	r0, [r7, #4]
 8007bb4:	6039      	str	r1, [r7, #0]
  lis2du12_md_t mode;
  lis2du12_data_t data;

  if (lis2du12_mode_get(&(pObj->Ctx), &mode) != LIS2DU12_OK)
 8007bb6:	687b      	ldr	r3, [r7, #4]
 8007bb8:	3320      	adds	r3, #32
 8007bba:	f107 0224 	add.w	r2, r7, #36	@ 0x24
 8007bbe:	4611      	mov	r1, r2
 8007bc0:	4618      	mov	r0, r3
 8007bc2:	f000 fbe9 	bl	8008398 <lis2du12_mode_get>
 8007bc6:	4603      	mov	r3, r0
 8007bc8:	2b00      	cmp	r3, #0
 8007bca:	d002      	beq.n	8007bd2 <LIS2DU12_ACC_GetAxes+0x26>
  {
    return LIS2DU12_ERROR;
 8007bcc:	f04f 33ff 	mov.w	r3, #4294967295
 8007bd0:	e027      	b.n	8007c22 <LIS2DU12_ACC_GetAxes+0x76>
  }

  if (lis2du12_data_get(&(pObj->Ctx), &mode, &data) != LIS2DU12_OK)
 8007bd2:	687b      	ldr	r3, [r7, #4]
 8007bd4:	3320      	adds	r3, #32
 8007bd6:	f107 0208 	add.w	r2, r7, #8
 8007bda:	f107 0124 	add.w	r1, r7, #36	@ 0x24
 8007bde:	4618      	mov	r0, r3
 8007be0:	f000 fc9e 	bl	8008520 <lis2du12_data_get>
 8007be4:	4603      	mov	r3, r0
 8007be6:	2b00      	cmp	r3, #0
 8007be8:	d002      	beq.n	8007bf0 <LIS2DU12_ACC_GetAxes+0x44>
  {
    return LIS2DU12_ERROR;
 8007bea:	f04f 33ff 	mov.w	r3, #4294967295
 8007bee:	e018      	b.n	8007c22 <LIS2DU12_ACC_GetAxes+0x76>
  }

  Acceleration->x = (int32_t)data.xl.mg[0];
 8007bf0:	edd7 7a02 	vldr	s15, [r7, #8]
 8007bf4:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8007bf8:	ee17 2a90 	vmov	r2, s15
 8007bfc:	683b      	ldr	r3, [r7, #0]
 8007bfe:	601a      	str	r2, [r3, #0]
  Acceleration->y = (int32_t)data.xl.mg[1];
 8007c00:	edd7 7a03 	vldr	s15, [r7, #12]
 8007c04:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8007c08:	ee17 2a90 	vmov	r2, s15
 8007c0c:	683b      	ldr	r3, [r7, #0]
 8007c0e:	605a      	str	r2, [r3, #4]
  Acceleration->z = (int32_t)data.xl.mg[2];
 8007c10:	edd7 7a04 	vldr	s15, [r7, #16]
 8007c14:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8007c18:	ee17 2a90 	vmov	r2, s15
 8007c1c:	683b      	ldr	r3, [r7, #0]
 8007c1e:	609a      	str	r2, [r3, #8]

  return LIS2DU12_OK;
 8007c20:	2300      	movs	r3, #0
}
 8007c22:	4618      	mov	r0, r3
 8007c24:	3728      	adds	r7, #40	@ 0x28
 8007c26:	46bd      	mov	sp, r7
 8007c28:	bd80      	pop	{r7, pc}

08007c2a <LIS2DU12_Write_Reg>:
  * @param  Reg address to be written
  * @param  Data value to be written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2DU12_Write_Reg(LIS2DU12_Object_t *pObj, uint8_t Reg, uint8_t Data)
{
 8007c2a:	b580      	push	{r7, lr}
 8007c2c:	b082      	sub	sp, #8
 8007c2e:	af00      	add	r7, sp, #0
 8007c30:	6078      	str	r0, [r7, #4]
 8007c32:	460b      	mov	r3, r1
 8007c34:	70fb      	strb	r3, [r7, #3]
 8007c36:	4613      	mov	r3, r2
 8007c38:	70bb      	strb	r3, [r7, #2]
  if (lis2du12_write_reg(&(pObj->Ctx), Reg, &Data, 1) != LIS2DU12_OK)
 8007c3a:	687b      	ldr	r3, [r7, #4]
 8007c3c:	f103 0020 	add.w	r0, r3, #32
 8007c40:	1cba      	adds	r2, r7, #2
 8007c42:	78f9      	ldrb	r1, [r7, #3]
 8007c44:	2301      	movs	r3, #1
 8007c46:	f000 f9ef 	bl	8008028 <lis2du12_write_reg>
 8007c4a:	4603      	mov	r3, r0
 8007c4c:	2b00      	cmp	r3, #0
 8007c4e:	d002      	beq.n	8007c56 <LIS2DU12_Write_Reg+0x2c>
  {
    return LIS2DU12_ERROR;
 8007c50:	f04f 33ff 	mov.w	r3, #4294967295
 8007c54:	e000      	b.n	8007c58 <LIS2DU12_Write_Reg+0x2e>
  }

  return LIS2DU12_OK;
 8007c56:	2300      	movs	r3, #0
}
 8007c58:	4618      	mov	r0, r3
 8007c5a:	3708      	adds	r7, #8
 8007c5c:	46bd      	mov	sp, r7
 8007c5e:	bd80      	pop	{r7, pc}

08007c60 <LIS2DU12_ACC_SetOutputDataRate_When_Enabled>:
  * @param  Power the ultra low power option
  * @retval 0 in case of success, an error code otherwise
  */
static int32_t LIS2DU12_ACC_SetOutputDataRate_When_Enabled(LIS2DU12_Object_t *pObj, float Odr,
                                                           LIS2DU12_Ultra_Low_Power_t Power)
{
 8007c60:	b580      	push	{r7, lr}
 8007c62:	b086      	sub	sp, #24
 8007c64:	af00      	add	r7, sp, #0
 8007c66:	60f8      	str	r0, [r7, #12]
 8007c68:	60b9      	str	r1, [r7, #8]
 8007c6a:	4613      	mov	r3, r2
 8007c6c:	71fb      	strb	r3, [r7, #7]
  lis2du12_md_t mode;

  if (lis2du12_mode_get(&(pObj->Ctx), &mode) != LIS2DU12_OK)
 8007c6e:	68fb      	ldr	r3, [r7, #12]
 8007c70:	3320      	adds	r3, #32
 8007c72:	f107 0214 	add.w	r2, r7, #20
 8007c76:	4611      	mov	r1, r2
 8007c78:	4618      	mov	r0, r3
 8007c7a:	f000 fb8d 	bl	8008398 <lis2du12_mode_get>
 8007c7e:	4603      	mov	r3, r0
 8007c80:	2b00      	cmp	r3, #0
 8007c82:	d002      	beq.n	8007c8a <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0x2a>
  {
    return LIS2DU12_ERROR;
 8007c84:	f04f 33ff 	mov.w	r3, #4294967295
 8007c88:	e0c5      	b.n	8007e16 <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0x1b6>
  }

  if (Power == LIS2DU12_ULTRA_LOW_POWER_ENABLE)
 8007c8a:	79fb      	ldrb	r3, [r7, #7]
 8007c8c:	2b01      	cmp	r3, #1
 8007c8e:	d118      	bne.n	8007cc2 <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0x62>
  {
    mode.odr = (Odr <= 1.5f) ? LIS2DU12_1Hz5_ULP
               : (Odr <= 3.0f) ? LIS2DU12_3Hz_ULP
 8007c90:	edd7 7a02 	vldr	s15, [r7, #8]
 8007c94:	eeb7 7a08 	vmov.f32	s14, #120	@ 0x3fc00000  1.5
 8007c98:	eef4 7ac7 	vcmpe.f32	s15, s14
 8007c9c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007ca0:	d801      	bhi.n	8007ca6 <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0x46>
 8007ca2:	2301      	movs	r3, #1
 8007ca4:	e00b      	b.n	8007cbe <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0x5e>
 8007ca6:	edd7 7a02 	vldr	s15, [r7, #8]
 8007caa:	eeb0 7a08 	vmov.f32	s14, #8	@ 0x40400000  3.0
 8007cae:	eef4 7ac7 	vcmpe.f32	s15, s14
 8007cb2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007cb6:	d801      	bhi.n	8007cbc <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0x5c>
 8007cb8:	2302      	movs	r3, #2
 8007cba:	e000      	b.n	8007cbe <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0x5e>
 8007cbc:	2303      	movs	r3, #3
    mode.odr = (Odr <= 1.5f) ? LIS2DU12_1Hz5_ULP
 8007cbe:	753b      	strb	r3, [r7, #20]
 8007cc0:	e04e      	b.n	8007d60 <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0x100>
               :                 LIS2DU12_6Hz_ULP;
  }
  else
  {
    mode.odr = (Odr <=   6.0f) ? LIS2DU12_6Hz
               : (Odr <=  12.5f) ? LIS2DU12_12Hz5
 8007cc2:	edd7 7a02 	vldr	s15, [r7, #8]
 8007cc6:	eeb1 7a08 	vmov.f32	s14, #24	@ 0x40c00000  6.0
 8007cca:	eef4 7ac7 	vcmpe.f32	s15, s14
 8007cce:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007cd2:	d801      	bhi.n	8007cd8 <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0x78>
 8007cd4:	2304      	movs	r3, #4
 8007cd6:	e042      	b.n	8007d5e <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0xfe>
 8007cd8:	edd7 7a02 	vldr	s15, [r7, #8]
 8007cdc:	eeb2 7a09 	vmov.f32	s14, #41	@ 0x41480000  12.5
 8007ce0:	eef4 7ac7 	vcmpe.f32	s15, s14
 8007ce4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007ce8:	d801      	bhi.n	8007cee <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0x8e>
 8007cea:	2305      	movs	r3, #5
 8007cec:	e037      	b.n	8007d5e <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0xfe>
 8007cee:	edd7 7a02 	vldr	s15, [r7, #8]
 8007cf2:	eeb3 7a09 	vmov.f32	s14, #57	@ 0x41c80000  25.0
 8007cf6:	eef4 7ac7 	vcmpe.f32	s15, s14
 8007cfa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007cfe:	d801      	bhi.n	8007d04 <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0xa4>
 8007d00:	2306      	movs	r3, #6
 8007d02:	e02c      	b.n	8007d5e <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0xfe>
 8007d04:	edd7 7a02 	vldr	s15, [r7, #8]
 8007d08:	ed9f 7a45 	vldr	s14, [pc, #276]	@ 8007e20 <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0x1c0>
 8007d0c:	eef4 7ac7 	vcmpe.f32	s15, s14
 8007d10:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007d14:	d801      	bhi.n	8007d1a <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0xba>
 8007d16:	2307      	movs	r3, #7
 8007d18:	e021      	b.n	8007d5e <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0xfe>
 8007d1a:	edd7 7a02 	vldr	s15, [r7, #8]
 8007d1e:	ed9f 7a41 	vldr	s14, [pc, #260]	@ 8007e24 <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0x1c4>
 8007d22:	eef4 7ac7 	vcmpe.f32	s15, s14
 8007d26:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007d2a:	d801      	bhi.n	8007d30 <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0xd0>
 8007d2c:	2308      	movs	r3, #8
 8007d2e:	e016      	b.n	8007d5e <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0xfe>
 8007d30:	edd7 7a02 	vldr	s15, [r7, #8]
 8007d34:	ed9f 7a3c 	vldr	s14, [pc, #240]	@ 8007e28 <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0x1c8>
 8007d38:	eef4 7ac7 	vcmpe.f32	s15, s14
 8007d3c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007d40:	d801      	bhi.n	8007d46 <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0xe6>
 8007d42:	2309      	movs	r3, #9
 8007d44:	e00b      	b.n	8007d5e <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0xfe>
 8007d46:	edd7 7a02 	vldr	s15, [r7, #8]
 8007d4a:	ed9f 7a38 	vldr	s14, [pc, #224]	@ 8007e2c <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0x1cc>
 8007d4e:	eef4 7ac7 	vcmpe.f32	s15, s14
 8007d52:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007d56:	d801      	bhi.n	8007d5c <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0xfc>
 8007d58:	230a      	movs	r3, #10
 8007d5a:	e000      	b.n	8007d5e <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0xfe>
 8007d5c:	230b      	movs	r3, #11
    mode.odr = (Odr <=   6.0f) ? LIS2DU12_6Hz
 8007d5e:	753b      	strb	r3, [r7, #20]
               : (Odr <= 200.0f) ? LIS2DU12_200Hz
               : (Odr <= 400.0f) ? LIS2DU12_400Hz
               :                   LIS2DU12_800Hz;
  }

  if (lis2du12_mode_set(&(pObj->Ctx), &mode) != LIS2DU12_OK)
 8007d60:	68fb      	ldr	r3, [r7, #12]
 8007d62:	3320      	adds	r3, #32
 8007d64:	f107 0214 	add.w	r2, r7, #20
 8007d68:	4611      	mov	r1, r2
 8007d6a:	4618      	mov	r0, r3
 8007d6c:	f000 fadb 	bl	8008326 <lis2du12_mode_set>
 8007d70:	4603      	mov	r3, r0
 8007d72:	2b00      	cmp	r3, #0
 8007d74:	d002      	beq.n	8007d7c <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0x11c>
  {
    return LIS2DU12_ERROR;
 8007d76:	f04f 33ff 	mov.w	r3, #4294967295
 8007d7a:	e04c      	b.n	8007e16 <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0x1b6>
  }

  /* Store the current Odr value */
  pObj->acc_odr = (mode.odr == LIS2DU12_1Hz5_ULP) ?   1.5f
 8007d7c:	7d3b      	ldrb	r3, [r7, #20]
                  : (mode.odr == LIS2DU12_3Hz_ULP)  ?   3.0f
 8007d7e:	2b01      	cmp	r3, #1
 8007d80:	d033      	beq.n	8007dea <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0x18a>
 8007d82:	7d3b      	ldrb	r3, [r7, #20]
                  : (mode.odr == LIS2DU12_6Hz_ULP)  ?   6.0f
 8007d84:	2b02      	cmp	r3, #2
 8007d86:	d02e      	beq.n	8007de6 <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0x186>
 8007d88:	7d3b      	ldrb	r3, [r7, #20]
                  : (mode.odr == LIS2DU12_6Hz)      ?   6.0f
 8007d8a:	2b03      	cmp	r3, #3
 8007d8c:	d029      	beq.n	8007de2 <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0x182>
 8007d8e:	7d3b      	ldrb	r3, [r7, #20]
                  : (mode.odr == LIS2DU12_12Hz5)    ?  12.5f
 8007d90:	2b04      	cmp	r3, #4
 8007d92:	d024      	beq.n	8007dde <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0x17e>
 8007d94:	7d3b      	ldrb	r3, [r7, #20]
                  : (mode.odr == LIS2DU12_25Hz)     ?  25.0f
 8007d96:	2b05      	cmp	r3, #5
 8007d98:	d01f      	beq.n	8007dda <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0x17a>
 8007d9a:	7d3b      	ldrb	r3, [r7, #20]
                  : (mode.odr == LIS2DU12_50Hz)     ?  50.0f
 8007d9c:	2b06      	cmp	r3, #6
 8007d9e:	d01a      	beq.n	8007dd6 <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0x176>
 8007da0:	7d3b      	ldrb	r3, [r7, #20]
                  : (mode.odr == LIS2DU12_100Hz)    ? 100.0f
 8007da2:	2b07      	cmp	r3, #7
 8007da4:	d015      	beq.n	8007dd2 <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0x172>
 8007da6:	7d3b      	ldrb	r3, [r7, #20]
                  : (mode.odr == LIS2DU12_200Hz)    ? 200.0f
 8007da8:	2b08      	cmp	r3, #8
 8007daa:	d010      	beq.n	8007dce <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0x16e>
 8007dac:	7d3b      	ldrb	r3, [r7, #20]
                  : (mode.odr == LIS2DU12_400Hz)    ? 400.0f
 8007dae:	2b09      	cmp	r3, #9
 8007db0:	d00b      	beq.n	8007dca <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0x16a>
 8007db2:	7d3b      	ldrb	r3, [r7, #20]
                  : (mode.odr == LIS2DU12_800Hz)    ? 800.0f
 8007db4:	2b0a      	cmp	r3, #10
 8007db6:	d006      	beq.n	8007dc6 <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0x166>
 8007db8:	7d3b      	ldrb	r3, [r7, #20]
                  :                                    -1.0f;
 8007dba:	2b0b      	cmp	r3, #11
 8007dbc:	d101      	bne.n	8007dc2 <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0x162>
 8007dbe:	4b1c      	ldr	r3, [pc, #112]	@ (8007e30 <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0x1d0>)
 8007dc0:	e015      	b.n	8007dee <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0x18e>
 8007dc2:	4b1c      	ldr	r3, [pc, #112]	@ (8007e34 <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0x1d4>)
 8007dc4:	e013      	b.n	8007dee <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0x18e>
                  : (mode.odr == LIS2DU12_800Hz)    ? 800.0f
 8007dc6:	4b1c      	ldr	r3, [pc, #112]	@ (8007e38 <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0x1d8>)
 8007dc8:	e011      	b.n	8007dee <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0x18e>
                  : (mode.odr == LIS2DU12_400Hz)    ? 400.0f
 8007dca:	4b1c      	ldr	r3, [pc, #112]	@ (8007e3c <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0x1dc>)
 8007dcc:	e00f      	b.n	8007dee <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0x18e>
                  : (mode.odr == LIS2DU12_200Hz)    ? 200.0f
 8007dce:	4b1c      	ldr	r3, [pc, #112]	@ (8007e40 <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0x1e0>)
 8007dd0:	e00d      	b.n	8007dee <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0x18e>
                  : (mode.odr == LIS2DU12_100Hz)    ? 100.0f
 8007dd2:	4b1c      	ldr	r3, [pc, #112]	@ (8007e44 <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0x1e4>)
 8007dd4:	e00b      	b.n	8007dee <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0x18e>
                  : (mode.odr == LIS2DU12_50Hz)     ?  50.0f
 8007dd6:	4b1c      	ldr	r3, [pc, #112]	@ (8007e48 <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0x1e8>)
 8007dd8:	e009      	b.n	8007dee <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0x18e>
                  : (mode.odr == LIS2DU12_25Hz)     ?  25.0f
 8007dda:	4b1c      	ldr	r3, [pc, #112]	@ (8007e4c <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0x1ec>)
 8007ddc:	e007      	b.n	8007dee <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0x18e>
                  : (mode.odr == LIS2DU12_12Hz5)    ?  12.5f
 8007dde:	4b1c      	ldr	r3, [pc, #112]	@ (8007e50 <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0x1f0>)
 8007de0:	e005      	b.n	8007dee <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0x18e>
                  : (mode.odr == LIS2DU12_6Hz)      ?   6.0f
 8007de2:	4b1b      	ldr	r3, [pc, #108]	@ (8007e50 <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0x1f0>)
 8007de4:	e003      	b.n	8007dee <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0x18e>
                  : (mode.odr == LIS2DU12_6Hz_ULP)  ?   6.0f
 8007de6:	4b1b      	ldr	r3, [pc, #108]	@ (8007e54 <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0x1f4>)
 8007de8:	e001      	b.n	8007dee <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0x18e>
                  : (mode.odr == LIS2DU12_3Hz_ULP)  ?   3.0f
 8007dea:	f04f 537f 	mov.w	r3, #1069547520	@ 0x3fc00000
  pObj->acc_odr = (mode.odr == LIS2DU12_1Hz5_ULP) ?   1.5f
 8007dee:	68fa      	ldr	r2, [r7, #12]
 8007df0:	6353      	str	r3, [r2, #52]	@ 0x34

  if (pObj->acc_odr == -1.0f)
 8007df2:	68fb      	ldr	r3, [r7, #12]
 8007df4:	edd3 7a0d 	vldr	s15, [r3, #52]	@ 0x34
 8007df8:	eebf 7a00 	vmov.f32	s14, #240	@ 0xbf800000 -1.0
 8007dfc:	eef4 7a47 	vcmp.f32	s15, s14
 8007e00:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007e04:	d102      	bne.n	8007e0c <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0x1ac>
  {
    return LIS2DU12_ERROR;
 8007e06:	f04f 33ff 	mov.w	r3, #4294967295
 8007e0a:	e004      	b.n	8007e16 <LIS2DU12_ACC_SetOutputDataRate_When_Enabled+0x1b6>
  }

  /* Store the current Power value */
  pObj->acc_ultra_low_power = Power;
 8007e0c:	68fb      	ldr	r3, [r7, #12]
 8007e0e:	79fa      	ldrb	r2, [r7, #7]
 8007e10:	f883 2038 	strb.w	r2, [r3, #56]	@ 0x38

  return LIS2DU12_OK;
 8007e14:	2300      	movs	r3, #0
}
 8007e16:	4618      	mov	r0, r3
 8007e18:	3718      	adds	r7, #24
 8007e1a:	46bd      	mov	sp, r7
 8007e1c:	bd80      	pop	{r7, pc}
 8007e1e:	bf00      	nop
 8007e20:	42480000 	.word	0x42480000
 8007e24:	42c80000 	.word	0x42c80000
 8007e28:	43480000 	.word	0x43480000
 8007e2c:	43c80000 	.word	0x43c80000
 8007e30:	44480000 	.word	0x44480000
 8007e34:	bf800000 	.word	0xbf800000
 8007e38:	43c80000 	.word	0x43c80000
 8007e3c:	43480000 	.word	0x43480000
 8007e40:	42c80000 	.word	0x42c80000
 8007e44:	42480000 	.word	0x42480000
 8007e48:	41c80000 	.word	0x41c80000
 8007e4c:	41480000 	.word	0x41480000
 8007e50:	40c00000 	.word	0x40c00000
 8007e54:	40400000 	.word	0x40400000

08007e58 <LIS2DU12_ACC_SetOutputDataRate_When_Disabled>:
  * @param  Power the ultra low power option
  * @retval 0 in case of success, an error code otherwise
  */
static int32_t LIS2DU12_ACC_SetOutputDataRate_When_Disabled(LIS2DU12_Object_t *pObj, float Odr,
                                                            LIS2DU12_Ultra_Low_Power_t Power)
{
 8007e58:	b480      	push	{r7}
 8007e5a:	b085      	sub	sp, #20
 8007e5c:	af00      	add	r7, sp, #0
 8007e5e:	60f8      	str	r0, [r7, #12]
 8007e60:	60b9      	str	r1, [r7, #8]
 8007e62:	4613      	mov	r3, r2
 8007e64:	71fb      	strb	r3, [r7, #7]
  /* Store the new Odr value */
  if (Power == LIS2DU12_ULTRA_LOW_POWER_ENABLE)
 8007e66:	79fb      	ldrb	r3, [r7, #7]
 8007e68:	2b01      	cmp	r3, #1
 8007e6a:	d11a      	bne.n	8007ea2 <LIS2DU12_ACC_SetOutputDataRate_When_Disabled+0x4a>
  {
    pObj->acc_odr = (Odr <= 1.5f) ? 1.5f
                    : (Odr <= 3.0f) ? 3.0f
 8007e6c:	edd7 7a02 	vldr	s15, [r7, #8]
 8007e70:	eeb7 7a08 	vmov.f32	s14, #120	@ 0x3fc00000  1.5
 8007e74:	eef4 7ac7 	vcmpe.f32	s15, s14
 8007e78:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007e7c:	d802      	bhi.n	8007e84 <LIS2DU12_ACC_SetOutputDataRate_When_Disabled+0x2c>
 8007e7e:	f04f 537f 	mov.w	r3, #1069547520	@ 0x3fc00000
 8007e82:	e00b      	b.n	8007e9c <LIS2DU12_ACC_SetOutputDataRate_When_Disabled+0x44>
                    :                 6.0f;
 8007e84:	edd7 7a02 	vldr	s15, [r7, #8]
 8007e88:	eeb0 7a08 	vmov.f32	s14, #8	@ 0x40400000  3.0
 8007e8c:	eef4 7ac7 	vcmpe.f32	s15, s14
 8007e90:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007e94:	d801      	bhi.n	8007e9a <LIS2DU12_ACC_SetOutputDataRate_When_Disabled+0x42>
 8007e96:	4b30      	ldr	r3, [pc, #192]	@ (8007f58 <LIS2DU12_ACC_SetOutputDataRate_When_Disabled+0x100>)
 8007e98:	e000      	b.n	8007e9c <LIS2DU12_ACC_SetOutputDataRate_When_Disabled+0x44>
 8007e9a:	4b30      	ldr	r3, [pc, #192]	@ (8007f5c <LIS2DU12_ACC_SetOutputDataRate_When_Disabled+0x104>)
    pObj->acc_odr = (Odr <= 1.5f) ? 1.5f
 8007e9c:	68fa      	ldr	r2, [r7, #12]
 8007e9e:	6353      	str	r3, [r2, #52]	@ 0x34
 8007ea0:	e04f      	b.n	8007f42 <LIS2DU12_ACC_SetOutputDataRate_When_Disabled+0xea>
  }
  else
  {
    pObj->acc_odr = (Odr <=   6.0f) ?   6.0f
                    : (Odr <=  12.5f) ?  12.5f
 8007ea2:	edd7 7a02 	vldr	s15, [r7, #8]
 8007ea6:	eeb1 7a08 	vmov.f32	s14, #24	@ 0x40c00000  6.0
 8007eaa:	eef4 7ac7 	vcmpe.f32	s15, s14
 8007eae:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007eb2:	d801      	bhi.n	8007eb8 <LIS2DU12_ACC_SetOutputDataRate_When_Disabled+0x60>
 8007eb4:	4b29      	ldr	r3, [pc, #164]	@ (8007f5c <LIS2DU12_ACC_SetOutputDataRate_When_Disabled+0x104>)
 8007eb6:	e042      	b.n	8007f3e <LIS2DU12_ACC_SetOutputDataRate_When_Disabled+0xe6>
                    : (Odr <=  25.0f) ?  25.0f
 8007eb8:	edd7 7a02 	vldr	s15, [r7, #8]
 8007ebc:	eeb2 7a09 	vmov.f32	s14, #41	@ 0x41480000  12.5
 8007ec0:	eef4 7ac7 	vcmpe.f32	s15, s14
 8007ec4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007ec8:	d801      	bhi.n	8007ece <LIS2DU12_ACC_SetOutputDataRate_When_Disabled+0x76>
 8007eca:	4b25      	ldr	r3, [pc, #148]	@ (8007f60 <LIS2DU12_ACC_SetOutputDataRate_When_Disabled+0x108>)
 8007ecc:	e037      	b.n	8007f3e <LIS2DU12_ACC_SetOutputDataRate_When_Disabled+0xe6>
                    : (Odr <=  50.0f) ?  50.0f
 8007ece:	edd7 7a02 	vldr	s15, [r7, #8]
 8007ed2:	eeb3 7a09 	vmov.f32	s14, #57	@ 0x41c80000  25.0
 8007ed6:	eef4 7ac7 	vcmpe.f32	s15, s14
 8007eda:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007ede:	d801      	bhi.n	8007ee4 <LIS2DU12_ACC_SetOutputDataRate_When_Disabled+0x8c>
 8007ee0:	4b20      	ldr	r3, [pc, #128]	@ (8007f64 <LIS2DU12_ACC_SetOutputDataRate_When_Disabled+0x10c>)
 8007ee2:	e02c      	b.n	8007f3e <LIS2DU12_ACC_SetOutputDataRate_When_Disabled+0xe6>
                    : (Odr <= 100.0f) ? 100.0f
 8007ee4:	edd7 7a02 	vldr	s15, [r7, #8]
 8007ee8:	ed9f 7a1f 	vldr	s14, [pc, #124]	@ 8007f68 <LIS2DU12_ACC_SetOutputDataRate_When_Disabled+0x110>
 8007eec:	eef4 7ac7 	vcmpe.f32	s15, s14
 8007ef0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007ef4:	d801      	bhi.n	8007efa <LIS2DU12_ACC_SetOutputDataRate_When_Disabled+0xa2>
 8007ef6:	4b1d      	ldr	r3, [pc, #116]	@ (8007f6c <LIS2DU12_ACC_SetOutputDataRate_When_Disabled+0x114>)
 8007ef8:	e021      	b.n	8007f3e <LIS2DU12_ACC_SetOutputDataRate_When_Disabled+0xe6>
                    : (Odr <= 200.0f) ? 200.0f
 8007efa:	edd7 7a02 	vldr	s15, [r7, #8]
 8007efe:	ed9f 7a1c 	vldr	s14, [pc, #112]	@ 8007f70 <LIS2DU12_ACC_SetOutputDataRate_When_Disabled+0x118>
 8007f02:	eef4 7ac7 	vcmpe.f32	s15, s14
 8007f06:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007f0a:	d801      	bhi.n	8007f10 <LIS2DU12_ACC_SetOutputDataRate_When_Disabled+0xb8>
 8007f0c:	4b19      	ldr	r3, [pc, #100]	@ (8007f74 <LIS2DU12_ACC_SetOutputDataRate_When_Disabled+0x11c>)
 8007f0e:	e016      	b.n	8007f3e <LIS2DU12_ACC_SetOutputDataRate_When_Disabled+0xe6>
                    : (Odr <= 400.0f) ? 400.0f
 8007f10:	edd7 7a02 	vldr	s15, [r7, #8]
 8007f14:	ed9f 7a18 	vldr	s14, [pc, #96]	@ 8007f78 <LIS2DU12_ACC_SetOutputDataRate_When_Disabled+0x120>
 8007f18:	eef4 7ac7 	vcmpe.f32	s15, s14
 8007f1c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007f20:	d801      	bhi.n	8007f26 <LIS2DU12_ACC_SetOutputDataRate_When_Disabled+0xce>
 8007f22:	4b16      	ldr	r3, [pc, #88]	@ (8007f7c <LIS2DU12_ACC_SetOutputDataRate_When_Disabled+0x124>)
 8007f24:	e00b      	b.n	8007f3e <LIS2DU12_ACC_SetOutputDataRate_When_Disabled+0xe6>
                    :                   800.0f;
 8007f26:	edd7 7a02 	vldr	s15, [r7, #8]
 8007f2a:	ed9f 7a15 	vldr	s14, [pc, #84]	@ 8007f80 <LIS2DU12_ACC_SetOutputDataRate_When_Disabled+0x128>
 8007f2e:	eef4 7ac7 	vcmpe.f32	s15, s14
 8007f32:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007f36:	d801      	bhi.n	8007f3c <LIS2DU12_ACC_SetOutputDataRate_When_Disabled+0xe4>
 8007f38:	4b12      	ldr	r3, [pc, #72]	@ (8007f84 <LIS2DU12_ACC_SetOutputDataRate_When_Disabled+0x12c>)
 8007f3a:	e000      	b.n	8007f3e <LIS2DU12_ACC_SetOutputDataRate_When_Disabled+0xe6>
 8007f3c:	4b12      	ldr	r3, [pc, #72]	@ (8007f88 <LIS2DU12_ACC_SetOutputDataRate_When_Disabled+0x130>)
    pObj->acc_odr = (Odr <=   6.0f) ?   6.0f
 8007f3e:	68fa      	ldr	r2, [r7, #12]
 8007f40:	6353      	str	r3, [r2, #52]	@ 0x34
  }

  /* Store the new Power value */
  pObj->acc_ultra_low_power = Power;
 8007f42:	68fb      	ldr	r3, [r7, #12]
 8007f44:	79fa      	ldrb	r2, [r7, #7]
 8007f46:	f883 2038 	strb.w	r2, [r3, #56]	@ 0x38

  return LIS2DU12_OK;
 8007f4a:	2300      	movs	r3, #0
}
 8007f4c:	4618      	mov	r0, r3
 8007f4e:	3714      	adds	r7, #20
 8007f50:	46bd      	mov	sp, r7
 8007f52:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007f56:	4770      	bx	lr
 8007f58:	40400000 	.word	0x40400000
 8007f5c:	40c00000 	.word	0x40c00000
 8007f60:	41480000 	.word	0x41480000
 8007f64:	41c80000 	.word	0x41c80000
 8007f68:	42480000 	.word	0x42480000
 8007f6c:	42480000 	.word	0x42480000
 8007f70:	42c80000 	.word	0x42c80000
 8007f74:	42c80000 	.word	0x42c80000
 8007f78:	43480000 	.word	0x43480000
 8007f7c:	43480000 	.word	0x43480000
 8007f80:	43c80000 	.word	0x43c80000
 8007f84:	43c80000 	.word	0x43c80000
 8007f88:	44480000 	.word	0x44480000

08007f8c <ReadRegWrap>:
  * @param  pData the stored data pointer
  * @param  Length the length
  * @retval 0 in case of success, an error code otherwise
  */
static int32_t ReadRegWrap(void *Handle, uint8_t Reg, uint8_t *pData, uint16_t Length)
{
 8007f8c:	b590      	push	{r4, r7, lr}
 8007f8e:	b087      	sub	sp, #28
 8007f90:	af00      	add	r7, sp, #0
 8007f92:	60f8      	str	r0, [r7, #12]
 8007f94:	607a      	str	r2, [r7, #4]
 8007f96:	461a      	mov	r2, r3
 8007f98:	460b      	mov	r3, r1
 8007f9a:	72fb      	strb	r3, [r7, #11]
 8007f9c:	4613      	mov	r3, r2
 8007f9e:	813b      	strh	r3, [r7, #8]
  LIS2DU12_Object_t *pObj = (LIS2DU12_Object_t *)Handle;
 8007fa0:	68fb      	ldr	r3, [r7, #12]
 8007fa2:	617b      	str	r3, [r7, #20]

  return pObj->IO.ReadReg(pObj->IO.Address, Reg, pData, Length);
 8007fa4:	697b      	ldr	r3, [r7, #20]
 8007fa6:	695c      	ldr	r4, [r3, #20]
 8007fa8:	697b      	ldr	r3, [r7, #20]
 8007faa:	7b1b      	ldrb	r3, [r3, #12]
 8007fac:	4618      	mov	r0, r3
 8007fae:	7afb      	ldrb	r3, [r7, #11]
 8007fb0:	b299      	uxth	r1, r3
 8007fb2:	893b      	ldrh	r3, [r7, #8]
 8007fb4:	687a      	ldr	r2, [r7, #4]
 8007fb6:	47a0      	blx	r4
 8007fb8:	4603      	mov	r3, r0
}
 8007fba:	4618      	mov	r0, r3
 8007fbc:	371c      	adds	r7, #28
 8007fbe:	46bd      	mov	sp, r7
 8007fc0:	bd90      	pop	{r4, r7, pc}

08007fc2 <WriteRegWrap>:
  * @param  pData the stored data pointer
  * @param  Length the length
  * @retval 0 in case of success, an error code otherwise
  */
static int32_t WriteRegWrap(void *Handle, uint8_t Reg, uint8_t *pData, uint16_t Length)
{
 8007fc2:	b590      	push	{r4, r7, lr}
 8007fc4:	b087      	sub	sp, #28
 8007fc6:	af00      	add	r7, sp, #0
 8007fc8:	60f8      	str	r0, [r7, #12]
 8007fca:	607a      	str	r2, [r7, #4]
 8007fcc:	461a      	mov	r2, r3
 8007fce:	460b      	mov	r3, r1
 8007fd0:	72fb      	strb	r3, [r7, #11]
 8007fd2:	4613      	mov	r3, r2
 8007fd4:	813b      	strh	r3, [r7, #8]
  LIS2DU12_Object_t *pObj = (LIS2DU12_Object_t *)Handle;
 8007fd6:	68fb      	ldr	r3, [r7, #12]
 8007fd8:	617b      	str	r3, [r7, #20]

  return pObj->IO.WriteReg(pObj->IO.Address, Reg, pData, Length);
 8007fda:	697b      	ldr	r3, [r7, #20]
 8007fdc:	691c      	ldr	r4, [r3, #16]
 8007fde:	697b      	ldr	r3, [r7, #20]
 8007fe0:	7b1b      	ldrb	r3, [r3, #12]
 8007fe2:	4618      	mov	r0, r3
 8007fe4:	7afb      	ldrb	r3, [r7, #11]
 8007fe6:	b299      	uxth	r1, r3
 8007fe8:	893b      	ldrh	r3, [r7, #8]
 8007fea:	687a      	ldr	r2, [r7, #4]
 8007fec:	47a0      	blx	r4
 8007fee:	4603      	mov	r3, r0
}
 8007ff0:	4618      	mov	r0, r3
 8007ff2:	371c      	adds	r7, #28
 8007ff4:	46bd      	mov	sp, r7
 8007ff6:	bd90      	pop	{r4, r7, pc}

08007ff8 <lis2du12_read_reg>:
  * @retval       interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lis2du12_read_reg(stmdev_ctx_t *ctx, uint8_t reg, uint8_t *data,
                          uint16_t len)
{
 8007ff8:	b590      	push	{r4, r7, lr}
 8007ffa:	b087      	sub	sp, #28
 8007ffc:	af00      	add	r7, sp, #0
 8007ffe:	60f8      	str	r0, [r7, #12]
 8008000:	607a      	str	r2, [r7, #4]
 8008002:	461a      	mov	r2, r3
 8008004:	460b      	mov	r3, r1
 8008006:	72fb      	strb	r3, [r7, #11]
 8008008:	4613      	mov	r3, r2
 800800a:	813b      	strh	r3, [r7, #8]
  int32_t ret;
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800800c:	68fb      	ldr	r3, [r7, #12]
 800800e:	685c      	ldr	r4, [r3, #4]
 8008010:	68fb      	ldr	r3, [r7, #12]
 8008012:	68d8      	ldr	r0, [r3, #12]
 8008014:	893b      	ldrh	r3, [r7, #8]
 8008016:	7af9      	ldrb	r1, [r7, #11]
 8008018:	687a      	ldr	r2, [r7, #4]
 800801a:	47a0      	blx	r4
 800801c:	6178      	str	r0, [r7, #20]
  return ret;
 800801e:	697b      	ldr	r3, [r7, #20]
}
 8008020:	4618      	mov	r0, r3
 8008022:	371c      	adds	r7, #28
 8008024:	46bd      	mov	sp, r7
 8008026:	bd90      	pop	{r4, r7, pc}

08008028 <lis2du12_write_reg>:
  * @retval       interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lis2du12_write_reg(stmdev_ctx_t *ctx, uint8_t reg, uint8_t *data,
                           uint16_t len)
{
 8008028:	b590      	push	{r4, r7, lr}
 800802a:	b087      	sub	sp, #28
 800802c:	af00      	add	r7, sp, #0
 800802e:	60f8      	str	r0, [r7, #12]
 8008030:	607a      	str	r2, [r7, #4]
 8008032:	461a      	mov	r2, r3
 8008034:	460b      	mov	r3, r1
 8008036:	72fb      	strb	r3, [r7, #11]
 8008038:	4613      	mov	r3, r2
 800803a:	813b      	strh	r3, [r7, #8]
  int32_t ret;
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800803c:	68fb      	ldr	r3, [r7, #12]
 800803e:	681c      	ldr	r4, [r3, #0]
 8008040:	68fb      	ldr	r3, [r7, #12]
 8008042:	68d8      	ldr	r0, [r3, #12]
 8008044:	893b      	ldrh	r3, [r7, #8]
 8008046:	7af9      	ldrb	r1, [r7, #11]
 8008048:	687a      	ldr	r2, [r7, #4]
 800804a:	47a0      	blx	r4
 800804c:	6178      	str	r0, [r7, #20]
  return ret;
 800804e:	697b      	ldr	r3, [r7, #20]
}
 8008050:	4618      	mov	r0, r3
 8008052:	371c      	adds	r7, #28
 8008054:	46bd      	mov	sp, r7
 8008056:	bd90      	pop	{r4, r7, pc}

08008058 <bytecpy>:
  * @{
  *
  */

static void bytecpy(uint8_t *target, uint8_t *source)
{
 8008058:	b480      	push	{r7}
 800805a:	b083      	sub	sp, #12
 800805c:	af00      	add	r7, sp, #0
 800805e:	6078      	str	r0, [r7, #4]
 8008060:	6039      	str	r1, [r7, #0]
  if ((target != NULL) && (source != NULL))
 8008062:	687b      	ldr	r3, [r7, #4]
 8008064:	2b00      	cmp	r3, #0
 8008066:	d006      	beq.n	8008076 <bytecpy+0x1e>
 8008068:	683b      	ldr	r3, [r7, #0]
 800806a:	2b00      	cmp	r3, #0
 800806c:	d003      	beq.n	8008076 <bytecpy+0x1e>
  {
    *target = *source;
 800806e:	683b      	ldr	r3, [r7, #0]
 8008070:	781a      	ldrb	r2, [r3, #0]
 8008072:	687b      	ldr	r3, [r7, #4]
 8008074:	701a      	strb	r2, [r3, #0]
  }
}
 8008076:	bf00      	nop
 8008078:	370c      	adds	r7, #12
 800807a:	46bd      	mov	sp, r7
 800807c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008080:	4770      	bx	lr
	...

08008084 <lis2du12_from_fs2g_to_mg>:
  * @{
  *
  */

float_t lis2du12_from_fs2g_to_mg(int16_t lsb)
{
 8008084:	b480      	push	{r7}
 8008086:	b083      	sub	sp, #12
 8008088:	af00      	add	r7, sp, #0
 800808a:	4603      	mov	r3, r0
 800808c:	80fb      	strh	r3, [r7, #6]
  return (float_t)lsb * 0.061f;
 800808e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8008092:	ee07 3a90 	vmov	s15, r3
 8008096:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800809a:	ed9f 7a06 	vldr	s14, [pc, #24]	@ 80080b4 <lis2du12_from_fs2g_to_mg+0x30>
 800809e:	ee67 7a87 	vmul.f32	s15, s15, s14
 80080a2:	ee17 3a90 	vmov	r3, s15
}
 80080a6:	4618      	mov	r0, r3
 80080a8:	370c      	adds	r7, #12
 80080aa:	46bd      	mov	sp, r7
 80080ac:	f85d 7b04 	ldr.w	r7, [sp], #4
 80080b0:	4770      	bx	lr
 80080b2:	bf00      	nop
 80080b4:	3d79db23 	.word	0x3d79db23

080080b8 <lis2du12_from_fs4g_to_mg>:

float_t lis2du12_from_fs4g_to_mg(int16_t lsb)
{
 80080b8:	b480      	push	{r7}
 80080ba:	b083      	sub	sp, #12
 80080bc:	af00      	add	r7, sp, #0
 80080be:	4603      	mov	r3, r0
 80080c0:	80fb      	strh	r3, [r7, #6]
  return (float_t)lsb * 0.122f;
 80080c2:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 80080c6:	ee07 3a90 	vmov	s15, r3
 80080ca:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80080ce:	ed9f 7a06 	vldr	s14, [pc, #24]	@ 80080e8 <lis2du12_from_fs4g_to_mg+0x30>
 80080d2:	ee67 7a87 	vmul.f32	s15, s15, s14
 80080d6:	ee17 3a90 	vmov	r3, s15
}
 80080da:	4618      	mov	r0, r3
 80080dc:	370c      	adds	r7, #12
 80080de:	46bd      	mov	sp, r7
 80080e0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80080e4:	4770      	bx	lr
 80080e6:	bf00      	nop
 80080e8:	3df9db23 	.word	0x3df9db23

080080ec <lis2du12_from_fs8g_to_mg>:

float_t lis2du12_from_fs8g_to_mg(int16_t lsb)
{
 80080ec:	b480      	push	{r7}
 80080ee:	b083      	sub	sp, #12
 80080f0:	af00      	add	r7, sp, #0
 80080f2:	4603      	mov	r3, r0
 80080f4:	80fb      	strh	r3, [r7, #6]
  return (float_t)lsb * 0.244f;
 80080f6:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 80080fa:	ee07 3a90 	vmov	s15, r3
 80080fe:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8008102:	ed9f 7a06 	vldr	s14, [pc, #24]	@ 800811c <lis2du12_from_fs8g_to_mg+0x30>
 8008106:	ee67 7a87 	vmul.f32	s15, s15, s14
 800810a:	ee17 3a90 	vmov	r3, s15
}
 800810e:	4618      	mov	r0, r3
 8008110:	370c      	adds	r7, #12
 8008112:	46bd      	mov	sp, r7
 8008114:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008118:	4770      	bx	lr
 800811a:	bf00      	nop
 800811c:	3e79db23 	.word	0x3e79db23

08008120 <lis2du12_from_fs16g_to_mg>:

float_t lis2du12_from_fs16g_to_mg(int16_t lsb)
{
 8008120:	b480      	push	{r7}
 8008122:	b083      	sub	sp, #12
 8008124:	af00      	add	r7, sp, #0
 8008126:	4603      	mov	r3, r0
 8008128:	80fb      	strh	r3, [r7, #6]
  return (float_t)lsb * 0.488f;
 800812a:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 800812e:	ee07 3a90 	vmov	s15, r3
 8008132:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8008136:	ed9f 7a06 	vldr	s14, [pc, #24]	@ 8008150 <lis2du12_from_fs16g_to_mg+0x30>
 800813a:	ee67 7a87 	vmul.f32	s15, s15, s14
 800813e:	ee17 3a90 	vmov	r3, s15
}
 8008142:	4618      	mov	r0, r3
 8008144:	370c      	adds	r7, #12
 8008146:	46bd      	mov	sp, r7
 8008148:	f85d 7b04 	ldr.w	r7, [sp], #4
 800814c:	4770      	bx	lr
 800814e:	bf00      	nop
 8008150:	3ef9db23 	.word	0x3ef9db23

08008154 <lis2du12_from_lsb_to_celsius>:

float_t lis2du12_from_lsb_to_celsius(int16_t lsb)
{
 8008154:	b480      	push	{r7}
 8008156:	b083      	sub	sp, #12
 8008158:	af00      	add	r7, sp, #0
 800815a:	4603      	mov	r3, r0
 800815c:	80fb      	strh	r3, [r7, #6]
  return ((float_t)lsb / 355.5f) + 25.0f;
 800815e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8008162:	ee07 3a90 	vmov	s15, r3
 8008166:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 800816a:	eddf 6a08 	vldr	s13, [pc, #32]	@ 800818c <lis2du12_from_lsb_to_celsius+0x38>
 800816e:	eec7 7a26 	vdiv.f32	s15, s14, s13
 8008172:	eeb3 7a09 	vmov.f32	s14, #57	@ 0x41c80000  25.0
 8008176:	ee77 7a87 	vadd.f32	s15, s15, s14
 800817a:	ee17 3a90 	vmov	r3, s15
}
 800817e:	4618      	mov	r0, r3
 8008180:	370c      	adds	r7, #12
 8008182:	46bd      	mov	sp, r7
 8008184:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008188:	4770      	bx	lr
 800818a:	bf00      	nop
 800818c:	43b1c000 	.word	0x43b1c000

08008190 <lis2du12_id_get>:
  * @param  val   ID values.(ptr)
  * @retval       interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lis2du12_id_get(stmdev_ctx_t *ctx, lis2du12_id_t *val)
{
 8008190:	b580      	push	{r7, lr}
 8008192:	b084      	sub	sp, #16
 8008194:	af00      	add	r7, sp, #0
 8008196:	6078      	str	r0, [r7, #4]
 8008198:	6039      	str	r1, [r7, #0]
  uint8_t reg;
  int32_t ret;

  ret = lis2du12_read_reg(ctx, LIS2DU12_WHO_AM_I, &reg, 1);
 800819a:	f107 020b 	add.w	r2, r7, #11
 800819e:	2301      	movs	r3, #1
 80081a0:	2143      	movs	r1, #67	@ 0x43
 80081a2:	6878      	ldr	r0, [r7, #4]
 80081a4:	f7ff ff28 	bl	8007ff8 <lis2du12_read_reg>
 80081a8:	60f8      	str	r0, [r7, #12]
  val->whoami = reg;
 80081aa:	7afa      	ldrb	r2, [r7, #11]
 80081ac:	683b      	ldr	r3, [r7, #0]
 80081ae:	701a      	strb	r2, [r3, #0]

  return ret;
 80081b0:	68fb      	ldr	r3, [r7, #12]
}
 80081b2:	4618      	mov	r0, r3
 80081b4:	3710      	adds	r7, #16
 80081b6:	46bd      	mov	sp, r7
 80081b8:	bd80      	pop	{r7, pc}

080081ba <lis2du12_bus_mode_set>:
  * @param  val   configures the bus operating mode.(ptr)
  * @retval       interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lis2du12_bus_mode_set(stmdev_ctx_t *ctx, lis2du12_bus_mode_t val)
{
 80081ba:	b580      	push	{r7, lr}
 80081bc:	b086      	sub	sp, #24
 80081be:	af00      	add	r7, sp, #0
 80081c0:	6078      	str	r0, [r7, #4]
 80081c2:	460b      	mov	r3, r1
 80081c4:	70fb      	strb	r3, [r7, #3]
  lis2du12_if_ctrl_t if_ctrl;
  lis2du12_ctrl1_t ctrl1;
  int32_t ret;

  ret = lis2du12_read_reg(ctx, LIS2DU12_IF_CTRL, (uint8_t *)&if_ctrl, 1);
 80081c6:	f107 0210 	add.w	r2, r7, #16
 80081ca:	2301      	movs	r3, #1
 80081cc:	210e      	movs	r1, #14
 80081ce:	6878      	ldr	r0, [r7, #4]
 80081d0:	f7ff ff12 	bl	8007ff8 <lis2du12_read_reg>
 80081d4:	6178      	str	r0, [r7, #20]
  if (ret == 0)
 80081d6:	697b      	ldr	r3, [r7, #20]
 80081d8:	2b00      	cmp	r3, #0
 80081da:	d118      	bne.n	800820e <lis2du12_bus_mode_set+0x54>
  {
    if_ctrl.i3c_disable = (uint8_t)val & 0x01U;
 80081dc:	78fb      	ldrb	r3, [r7, #3]
 80081de:	f003 0301 	and.w	r3, r3, #1
 80081e2:	b2da      	uxtb	r2, r3
 80081e4:	7c3b      	ldrb	r3, [r7, #16]
 80081e6:	f362 0341 	bfi	r3, r2, #1, #1
 80081ea:	743b      	strb	r3, [r7, #16]
    if_ctrl.i2c_disable = ((uint8_t)val & 0x02U) >> 1;
 80081ec:	78fb      	ldrb	r3, [r7, #3]
 80081ee:	085b      	lsrs	r3, r3, #1
 80081f0:	f003 0301 	and.w	r3, r3, #1
 80081f4:	b2da      	uxtb	r2, r3
 80081f6:	7c3b      	ldrb	r3, [r7, #16]
 80081f8:	f362 0300 	bfi	r3, r2, #0, #1
 80081fc:	743b      	strb	r3, [r7, #16]
    ret = lis2du12_write_reg(ctx, LIS2DU12_IF_CTRL, (uint8_t *)&if_ctrl, 1);
 80081fe:	f107 0210 	add.w	r2, r7, #16
 8008202:	2301      	movs	r3, #1
 8008204:	210e      	movs	r1, #14
 8008206:	6878      	ldr	r0, [r7, #4]
 8008208:	f7ff ff0e 	bl	8008028 <lis2du12_write_reg>
 800820c:	6178      	str	r0, [r7, #20]
  }
  if (ret == 0)
 800820e:	697b      	ldr	r3, [r7, #20]
 8008210:	2b00      	cmp	r3, #0
 8008212:	d107      	bne.n	8008224 <lis2du12_bus_mode_set+0x6a>
  {
    ret = lis2du12_read_reg(ctx, LIS2DU12_CTRL1, (uint8_t *)&ctrl1, 1);
 8008214:	f107 020c 	add.w	r2, r7, #12
 8008218:	2301      	movs	r3, #1
 800821a:	2110      	movs	r1, #16
 800821c:	6878      	ldr	r0, [r7, #4]
 800821e:	f7ff feeb 	bl	8007ff8 <lis2du12_read_reg>
 8008222:	6178      	str	r0, [r7, #20]
  }
  if (ret == 0)
 8008224:	697b      	ldr	r3, [r7, #20]
 8008226:	2b00      	cmp	r3, #0
 8008228:	d110      	bne.n	800824c <lis2du12_bus_mode_set+0x92>
  {
    ctrl1.sim = ((uint8_t)val & 0x04U) >> 2;
 800822a:	78fb      	ldrb	r3, [r7, #3]
 800822c:	089b      	lsrs	r3, r3, #2
 800822e:	f003 0301 	and.w	r3, r3, #1
 8008232:	b2da      	uxtb	r2, r3
 8008234:	7b3b      	ldrb	r3, [r7, #12]
 8008236:	f362 1386 	bfi	r3, r2, #6, #1
 800823a:	733b      	strb	r3, [r7, #12]
    ret = lis2du12_write_reg(ctx, LIS2DU12_CTRL1, (uint8_t *)&ctrl1, 1);
 800823c:	f107 020c 	add.w	r2, r7, #12
 8008240:	2301      	movs	r3, #1
 8008242:	2110      	movs	r1, #16
 8008244:	6878      	ldr	r0, [r7, #4]
 8008246:	f7ff feef 	bl	8008028 <lis2du12_write_reg>
 800824a:	6178      	str	r0, [r7, #20]
  }

  return ret;
 800824c:	697b      	ldr	r3, [r7, #20]

}
 800824e:	4618      	mov	r0, r3
 8008250:	3718      	adds	r7, #24
 8008252:	46bd      	mov	sp, r7
 8008254:	bd80      	pop	{r7, pc}

08008256 <lis2du12_init_set>:
  * @param  val   configures the bus operating mode.(ptr)
  * @retval       interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lis2du12_init_set(stmdev_ctx_t *ctx, lis2du12_init_t val)
{
 8008256:	b580      	push	{r7, lr}
 8008258:	b086      	sub	sp, #24
 800825a:	af00      	add	r7, sp, #0
 800825c:	6078      	str	r0, [r7, #4]
 800825e:	460b      	mov	r3, r1
 8008260:	70fb      	strb	r3, [r7, #3]
  lis2du12_ctrl1_t ctrl1;
  lis2du12_ctrl4_t ctrl4;
  int32_t ret;

  ret = lis2du12_read_reg(ctx, LIS2DU12_CTRL1, (uint8_t *)&ctrl1, 1);
 8008262:	f107 0210 	add.w	r2, r7, #16
 8008266:	2301      	movs	r3, #1
 8008268:	2110      	movs	r1, #16
 800826a:	6878      	ldr	r0, [r7, #4]
 800826c:	f7ff fec4 	bl	8007ff8 <lis2du12_read_reg>
 8008270:	6178      	str	r0, [r7, #20]
  ret = lis2du12_read_reg(ctx, LIS2DU12_CTRL4, (uint8_t *)&ctrl4, 1);
 8008272:	f107 020c 	add.w	r2, r7, #12
 8008276:	2301      	movs	r3, #1
 8008278:	2113      	movs	r1, #19
 800827a:	6878      	ldr	r0, [r7, #4]
 800827c:	f7ff febc 	bl	8007ff8 <lis2du12_read_reg>
 8008280:	6178      	str	r0, [r7, #20]
  switch (val)
 8008282:	78fb      	ldrb	r3, [r7, #3]
 8008284:	2b02      	cmp	r3, #2
 8008286:	d012      	beq.n	80082ae <lis2du12_init_set+0x58>
 8008288:	2b02      	cmp	r3, #2
 800828a:	dc39      	bgt.n	8008300 <lis2du12_init_set+0xaa>
 800828c:	2b00      	cmp	r3, #0
 800828e:	d01b      	beq.n	80082c8 <lis2du12_init_set+0x72>
 8008290:	2b01      	cmp	r3, #1
 8008292:	d135      	bne.n	8008300 <lis2du12_init_set+0xaa>
  {
    case LIS2DU12_BOOT:
      ctrl4.boot = PROPERTY_ENABLE;
 8008294:	7b3b      	ldrb	r3, [r7, #12]
 8008296:	f043 0301 	orr.w	r3, r3, #1
 800829a:	733b      	strb	r3, [r7, #12]
      ret = lis2du12_write_reg(ctx, LIS2DU12_CTRL4, (uint8_t *)&ctrl4, 1);
 800829c:	f107 020c 	add.w	r2, r7, #12
 80082a0:	2301      	movs	r3, #1
 80082a2:	2113      	movs	r1, #19
 80082a4:	6878      	ldr	r0, [r7, #4]
 80082a6:	f7ff febf 	bl	8008028 <lis2du12_write_reg>
 80082aa:	6178      	str	r0, [r7, #20]
      break;
 80082ac:	e036      	b.n	800831c <lis2du12_init_set+0xc6>
    case LIS2DU12_RESET:

      ctrl1.sw_reset = PROPERTY_ENABLE;
 80082ae:	7c3b      	ldrb	r3, [r7, #16]
 80082b0:	f043 0320 	orr.w	r3, r3, #32
 80082b4:	743b      	strb	r3, [r7, #16]
      ret = lis2du12_write_reg(ctx, LIS2DU12_CTRL1, (uint8_t *)&ctrl1, 1);
 80082b6:	f107 0210 	add.w	r2, r7, #16
 80082ba:	2301      	movs	r3, #1
 80082bc:	2110      	movs	r1, #16
 80082be:	6878      	ldr	r0, [r7, #4]
 80082c0:	f7ff feb2 	bl	8008028 <lis2du12_write_reg>
 80082c4:	6178      	str	r0, [r7, #20]
      break;
 80082c6:	e029      	b.n	800831c <lis2du12_init_set+0xc6>
    case LIS2DU12_DRV_RDY:
      ctrl4.bdu = PROPERTY_ENABLE;
 80082c8:	7b3b      	ldrb	r3, [r7, #12]
 80082ca:	f043 0320 	orr.w	r3, r3, #32
 80082ce:	733b      	strb	r3, [r7, #12]
      ctrl1.if_add_inc = PROPERTY_ENABLE;
 80082d0:	7c3b      	ldrb	r3, [r7, #16]
 80082d2:	f043 0310 	orr.w	r3, r3, #16
 80082d6:	743b      	strb	r3, [r7, #16]
      ret = lis2du12_write_reg(ctx, LIS2DU12_CTRL4, (uint8_t *)&ctrl4, 1);
 80082d8:	f107 020c 	add.w	r2, r7, #12
 80082dc:	2301      	movs	r3, #1
 80082de:	2113      	movs	r1, #19
 80082e0:	6878      	ldr	r0, [r7, #4]
 80082e2:	f7ff fea1 	bl	8008028 <lis2du12_write_reg>
 80082e6:	6178      	str	r0, [r7, #20]
      if (ret == 0)
 80082e8:	697b      	ldr	r3, [r7, #20]
 80082ea:	2b00      	cmp	r3, #0
 80082ec:	d115      	bne.n	800831a <lis2du12_init_set+0xc4>
      {
        ret = lis2du12_write_reg(ctx, LIS2DU12_CTRL1, (uint8_t *)&ctrl1, 1);
 80082ee:	f107 0210 	add.w	r2, r7, #16
 80082f2:	2301      	movs	r3, #1
 80082f4:	2110      	movs	r1, #16
 80082f6:	6878      	ldr	r0, [r7, #4]
 80082f8:	f7ff fe96 	bl	8008028 <lis2du12_write_reg>
 80082fc:	6178      	str	r0, [r7, #20]
      }
      break;
 80082fe:	e00c      	b.n	800831a <lis2du12_init_set+0xc4>
    default:
      ctrl1.sw_reset = PROPERTY_ENABLE;
 8008300:	7c3b      	ldrb	r3, [r7, #16]
 8008302:	f043 0320 	orr.w	r3, r3, #32
 8008306:	743b      	strb	r3, [r7, #16]
      ret = lis2du12_write_reg(ctx, LIS2DU12_CTRL1, (uint8_t *)&ctrl1, 1);
 8008308:	f107 0210 	add.w	r2, r7, #16
 800830c:	2301      	movs	r3, #1
 800830e:	2110      	movs	r1, #16
 8008310:	6878      	ldr	r0, [r7, #4]
 8008312:	f7ff fe89 	bl	8008028 <lis2du12_write_reg>
 8008316:	6178      	str	r0, [r7, #20]
      break;
 8008318:	e000      	b.n	800831c <lis2du12_init_set+0xc6>
      break;
 800831a:	bf00      	nop
  }
  return ret;
 800831c:	697b      	ldr	r3, [r7, #20]
}
 800831e:	4618      	mov	r0, r3
 8008320:	3718      	adds	r7, #24
 8008322:	46bd      	mov	sp, r7
 8008324:	bd80      	pop	{r7, pc}

08008326 <lis2du12_mode_set>:
  * @param  val   set the sensor conversion parameters.(ptr)
  * @retval       interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lis2du12_mode_set(stmdev_ctx_t *ctx, lis2du12_md_t *val)
{
 8008326:	b580      	push	{r7, lr}
 8008328:	b084      	sub	sp, #16
 800832a:	af00      	add	r7, sp, #0
 800832c:	6078      	str	r0, [r7, #4]
 800832e:	6039      	str	r1, [r7, #0]
  lis2du12_ctrl5_t ctrl5;
  int32_t ret;

  ret = lis2du12_read_reg(ctx, LIS2DU12_CTRL5, (uint8_t *)&ctrl5, 1);
 8008330:	f107 0208 	add.w	r2, r7, #8
 8008334:	2301      	movs	r3, #1
 8008336:	2114      	movs	r1, #20
 8008338:	6878      	ldr	r0, [r7, #4]
 800833a:	f7ff fe5d 	bl	8007ff8 <lis2du12_read_reg>
 800833e:	60f8      	str	r0, [r7, #12]

  ctrl5.odr = (uint8_t)val->odr;
 8008340:	683b      	ldr	r3, [r7, #0]
 8008342:	781b      	ldrb	r3, [r3, #0]
 8008344:	f003 030f 	and.w	r3, r3, #15
 8008348:	b2da      	uxtb	r2, r3
 800834a:	7a3b      	ldrb	r3, [r7, #8]
 800834c:	f362 1307 	bfi	r3, r2, #4, #4
 8008350:	723b      	strb	r3, [r7, #8]
  ctrl5.fs = (uint8_t)val->fs;
 8008352:	683b      	ldr	r3, [r7, #0]
 8008354:	785b      	ldrb	r3, [r3, #1]
 8008356:	f003 0303 	and.w	r3, r3, #3
 800835a:	b2da      	uxtb	r2, r3
 800835c:	7a3b      	ldrb	r3, [r7, #8]
 800835e:	f362 0301 	bfi	r3, r2, #0, #2
 8008362:	723b      	strb	r3, [r7, #8]
  ctrl5.bw = (uint8_t)val->bw;
 8008364:	683b      	ldr	r3, [r7, #0]
 8008366:	789b      	ldrb	r3, [r3, #2]
 8008368:	f003 0303 	and.w	r3, r3, #3
 800836c:	b2da      	uxtb	r2, r3
 800836e:	7a3b      	ldrb	r3, [r7, #8]
 8008370:	f362 0383 	bfi	r3, r2, #2, #2
 8008374:	723b      	strb	r3, [r7, #8]

  if (ret == 0)
 8008376:	68fb      	ldr	r3, [r7, #12]
 8008378:	2b00      	cmp	r3, #0
 800837a:	d107      	bne.n	800838c <lis2du12_mode_set+0x66>
  {
    ret = lis2du12_write_reg(ctx, LIS2DU12_CTRL5, (uint8_t *)&ctrl5, 1);
 800837c:	f107 0208 	add.w	r2, r7, #8
 8008380:	2301      	movs	r3, #1
 8008382:	2114      	movs	r1, #20
 8008384:	6878      	ldr	r0, [r7, #4]
 8008386:	f7ff fe4f 	bl	8008028 <lis2du12_write_reg>
 800838a:	60f8      	str	r0, [r7, #12]
  }

  return ret;
 800838c:	68fb      	ldr	r3, [r7, #12]
}
 800838e:	4618      	mov	r0, r3
 8008390:	3710      	adds	r7, #16
 8008392:	46bd      	mov	sp, r7
 8008394:	bd80      	pop	{r7, pc}
	...

08008398 <lis2du12_mode_get>:
  * @param  val   get the sensor conversion parameters.(ptr)
  * @retval       interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lis2du12_mode_get(stmdev_ctx_t *ctx, lis2du12_md_t *val)
{
 8008398:	b580      	push	{r7, lr}
 800839a:	b084      	sub	sp, #16
 800839c:	af00      	add	r7, sp, #0
 800839e:	6078      	str	r0, [r7, #4]
 80083a0:	6039      	str	r1, [r7, #0]
  lis2du12_ctrl5_t ctrl5;
  int32_t ret;

  ret = lis2du12_read_reg(ctx, LIS2DU12_CTRL5, (uint8_t *)&ctrl5, 1);
 80083a2:	f107 0208 	add.w	r2, r7, #8
 80083a6:	2301      	movs	r3, #1
 80083a8:	2114      	movs	r1, #20
 80083aa:	6878      	ldr	r0, [r7, #4]
 80083ac:	f7ff fe24 	bl	8007ff8 <lis2du12_read_reg>
 80083b0:	60f8      	str	r0, [r7, #12]

  switch (ctrl5.odr)
 80083b2:	7a3b      	ldrb	r3, [r7, #8]
 80083b4:	f3c3 1303 	ubfx	r3, r3, #4, #4
 80083b8:	b2db      	uxtb	r3, r3
 80083ba:	2b0f      	cmp	r3, #15
 80083bc:	d85a      	bhi.n	8008474 <lis2du12_mode_get+0xdc>
 80083be:	a201      	add	r2, pc, #4	@ (adr r2, 80083c4 <lis2du12_mode_get+0x2c>)
 80083c0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80083c4:	08008405 	.word	0x08008405
 80083c8:	0800840d 	.word	0x0800840d
 80083cc:	08008415 	.word	0x08008415
 80083d0:	0800841d 	.word	0x0800841d
 80083d4:	08008425 	.word	0x08008425
 80083d8:	0800842d 	.word	0x0800842d
 80083dc:	08008435 	.word	0x08008435
 80083e0:	0800843d 	.word	0x0800843d
 80083e4:	08008445 	.word	0x08008445
 80083e8:	0800844d 	.word	0x0800844d
 80083ec:	08008455 	.word	0x08008455
 80083f0:	0800845d 	.word	0x0800845d
 80083f4:	08008475 	.word	0x08008475
 80083f8:	08008475 	.word	0x08008475
 80083fc:	08008465 	.word	0x08008465
 8008400:	0800846d 	.word	0x0800846d
  {
    case LIS2DU12_OFF:
      val->odr = LIS2DU12_OFF;
 8008404:	683b      	ldr	r3, [r7, #0]
 8008406:	2200      	movs	r2, #0
 8008408:	701a      	strb	r2, [r3, #0]
      break;
 800840a:	e037      	b.n	800847c <lis2du12_mode_get+0xe4>
    case LIS2DU12_1Hz5_ULP:
      val->odr = LIS2DU12_1Hz5_ULP;
 800840c:	683b      	ldr	r3, [r7, #0]
 800840e:	2201      	movs	r2, #1
 8008410:	701a      	strb	r2, [r3, #0]
      break;
 8008412:	e033      	b.n	800847c <lis2du12_mode_get+0xe4>
    case LIS2DU12_3Hz_ULP:
      val->odr = LIS2DU12_3Hz_ULP;
 8008414:	683b      	ldr	r3, [r7, #0]
 8008416:	2202      	movs	r2, #2
 8008418:	701a      	strb	r2, [r3, #0]
      break;
 800841a:	e02f      	b.n	800847c <lis2du12_mode_get+0xe4>
    case LIS2DU12_6Hz_ULP:
      val->odr = LIS2DU12_6Hz_ULP;
 800841c:	683b      	ldr	r3, [r7, #0]
 800841e:	2203      	movs	r2, #3
 8008420:	701a      	strb	r2, [r3, #0]
      break;
 8008422:	e02b      	b.n	800847c <lis2du12_mode_get+0xe4>
    case LIS2DU12_6Hz:
      val->odr = LIS2DU12_6Hz;
 8008424:	683b      	ldr	r3, [r7, #0]
 8008426:	2204      	movs	r2, #4
 8008428:	701a      	strb	r2, [r3, #0]
      break;
 800842a:	e027      	b.n	800847c <lis2du12_mode_get+0xe4>
    case LIS2DU12_12Hz5:
      val->odr = LIS2DU12_12Hz5;
 800842c:	683b      	ldr	r3, [r7, #0]
 800842e:	2205      	movs	r2, #5
 8008430:	701a      	strb	r2, [r3, #0]
      break;
 8008432:	e023      	b.n	800847c <lis2du12_mode_get+0xe4>
    case LIS2DU12_25Hz:
      val->odr = LIS2DU12_25Hz;
 8008434:	683b      	ldr	r3, [r7, #0]
 8008436:	2206      	movs	r2, #6
 8008438:	701a      	strb	r2, [r3, #0]
      break;
 800843a:	e01f      	b.n	800847c <lis2du12_mode_get+0xe4>
    case LIS2DU12_50Hz:
      val->odr = LIS2DU12_50Hz;
 800843c:	683b      	ldr	r3, [r7, #0]
 800843e:	2207      	movs	r2, #7
 8008440:	701a      	strb	r2, [r3, #0]
      break;
 8008442:	e01b      	b.n	800847c <lis2du12_mode_get+0xe4>
    case LIS2DU12_100Hz:
      val->odr = LIS2DU12_100Hz;
 8008444:	683b      	ldr	r3, [r7, #0]
 8008446:	2208      	movs	r2, #8
 8008448:	701a      	strb	r2, [r3, #0]
      break;
 800844a:	e017      	b.n	800847c <lis2du12_mode_get+0xe4>
    case LIS2DU12_200Hz:
      val->odr = LIS2DU12_200Hz;
 800844c:	683b      	ldr	r3, [r7, #0]
 800844e:	2209      	movs	r2, #9
 8008450:	701a      	strb	r2, [r3, #0]
      break;
 8008452:	e013      	b.n	800847c <lis2du12_mode_get+0xe4>
    case LIS2DU12_400Hz:
      val->odr = LIS2DU12_400Hz;
 8008454:	683b      	ldr	r3, [r7, #0]
 8008456:	220a      	movs	r2, #10
 8008458:	701a      	strb	r2, [r3, #0]
      break;
 800845a:	e00f      	b.n	800847c <lis2du12_mode_get+0xe4>
    case LIS2DU12_800Hz:
      val->odr = LIS2DU12_800Hz;
 800845c:	683b      	ldr	r3, [r7, #0]
 800845e:	220b      	movs	r2, #11
 8008460:	701a      	strb	r2, [r3, #0]
      break;
 8008462:	e00b      	b.n	800847c <lis2du12_mode_get+0xe4>
    case LIS2DU12_TRIG_PIN:
      val->odr = LIS2DU12_TRIG_PIN;
 8008464:	683b      	ldr	r3, [r7, #0]
 8008466:	220e      	movs	r2, #14
 8008468:	701a      	strb	r2, [r3, #0]
      break;
 800846a:	e007      	b.n	800847c <lis2du12_mode_get+0xe4>
    case LIS2DU12_TRIG_SW:
      val->odr = LIS2DU12_TRIG_SW;
 800846c:	683b      	ldr	r3, [r7, #0]
 800846e:	220f      	movs	r2, #15
 8008470:	701a      	strb	r2, [r3, #0]
      break;
 8008472:	e003      	b.n	800847c <lis2du12_mode_get+0xe4>
    default:
      val->odr = LIS2DU12_OFF;
 8008474:	683b      	ldr	r3, [r7, #0]
 8008476:	2200      	movs	r2, #0
 8008478:	701a      	strb	r2, [r3, #0]
      break;
 800847a:	bf00      	nop
  }

  switch (ctrl5.fs)
 800847c:	7a3b      	ldrb	r3, [r7, #8]
 800847e:	f3c3 0301 	ubfx	r3, r3, #0, #2
 8008482:	b2db      	uxtb	r3, r3
 8008484:	2b03      	cmp	r3, #3
 8008486:	d81b      	bhi.n	80084c0 <lis2du12_mode_get+0x128>
 8008488:	a201      	add	r2, pc, #4	@ (adr r2, 8008490 <lis2du12_mode_get+0xf8>)
 800848a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800848e:	bf00      	nop
 8008490:	080084a1 	.word	0x080084a1
 8008494:	080084a9 	.word	0x080084a9
 8008498:	080084b1 	.word	0x080084b1
 800849c:	080084b9 	.word	0x080084b9
  {
    case LIS2DU12_2g:
      val->fs = LIS2DU12_2g;
 80084a0:	683b      	ldr	r3, [r7, #0]
 80084a2:	2200      	movs	r2, #0
 80084a4:	705a      	strb	r2, [r3, #1]
      break;
 80084a6:	e00f      	b.n	80084c8 <lis2du12_mode_get+0x130>
    case LIS2DU12_4g:
      val->fs = LIS2DU12_4g;
 80084a8:	683b      	ldr	r3, [r7, #0]
 80084aa:	2201      	movs	r2, #1
 80084ac:	705a      	strb	r2, [r3, #1]
      break;
 80084ae:	e00b      	b.n	80084c8 <lis2du12_mode_get+0x130>
    case LIS2DU12_8g:
      val->fs = LIS2DU12_8g;
 80084b0:	683b      	ldr	r3, [r7, #0]
 80084b2:	2202      	movs	r2, #2
 80084b4:	705a      	strb	r2, [r3, #1]
      break;
 80084b6:	e007      	b.n	80084c8 <lis2du12_mode_get+0x130>
    case LIS2DU12_16g:
      val->fs = LIS2DU12_16g;
 80084b8:	683b      	ldr	r3, [r7, #0]
 80084ba:	2203      	movs	r2, #3
 80084bc:	705a      	strb	r2, [r3, #1]
      break;
 80084be:	e003      	b.n	80084c8 <lis2du12_mode_get+0x130>
    default:
      val->fs = LIS2DU12_2g;
 80084c0:	683b      	ldr	r3, [r7, #0]
 80084c2:	2200      	movs	r2, #0
 80084c4:	705a      	strb	r2, [r3, #1]
      break;
 80084c6:	bf00      	nop
  }

  switch (ctrl5.bw)
 80084c8:	7a3b      	ldrb	r3, [r7, #8]
 80084ca:	f3c3 0381 	ubfx	r3, r3, #2, #2
 80084ce:	b2db      	uxtb	r3, r3
 80084d0:	2b03      	cmp	r3, #3
 80084d2:	d81b      	bhi.n	800850c <lis2du12_mode_get+0x174>
 80084d4:	a201      	add	r2, pc, #4	@ (adr r2, 80084dc <lis2du12_mode_get+0x144>)
 80084d6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80084da:	bf00      	nop
 80084dc:	080084ed 	.word	0x080084ed
 80084e0:	080084f5 	.word	0x080084f5
 80084e4:	080084fd 	.word	0x080084fd
 80084e8:	08008505 	.word	0x08008505
  {
    case LIS2DU12_ODR_div_2:
      val->bw = LIS2DU12_ODR_div_2;
 80084ec:	683b      	ldr	r3, [r7, #0]
 80084ee:	2200      	movs	r2, #0
 80084f0:	709a      	strb	r2, [r3, #2]
      break;
 80084f2:	e00f      	b.n	8008514 <lis2du12_mode_get+0x17c>
    case LIS2DU12_ODR_div_4:
      val->bw = LIS2DU12_ODR_div_4;
 80084f4:	683b      	ldr	r3, [r7, #0]
 80084f6:	2201      	movs	r2, #1
 80084f8:	709a      	strb	r2, [r3, #2]
      break;
 80084fa:	e00b      	b.n	8008514 <lis2du12_mode_get+0x17c>
    case LIS2DU12_ODR_div_8:
      val->bw = LIS2DU12_ODR_div_8;
 80084fc:	683b      	ldr	r3, [r7, #0]
 80084fe:	2202      	movs	r2, #2
 8008500:	709a      	strb	r2, [r3, #2]
      break;
 8008502:	e007      	b.n	8008514 <lis2du12_mode_get+0x17c>
    case LIS2DU12_ODR_div_16:
      val->bw = LIS2DU12_ODR_div_16;
 8008504:	683b      	ldr	r3, [r7, #0]
 8008506:	2203      	movs	r2, #3
 8008508:	709a      	strb	r2, [r3, #2]
      break;
 800850a:	e003      	b.n	8008514 <lis2du12_mode_get+0x17c>
    default:
      val->bw = LIS2DU12_ODR_div_2;
 800850c:	683b      	ldr	r3, [r7, #0]
 800850e:	2200      	movs	r2, #0
 8008510:	709a      	strb	r2, [r3, #2]
      break;
 8008512:	bf00      	nop
  }

  return ret;
 8008514:	68fb      	ldr	r3, [r7, #12]
}
 8008516:	4618      	mov	r0, r3
 8008518:	3710      	adds	r7, #16
 800851a:	46bd      	mov	sp, r7
 800851c:	bd80      	pop	{r7, pc}
 800851e:	bf00      	nop

08008520 <lis2du12_data_get>:
  * @retval       interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lis2du12_data_get(stmdev_ctx_t *ctx, lis2du12_md_t *md,
                          lis2du12_data_t *data)
{
 8008520:	b590      	push	{r4, r7, lr}
 8008522:	b089      	sub	sp, #36	@ 0x24
 8008524:	af00      	add	r7, sp, #0
 8008526:	60f8      	str	r0, [r7, #12]
 8008528:	60b9      	str	r1, [r7, #8]
 800852a:	607a      	str	r2, [r7, #4]
  uint8_t buff[8];
  int32_t ret;
  uint8_t i;
  uint8_t j;

  ret = lis2du12_read_reg(ctx, LIS2DU12_OUTX_L, (uint8_t *)&buff, 8);
 800852c:	f107 0210 	add.w	r2, r7, #16
 8008530:	2308      	movs	r3, #8
 8008532:	2128      	movs	r1, #40	@ 0x28
 8008534:	68f8      	ldr	r0, [r7, #12]
 8008536:	f7ff fd5f 	bl	8007ff8 <lis2du12_read_reg>
 800853a:	61b8      	str	r0, [r7, #24]

  /* acceleration conversion */
  j = 0U;
 800853c:	2300      	movs	r3, #0
 800853e:	77bb      	strb	r3, [r7, #30]
  for (i = 0U; i < 3U; i++)
 8008540:	2300      	movs	r3, #0
 8008542:	77fb      	strb	r3, [r7, #31]
 8008544:	e087      	b.n	8008656 <lis2du12_data_get+0x136>
  {
    data->xl.raw[i] = (int16_t)buff[j + 1U];
 8008546:	7fbb      	ldrb	r3, [r7, #30]
 8008548:	3301      	adds	r3, #1
 800854a:	3320      	adds	r3, #32
 800854c:	443b      	add	r3, r7
 800854e:	f813 2c10 	ldrb.w	r2, [r3, #-16]
 8008552:	7ffb      	ldrb	r3, [r7, #31]
 8008554:	b211      	sxth	r1, r2
 8008556:	687a      	ldr	r2, [r7, #4]
 8008558:	3304      	adds	r3, #4
 800855a:	005b      	lsls	r3, r3, #1
 800855c:	4413      	add	r3, r2
 800855e:	460a      	mov	r2, r1
 8008560:	809a      	strh	r2, [r3, #4]
    data->xl.raw[i] = (data->xl.raw[i] * 256) + (int16_t) buff[j];
 8008562:	7ffb      	ldrb	r3, [r7, #31]
 8008564:	687a      	ldr	r2, [r7, #4]
 8008566:	3304      	adds	r3, #4
 8008568:	005b      	lsls	r3, r3, #1
 800856a:	4413      	add	r3, r2
 800856c:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8008570:	b29b      	uxth	r3, r3
 8008572:	021b      	lsls	r3, r3, #8
 8008574:	b29b      	uxth	r3, r3
 8008576:	7fba      	ldrb	r2, [r7, #30]
 8008578:	3220      	adds	r2, #32
 800857a:	443a      	add	r2, r7
 800857c:	f812 2c10 	ldrb.w	r2, [r2, #-16]
 8008580:	4413      	add	r3, r2
 8008582:	b29a      	uxth	r2, r3
 8008584:	7ffb      	ldrb	r3, [r7, #31]
 8008586:	b211      	sxth	r1, r2
 8008588:	687a      	ldr	r2, [r7, #4]
 800858a:	3304      	adds	r3, #4
 800858c:	005b      	lsls	r3, r3, #1
 800858e:	4413      	add	r3, r2
 8008590:	460a      	mov	r2, r1
 8008592:	809a      	strh	r2, [r3, #4]
    j += 2U;
 8008594:	7fbb      	ldrb	r3, [r7, #30]
 8008596:	3302      	adds	r3, #2
 8008598:	77bb      	strb	r3, [r7, #30]
    switch (md->fs)
 800859a:	68bb      	ldr	r3, [r7, #8]
 800859c:	785b      	ldrb	r3, [r3, #1]
 800859e:	2b03      	cmp	r3, #3
 80085a0:	d84e      	bhi.n	8008640 <lis2du12_data_get+0x120>
 80085a2:	a201      	add	r2, pc, #4	@ (adr r2, 80085a8 <lis2du12_data_get+0x88>)
 80085a4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80085a8:	080085b9 	.word	0x080085b9
 80085ac:	080085db 	.word	0x080085db
 80085b0:	080085fd 	.word	0x080085fd
 80085b4:	0800861f 	.word	0x0800861f
    {
      case LIS2DU12_2g:
        data->xl.mg[i] = lis2du12_from_fs2g_to_mg(data->xl.raw[i]);
 80085b8:	7ffb      	ldrb	r3, [r7, #31]
 80085ba:	687a      	ldr	r2, [r7, #4]
 80085bc:	3304      	adds	r3, #4
 80085be:	005b      	lsls	r3, r3, #1
 80085c0:	4413      	add	r3, r2
 80085c2:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 80085c6:	7ffc      	ldrb	r4, [r7, #31]
 80085c8:	4618      	mov	r0, r3
 80085ca:	f7ff fd5b 	bl	8008084 <lis2du12_from_fs2g_to_mg>
 80085ce:	4601      	mov	r1, r0
 80085d0:	687a      	ldr	r2, [r7, #4]
 80085d2:	00a3      	lsls	r3, r4, #2
 80085d4:	4413      	add	r3, r2
 80085d6:	6019      	str	r1, [r3, #0]
        break;
 80085d8:	e03a      	b.n	8008650 <lis2du12_data_get+0x130>
      case LIS2DU12_4g:
        data->xl.mg[i] = lis2du12_from_fs4g_to_mg(data->xl.raw[i]);
 80085da:	7ffb      	ldrb	r3, [r7, #31]
 80085dc:	687a      	ldr	r2, [r7, #4]
 80085de:	3304      	adds	r3, #4
 80085e0:	005b      	lsls	r3, r3, #1
 80085e2:	4413      	add	r3, r2
 80085e4:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 80085e8:	7ffc      	ldrb	r4, [r7, #31]
 80085ea:	4618      	mov	r0, r3
 80085ec:	f7ff fd64 	bl	80080b8 <lis2du12_from_fs4g_to_mg>
 80085f0:	4601      	mov	r1, r0
 80085f2:	687a      	ldr	r2, [r7, #4]
 80085f4:	00a3      	lsls	r3, r4, #2
 80085f6:	4413      	add	r3, r2
 80085f8:	6019      	str	r1, [r3, #0]
        break;
 80085fa:	e029      	b.n	8008650 <lis2du12_data_get+0x130>
      case LIS2DU12_8g:
        data->xl.mg[i] = lis2du12_from_fs8g_to_mg(data->xl.raw[i]);
 80085fc:	7ffb      	ldrb	r3, [r7, #31]
 80085fe:	687a      	ldr	r2, [r7, #4]
 8008600:	3304      	adds	r3, #4
 8008602:	005b      	lsls	r3, r3, #1
 8008604:	4413      	add	r3, r2
 8008606:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 800860a:	7ffc      	ldrb	r4, [r7, #31]
 800860c:	4618      	mov	r0, r3
 800860e:	f7ff fd6d 	bl	80080ec <lis2du12_from_fs8g_to_mg>
 8008612:	4601      	mov	r1, r0
 8008614:	687a      	ldr	r2, [r7, #4]
 8008616:	00a3      	lsls	r3, r4, #2
 8008618:	4413      	add	r3, r2
 800861a:	6019      	str	r1, [r3, #0]
        break;
 800861c:	e018      	b.n	8008650 <lis2du12_data_get+0x130>
      case LIS2DU12_16g:
        data->xl.mg[i] = lis2du12_from_fs16g_to_mg(data->xl.raw[i]);
 800861e:	7ffb      	ldrb	r3, [r7, #31]
 8008620:	687a      	ldr	r2, [r7, #4]
 8008622:	3304      	adds	r3, #4
 8008624:	005b      	lsls	r3, r3, #1
 8008626:	4413      	add	r3, r2
 8008628:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 800862c:	7ffc      	ldrb	r4, [r7, #31]
 800862e:	4618      	mov	r0, r3
 8008630:	f7ff fd76 	bl	8008120 <lis2du12_from_fs16g_to_mg>
 8008634:	4601      	mov	r1, r0
 8008636:	687a      	ldr	r2, [r7, #4]
 8008638:	00a3      	lsls	r3, r4, #2
 800863a:	4413      	add	r3, r2
 800863c:	6019      	str	r1, [r3, #0]
        break;
 800863e:	e007      	b.n	8008650 <lis2du12_data_get+0x130>
      default:
        data->xl.mg[i] = 0.0f;
 8008640:	7ffb      	ldrb	r3, [r7, #31]
 8008642:	687a      	ldr	r2, [r7, #4]
 8008644:	009b      	lsls	r3, r3, #2
 8008646:	4413      	add	r3, r2
 8008648:	f04f 0200 	mov.w	r2, #0
 800864c:	601a      	str	r2, [r3, #0]
        break;
 800864e:	bf00      	nop
  for (i = 0U; i < 3U; i++)
 8008650:	7ffb      	ldrb	r3, [r7, #31]
 8008652:	3301      	adds	r3, #1
 8008654:	77fb      	strb	r3, [r7, #31]
 8008656:	7ffb      	ldrb	r3, [r7, #31]
 8008658:	2b02      	cmp	r3, #2
 800865a:	f67f af74 	bls.w	8008546 <lis2du12_data_get+0x26>
    }
  }

  data->heat.raw = (int16_t)buff[j + 1U];
 800865e:	7fbb      	ldrb	r3, [r7, #30]
 8008660:	3301      	adds	r3, #1
 8008662:	3320      	adds	r3, #32
 8008664:	443b      	add	r3, r7
 8008666:	f813 3c10 	ldrb.w	r3, [r3, #-16]
 800866a:	b21a      	sxth	r2, r3
 800866c:	687b      	ldr	r3, [r7, #4]
 800866e:	831a      	strh	r2, [r3, #24]
  data->heat.raw = (data->heat.raw * 256) + (int16_t) buff[j];
 8008670:	687b      	ldr	r3, [r7, #4]
 8008672:	f9b3 3018 	ldrsh.w	r3, [r3, #24]
 8008676:	b29b      	uxth	r3, r3
 8008678:	021b      	lsls	r3, r3, #8
 800867a:	b29b      	uxth	r3, r3
 800867c:	7fba      	ldrb	r2, [r7, #30]
 800867e:	3220      	adds	r2, #32
 8008680:	443a      	add	r2, r7
 8008682:	f812 2c10 	ldrb.w	r2, [r2, #-16]
 8008686:	4413      	add	r3, r2
 8008688:	b29b      	uxth	r3, r3
 800868a:	b21a      	sxth	r2, r3
 800868c:	687b      	ldr	r3, [r7, #4]
 800868e:	831a      	strh	r2, [r3, #24]
  /* temperature conversion */
  data->heat.deg_c = lis2du12_from_lsb_to_celsius(data->heat.raw);
 8008690:	687b      	ldr	r3, [r7, #4]
 8008692:	f9b3 3018 	ldrsh.w	r3, [r3, #24]
 8008696:	4618      	mov	r0, r3
 8008698:	f7ff fd5c 	bl	8008154 <lis2du12_from_lsb_to_celsius>
 800869c:	4602      	mov	r2, r0
 800869e:	687b      	ldr	r3, [r7, #4]
 80086a0:	615a      	str	r2, [r3, #20]

  return ret;
 80086a2:	69bb      	ldr	r3, [r7, #24]
}
 80086a4:	4618      	mov	r0, r3
 80086a6:	3724      	adds	r7, #36	@ 0x24
 80086a8:	46bd      	mov	sp, r7
 80086aa:	bd90      	pop	{r4, r7, pc}

080086ac <lis2du12_fifo_mode_set>:
  * @param  val   set the FIFO operation mode.(ptr)
  * @retval       interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lis2du12_fifo_mode_set(stmdev_ctx_t *ctx, lis2du12_fifo_md_t *val)
{
 80086ac:	b580      	push	{r7, lr}
 80086ae:	b086      	sub	sp, #24
 80086b0:	af00      	add	r7, sp, #0
 80086b2:	6078      	str	r0, [r7, #4]
 80086b4:	6039      	str	r1, [r7, #0]
  lis2du12_fifo_ctrl_t fifo_ctrl;
  lis2du12_fifo_wtm_t fifo_wtm;
  uint8_t reg[2];
  int32_t ret;

  ret = lis2du12_read_reg(ctx, LIS2DU12_FIFO_CTRL, reg, 2);
 80086b6:	f107 0208 	add.w	r2, r7, #8
 80086ba:	2302      	movs	r3, #2
 80086bc:	2115      	movs	r1, #21
 80086be:	6878      	ldr	r0, [r7, #4]
 80086c0:	f7ff fc9a 	bl	8007ff8 <lis2du12_read_reg>
 80086c4:	6178      	str	r0, [r7, #20]

  bytecpy((uint8_t *)&fifo_ctrl, &reg[0]);
 80086c6:	f107 0208 	add.w	r2, r7, #8
 80086ca:	f107 0310 	add.w	r3, r7, #16
 80086ce:	4611      	mov	r1, r2
 80086d0:	4618      	mov	r0, r3
 80086d2:	f7ff fcc1 	bl	8008058 <bytecpy>
  bytecpy((uint8_t *)&fifo_wtm, &reg[1]);
 80086d6:	f107 0308 	add.w	r3, r7, #8
 80086da:	1c5a      	adds	r2, r3, #1
 80086dc:	f107 030c 	add.w	r3, r7, #12
 80086e0:	4611      	mov	r1, r2
 80086e2:	4618      	mov	r0, r3
 80086e4:	f7ff fcb8 	bl	8008058 <bytecpy>

  fifo_ctrl.f_mode = (uint8_t) val->operation;
 80086e8:	683b      	ldr	r3, [r7, #0]
 80086ea:	781b      	ldrb	r3, [r3, #0]
 80086ec:	f003 0307 	and.w	r3, r3, #7
 80086f0:	b2da      	uxtb	r2, r3
 80086f2:	7c3b      	ldrb	r3, [r7, #16]
 80086f4:	f362 0302 	bfi	r3, r2, #0, #3
 80086f8:	743b      	strb	r3, [r7, #16]
  fifo_ctrl.fifo_depth = (uint8_t) val->store;
 80086fa:	683b      	ldr	r3, [r7, #0]
 80086fc:	785b      	ldrb	r3, [r3, #1]
 80086fe:	f003 0301 	and.w	r3, r3, #1
 8008702:	b2da      	uxtb	r2, r3
 8008704:	7c3b      	ldrb	r3, [r7, #16]
 8008706:	f362 1386 	bfi	r3, r2, #6, #1
 800870a:	743b      	strb	r3, [r7, #16]

  if (val->watermark != 0x00U)
 800870c:	683b      	ldr	r3, [r7, #0]
 800870e:	789b      	ldrb	r3, [r3, #2]
 8008710:	2b00      	cmp	r3, #0
 8008712:	d004      	beq.n	800871e <lis2du12_fifo_mode_set+0x72>
  {
    fifo_ctrl.stop_on_fth = PROPERTY_ENABLE;
 8008714:	7c3b      	ldrb	r3, [r7, #16]
 8008716:	f043 0308 	orr.w	r3, r3, #8
 800871a:	743b      	strb	r3, [r7, #16]
 800871c:	e003      	b.n	8008726 <lis2du12_fifo_mode_set+0x7a>
  }
  else
  {
    fifo_ctrl.stop_on_fth = PROPERTY_DISABLE;
 800871e:	7c3b      	ldrb	r3, [r7, #16]
 8008720:	f023 0308 	bic.w	r3, r3, #8
 8008724:	743b      	strb	r3, [r7, #16]
  }

  fifo_wtm.fth = val->watermark;
 8008726:	683b      	ldr	r3, [r7, #0]
 8008728:	789b      	ldrb	r3, [r3, #2]
 800872a:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 800872e:	b2da      	uxtb	r2, r3
 8008730:	7b3b      	ldrb	r3, [r7, #12]
 8008732:	f362 0306 	bfi	r3, r2, #0, #7
 8008736:	733b      	strb	r3, [r7, #12]

  bytecpy(&reg[0], (uint8_t *)&fifo_ctrl);
 8008738:	f107 0210 	add.w	r2, r7, #16
 800873c:	f107 0308 	add.w	r3, r7, #8
 8008740:	4611      	mov	r1, r2
 8008742:	4618      	mov	r0, r3
 8008744:	f7ff fc88 	bl	8008058 <bytecpy>
  bytecpy(&reg[1], (uint8_t *)&fifo_wtm);
 8008748:	f107 020c 	add.w	r2, r7, #12
 800874c:	f107 0308 	add.w	r3, r7, #8
 8008750:	3301      	adds	r3, #1
 8008752:	4611      	mov	r1, r2
 8008754:	4618      	mov	r0, r3
 8008756:	f7ff fc7f 	bl	8008058 <bytecpy>

  ret = lis2du12_write_reg(ctx, LIS2DU12_FIFO_CTRL, reg, 2);
 800875a:	f107 0208 	add.w	r2, r7, #8
 800875e:	2302      	movs	r3, #2
 8008760:	2115      	movs	r1, #21
 8008762:	6878      	ldr	r0, [r7, #4]
 8008764:	f7ff fc60 	bl	8008028 <lis2du12_write_reg>
 8008768:	6178      	str	r0, [r7, #20]

  return ret;
 800876a:	697b      	ldr	r3, [r7, #20]
}
 800876c:	4618      	mov	r0, r3
 800876e:	3718      	adds	r7, #24
 8008770:	46bd      	mov	sp, r7
 8008772:	bd80      	pop	{r7, pc}

08008774 <LIS2MDL_RegisterBusIO>:
  * @brief  Register Component Bus IO operations
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2MDL_RegisterBusIO(LIS2MDL_Object_t *pObj, LIS2MDL_IO_t *pIO)
{
 8008774:	b580      	push	{r7, lr}
 8008776:	b084      	sub	sp, #16
 8008778:	af00      	add	r7, sp, #0
 800877a:	6078      	str	r0, [r7, #4]
 800877c:	6039      	str	r1, [r7, #0]
  int32_t ret = LIS2MDL_OK;
 800877e:	2300      	movs	r3, #0
 8008780:	60fb      	str	r3, [r7, #12]

  if (pObj == NULL)
 8008782:	687b      	ldr	r3, [r7, #4]
 8008784:	2b00      	cmp	r3, #0
 8008786:	d103      	bne.n	8008790 <LIS2MDL_RegisterBusIO+0x1c>
  {
    ret = LIS2MDL_ERROR;
 8008788:	f04f 33ff 	mov.w	r3, #4294967295
 800878c:	60fb      	str	r3, [r7, #12]
 800878e:	e067      	b.n	8008860 <LIS2MDL_RegisterBusIO+0xec>
  }
  else
  {
    pObj->IO.Init      = pIO->Init;
 8008790:	683b      	ldr	r3, [r7, #0]
 8008792:	681a      	ldr	r2, [r3, #0]
 8008794:	687b      	ldr	r3, [r7, #4]
 8008796:	601a      	str	r2, [r3, #0]
    pObj->IO.DeInit    = pIO->DeInit;
 8008798:	683b      	ldr	r3, [r7, #0]
 800879a:	685a      	ldr	r2, [r3, #4]
 800879c:	687b      	ldr	r3, [r7, #4]
 800879e:	605a      	str	r2, [r3, #4]
    pObj->IO.BusType   = pIO->BusType;
 80087a0:	683b      	ldr	r3, [r7, #0]
 80087a2:	689a      	ldr	r2, [r3, #8]
 80087a4:	687b      	ldr	r3, [r7, #4]
 80087a6:	609a      	str	r2, [r3, #8]
    pObj->IO.Address   = pIO->Address;
 80087a8:	683b      	ldr	r3, [r7, #0]
 80087aa:	7b1a      	ldrb	r2, [r3, #12]
 80087ac:	687b      	ldr	r3, [r7, #4]
 80087ae:	731a      	strb	r2, [r3, #12]
    pObj->IO.WriteReg  = pIO->WriteReg;
 80087b0:	683b      	ldr	r3, [r7, #0]
 80087b2:	691a      	ldr	r2, [r3, #16]
 80087b4:	687b      	ldr	r3, [r7, #4]
 80087b6:	611a      	str	r2, [r3, #16]
    pObj->IO.ReadReg   = pIO->ReadReg;
 80087b8:	683b      	ldr	r3, [r7, #0]
 80087ba:	695a      	ldr	r2, [r3, #20]
 80087bc:	687b      	ldr	r3, [r7, #4]
 80087be:	615a      	str	r2, [r3, #20]
    pObj->IO.GetTick   = pIO->GetTick;
 80087c0:	683b      	ldr	r3, [r7, #0]
 80087c2:	699a      	ldr	r2, [r3, #24]
 80087c4:	687b      	ldr	r3, [r7, #4]
 80087c6:	619a      	str	r2, [r3, #24]

    pObj->Ctx.read_reg  = ReadMagRegWrap;
 80087c8:	687b      	ldr	r3, [r7, #4]
 80087ca:	4a28      	ldr	r2, [pc, #160]	@ (800886c <LIS2MDL_RegisterBusIO+0xf8>)
 80087cc:	625a      	str	r2, [r3, #36]	@ 0x24
    pObj->Ctx.write_reg = WriteMagRegWrap;
 80087ce:	687b      	ldr	r3, [r7, #4]
 80087d0:	4a27      	ldr	r2, [pc, #156]	@ (8008870 <LIS2MDL_RegisterBusIO+0xfc>)
 80087d2:	621a      	str	r2, [r3, #32]
    pObj->Ctx.mdelay    = pIO->Delay;
 80087d4:	683b      	ldr	r3, [r7, #0]
 80087d6:	69da      	ldr	r2, [r3, #28]
 80087d8:	687b      	ldr	r3, [r7, #4]
 80087da:	629a      	str	r2, [r3, #40]	@ 0x28
    pObj->Ctx.handle    = pObj;
 80087dc:	687b      	ldr	r3, [r7, #4]
 80087de:	687a      	ldr	r2, [r7, #4]
 80087e0:	62da      	str	r2, [r3, #44]	@ 0x2c

    if (pObj->IO.Init == NULL)
 80087e2:	687b      	ldr	r3, [r7, #4]
 80087e4:	681b      	ldr	r3, [r3, #0]
 80087e6:	2b00      	cmp	r3, #0
 80087e8:	d103      	bne.n	80087f2 <LIS2MDL_RegisterBusIO+0x7e>
    {
      ret = LIS2MDL_ERROR;
 80087ea:	f04f 33ff 	mov.w	r3, #4294967295
 80087ee:	60fb      	str	r3, [r7, #12]
 80087f0:	e036      	b.n	8008860 <LIS2MDL_RegisterBusIO+0xec>
    }
    else if (pObj->IO.Init() != LIS2MDL_OK)
 80087f2:	687b      	ldr	r3, [r7, #4]
 80087f4:	681b      	ldr	r3, [r3, #0]
 80087f6:	4798      	blx	r3
 80087f8:	4603      	mov	r3, r0
 80087fa:	2b00      	cmp	r3, #0
 80087fc:	d003      	beq.n	8008806 <LIS2MDL_RegisterBusIO+0x92>
    {
      ret = LIS2MDL_ERROR;
 80087fe:	f04f 33ff 	mov.w	r3, #4294967295
 8008802:	60fb      	str	r3, [r7, #12]
 8008804:	e02c      	b.n	8008860 <LIS2MDL_RegisterBusIO+0xec>
    }
    else
    {
      if (pObj->IO.BusType != LIS2MDL_I2C_BUS) /* If the bus type is not I2C */
 8008806:	687b      	ldr	r3, [r7, #4]
 8008808:	689b      	ldr	r3, [r3, #8]
 800880a:	2b00      	cmp	r3, #0
 800880c:	d028      	beq.n	8008860 <LIS2MDL_RegisterBusIO+0xec>
      {
        /* Disable I2C interface support and enable eventually SPI 4-Wires only the first time */
        if (pObj->is_initialized == 0U)
 800880e:	687b      	ldr	r3, [r7, #4]
 8008810:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
 8008814:	2b00      	cmp	r3, #0
 8008816:	d123      	bne.n	8008860 <LIS2MDL_RegisterBusIO+0xec>
        {
          if (pObj->IO.BusType == LIS2MDL_SPI_4WIRES_BUS) /* SPI 4-Wires */
 8008818:	687b      	ldr	r3, [r7, #4]
 800881a:	689b      	ldr	r3, [r3, #8]
 800881c:	2b01      	cmp	r3, #1
 800881e:	d10d      	bne.n	800883c <LIS2MDL_RegisterBusIO+0xc8>
          {
            /* Enable SPI 4-Wires and disable I2C support on the component */
            uint8_t data = 0x34;
 8008820:	2334      	movs	r3, #52	@ 0x34
 8008822:	72fb      	strb	r3, [r7, #11]

            if (LIS2MDL_Write_Reg(pObj, LIS2MDL_CFG_REG_C, data) != LIS2MDL_OK)
 8008824:	7afb      	ldrb	r3, [r7, #11]
 8008826:	461a      	mov	r2, r3
 8008828:	2162      	movs	r1, #98	@ 0x62
 800882a:	6878      	ldr	r0, [r7, #4]
 800882c:	f000 fb16 	bl	8008e5c <LIS2MDL_Write_Reg>
 8008830:	4603      	mov	r3, r0
 8008832:	2b00      	cmp	r3, #0
 8008834:	d014      	beq.n	8008860 <LIS2MDL_RegisterBusIO+0xec>
            {
              return LIS2MDL_ERROR;
 8008836:	f04f 33ff 	mov.w	r3, #4294967295
 800883a:	e012      	b.n	8008862 <LIS2MDL_RegisterBusIO+0xee>
            }
          }
          else if (pObj->IO.BusType == LSM6DSOX_SENSORHUB_LIS2MDL_I2C_BUS) /* LSM6DSOX SensorHub with LIS2MDL example */
 800883c:	687b      	ldr	r3, [r7, #4]
 800883e:	689b      	ldr	r3, [r3, #8]
 8008840:	2b03      	cmp	r3, #3
 8008842:	d101      	bne.n	8008848 <LIS2MDL_RegisterBusIO+0xd4>
          {
            /* Do nothing, just keep I2C support on the component */
            return ret;
 8008844:	68fb      	ldr	r3, [r7, #12]
 8008846:	e00c      	b.n	8008862 <LIS2MDL_RegisterBusIO+0xee>
          }
          else
          {
            /* Disable I2C interface on the component */
            if (lis2mdl_i2c_interface_set(&(pObj->Ctx), LIS2MDL_I2C_DISABLE) != LIS2MDL_OK)
 8008848:	687b      	ldr	r3, [r7, #4]
 800884a:	3320      	adds	r3, #32
 800884c:	2101      	movs	r1, #1
 800884e:	4618      	mov	r0, r3
 8008850:	f000 ff67 	bl	8009722 <lis2mdl_i2c_interface_set>
 8008854:	4603      	mov	r3, r0
 8008856:	2b00      	cmp	r3, #0
 8008858:	d002      	beq.n	8008860 <LIS2MDL_RegisterBusIO+0xec>
            {
              return LIS2MDL_ERROR;
 800885a:	f04f 33ff 	mov.w	r3, #4294967295
 800885e:	e000      	b.n	8008862 <LIS2MDL_RegisterBusIO+0xee>
        }
      }
    }
  }

  return ret;
 8008860:	68fb      	ldr	r3, [r7, #12]
}
 8008862:	4618      	mov	r0, r3
 8008864:	3710      	adds	r7, #16
 8008866:	46bd      	mov	sp, r7
 8008868:	bd80      	pop	{r7, pc}
 800886a:	bf00      	nop
 800886c:	08008eb3 	.word	0x08008eb3
 8008870:	08008f35 	.word	0x08008f35

08008874 <LIS2MDL_Init>:
  * @brief  Initialize the LIS2MDL sensor
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2MDL_Init(LIS2MDL_Object_t *pObj)
{
 8008874:	b580      	push	{r7, lr}
 8008876:	b084      	sub	sp, #16
 8008878:	af00      	add	r7, sp, #0
 800887a:	6078      	str	r0, [r7, #4]
  lis2mdl_cfg_reg_a_t reg_a;
  lis2mdl_cfg_reg_c_t reg_c;

  if (pObj->IO.BusType == LSM6DSOX_SENSORHUB_LIS2MDL_I2C_BUS) /* LSM6DSOX SensorHub with LIS2MDL example */
 800887c:	687b      	ldr	r3, [r7, #4]
 800887e:	689b      	ldr	r3, [r3, #8]
 8008880:	2b03      	cmp	r3, #3
 8008882:	d144      	bne.n	800890e <LIS2MDL_Init+0x9a>
  {
    /* Read configuration from CFG_REG_C & CFG_REG_A regs */
    if (LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData(pObj, LIS2MDL_CFG_REG_C, (uint8_t *)&reg_c, 1) != LIS2MDL_OK)
 8008884:	f107 0208 	add.w	r2, r7, #8
 8008888:	2301      	movs	r3, #1
 800888a:	2162      	movs	r1, #98	@ 0x62
 800888c:	6878      	ldr	r0, [r7, #4]
 800888e:	f000 fb92 	bl	8008fb6 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData>
 8008892:	4603      	mov	r3, r0
 8008894:	2b00      	cmp	r3, #0
 8008896:	d002      	beq.n	800889e <LIS2MDL_Init+0x2a>
    {
      return LIS2MDL_ERROR;
 8008898:	f04f 33ff 	mov.w	r3, #4294967295
 800889c:	e06c      	b.n	8008978 <LIS2MDL_Init+0x104>
    }
    if (LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData(pObj, LIS2MDL_CFG_REG_A, (uint8_t *)&reg_a, 1) != LIS2MDL_OK)
 800889e:	f107 020c 	add.w	r2, r7, #12
 80088a2:	2301      	movs	r3, #1
 80088a4:	2160      	movs	r1, #96	@ 0x60
 80088a6:	6878      	ldr	r0, [r7, #4]
 80088a8:	f000 fb85 	bl	8008fb6 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData>
 80088ac:	4603      	mov	r3, r0
 80088ae:	2b00      	cmp	r3, #0
 80088b0:	d002      	beq.n	80088b8 <LIS2MDL_Init+0x44>
    {
      return LIS2MDL_ERROR;
 80088b2:	f04f 33ff 	mov.w	r3, #4294967295
 80088b6:	e05f      	b.n	8008978 <LIS2MDL_Init+0x104>
    }

    /* Enable BDU */
    reg_c.bdu = PROPERTY_ENABLE;
 80088b8:	7a3b      	ldrb	r3, [r7, #8]
 80088ba:	f043 0310 	orr.w	r3, r3, #16
 80088be:	723b      	strb	r3, [r7, #8]

    /* Self Test disabled. */
    reg_c.self_test = PROPERTY_DISABLE;
 80088c0:	7a3b      	ldrb	r3, [r7, #8]
 80088c2:	f023 0302 	bic.w	r3, r3, #2
 80088c6:	723b      	strb	r3, [r7, #8]

    /* Operating mode selection - power down */
    reg_a.md = LIS2MDL_POWER_DOWN;
 80088c8:	7b3b      	ldrb	r3, [r7, #12]
 80088ca:	2202      	movs	r2, #2
 80088cc:	f362 0301 	bfi	r3, r2, #0, #2
 80088d0:	733b      	strb	r3, [r7, #12]

    /* Output data rate selection */
    reg_a.odr = LIS2MDL_ODR_100Hz;
 80088d2:	7b3b      	ldrb	r3, [r7, #12]
 80088d4:	f043 030c 	orr.w	r3, r3, #12
 80088d8:	733b      	strb	r3, [r7, #12]

    /* Write configuration to CFG_REG_C & CFG_REG_A regs */
    if (LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData(pObj, LIS2MDL_CFG_REG_C, (uint8_t *)&reg_c, 1) != LIS2MDL_OK)
 80088da:	f107 0208 	add.w	r2, r7, #8
 80088de:	2301      	movs	r3, #1
 80088e0:	2162      	movs	r1, #98	@ 0x62
 80088e2:	6878      	ldr	r0, [r7, #4]
 80088e4:	f000 fca6 	bl	8009234 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData>
 80088e8:	4603      	mov	r3, r0
 80088ea:	2b00      	cmp	r3, #0
 80088ec:	d002      	beq.n	80088f4 <LIS2MDL_Init+0x80>
    {
      return LIS2MDL_ERROR;
 80088ee:	f04f 33ff 	mov.w	r3, #4294967295
 80088f2:	e041      	b.n	8008978 <LIS2MDL_Init+0x104>
    }
    if (LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData(pObj, LIS2MDL_CFG_REG_A, (uint8_t *)&reg_a, 1) != LIS2MDL_OK)
 80088f4:	f107 020c 	add.w	r2, r7, #12
 80088f8:	2301      	movs	r3, #1
 80088fa:	2160      	movs	r1, #96	@ 0x60
 80088fc:	6878      	ldr	r0, [r7, #4]
 80088fe:	f000 fc99 	bl	8009234 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData>
 8008902:	4603      	mov	r3, r0
 8008904:	2b00      	cmp	r3, #0
 8008906:	d032      	beq.n	800896e <LIS2MDL_Init+0xfa>
    {
      return LIS2MDL_ERROR;
 8008908:	f04f 33ff 	mov.w	r3, #4294967295
 800890c:	e034      	b.n	8008978 <LIS2MDL_Init+0x104>
    }
  }
  else
  {
    /* Enable BDU */
    if (lis2mdl_block_data_update_set(&(pObj->Ctx), PROPERTY_ENABLE) != LIS2MDL_OK)
 800890e:	687b      	ldr	r3, [r7, #4]
 8008910:	3320      	adds	r3, #32
 8008912:	2101      	movs	r1, #1
 8008914:	4618      	mov	r0, r3
 8008916:	f000 fe5f 	bl	80095d8 <lis2mdl_block_data_update_set>
 800891a:	4603      	mov	r3, r0
 800891c:	2b00      	cmp	r3, #0
 800891e:	d002      	beq.n	8008926 <LIS2MDL_Init+0xb2>
    {
      return LIS2MDL_ERROR;
 8008920:	f04f 33ff 	mov.w	r3, #4294967295
 8008924:	e028      	b.n	8008978 <LIS2MDL_Init+0x104>
    }

    /* Operating mode selection - power down */
    if (lis2mdl_operating_mode_set(&(pObj->Ctx), LIS2MDL_POWER_DOWN) != LIS2MDL_OK)
 8008926:	687b      	ldr	r3, [r7, #4]
 8008928:	3320      	adds	r3, #32
 800892a:	2102      	movs	r1, #2
 800892c:	4618      	mov	r0, r3
 800892e:	f000 fdcf 	bl	80094d0 <lis2mdl_operating_mode_set>
 8008932:	4603      	mov	r3, r0
 8008934:	2b00      	cmp	r3, #0
 8008936:	d002      	beq.n	800893e <LIS2MDL_Init+0xca>
    {
      return LIS2MDL_ERROR;
 8008938:	f04f 33ff 	mov.w	r3, #4294967295
 800893c:	e01c      	b.n	8008978 <LIS2MDL_Init+0x104>
    }

    /* Output data rate selection */
    if (lis2mdl_data_rate_set(&(pObj->Ctx), LIS2MDL_ODR_100Hz) != LIS2MDL_OK)
 800893e:	687b      	ldr	r3, [r7, #4]
 8008940:	3320      	adds	r3, #32
 8008942:	2103      	movs	r1, #3
 8008944:	4618      	mov	r0, r3
 8008946:	f000 fde9 	bl	800951c <lis2mdl_data_rate_set>
 800894a:	4603      	mov	r3, r0
 800894c:	2b00      	cmp	r3, #0
 800894e:	d002      	beq.n	8008956 <LIS2MDL_Init+0xe2>
    {
      return LIS2MDL_ERROR;
 8008950:	f04f 33ff 	mov.w	r3, #4294967295
 8008954:	e010      	b.n	8008978 <LIS2MDL_Init+0x104>
    }

    /* Self Test disabled. */
    if (lis2mdl_self_test_set(&(pObj->Ctx), PROPERTY_DISABLE) != LIS2MDL_OK)
 8008956:	687b      	ldr	r3, [r7, #4]
 8008958:	3320      	adds	r3, #32
 800895a:	2100      	movs	r1, #0
 800895c:	4618      	mov	r0, r3
 800895e:	f000 feba 	bl	80096d6 <lis2mdl_self_test_set>
 8008962:	4603      	mov	r3, r0
 8008964:	2b00      	cmp	r3, #0
 8008966:	d002      	beq.n	800896e <LIS2MDL_Init+0xfa>
    {
      return LIS2MDL_ERROR;
 8008968:	f04f 33ff 	mov.w	r3, #4294967295
 800896c:	e004      	b.n	8008978 <LIS2MDL_Init+0x104>
    }
  }

  pObj->is_initialized = 1;
 800896e:	687b      	ldr	r3, [r7, #4]
 8008970:	2201      	movs	r2, #1
 8008972:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30

  return LIS2MDL_OK;
 8008976:	2300      	movs	r3, #0
}
 8008978:	4618      	mov	r0, r3
 800897a:	3710      	adds	r7, #16
 800897c:	46bd      	mov	sp, r7
 800897e:	bd80      	pop	{r7, pc}

08008980 <LIS2MDL_DeInit>:
  * @brief  Deinitialize the LIS2MDL magnetometer sensor
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2MDL_DeInit(LIS2MDL_Object_t *pObj)
{
 8008980:	b580      	push	{r7, lr}
 8008982:	b082      	sub	sp, #8
 8008984:	af00      	add	r7, sp, #0
 8008986:	6078      	str	r0, [r7, #4]
  /* Disable the component */
  if (LIS2MDL_MAG_Disable(pObj) != LIS2MDL_OK)
 8008988:	6878      	ldr	r0, [r7, #4]
 800898a:	f000 f8a5 	bl	8008ad8 <LIS2MDL_MAG_Disable>
 800898e:	4603      	mov	r3, r0
 8008990:	2b00      	cmp	r3, #0
 8008992:	d002      	beq.n	800899a <LIS2MDL_DeInit+0x1a>
  {
    return LIS2MDL_ERROR;
 8008994:	f04f 33ff 	mov.w	r3, #4294967295
 8008998:	e004      	b.n	80089a4 <LIS2MDL_DeInit+0x24>
  }

  pObj->is_initialized = 0;
 800899a:	687b      	ldr	r3, [r7, #4]
 800899c:	2200      	movs	r2, #0
 800899e:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30

  return LIS2MDL_OK;
 80089a2:	2300      	movs	r3, #0
}
 80089a4:	4618      	mov	r0, r3
 80089a6:	3708      	adds	r7, #8
 80089a8:	46bd      	mov	sp, r7
 80089aa:	bd80      	pop	{r7, pc}

080089ac <LIS2MDL_ReadID>:
  * @param  pObj the device pObj
  * @param  Id the WHO_AM_I value
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2MDL_ReadID(LIS2MDL_Object_t *pObj, uint8_t *Id)
{
 80089ac:	b580      	push	{r7, lr}
 80089ae:	b082      	sub	sp, #8
 80089b0:	af00      	add	r7, sp, #0
 80089b2:	6078      	str	r0, [r7, #4]
 80089b4:	6039      	str	r1, [r7, #0]
  if (pObj->IO.BusType == LSM6DSOX_SENSORHUB_LIS2MDL_I2C_BUS) /* LSM6DSOX SensorHub with LIS2MDL example */
 80089b6:	687b      	ldr	r3, [r7, #4]
 80089b8:	689b      	ldr	r3, [r3, #8]
 80089ba:	2b03      	cmp	r3, #3
 80089bc:	d10b      	bne.n	80089d6 <LIS2MDL_ReadID+0x2a>
  {
    if (LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData(pObj, LIS2MDL_WHO_AM_I, Id, 1) != LIS2MDL_OK)
 80089be:	2301      	movs	r3, #1
 80089c0:	683a      	ldr	r2, [r7, #0]
 80089c2:	214f      	movs	r1, #79	@ 0x4f
 80089c4:	6878      	ldr	r0, [r7, #4]
 80089c6:	f000 faf6 	bl	8008fb6 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData>
 80089ca:	4603      	mov	r3, r0
 80089cc:	2b00      	cmp	r3, #0
 80089ce:	d00e      	beq.n	80089ee <LIS2MDL_ReadID+0x42>
    {
      return LIS2MDL_ERROR;
 80089d0:	f04f 33ff 	mov.w	r3, #4294967295
 80089d4:	e00c      	b.n	80089f0 <LIS2MDL_ReadID+0x44>
    }
  }
  else
  {
    if (lis2mdl_device_id_get(&(pObj->Ctx), Id) != LIS2MDL_OK)
 80089d6:	687b      	ldr	r3, [r7, #4]
 80089d8:	3320      	adds	r3, #32
 80089da:	6839      	ldr	r1, [r7, #0]
 80089dc:	4618      	mov	r0, r3
 80089de:	f000 fe69 	bl	80096b4 <lis2mdl_device_id_get>
 80089e2:	4603      	mov	r3, r0
 80089e4:	2b00      	cmp	r3, #0
 80089e6:	d002      	beq.n	80089ee <LIS2MDL_ReadID+0x42>
    {
      return LIS2MDL_ERROR;
 80089e8:	f04f 33ff 	mov.w	r3, #4294967295
 80089ec:	e000      	b.n	80089f0 <LIS2MDL_ReadID+0x44>
    }
  }

  return LIS2MDL_OK;
 80089ee:	2300      	movs	r3, #0
}
 80089f0:	4618      	mov	r0, r3
 80089f2:	3708      	adds	r7, #8
 80089f4:	46bd      	mov	sp, r7
 80089f6:	bd80      	pop	{r7, pc}

080089f8 <LIS2MDL_GetCapabilities>:
  * @param  pObj Component object pointer
  * @param  Capabilities pointer to LIS2MDL magnetometer sensor capabilities
  * @retval Component status
  */
int32_t LIS2MDL_GetCapabilities(LIS2MDL_Object_t *pObj, LIS2MDL_Capabilities_t *Capabilities)
{
 80089f8:	b480      	push	{r7}
 80089fa:	b083      	sub	sp, #12
 80089fc:	af00      	add	r7, sp, #0
 80089fe:	6078      	str	r0, [r7, #4]
 8008a00:	6039      	str	r1, [r7, #0]
  /* Prevent unused argument(s) compilation warning */
  (void)(pObj);

  Capabilities->Acc          = 0;
 8008a02:	683b      	ldr	r3, [r7, #0]
 8008a04:	2200      	movs	r2, #0
 8008a06:	701a      	strb	r2, [r3, #0]
  Capabilities->Gyro         = 0;
 8008a08:	683b      	ldr	r3, [r7, #0]
 8008a0a:	2200      	movs	r2, #0
 8008a0c:	705a      	strb	r2, [r3, #1]
  Capabilities->Magneto      = 1;
 8008a0e:	683b      	ldr	r3, [r7, #0]
 8008a10:	2201      	movs	r2, #1
 8008a12:	709a      	strb	r2, [r3, #2]
  Capabilities->LowPower     = 0;
 8008a14:	683b      	ldr	r3, [r7, #0]
 8008a16:	2200      	movs	r2, #0
 8008a18:	70da      	strb	r2, [r3, #3]
  Capabilities->GyroMaxFS    = 0;
 8008a1a:	683b      	ldr	r3, [r7, #0]
 8008a1c:	2200      	movs	r2, #0
 8008a1e:	605a      	str	r2, [r3, #4]
  Capabilities->AccMaxFS     = 0;
 8008a20:	683b      	ldr	r3, [r7, #0]
 8008a22:	2200      	movs	r2, #0
 8008a24:	609a      	str	r2, [r3, #8]
  Capabilities->MagMaxFS     = 50;
 8008a26:	683b      	ldr	r3, [r7, #0]
 8008a28:	2232      	movs	r2, #50	@ 0x32
 8008a2a:	60da      	str	r2, [r3, #12]
  Capabilities->GyroMaxOdr   = 0.0f;
 8008a2c:	683b      	ldr	r3, [r7, #0]
 8008a2e:	f04f 0200 	mov.w	r2, #0
 8008a32:	611a      	str	r2, [r3, #16]
  Capabilities->AccMaxOdr    = 0.0f;
 8008a34:	683b      	ldr	r3, [r7, #0]
 8008a36:	f04f 0200 	mov.w	r2, #0
 8008a3a:	615a      	str	r2, [r3, #20]
  Capabilities->MagMaxOdr    = 100.0f;
 8008a3c:	683b      	ldr	r3, [r7, #0]
 8008a3e:	4a04      	ldr	r2, [pc, #16]	@ (8008a50 <LIS2MDL_GetCapabilities+0x58>)
 8008a40:	619a      	str	r2, [r3, #24]
  return LIS2MDL_OK;
 8008a42:	2300      	movs	r3, #0
}
 8008a44:	4618      	mov	r0, r3
 8008a46:	370c      	adds	r7, #12
 8008a48:	46bd      	mov	sp, r7
 8008a4a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008a4e:	4770      	bx	lr
 8008a50:	42c80000 	.word	0x42c80000

08008a54 <LIS2MDL_MAG_Enable>:
  * @brief Enable the LIS2MDL magnetometer sensor
  * @param pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2MDL_MAG_Enable(LIS2MDL_Object_t *pObj)
{
 8008a54:	b580      	push	{r7, lr}
 8008a56:	b084      	sub	sp, #16
 8008a58:	af00      	add	r7, sp, #0
 8008a5a:	6078      	str	r0, [r7, #4]
  lis2mdl_cfg_reg_a_t reg_a;

  /* Check if the component is already enabled */
  if (pObj->mag_is_enabled == 1U)
 8008a5c:	687b      	ldr	r3, [r7, #4]
 8008a5e:	f893 3031 	ldrb.w	r3, [r3, #49]	@ 0x31
 8008a62:	2b01      	cmp	r3, #1
 8008a64:	d101      	bne.n	8008a6a <LIS2MDL_MAG_Enable+0x16>
  {
    return LIS2MDL_OK;
 8008a66:	2300      	movs	r3, #0
 8008a68:	e032      	b.n	8008ad0 <LIS2MDL_MAG_Enable+0x7c>
  }

  if (pObj->IO.BusType == LSM6DSOX_SENSORHUB_LIS2MDL_I2C_BUS) /* LSM6DSOX SensorHub with LIS2MDL example */
 8008a6a:	687b      	ldr	r3, [r7, #4]
 8008a6c:	689b      	ldr	r3, [r3, #8]
 8008a6e:	2b03      	cmp	r3, #3
 8008a70:	d11d      	bne.n	8008aae <LIS2MDL_MAG_Enable+0x5a>
  {
    /* Read configuration from CFG_REG_A reg */
    if (LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData(pObj, LIS2MDL_CFG_REG_A, (uint8_t *)&reg_a, 1) != LIS2MDL_OK)
 8008a72:	f107 020c 	add.w	r2, r7, #12
 8008a76:	2301      	movs	r3, #1
 8008a78:	2160      	movs	r1, #96	@ 0x60
 8008a7a:	6878      	ldr	r0, [r7, #4]
 8008a7c:	f000 fa9b 	bl	8008fb6 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData>
 8008a80:	4603      	mov	r3, r0
 8008a82:	2b00      	cmp	r3, #0
 8008a84:	d002      	beq.n	8008a8c <LIS2MDL_MAG_Enable+0x38>
    {
      return LIS2MDL_ERROR;
 8008a86:	f04f 33ff 	mov.w	r3, #4294967295
 8008a8a:	e021      	b.n	8008ad0 <LIS2MDL_MAG_Enable+0x7c>
    }

    /* Operation mode selection. */
    reg_a.md = LIS2MDL_CONTINUOUS_MODE;
 8008a8c:	7b3b      	ldrb	r3, [r7, #12]
 8008a8e:	f023 0303 	bic.w	r3, r3, #3
 8008a92:	733b      	strb	r3, [r7, #12]

    /* Write configuration to CFG_REG_A reg */
    if (LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData(pObj, LIS2MDL_CFG_REG_A, (uint8_t *)&reg_a, 1) != LIS2MDL_OK)
 8008a94:	f107 020c 	add.w	r2, r7, #12
 8008a98:	2301      	movs	r3, #1
 8008a9a:	2160      	movs	r1, #96	@ 0x60
 8008a9c:	6878      	ldr	r0, [r7, #4]
 8008a9e:	f000 fbc9 	bl	8009234 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData>
 8008aa2:	4603      	mov	r3, r0
 8008aa4:	2b00      	cmp	r3, #0
 8008aa6:	d00e      	beq.n	8008ac6 <LIS2MDL_MAG_Enable+0x72>
    {
      return LIS2MDL_ERROR;
 8008aa8:	f04f 33ff 	mov.w	r3, #4294967295
 8008aac:	e010      	b.n	8008ad0 <LIS2MDL_MAG_Enable+0x7c>
    }
  }
  else
  {
    /* Operation mode selection. */
    if (lis2mdl_operating_mode_set(&(pObj->Ctx), LIS2MDL_CONTINUOUS_MODE) != LIS2MDL_OK)
 8008aae:	687b      	ldr	r3, [r7, #4]
 8008ab0:	3320      	adds	r3, #32
 8008ab2:	2100      	movs	r1, #0
 8008ab4:	4618      	mov	r0, r3
 8008ab6:	f000 fd0b 	bl	80094d0 <lis2mdl_operating_mode_set>
 8008aba:	4603      	mov	r3, r0
 8008abc:	2b00      	cmp	r3, #0
 8008abe:	d002      	beq.n	8008ac6 <LIS2MDL_MAG_Enable+0x72>
    {
      return LIS2MDL_ERROR;
 8008ac0:	f04f 33ff 	mov.w	r3, #4294967295
 8008ac4:	e004      	b.n	8008ad0 <LIS2MDL_MAG_Enable+0x7c>
    }
  }

  pObj->mag_is_enabled = 1;
 8008ac6:	687b      	ldr	r3, [r7, #4]
 8008ac8:	2201      	movs	r2, #1
 8008aca:	f883 2031 	strb.w	r2, [r3, #49]	@ 0x31

  return LIS2MDL_OK;
 8008ace:	2300      	movs	r3, #0
}
 8008ad0:	4618      	mov	r0, r3
 8008ad2:	3710      	adds	r7, #16
 8008ad4:	46bd      	mov	sp, r7
 8008ad6:	bd80      	pop	{r7, pc}

08008ad8 <LIS2MDL_MAG_Disable>:
  * @brief Disable the LIS2MDL magnetometer sensor
  * @param pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2MDL_MAG_Disable(LIS2MDL_Object_t *pObj)
{
 8008ad8:	b580      	push	{r7, lr}
 8008ada:	b084      	sub	sp, #16
 8008adc:	af00      	add	r7, sp, #0
 8008ade:	6078      	str	r0, [r7, #4]
  lis2mdl_cfg_reg_a_t reg_a;

  /* Check if the component is already disabled */
  if (pObj->mag_is_enabled == 0U)
 8008ae0:	687b      	ldr	r3, [r7, #4]
 8008ae2:	f893 3031 	ldrb.w	r3, [r3, #49]	@ 0x31
 8008ae6:	2b00      	cmp	r3, #0
 8008ae8:	d101      	bne.n	8008aee <LIS2MDL_MAG_Disable+0x16>
  {
    return LIS2MDL_OK;
 8008aea:	2300      	movs	r3, #0
 8008aec:	e033      	b.n	8008b56 <LIS2MDL_MAG_Disable+0x7e>
  }

  if (pObj->IO.BusType == LSM6DSOX_SENSORHUB_LIS2MDL_I2C_BUS) /* LSM6DSOX SensorHub with LIS2MDL example */
 8008aee:	687b      	ldr	r3, [r7, #4]
 8008af0:	689b      	ldr	r3, [r3, #8]
 8008af2:	2b03      	cmp	r3, #3
 8008af4:	d11e      	bne.n	8008b34 <LIS2MDL_MAG_Disable+0x5c>
  {
    /* Read configuration from CFG_REG_A reg */
    if (LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData(pObj, LIS2MDL_CFG_REG_A, (uint8_t *)&reg_a, 1) != LIS2MDL_OK)
 8008af6:	f107 020c 	add.w	r2, r7, #12
 8008afa:	2301      	movs	r3, #1
 8008afc:	2160      	movs	r1, #96	@ 0x60
 8008afe:	6878      	ldr	r0, [r7, #4]
 8008b00:	f000 fa59 	bl	8008fb6 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData>
 8008b04:	4603      	mov	r3, r0
 8008b06:	2b00      	cmp	r3, #0
 8008b08:	d002      	beq.n	8008b10 <LIS2MDL_MAG_Disable+0x38>
    {
      return LIS2MDL_ERROR;
 8008b0a:	f04f 33ff 	mov.w	r3, #4294967295
 8008b0e:	e022      	b.n	8008b56 <LIS2MDL_MAG_Disable+0x7e>
    }

    /* Operation mode selection. */
    reg_a.md = LIS2MDL_POWER_DOWN;
 8008b10:	7b3b      	ldrb	r3, [r7, #12]
 8008b12:	2202      	movs	r2, #2
 8008b14:	f362 0301 	bfi	r3, r2, #0, #2
 8008b18:	733b      	strb	r3, [r7, #12]

    /* Write configuration to CFG_REG_A reg */
    if (LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData(pObj, LIS2MDL_CFG_REG_A, (uint8_t *)&reg_a, 1) != LIS2MDL_OK)
 8008b1a:	f107 020c 	add.w	r2, r7, #12
 8008b1e:	2301      	movs	r3, #1
 8008b20:	2160      	movs	r1, #96	@ 0x60
 8008b22:	6878      	ldr	r0, [r7, #4]
 8008b24:	f000 fb86 	bl	8009234 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData>
 8008b28:	4603      	mov	r3, r0
 8008b2a:	2b00      	cmp	r3, #0
 8008b2c:	d00e      	beq.n	8008b4c <LIS2MDL_MAG_Disable+0x74>
    {
      return LIS2MDL_ERROR;
 8008b2e:	f04f 33ff 	mov.w	r3, #4294967295
 8008b32:	e010      	b.n	8008b56 <LIS2MDL_MAG_Disable+0x7e>
    }
  }
  else
  {
    /* Operation mode selection. */
    if (lis2mdl_operating_mode_set(&(pObj->Ctx), LIS2MDL_POWER_DOWN) != LIS2MDL_OK)
 8008b34:	687b      	ldr	r3, [r7, #4]
 8008b36:	3320      	adds	r3, #32
 8008b38:	2102      	movs	r1, #2
 8008b3a:	4618      	mov	r0, r3
 8008b3c:	f000 fcc8 	bl	80094d0 <lis2mdl_operating_mode_set>
 8008b40:	4603      	mov	r3, r0
 8008b42:	2b00      	cmp	r3, #0
 8008b44:	d002      	beq.n	8008b4c <LIS2MDL_MAG_Disable+0x74>
    {
      return LIS2MDL_ERROR;
 8008b46:	f04f 33ff 	mov.w	r3, #4294967295
 8008b4a:	e004      	b.n	8008b56 <LIS2MDL_MAG_Disable+0x7e>
    }
  }

  pObj->mag_is_enabled = 0;
 8008b4c:	687b      	ldr	r3, [r7, #4]
 8008b4e:	2200      	movs	r2, #0
 8008b50:	f883 2031 	strb.w	r2, [r3, #49]	@ 0x31

  return LIS2MDL_OK;
 8008b54:	2300      	movs	r3, #0
}
 8008b56:	4618      	mov	r0, r3
 8008b58:	3710      	adds	r7, #16
 8008b5a:	46bd      	mov	sp, r7
 8008b5c:	bd80      	pop	{r7, pc}

08008b5e <LIS2MDL_MAG_GetSensitivity>:
  * @param  pObj the device pObj
  * @param  Sensitivity pointer
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2MDL_MAG_GetSensitivity(LIS2MDL_Object_t *pObj, float *Sensitivity)
{
 8008b5e:	b480      	push	{r7}
 8008b60:	b083      	sub	sp, #12
 8008b62:	af00      	add	r7, sp, #0
 8008b64:	6078      	str	r0, [r7, #4]
 8008b66:	6039      	str	r1, [r7, #0]
  *Sensitivity = LIS2MDL_MAG_SENSITIVITY_FS_50GAUSS;
 8008b68:	683b      	ldr	r3, [r7, #0]
 8008b6a:	f04f 527f 	mov.w	r2, #1069547520	@ 0x3fc00000
 8008b6e:	601a      	str	r2, [r3, #0]

  return LIS2MDL_OK;
 8008b70:	2300      	movs	r3, #0
}
 8008b72:	4618      	mov	r0, r3
 8008b74:	370c      	adds	r7, #12
 8008b76:	46bd      	mov	sp, r7
 8008b78:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008b7c:	4770      	bx	lr
	...

08008b80 <LIS2MDL_MAG_GetOutputDataRate>:
  * @param  pObj the device pObj
  * @param  Odr pointer where the output data rate is written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2MDL_MAG_GetOutputDataRate(LIS2MDL_Object_t *pObj, float *Odr)
{
 8008b80:	b580      	push	{r7, lr}
 8008b82:	b084      	sub	sp, #16
 8008b84:	af00      	add	r7, sp, #0
 8008b86:	6078      	str	r0, [r7, #4]
 8008b88:	6039      	str	r1, [r7, #0]
  int32_t ret = LIS2MDL_OK;
 8008b8a:	2300      	movs	r3, #0
 8008b8c:	60fb      	str	r3, [r7, #12]
  lis2mdl_odr_t odr_low_level;

  /* Get current output data rate. */
  if (lis2mdl_data_rate_get(&(pObj->Ctx), &odr_low_level) != LIS2MDL_OK)
 8008b8e:	687b      	ldr	r3, [r7, #4]
 8008b90:	3320      	adds	r3, #32
 8008b92:	f107 020b 	add.w	r2, r7, #11
 8008b96:	4611      	mov	r1, r2
 8008b98:	4618      	mov	r0, r3
 8008b9a:	f000 fce5 	bl	8009568 <lis2mdl_data_rate_get>
 8008b9e:	4603      	mov	r3, r0
 8008ba0:	2b00      	cmp	r3, #0
 8008ba2:	d002      	beq.n	8008baa <LIS2MDL_MAG_GetOutputDataRate+0x2a>
  {
    return LIS2MDL_ERROR;
 8008ba4:	f04f 33ff 	mov.w	r3, #4294967295
 8008ba8:	e023      	b.n	8008bf2 <LIS2MDL_MAG_GetOutputDataRate+0x72>
  }

  switch (odr_low_level)
 8008baa:	7afb      	ldrb	r3, [r7, #11]
 8008bac:	2b03      	cmp	r3, #3
 8008bae:	d81b      	bhi.n	8008be8 <LIS2MDL_MAG_GetOutputDataRate+0x68>
 8008bb0:	a201      	add	r2, pc, #4	@ (adr r2, 8008bb8 <LIS2MDL_MAG_GetOutputDataRate+0x38>)
 8008bb2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8008bb6:	bf00      	nop
 8008bb8:	08008bc9 	.word	0x08008bc9
 8008bbc:	08008bd1 	.word	0x08008bd1
 8008bc0:	08008bd9 	.word	0x08008bd9
 8008bc4:	08008be1 	.word	0x08008be1
  {
    case LIS2MDL_ODR_10Hz:
      *Odr = 10.0f;
 8008bc8:	683b      	ldr	r3, [r7, #0]
 8008bca:	4a0c      	ldr	r2, [pc, #48]	@ (8008bfc <LIS2MDL_MAG_GetOutputDataRate+0x7c>)
 8008bcc:	601a      	str	r2, [r3, #0]
      break;
 8008bce:	e00f      	b.n	8008bf0 <LIS2MDL_MAG_GetOutputDataRate+0x70>

    case LIS2MDL_ODR_20Hz:
      *Odr = 20.0f;
 8008bd0:	683b      	ldr	r3, [r7, #0]
 8008bd2:	4a0b      	ldr	r2, [pc, #44]	@ (8008c00 <LIS2MDL_MAG_GetOutputDataRate+0x80>)
 8008bd4:	601a      	str	r2, [r3, #0]
      break;
 8008bd6:	e00b      	b.n	8008bf0 <LIS2MDL_MAG_GetOutputDataRate+0x70>

    case LIS2MDL_ODR_50Hz:
      *Odr = 50.0f;
 8008bd8:	683b      	ldr	r3, [r7, #0]
 8008bda:	4a0a      	ldr	r2, [pc, #40]	@ (8008c04 <LIS2MDL_MAG_GetOutputDataRate+0x84>)
 8008bdc:	601a      	str	r2, [r3, #0]
      break;
 8008bde:	e007      	b.n	8008bf0 <LIS2MDL_MAG_GetOutputDataRate+0x70>

    case LIS2MDL_ODR_100Hz:
      *Odr = 100.0f;
 8008be0:	683b      	ldr	r3, [r7, #0]
 8008be2:	4a09      	ldr	r2, [pc, #36]	@ (8008c08 <LIS2MDL_MAG_GetOutputDataRate+0x88>)
 8008be4:	601a      	str	r2, [r3, #0]
      break;
 8008be6:	e003      	b.n	8008bf0 <LIS2MDL_MAG_GetOutputDataRate+0x70>

    default:
      ret = LIS2MDL_ERROR;
 8008be8:	f04f 33ff 	mov.w	r3, #4294967295
 8008bec:	60fb      	str	r3, [r7, #12]
      break;
 8008bee:	bf00      	nop
  }

  return ret;
 8008bf0:	68fb      	ldr	r3, [r7, #12]
}
 8008bf2:	4618      	mov	r0, r3
 8008bf4:	3710      	adds	r7, #16
 8008bf6:	46bd      	mov	sp, r7
 8008bf8:	bd80      	pop	{r7, pc}
 8008bfa:	bf00      	nop
 8008bfc:	41200000 	.word	0x41200000
 8008c00:	41a00000 	.word	0x41a00000
 8008c04:	42480000 	.word	0x42480000
 8008c08:	42c80000 	.word	0x42c80000

08008c0c <LIS2MDL_MAG_SetOutputDataRate>:
  * @param  pObj the device pObj
  * @param  Odr the output data rate value to be set
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2MDL_MAG_SetOutputDataRate(LIS2MDL_Object_t *pObj, float Odr)
{
 8008c0c:	b580      	push	{r7, lr}
 8008c0e:	b084      	sub	sp, #16
 8008c10:	af00      	add	r7, sp, #0
 8008c12:	6078      	str	r0, [r7, #4]
 8008c14:	6039      	str	r1, [r7, #0]
  lis2mdl_odr_t new_odr;
  lis2mdl_cfg_reg_a_t reg_a;

  new_odr = (Odr <= 10.000f) ? LIS2MDL_ODR_10Hz
            : (Odr <= 20.000f) ? LIS2MDL_ODR_20Hz
 8008c16:	edd7 7a00 	vldr	s15, [r7]
 8008c1a:	eeb2 7a04 	vmov.f32	s14, #36	@ 0x41200000  10.0
 8008c1e:	eef4 7ac7 	vcmpe.f32	s15, s14
 8008c22:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008c26:	d801      	bhi.n	8008c2c <LIS2MDL_MAG_SetOutputDataRate+0x20>
 8008c28:	2300      	movs	r3, #0
 8008c2a:	e016      	b.n	8008c5a <LIS2MDL_MAG_SetOutputDataRate+0x4e>
 8008c2c:	edd7 7a00 	vldr	s15, [r7]
 8008c30:	eeb3 7a04 	vmov.f32	s14, #52	@ 0x41a00000  20.0
 8008c34:	eef4 7ac7 	vcmpe.f32	s15, s14
 8008c38:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008c3c:	d801      	bhi.n	8008c42 <LIS2MDL_MAG_SetOutputDataRate+0x36>
 8008c3e:	2301      	movs	r3, #1
 8008c40:	e00b      	b.n	8008c5a <LIS2MDL_MAG_SetOutputDataRate+0x4e>
 8008c42:	edd7 7a00 	vldr	s15, [r7]
 8008c46:	ed9f 7a21 	vldr	s14, [pc, #132]	@ 8008ccc <LIS2MDL_MAG_SetOutputDataRate+0xc0>
 8008c4a:	eef4 7ac7 	vcmpe.f32	s15, s14
 8008c4e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008c52:	d801      	bhi.n	8008c58 <LIS2MDL_MAG_SetOutputDataRate+0x4c>
 8008c54:	2302      	movs	r3, #2
 8008c56:	e000      	b.n	8008c5a <LIS2MDL_MAG_SetOutputDataRate+0x4e>
 8008c58:	2303      	movs	r3, #3
  new_odr = (Odr <= 10.000f) ? LIS2MDL_ODR_10Hz
 8008c5a:	73fb      	strb	r3, [r7, #15]
            : (Odr <= 50.000f) ? LIS2MDL_ODR_50Hz
            :                    LIS2MDL_ODR_100Hz;

  if (pObj->IO.BusType == LSM6DSOX_SENSORHUB_LIS2MDL_I2C_BUS) /* LSM6DSOX SensorHub with LIS2MDL example */
 8008c5c:	687b      	ldr	r3, [r7, #4]
 8008c5e:	689b      	ldr	r3, [r3, #8]
 8008c60:	2b03      	cmp	r3, #3
 8008c62:	d121      	bne.n	8008ca8 <LIS2MDL_MAG_SetOutputDataRate+0x9c>
  {
    /* Read configuration from CFG_REG_A reg */
    if (LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData(pObj, LIS2MDL_CFG_REG_A, (uint8_t *)&reg_a, 1) != LIS2MDL_OK)
 8008c64:	f107 020c 	add.w	r2, r7, #12
 8008c68:	2301      	movs	r3, #1
 8008c6a:	2160      	movs	r1, #96	@ 0x60
 8008c6c:	6878      	ldr	r0, [r7, #4]
 8008c6e:	f000 f9a2 	bl	8008fb6 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData>
 8008c72:	4603      	mov	r3, r0
 8008c74:	2b00      	cmp	r3, #0
 8008c76:	d002      	beq.n	8008c7e <LIS2MDL_MAG_SetOutputDataRate+0x72>
    {
      return LIS2MDL_ERROR;
 8008c78:	f04f 33ff 	mov.w	r3, #4294967295
 8008c7c:	e022      	b.n	8008cc4 <LIS2MDL_MAG_SetOutputDataRate+0xb8>
    }

    /* Output data rate selection */
    reg_a.odr = new_odr;
 8008c7e:	7bfb      	ldrb	r3, [r7, #15]
 8008c80:	f003 0303 	and.w	r3, r3, #3
 8008c84:	b2da      	uxtb	r2, r3
 8008c86:	7b3b      	ldrb	r3, [r7, #12]
 8008c88:	f362 0383 	bfi	r3, r2, #2, #2
 8008c8c:	733b      	strb	r3, [r7, #12]

    /* Write configuration to CFG_REG_A reg */
    if (LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData(pObj, LIS2MDL_CFG_REG_A, (uint8_t *)&reg_a, 1) != LIS2MDL_OK)
 8008c8e:	f107 020c 	add.w	r2, r7, #12
 8008c92:	2301      	movs	r3, #1
 8008c94:	2160      	movs	r1, #96	@ 0x60
 8008c96:	6878      	ldr	r0, [r7, #4]
 8008c98:	f000 facc 	bl	8009234 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData>
 8008c9c:	4603      	mov	r3, r0
 8008c9e:	2b00      	cmp	r3, #0
 8008ca0:	d00f      	beq.n	8008cc2 <LIS2MDL_MAG_SetOutputDataRate+0xb6>
    {
      return LIS2MDL_ERROR;
 8008ca2:	f04f 33ff 	mov.w	r3, #4294967295
 8008ca6:	e00d      	b.n	8008cc4 <LIS2MDL_MAG_SetOutputDataRate+0xb8>
    }
  }
  else
  {
    if (lis2mdl_data_rate_set(&(pObj->Ctx), new_odr) != LIS2MDL_OK)
 8008ca8:	687b      	ldr	r3, [r7, #4]
 8008caa:	3320      	adds	r3, #32
 8008cac:	7bfa      	ldrb	r2, [r7, #15]
 8008cae:	4611      	mov	r1, r2
 8008cb0:	4618      	mov	r0, r3
 8008cb2:	f000 fc33 	bl	800951c <lis2mdl_data_rate_set>
 8008cb6:	4603      	mov	r3, r0
 8008cb8:	2b00      	cmp	r3, #0
 8008cba:	d002      	beq.n	8008cc2 <LIS2MDL_MAG_SetOutputDataRate+0xb6>
    {
      return LIS2MDL_ERROR;
 8008cbc:	f04f 33ff 	mov.w	r3, #4294967295
 8008cc0:	e000      	b.n	8008cc4 <LIS2MDL_MAG_SetOutputDataRate+0xb8>
    }
  }

  return LIS2MDL_OK;
 8008cc2:	2300      	movs	r3, #0
}
 8008cc4:	4618      	mov	r0, r3
 8008cc6:	3710      	adds	r7, #16
 8008cc8:	46bd      	mov	sp, r7
 8008cca:	bd80      	pop	{r7, pc}
 8008ccc:	42480000 	.word	0x42480000

08008cd0 <LIS2MDL_MAG_GetFullScale>:
  * @param  pObj the device pObj
  * @param  FullScale pointer where the full scale is written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2MDL_MAG_GetFullScale(LIS2MDL_Object_t *pObj, int32_t *FullScale)
{
 8008cd0:	b480      	push	{r7}
 8008cd2:	b083      	sub	sp, #12
 8008cd4:	af00      	add	r7, sp, #0
 8008cd6:	6078      	str	r0, [r7, #4]
 8008cd8:	6039      	str	r1, [r7, #0]
  *FullScale = 50;
 8008cda:	683b      	ldr	r3, [r7, #0]
 8008cdc:	2232      	movs	r2, #50	@ 0x32
 8008cde:	601a      	str	r2, [r3, #0]

  return LIS2MDL_OK;
 8008ce0:	2300      	movs	r3, #0
}
 8008ce2:	4618      	mov	r0, r3
 8008ce4:	370c      	adds	r7, #12
 8008ce6:	46bd      	mov	sp, r7
 8008ce8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008cec:	4770      	bx	lr

08008cee <LIS2MDL_MAG_SetFullScale>:
  * @param  pObj the device pObj
  * @param  FullScale the functional full scale to be set
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2MDL_MAG_SetFullScale(LIS2MDL_Object_t *pObj, int32_t FullScale)
{
 8008cee:	b480      	push	{r7}
 8008cf0:	b083      	sub	sp, #12
 8008cf2:	af00      	add	r7, sp, #0
 8008cf4:	6078      	str	r0, [r7, #4]
 8008cf6:	6039      	str	r1, [r7, #0]
  return LIS2MDL_OK;
 8008cf8:	2300      	movs	r3, #0
}
 8008cfa:	4618      	mov	r0, r3
 8008cfc:	370c      	adds	r7, #12
 8008cfe:	46bd      	mov	sp, r7
 8008d00:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008d04:	4770      	bx	lr

08008d06 <LIS2MDL_MAG_GetAxesRaw>:
  * @param  pObj the device pObj
  * @param  Value pointer where the raw values of the axes are written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2MDL_MAG_GetAxesRaw(LIS2MDL_Object_t *pObj, LIS2MDL_AxesRaw_t *Value)
{
 8008d06:	b580      	push	{r7, lr}
 8008d08:	b084      	sub	sp, #16
 8008d0a:	af00      	add	r7, sp, #0
 8008d0c:	6078      	str	r0, [r7, #4]
 8008d0e:	6039      	str	r1, [r7, #0]
  lis2mdl_axis3bit16_t data_raw;

  /* Read raw data values. */
  if (lis2mdl_magnetic_raw_get(&(pObj->Ctx), data_raw.i16bit) != LIS2MDL_OK)
 8008d10:	687b      	ldr	r3, [r7, #4]
 8008d12:	3320      	adds	r3, #32
 8008d14:	f107 0208 	add.w	r2, r7, #8
 8008d18:	4611      	mov	r1, r2
 8008d1a:	4618      	mov	r0, r3
 8008d1c:	f000 fc82 	bl	8009624 <lis2mdl_magnetic_raw_get>
 8008d20:	4603      	mov	r3, r0
 8008d22:	2b00      	cmp	r3, #0
 8008d24:	d002      	beq.n	8008d2c <LIS2MDL_MAG_GetAxesRaw+0x26>
  {
    return LIS2MDL_ERROR;
 8008d26:	f04f 33ff 	mov.w	r3, #4294967295
 8008d2a:	e00c      	b.n	8008d46 <LIS2MDL_MAG_GetAxesRaw+0x40>
  }

  /* Format the data. */
  Value->x = data_raw.i16bit[0];
 8008d2c:	f9b7 2008 	ldrsh.w	r2, [r7, #8]
 8008d30:	683b      	ldr	r3, [r7, #0]
 8008d32:	801a      	strh	r2, [r3, #0]
  Value->y = data_raw.i16bit[1];
 8008d34:	f9b7 200a 	ldrsh.w	r2, [r7, #10]
 8008d38:	683b      	ldr	r3, [r7, #0]
 8008d3a:	805a      	strh	r2, [r3, #2]
  Value->z = data_raw.i16bit[2];
 8008d3c:	f9b7 200c 	ldrsh.w	r2, [r7, #12]
 8008d40:	683b      	ldr	r3, [r7, #0]
 8008d42:	809a      	strh	r2, [r3, #4]

  return LIS2MDL_OK;
 8008d44:	2300      	movs	r3, #0
}
 8008d46:	4618      	mov	r0, r3
 8008d48:	3710      	adds	r7, #16
 8008d4a:	46bd      	mov	sp, r7
 8008d4c:	bd80      	pop	{r7, pc}

08008d4e <LIS2MDL_MAG_GetAxes>:
  * @param  pObj the device pObj
  * @param  MagneticField pointer where the values of the axes are written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2MDL_MAG_GetAxes(LIS2MDL_Object_t *pObj, LIS2MDL_Axes_t *MagneticField)
{
 8008d4e:	b580      	push	{r7, lr}
 8008d50:	b088      	sub	sp, #32
 8008d52:	af00      	add	r7, sp, #0
 8008d54:	6078      	str	r0, [r7, #4]
 8008d56:	6039      	str	r1, [r7, #0]
  uint8_t buff[6];
  lis2mdl_axis3bit16_t data_raw;
  float sensitivity;

  if (pObj->IO.BusType == LSM6DSOX_SENSORHUB_LIS2MDL_I2C_BUS) /* LSM6DSOX SensorHub with LIS2MDL example */
 8008d58:	687b      	ldr	r3, [r7, #4]
 8008d5a:	689b      	ldr	r3, [r3, #8]
 8008d5c:	2b03      	cmp	r3, #3
 8008d5e:	d134      	bne.n	8008dca <LIS2MDL_MAG_GetAxes+0x7c>
  {
    /* Read raw data values. */
    if (LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData(pObj, LIS2MDL_OUTX_L_REG, buff, 6) != LIS2MDL_OK)
 8008d60:	f107 0218 	add.w	r2, r7, #24
 8008d64:	2306      	movs	r3, #6
 8008d66:	2168      	movs	r1, #104	@ 0x68
 8008d68:	6878      	ldr	r0, [r7, #4]
 8008d6a:	f000 f924 	bl	8008fb6 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData>
 8008d6e:	4603      	mov	r3, r0
 8008d70:	2b00      	cmp	r3, #0
 8008d72:	d002      	beq.n	8008d7a <LIS2MDL_MAG_GetAxes+0x2c>
    {
      return LIS2MDL_ERROR;
 8008d74:	f04f 33ff 	mov.w	r3, #4294967295
 8008d78:	e06c      	b.n	8008e54 <LIS2MDL_MAG_GetAxes+0x106>
    }
    data_raw.i16bit[0] = (int16_t)buff[1];
 8008d7a:	7e7b      	ldrb	r3, [r7, #25]
 8008d7c:	b21b      	sxth	r3, r3
 8008d7e:	823b      	strh	r3, [r7, #16]
    data_raw.i16bit[0] = (data_raw.i16bit[0] * 256) + (int16_t)buff[0];
 8008d80:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 8008d84:	b29b      	uxth	r3, r3
 8008d86:	021b      	lsls	r3, r3, #8
 8008d88:	b29b      	uxth	r3, r3
 8008d8a:	7e3a      	ldrb	r2, [r7, #24]
 8008d8c:	4413      	add	r3, r2
 8008d8e:	b29b      	uxth	r3, r3
 8008d90:	b21b      	sxth	r3, r3
 8008d92:	823b      	strh	r3, [r7, #16]
    data_raw.i16bit[1] = (int16_t)buff[3];
 8008d94:	7efb      	ldrb	r3, [r7, #27]
 8008d96:	b21b      	sxth	r3, r3
 8008d98:	827b      	strh	r3, [r7, #18]
    data_raw.i16bit[1] = (data_raw.i16bit[1] * 256) + (int16_t)buff[2];
 8008d9a:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8008d9e:	b29b      	uxth	r3, r3
 8008da0:	021b      	lsls	r3, r3, #8
 8008da2:	b29b      	uxth	r3, r3
 8008da4:	7eba      	ldrb	r2, [r7, #26]
 8008da6:	4413      	add	r3, r2
 8008da8:	b29b      	uxth	r3, r3
 8008daa:	b21b      	sxth	r3, r3
 8008dac:	827b      	strh	r3, [r7, #18]
    data_raw.i16bit[2] = (int16_t)buff[5];
 8008dae:	7f7b      	ldrb	r3, [r7, #29]
 8008db0:	b21b      	sxth	r3, r3
 8008db2:	82bb      	strh	r3, [r7, #20]
    data_raw.i16bit[2] = (data_raw.i16bit[2] * 256) + (int16_t)buff[4];
 8008db4:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8008db8:	b29b      	uxth	r3, r3
 8008dba:	021b      	lsls	r3, r3, #8
 8008dbc:	b29b      	uxth	r3, r3
 8008dbe:	7f3a      	ldrb	r2, [r7, #28]
 8008dc0:	4413      	add	r3, r2
 8008dc2:	b29b      	uxth	r3, r3
 8008dc4:	b21b      	sxth	r3, r3
 8008dc6:	82bb      	strh	r3, [r7, #20]
 8008dc8:	e00d      	b.n	8008de6 <LIS2MDL_MAG_GetAxes+0x98>
  }
  else
  {
    /* Read raw data values. */
    if (lis2mdl_magnetic_raw_get(&(pObj->Ctx), data_raw.i16bit) != LIS2MDL_OK)
 8008dca:	687b      	ldr	r3, [r7, #4]
 8008dcc:	3320      	adds	r3, #32
 8008dce:	f107 0210 	add.w	r2, r7, #16
 8008dd2:	4611      	mov	r1, r2
 8008dd4:	4618      	mov	r0, r3
 8008dd6:	f000 fc25 	bl	8009624 <lis2mdl_magnetic_raw_get>
 8008dda:	4603      	mov	r3, r0
 8008ddc:	2b00      	cmp	r3, #0
 8008dde:	d002      	beq.n	8008de6 <LIS2MDL_MAG_GetAxes+0x98>
    {
      return LIS2MDL_ERROR;
 8008de0:	f04f 33ff 	mov.w	r3, #4294967295
 8008de4:	e036      	b.n	8008e54 <LIS2MDL_MAG_GetAxes+0x106>
    }
  }

  /* Get LIS2MDL actual sensitivity. */
  (void)LIS2MDL_MAG_GetSensitivity(pObj, &sensitivity);
 8008de6:	f107 030c 	add.w	r3, r7, #12
 8008dea:	4619      	mov	r1, r3
 8008dec:	6878      	ldr	r0, [r7, #4]
 8008dee:	f7ff feb6 	bl	8008b5e <LIS2MDL_MAG_GetSensitivity>

  /* Calculate the data. */
  MagneticField->x = (int32_t)((float)((float)data_raw.i16bit[0] * sensitivity));
 8008df2:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 8008df6:	ee07 3a90 	vmov	s15, r3
 8008dfa:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 8008dfe:	edd7 7a03 	vldr	s15, [r7, #12]
 8008e02:	ee67 7a27 	vmul.f32	s15, s14, s15
 8008e06:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8008e0a:	ee17 2a90 	vmov	r2, s15
 8008e0e:	683b      	ldr	r3, [r7, #0]
 8008e10:	601a      	str	r2, [r3, #0]
  MagneticField->y = (int32_t)((float)((float)data_raw.i16bit[1] * sensitivity));
 8008e12:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8008e16:	ee07 3a90 	vmov	s15, r3
 8008e1a:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 8008e1e:	edd7 7a03 	vldr	s15, [r7, #12]
 8008e22:	ee67 7a27 	vmul.f32	s15, s14, s15
 8008e26:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8008e2a:	ee17 2a90 	vmov	r2, s15
 8008e2e:	683b      	ldr	r3, [r7, #0]
 8008e30:	605a      	str	r2, [r3, #4]
  MagneticField->z = (int32_t)((float)((float)data_raw.i16bit[2] * sensitivity));
 8008e32:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8008e36:	ee07 3a90 	vmov	s15, r3
 8008e3a:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 8008e3e:	edd7 7a03 	vldr	s15, [r7, #12]
 8008e42:	ee67 7a27 	vmul.f32	s15, s14, s15
 8008e46:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8008e4a:	ee17 2a90 	vmov	r2, s15
 8008e4e:	683b      	ldr	r3, [r7, #0]
 8008e50:	609a      	str	r2, [r3, #8]

  return LIS2MDL_OK;
 8008e52:	2300      	movs	r3, #0
}
 8008e54:	4618      	mov	r0, r3
 8008e56:	3720      	adds	r7, #32
 8008e58:	46bd      	mov	sp, r7
 8008e5a:	bd80      	pop	{r7, pc}

08008e5c <LIS2MDL_Write_Reg>:
  * @param  Reg address to be written
  * @param  Data value to be written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2MDL_Write_Reg(LIS2MDL_Object_t *pObj, uint8_t Reg, uint8_t Data)
{
 8008e5c:	b580      	push	{r7, lr}
 8008e5e:	b082      	sub	sp, #8
 8008e60:	af00      	add	r7, sp, #0
 8008e62:	6078      	str	r0, [r7, #4]
 8008e64:	460b      	mov	r3, r1
 8008e66:	70fb      	strb	r3, [r7, #3]
 8008e68:	4613      	mov	r3, r2
 8008e6a:	70bb      	strb	r3, [r7, #2]
  if (pObj->IO.BusType == LSM6DSOX_SENSORHUB_LIS2MDL_I2C_BUS) /* LSM6DSOX SensorHub with LIS2MDL example */
 8008e6c:	687b      	ldr	r3, [r7, #4]
 8008e6e:	689b      	ldr	r3, [r3, #8]
 8008e70:	2b03      	cmp	r3, #3
 8008e72:	d10b      	bne.n	8008e8c <LIS2MDL_Write_Reg+0x30>
  {
    if (LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData(pObj, Reg, (uint8_t *)&Data, 1) != LIS2MDL_OK)
 8008e74:	1cba      	adds	r2, r7, #2
 8008e76:	78f9      	ldrb	r1, [r7, #3]
 8008e78:	2301      	movs	r3, #1
 8008e7a:	6878      	ldr	r0, [r7, #4]
 8008e7c:	f000 f9da 	bl	8009234 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData>
 8008e80:	4603      	mov	r3, r0
 8008e82:	2b00      	cmp	r3, #0
 8008e84:	d010      	beq.n	8008ea8 <LIS2MDL_Write_Reg+0x4c>
    {
      return LIS2MDL_ERROR;
 8008e86:	f04f 33ff 	mov.w	r3, #4294967295
 8008e8a:	e00e      	b.n	8008eaa <LIS2MDL_Write_Reg+0x4e>
    }
  }
  else
  {
    if (lis2mdl_write_reg(&(pObj->Ctx), Reg, &Data, 1) != LIS2MDL_OK)
 8008e8c:	687b      	ldr	r3, [r7, #4]
 8008e8e:	f103 0020 	add.w	r0, r3, #32
 8008e92:	1cba      	adds	r2, r7, #2
 8008e94:	78f9      	ldrb	r1, [r7, #3]
 8008e96:	2301      	movs	r3, #1
 8008e98:	f000 fb02 	bl	80094a0 <lis2mdl_write_reg>
 8008e9c:	4603      	mov	r3, r0
 8008e9e:	2b00      	cmp	r3, #0
 8008ea0:	d002      	beq.n	8008ea8 <LIS2MDL_Write_Reg+0x4c>
    {
      return LIS2MDL_ERROR;
 8008ea2:	f04f 33ff 	mov.w	r3, #4294967295
 8008ea6:	e000      	b.n	8008eaa <LIS2MDL_Write_Reg+0x4e>
    }
  }

  return LIS2MDL_OK;
 8008ea8:	2300      	movs	r3, #0
}
 8008eaa:	4618      	mov	r0, r3
 8008eac:	3708      	adds	r7, #8
 8008eae:	46bd      	mov	sp, r7
 8008eb0:	bd80      	pop	{r7, pc}

08008eb2 <ReadMagRegWrap>:
  * @param  pData the stored data pointer
  * @param  Length the length
  * @retval 0 in case of success, an error code otherwise
  */
static int32_t ReadMagRegWrap(void *Handle, uint8_t Reg, uint8_t *pData, uint16_t Length)
{
 8008eb2:	b590      	push	{r4, r7, lr}
 8008eb4:	b087      	sub	sp, #28
 8008eb6:	af00      	add	r7, sp, #0
 8008eb8:	60f8      	str	r0, [r7, #12]
 8008eba:	607a      	str	r2, [r7, #4]
 8008ebc:	461a      	mov	r2, r3
 8008ebe:	460b      	mov	r3, r1
 8008ec0:	72fb      	strb	r3, [r7, #11]
 8008ec2:	4613      	mov	r3, r2
 8008ec4:	813b      	strh	r3, [r7, #8]
  LIS2MDL_Object_t *pObj = (LIS2MDL_Object_t *)Handle;
 8008ec6:	68fb      	ldr	r3, [r7, #12]
 8008ec8:	617b      	str	r3, [r7, #20]

  if (pObj->IO.BusType == LIS2MDL_I2C_BUS) /* I2C */
 8008eca:	697b      	ldr	r3, [r7, #20]
 8008ecc:	689b      	ldr	r3, [r3, #8]
 8008ece:	2b00      	cmp	r3, #0
 8008ed0:	d10e      	bne.n	8008ef0 <ReadMagRegWrap+0x3e>
  {
    /* Enable Multi-byte read */
    return pObj->IO.ReadReg(pObj->IO.Address, (Reg | 0x80U), pData, Length);
 8008ed2:	697b      	ldr	r3, [r7, #20]
 8008ed4:	695c      	ldr	r4, [r3, #20]
 8008ed6:	697b      	ldr	r3, [r7, #20]
 8008ed8:	7b1b      	ldrb	r3, [r3, #12]
 8008eda:	4618      	mov	r0, r3
 8008edc:	7afb      	ldrb	r3, [r7, #11]
 8008ede:	f063 037f 	orn	r3, r3, #127	@ 0x7f
 8008ee2:	b2db      	uxtb	r3, r3
 8008ee4:	4619      	mov	r1, r3
 8008ee6:	893b      	ldrh	r3, [r7, #8]
 8008ee8:	687a      	ldr	r2, [r7, #4]
 8008eea:	47a0      	blx	r4
 8008eec:	4603      	mov	r3, r0
 8008eee:	e01d      	b.n	8008f2c <ReadMagRegWrap+0x7a>
  }
  else if (pObj->IO.BusType == LSM6DSOX_SENSORHUB_LIS2MDL_I2C_BUS) /* LSM6DSOX SensorHub with LIS2MDL example */
 8008ef0:	697b      	ldr	r3, [r7, #20]
 8008ef2:	689b      	ldr	r3, [r3, #8]
 8008ef4:	2b03      	cmp	r3, #3
 8008ef6:	d10b      	bne.n	8008f10 <ReadMagRegWrap+0x5e>
  {
    return pObj->IO.ReadReg(pObj->IO.Address, Reg, pData, Length);
 8008ef8:	697b      	ldr	r3, [r7, #20]
 8008efa:	695c      	ldr	r4, [r3, #20]
 8008efc:	697b      	ldr	r3, [r7, #20]
 8008efe:	7b1b      	ldrb	r3, [r3, #12]
 8008f00:	4618      	mov	r0, r3
 8008f02:	7afb      	ldrb	r3, [r7, #11]
 8008f04:	b299      	uxth	r1, r3
 8008f06:	893b      	ldrh	r3, [r7, #8]
 8008f08:	687a      	ldr	r2, [r7, #4]
 8008f0a:	47a0      	blx	r4
 8008f0c:	4603      	mov	r3, r0
 8008f0e:	e00d      	b.n	8008f2c <ReadMagRegWrap+0x7a>
  }
  else   /* SPI 3-Wires or SPI 4-Wires */
  {
    /* Enable Multi-byte read */
    return pObj->IO.ReadReg(pObj->IO.Address, (Reg | 0x40U), pData, Length);
 8008f10:	697b      	ldr	r3, [r7, #20]
 8008f12:	695c      	ldr	r4, [r3, #20]
 8008f14:	697b      	ldr	r3, [r7, #20]
 8008f16:	7b1b      	ldrb	r3, [r3, #12]
 8008f18:	4618      	mov	r0, r3
 8008f1a:	7afb      	ldrb	r3, [r7, #11]
 8008f1c:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8008f20:	b2db      	uxtb	r3, r3
 8008f22:	4619      	mov	r1, r3
 8008f24:	893b      	ldrh	r3, [r7, #8]
 8008f26:	687a      	ldr	r2, [r7, #4]
 8008f28:	47a0      	blx	r4
 8008f2a:	4603      	mov	r3, r0
  }
}
 8008f2c:	4618      	mov	r0, r3
 8008f2e:	371c      	adds	r7, #28
 8008f30:	46bd      	mov	sp, r7
 8008f32:	bd90      	pop	{r4, r7, pc}

08008f34 <WriteMagRegWrap>:
  * @param  pData the stored data pointer
  * @param  Length the length
  * @retval 0 in case of success, an error code otherwise
  */
static int32_t WriteMagRegWrap(void *Handle, uint8_t Reg, uint8_t *pData, uint16_t Length)
{
 8008f34:	b590      	push	{r4, r7, lr}
 8008f36:	b087      	sub	sp, #28
 8008f38:	af00      	add	r7, sp, #0
 8008f3a:	60f8      	str	r0, [r7, #12]
 8008f3c:	607a      	str	r2, [r7, #4]
 8008f3e:	461a      	mov	r2, r3
 8008f40:	460b      	mov	r3, r1
 8008f42:	72fb      	strb	r3, [r7, #11]
 8008f44:	4613      	mov	r3, r2
 8008f46:	813b      	strh	r3, [r7, #8]
  LIS2MDL_Object_t *pObj = (LIS2MDL_Object_t *)Handle;
 8008f48:	68fb      	ldr	r3, [r7, #12]
 8008f4a:	617b      	str	r3, [r7, #20]

  if (pObj->IO.BusType == LIS2MDL_I2C_BUS) /* I2C */
 8008f4c:	697b      	ldr	r3, [r7, #20]
 8008f4e:	689b      	ldr	r3, [r3, #8]
 8008f50:	2b00      	cmp	r3, #0
 8008f52:	d10e      	bne.n	8008f72 <WriteMagRegWrap+0x3e>
  {
    /* Enable Multi-byte write */
    return pObj->IO.WriteReg(pObj->IO.Address, (Reg | 0x80U), pData, Length);
 8008f54:	697b      	ldr	r3, [r7, #20]
 8008f56:	691c      	ldr	r4, [r3, #16]
 8008f58:	697b      	ldr	r3, [r7, #20]
 8008f5a:	7b1b      	ldrb	r3, [r3, #12]
 8008f5c:	4618      	mov	r0, r3
 8008f5e:	7afb      	ldrb	r3, [r7, #11]
 8008f60:	f063 037f 	orn	r3, r3, #127	@ 0x7f
 8008f64:	b2db      	uxtb	r3, r3
 8008f66:	4619      	mov	r1, r3
 8008f68:	893b      	ldrh	r3, [r7, #8]
 8008f6a:	687a      	ldr	r2, [r7, #4]
 8008f6c:	47a0      	blx	r4
 8008f6e:	4603      	mov	r3, r0
 8008f70:	e01d      	b.n	8008fae <WriteMagRegWrap+0x7a>
  }
  else if (pObj->IO.BusType == LSM6DSOX_SENSORHUB_LIS2MDL_I2C_BUS) /* LSM6DSOX SensorHub with LIS2MDL example */
 8008f72:	697b      	ldr	r3, [r7, #20]
 8008f74:	689b      	ldr	r3, [r3, #8]
 8008f76:	2b03      	cmp	r3, #3
 8008f78:	d10b      	bne.n	8008f92 <WriteMagRegWrap+0x5e>
  {
    return pObj->IO.WriteReg(pObj->IO.Address, Reg, pData, Length);
 8008f7a:	697b      	ldr	r3, [r7, #20]
 8008f7c:	691c      	ldr	r4, [r3, #16]
 8008f7e:	697b      	ldr	r3, [r7, #20]
 8008f80:	7b1b      	ldrb	r3, [r3, #12]
 8008f82:	4618      	mov	r0, r3
 8008f84:	7afb      	ldrb	r3, [r7, #11]
 8008f86:	b299      	uxth	r1, r3
 8008f88:	893b      	ldrh	r3, [r7, #8]
 8008f8a:	687a      	ldr	r2, [r7, #4]
 8008f8c:	47a0      	blx	r4
 8008f8e:	4603      	mov	r3, r0
 8008f90:	e00d      	b.n	8008fae <WriteMagRegWrap+0x7a>
  }
  else   /* SPI 3-Wires or SPI 4-Wires */
  {
    /* Enable Multi-byte write */
    return pObj->IO.WriteReg(pObj->IO.Address, (Reg | 0x40U), pData, Length);
 8008f92:	697b      	ldr	r3, [r7, #20]
 8008f94:	691c      	ldr	r4, [r3, #16]
 8008f96:	697b      	ldr	r3, [r7, #20]
 8008f98:	7b1b      	ldrb	r3, [r3, #12]
 8008f9a:	4618      	mov	r0, r3
 8008f9c:	7afb      	ldrb	r3, [r7, #11]
 8008f9e:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8008fa2:	b2db      	uxtb	r3, r3
 8008fa4:	4619      	mov	r1, r3
 8008fa6:	893b      	ldrh	r3, [r7, #8]
 8008fa8:	687a      	ldr	r2, [r7, #4]
 8008faa:	47a0      	blx	r4
 8008fac:	4603      	mov	r3, r0
  }
}
 8008fae:	4618      	mov	r0, r3
 8008fb0:	371c      	adds	r7, #28
 8008fb2:	46bd      	mov	sp, r7
 8008fb4:	bd90      	pop	{r4, r7, pc}

08008fb6 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData>:
  * @param  Length the length
  * @retval 0 in case of success, an error code otherwise
  */
static int32_t LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData(LIS2MDL_Object_t *pObj, uint8_t Reg, uint8_t *pData,
                                                     uint16_t Length)
{
 8008fb6:	b580      	push	{r7, lr}
 8008fb8:	b08c      	sub	sp, #48	@ 0x30
 8008fba:	af00      	add	r7, sp, #0
 8008fbc:	60f8      	str	r0, [r7, #12]
 8008fbe:	607a      	str	r2, [r7, #4]
 8008fc0:	461a      	mov	r2, r3
 8008fc2:	460b      	mov	r3, r1
 8008fc4:	72fb      	strb	r3, [r7, #11]
 8008fc6:	4613      	mov	r3, r2
 8008fc8:	813b      	strh	r3, [r7, #8]
  uint8_t lsm6dsox_func_cfg_access = 0x01U;
 8008fca:	2301      	movs	r3, #1
 8008fcc:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
  uint8_t shub_reg_access_en = 0x40U;
 8008fd0:	2340      	movs	r3, #64	@ 0x40
 8008fd2:	f887 3021 	strb.w	r3, [r7, #33]	@ 0x21
  uint8_t shub_reg_access_dis = 0x00U;
 8008fd6:	2300      	movs	r3, #0
 8008fd8:	f887 3020 	strb.w	r3, [r7, #32]
  uint8_t ext_sens_addr_read = LIS2MDL_I2C_ADD | 0x01U;
 8008fdc:	233d      	movs	r3, #61	@ 0x3d
 8008fde:	77fb      	strb	r3, [r7, #31]
  uint8_t slv0_add = 0x15U;
 8008fe0:	2315      	movs	r3, #21
 8008fe2:	f887 302e 	strb.w	r3, [r7, #46]	@ 0x2e
  uint8_t slv0_subadd = 0x16U;
 8008fe6:	2316      	movs	r3, #22
 8008fe8:	f887 302d 	strb.w	r3, [r7, #45]	@ 0x2d
  uint8_t slave0_config = 0x17U;
 8008fec:	2317      	movs	r3, #23
 8008fee:	f887 302c 	strb.w	r3, [r7, #44]	@ 0x2c
  uint8_t master_config = 0x14U;
 8008ff2:	2314      	movs	r3, #20
 8008ff4:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
  uint8_t write_once_i2c_en = 0x44U;
 8008ff8:	2344      	movs	r3, #68	@ 0x44
 8008ffa:	77bb      	strb	r3, [r7, #30]
  uint8_t sensor_hub_1 = 0x02U;
 8008ffc:	2302      	movs	r3, #2
 8008ffe:	f887 302a 	strb.w	r3, [r7, #42]	@ 0x2a
  uint8_t status_master_mainpage = 0x39U;
 8009002:	2339      	movs	r3, #57	@ 0x39
 8009004:	f887 3029 	strb.w	r3, [r7, #41]	@ 0x29
  uint8_t sens_hub_endop = 0x01U;
 8009008:	2301      	movs	r3, #1
 800900a:	f887 3028 	strb.w	r3, [r7, #40]	@ 0x28
  uint8_t lsm6dsox_outx_h_a = 0x29U;
 800900e:	2329      	movs	r3, #41	@ 0x29
 8009010:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  uint8_t lsm6dsox_status_reg = 0x1EU;
 8009014:	231e      	movs	r3, #30
 8009016:	f887 3026 	strb.w	r3, [r7, #38]	@ 0x26
  uint8_t xlda = 0x01U;
 800901a:	2301      	movs	r3, #1
 800901c:	f887 3025 	strb.w	r3, [r7, #37]	@ 0x25
  uint8_t len = (uint8_t)Length;
 8009020:	893b      	ldrh	r3, [r7, #8]
 8009022:	b2db      	uxtb	r3, r3
 8009024:	777b      	strb	r3, [r7, #29]
  uint8_t lsm6dsox_ctrl1_xl = 0x10U;
 8009026:	2310      	movs	r3, #16
 8009028:	f887 3024 	strb.w	r3, [r7, #36]	@ 0x24
  uint8_t lsm6dsox_xl_prev_odr;
  uint8_t lsm6dsox_xl_odr_off = 0x00U;
 800902c:	2300      	movs	r3, #0
 800902e:	f887 3023 	strb.w	r3, [r7, #35]	@ 0x23
  uint8_t lsm6dsox_xl_odr_104hz = 0x40U;
 8009032:	2340      	movs	r3, #64	@ 0x40
 8009034:	f887 3022 	strb.w	r3, [r7, #34]	@ 0x22
  uint8_t data;
  uint8_t data_array[6];

  /* Enable access to sensor hub registers */
  if (lis2mdl_write_reg(&(pObj->Ctx), lsm6dsox_func_cfg_access, &shub_reg_access_en, 1) != LIS2MDL_OK)
 8009038:	68fb      	ldr	r3, [r7, #12]
 800903a:	f103 0020 	add.w	r0, r3, #32
 800903e:	f107 0221 	add.w	r2, r7, #33	@ 0x21
 8009042:	f897 102f 	ldrb.w	r1, [r7, #47]	@ 0x2f
 8009046:	2301      	movs	r3, #1
 8009048:	f000 fa2a 	bl	80094a0 <lis2mdl_write_reg>
 800904c:	4603      	mov	r3, r0
 800904e:	2b00      	cmp	r3, #0
 8009050:	d002      	beq.n	8009058 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0xa2>
  {
    return LIS2MDL_ERROR;
 8009052:	f04f 33ff 	mov.w	r3, #4294967295
 8009056:	e0e9      	b.n	800922c <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0x276>
  }

  /* Configure external device address, Enable read operation (rw_0 = 1) */
  if (lis2mdl_write_reg(&(pObj->Ctx), slv0_add, &ext_sens_addr_read, 1) != LIS2MDL_OK)
 8009058:	68fb      	ldr	r3, [r7, #12]
 800905a:	f103 0020 	add.w	r0, r3, #32
 800905e:	f107 021f 	add.w	r2, r7, #31
 8009062:	f897 102e 	ldrb.w	r1, [r7, #46]	@ 0x2e
 8009066:	2301      	movs	r3, #1
 8009068:	f000 fa1a 	bl	80094a0 <lis2mdl_write_reg>
 800906c:	4603      	mov	r3, r0
 800906e:	2b00      	cmp	r3, #0
 8009070:	d002      	beq.n	8009078 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0xc2>
  {
    return LIS2MDL_ERROR;
 8009072:	f04f 33ff 	mov.w	r3, #4294967295
 8009076:	e0d9      	b.n	800922c <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0x276>
  }

  /* Configure address of the LIS2MDL register to be read */
  if (lis2mdl_write_reg(&(pObj->Ctx), slv0_subadd, &Reg, 1) != LIS2MDL_OK)
 8009078:	68fb      	ldr	r3, [r7, #12]
 800907a:	f103 0020 	add.w	r0, r3, #32
 800907e:	f107 020b 	add.w	r2, r7, #11
 8009082:	f897 102d 	ldrb.w	r1, [r7, #45]	@ 0x2d
 8009086:	2301      	movs	r3, #1
 8009088:	f000 fa0a 	bl	80094a0 <lis2mdl_write_reg>
 800908c:	4603      	mov	r3, r0
 800908e:	2b00      	cmp	r3, #0
 8009090:	d002      	beq.n	8009098 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0xe2>
  {
    return LIS2MDL_ERROR;
 8009092:	f04f 33ff 	mov.w	r3, #4294967295
 8009096:	e0c9      	b.n	800922c <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0x276>
  }

  /* Read required number of bytes (up to 6), SHUB_ODR = 104 Hz */
  if (lis2mdl_write_reg(&(pObj->Ctx), slave0_config, &len, 1) != LIS2MDL_OK)
 8009098:	68fb      	ldr	r3, [r7, #12]
 800909a:	f103 0020 	add.w	r0, r3, #32
 800909e:	f107 021d 	add.w	r2, r7, #29
 80090a2:	f897 102c 	ldrb.w	r1, [r7, #44]	@ 0x2c
 80090a6:	2301      	movs	r3, #1
 80090a8:	f000 f9fa 	bl	80094a0 <lis2mdl_write_reg>
 80090ac:	4603      	mov	r3, r0
 80090ae:	2b00      	cmp	r3, #0
 80090b0:	d002      	beq.n	80090b8 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0x102>
  {
    return LIS2MDL_ERROR;
 80090b2:	f04f 33ff 	mov.w	r3, #4294967295
 80090b6:	e0b9      	b.n	800922c <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0x276>
  }

  /* WRITE_ONCE is mandatory for read, I2C master enabled using slave 0, I2C pull-ups disabled */
  if (lis2mdl_write_reg(&(pObj->Ctx), master_config, &write_once_i2c_en, 1) != LIS2MDL_OK)
 80090b8:	68fb      	ldr	r3, [r7, #12]
 80090ba:	f103 0020 	add.w	r0, r3, #32
 80090be:	f107 021e 	add.w	r2, r7, #30
 80090c2:	f897 102b 	ldrb.w	r1, [r7, #43]	@ 0x2b
 80090c6:	2301      	movs	r3, #1
 80090c8:	f000 f9ea 	bl	80094a0 <lis2mdl_write_reg>
 80090cc:	4603      	mov	r3, r0
 80090ce:	2b00      	cmp	r3, #0
 80090d0:	d002      	beq.n	80090d8 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0x122>
  {
    return LIS2MDL_ERROR;
 80090d2:	f04f 33ff 	mov.w	r3, #4294967295
 80090d6:	e0a9      	b.n	800922c <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0x276>
  }

  /* Disable access to sensor hub registers */
  if (lis2mdl_write_reg(&(pObj->Ctx), lsm6dsox_func_cfg_access, &shub_reg_access_dis, 1) != LIS2MDL_OK)
 80090d8:	68fb      	ldr	r3, [r7, #12]
 80090da:	f103 0020 	add.w	r0, r3, #32
 80090de:	f107 0220 	add.w	r2, r7, #32
 80090e2:	f897 102f 	ldrb.w	r1, [r7, #47]	@ 0x2f
 80090e6:	2301      	movs	r3, #1
 80090e8:	f000 f9da 	bl	80094a0 <lis2mdl_write_reg>
 80090ec:	4603      	mov	r3, r0
 80090ee:	2b00      	cmp	r3, #0
 80090f0:	d002      	beq.n	80090f8 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0x142>
  {
    return LIS2MDL_ERROR;
 80090f2:	f04f 33ff 	mov.w	r3, #4294967295
 80090f6:	e099      	b.n	800922c <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0x276>
  }

  /* Read LSM6DSOX ODR */
  if (lis2mdl_read_reg(&(pObj->Ctx), lsm6dsox_ctrl1_xl, &lsm6dsox_xl_prev_odr, 1) != LIS2MDL_OK)
 80090f8:	68fb      	ldr	r3, [r7, #12]
 80090fa:	f103 0020 	add.w	r0, r3, #32
 80090fe:	f107 021c 	add.w	r2, r7, #28
 8009102:	f897 1024 	ldrb.w	r1, [r7, #36]	@ 0x24
 8009106:	2301      	movs	r3, #1
 8009108:	f000 f9b2 	bl	8009470 <lis2mdl_read_reg>
 800910c:	4603      	mov	r3, r0
 800910e:	2b00      	cmp	r3, #0
 8009110:	d002      	beq.n	8009118 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0x162>
  {
    return LIS2MDL_ERROR;
 8009112:	f04f 33ff 	mov.w	r3, #4294967295
 8009116:	e089      	b.n	800922c <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0x276>
  }

  /* Set XL_ODR_104HZ if the accelerometer is disabled */
  if (lsm6dsox_xl_prev_odr == lsm6dsox_xl_odr_off)
 8009118:	7f3b      	ldrb	r3, [r7, #28]
 800911a:	f897 2023 	ldrb.w	r2, [r7, #35]	@ 0x23
 800911e:	429a      	cmp	r2, r3
 8009120:	d102      	bne.n	8009128 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0x172>
  {
    lsm6dsox_xl_prev_odr = lsm6dsox_xl_odr_104hz;
 8009122:	f897 3022 	ldrb.w	r3, [r7, #34]	@ 0x22
 8009126:	773b      	strb	r3, [r7, #28]
  }

  /* Enable accelerometer to trigger Sensor Hub operation */
  if (lis2mdl_write_reg(&(pObj->Ctx), lsm6dsox_ctrl1_xl, &lsm6dsox_xl_prev_odr, 1) != LIS2MDL_OK)
 8009128:	68fb      	ldr	r3, [r7, #12]
 800912a:	f103 0020 	add.w	r0, r3, #32
 800912e:	f107 021c 	add.w	r2, r7, #28
 8009132:	f897 1024 	ldrb.w	r1, [r7, #36]	@ 0x24
 8009136:	2301      	movs	r3, #1
 8009138:	f000 f9b2 	bl	80094a0 <lis2mdl_write_reg>
 800913c:	4603      	mov	r3, r0
 800913e:	2b00      	cmp	r3, #0
 8009140:	d002      	beq.n	8009148 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0x192>
  {
    return LIS2MDL_ERROR;
 8009142:	f04f 33ff 	mov.w	r3, #4294967295
 8009146:	e071      	b.n	800922c <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0x276>
  }

  /* Read ACC data starting from LSM6DSOX OUTX_H_A register to clear accelerometer data-ready XLDA */
  if (lis2mdl_read_reg(&(pObj->Ctx), lsm6dsox_outx_h_a, data_array, 6) != LIS2MDL_OK)
 8009148:	68fb      	ldr	r3, [r7, #12]
 800914a:	f103 0020 	add.w	r0, r3, #32
 800914e:	f107 0214 	add.w	r2, r7, #20
 8009152:	f897 1027 	ldrb.w	r1, [r7, #39]	@ 0x27
 8009156:	2306      	movs	r3, #6
 8009158:	f000 f98a 	bl	8009470 <lis2mdl_read_reg>
 800915c:	4603      	mov	r3, r0
 800915e:	2b00      	cmp	r3, #0
 8009160:	d002      	beq.n	8009168 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0x1b2>
  {
    return LIS2MDL_ERROR;
 8009162:	f04f 33ff 	mov.w	r3, #4294967295
 8009166:	e061      	b.n	800922c <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0x276>
  }

  /* Poll LSM6DSOX LSM6DSOX_STATUS_REG until XLDA = 1 (Wait for sensor hub trigger) */
  do
  {
    if (lis2mdl_read_reg(&(pObj->Ctx), lsm6dsox_status_reg, &data, 1) != LIS2MDL_OK)
 8009168:	68fb      	ldr	r3, [r7, #12]
 800916a:	f103 0020 	add.w	r0, r3, #32
 800916e:	f107 021b 	add.w	r2, r7, #27
 8009172:	f897 1026 	ldrb.w	r1, [r7, #38]	@ 0x26
 8009176:	2301      	movs	r3, #1
 8009178:	f000 f97a 	bl	8009470 <lis2mdl_read_reg>
 800917c:	4603      	mov	r3, r0
 800917e:	2b00      	cmp	r3, #0
 8009180:	d002      	beq.n	8009188 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0x1d2>
    {
      return LIS2MDL_ERROR;
 8009182:	f04f 33ff 	mov.w	r3, #4294967295
 8009186:	e051      	b.n	800922c <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0x276>
    }
  } while ((data & xlda) != xlda);
 8009188:	7efa      	ldrb	r2, [r7, #27]
 800918a:	f897 3025 	ldrb.w	r3, [r7, #37]	@ 0x25
 800918e:	4013      	ands	r3, r2
 8009190:	b2db      	uxtb	r3, r3
 8009192:	f897 2025 	ldrb.w	r2, [r7, #37]	@ 0x25
 8009196:	429a      	cmp	r2, r3
 8009198:	d1e6      	bne.n	8009168 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0x1b2>

  /* Poll LSM6DSOX SensorHub SENS_HUB_ENDOP bit in STATUS_MASTER_MAINPAGE reg until the end of SW write operations */
  do
  {
    if (lis2mdl_read_reg(&(pObj->Ctx), status_master_mainpage, &data, 1) != LIS2MDL_OK)
 800919a:	68fb      	ldr	r3, [r7, #12]
 800919c:	f103 0020 	add.w	r0, r3, #32
 80091a0:	f107 021b 	add.w	r2, r7, #27
 80091a4:	f897 1029 	ldrb.w	r1, [r7, #41]	@ 0x29
 80091a8:	2301      	movs	r3, #1
 80091aa:	f000 f961 	bl	8009470 <lis2mdl_read_reg>
 80091ae:	4603      	mov	r3, r0
 80091b0:	2b00      	cmp	r3, #0
 80091b2:	d002      	beq.n	80091ba <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0x204>
    {
      return LIS2MDL_ERROR;
 80091b4:	f04f 33ff 	mov.w	r3, #4294967295
 80091b8:	e038      	b.n	800922c <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0x276>
    }
  } while ((data & sens_hub_endop) != sens_hub_endop);
 80091ba:	7efa      	ldrb	r2, [r7, #27]
 80091bc:	f897 3028 	ldrb.w	r3, [r7, #40]	@ 0x28
 80091c0:	4013      	ands	r3, r2
 80091c2:	b2db      	uxtb	r3, r3
 80091c4:	f897 2028 	ldrb.w	r2, [r7, #40]	@ 0x28
 80091c8:	429a      	cmp	r2, r3
 80091ca:	d1e6      	bne.n	800919a <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0x1e4>

  /* Enable access to sensor hub registers */
  if (lis2mdl_write_reg(&(pObj->Ctx), lsm6dsox_func_cfg_access, &shub_reg_access_en, 1) != LIS2MDL_OK)
 80091cc:	68fb      	ldr	r3, [r7, #12]
 80091ce:	f103 0020 	add.w	r0, r3, #32
 80091d2:	f107 0221 	add.w	r2, r7, #33	@ 0x21
 80091d6:	f897 102f 	ldrb.w	r1, [r7, #47]	@ 0x2f
 80091da:	2301      	movs	r3, #1
 80091dc:	f000 f960 	bl	80094a0 <lis2mdl_write_reg>
 80091e0:	4603      	mov	r3, r0
 80091e2:	2b00      	cmp	r3, #0
 80091e4:	d002      	beq.n	80091ec <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0x236>
  {
    return LIS2MDL_ERROR;
 80091e6:	f04f 33ff 	mov.w	r3, #4294967295
 80091ea:	e01f      	b.n	800922c <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0x276>
  }

  /* Read data from LSM6DSOX SensorHub regs containing values from required LIS2MDL regs */
  if (lis2mdl_read_reg(&(pObj->Ctx), sensor_hub_1, pData, Length) != LIS2MDL_OK)
 80091ec:	68fb      	ldr	r3, [r7, #12]
 80091ee:	f103 0020 	add.w	r0, r3, #32
 80091f2:	893b      	ldrh	r3, [r7, #8]
 80091f4:	f897 102a 	ldrb.w	r1, [r7, #42]	@ 0x2a
 80091f8:	687a      	ldr	r2, [r7, #4]
 80091fa:	f000 f939 	bl	8009470 <lis2mdl_read_reg>
 80091fe:	4603      	mov	r3, r0
 8009200:	2b00      	cmp	r3, #0
 8009202:	d002      	beq.n	800920a <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0x254>
  {
    return LIS2MDL_ERROR;
 8009204:	f04f 33ff 	mov.w	r3, #4294967295
 8009208:	e010      	b.n	800922c <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0x276>
  }

  /* Disable access to sensor hub registers */
  if (lis2mdl_write_reg(&(pObj->Ctx), lsm6dsox_func_cfg_access, &shub_reg_access_dis, 1) != LIS2MDL_OK)
 800920a:	68fb      	ldr	r3, [r7, #12]
 800920c:	f103 0020 	add.w	r0, r3, #32
 8009210:	f107 0220 	add.w	r2, r7, #32
 8009214:	f897 102f 	ldrb.w	r1, [r7, #47]	@ 0x2f
 8009218:	2301      	movs	r3, #1
 800921a:	f000 f941 	bl	80094a0 <lis2mdl_write_reg>
 800921e:	4603      	mov	r3, r0
 8009220:	2b00      	cmp	r3, #0
 8009222:	d002      	beq.n	800922a <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0x274>
  {
    return LIS2MDL_ERROR;
 8009224:	f04f 33ff 	mov.w	r3, #4294967295
 8009228:	e000      	b.n	800922c <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0x276>
  }

  return LIS2MDL_OK;
 800922a:	2300      	movs	r3, #0
}
 800922c:	4618      	mov	r0, r3
 800922e:	3730      	adds	r7, #48	@ 0x30
 8009230:	46bd      	mov	sp, r7
 8009232:	bd80      	pop	{r7, pc}

08009234 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData>:
  * @param  Length the length
  * @retval 0 in case of success, an error code otherwise
  */
static int32_t LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData(LIS2MDL_Object_t *pObj, uint8_t Reg, uint8_t *pData,
                                                      uint16_t Length)
{
 8009234:	b580      	push	{r7, lr}
 8009236:	b08c      	sub	sp, #48	@ 0x30
 8009238:	af00      	add	r7, sp, #0
 800923a:	60f8      	str	r0, [r7, #12]
 800923c:	607a      	str	r2, [r7, #4]
 800923e:	461a      	mov	r2, r3
 8009240:	460b      	mov	r3, r1
 8009242:	72fb      	strb	r3, [r7, #11]
 8009244:	4613      	mov	r3, r2
 8009246:	813b      	strh	r3, [r7, #8]
  uint8_t lsm6dsox_func_cfg_access = 0x01U;
 8009248:	2301      	movs	r3, #1
 800924a:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
  uint8_t shub_reg_access_en = 0x40U;
 800924e:	2340      	movs	r3, #64	@ 0x40
 8009250:	f887 3021 	strb.w	r3, [r7, #33]	@ 0x21
  uint8_t shub_reg_access_dis = 0x00U;
 8009254:	2300      	movs	r3, #0
 8009256:	f887 3020 	strb.w	r3, [r7, #32]
  uint8_t ext_sens_addr_write = LIS2MDL_I2C_ADD & 0xFEU;
 800925a:	233c      	movs	r3, #60	@ 0x3c
 800925c:	77fb      	strb	r3, [r7, #31]
  uint8_t slv0_add = 0x15U;
 800925e:	2315      	movs	r3, #21
 8009260:	f887 302e 	strb.w	r3, [r7, #46]	@ 0x2e
  uint8_t slv0_subadd = 0x16U;
 8009264:	2316      	movs	r3, #22
 8009266:	f887 302d 	strb.w	r3, [r7, #45]	@ 0x2d
  uint8_t slave0_config = 0x17U;
 800926a:	2317      	movs	r3, #23
 800926c:	f887 302c 	strb.w	r3, [r7, #44]	@ 0x2c
  uint8_t shub_odr_104 = 0x00U;
 8009270:	2300      	movs	r3, #0
 8009272:	77bb      	strb	r3, [r7, #30]
  uint8_t master_config = 0x14U;
 8009274:	2314      	movs	r3, #20
 8009276:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
  uint8_t write_once_i2c_en = 0x44U;
 800927a:	2344      	movs	r3, #68	@ 0x44
 800927c:	777b      	strb	r3, [r7, #29]
  uint8_t status_master_mainpage = 0x39U;
 800927e:	2339      	movs	r3, #57	@ 0x39
 8009280:	f887 302a 	strb.w	r3, [r7, #42]	@ 0x2a
  uint8_t wr_once_done = 0x80U;
 8009284:	2380      	movs	r3, #128	@ 0x80
 8009286:	f887 3029 	strb.w	r3, [r7, #41]	@ 0x29
  uint8_t lsm6dsox_outx_h_a = 0x29U;
 800928a:	2329      	movs	r3, #41	@ 0x29
 800928c:	f887 3028 	strb.w	r3, [r7, #40]	@ 0x28
  uint8_t lsm6dsox_status_reg = 0x1EU;
 8009290:	231e      	movs	r3, #30
 8009292:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  uint8_t xlda = 0x01U;
 8009296:	2301      	movs	r3, #1
 8009298:	f887 3026 	strb.w	r3, [r7, #38]	@ 0x26
  uint8_t lsm6dsox_ctrl1_xl = 0x10U;
 800929c:	2310      	movs	r3, #16
 800929e:	f887 3025 	strb.w	r3, [r7, #37]	@ 0x25
  uint8_t lsm6dsox_xl_prev_odr;
  uint8_t lsm6dsox_xl_odr_off = 0x00U;
 80092a2:	2300      	movs	r3, #0
 80092a4:	f887 3024 	strb.w	r3, [r7, #36]	@ 0x24
  uint8_t lsm6dsox_xl_odr_104hz = 0x40U;
 80092a8:	2340      	movs	r3, #64	@ 0x40
 80092aa:	f887 3023 	strb.w	r3, [r7, #35]	@ 0x23
  uint8_t datawrite_slv0 = 0x0EU;
 80092ae:	230e      	movs	r3, #14
 80092b0:	f887 3022 	strb.w	r3, [r7, #34]	@ 0x22
  uint8_t data;
  uint8_t data_array[6];

  /* Enable access to sensor hub registers */
  if (lis2mdl_write_reg(&(pObj->Ctx), lsm6dsox_func_cfg_access, &shub_reg_access_en, 1) != LIS2MDL_OK)
 80092b4:	68fb      	ldr	r3, [r7, #12]
 80092b6:	f103 0020 	add.w	r0, r3, #32
 80092ba:	f107 0221 	add.w	r2, r7, #33	@ 0x21
 80092be:	f897 102f 	ldrb.w	r1, [r7, #47]	@ 0x2f
 80092c2:	2301      	movs	r3, #1
 80092c4:	f000 f8ec 	bl	80094a0 <lis2mdl_write_reg>
 80092c8:	4603      	mov	r3, r0
 80092ca:	2b00      	cmp	r3, #0
 80092cc:	d002      	beq.n	80092d4 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData+0xa0>
  {
    return LIS2MDL_ERROR;
 80092ce:	f04f 33ff 	mov.w	r3, #4294967295
 80092d2:	e0c9      	b.n	8009468 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData+0x234>
  }

  /* Configure external device address, Enable write operation (rw_0 = 0) */
  if (lis2mdl_write_reg(&(pObj->Ctx), slv0_add, &ext_sens_addr_write, 1) != LIS2MDL_OK)
 80092d4:	68fb      	ldr	r3, [r7, #12]
 80092d6:	f103 0020 	add.w	r0, r3, #32
 80092da:	f107 021f 	add.w	r2, r7, #31
 80092de:	f897 102e 	ldrb.w	r1, [r7, #46]	@ 0x2e
 80092e2:	2301      	movs	r3, #1
 80092e4:	f000 f8dc 	bl	80094a0 <lis2mdl_write_reg>
 80092e8:	4603      	mov	r3, r0
 80092ea:	2b00      	cmp	r3, #0
 80092ec:	d002      	beq.n	80092f4 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData+0xc0>
  {
    return LIS2MDL_ERROR;
 80092ee:	f04f 33ff 	mov.w	r3, #4294967295
 80092f2:	e0b9      	b.n	8009468 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData+0x234>
  }

  /* Configure address of the LIS2MDL register to be written to */
  if (lis2mdl_write_reg(&(pObj->Ctx), slv0_subadd, &Reg, 1) != LIS2MDL_OK)
 80092f4:	68fb      	ldr	r3, [r7, #12]
 80092f6:	f103 0020 	add.w	r0, r3, #32
 80092fa:	f107 020b 	add.w	r2, r7, #11
 80092fe:	f897 102d 	ldrb.w	r1, [r7, #45]	@ 0x2d
 8009302:	2301      	movs	r3, #1
 8009304:	f000 f8cc 	bl	80094a0 <lis2mdl_write_reg>
 8009308:	4603      	mov	r3, r0
 800930a:	2b00      	cmp	r3, #0
 800930c:	d002      	beq.n	8009314 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData+0xe0>
  {
    return LIS2MDL_ERROR;
 800930e:	f04f 33ff 	mov.w	r3, #4294967295
 8009312:	e0a9      	b.n	8009468 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData+0x234>
  }

  /* Set SHUB_ODR = 104 Hz */
  if (lis2mdl_write_reg(&(pObj->Ctx), slave0_config, &shub_odr_104, 1) != LIS2MDL_OK)
 8009314:	68fb      	ldr	r3, [r7, #12]
 8009316:	f103 0020 	add.w	r0, r3, #32
 800931a:	f107 021e 	add.w	r2, r7, #30
 800931e:	f897 102c 	ldrb.w	r1, [r7, #44]	@ 0x2c
 8009322:	2301      	movs	r3, #1
 8009324:	f000 f8bc 	bl	80094a0 <lis2mdl_write_reg>
 8009328:	4603      	mov	r3, r0
 800932a:	2b00      	cmp	r3, #0
 800932c:	d002      	beq.n	8009334 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData+0x100>
  {
    return LIS2MDL_ERROR;
 800932e:	f04f 33ff 	mov.w	r3, #4294967295
 8009332:	e099      	b.n	8009468 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData+0x234>
  }

  /* Store data to be written to LIS2MDL in LSM6DSOX SH reg */
  if (lis2mdl_write_reg(&(pObj->Ctx), datawrite_slv0, pData, 1) != LIS2MDL_OK)
 8009334:	68fb      	ldr	r3, [r7, #12]
 8009336:	f103 0020 	add.w	r0, r3, #32
 800933a:	f897 1022 	ldrb.w	r1, [r7, #34]	@ 0x22
 800933e:	2301      	movs	r3, #1
 8009340:	687a      	ldr	r2, [r7, #4]
 8009342:	f000 f8ad 	bl	80094a0 <lis2mdl_write_reg>
 8009346:	4603      	mov	r3, r0
 8009348:	2b00      	cmp	r3, #0
 800934a:	d002      	beq.n	8009352 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData+0x11e>
  {
    return LIS2MDL_ERROR;
 800934c:	f04f 33ff 	mov.w	r3, #4294967295
 8009350:	e08a      	b.n	8009468 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData+0x234>
  }

  /* WRITE_ONCE enabled for single write, I2C master enabled using slave 0, I2C pull-ups disabled */
  if (lis2mdl_write_reg(&(pObj->Ctx), master_config, &write_once_i2c_en, 1) != LIS2MDL_OK)
 8009352:	68fb      	ldr	r3, [r7, #12]
 8009354:	f103 0020 	add.w	r0, r3, #32
 8009358:	f107 021d 	add.w	r2, r7, #29
 800935c:	f897 102b 	ldrb.w	r1, [r7, #43]	@ 0x2b
 8009360:	2301      	movs	r3, #1
 8009362:	f000 f89d 	bl	80094a0 <lis2mdl_write_reg>
 8009366:	4603      	mov	r3, r0
 8009368:	2b00      	cmp	r3, #0
 800936a:	d002      	beq.n	8009372 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData+0x13e>
  {
    return LIS2MDL_ERROR;
 800936c:	f04f 33ff 	mov.w	r3, #4294967295
 8009370:	e07a      	b.n	8009468 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData+0x234>
  }

  /* Disable access to sensor hub registers */
  if (lis2mdl_write_reg(&(pObj->Ctx), lsm6dsox_func_cfg_access, &shub_reg_access_dis, 1) != LIS2MDL_OK)
 8009372:	68fb      	ldr	r3, [r7, #12]
 8009374:	f103 0020 	add.w	r0, r3, #32
 8009378:	f107 0220 	add.w	r2, r7, #32
 800937c:	f897 102f 	ldrb.w	r1, [r7, #47]	@ 0x2f
 8009380:	2301      	movs	r3, #1
 8009382:	f000 f88d 	bl	80094a0 <lis2mdl_write_reg>
 8009386:	4603      	mov	r3, r0
 8009388:	2b00      	cmp	r3, #0
 800938a:	d002      	beq.n	8009392 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData+0x15e>
  {
    return LIS2MDL_ERROR;
 800938c:	f04f 33ff 	mov.w	r3, #4294967295
 8009390:	e06a      	b.n	8009468 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData+0x234>
  }

  /* Read LSM6DSOX ODR */
  if (lis2mdl_read_reg(&(pObj->Ctx), lsm6dsox_ctrl1_xl, &lsm6dsox_xl_prev_odr, 1) != LIS2MDL_OK)
 8009392:	68fb      	ldr	r3, [r7, #12]
 8009394:	f103 0020 	add.w	r0, r3, #32
 8009398:	f107 021c 	add.w	r2, r7, #28
 800939c:	f897 1025 	ldrb.w	r1, [r7, #37]	@ 0x25
 80093a0:	2301      	movs	r3, #1
 80093a2:	f000 f865 	bl	8009470 <lis2mdl_read_reg>
 80093a6:	4603      	mov	r3, r0
 80093a8:	2b00      	cmp	r3, #0
 80093aa:	d002      	beq.n	80093b2 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData+0x17e>
  {
    return LIS2MDL_ERROR;
 80093ac:	f04f 33ff 	mov.w	r3, #4294967295
 80093b0:	e05a      	b.n	8009468 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData+0x234>
  }

  /* Set XL_ODR_104HZ if the accelerometer is disabled */
  if (lsm6dsox_xl_prev_odr == lsm6dsox_xl_odr_off)
 80093b2:	7f3b      	ldrb	r3, [r7, #28]
 80093b4:	f897 2024 	ldrb.w	r2, [r7, #36]	@ 0x24
 80093b8:	429a      	cmp	r2, r3
 80093ba:	d102      	bne.n	80093c2 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData+0x18e>
  {
    lsm6dsox_xl_prev_odr = lsm6dsox_xl_odr_104hz;
 80093bc:	f897 3023 	ldrb.w	r3, [r7, #35]	@ 0x23
 80093c0:	773b      	strb	r3, [r7, #28]
  }

  /* Enable accelerometer to trigger Sensor Hub operation */
  if (lis2mdl_write_reg(&(pObj->Ctx), lsm6dsox_ctrl1_xl, &lsm6dsox_xl_prev_odr, 1) != LIS2MDL_OK)
 80093c2:	68fb      	ldr	r3, [r7, #12]
 80093c4:	f103 0020 	add.w	r0, r3, #32
 80093c8:	f107 021c 	add.w	r2, r7, #28
 80093cc:	f897 1025 	ldrb.w	r1, [r7, #37]	@ 0x25
 80093d0:	2301      	movs	r3, #1
 80093d2:	f000 f865 	bl	80094a0 <lis2mdl_write_reg>
 80093d6:	4603      	mov	r3, r0
 80093d8:	2b00      	cmp	r3, #0
 80093da:	d002      	beq.n	80093e2 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData+0x1ae>
  {
    return LIS2MDL_ERROR;
 80093dc:	f04f 33ff 	mov.w	r3, #4294967295
 80093e0:	e042      	b.n	8009468 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData+0x234>
  }

  /* Read ACC data starting from LSM6DSOX OUTX_H_A register to clear accelerometer data-ready XLDA */
  if (lis2mdl_read_reg(&(pObj->Ctx), lsm6dsox_outx_h_a, data_array, 6) != LIS2MDL_OK)
 80093e2:	68fb      	ldr	r3, [r7, #12]
 80093e4:	f103 0020 	add.w	r0, r3, #32
 80093e8:	f107 0214 	add.w	r2, r7, #20
 80093ec:	f897 1028 	ldrb.w	r1, [r7, #40]	@ 0x28
 80093f0:	2306      	movs	r3, #6
 80093f2:	f000 f83d 	bl	8009470 <lis2mdl_read_reg>
 80093f6:	4603      	mov	r3, r0
 80093f8:	2b00      	cmp	r3, #0
 80093fa:	d002      	beq.n	8009402 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData+0x1ce>
  {
    return LIS2MDL_ERROR;
 80093fc:	f04f 33ff 	mov.w	r3, #4294967295
 8009400:	e032      	b.n	8009468 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData+0x234>
  }

  /* Poll LSM6DSOX LSM6DSOX_STATUS_REG until XLDA = 1 (Wait for sensor hub trigger) */
  do
  {
    if (lis2mdl_read_reg(&(pObj->Ctx), lsm6dsox_status_reg, &data, 1) != LIS2MDL_OK)
 8009402:	68fb      	ldr	r3, [r7, #12]
 8009404:	f103 0020 	add.w	r0, r3, #32
 8009408:	f107 021b 	add.w	r2, r7, #27
 800940c:	f897 1027 	ldrb.w	r1, [r7, #39]	@ 0x27
 8009410:	2301      	movs	r3, #1
 8009412:	f000 f82d 	bl	8009470 <lis2mdl_read_reg>
 8009416:	4603      	mov	r3, r0
 8009418:	2b00      	cmp	r3, #0
 800941a:	d002      	beq.n	8009422 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData+0x1ee>
    {
      return LIS2MDL_ERROR;
 800941c:	f04f 33ff 	mov.w	r3, #4294967295
 8009420:	e022      	b.n	8009468 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData+0x234>
    }
  } while ((data & xlda) != xlda);
 8009422:	7efa      	ldrb	r2, [r7, #27]
 8009424:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
 8009428:	4013      	ands	r3, r2
 800942a:	b2db      	uxtb	r3, r3
 800942c:	f897 2026 	ldrb.w	r2, [r7, #38]	@ 0x26
 8009430:	429a      	cmp	r2, r3
 8009432:	d1e6      	bne.n	8009402 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData+0x1ce>

  /* Poll LSM6DSOX SensorHub WR_ONCE_DONE bit in STATUS_MASTER_MAINPAGE reg until the end of SW write operations */
  do
  {
    if (lis2mdl_read_reg(&(pObj->Ctx), status_master_mainpage, &data, 1) != LIS2MDL_OK)
 8009434:	68fb      	ldr	r3, [r7, #12]
 8009436:	f103 0020 	add.w	r0, r3, #32
 800943a:	f107 021b 	add.w	r2, r7, #27
 800943e:	f897 102a 	ldrb.w	r1, [r7, #42]	@ 0x2a
 8009442:	2301      	movs	r3, #1
 8009444:	f000 f814 	bl	8009470 <lis2mdl_read_reg>
 8009448:	4603      	mov	r3, r0
 800944a:	2b00      	cmp	r3, #0
 800944c:	d002      	beq.n	8009454 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData+0x220>
    {
      return LIS2MDL_ERROR;
 800944e:	f04f 33ff 	mov.w	r3, #4294967295
 8009452:	e009      	b.n	8009468 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData+0x234>
    }
  } while ((data & wr_once_done) != wr_once_done);
 8009454:	7efa      	ldrb	r2, [r7, #27]
 8009456:	f897 3029 	ldrb.w	r3, [r7, #41]	@ 0x29
 800945a:	4013      	ands	r3, r2
 800945c:	b2db      	uxtb	r3, r3
 800945e:	f897 2029 	ldrb.w	r2, [r7, #41]	@ 0x29
 8009462:	429a      	cmp	r2, r3
 8009464:	d1e6      	bne.n	8009434 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData+0x200>

  return LIS2MDL_OK;
 8009466:	2300      	movs	r3, #0
}
 8009468:	4618      	mov	r0, r3
 800946a:	3730      	adds	r7, #48	@ 0x30
 800946c:	46bd      	mov	sp, r7
 800946e:	bd80      	pop	{r7, pc}

08009470 <lis2mdl_read_reg>:
  *
  */
int32_t lis2mdl_read_reg(stmdev_ctx_t *ctx, uint8_t reg,
                         uint8_t *data,
                         uint16_t len)
{
 8009470:	b590      	push	{r4, r7, lr}
 8009472:	b087      	sub	sp, #28
 8009474:	af00      	add	r7, sp, #0
 8009476:	60f8      	str	r0, [r7, #12]
 8009478:	607a      	str	r2, [r7, #4]
 800947a:	461a      	mov	r2, r3
 800947c:	460b      	mov	r3, r1
 800947e:	72fb      	strb	r3, [r7, #11]
 8009480:	4613      	mov	r3, r2
 8009482:	813b      	strh	r3, [r7, #8]
  int32_t ret;

  ret = ctx->read_reg(ctx->handle, reg, data, len);
 8009484:	68fb      	ldr	r3, [r7, #12]
 8009486:	685c      	ldr	r4, [r3, #4]
 8009488:	68fb      	ldr	r3, [r7, #12]
 800948a:	68d8      	ldr	r0, [r3, #12]
 800948c:	893b      	ldrh	r3, [r7, #8]
 800948e:	7af9      	ldrb	r1, [r7, #11]
 8009490:	687a      	ldr	r2, [r7, #4]
 8009492:	47a0      	blx	r4
 8009494:	6178      	str	r0, [r7, #20]

  return ret;
 8009496:	697b      	ldr	r3, [r7, #20]
}
 8009498:	4618      	mov	r0, r3
 800949a:	371c      	adds	r7, #28
 800949c:	46bd      	mov	sp, r7
 800949e:	bd90      	pop	{r4, r7, pc}

080094a0 <lis2mdl_write_reg>:
  *
  */
int32_t lis2mdl_write_reg(stmdev_ctx_t *ctx, uint8_t reg,
                          uint8_t *data,
                          uint16_t len)
{
 80094a0:	b590      	push	{r4, r7, lr}
 80094a2:	b087      	sub	sp, #28
 80094a4:	af00      	add	r7, sp, #0
 80094a6:	60f8      	str	r0, [r7, #12]
 80094a8:	607a      	str	r2, [r7, #4]
 80094aa:	461a      	mov	r2, r3
 80094ac:	460b      	mov	r3, r1
 80094ae:	72fb      	strb	r3, [r7, #11]
 80094b0:	4613      	mov	r3, r2
 80094b2:	813b      	strh	r3, [r7, #8]
  int32_t ret;

  ret = ctx->write_reg(ctx->handle, reg, data, len);
 80094b4:	68fb      	ldr	r3, [r7, #12]
 80094b6:	681c      	ldr	r4, [r3, #0]
 80094b8:	68fb      	ldr	r3, [r7, #12]
 80094ba:	68d8      	ldr	r0, [r3, #12]
 80094bc:	893b      	ldrh	r3, [r7, #8]
 80094be:	7af9      	ldrb	r1, [r7, #11]
 80094c0:	687a      	ldr	r2, [r7, #4]
 80094c2:	47a0      	blx	r4
 80094c4:	6178      	str	r0, [r7, #20]

  return ret;
 80094c6:	697b      	ldr	r3, [r7, #20]
}
 80094c8:	4618      	mov	r0, r3
 80094ca:	371c      	adds	r7, #28
 80094cc:	46bd      	mov	sp, r7
 80094ce:	bd90      	pop	{r4, r7, pc}

080094d0 <lis2mdl_operating_mode_set>:
  * @retval        interface status.(MANDATORY: return 0 -> no Error)
  *
  */
int32_t lis2mdl_operating_mode_set(stmdev_ctx_t *ctx,
                                   lis2mdl_md_t val)
{
 80094d0:	b580      	push	{r7, lr}
 80094d2:	b084      	sub	sp, #16
 80094d4:	af00      	add	r7, sp, #0
 80094d6:	6078      	str	r0, [r7, #4]
 80094d8:	460b      	mov	r3, r1
 80094da:	70fb      	strb	r3, [r7, #3]
  lis2mdl_cfg_reg_a_t reg;
  int32_t ret;

  ret = lis2mdl_read_reg(ctx, LIS2MDL_CFG_REG_A, (uint8_t *)&reg, 1);
 80094dc:	f107 0208 	add.w	r2, r7, #8
 80094e0:	2301      	movs	r3, #1
 80094e2:	2160      	movs	r1, #96	@ 0x60
 80094e4:	6878      	ldr	r0, [r7, #4]
 80094e6:	f7ff ffc3 	bl	8009470 <lis2mdl_read_reg>
 80094ea:	60f8      	str	r0, [r7, #12]

  if (ret == 0)
 80094ec:	68fb      	ldr	r3, [r7, #12]
 80094ee:	2b00      	cmp	r3, #0
 80094f0:	d10f      	bne.n	8009512 <lis2mdl_operating_mode_set+0x42>
  {
    reg.md = (uint8_t)val;
 80094f2:	78fb      	ldrb	r3, [r7, #3]
 80094f4:	f003 0303 	and.w	r3, r3, #3
 80094f8:	b2da      	uxtb	r2, r3
 80094fa:	7a3b      	ldrb	r3, [r7, #8]
 80094fc:	f362 0301 	bfi	r3, r2, #0, #2
 8009500:	723b      	strb	r3, [r7, #8]
    ret = lis2mdl_write_reg(ctx, LIS2MDL_CFG_REG_A, (uint8_t *)&reg, 1);
 8009502:	f107 0208 	add.w	r2, r7, #8
 8009506:	2301      	movs	r3, #1
 8009508:	2160      	movs	r1, #96	@ 0x60
 800950a:	6878      	ldr	r0, [r7, #4]
 800950c:	f7ff ffc8 	bl	80094a0 <lis2mdl_write_reg>
 8009510:	60f8      	str	r0, [r7, #12]
  }

  return ret;
 8009512:	68fb      	ldr	r3, [r7, #12]
}
 8009514:	4618      	mov	r0, r3
 8009516:	3710      	adds	r7, #16
 8009518:	46bd      	mov	sp, r7
 800951a:	bd80      	pop	{r7, pc}

0800951c <lis2mdl_data_rate_set>:
  * @param  val   change the values of odr in reg CFG_REG_A
  * @retval       interface status.(MANDATORY: return 0 -> no Error)
  *
  */
int32_t lis2mdl_data_rate_set(stmdev_ctx_t *ctx, lis2mdl_odr_t val)
{
 800951c:	b580      	push	{r7, lr}
 800951e:	b084      	sub	sp, #16
 8009520:	af00      	add	r7, sp, #0
 8009522:	6078      	str	r0, [r7, #4]
 8009524:	460b      	mov	r3, r1
 8009526:	70fb      	strb	r3, [r7, #3]
  lis2mdl_cfg_reg_a_t reg;
  int32_t ret;

  ret = lis2mdl_read_reg(ctx, LIS2MDL_CFG_REG_A, (uint8_t *)&reg, 1);
 8009528:	f107 0208 	add.w	r2, r7, #8
 800952c:	2301      	movs	r3, #1
 800952e:	2160      	movs	r1, #96	@ 0x60
 8009530:	6878      	ldr	r0, [r7, #4]
 8009532:	f7ff ff9d 	bl	8009470 <lis2mdl_read_reg>
 8009536:	60f8      	str	r0, [r7, #12]

  if (ret == 0)
 8009538:	68fb      	ldr	r3, [r7, #12]
 800953a:	2b00      	cmp	r3, #0
 800953c:	d10f      	bne.n	800955e <lis2mdl_data_rate_set+0x42>
  {
    reg.odr = (uint8_t)val;
 800953e:	78fb      	ldrb	r3, [r7, #3]
 8009540:	f003 0303 	and.w	r3, r3, #3
 8009544:	b2da      	uxtb	r2, r3
 8009546:	7a3b      	ldrb	r3, [r7, #8]
 8009548:	f362 0383 	bfi	r3, r2, #2, #2
 800954c:	723b      	strb	r3, [r7, #8]
    ret = lis2mdl_write_reg(ctx, LIS2MDL_CFG_REG_A, (uint8_t *)&reg, 1);
 800954e:	f107 0208 	add.w	r2, r7, #8
 8009552:	2301      	movs	r3, #1
 8009554:	2160      	movs	r1, #96	@ 0x60
 8009556:	6878      	ldr	r0, [r7, #4]
 8009558:	f7ff ffa2 	bl	80094a0 <lis2mdl_write_reg>
 800955c:	60f8      	str	r0, [r7, #12]
  }

  return ret;
 800955e:	68fb      	ldr	r3, [r7, #12]
}
 8009560:	4618      	mov	r0, r3
 8009562:	3710      	adds	r7, #16
 8009564:	46bd      	mov	sp, r7
 8009566:	bd80      	pop	{r7, pc}

08009568 <lis2mdl_data_rate_get>:
  * @param  val   Get the values of odr in reg CFG_REG_A.(ptr)
  * @retval       interface status.(MANDATORY: return 0 -> no Error)
  *
  */
int32_t lis2mdl_data_rate_get(stmdev_ctx_t *ctx, lis2mdl_odr_t *val)
{
 8009568:	b580      	push	{r7, lr}
 800956a:	b084      	sub	sp, #16
 800956c:	af00      	add	r7, sp, #0
 800956e:	6078      	str	r0, [r7, #4]
 8009570:	6039      	str	r1, [r7, #0]
  lis2mdl_cfg_reg_a_t reg;
  int32_t ret;

  ret = lis2mdl_read_reg(ctx, LIS2MDL_CFG_REG_A, (uint8_t *)&reg, 1);
 8009572:	f107 0208 	add.w	r2, r7, #8
 8009576:	2301      	movs	r3, #1
 8009578:	2160      	movs	r1, #96	@ 0x60
 800957a:	6878      	ldr	r0, [r7, #4]
 800957c:	f7ff ff78 	bl	8009470 <lis2mdl_read_reg>
 8009580:	60f8      	str	r0, [r7, #12]

  switch (reg.odr)
 8009582:	7a3b      	ldrb	r3, [r7, #8]
 8009584:	f3c3 0381 	ubfx	r3, r3, #2, #2
 8009588:	b2db      	uxtb	r3, r3
 800958a:	2b03      	cmp	r3, #3
 800958c:	d81a      	bhi.n	80095c4 <lis2mdl_data_rate_get+0x5c>
 800958e:	a201      	add	r2, pc, #4	@ (adr r2, 8009594 <lis2mdl_data_rate_get+0x2c>)
 8009590:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8009594:	080095a5 	.word	0x080095a5
 8009598:	080095ad 	.word	0x080095ad
 800959c:	080095b5 	.word	0x080095b5
 80095a0:	080095bd 	.word	0x080095bd
  {
    case LIS2MDL_ODR_10Hz:
      *val = LIS2MDL_ODR_10Hz;
 80095a4:	683b      	ldr	r3, [r7, #0]
 80095a6:	2200      	movs	r2, #0
 80095a8:	701a      	strb	r2, [r3, #0]
      break;
 80095aa:	e00f      	b.n	80095cc <lis2mdl_data_rate_get+0x64>

    case LIS2MDL_ODR_20Hz:
      *val = LIS2MDL_ODR_20Hz;
 80095ac:	683b      	ldr	r3, [r7, #0]
 80095ae:	2201      	movs	r2, #1
 80095b0:	701a      	strb	r2, [r3, #0]
      break;
 80095b2:	e00b      	b.n	80095cc <lis2mdl_data_rate_get+0x64>

    case LIS2MDL_ODR_50Hz:
      *val = LIS2MDL_ODR_50Hz;
 80095b4:	683b      	ldr	r3, [r7, #0]
 80095b6:	2202      	movs	r2, #2
 80095b8:	701a      	strb	r2, [r3, #0]
      break;
 80095ba:	e007      	b.n	80095cc <lis2mdl_data_rate_get+0x64>

    case LIS2MDL_ODR_100Hz:
      *val = LIS2MDL_ODR_100Hz;
 80095bc:	683b      	ldr	r3, [r7, #0]
 80095be:	2203      	movs	r2, #3
 80095c0:	701a      	strb	r2, [r3, #0]
      break;
 80095c2:	e003      	b.n	80095cc <lis2mdl_data_rate_get+0x64>

    default:
      *val = LIS2MDL_ODR_10Hz;
 80095c4:	683b      	ldr	r3, [r7, #0]
 80095c6:	2200      	movs	r2, #0
 80095c8:	701a      	strb	r2, [r3, #0]
      break;
 80095ca:	bf00      	nop
  }

  return ret;
 80095cc:	68fb      	ldr	r3, [r7, #12]
}
 80095ce:	4618      	mov	r0, r3
 80095d0:	3710      	adds	r7, #16
 80095d2:	46bd      	mov	sp, r7
 80095d4:	bd80      	pop	{r7, pc}
 80095d6:	bf00      	nop

080095d8 <lis2mdl_block_data_update_set>:
  * @param  val   change the values of bdu in reg CFG_REG_C
  * @retval       interface status.(MANDATORY: return 0 -> no Error)
  *
  */
int32_t lis2mdl_block_data_update_set(stmdev_ctx_t *ctx, uint8_t val)
{
 80095d8:	b580      	push	{r7, lr}
 80095da:	b084      	sub	sp, #16
 80095dc:	af00      	add	r7, sp, #0
 80095de:	6078      	str	r0, [r7, #4]
 80095e0:	460b      	mov	r3, r1
 80095e2:	70fb      	strb	r3, [r7, #3]
  lis2mdl_cfg_reg_c_t reg;
  int32_t ret;

  ret = lis2mdl_read_reg(ctx, LIS2MDL_CFG_REG_C, (uint8_t *)&reg, 1);
 80095e4:	f107 0208 	add.w	r2, r7, #8
 80095e8:	2301      	movs	r3, #1
 80095ea:	2162      	movs	r1, #98	@ 0x62
 80095ec:	6878      	ldr	r0, [r7, #4]
 80095ee:	f7ff ff3f 	bl	8009470 <lis2mdl_read_reg>
 80095f2:	60f8      	str	r0, [r7, #12]

  if (ret == 0)
 80095f4:	68fb      	ldr	r3, [r7, #12]
 80095f6:	2b00      	cmp	r3, #0
 80095f8:	d10f      	bne.n	800961a <lis2mdl_block_data_update_set+0x42>
  {
    reg.bdu = val;
 80095fa:	78fb      	ldrb	r3, [r7, #3]
 80095fc:	f003 0301 	and.w	r3, r3, #1
 8009600:	b2da      	uxtb	r2, r3
 8009602:	7a3b      	ldrb	r3, [r7, #8]
 8009604:	f362 1304 	bfi	r3, r2, #4, #1
 8009608:	723b      	strb	r3, [r7, #8]
    ret = lis2mdl_write_reg(ctx, LIS2MDL_CFG_REG_C, (uint8_t *)&reg, 1);
 800960a:	f107 0208 	add.w	r2, r7, #8
 800960e:	2301      	movs	r3, #1
 8009610:	2162      	movs	r1, #98	@ 0x62
 8009612:	6878      	ldr	r0, [r7, #4]
 8009614:	f7ff ff44 	bl	80094a0 <lis2mdl_write_reg>
 8009618:	60f8      	str	r0, [r7, #12]
  }

  return ret;
 800961a:	68fb      	ldr	r3, [r7, #12]
}
 800961c:	4618      	mov	r0, r3
 800961e:	3710      	adds	r7, #16
 8009620:	46bd      	mov	sp, r7
 8009622:	bd80      	pop	{r7, pc}

08009624 <lis2mdl_magnetic_raw_get>:
  * @param  buff  that stores data read
  * @retval       interface status.(MANDATORY: return 0 -> no Error)
  *
  */
int32_t lis2mdl_magnetic_raw_get(stmdev_ctx_t *ctx, int16_t *val)
{
 8009624:	b580      	push	{r7, lr}
 8009626:	b086      	sub	sp, #24
 8009628:	af00      	add	r7, sp, #0
 800962a:	6078      	str	r0, [r7, #4]
 800962c:	6039      	str	r1, [r7, #0]
  uint8_t buff[6];
  int32_t ret;

  ret = lis2mdl_read_reg(ctx, LIS2MDL_OUTX_L_REG, buff, 6);
 800962e:	f107 020c 	add.w	r2, r7, #12
 8009632:	2306      	movs	r3, #6
 8009634:	2168      	movs	r1, #104	@ 0x68
 8009636:	6878      	ldr	r0, [r7, #4]
 8009638:	f7ff ff1a 	bl	8009470 <lis2mdl_read_reg>
 800963c:	6178      	str	r0, [r7, #20]
  val[0] = (int16_t)buff[1];
 800963e:	7b7b      	ldrb	r3, [r7, #13]
 8009640:	b21a      	sxth	r2, r3
 8009642:	683b      	ldr	r3, [r7, #0]
 8009644:	801a      	strh	r2, [r3, #0]
  val[0] = (val[0] * 256) + (int16_t)buff[0];
 8009646:	683b      	ldr	r3, [r7, #0]
 8009648:	f9b3 3000 	ldrsh.w	r3, [r3]
 800964c:	b29b      	uxth	r3, r3
 800964e:	021b      	lsls	r3, r3, #8
 8009650:	b29b      	uxth	r3, r3
 8009652:	7b3a      	ldrb	r2, [r7, #12]
 8009654:	4413      	add	r3, r2
 8009656:	b29b      	uxth	r3, r3
 8009658:	b21a      	sxth	r2, r3
 800965a:	683b      	ldr	r3, [r7, #0]
 800965c:	801a      	strh	r2, [r3, #0]
  val[1] = (int16_t)buff[3];
 800965e:	7bfa      	ldrb	r2, [r7, #15]
 8009660:	683b      	ldr	r3, [r7, #0]
 8009662:	3302      	adds	r3, #2
 8009664:	b212      	sxth	r2, r2
 8009666:	801a      	strh	r2, [r3, #0]
  val[1] = (val[1] * 256) + (int16_t)buff[2];
 8009668:	683b      	ldr	r3, [r7, #0]
 800966a:	3302      	adds	r3, #2
 800966c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8009670:	b29b      	uxth	r3, r3
 8009672:	021b      	lsls	r3, r3, #8
 8009674:	b29b      	uxth	r3, r3
 8009676:	7bba      	ldrb	r2, [r7, #14]
 8009678:	4413      	add	r3, r2
 800967a:	b29a      	uxth	r2, r3
 800967c:	683b      	ldr	r3, [r7, #0]
 800967e:	3302      	adds	r3, #2
 8009680:	b212      	sxth	r2, r2
 8009682:	801a      	strh	r2, [r3, #0]
  val[2] = (int16_t)buff[5];
 8009684:	7c7a      	ldrb	r2, [r7, #17]
 8009686:	683b      	ldr	r3, [r7, #0]
 8009688:	3304      	adds	r3, #4
 800968a:	b212      	sxth	r2, r2
 800968c:	801a      	strh	r2, [r3, #0]
  val[2] = (val[2] * 256) + (int16_t)buff[4];
 800968e:	683b      	ldr	r3, [r7, #0]
 8009690:	3304      	adds	r3, #4
 8009692:	f9b3 3000 	ldrsh.w	r3, [r3]
 8009696:	b29b      	uxth	r3, r3
 8009698:	021b      	lsls	r3, r3, #8
 800969a:	b29b      	uxth	r3, r3
 800969c:	7c3a      	ldrb	r2, [r7, #16]
 800969e:	4413      	add	r3, r2
 80096a0:	b29a      	uxth	r2, r3
 80096a2:	683b      	ldr	r3, [r7, #0]
 80096a4:	3304      	adds	r3, #4
 80096a6:	b212      	sxth	r2, r2
 80096a8:	801a      	strh	r2, [r3, #0]

  return ret;
 80096aa:	697b      	ldr	r3, [r7, #20]
}
 80096ac:	4618      	mov	r0, r3
 80096ae:	3718      	adds	r7, #24
 80096b0:	46bd      	mov	sp, r7
 80096b2:	bd80      	pop	{r7, pc}

080096b4 <lis2mdl_device_id_get>:
  * @param  buff  that stores data read
  * @retval       interface status.(MANDATORY: return 0 -> no Error)
  *
  */
int32_t lis2mdl_device_id_get(stmdev_ctx_t *ctx, uint8_t *buff)
{
 80096b4:	b580      	push	{r7, lr}
 80096b6:	b084      	sub	sp, #16
 80096b8:	af00      	add	r7, sp, #0
 80096ba:	6078      	str	r0, [r7, #4]
 80096bc:	6039      	str	r1, [r7, #0]
  int32_t ret;

  ret = lis2mdl_read_reg(ctx, LIS2MDL_WHO_AM_I, buff, 1);
 80096be:	2301      	movs	r3, #1
 80096c0:	683a      	ldr	r2, [r7, #0]
 80096c2:	214f      	movs	r1, #79	@ 0x4f
 80096c4:	6878      	ldr	r0, [r7, #4]
 80096c6:	f7ff fed3 	bl	8009470 <lis2mdl_read_reg>
 80096ca:	60f8      	str	r0, [r7, #12]

  return ret;
 80096cc:	68fb      	ldr	r3, [r7, #12]
}
 80096ce:	4618      	mov	r0, r3
 80096d0:	3710      	adds	r7, #16
 80096d2:	46bd      	mov	sp, r7
 80096d4:	bd80      	pop	{r7, pc}

080096d6 <lis2mdl_self_test_set>:
  * @param  val   change the values of self_test in reg CFG_REG_C
  * @retval       interface status.(MANDATORY: return 0 -> no Error)
  *
  */
int32_t lis2mdl_self_test_set(stmdev_ctx_t *ctx, uint8_t val)
{
 80096d6:	b580      	push	{r7, lr}
 80096d8:	b084      	sub	sp, #16
 80096da:	af00      	add	r7, sp, #0
 80096dc:	6078      	str	r0, [r7, #4]
 80096de:	460b      	mov	r3, r1
 80096e0:	70fb      	strb	r3, [r7, #3]
  lis2mdl_cfg_reg_c_t reg;
  int32_t ret;

  ret = lis2mdl_read_reg(ctx, LIS2MDL_CFG_REG_C, (uint8_t *)&reg, 1);
 80096e2:	f107 0208 	add.w	r2, r7, #8
 80096e6:	2301      	movs	r3, #1
 80096e8:	2162      	movs	r1, #98	@ 0x62
 80096ea:	6878      	ldr	r0, [r7, #4]
 80096ec:	f7ff fec0 	bl	8009470 <lis2mdl_read_reg>
 80096f0:	60f8      	str	r0, [r7, #12]

  if (ret == 0)
 80096f2:	68fb      	ldr	r3, [r7, #12]
 80096f4:	2b00      	cmp	r3, #0
 80096f6:	d10f      	bne.n	8009718 <lis2mdl_self_test_set+0x42>
  {
    reg.self_test = val;
 80096f8:	78fb      	ldrb	r3, [r7, #3]
 80096fa:	f003 0301 	and.w	r3, r3, #1
 80096fe:	b2da      	uxtb	r2, r3
 8009700:	7a3b      	ldrb	r3, [r7, #8]
 8009702:	f362 0341 	bfi	r3, r2, #1, #1
 8009706:	723b      	strb	r3, [r7, #8]
    ret = lis2mdl_write_reg(ctx, LIS2MDL_CFG_REG_C, (uint8_t *)&reg, 1);
 8009708:	f107 0208 	add.w	r2, r7, #8
 800970c:	2301      	movs	r3, #1
 800970e:	2162      	movs	r1, #98	@ 0x62
 8009710:	6878      	ldr	r0, [r7, #4]
 8009712:	f7ff fec5 	bl	80094a0 <lis2mdl_write_reg>
 8009716:	60f8      	str	r0, [r7, #12]
  }

  return ret;
 8009718:	68fb      	ldr	r3, [r7, #12]
}
 800971a:	4618      	mov	r0, r3
 800971c:	3710      	adds	r7, #16
 800971e:	46bd      	mov	sp, r7
 8009720:	bd80      	pop	{r7, pc}

08009722 <lis2mdl_i2c_interface_set>:
  * @retval       interface status.(MANDATORY: return 0 -> no Error)
  *
  */
int32_t lis2mdl_i2c_interface_set(stmdev_ctx_t *ctx,
                                  lis2mdl_i2c_dis_t val)
{
 8009722:	b580      	push	{r7, lr}
 8009724:	b084      	sub	sp, #16
 8009726:	af00      	add	r7, sp, #0
 8009728:	6078      	str	r0, [r7, #4]
 800972a:	460b      	mov	r3, r1
 800972c:	70fb      	strb	r3, [r7, #3]
  lis2mdl_cfg_reg_c_t reg;
  int32_t ret;

  ret = lis2mdl_read_reg(ctx, LIS2MDL_CFG_REG_C, (uint8_t *)&reg, 1);
 800972e:	f107 0208 	add.w	r2, r7, #8
 8009732:	2301      	movs	r3, #1
 8009734:	2162      	movs	r1, #98	@ 0x62
 8009736:	6878      	ldr	r0, [r7, #4]
 8009738:	f7ff fe9a 	bl	8009470 <lis2mdl_read_reg>
 800973c:	60f8      	str	r0, [r7, #12]

  if (ret == 0)
 800973e:	68fb      	ldr	r3, [r7, #12]
 8009740:	2b00      	cmp	r3, #0
 8009742:	d10f      	bne.n	8009764 <lis2mdl_i2c_interface_set+0x42>
  {
    reg.i2c_dis = (uint8_t)val;
 8009744:	78fb      	ldrb	r3, [r7, #3]
 8009746:	f003 0301 	and.w	r3, r3, #1
 800974a:	b2da      	uxtb	r2, r3
 800974c:	7a3b      	ldrb	r3, [r7, #8]
 800974e:	f362 1345 	bfi	r3, r2, #5, #1
 8009752:	723b      	strb	r3, [r7, #8]
    ret = lis2mdl_write_reg(ctx, LIS2MDL_CFG_REG_C, (uint8_t *)&reg, 1);
 8009754:	f107 0208 	add.w	r2, r7, #8
 8009758:	2301      	movs	r3, #1
 800975a:	2162      	movs	r1, #98	@ 0x62
 800975c:	6878      	ldr	r0, [r7, #4]
 800975e:	f7ff fe9f 	bl	80094a0 <lis2mdl_write_reg>
 8009762:	60f8      	str	r0, [r7, #12]
  }

  return ret;
 8009764:	68fb      	ldr	r3, [r7, #12]
}
 8009766:	4618      	mov	r0, r3
 8009768:	3710      	adds	r7, #16
 800976a:	46bd      	mov	sp, r7
 800976c:	bd80      	pop	{r7, pc}
	...

08009770 <LPS22DF_RegisterBusIO>:
  * @brief  Register Component Bus IO operations
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LPS22DF_RegisterBusIO(LPS22DF_Object_t *pObj, LPS22DF_IO_t *pIO)
{
 8009770:	b580      	push	{r7, lr}
 8009772:	b084      	sub	sp, #16
 8009774:	af00      	add	r7, sp, #0
 8009776:	6078      	str	r0, [r7, #4]
 8009778:	6039      	str	r1, [r7, #0]
  int32_t ret = LPS22DF_OK;
 800977a:	2300      	movs	r3, #0
 800977c:	60fb      	str	r3, [r7, #12]

  if (pObj == NULL)
 800977e:	687b      	ldr	r3, [r7, #4]
 8009780:	2b00      	cmp	r3, #0
 8009782:	d103      	bne.n	800978c <LPS22DF_RegisterBusIO+0x1c>
  {
    ret = LPS22DF_ERROR;
 8009784:	f04f 33ff 	mov.w	r3, #4294967295
 8009788:	60fb      	str	r3, [r7, #12]
 800978a:	e051      	b.n	8009830 <LPS22DF_RegisterBusIO+0xc0>
  }
  else
  {
    pObj->IO.Init      = pIO->Init;
 800978c:	683b      	ldr	r3, [r7, #0]
 800978e:	681a      	ldr	r2, [r3, #0]
 8009790:	687b      	ldr	r3, [r7, #4]
 8009792:	601a      	str	r2, [r3, #0]
    pObj->IO.DeInit    = pIO->DeInit;
 8009794:	683b      	ldr	r3, [r7, #0]
 8009796:	685a      	ldr	r2, [r3, #4]
 8009798:	687b      	ldr	r3, [r7, #4]
 800979a:	605a      	str	r2, [r3, #4]
    pObj->IO.BusType   = pIO->BusType;
 800979c:	683b      	ldr	r3, [r7, #0]
 800979e:	689a      	ldr	r2, [r3, #8]
 80097a0:	687b      	ldr	r3, [r7, #4]
 80097a2:	609a      	str	r2, [r3, #8]
    pObj->IO.Address   = pIO->Address;
 80097a4:	683b      	ldr	r3, [r7, #0]
 80097a6:	7b1a      	ldrb	r2, [r3, #12]
 80097a8:	687b      	ldr	r3, [r7, #4]
 80097aa:	731a      	strb	r2, [r3, #12]
    pObj->IO.WriteReg  = pIO->WriteReg;
 80097ac:	683b      	ldr	r3, [r7, #0]
 80097ae:	691a      	ldr	r2, [r3, #16]
 80097b0:	687b      	ldr	r3, [r7, #4]
 80097b2:	611a      	str	r2, [r3, #16]
    pObj->IO.ReadReg   = pIO->ReadReg;
 80097b4:	683b      	ldr	r3, [r7, #0]
 80097b6:	695a      	ldr	r2, [r3, #20]
 80097b8:	687b      	ldr	r3, [r7, #4]
 80097ba:	615a      	str	r2, [r3, #20]
    pObj->IO.GetTick   = pIO->GetTick;
 80097bc:	683b      	ldr	r3, [r7, #0]
 80097be:	699a      	ldr	r2, [r3, #24]
 80097c0:	687b      	ldr	r3, [r7, #4]
 80097c2:	619a      	str	r2, [r3, #24]

    pObj->Ctx.read_reg  = ReadRegWrap;
 80097c4:	687b      	ldr	r3, [r7, #4]
 80097c6:	4a1d      	ldr	r2, [pc, #116]	@ (800983c <LPS22DF_RegisterBusIO+0xcc>)
 80097c8:	625a      	str	r2, [r3, #36]	@ 0x24
    pObj->Ctx.write_reg = WriteRegWrap;
 80097ca:	687b      	ldr	r3, [r7, #4]
 80097cc:	4a1c      	ldr	r2, [pc, #112]	@ (8009840 <LPS22DF_RegisterBusIO+0xd0>)
 80097ce:	621a      	str	r2, [r3, #32]
    pObj->Ctx.mdelay    = pIO->Delay;
 80097d0:	683b      	ldr	r3, [r7, #0]
 80097d2:	69da      	ldr	r2, [r3, #28]
 80097d4:	687b      	ldr	r3, [r7, #4]
 80097d6:	629a      	str	r2, [r3, #40]	@ 0x28
    pObj->Ctx.handle    = pObj;
 80097d8:	687b      	ldr	r3, [r7, #4]
 80097da:	687a      	ldr	r2, [r7, #4]
 80097dc:	62da      	str	r2, [r3, #44]	@ 0x2c

    if (pObj->IO.Init == NULL)
 80097de:	687b      	ldr	r3, [r7, #4]
 80097e0:	681b      	ldr	r3, [r3, #0]
 80097e2:	2b00      	cmp	r3, #0
 80097e4:	d103      	bne.n	80097ee <LPS22DF_RegisterBusIO+0x7e>
    {
      ret = LPS22DF_ERROR;
 80097e6:	f04f 33ff 	mov.w	r3, #4294967295
 80097ea:	60fb      	str	r3, [r7, #12]
 80097ec:	e020      	b.n	8009830 <LPS22DF_RegisterBusIO+0xc0>
    }
    else if (pObj->IO.Init() != LPS22DF_OK)
 80097ee:	687b      	ldr	r3, [r7, #4]
 80097f0:	681b      	ldr	r3, [r3, #0]
 80097f2:	4798      	blx	r3
 80097f4:	4603      	mov	r3, r0
 80097f6:	2b00      	cmp	r3, #0
 80097f8:	d003      	beq.n	8009802 <LPS22DF_RegisterBusIO+0x92>
    {
      ret = LPS22DF_ERROR;
 80097fa:	f04f 33ff 	mov.w	r3, #4294967295
 80097fe:	60fb      	str	r3, [r7, #12]
 8009800:	e016      	b.n	8009830 <LPS22DF_RegisterBusIO+0xc0>
    }
    else
    {
      if (pObj->IO.BusType == LPS22DF_SPI_3WIRES_BUS) /* SPI 3-Wires */
 8009802:	687b      	ldr	r3, [r7, #4]
 8009804:	689b      	ldr	r3, [r3, #8]
 8009806:	2b02      	cmp	r3, #2
 8009808:	d112      	bne.n	8009830 <LPS22DF_RegisterBusIO+0xc0>
      {
        /* Enable the SPI 3-Wires support only the first time */
        if (pObj->is_initialized == 0U)
 800980a:	687b      	ldr	r3, [r7, #4]
 800980c:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
 8009810:	2b00      	cmp	r3, #0
 8009812:	d10d      	bne.n	8009830 <LPS22DF_RegisterBusIO+0xc0>
        {
          /* Enable SPI 3-Wires on the component */
          uint8_t data = 0x20;
 8009814:	2320      	movs	r3, #32
 8009816:	72fb      	strb	r3, [r7, #11]

          if (LPS22DF_Write_Reg(pObj, LPS22DF_IF_CTRL, data) != LPS22DF_OK)
 8009818:	7afb      	ldrb	r3, [r7, #11]
 800981a:	461a      	mov	r2, r3
 800981c:	210e      	movs	r1, #14
 800981e:	6878      	ldr	r0, [r7, #4]
 8009820:	f000 f9e0 	bl	8009be4 <LPS22DF_Write_Reg>
 8009824:	4603      	mov	r3, r0
 8009826:	2b00      	cmp	r3, #0
 8009828:	d002      	beq.n	8009830 <LPS22DF_RegisterBusIO+0xc0>
          {
            ret = LPS22DF_ERROR;
 800982a:	f04f 33ff 	mov.w	r3, #4294967295
 800982e:	60fb      	str	r3, [r7, #12]
        }
      }
    }
  }

  return ret;
 8009830:	68fb      	ldr	r3, [r7, #12]
}
 8009832:	4618      	mov	r0, r3
 8009834:	3710      	adds	r7, #16
 8009836:	46bd      	mov	sp, r7
 8009838:	bd80      	pop	{r7, pc}
 800983a:	bf00      	nop
 800983c:	08009f85 	.word	0x08009f85
 8009840:	08009fbb 	.word	0x08009fbb

08009844 <LPS22DF_Init>:
  * @brief  Initialize the LPS22DF sensor
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LPS22DF_Init(LPS22DF_Object_t *pObj)
{
 8009844:	b580      	push	{r7, lr}
 8009846:	b082      	sub	sp, #8
 8009848:	af00      	add	r7, sp, #0
 800984a:	6078      	str	r0, [r7, #4]
  if (pObj->is_initialized == 0U)
 800984c:	687b      	ldr	r3, [r7, #4]
 800984e:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
 8009852:	2b00      	cmp	r3, #0
 8009854:	d108      	bne.n	8009868 <LPS22DF_Init+0x24>
  {
    if (LPS22DF_Initialize(pObj) != LPS22DF_OK)
 8009856:	6878      	ldr	r0, [r7, #4]
 8009858:	f000 fb38 	bl	8009ecc <LPS22DF_Initialize>
 800985c:	4603      	mov	r3, r0
 800985e:	2b00      	cmp	r3, #0
 8009860:	d002      	beq.n	8009868 <LPS22DF_Init+0x24>
    {
      return LPS22DF_ERROR;
 8009862:	f04f 33ff 	mov.w	r3, #4294967295
 8009866:	e004      	b.n	8009872 <LPS22DF_Init+0x2e>
    }
  }

  pObj->is_initialized = 1U;
 8009868:	687b      	ldr	r3, [r7, #4]
 800986a:	2201      	movs	r2, #1
 800986c:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30

  return LPS22DF_OK;
 8009870:	2300      	movs	r3, #0
}
 8009872:	4618      	mov	r0, r3
 8009874:	3708      	adds	r7, #8
 8009876:	46bd      	mov	sp, r7
 8009878:	bd80      	pop	{r7, pc}

0800987a <LPS22DF_DeInit>:
  * @brief  Deinitialize the LPS22DF sensor
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LPS22DF_DeInit(LPS22DF_Object_t *pObj)
{
 800987a:	b580      	push	{r7, lr}
 800987c:	b082      	sub	sp, #8
 800987e:	af00      	add	r7, sp, #0
 8009880:	6078      	str	r0, [r7, #4]
  if (pObj->is_initialized == 1U)
 8009882:	687b      	ldr	r3, [r7, #4]
 8009884:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
 8009888:	2b01      	cmp	r3, #1
 800988a:	d111      	bne.n	80098b0 <LPS22DF_DeInit+0x36>
  {
    if (LPS22DF_PRESS_Disable(pObj) != LPS22DF_OK)
 800988c:	6878      	ldr	r0, [r7, #4]
 800988e:	f000 f882 	bl	8009996 <LPS22DF_PRESS_Disable>
 8009892:	4603      	mov	r3, r0
 8009894:	2b00      	cmp	r3, #0
 8009896:	d002      	beq.n	800989e <LPS22DF_DeInit+0x24>
    {
      return LPS22DF_ERROR;
 8009898:	f04f 33ff 	mov.w	r3, #4294967295
 800989c:	e00d      	b.n	80098ba <LPS22DF_DeInit+0x40>
    }

    if (LPS22DF_TEMP_Disable(pObj) != LPS22DF_OK)
 800989e:	6878      	ldr	r0, [r7, #4]
 80098a0:	f000 f91e 	bl	8009ae0 <LPS22DF_TEMP_Disable>
 80098a4:	4603      	mov	r3, r0
 80098a6:	2b00      	cmp	r3, #0
 80098a8:	d002      	beq.n	80098b0 <LPS22DF_DeInit+0x36>
    {
      return LPS22DF_ERROR;
 80098aa:	f04f 33ff 	mov.w	r3, #4294967295
 80098ae:	e004      	b.n	80098ba <LPS22DF_DeInit+0x40>
    }
  }

  pObj->is_initialized = 0;
 80098b0:	687b      	ldr	r3, [r7, #4]
 80098b2:	2200      	movs	r2, #0
 80098b4:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30

  return LPS22DF_OK;
 80098b8:	2300      	movs	r3, #0
}
 80098ba:	4618      	mov	r0, r3
 80098bc:	3708      	adds	r7, #8
 80098be:	46bd      	mov	sp, r7
 80098c0:	bd80      	pop	{r7, pc}

080098c2 <LPS22DF_ReadID>:
  * @param  pObj the device pObj
  * @param  Id the WHO_AM_I value
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LPS22DF_ReadID(LPS22DF_Object_t *pObj, uint8_t *Id)
{
 80098c2:	b580      	push	{r7, lr}
 80098c4:	b084      	sub	sp, #16
 80098c6:	af00      	add	r7, sp, #0
 80098c8:	6078      	str	r0, [r7, #4]
 80098ca:	6039      	str	r1, [r7, #0]
  lps22df_id_t val;
  if (lps22df_id_get(&(pObj->Ctx), &val) != LPS22DF_OK)
 80098cc:	687b      	ldr	r3, [r7, #4]
 80098ce:	3320      	adds	r3, #32
 80098d0:	f107 020c 	add.w	r2, r7, #12
 80098d4:	4611      	mov	r1, r2
 80098d6:	4618      	mov	r0, r3
 80098d8:	f000 fc02 	bl	800a0e0 <lps22df_id_get>
 80098dc:	4603      	mov	r3, r0
 80098de:	2b00      	cmp	r3, #0
 80098e0:	d002      	beq.n	80098e8 <LPS22DF_ReadID+0x26>
  {
    return LPS22DF_ERROR;
 80098e2:	f04f 33ff 	mov.w	r3, #4294967295
 80098e6:	e003      	b.n	80098f0 <LPS22DF_ReadID+0x2e>
  }

  *Id = val.whoami;
 80098e8:	7b3a      	ldrb	r2, [r7, #12]
 80098ea:	683b      	ldr	r3, [r7, #0]
 80098ec:	701a      	strb	r2, [r3, #0]

  return LPS22DF_OK;
 80098ee:	2300      	movs	r3, #0
}
 80098f0:	4618      	mov	r0, r3
 80098f2:	3710      	adds	r7, #16
 80098f4:	46bd      	mov	sp, r7
 80098f6:	bd80      	pop	{r7, pc}

080098f8 <LPS22DF_GetCapabilities>:
  * @param  pObj Component object pointer
  * @param  Capabilities pointer to LPS22DF sensor capabilities
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LPS22DF_GetCapabilities(LPS22DF_Object_t *pObj, LPS22DF_Capabilities_t *Capabilities)
{
 80098f8:	b480      	push	{r7}
 80098fa:	b083      	sub	sp, #12
 80098fc:	af00      	add	r7, sp, #0
 80098fe:	6078      	str	r0, [r7, #4]
 8009900:	6039      	str	r1, [r7, #0]
  /* Prevent unused argument(s) compilation warning */
  (void)(pObj);

  Capabilities->Humidity    = 0;
 8009902:	683b      	ldr	r3, [r7, #0]
 8009904:	2200      	movs	r2, #0
 8009906:	709a      	strb	r2, [r3, #2]
  Capabilities->Pressure    = 1;
 8009908:	683b      	ldr	r3, [r7, #0]
 800990a:	2201      	movs	r2, #1
 800990c:	705a      	strb	r2, [r3, #1]
  Capabilities->Temperature = 1;
 800990e:	683b      	ldr	r3, [r7, #0]
 8009910:	2201      	movs	r2, #1
 8009912:	701a      	strb	r2, [r3, #0]
  Capabilities->Gas         = 0;
 8009914:	683b      	ldr	r3, [r7, #0]
 8009916:	2200      	movs	r2, #0
 8009918:	70da      	strb	r2, [r3, #3]
  Capabilities->LowPower    = 0;
 800991a:	683b      	ldr	r3, [r7, #0]
 800991c:	2200      	movs	r2, #0
 800991e:	711a      	strb	r2, [r3, #4]
  Capabilities->HumMaxOdr   = 0.0f;
 8009920:	683b      	ldr	r3, [r7, #0]
 8009922:	f04f 0200 	mov.w	r2, #0
 8009926:	609a      	str	r2, [r3, #8]
  Capabilities->TempMaxOdr  = 200.0f;
 8009928:	683b      	ldr	r3, [r7, #0]
 800992a:	4a08      	ldr	r2, [pc, #32]	@ (800994c <LPS22DF_GetCapabilities+0x54>)
 800992c:	60da      	str	r2, [r3, #12]
  Capabilities->PressMaxOdr = 200.0f;
 800992e:	683b      	ldr	r3, [r7, #0]
 8009930:	4a06      	ldr	r2, [pc, #24]	@ (800994c <LPS22DF_GetCapabilities+0x54>)
 8009932:	611a      	str	r2, [r3, #16]
  Capabilities->GasMaxOdr   = 0.0f;
 8009934:	683b      	ldr	r3, [r7, #0]
 8009936:	f04f 0200 	mov.w	r2, #0
 800993a:	615a      	str	r2, [r3, #20]
  return LPS22DF_OK;
 800993c:	2300      	movs	r3, #0
}
 800993e:	4618      	mov	r0, r3
 8009940:	370c      	adds	r7, #12
 8009942:	46bd      	mov	sp, r7
 8009944:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009948:	4770      	bx	lr
 800994a:	bf00      	nop
 800994c:	43480000 	.word	0x43480000

08009950 <LPS22DF_PRESS_Enable>:
  * @brief  Enable the LPS22DF pressure sensor
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LPS22DF_PRESS_Enable(LPS22DF_Object_t *pObj)
{
 8009950:	b580      	push	{r7, lr}
 8009952:	b082      	sub	sp, #8
 8009954:	af00      	add	r7, sp, #0
 8009956:	6078      	str	r0, [r7, #4]
  /* Check if the component is already enabled */
  if (pObj->press_is_enabled == 1U)
 8009958:	687b      	ldr	r3, [r7, #4]
 800995a:	f893 3031 	ldrb.w	r3, [r3, #49]	@ 0x31
 800995e:	2b01      	cmp	r3, #1
 8009960:	d101      	bne.n	8009966 <LPS22DF_PRESS_Enable+0x16>
  {
    return LPS22DF_OK;
 8009962:	2300      	movs	r3, #0
 8009964:	e013      	b.n	800998e <LPS22DF_PRESS_Enable+0x3e>
  }

  /* Output data rate selection. */
  if (lps22df_mode_set(&(pObj->Ctx), &pObj->last_odr) != LPS22DF_OK)
 8009966:	687b      	ldr	r3, [r7, #4]
 8009968:	f103 0220 	add.w	r2, r3, #32
 800996c:	687b      	ldr	r3, [r7, #4]
 800996e:	3333      	adds	r3, #51	@ 0x33
 8009970:	4619      	mov	r1, r3
 8009972:	4610      	mov	r0, r2
 8009974:	f000 fca4 	bl	800a2c0 <lps22df_mode_set>
 8009978:	4603      	mov	r3, r0
 800997a:	2b00      	cmp	r3, #0
 800997c:	d002      	beq.n	8009984 <LPS22DF_PRESS_Enable+0x34>
  {
    return LPS22DF_ERROR;
 800997e:	f04f 33ff 	mov.w	r3, #4294967295
 8009982:	e004      	b.n	800998e <LPS22DF_PRESS_Enable+0x3e>
  }

  pObj->press_is_enabled = 1;
 8009984:	687b      	ldr	r3, [r7, #4]
 8009986:	2201      	movs	r2, #1
 8009988:	f883 2031 	strb.w	r2, [r3, #49]	@ 0x31

  return LPS22DF_OK;
 800998c:	2300      	movs	r3, #0
}
 800998e:	4618      	mov	r0, r3
 8009990:	3708      	adds	r7, #8
 8009992:	46bd      	mov	sp, r7
 8009994:	bd80      	pop	{r7, pc}

08009996 <LPS22DF_PRESS_Disable>:
  * @brief  Disable the LPS22DF pressure sensor
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LPS22DF_PRESS_Disable(LPS22DF_Object_t *pObj)
{
 8009996:	b580      	push	{r7, lr}
 8009998:	b084      	sub	sp, #16
 800999a:	af00      	add	r7, sp, #0
 800999c:	6078      	str	r0, [r7, #4]
  /* Check if the component is already disabled */
  if (pObj->press_is_enabled == 0U)
 800999e:	687b      	ldr	r3, [r7, #4]
 80099a0:	f893 3031 	ldrb.w	r3, [r3, #49]	@ 0x31
 80099a4:	2b00      	cmp	r3, #0
 80099a6:	d101      	bne.n	80099ac <LPS22DF_PRESS_Disable+0x16>
  {
    return LPS22DF_OK;
 80099a8:	2300      	movs	r3, #0
 80099aa:	e030      	b.n	8009a0e <LPS22DF_PRESS_Disable+0x78>
  }

  /* Check if the LPS22DF temperature sensor is still enable. */
  /* If yes, skip the disable function, if not call disable function */
  if (pObj->temp_is_enabled == 0U)
 80099ac:	687b      	ldr	r3, [r7, #4]
 80099ae:	f893 3032 	ldrb.w	r3, [r3, #50]	@ 0x32
 80099b2:	2b00      	cmp	r3, #0
 80099b4:	d126      	bne.n	8009a04 <LPS22DF_PRESS_Disable+0x6e>
  {
    lps22df_md_t val;

    /* Get current output data rate. */
    if (lps22df_mode_get(&(pObj->Ctx), &val) != LPS22DF_OK)
 80099b6:	687b      	ldr	r3, [r7, #4]
 80099b8:	3320      	adds	r3, #32
 80099ba:	f107 020c 	add.w	r2, r7, #12
 80099be:	4611      	mov	r1, r2
 80099c0:	4618      	mov	r0, r3
 80099c2:	f000 fcdb 	bl	800a37c <lps22df_mode_get>
 80099c6:	4603      	mov	r3, r0
 80099c8:	2b00      	cmp	r3, #0
 80099ca:	d002      	beq.n	80099d2 <LPS22DF_PRESS_Disable+0x3c>
    {
      return LPS22DF_ERROR;
 80099cc:	f04f 33ff 	mov.w	r3, #4294967295
 80099d0:	e01d      	b.n	8009a0e <LPS22DF_PRESS_Disable+0x78>
    }

    memcpy(&pObj->last_odr, &val, sizeof(lps22df_md_t));
 80099d2:	687b      	ldr	r3, [r7, #4]
 80099d4:	3333      	adds	r3, #51	@ 0x33
 80099d6:	461a      	mov	r2, r3
 80099d8:	f107 030c 	add.w	r3, r7, #12
 80099dc:	8819      	ldrh	r1, [r3, #0]
 80099de:	789b      	ldrb	r3, [r3, #2]
 80099e0:	8011      	strh	r1, [r2, #0]
 80099e2:	7093      	strb	r3, [r2, #2]

    val.odr = LPS22DF_ONE_SHOT;
 80099e4:	2300      	movs	r3, #0
 80099e6:	733b      	strb	r3, [r7, #12]

    /* Output data rate selection - power down. */
    if (lps22df_mode_set(&(pObj->Ctx), &val) != LPS22DF_OK)
 80099e8:	687b      	ldr	r3, [r7, #4]
 80099ea:	3320      	adds	r3, #32
 80099ec:	f107 020c 	add.w	r2, r7, #12
 80099f0:	4611      	mov	r1, r2
 80099f2:	4618      	mov	r0, r3
 80099f4:	f000 fc64 	bl	800a2c0 <lps22df_mode_set>
 80099f8:	4603      	mov	r3, r0
 80099fa:	2b00      	cmp	r3, #0
 80099fc:	d002      	beq.n	8009a04 <LPS22DF_PRESS_Disable+0x6e>
    {
      return LPS22DF_ERROR;
 80099fe:	f04f 33ff 	mov.w	r3, #4294967295
 8009a02:	e004      	b.n	8009a0e <LPS22DF_PRESS_Disable+0x78>
    }
  }

  pObj->press_is_enabled = 0;
 8009a04:	687b      	ldr	r3, [r7, #4]
 8009a06:	2200      	movs	r2, #0
 8009a08:	f883 2031 	strb.w	r2, [r3, #49]	@ 0x31

  return LPS22DF_OK;
 8009a0c:	2300      	movs	r3, #0
}
 8009a0e:	4618      	mov	r0, r3
 8009a10:	3710      	adds	r7, #16
 8009a12:	46bd      	mov	sp, r7
 8009a14:	bd80      	pop	{r7, pc}

08009a16 <LPS22DF_PRESS_GetOutputDataRate>:
  * @param  pObj the device pObj
  * @param  Odr pointer where the output data rate is written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LPS22DF_PRESS_GetOutputDataRate(LPS22DF_Object_t *pObj, float *Odr)
{
 8009a16:	b580      	push	{r7, lr}
 8009a18:	b082      	sub	sp, #8
 8009a1a:	af00      	add	r7, sp, #0
 8009a1c:	6078      	str	r0, [r7, #4]
 8009a1e:	6039      	str	r1, [r7, #0]
  return LPS22DF_GetOutputDataRate(pObj, Odr);
 8009a20:	6839      	ldr	r1, [r7, #0]
 8009a22:	6878      	ldr	r0, [r7, #4]
 8009a24:	f000 f8fa 	bl	8009c1c <LPS22DF_GetOutputDataRate>
 8009a28:	4603      	mov	r3, r0
}
 8009a2a:	4618      	mov	r0, r3
 8009a2c:	3708      	adds	r7, #8
 8009a2e:	46bd      	mov	sp, r7
 8009a30:	bd80      	pop	{r7, pc}

08009a32 <LPS22DF_PRESS_SetOutputDataRate>:
  * @param  pObj the device pObj
  * @param  Odr the output data rate value to be set
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LPS22DF_PRESS_SetOutputDataRate(LPS22DF_Object_t *pObj, float Odr)
{
 8009a32:	b580      	push	{r7, lr}
 8009a34:	b082      	sub	sp, #8
 8009a36:	af00      	add	r7, sp, #0
 8009a38:	6078      	str	r0, [r7, #4]
 8009a3a:	6039      	str	r1, [r7, #0]
  /* Check if the component is enabled */
  if (pObj->press_is_enabled == 1U)
 8009a3c:	687b      	ldr	r3, [r7, #4]
 8009a3e:	f893 3031 	ldrb.w	r3, [r3, #49]	@ 0x31
 8009a42:	2b01      	cmp	r3, #1
 8009a44:	d105      	bne.n	8009a52 <LPS22DF_PRESS_SetOutputDataRate+0x20>
  {
    return LPS22DF_SetOutputDataRate_When_Enabled(pObj, Odr);
 8009a46:	6839      	ldr	r1, [r7, #0]
 8009a48:	6878      	ldr	r0, [r7, #4]
 8009a4a:	f000 f951 	bl	8009cf0 <LPS22DF_SetOutputDataRate_When_Enabled>
 8009a4e:	4603      	mov	r3, r0
 8009a50:	e004      	b.n	8009a5c <LPS22DF_PRESS_SetOutputDataRate+0x2a>
  }
  else
  {
    return LPS22DF_SetOutputDataRate_When_Disabled(pObj, Odr);
 8009a52:	6839      	ldr	r1, [r7, #0]
 8009a54:	6878      	ldr	r0, [r7, #4]
 8009a56:	f000 f9d5 	bl	8009e04 <LPS22DF_SetOutputDataRate_When_Disabled>
 8009a5a:	4603      	mov	r3, r0
  }
}
 8009a5c:	4618      	mov	r0, r3
 8009a5e:	3708      	adds	r7, #8
 8009a60:	46bd      	mov	sp, r7
 8009a62:	bd80      	pop	{r7, pc}

08009a64 <LPS22DF_PRESS_GetPressure>:
  * @param  pObj the device pObj
  * @param  Value pointer where the pressure value is written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LPS22DF_PRESS_GetPressure(LPS22DF_Object_t *pObj, float *Value)
{
 8009a64:	b580      	push	{r7, lr}
 8009a66:	b086      	sub	sp, #24
 8009a68:	af00      	add	r7, sp, #0
 8009a6a:	6078      	str	r0, [r7, #4]
 8009a6c:	6039      	str	r1, [r7, #0]
  lps22df_data_t data;

  if (lps22df_data_get(&(pObj->Ctx), &data) != LPS22DF_OK)
 8009a6e:	687b      	ldr	r3, [r7, #4]
 8009a70:	3320      	adds	r3, #32
 8009a72:	f107 0208 	add.w	r2, r7, #8
 8009a76:	4611      	mov	r1, r2
 8009a78:	4618      	mov	r0, r3
 8009a7a:	f000 fd4b 	bl	800a514 <lps22df_data_get>
 8009a7e:	4603      	mov	r3, r0
 8009a80:	2b00      	cmp	r3, #0
 8009a82:	d002      	beq.n	8009a8a <LPS22DF_PRESS_GetPressure+0x26>
  {
    return LPS22DF_ERROR;
 8009a84:	f04f 33ff 	mov.w	r3, #4294967295
 8009a88:	e003      	b.n	8009a92 <LPS22DF_PRESS_GetPressure+0x2e>
  }

  *Value = data.pressure.hpa;
 8009a8a:	68ba      	ldr	r2, [r7, #8]
 8009a8c:	683b      	ldr	r3, [r7, #0]
 8009a8e:	601a      	str	r2, [r3, #0]

  return LPS22DF_OK;
 8009a90:	2300      	movs	r3, #0
}
 8009a92:	4618      	mov	r0, r3
 8009a94:	3718      	adds	r7, #24
 8009a96:	46bd      	mov	sp, r7
 8009a98:	bd80      	pop	{r7, pc}

08009a9a <LPS22DF_TEMP_Enable>:
  * @brief  Enable the LPS22DF temperature sensor
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LPS22DF_TEMP_Enable(LPS22DF_Object_t *pObj)
{
 8009a9a:	b580      	push	{r7, lr}
 8009a9c:	b082      	sub	sp, #8
 8009a9e:	af00      	add	r7, sp, #0
 8009aa0:	6078      	str	r0, [r7, #4]
  /* Check if the component is already enabled */
  if (pObj->temp_is_enabled == 1U)
 8009aa2:	687b      	ldr	r3, [r7, #4]
 8009aa4:	f893 3032 	ldrb.w	r3, [r3, #50]	@ 0x32
 8009aa8:	2b01      	cmp	r3, #1
 8009aaa:	d101      	bne.n	8009ab0 <LPS22DF_TEMP_Enable+0x16>
  {
    return LPS22DF_OK;
 8009aac:	2300      	movs	r3, #0
 8009aae:	e013      	b.n	8009ad8 <LPS22DF_TEMP_Enable+0x3e>
  }

  /* Output data rate selection. */
  if (lps22df_mode_set(&(pObj->Ctx), &pObj->last_odr) != LPS22DF_OK)
 8009ab0:	687b      	ldr	r3, [r7, #4]
 8009ab2:	f103 0220 	add.w	r2, r3, #32
 8009ab6:	687b      	ldr	r3, [r7, #4]
 8009ab8:	3333      	adds	r3, #51	@ 0x33
 8009aba:	4619      	mov	r1, r3
 8009abc:	4610      	mov	r0, r2
 8009abe:	f000 fbff 	bl	800a2c0 <lps22df_mode_set>
 8009ac2:	4603      	mov	r3, r0
 8009ac4:	2b00      	cmp	r3, #0
 8009ac6:	d002      	beq.n	8009ace <LPS22DF_TEMP_Enable+0x34>
  {
    return LPS22DF_ERROR;
 8009ac8:	f04f 33ff 	mov.w	r3, #4294967295
 8009acc:	e004      	b.n	8009ad8 <LPS22DF_TEMP_Enable+0x3e>
  }

  pObj->temp_is_enabled = 1;
 8009ace:	687b      	ldr	r3, [r7, #4]
 8009ad0:	2201      	movs	r2, #1
 8009ad2:	f883 2032 	strb.w	r2, [r3, #50]	@ 0x32

  return LPS22DF_OK;
 8009ad6:	2300      	movs	r3, #0
}
 8009ad8:	4618      	mov	r0, r3
 8009ada:	3708      	adds	r7, #8
 8009adc:	46bd      	mov	sp, r7
 8009ade:	bd80      	pop	{r7, pc}

08009ae0 <LPS22DF_TEMP_Disable>:
  * @brief  Disable the LPS22DF temperature sensor
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LPS22DF_TEMP_Disable(LPS22DF_Object_t *pObj)
{
 8009ae0:	b580      	push	{r7, lr}
 8009ae2:	b084      	sub	sp, #16
 8009ae4:	af00      	add	r7, sp, #0
 8009ae6:	6078      	str	r0, [r7, #4]
  /* Check if the component is already disabled */
  if (pObj->temp_is_enabled == 0U)
 8009ae8:	687b      	ldr	r3, [r7, #4]
 8009aea:	f893 3032 	ldrb.w	r3, [r3, #50]	@ 0x32
 8009aee:	2b00      	cmp	r3, #0
 8009af0:	d101      	bne.n	8009af6 <LPS22DF_TEMP_Disable+0x16>
  {
    return LPS22DF_OK;
 8009af2:	2300      	movs	r3, #0
 8009af4:	e030      	b.n	8009b58 <LPS22DF_TEMP_Disable+0x78>
  }

  /* Check if the LPS22DF pressure sensor is still enable. */
  /* If yes, skip the disable function, if not call disable function */
  if (pObj->press_is_enabled == 0U)
 8009af6:	687b      	ldr	r3, [r7, #4]
 8009af8:	f893 3031 	ldrb.w	r3, [r3, #49]	@ 0x31
 8009afc:	2b00      	cmp	r3, #0
 8009afe:	d126      	bne.n	8009b4e <LPS22DF_TEMP_Disable+0x6e>
  {
    lps22df_md_t val;

    /* Get current output data rate. */
    if (lps22df_mode_get(&(pObj->Ctx), &val) != LPS22DF_OK)
 8009b00:	687b      	ldr	r3, [r7, #4]
 8009b02:	3320      	adds	r3, #32
 8009b04:	f107 020c 	add.w	r2, r7, #12
 8009b08:	4611      	mov	r1, r2
 8009b0a:	4618      	mov	r0, r3
 8009b0c:	f000 fc36 	bl	800a37c <lps22df_mode_get>
 8009b10:	4603      	mov	r3, r0
 8009b12:	2b00      	cmp	r3, #0
 8009b14:	d002      	beq.n	8009b1c <LPS22DF_TEMP_Disable+0x3c>
    {
      return LPS22DF_ERROR;
 8009b16:	f04f 33ff 	mov.w	r3, #4294967295
 8009b1a:	e01d      	b.n	8009b58 <LPS22DF_TEMP_Disable+0x78>
    }

    memcpy(&pObj->last_odr, &val, sizeof(lps22df_md_t));
 8009b1c:	687b      	ldr	r3, [r7, #4]
 8009b1e:	3333      	adds	r3, #51	@ 0x33
 8009b20:	461a      	mov	r2, r3
 8009b22:	f107 030c 	add.w	r3, r7, #12
 8009b26:	8819      	ldrh	r1, [r3, #0]
 8009b28:	789b      	ldrb	r3, [r3, #2]
 8009b2a:	8011      	strh	r1, [r2, #0]
 8009b2c:	7093      	strb	r3, [r2, #2]

    val.odr = LPS22DF_ONE_SHOT;
 8009b2e:	2300      	movs	r3, #0
 8009b30:	733b      	strb	r3, [r7, #12]

    /* Output data rate selection - power down. */
    if (lps22df_mode_set(&(pObj->Ctx), &val) != LPS22DF_OK)
 8009b32:	687b      	ldr	r3, [r7, #4]
 8009b34:	3320      	adds	r3, #32
 8009b36:	f107 020c 	add.w	r2, r7, #12
 8009b3a:	4611      	mov	r1, r2
 8009b3c:	4618      	mov	r0, r3
 8009b3e:	f000 fbbf 	bl	800a2c0 <lps22df_mode_set>
 8009b42:	4603      	mov	r3, r0
 8009b44:	2b00      	cmp	r3, #0
 8009b46:	d002      	beq.n	8009b4e <LPS22DF_TEMP_Disable+0x6e>
    {
      return LPS22DF_ERROR;
 8009b48:	f04f 33ff 	mov.w	r3, #4294967295
 8009b4c:	e004      	b.n	8009b58 <LPS22DF_TEMP_Disable+0x78>
    }
  }

  pObj->temp_is_enabled = 0;
 8009b4e:	687b      	ldr	r3, [r7, #4]
 8009b50:	2200      	movs	r2, #0
 8009b52:	f883 2032 	strb.w	r2, [r3, #50]	@ 0x32

  return LPS22DF_OK;
 8009b56:	2300      	movs	r3, #0
}
 8009b58:	4618      	mov	r0, r3
 8009b5a:	3710      	adds	r7, #16
 8009b5c:	46bd      	mov	sp, r7
 8009b5e:	bd80      	pop	{r7, pc}

08009b60 <LPS22DF_TEMP_GetOutputDataRate>:
  * @param  pObj the device pObj
  * @param  Odr pointer where the output data rate is written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LPS22DF_TEMP_GetOutputDataRate(LPS22DF_Object_t *pObj, float *Odr)
{
 8009b60:	b580      	push	{r7, lr}
 8009b62:	b082      	sub	sp, #8
 8009b64:	af00      	add	r7, sp, #0
 8009b66:	6078      	str	r0, [r7, #4]
 8009b68:	6039      	str	r1, [r7, #0]
  return LPS22DF_GetOutputDataRate(pObj, Odr);
 8009b6a:	6839      	ldr	r1, [r7, #0]
 8009b6c:	6878      	ldr	r0, [r7, #4]
 8009b6e:	f000 f855 	bl	8009c1c <LPS22DF_GetOutputDataRate>
 8009b72:	4603      	mov	r3, r0
}
 8009b74:	4618      	mov	r0, r3
 8009b76:	3708      	adds	r7, #8
 8009b78:	46bd      	mov	sp, r7
 8009b7a:	bd80      	pop	{r7, pc}

08009b7c <LPS22DF_TEMP_SetOutputDataRate>:
  * @param  pObj the device pObj
  * @param  Odr the output data rate value to be set
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LPS22DF_TEMP_SetOutputDataRate(LPS22DF_Object_t *pObj, float Odr)
{
 8009b7c:	b580      	push	{r7, lr}
 8009b7e:	b082      	sub	sp, #8
 8009b80:	af00      	add	r7, sp, #0
 8009b82:	6078      	str	r0, [r7, #4]
 8009b84:	6039      	str	r1, [r7, #0]
  /* Check if the component is enabled */
  if (pObj->temp_is_enabled == 1U)
 8009b86:	687b      	ldr	r3, [r7, #4]
 8009b88:	f893 3032 	ldrb.w	r3, [r3, #50]	@ 0x32
 8009b8c:	2b01      	cmp	r3, #1
 8009b8e:	d105      	bne.n	8009b9c <LPS22DF_TEMP_SetOutputDataRate+0x20>
  {
    return LPS22DF_SetOutputDataRate_When_Enabled(pObj, Odr);
 8009b90:	6839      	ldr	r1, [r7, #0]
 8009b92:	6878      	ldr	r0, [r7, #4]
 8009b94:	f000 f8ac 	bl	8009cf0 <LPS22DF_SetOutputDataRate_When_Enabled>
 8009b98:	4603      	mov	r3, r0
 8009b9a:	e004      	b.n	8009ba6 <LPS22DF_TEMP_SetOutputDataRate+0x2a>
  }
  else
  {
    return LPS22DF_SetOutputDataRate_When_Disabled(pObj, Odr);
 8009b9c:	6839      	ldr	r1, [r7, #0]
 8009b9e:	6878      	ldr	r0, [r7, #4]
 8009ba0:	f000 f930 	bl	8009e04 <LPS22DF_SetOutputDataRate_When_Disabled>
 8009ba4:	4603      	mov	r3, r0
  }
}
 8009ba6:	4618      	mov	r0, r3
 8009ba8:	3708      	adds	r7, #8
 8009baa:	46bd      	mov	sp, r7
 8009bac:	bd80      	pop	{r7, pc}

08009bae <LPS22DF_TEMP_GetTemperature>:
  * @param  pObj the device pObj
  * @param  Value pointer where the temperature value is written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LPS22DF_TEMP_GetTemperature(LPS22DF_Object_t *pObj, float *Value)
{
 8009bae:	b580      	push	{r7, lr}
 8009bb0:	b086      	sub	sp, #24
 8009bb2:	af00      	add	r7, sp, #0
 8009bb4:	6078      	str	r0, [r7, #4]
 8009bb6:	6039      	str	r1, [r7, #0]
  lps22df_data_t data;

  if (lps22df_data_get(&(pObj->Ctx), &data) != LPS22DF_OK)
 8009bb8:	687b      	ldr	r3, [r7, #4]
 8009bba:	3320      	adds	r3, #32
 8009bbc:	f107 0208 	add.w	r2, r7, #8
 8009bc0:	4611      	mov	r1, r2
 8009bc2:	4618      	mov	r0, r3
 8009bc4:	f000 fca6 	bl	800a514 <lps22df_data_get>
 8009bc8:	4603      	mov	r3, r0
 8009bca:	2b00      	cmp	r3, #0
 8009bcc:	d002      	beq.n	8009bd4 <LPS22DF_TEMP_GetTemperature+0x26>
  {
    return LPS22DF_ERROR;
 8009bce:	f04f 33ff 	mov.w	r3, #4294967295
 8009bd2:	e003      	b.n	8009bdc <LPS22DF_TEMP_GetTemperature+0x2e>
  }

  *Value = data.heat.deg_c;
 8009bd4:	693a      	ldr	r2, [r7, #16]
 8009bd6:	683b      	ldr	r3, [r7, #0]
 8009bd8:	601a      	str	r2, [r3, #0]

  return LPS22DF_OK;
 8009bda:	2300      	movs	r3, #0
}
 8009bdc:	4618      	mov	r0, r3
 8009bde:	3718      	adds	r7, #24
 8009be0:	46bd      	mov	sp, r7
 8009be2:	bd80      	pop	{r7, pc}

08009be4 <LPS22DF_Write_Reg>:
  * @param  Reg address to be written
  * @param  Data value to be written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LPS22DF_Write_Reg(LPS22DF_Object_t *pObj, uint8_t Reg, uint8_t Data)
{
 8009be4:	b580      	push	{r7, lr}
 8009be6:	b082      	sub	sp, #8
 8009be8:	af00      	add	r7, sp, #0
 8009bea:	6078      	str	r0, [r7, #4]
 8009bec:	460b      	mov	r3, r1
 8009bee:	70fb      	strb	r3, [r7, #3]
 8009bf0:	4613      	mov	r3, r2
 8009bf2:	70bb      	strb	r3, [r7, #2]
  if (lps22df_write_reg(&(pObj->Ctx), Reg, &Data, 1) != LPS22DF_OK)
 8009bf4:	687b      	ldr	r3, [r7, #4]
 8009bf6:	f103 0020 	add.w	r0, r3, #32
 8009bfa:	1cba      	adds	r2, r7, #2
 8009bfc:	78f9      	ldrb	r1, [r7, #3]
 8009bfe:	2301      	movs	r3, #1
 8009c00:	f000 fa0e 	bl	800a020 <lps22df_write_reg>
 8009c04:	4603      	mov	r3, r0
 8009c06:	2b00      	cmp	r3, #0
 8009c08:	d002      	beq.n	8009c10 <LPS22DF_Write_Reg+0x2c>
  {
    return LPS22DF_ERROR;
 8009c0a:	f04f 33ff 	mov.w	r3, #4294967295
 8009c0e:	e000      	b.n	8009c12 <LPS22DF_Write_Reg+0x2e>
  }

  return LPS22DF_OK;
 8009c10:	2300      	movs	r3, #0
}
 8009c12:	4618      	mov	r0, r3
 8009c14:	3708      	adds	r7, #8
 8009c16:	46bd      	mov	sp, r7
 8009c18:	bd80      	pop	{r7, pc}
	...

08009c1c <LPS22DF_GetOutputDataRate>:
  * @param  pObj the device pObj
  * @param  Odr the output data rate value
  * @retval 0 in case of success, an error code otherwise
  */
static int32_t LPS22DF_GetOutputDataRate(LPS22DF_Object_t *pObj, float *Odr)
{
 8009c1c:	b580      	push	{r7, lr}
 8009c1e:	b084      	sub	sp, #16
 8009c20:	af00      	add	r7, sp, #0
 8009c22:	6078      	str	r0, [r7, #4]
 8009c24:	6039      	str	r1, [r7, #0]
  int32_t ret = LPS22DF_OK;
 8009c26:	2300      	movs	r3, #0
 8009c28:	60fb      	str	r3, [r7, #12]
  lps22df_md_t val;

  if (lps22df_mode_get(&(pObj->Ctx), &val) != LPS22DF_OK)
 8009c2a:	687b      	ldr	r3, [r7, #4]
 8009c2c:	3320      	adds	r3, #32
 8009c2e:	f107 0208 	add.w	r2, r7, #8
 8009c32:	4611      	mov	r1, r2
 8009c34:	4618      	mov	r0, r3
 8009c36:	f000 fba1 	bl	800a37c <lps22df_mode_get>
 8009c3a:	4603      	mov	r3, r0
 8009c3c:	2b00      	cmp	r3, #0
 8009c3e:	d002      	beq.n	8009c46 <LPS22DF_GetOutputDataRate+0x2a>
  {
    return LPS22DF_ERROR;
 8009c40:	f04f 33ff 	mov.w	r3, #4294967295
 8009c44:	e044      	b.n	8009cd0 <LPS22DF_GetOutputDataRate+0xb4>
  }

  switch (val.odr)
 8009c46:	7a3b      	ldrb	r3, [r7, #8]
 8009c48:	2b08      	cmp	r3, #8
 8009c4a:	d83c      	bhi.n	8009cc6 <LPS22DF_GetOutputDataRate+0xaa>
 8009c4c:	a201      	add	r2, pc, #4	@ (adr r2, 8009c54 <LPS22DF_GetOutputDataRate+0x38>)
 8009c4e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8009c52:	bf00      	nop
 8009c54:	08009c79 	.word	0x08009c79
 8009c58:	08009c83 	.word	0x08009c83
 8009c5c:	08009c8d 	.word	0x08009c8d
 8009c60:	08009c97 	.word	0x08009c97
 8009c64:	08009c9f 	.word	0x08009c9f
 8009c68:	08009ca7 	.word	0x08009ca7
 8009c6c:	08009caf 	.word	0x08009caf
 8009c70:	08009cb7 	.word	0x08009cb7
 8009c74:	08009cbf 	.word	0x08009cbf
  {
    case LPS22DF_ONE_SHOT:
      *Odr = 0.0f;
 8009c78:	683b      	ldr	r3, [r7, #0]
 8009c7a:	f04f 0200 	mov.w	r2, #0
 8009c7e:	601a      	str	r2, [r3, #0]
      break;
 8009c80:	e025      	b.n	8009cce <LPS22DF_GetOutputDataRate+0xb2>

    case LPS22DF_1Hz:
      *Odr = 1.0f;
 8009c82:	683b      	ldr	r3, [r7, #0]
 8009c84:	f04f 527e 	mov.w	r2, #1065353216	@ 0x3f800000
 8009c88:	601a      	str	r2, [r3, #0]
      break;
 8009c8a:	e020      	b.n	8009cce <LPS22DF_GetOutputDataRate+0xb2>

    case LPS22DF_4Hz:
      *Odr = 4.0f;
 8009c8c:	683b      	ldr	r3, [r7, #0]
 8009c8e:	f04f 4281 	mov.w	r2, #1082130432	@ 0x40800000
 8009c92:	601a      	str	r2, [r3, #0]
      break;
 8009c94:	e01b      	b.n	8009cce <LPS22DF_GetOutputDataRate+0xb2>

    case LPS22DF_10Hz:
      *Odr = 10.0f;
 8009c96:	683b      	ldr	r3, [r7, #0]
 8009c98:	4a0f      	ldr	r2, [pc, #60]	@ (8009cd8 <LPS22DF_GetOutputDataRate+0xbc>)
 8009c9a:	601a      	str	r2, [r3, #0]
      break;
 8009c9c:	e017      	b.n	8009cce <LPS22DF_GetOutputDataRate+0xb2>

    case LPS22DF_25Hz:
      *Odr = 25.0f;
 8009c9e:	683b      	ldr	r3, [r7, #0]
 8009ca0:	4a0e      	ldr	r2, [pc, #56]	@ (8009cdc <LPS22DF_GetOutputDataRate+0xc0>)
 8009ca2:	601a      	str	r2, [r3, #0]
      break;
 8009ca4:	e013      	b.n	8009cce <LPS22DF_GetOutputDataRate+0xb2>

    case LPS22DF_50Hz:
      *Odr = 50.0f;
 8009ca6:	683b      	ldr	r3, [r7, #0]
 8009ca8:	4a0d      	ldr	r2, [pc, #52]	@ (8009ce0 <LPS22DF_GetOutputDataRate+0xc4>)
 8009caa:	601a      	str	r2, [r3, #0]
      break;
 8009cac:	e00f      	b.n	8009cce <LPS22DF_GetOutputDataRate+0xb2>

    case LPS22DF_75Hz:
      *Odr = 75.0f;
 8009cae:	683b      	ldr	r3, [r7, #0]
 8009cb0:	4a0c      	ldr	r2, [pc, #48]	@ (8009ce4 <LPS22DF_GetOutputDataRate+0xc8>)
 8009cb2:	601a      	str	r2, [r3, #0]
      break;
 8009cb4:	e00b      	b.n	8009cce <LPS22DF_GetOutputDataRate+0xb2>

    case LPS22DF_100Hz:
      *Odr = 100.0f;
 8009cb6:	683b      	ldr	r3, [r7, #0]
 8009cb8:	4a0b      	ldr	r2, [pc, #44]	@ (8009ce8 <LPS22DF_GetOutputDataRate+0xcc>)
 8009cba:	601a      	str	r2, [r3, #0]
      break;
 8009cbc:	e007      	b.n	8009cce <LPS22DF_GetOutputDataRate+0xb2>

    case LPS22DF_200Hz:
      *Odr = 200.0f;
 8009cbe:	683b      	ldr	r3, [r7, #0]
 8009cc0:	4a0a      	ldr	r2, [pc, #40]	@ (8009cec <LPS22DF_GetOutputDataRate+0xd0>)
 8009cc2:	601a      	str	r2, [r3, #0]
      break;
 8009cc4:	e003      	b.n	8009cce <LPS22DF_GetOutputDataRate+0xb2>

    default:
      ret = LPS22DF_ERROR;
 8009cc6:	f04f 33ff 	mov.w	r3, #4294967295
 8009cca:	60fb      	str	r3, [r7, #12]
      break;
 8009ccc:	bf00      	nop
  }

  return ret;
 8009cce:	68fb      	ldr	r3, [r7, #12]
}
 8009cd0:	4618      	mov	r0, r3
 8009cd2:	3710      	adds	r7, #16
 8009cd4:	46bd      	mov	sp, r7
 8009cd6:	bd80      	pop	{r7, pc}
 8009cd8:	41200000 	.word	0x41200000
 8009cdc:	41c80000 	.word	0x41c80000
 8009ce0:	42480000 	.word	0x42480000
 8009ce4:	42960000 	.word	0x42960000
 8009ce8:	42c80000 	.word	0x42c80000
 8009cec:	43480000 	.word	0x43480000

08009cf0 <LPS22DF_SetOutputDataRate_When_Enabled>:
  * @param  pObj the device pObj
  * @param  Odr the output data rate value to be set
  * @retval 0 in case of success, an error code otherwise
  */
static int32_t LPS22DF_SetOutputDataRate_When_Enabled(LPS22DF_Object_t *pObj, float Odr)
{
 8009cf0:	b580      	push	{r7, lr}
 8009cf2:	b084      	sub	sp, #16
 8009cf4:	af00      	add	r7, sp, #0
 8009cf6:	6078      	str	r0, [r7, #4]
 8009cf8:	6039      	str	r1, [r7, #0]
  lps22df_md_t new_val;

  if (lps22df_mode_get(&(pObj->Ctx), &new_val) != LPS22DF_OK)
 8009cfa:	687b      	ldr	r3, [r7, #4]
 8009cfc:	3320      	adds	r3, #32
 8009cfe:	f107 020c 	add.w	r2, r7, #12
 8009d02:	4611      	mov	r1, r2
 8009d04:	4618      	mov	r0, r3
 8009d06:	f000 fb39 	bl	800a37c <lps22df_mode_get>
 8009d0a:	4603      	mov	r3, r0
 8009d0c:	2b00      	cmp	r3, #0
 8009d0e:	d002      	beq.n	8009d16 <LPS22DF_SetOutputDataRate_When_Enabled+0x26>
  {
    return LPS22DF_ERROR;
 8009d10:	f04f 33ff 	mov.w	r3, #4294967295
 8009d14:	e06c      	b.n	8009df0 <LPS22DF_SetOutputDataRate_When_Enabled+0x100>
  }

  new_val.odr = (Odr <=   1.0f) ? LPS22DF_1Hz
                : (Odr <=   4.0f) ? LPS22DF_4Hz
 8009d16:	edd7 7a00 	vldr	s15, [r7]
 8009d1a:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 8009d1e:	eef4 7ac7 	vcmpe.f32	s15, s14
 8009d22:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009d26:	d801      	bhi.n	8009d2c <LPS22DF_SetOutputDataRate_When_Enabled+0x3c>
 8009d28:	2301      	movs	r3, #1
 8009d2a:	e042      	b.n	8009db2 <LPS22DF_SetOutputDataRate_When_Enabled+0xc2>
 8009d2c:	edd7 7a00 	vldr	s15, [r7]
 8009d30:	eeb1 7a00 	vmov.f32	s14, #16	@ 0x40800000  4.0
 8009d34:	eef4 7ac7 	vcmpe.f32	s15, s14
 8009d38:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009d3c:	d801      	bhi.n	8009d42 <LPS22DF_SetOutputDataRate_When_Enabled+0x52>
 8009d3e:	2302      	movs	r3, #2
 8009d40:	e037      	b.n	8009db2 <LPS22DF_SetOutputDataRate_When_Enabled+0xc2>
 8009d42:	edd7 7a00 	vldr	s15, [r7]
 8009d46:	eeb2 7a04 	vmov.f32	s14, #36	@ 0x41200000  10.0
 8009d4a:	eef4 7ac7 	vcmpe.f32	s15, s14
 8009d4e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009d52:	d801      	bhi.n	8009d58 <LPS22DF_SetOutputDataRate_When_Enabled+0x68>
 8009d54:	2303      	movs	r3, #3
 8009d56:	e02c      	b.n	8009db2 <LPS22DF_SetOutputDataRate_When_Enabled+0xc2>
 8009d58:	edd7 7a00 	vldr	s15, [r7]
 8009d5c:	eeb3 7a09 	vmov.f32	s14, #57	@ 0x41c80000  25.0
 8009d60:	eef4 7ac7 	vcmpe.f32	s15, s14
 8009d64:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009d68:	d801      	bhi.n	8009d6e <LPS22DF_SetOutputDataRate_When_Enabled+0x7e>
 8009d6a:	2304      	movs	r3, #4
 8009d6c:	e021      	b.n	8009db2 <LPS22DF_SetOutputDataRate_When_Enabled+0xc2>
 8009d6e:	edd7 7a00 	vldr	s15, [r7]
 8009d72:	ed9f 7a21 	vldr	s14, [pc, #132]	@ 8009df8 <LPS22DF_SetOutputDataRate_When_Enabled+0x108>
 8009d76:	eef4 7ac7 	vcmpe.f32	s15, s14
 8009d7a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009d7e:	d801      	bhi.n	8009d84 <LPS22DF_SetOutputDataRate_When_Enabled+0x94>
 8009d80:	2305      	movs	r3, #5
 8009d82:	e016      	b.n	8009db2 <LPS22DF_SetOutputDataRate_When_Enabled+0xc2>
 8009d84:	edd7 7a00 	vldr	s15, [r7]
 8009d88:	ed9f 7a1c 	vldr	s14, [pc, #112]	@ 8009dfc <LPS22DF_SetOutputDataRate_When_Enabled+0x10c>
 8009d8c:	eef4 7ac7 	vcmpe.f32	s15, s14
 8009d90:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009d94:	d801      	bhi.n	8009d9a <LPS22DF_SetOutputDataRate_When_Enabled+0xaa>
 8009d96:	2306      	movs	r3, #6
 8009d98:	e00b      	b.n	8009db2 <LPS22DF_SetOutputDataRate_When_Enabled+0xc2>
 8009d9a:	edd7 7a00 	vldr	s15, [r7]
 8009d9e:	ed9f 7a18 	vldr	s14, [pc, #96]	@ 8009e00 <LPS22DF_SetOutputDataRate_When_Enabled+0x110>
 8009da2:	eef4 7ac7 	vcmpe.f32	s15, s14
 8009da6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009daa:	d801      	bhi.n	8009db0 <LPS22DF_SetOutputDataRate_When_Enabled+0xc0>
 8009dac:	2307      	movs	r3, #7
 8009dae:	e000      	b.n	8009db2 <LPS22DF_SetOutputDataRate_When_Enabled+0xc2>
 8009db0:	2308      	movs	r3, #8
  new_val.odr = (Odr <=   1.0f) ? LPS22DF_1Hz
 8009db2:	733b      	strb	r3, [r7, #12]
                : (Odr <=  50.0f) ? LPS22DF_50Hz
                : (Odr <=  75.0f) ? LPS22DF_75Hz
                : (Odr <= 100.0f) ? LPS22DF_100Hz
                :                   LPS22DF_200Hz;

  if (lps22df_mode_set(&(pObj->Ctx), &new_val) != LPS22DF_OK)
 8009db4:	687b      	ldr	r3, [r7, #4]
 8009db6:	3320      	adds	r3, #32
 8009db8:	f107 020c 	add.w	r2, r7, #12
 8009dbc:	4611      	mov	r1, r2
 8009dbe:	4618      	mov	r0, r3
 8009dc0:	f000 fa7e 	bl	800a2c0 <lps22df_mode_set>
 8009dc4:	4603      	mov	r3, r0
 8009dc6:	2b00      	cmp	r3, #0
 8009dc8:	d002      	beq.n	8009dd0 <LPS22DF_SetOutputDataRate_When_Enabled+0xe0>
  {
    return LPS22DF_ERROR;
 8009dca:	f04f 33ff 	mov.w	r3, #4294967295
 8009dce:	e00f      	b.n	8009df0 <LPS22DF_SetOutputDataRate_When_Enabled+0x100>
  }

  if (lps22df_mode_get(&(pObj->Ctx), &pObj->last_odr) != LPS22DF_OK)
 8009dd0:	687b      	ldr	r3, [r7, #4]
 8009dd2:	f103 0220 	add.w	r2, r3, #32
 8009dd6:	687b      	ldr	r3, [r7, #4]
 8009dd8:	3333      	adds	r3, #51	@ 0x33
 8009dda:	4619      	mov	r1, r3
 8009ddc:	4610      	mov	r0, r2
 8009dde:	f000 facd 	bl	800a37c <lps22df_mode_get>
 8009de2:	4603      	mov	r3, r0
 8009de4:	2b00      	cmp	r3, #0
 8009de6:	d002      	beq.n	8009dee <LPS22DF_SetOutputDataRate_When_Enabled+0xfe>
  {
    return LPS22DF_ERROR;
 8009de8:	f04f 33ff 	mov.w	r3, #4294967295
 8009dec:	e000      	b.n	8009df0 <LPS22DF_SetOutputDataRate_When_Enabled+0x100>
  }

  return LPS22DF_OK;
 8009dee:	2300      	movs	r3, #0
}
 8009df0:	4618      	mov	r0, r3
 8009df2:	3710      	adds	r7, #16
 8009df4:	46bd      	mov	sp, r7
 8009df6:	bd80      	pop	{r7, pc}
 8009df8:	42480000 	.word	0x42480000
 8009dfc:	42960000 	.word	0x42960000
 8009e00:	42c80000 	.word	0x42c80000

08009e04 <LPS22DF_SetOutputDataRate_When_Disabled>:
  * @param  pObj the device pObj
  * @param  Odr the output data rate value to be set
  * @retval 0 in case of success, an error code otherwise
  */
static int32_t LPS22DF_SetOutputDataRate_When_Disabled(LPS22DF_Object_t *pObj, float Odr)
{
 8009e04:	b480      	push	{r7}
 8009e06:	b083      	sub	sp, #12
 8009e08:	af00      	add	r7, sp, #0
 8009e0a:	6078      	str	r0, [r7, #4]
 8009e0c:	6039      	str	r1, [r7, #0]
  pObj->last_odr.odr = (Odr <=   1.0f) ? LPS22DF_1Hz
                       : (Odr <=   4.0f) ? LPS22DF_4Hz
 8009e0e:	edd7 7a00 	vldr	s15, [r7]
 8009e12:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 8009e16:	eef4 7ac7 	vcmpe.f32	s15, s14
 8009e1a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009e1e:	d801      	bhi.n	8009e24 <LPS22DF_SetOutputDataRate_When_Disabled+0x20>
 8009e20:	2301      	movs	r3, #1
 8009e22:	e042      	b.n	8009eaa <LPS22DF_SetOutputDataRate_When_Disabled+0xa6>
 8009e24:	edd7 7a00 	vldr	s15, [r7]
 8009e28:	eeb1 7a00 	vmov.f32	s14, #16	@ 0x40800000  4.0
 8009e2c:	eef4 7ac7 	vcmpe.f32	s15, s14
 8009e30:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009e34:	d801      	bhi.n	8009e3a <LPS22DF_SetOutputDataRate_When_Disabled+0x36>
 8009e36:	2302      	movs	r3, #2
 8009e38:	e037      	b.n	8009eaa <LPS22DF_SetOutputDataRate_When_Disabled+0xa6>
 8009e3a:	edd7 7a00 	vldr	s15, [r7]
 8009e3e:	eeb2 7a04 	vmov.f32	s14, #36	@ 0x41200000  10.0
 8009e42:	eef4 7ac7 	vcmpe.f32	s15, s14
 8009e46:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009e4a:	d801      	bhi.n	8009e50 <LPS22DF_SetOutputDataRate_When_Disabled+0x4c>
 8009e4c:	2303      	movs	r3, #3
 8009e4e:	e02c      	b.n	8009eaa <LPS22DF_SetOutputDataRate_When_Disabled+0xa6>
 8009e50:	edd7 7a00 	vldr	s15, [r7]
 8009e54:	eeb3 7a09 	vmov.f32	s14, #57	@ 0x41c80000  25.0
 8009e58:	eef4 7ac7 	vcmpe.f32	s15, s14
 8009e5c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009e60:	d801      	bhi.n	8009e66 <LPS22DF_SetOutputDataRate_When_Disabled+0x62>
 8009e62:	2304      	movs	r3, #4
 8009e64:	e021      	b.n	8009eaa <LPS22DF_SetOutputDataRate_When_Disabled+0xa6>
 8009e66:	edd7 7a00 	vldr	s15, [r7]
 8009e6a:	ed9f 7a15 	vldr	s14, [pc, #84]	@ 8009ec0 <LPS22DF_SetOutputDataRate_When_Disabled+0xbc>
 8009e6e:	eef4 7ac7 	vcmpe.f32	s15, s14
 8009e72:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009e76:	d801      	bhi.n	8009e7c <LPS22DF_SetOutputDataRate_When_Disabled+0x78>
 8009e78:	2305      	movs	r3, #5
 8009e7a:	e016      	b.n	8009eaa <LPS22DF_SetOutputDataRate_When_Disabled+0xa6>
 8009e7c:	edd7 7a00 	vldr	s15, [r7]
 8009e80:	ed9f 7a10 	vldr	s14, [pc, #64]	@ 8009ec4 <LPS22DF_SetOutputDataRate_When_Disabled+0xc0>
 8009e84:	eef4 7ac7 	vcmpe.f32	s15, s14
 8009e88:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009e8c:	d801      	bhi.n	8009e92 <LPS22DF_SetOutputDataRate_When_Disabled+0x8e>
 8009e8e:	2306      	movs	r3, #6
 8009e90:	e00b      	b.n	8009eaa <LPS22DF_SetOutputDataRate_When_Disabled+0xa6>
 8009e92:	edd7 7a00 	vldr	s15, [r7]
 8009e96:	ed9f 7a0c 	vldr	s14, [pc, #48]	@ 8009ec8 <LPS22DF_SetOutputDataRate_When_Disabled+0xc4>
 8009e9a:	eef4 7ac7 	vcmpe.f32	s15, s14
 8009e9e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009ea2:	d801      	bhi.n	8009ea8 <LPS22DF_SetOutputDataRate_When_Disabled+0xa4>
 8009ea4:	2307      	movs	r3, #7
 8009ea6:	e000      	b.n	8009eaa <LPS22DF_SetOutputDataRate_When_Disabled+0xa6>
 8009ea8:	2308      	movs	r3, #8
  pObj->last_odr.odr = (Odr <=   1.0f) ? LPS22DF_1Hz
 8009eaa:	687a      	ldr	r2, [r7, #4]
 8009eac:	f882 3033 	strb.w	r3, [r2, #51]	@ 0x33
                       : (Odr <=  50.0f) ? LPS22DF_50Hz
                       : (Odr <=  75.0f) ? LPS22DF_75Hz
                       : (Odr <= 100.0f) ? LPS22DF_100Hz
                       :                   LPS22DF_200Hz;

  return LPS22DF_OK;
 8009eb0:	2300      	movs	r3, #0
}
 8009eb2:	4618      	mov	r0, r3
 8009eb4:	370c      	adds	r7, #12
 8009eb6:	46bd      	mov	sp, r7
 8009eb8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009ebc:	4770      	bx	lr
 8009ebe:	bf00      	nop
 8009ec0:	42480000 	.word	0x42480000
 8009ec4:	42960000 	.word	0x42960000
 8009ec8:	42c80000 	.word	0x42c80000

08009ecc <LPS22DF_Initialize>:
  * @brief  Initialize the LPS22DF sensor
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
static int32_t LPS22DF_Initialize(LPS22DF_Object_t *pObj)
{
 8009ecc:	b580      	push	{r7, lr}
 8009ece:	b084      	sub	sp, #16
 8009ed0:	af00      	add	r7, sp, #0
 8009ed2:	6078      	str	r0, [r7, #4]
  lps22df_md_t md;
  lps22df_bus_mode_t bus_mode;

  /* Set bdu and if_inc recommended for driver usage */
  if (lps22df_init_set(&(pObj->Ctx), LPS22DF_DRV_RDY) != LPS22DF_OK)
 8009ed4:	687b      	ldr	r3, [r7, #4]
 8009ed6:	3320      	adds	r3, #32
 8009ed8:	2100      	movs	r1, #0
 8009eda:	4618      	mov	r0, r3
 8009edc:	f000 f977 	bl	800a1ce <lps22df_init_set>
 8009ee0:	4603      	mov	r3, r0
 8009ee2:	2b00      	cmp	r3, #0
 8009ee4:	d002      	beq.n	8009eec <LPS22DF_Initialize+0x20>
  {
    return LPS22DF_ERROR;
 8009ee6:	f04f 33ff 	mov.w	r3, #4294967295
 8009eea:	e047      	b.n	8009f7c <LPS22DF_Initialize+0xb0>
  }

  /* Select bus interface */
  if (pObj->IO.BusType == LPS22DF_SPI_3WIRES_BUS) /* SPI 3-Wires */
 8009eec:	687b      	ldr	r3, [r7, #4]
 8009eee:	689b      	ldr	r3, [r3, #8]
 8009ef0:	2b02      	cmp	r3, #2
 8009ef2:	d102      	bne.n	8009efa <LPS22DF_Initialize+0x2e>
  {
    bus_mode.interface = LPS22DF_SPI_3W;
 8009ef4:	2303      	movs	r3, #3
 8009ef6:	723b      	strb	r3, [r7, #8]
 8009ef8:	e008      	b.n	8009f0c <LPS22DF_Initialize+0x40>
  }
  else if (pObj->IO.BusType == LPS22DF_SPI_4WIRES_BUS) /* SPI 4-Wires */
 8009efa:	687b      	ldr	r3, [r7, #4]
 8009efc:	689b      	ldr	r3, [r3, #8]
 8009efe:	2b01      	cmp	r3, #1
 8009f00:	d102      	bne.n	8009f08 <LPS22DF_Initialize+0x3c>
  {
    bus_mode.interface = LPS22DF_SPI_4W;
 8009f02:	2302      	movs	r3, #2
 8009f04:	723b      	strb	r3, [r7, #8]
 8009f06:	e001      	b.n	8009f0c <LPS22DF_Initialize+0x40>
  }
  else
  {
    bus_mode.interface = LPS22DF_SEL_BY_HW;
 8009f08:	2300      	movs	r3, #0
 8009f0a:	723b      	strb	r3, [r7, #8]
  }

  bus_mode.filter = LPS22DF_AUTO;
 8009f0c:	2300      	movs	r3, #0
 8009f0e:	727b      	strb	r3, [r7, #9]
  if (lps22df_bus_mode_set(&(pObj->Ctx), &bus_mode) != LPS22DF_OK)
 8009f10:	687b      	ldr	r3, [r7, #4]
 8009f12:	3320      	adds	r3, #32
 8009f14:	f107 0208 	add.w	r2, r7, #8
 8009f18:	4611      	mov	r1, r2
 8009f1a:	4618      	mov	r0, r3
 8009f1c:	f000 f8f5 	bl	800a10a <lps22df_bus_mode_set>
 8009f20:	4603      	mov	r3, r0
 8009f22:	2b00      	cmp	r3, #0
 8009f24:	d002      	beq.n	8009f2c <LPS22DF_Initialize+0x60>
  {
    return LPS22DF_ERROR;
 8009f26:	f04f 33ff 	mov.w	r3, #4294967295
 8009f2a:	e027      	b.n	8009f7c <LPS22DF_Initialize+0xb0>
  }

  /* Set Output Data Rate in Power Down */
  md.odr = LPS22DF_ONE_SHOT;
 8009f2c:	2300      	movs	r3, #0
 8009f2e:	733b      	strb	r3, [r7, #12]
  md.avg = LPS22DF_4_AVG;
 8009f30:	2300      	movs	r3, #0
 8009f32:	737b      	strb	r3, [r7, #13]
  md.lpf = LPS22DF_LPF_ODR_DIV_4;
 8009f34:	2301      	movs	r3, #1
 8009f36:	73bb      	strb	r3, [r7, #14]

  /* Power down the device */
  if (lps22df_mode_set(&(pObj->Ctx), &md) != LPS22DF_OK)
 8009f38:	687b      	ldr	r3, [r7, #4]
 8009f3a:	3320      	adds	r3, #32
 8009f3c:	f107 020c 	add.w	r2, r7, #12
 8009f40:	4611      	mov	r1, r2
 8009f42:	4618      	mov	r0, r3
 8009f44:	f000 f9bc 	bl	800a2c0 <lps22df_mode_set>
 8009f48:	4603      	mov	r3, r0
 8009f4a:	2b00      	cmp	r3, #0
 8009f4c:	d002      	beq.n	8009f54 <LPS22DF_Initialize+0x88>
  {
    return LPS22DF_ERROR;
 8009f4e:	f04f 33ff 	mov.w	r3, #4294967295
 8009f52:	e013      	b.n	8009f7c <LPS22DF_Initialize+0xb0>
  }

  if (lps22df_mode_get(&(pObj->Ctx), &pObj->last_odr) != LPS22DF_OK)
 8009f54:	687b      	ldr	r3, [r7, #4]
 8009f56:	f103 0220 	add.w	r2, r3, #32
 8009f5a:	687b      	ldr	r3, [r7, #4]
 8009f5c:	3333      	adds	r3, #51	@ 0x33
 8009f5e:	4619      	mov	r1, r3
 8009f60:	4610      	mov	r0, r2
 8009f62:	f000 fa0b 	bl	800a37c <lps22df_mode_get>
 8009f66:	4603      	mov	r3, r0
 8009f68:	2b00      	cmp	r3, #0
 8009f6a:	d002      	beq.n	8009f72 <LPS22DF_Initialize+0xa6>
  {
    return LPS22DF_ERROR;
 8009f6c:	f04f 33ff 	mov.w	r3, #4294967295
 8009f70:	e004      	b.n	8009f7c <LPS22DF_Initialize+0xb0>
  }

  pObj->last_odr.odr = LPS22DF_25Hz;
 8009f72:	687b      	ldr	r3, [r7, #4]
 8009f74:	2204      	movs	r2, #4
 8009f76:	f883 2033 	strb.w	r2, [r3, #51]	@ 0x33

  return LPS22DF_OK;
 8009f7a:	2300      	movs	r3, #0
}
 8009f7c:	4618      	mov	r0, r3
 8009f7e:	3710      	adds	r7, #16
 8009f80:	46bd      	mov	sp, r7
 8009f82:	bd80      	pop	{r7, pc}

08009f84 <ReadRegWrap>:
  * @param  pData the stored data pointer
  * @param  Length the length
  * @retval 0 in case of success, an error code otherwise
  */
static int32_t ReadRegWrap(void *Handle, uint8_t Reg, uint8_t *pData, uint16_t Length)
{
 8009f84:	b590      	push	{r4, r7, lr}
 8009f86:	b087      	sub	sp, #28
 8009f88:	af00      	add	r7, sp, #0
 8009f8a:	60f8      	str	r0, [r7, #12]
 8009f8c:	607a      	str	r2, [r7, #4]
 8009f8e:	461a      	mov	r2, r3
 8009f90:	460b      	mov	r3, r1
 8009f92:	72fb      	strb	r3, [r7, #11]
 8009f94:	4613      	mov	r3, r2
 8009f96:	813b      	strh	r3, [r7, #8]
  LPS22DF_Object_t *pObj = (LPS22DF_Object_t *)Handle;
 8009f98:	68fb      	ldr	r3, [r7, #12]
 8009f9a:	617b      	str	r3, [r7, #20]

  return pObj->IO.ReadReg(pObj->IO.Address, Reg, pData, Length);
 8009f9c:	697b      	ldr	r3, [r7, #20]
 8009f9e:	695c      	ldr	r4, [r3, #20]
 8009fa0:	697b      	ldr	r3, [r7, #20]
 8009fa2:	7b1b      	ldrb	r3, [r3, #12]
 8009fa4:	4618      	mov	r0, r3
 8009fa6:	7afb      	ldrb	r3, [r7, #11]
 8009fa8:	b299      	uxth	r1, r3
 8009faa:	893b      	ldrh	r3, [r7, #8]
 8009fac:	687a      	ldr	r2, [r7, #4]
 8009fae:	47a0      	blx	r4
 8009fb0:	4603      	mov	r3, r0
}
 8009fb2:	4618      	mov	r0, r3
 8009fb4:	371c      	adds	r7, #28
 8009fb6:	46bd      	mov	sp, r7
 8009fb8:	bd90      	pop	{r4, r7, pc}

08009fba <WriteRegWrap>:
  * @param  pData the stored data pointer
  * @param  Length the length
  * @retval 0 in case of success, an error code otherwise
  */
static int32_t WriteRegWrap(void *Handle, uint8_t Reg, uint8_t *pData, uint16_t Length)
{
 8009fba:	b590      	push	{r4, r7, lr}
 8009fbc:	b087      	sub	sp, #28
 8009fbe:	af00      	add	r7, sp, #0
 8009fc0:	60f8      	str	r0, [r7, #12]
 8009fc2:	607a      	str	r2, [r7, #4]
 8009fc4:	461a      	mov	r2, r3
 8009fc6:	460b      	mov	r3, r1
 8009fc8:	72fb      	strb	r3, [r7, #11]
 8009fca:	4613      	mov	r3, r2
 8009fcc:	813b      	strh	r3, [r7, #8]
  LPS22DF_Object_t *pObj = (LPS22DF_Object_t *)Handle;
 8009fce:	68fb      	ldr	r3, [r7, #12]
 8009fd0:	617b      	str	r3, [r7, #20]

  return pObj->IO.WriteReg(pObj->IO.Address, Reg, pData, Length);
 8009fd2:	697b      	ldr	r3, [r7, #20]
 8009fd4:	691c      	ldr	r4, [r3, #16]
 8009fd6:	697b      	ldr	r3, [r7, #20]
 8009fd8:	7b1b      	ldrb	r3, [r3, #12]
 8009fda:	4618      	mov	r0, r3
 8009fdc:	7afb      	ldrb	r3, [r7, #11]
 8009fde:	b299      	uxth	r1, r3
 8009fe0:	893b      	ldrh	r3, [r7, #8]
 8009fe2:	687a      	ldr	r2, [r7, #4]
 8009fe4:	47a0      	blx	r4
 8009fe6:	4603      	mov	r3, r0
}
 8009fe8:	4618      	mov	r0, r3
 8009fea:	371c      	adds	r7, #28
 8009fec:	46bd      	mov	sp, r7
 8009fee:	bd90      	pop	{r4, r7, pc}

08009ff0 <lps22df_read_reg>:
  * @retval       interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lps22df_read_reg(stmdev_ctx_t *ctx, uint8_t reg, uint8_t *data,
                         uint16_t len)
{
 8009ff0:	b590      	push	{r4, r7, lr}
 8009ff2:	b087      	sub	sp, #28
 8009ff4:	af00      	add	r7, sp, #0
 8009ff6:	60f8      	str	r0, [r7, #12]
 8009ff8:	607a      	str	r2, [r7, #4]
 8009ffa:	461a      	mov	r2, r3
 8009ffc:	460b      	mov	r3, r1
 8009ffe:	72fb      	strb	r3, [r7, #11]
 800a000:	4613      	mov	r3, r2
 800a002:	813b      	strh	r3, [r7, #8]
  int32_t ret;

  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800a004:	68fb      	ldr	r3, [r7, #12]
 800a006:	685c      	ldr	r4, [r3, #4]
 800a008:	68fb      	ldr	r3, [r7, #12]
 800a00a:	68d8      	ldr	r0, [r3, #12]
 800a00c:	893b      	ldrh	r3, [r7, #8]
 800a00e:	7af9      	ldrb	r1, [r7, #11]
 800a010:	687a      	ldr	r2, [r7, #4]
 800a012:	47a0      	blx	r4
 800a014:	6178      	str	r0, [r7, #20]
  return ret;
 800a016:	697b      	ldr	r3, [r7, #20]
}
 800a018:	4618      	mov	r0, r3
 800a01a:	371c      	adds	r7, #28
 800a01c:	46bd      	mov	sp, r7
 800a01e:	bd90      	pop	{r4, r7, pc}

0800a020 <lps22df_write_reg>:
  * @retval       interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lps22df_write_reg(stmdev_ctx_t *ctx, uint8_t reg, uint8_t *data,
                          uint16_t len)
{
 800a020:	b590      	push	{r4, r7, lr}
 800a022:	b087      	sub	sp, #28
 800a024:	af00      	add	r7, sp, #0
 800a026:	60f8      	str	r0, [r7, #12]
 800a028:	607a      	str	r2, [r7, #4]
 800a02a:	461a      	mov	r2, r3
 800a02c:	460b      	mov	r3, r1
 800a02e:	72fb      	strb	r3, [r7, #11]
 800a030:	4613      	mov	r3, r2
 800a032:	813b      	strh	r3, [r7, #8]
  int32_t ret;

  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800a034:	68fb      	ldr	r3, [r7, #12]
 800a036:	681c      	ldr	r4, [r3, #0]
 800a038:	68fb      	ldr	r3, [r7, #12]
 800a03a:	68d8      	ldr	r0, [r3, #12]
 800a03c:	893b      	ldrh	r3, [r7, #8]
 800a03e:	7af9      	ldrb	r1, [r7, #11]
 800a040:	687a      	ldr	r2, [r7, #4]
 800a042:	47a0      	blx	r4
 800a044:	6178      	str	r0, [r7, #20]
  return ret;
 800a046:	697b      	ldr	r3, [r7, #20]
}
 800a048:	4618      	mov	r0, r3
 800a04a:	371c      	adds	r7, #28
 800a04c:	46bd      	mov	sp, r7
 800a04e:	bd90      	pop	{r4, r7, pc}

0800a050 <bytecpy>:
  * @{
  *
  */

static void bytecpy(uint8_t *target, uint8_t *source)
{
 800a050:	b480      	push	{r7}
 800a052:	b083      	sub	sp, #12
 800a054:	af00      	add	r7, sp, #0
 800a056:	6078      	str	r0, [r7, #4]
 800a058:	6039      	str	r1, [r7, #0]
  if ((target != NULL) && (source != NULL))
 800a05a:	687b      	ldr	r3, [r7, #4]
 800a05c:	2b00      	cmp	r3, #0
 800a05e:	d006      	beq.n	800a06e <bytecpy+0x1e>
 800a060:	683b      	ldr	r3, [r7, #0]
 800a062:	2b00      	cmp	r3, #0
 800a064:	d003      	beq.n	800a06e <bytecpy+0x1e>
  {
    *target = *source;
 800a066:	683b      	ldr	r3, [r7, #0]
 800a068:	781a      	ldrb	r2, [r3, #0]
 800a06a:	687b      	ldr	r3, [r7, #4]
 800a06c:	701a      	strb	r2, [r3, #0]
  }
}
 800a06e:	bf00      	nop
 800a070:	370c      	adds	r7, #12
 800a072:	46bd      	mov	sp, r7
 800a074:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a078:	4770      	bx	lr
	...

0800a07c <lps22df_from_lsb_to_hPa>:
  * @{
  *
  */

float_t lps22df_from_lsb_to_hPa(int32_t lsb)
{
 800a07c:	b480      	push	{r7}
 800a07e:	b083      	sub	sp, #12
 800a080:	af00      	add	r7, sp, #0
 800a082:	6078      	str	r0, [r7, #4]
  return ((float_t)lsb / 1048576.0f);   /* 4096.0f * 256 */
 800a084:	687b      	ldr	r3, [r7, #4]
 800a086:	ee07 3a90 	vmov	s15, r3
 800a08a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800a08e:	ed9f 7a06 	vldr	s14, [pc, #24]	@ 800a0a8 <lps22df_from_lsb_to_hPa+0x2c>
 800a092:	eec7 6a87 	vdiv.f32	s13, s15, s14
 800a096:	ee16 3a90 	vmov	r3, s13
}
 800a09a:	4618      	mov	r0, r3
 800a09c:	370c      	adds	r7, #12
 800a09e:	46bd      	mov	sp, r7
 800a0a0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a0a4:	4770      	bx	lr
 800a0a6:	bf00      	nop
 800a0a8:	49800000 	.word	0x49800000

0800a0ac <lps22df_from_lsb_to_celsius>:

float_t lps22df_from_lsb_to_celsius(int16_t lsb)
{
 800a0ac:	b480      	push	{r7}
 800a0ae:	b083      	sub	sp, #12
 800a0b0:	af00      	add	r7, sp, #0
 800a0b2:	4603      	mov	r3, r0
 800a0b4:	80fb      	strh	r3, [r7, #6]
  return ((float_t)lsb / 100.0f);
 800a0b6:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 800a0ba:	ee07 3a90 	vmov	s15, r3
 800a0be:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800a0c2:	ed9f 7a06 	vldr	s14, [pc, #24]	@ 800a0dc <lps22df_from_lsb_to_celsius+0x30>
 800a0c6:	eec7 6a87 	vdiv.f32	s13, s15, s14
 800a0ca:	ee16 3a90 	vmov	r3, s13
}
 800a0ce:	4618      	mov	r0, r3
 800a0d0:	370c      	adds	r7, #12
 800a0d2:	46bd      	mov	sp, r7
 800a0d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a0d8:	4770      	bx	lr
 800a0da:	bf00      	nop
 800a0dc:	42c80000 	.word	0x42c80000

0800a0e0 <lps22df_id_get>:
  * @param  val   ID values.(ptr)
  * @retval       interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lps22df_id_get(stmdev_ctx_t *ctx, lps22df_id_t *val)
{
 800a0e0:	b580      	push	{r7, lr}
 800a0e2:	b084      	sub	sp, #16
 800a0e4:	af00      	add	r7, sp, #0
 800a0e6:	6078      	str	r0, [r7, #4]
 800a0e8:	6039      	str	r1, [r7, #0]
  uint8_t reg;
  int32_t ret;

  ret = lps22df_read_reg(ctx, LPS22DF_WHO_AM_I, &reg, 1);
 800a0ea:	f107 020b 	add.w	r2, r7, #11
 800a0ee:	2301      	movs	r3, #1
 800a0f0:	210f      	movs	r1, #15
 800a0f2:	6878      	ldr	r0, [r7, #4]
 800a0f4:	f7ff ff7c 	bl	8009ff0 <lps22df_read_reg>
 800a0f8:	60f8      	str	r0, [r7, #12]
  val->whoami = reg;
 800a0fa:	7afa      	ldrb	r2, [r7, #11]
 800a0fc:	683b      	ldr	r3, [r7, #0]
 800a0fe:	701a      	strb	r2, [r3, #0]

  return ret;
 800a100:	68fb      	ldr	r3, [r7, #12]
}
 800a102:	4618      	mov	r0, r3
 800a104:	3710      	adds	r7, #16
 800a106:	46bd      	mov	sp, r7
 800a108:	bd80      	pop	{r7, pc}

0800a10a <lps22df_bus_mode_set>:
  * @param  val   configures the bus operating mode.(ptr)
  * @retval       interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lps22df_bus_mode_set(stmdev_ctx_t *ctx, lps22df_bus_mode_t *val)
{
 800a10a:	b580      	push	{r7, lr}
 800a10c:	b086      	sub	sp, #24
 800a10e:	af00      	add	r7, sp, #0
 800a110:	6078      	str	r0, [r7, #4]
 800a112:	6039      	str	r1, [r7, #0]
  lps22df_i3c_if_ctrl_add_t i3c_if_ctrl_add;
  lps22df_if_ctrl_t if_ctrl;
  int32_t ret;

  ret = lps22df_read_reg(ctx, LPS22DF_IF_CTRL, (uint8_t *)&if_ctrl, 1);
 800a114:	f107 020c 	add.w	r2, r7, #12
 800a118:	2301      	movs	r3, #1
 800a11a:	210e      	movs	r1, #14
 800a11c:	6878      	ldr	r0, [r7, #4]
 800a11e:	f7ff ff67 	bl	8009ff0 <lps22df_read_reg>
 800a122:	6178      	str	r0, [r7, #20]
  if (ret == 0)
 800a124:	697b      	ldr	r3, [r7, #20]
 800a126:	2b00      	cmp	r3, #0
 800a128:	d124      	bne.n	800a174 <lps22df_bus_mode_set+0x6a>
  {
    if_ctrl.int_en_i3c = ((uint8_t)val->interface & 0x04U) >> 2;
 800a12a:	683b      	ldr	r3, [r7, #0]
 800a12c:	781b      	ldrb	r3, [r3, #0]
 800a12e:	089b      	lsrs	r3, r3, #2
 800a130:	f003 0301 	and.w	r3, r3, #1
 800a134:	b2da      	uxtb	r2, r3
 800a136:	7b3b      	ldrb	r3, [r7, #12]
 800a138:	f362 13c7 	bfi	r3, r2, #7, #1
 800a13c:	733b      	strb	r3, [r7, #12]
    if_ctrl.i2c_i3c_dis = ((uint8_t)val->interface & 0x02U) >> 1;
 800a13e:	683b      	ldr	r3, [r7, #0]
 800a140:	781b      	ldrb	r3, [r3, #0]
 800a142:	085b      	lsrs	r3, r3, #1
 800a144:	f003 0301 	and.w	r3, r3, #1
 800a148:	b2da      	uxtb	r2, r3
 800a14a:	7b3b      	ldrb	r3, [r7, #12]
 800a14c:	f362 1386 	bfi	r3, r2, #6, #1
 800a150:	733b      	strb	r3, [r7, #12]
    if_ctrl.sim = ((uint8_t)val->interface & 0x01U);
 800a152:	683b      	ldr	r3, [r7, #0]
 800a154:	781b      	ldrb	r3, [r3, #0]
 800a156:	f003 0301 	and.w	r3, r3, #1
 800a15a:	b2da      	uxtb	r2, r3
 800a15c:	7b3b      	ldrb	r3, [r7, #12]
 800a15e:	f362 1345 	bfi	r3, r2, #5, #1
 800a162:	733b      	strb	r3, [r7, #12]
    ret = lps22df_write_reg(ctx, LPS22DF_IF_CTRL, (uint8_t *)&if_ctrl, 1);
 800a164:	f107 020c 	add.w	r2, r7, #12
 800a168:	2301      	movs	r3, #1
 800a16a:	210e      	movs	r1, #14
 800a16c:	6878      	ldr	r0, [r7, #4]
 800a16e:	f7ff ff57 	bl	800a020 <lps22df_write_reg>
 800a172:	6178      	str	r0, [r7, #20]
  }
  if (ret == 0)
 800a174:	697b      	ldr	r3, [r7, #20]
 800a176:	2b00      	cmp	r3, #0
 800a178:	d107      	bne.n	800a18a <lps22df_bus_mode_set+0x80>
  {
    ret = lps22df_read_reg(ctx, LPS22DF_I3C_IF_CTRL_ADD,
 800a17a:	f107 0210 	add.w	r2, r7, #16
 800a17e:	2301      	movs	r3, #1
 800a180:	2119      	movs	r1, #25
 800a182:	6878      	ldr	r0, [r7, #4]
 800a184:	f7ff ff34 	bl	8009ff0 <lps22df_read_reg>
 800a188:	6178      	str	r0, [r7, #20]
                           (uint8_t *)&i3c_if_ctrl_add, 1);
  }
  if (ret == 0)
 800a18a:	697b      	ldr	r3, [r7, #20]
 800a18c:	2b00      	cmp	r3, #0
 800a18e:	d119      	bne.n	800a1c4 <lps22df_bus_mode_set+0xba>
  {
    i3c_if_ctrl_add.asf_on = (uint8_t)val->filter & 0x01U;
 800a190:	683b      	ldr	r3, [r7, #0]
 800a192:	785b      	ldrb	r3, [r3, #1]
 800a194:	f003 0301 	and.w	r3, r3, #1
 800a198:	b2da      	uxtb	r2, r3
 800a19a:	7c3b      	ldrb	r3, [r7, #16]
 800a19c:	f362 1345 	bfi	r3, r2, #5, #1
 800a1a0:	743b      	strb	r3, [r7, #16]
    i3c_if_ctrl_add.i3c_bus_avb_sel = (uint8_t)val->i3c_ibi_time & 0x03U;
 800a1a2:	683b      	ldr	r3, [r7, #0]
 800a1a4:	789b      	ldrb	r3, [r3, #2]
 800a1a6:	f003 0303 	and.w	r3, r3, #3
 800a1aa:	b2da      	uxtb	r2, r3
 800a1ac:	7c3b      	ldrb	r3, [r7, #16]
 800a1ae:	f362 0301 	bfi	r3, r2, #0, #2
 800a1b2:	743b      	strb	r3, [r7, #16]
    ret = lps22df_write_reg(ctx, LPS22DF_I3C_IF_CTRL_ADD,
 800a1b4:	f107 0210 	add.w	r2, r7, #16
 800a1b8:	2301      	movs	r3, #1
 800a1ba:	2119      	movs	r1, #25
 800a1bc:	6878      	ldr	r0, [r7, #4]
 800a1be:	f7ff ff2f 	bl	800a020 <lps22df_write_reg>
 800a1c2:	6178      	str	r0, [r7, #20]
                            (uint8_t *)&i3c_if_ctrl_add, 1);
  }
  return ret;
 800a1c4:	697b      	ldr	r3, [r7, #20]
}
 800a1c6:	4618      	mov	r0, r3
 800a1c8:	3718      	adds	r7, #24
 800a1ca:	46bd      	mov	sp, r7
 800a1cc:	bd80      	pop	{r7, pc}

0800a1ce <lps22df_init_set>:
  * @param  val   configures the bus operating mode.(ptr)
  * @retval       interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lps22df_init_set(stmdev_ctx_t *ctx, lps22df_init_t val)
{
 800a1ce:	b580      	push	{r7, lr}
 800a1d0:	b086      	sub	sp, #24
 800a1d2:	af00      	add	r7, sp, #0
 800a1d4:	6078      	str	r0, [r7, #4]
 800a1d6:	460b      	mov	r3, r1
 800a1d8:	70fb      	strb	r3, [r7, #3]
  lps22df_ctrl_reg2_t ctrl_reg2;
  lps22df_ctrl_reg3_t ctrl_reg3;
  uint8_t reg[2];
  int32_t ret;

  ret = lps22df_read_reg(ctx, LPS22DF_CTRL_REG2, reg, 2);
 800a1da:	f107 0208 	add.w	r2, r7, #8
 800a1de:	2302      	movs	r3, #2
 800a1e0:	2111      	movs	r1, #17
 800a1e2:	6878      	ldr	r0, [r7, #4]
 800a1e4:	f7ff ff04 	bl	8009ff0 <lps22df_read_reg>
 800a1e8:	6178      	str	r0, [r7, #20]
  if (ret == 0)
 800a1ea:	697b      	ldr	r3, [r7, #20]
 800a1ec:	2b00      	cmp	r3, #0
 800a1ee:	d162      	bne.n	800a2b6 <lps22df_init_set+0xe8>
  {
    bytecpy((uint8_t *)&ctrl_reg2, &reg[0]);
 800a1f0:	f107 0208 	add.w	r2, r7, #8
 800a1f4:	f107 0310 	add.w	r3, r7, #16
 800a1f8:	4611      	mov	r1, r2
 800a1fa:	4618      	mov	r0, r3
 800a1fc:	f7ff ff28 	bl	800a050 <bytecpy>
    bytecpy((uint8_t *)&ctrl_reg3, &reg[1]);
 800a200:	f107 0308 	add.w	r3, r7, #8
 800a204:	1c5a      	adds	r2, r3, #1
 800a206:	f107 030c 	add.w	r3, r7, #12
 800a20a:	4611      	mov	r1, r2
 800a20c:	4618      	mov	r0, r3
 800a20e:	f7ff ff1f 	bl	800a050 <bytecpy>

    switch (val)
 800a212:	78fb      	ldrb	r3, [r7, #3]
 800a214:	2b02      	cmp	r3, #2
 800a216:	d012      	beq.n	800a23e <lps22df_init_set+0x70>
 800a218:	2b02      	cmp	r3, #2
 800a21a:	dc3f      	bgt.n	800a29c <lps22df_init_set+0xce>
 800a21c:	2b00      	cmp	r3, #0
 800a21e:	d01b      	beq.n	800a258 <lps22df_init_set+0x8a>
 800a220:	2b01      	cmp	r3, #1
 800a222:	d13b      	bne.n	800a29c <lps22df_init_set+0xce>
    {
      case LPS22DF_BOOT:
        ctrl_reg2.boot = PROPERTY_ENABLE;
 800a224:	7c3b      	ldrb	r3, [r7, #16]
 800a226:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 800a22a:	743b      	strb	r3, [r7, #16]
        ret = lps22df_write_reg(ctx, LPS22DF_CTRL_REG2,
 800a22c:	f107 0210 	add.w	r2, r7, #16
 800a230:	2301      	movs	r3, #1
 800a232:	2111      	movs	r1, #17
 800a234:	6878      	ldr	r0, [r7, #4]
 800a236:	f7ff fef3 	bl	800a020 <lps22df_write_reg>
 800a23a:	6178      	str	r0, [r7, #20]
                                (uint8_t *)&ctrl_reg2, 1);
        break;
 800a23c:	e03b      	b.n	800a2b6 <lps22df_init_set+0xe8>
      case LPS22DF_RESET:
        ctrl_reg2.swreset = PROPERTY_ENABLE;
 800a23e:	7c3b      	ldrb	r3, [r7, #16]
 800a240:	f043 0304 	orr.w	r3, r3, #4
 800a244:	743b      	strb	r3, [r7, #16]
        ret = lps22df_write_reg(ctx, LPS22DF_CTRL_REG2,
 800a246:	f107 0210 	add.w	r2, r7, #16
 800a24a:	2301      	movs	r3, #1
 800a24c:	2111      	movs	r1, #17
 800a24e:	6878      	ldr	r0, [r7, #4]
 800a250:	f7ff fee6 	bl	800a020 <lps22df_write_reg>
 800a254:	6178      	str	r0, [r7, #20]
                                (uint8_t *)&ctrl_reg2, 1);
        break;
 800a256:	e02e      	b.n	800a2b6 <lps22df_init_set+0xe8>
      case LPS22DF_DRV_RDY:
        ctrl_reg2.bdu = PROPERTY_ENABLE;
 800a258:	7c3b      	ldrb	r3, [r7, #16]
 800a25a:	f043 0308 	orr.w	r3, r3, #8
 800a25e:	743b      	strb	r3, [r7, #16]
        ctrl_reg3.if_add_inc = PROPERTY_ENABLE;
 800a260:	7b3b      	ldrb	r3, [r7, #12]
 800a262:	f043 0301 	orr.w	r3, r3, #1
 800a266:	733b      	strb	r3, [r7, #12]
        bytecpy(&reg[0], (uint8_t *)&ctrl_reg2);
 800a268:	f107 0210 	add.w	r2, r7, #16
 800a26c:	f107 0308 	add.w	r3, r7, #8
 800a270:	4611      	mov	r1, r2
 800a272:	4618      	mov	r0, r3
 800a274:	f7ff feec 	bl	800a050 <bytecpy>
        bytecpy(&reg[1], (uint8_t *)&ctrl_reg3);
 800a278:	f107 020c 	add.w	r2, r7, #12
 800a27c:	f107 0308 	add.w	r3, r7, #8
 800a280:	3301      	adds	r3, #1
 800a282:	4611      	mov	r1, r2
 800a284:	4618      	mov	r0, r3
 800a286:	f7ff fee3 	bl	800a050 <bytecpy>
        ret = lps22df_write_reg(ctx, LPS22DF_CTRL_REG2, reg, 2);
 800a28a:	f107 0208 	add.w	r2, r7, #8
 800a28e:	2302      	movs	r3, #2
 800a290:	2111      	movs	r1, #17
 800a292:	6878      	ldr	r0, [r7, #4]
 800a294:	f7ff fec4 	bl	800a020 <lps22df_write_reg>
 800a298:	6178      	str	r0, [r7, #20]
        break;
 800a29a:	e00c      	b.n	800a2b6 <lps22df_init_set+0xe8>
      default:
        ctrl_reg2.swreset = PROPERTY_ENABLE;
 800a29c:	7c3b      	ldrb	r3, [r7, #16]
 800a29e:	f043 0304 	orr.w	r3, r3, #4
 800a2a2:	743b      	strb	r3, [r7, #16]
        ret = lps22df_write_reg(ctx, LPS22DF_CTRL_REG2,
 800a2a4:	f107 0210 	add.w	r2, r7, #16
 800a2a8:	2301      	movs	r3, #1
 800a2aa:	2111      	movs	r1, #17
 800a2ac:	6878      	ldr	r0, [r7, #4]
 800a2ae:	f7ff feb7 	bl	800a020 <lps22df_write_reg>
 800a2b2:	6178      	str	r0, [r7, #20]
                                (uint8_t *)&ctrl_reg2, 1);
        break;
 800a2b4:	bf00      	nop
    }
  }
  return ret;
 800a2b6:	697b      	ldr	r3, [r7, #20]
}
 800a2b8:	4618      	mov	r0, r3
 800a2ba:	3718      	adds	r7, #24
 800a2bc:	46bd      	mov	sp, r7
 800a2be:	bd80      	pop	{r7, pc}

0800a2c0 <lps22df_mode_set>:
  * @param  val   set the sensor conversion parameters.(ptr)
  * @retval       interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lps22df_mode_set(stmdev_ctx_t *ctx, lps22df_md_t *val)
{
 800a2c0:	b580      	push	{r7, lr}
 800a2c2:	b086      	sub	sp, #24
 800a2c4:	af00      	add	r7, sp, #0
 800a2c6:	6078      	str	r0, [r7, #4]
 800a2c8:	6039      	str	r1, [r7, #0]
  lps22df_ctrl_reg1_t ctrl_reg1;
  lps22df_ctrl_reg2_t ctrl_reg2;
  uint8_t reg[2];
  int32_t ret;

  ret = lps22df_read_reg(ctx, LPS22DF_CTRL_REG1, reg, 2);
 800a2ca:	f107 0208 	add.w	r2, r7, #8
 800a2ce:	2302      	movs	r3, #2
 800a2d0:	2110      	movs	r1, #16
 800a2d2:	6878      	ldr	r0, [r7, #4]
 800a2d4:	f7ff fe8c 	bl	8009ff0 <lps22df_read_reg>
 800a2d8:	6178      	str	r0, [r7, #20]

  if (ret == 0)
 800a2da:	697b      	ldr	r3, [r7, #20]
 800a2dc:	2b00      	cmp	r3, #0
 800a2de:	d148      	bne.n	800a372 <lps22df_mode_set+0xb2>
  {
    bytecpy((uint8_t *)&ctrl_reg1, &reg[0]);
 800a2e0:	f107 0208 	add.w	r2, r7, #8
 800a2e4:	f107 0310 	add.w	r3, r7, #16
 800a2e8:	4611      	mov	r1, r2
 800a2ea:	4618      	mov	r0, r3
 800a2ec:	f7ff feb0 	bl	800a050 <bytecpy>
    bytecpy((uint8_t *)&ctrl_reg2, &reg[1]);
 800a2f0:	f107 0308 	add.w	r3, r7, #8
 800a2f4:	1c5a      	adds	r2, r3, #1
 800a2f6:	f107 030c 	add.w	r3, r7, #12
 800a2fa:	4611      	mov	r1, r2
 800a2fc:	4618      	mov	r0, r3
 800a2fe:	f7ff fea7 	bl	800a050 <bytecpy>

    ctrl_reg1.odr = (uint8_t)val->odr;
 800a302:	683b      	ldr	r3, [r7, #0]
 800a304:	781b      	ldrb	r3, [r3, #0]
 800a306:	f003 030f 	and.w	r3, r3, #15
 800a30a:	b2da      	uxtb	r2, r3
 800a30c:	7c3b      	ldrb	r3, [r7, #16]
 800a30e:	f362 03c6 	bfi	r3, r2, #3, #4
 800a312:	743b      	strb	r3, [r7, #16]
    ctrl_reg1.avg = (uint8_t)val->avg;
 800a314:	683b      	ldr	r3, [r7, #0]
 800a316:	785b      	ldrb	r3, [r3, #1]
 800a318:	f003 0307 	and.w	r3, r3, #7
 800a31c:	b2da      	uxtb	r2, r3
 800a31e:	7c3b      	ldrb	r3, [r7, #16]
 800a320:	f362 0302 	bfi	r3, r2, #0, #3
 800a324:	743b      	strb	r3, [r7, #16]
    ctrl_reg2.en_lpfp = (uint8_t)val->lpf & 0x01U;
 800a326:	683b      	ldr	r3, [r7, #0]
 800a328:	789b      	ldrb	r3, [r3, #2]
 800a32a:	f003 0301 	and.w	r3, r3, #1
 800a32e:	b2da      	uxtb	r2, r3
 800a330:	7b3b      	ldrb	r3, [r7, #12]
 800a332:	f362 1304 	bfi	r3, r2, #4, #1
 800a336:	733b      	strb	r3, [r7, #12]
    ctrl_reg2.lfpf_cfg = ((uint8_t)val->lpf & 0x02U) >> 2;
 800a338:	7b3b      	ldrb	r3, [r7, #12]
 800a33a:	f023 0320 	bic.w	r3, r3, #32
 800a33e:	733b      	strb	r3, [r7, #12]

    bytecpy(&reg[0], (uint8_t *)&ctrl_reg1);
 800a340:	f107 0210 	add.w	r2, r7, #16
 800a344:	f107 0308 	add.w	r3, r7, #8
 800a348:	4611      	mov	r1, r2
 800a34a:	4618      	mov	r0, r3
 800a34c:	f7ff fe80 	bl	800a050 <bytecpy>
    bytecpy(&reg[1], (uint8_t *)&ctrl_reg2);
 800a350:	f107 020c 	add.w	r2, r7, #12
 800a354:	f107 0308 	add.w	r3, r7, #8
 800a358:	3301      	adds	r3, #1
 800a35a:	4611      	mov	r1, r2
 800a35c:	4618      	mov	r0, r3
 800a35e:	f7ff fe77 	bl	800a050 <bytecpy>
    ret = lps22df_write_reg(ctx, LPS22DF_CTRL_REG1, reg, 2);
 800a362:	f107 0208 	add.w	r2, r7, #8
 800a366:	2302      	movs	r3, #2
 800a368:	2110      	movs	r1, #16
 800a36a:	6878      	ldr	r0, [r7, #4]
 800a36c:	f7ff fe58 	bl	800a020 <lps22df_write_reg>
 800a370:	6178      	str	r0, [r7, #20]
  }

  return ret;
 800a372:	697b      	ldr	r3, [r7, #20]
}
 800a374:	4618      	mov	r0, r3
 800a376:	3718      	adds	r7, #24
 800a378:	46bd      	mov	sp, r7
 800a37a:	bd80      	pop	{r7, pc}

0800a37c <lps22df_mode_get>:
  * @param  val   get the sensor conversion parameters.(ptr)
  * @retval       interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lps22df_mode_get(stmdev_ctx_t *ctx, lps22df_md_t *val)
{
 800a37c:	b580      	push	{r7, lr}
 800a37e:	b086      	sub	sp, #24
 800a380:	af00      	add	r7, sp, #0
 800a382:	6078      	str	r0, [r7, #4]
 800a384:	6039      	str	r1, [r7, #0]
  lps22df_ctrl_reg1_t ctrl_reg1;
  lps22df_ctrl_reg2_t ctrl_reg2;
  uint8_t reg[2];
  int32_t ret;

  ret = lps22df_read_reg(ctx, LPS22DF_CTRL_REG1, reg, 2);
 800a386:	f107 0208 	add.w	r2, r7, #8
 800a38a:	2302      	movs	r3, #2
 800a38c:	2110      	movs	r1, #16
 800a38e:	6878      	ldr	r0, [r7, #4]
 800a390:	f7ff fe2e 	bl	8009ff0 <lps22df_read_reg>
 800a394:	6178      	str	r0, [r7, #20]

  if (ret == 0)
 800a396:	697b      	ldr	r3, [r7, #20]
 800a398:	2b00      	cmp	r3, #0
 800a39a:	f040 80b6 	bne.w	800a50a <lps22df_mode_get+0x18e>
  {
    bytecpy((uint8_t *)&ctrl_reg1, &reg[0]);
 800a39e:	f107 0208 	add.w	r2, r7, #8
 800a3a2:	f107 0310 	add.w	r3, r7, #16
 800a3a6:	4611      	mov	r1, r2
 800a3a8:	4618      	mov	r0, r3
 800a3aa:	f7ff fe51 	bl	800a050 <bytecpy>
    bytecpy((uint8_t *)&ctrl_reg2, &reg[1]);
 800a3ae:	f107 0308 	add.w	r3, r7, #8
 800a3b2:	1c5a      	adds	r2, r3, #1
 800a3b4:	f107 030c 	add.w	r3, r7, #12
 800a3b8:	4611      	mov	r1, r2
 800a3ba:	4618      	mov	r0, r3
 800a3bc:	f7ff fe48 	bl	800a050 <bytecpy>

    switch (ctrl_reg1.odr)
 800a3c0:	7c3b      	ldrb	r3, [r7, #16]
 800a3c2:	f3c3 03c3 	ubfx	r3, r3, #3, #4
 800a3c6:	b2db      	uxtb	r3, r3
 800a3c8:	2b08      	cmp	r3, #8
 800a3ca:	d839      	bhi.n	800a440 <lps22df_mode_get+0xc4>
 800a3cc:	a201      	add	r2, pc, #4	@ (adr r2, 800a3d4 <lps22df_mode_get+0x58>)
 800a3ce:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800a3d2:	bf00      	nop
 800a3d4:	0800a3f9 	.word	0x0800a3f9
 800a3d8:	0800a401 	.word	0x0800a401
 800a3dc:	0800a409 	.word	0x0800a409
 800a3e0:	0800a411 	.word	0x0800a411
 800a3e4:	0800a419 	.word	0x0800a419
 800a3e8:	0800a421 	.word	0x0800a421
 800a3ec:	0800a429 	.word	0x0800a429
 800a3f0:	0800a431 	.word	0x0800a431
 800a3f4:	0800a439 	.word	0x0800a439
    {
      case LPS22DF_ONE_SHOT:
        val->odr = LPS22DF_ONE_SHOT;
 800a3f8:	683b      	ldr	r3, [r7, #0]
 800a3fa:	2200      	movs	r2, #0
 800a3fc:	701a      	strb	r2, [r3, #0]
        break;
 800a3fe:	e023      	b.n	800a448 <lps22df_mode_get+0xcc>
      case LPS22DF_1Hz:
        val->odr = LPS22DF_1Hz;
 800a400:	683b      	ldr	r3, [r7, #0]
 800a402:	2201      	movs	r2, #1
 800a404:	701a      	strb	r2, [r3, #0]
        break;
 800a406:	e01f      	b.n	800a448 <lps22df_mode_get+0xcc>
      case LPS22DF_4Hz:
        val->odr = LPS22DF_4Hz;
 800a408:	683b      	ldr	r3, [r7, #0]
 800a40a:	2202      	movs	r2, #2
 800a40c:	701a      	strb	r2, [r3, #0]
        break;
 800a40e:	e01b      	b.n	800a448 <lps22df_mode_get+0xcc>
      case LPS22DF_10Hz:
        val->odr = LPS22DF_10Hz;
 800a410:	683b      	ldr	r3, [r7, #0]
 800a412:	2203      	movs	r2, #3
 800a414:	701a      	strb	r2, [r3, #0]
        break;
 800a416:	e017      	b.n	800a448 <lps22df_mode_get+0xcc>
      case LPS22DF_25Hz:
        val->odr = LPS22DF_25Hz;
 800a418:	683b      	ldr	r3, [r7, #0]
 800a41a:	2204      	movs	r2, #4
 800a41c:	701a      	strb	r2, [r3, #0]
        break;
 800a41e:	e013      	b.n	800a448 <lps22df_mode_get+0xcc>
      case LPS22DF_50Hz:
        val->odr = LPS22DF_50Hz;
 800a420:	683b      	ldr	r3, [r7, #0]
 800a422:	2205      	movs	r2, #5
 800a424:	701a      	strb	r2, [r3, #0]
        break;
 800a426:	e00f      	b.n	800a448 <lps22df_mode_get+0xcc>
      case LPS22DF_75Hz:
        val->odr = LPS22DF_75Hz;
 800a428:	683b      	ldr	r3, [r7, #0]
 800a42a:	2206      	movs	r2, #6
 800a42c:	701a      	strb	r2, [r3, #0]
        break;
 800a42e:	e00b      	b.n	800a448 <lps22df_mode_get+0xcc>
      case LPS22DF_100Hz:
        val->odr = LPS22DF_100Hz;
 800a430:	683b      	ldr	r3, [r7, #0]
 800a432:	2207      	movs	r2, #7
 800a434:	701a      	strb	r2, [r3, #0]
        break;
 800a436:	e007      	b.n	800a448 <lps22df_mode_get+0xcc>
      case LPS22DF_200Hz:
        val->odr = LPS22DF_200Hz;
 800a438:	683b      	ldr	r3, [r7, #0]
 800a43a:	2208      	movs	r2, #8
 800a43c:	701a      	strb	r2, [r3, #0]
        break;
 800a43e:	e003      	b.n	800a448 <lps22df_mode_get+0xcc>
      default:
        val->odr = LPS22DF_ONE_SHOT;
 800a440:	683b      	ldr	r3, [r7, #0]
 800a442:	2200      	movs	r2, #0
 800a444:	701a      	strb	r2, [r3, #0]
        break;
 800a446:	bf00      	nop
    }

    switch (ctrl_reg1.avg)
 800a448:	7c3b      	ldrb	r3, [r7, #16]
 800a44a:	f3c3 0302 	ubfx	r3, r3, #0, #3
 800a44e:	b2db      	uxtb	r3, r3
 800a450:	2b07      	cmp	r3, #7
 800a452:	d833      	bhi.n	800a4bc <lps22df_mode_get+0x140>
 800a454:	a201      	add	r2, pc, #4	@ (adr r2, 800a45c <lps22df_mode_get+0xe0>)
 800a456:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800a45a:	bf00      	nop
 800a45c:	0800a47d 	.word	0x0800a47d
 800a460:	0800a485 	.word	0x0800a485
 800a464:	0800a48d 	.word	0x0800a48d
 800a468:	0800a495 	.word	0x0800a495
 800a46c:	0800a49d 	.word	0x0800a49d
 800a470:	0800a4a5 	.word	0x0800a4a5
 800a474:	0800a4ad 	.word	0x0800a4ad
 800a478:	0800a4b5 	.word	0x0800a4b5
    {
      case LPS22DF_4_AVG:
        val->avg = LPS22DF_4_AVG;
 800a47c:	683b      	ldr	r3, [r7, #0]
 800a47e:	2200      	movs	r2, #0
 800a480:	705a      	strb	r2, [r3, #1]
        break;
 800a482:	e01f      	b.n	800a4c4 <lps22df_mode_get+0x148>
      case LPS22DF_8_AVG:
        val->avg = LPS22DF_8_AVG;
 800a484:	683b      	ldr	r3, [r7, #0]
 800a486:	2201      	movs	r2, #1
 800a488:	705a      	strb	r2, [r3, #1]
        break;
 800a48a:	e01b      	b.n	800a4c4 <lps22df_mode_get+0x148>
      case LPS22DF_16_AVG:
        val->avg = LPS22DF_16_AVG;
 800a48c:	683b      	ldr	r3, [r7, #0]
 800a48e:	2202      	movs	r2, #2
 800a490:	705a      	strb	r2, [r3, #1]
        break;
 800a492:	e017      	b.n	800a4c4 <lps22df_mode_get+0x148>
      case LPS22DF_32_AVG:
        val->avg = LPS22DF_32_AVG;
 800a494:	683b      	ldr	r3, [r7, #0]
 800a496:	2203      	movs	r2, #3
 800a498:	705a      	strb	r2, [r3, #1]
        break;
 800a49a:	e013      	b.n	800a4c4 <lps22df_mode_get+0x148>
      case LPS22DF_64_AVG:
        val->avg = LPS22DF_64_AVG;
 800a49c:	683b      	ldr	r3, [r7, #0]
 800a49e:	2204      	movs	r2, #4
 800a4a0:	705a      	strb	r2, [r3, #1]
        break;
 800a4a2:	e00f      	b.n	800a4c4 <lps22df_mode_get+0x148>
      case LPS22DF_128_AVG:
        val->avg = LPS22DF_128_AVG;
 800a4a4:	683b      	ldr	r3, [r7, #0]
 800a4a6:	2205      	movs	r2, #5
 800a4a8:	705a      	strb	r2, [r3, #1]
        break;
 800a4aa:	e00b      	b.n	800a4c4 <lps22df_mode_get+0x148>
      case LPS22DF_256_AVG:
        val->avg = LPS22DF_256_AVG;
 800a4ac:	683b      	ldr	r3, [r7, #0]
 800a4ae:	2206      	movs	r2, #6
 800a4b0:	705a      	strb	r2, [r3, #1]
        break;
 800a4b2:	e007      	b.n	800a4c4 <lps22df_mode_get+0x148>
      case LPS22DF_512_AVG:
        val->avg = LPS22DF_512_AVG;
 800a4b4:	683b      	ldr	r3, [r7, #0]
 800a4b6:	2207      	movs	r2, #7
 800a4b8:	705a      	strb	r2, [r3, #1]
        break;
 800a4ba:	e003      	b.n	800a4c4 <lps22df_mode_get+0x148>
      default:
        val->avg = LPS22DF_4_AVG;
 800a4bc:	683b      	ldr	r3, [r7, #0]
 800a4be:	2200      	movs	r2, #0
 800a4c0:	705a      	strb	r2, [r3, #1]
        break;
 800a4c2:	bf00      	nop
    }

    switch ((ctrl_reg2.lfpf_cfg << 2) | ctrl_reg2.en_lpfp)
 800a4c4:	7b3b      	ldrb	r3, [r7, #12]
 800a4c6:	f3c3 1340 	ubfx	r3, r3, #5, #1
 800a4ca:	b2db      	uxtb	r3, r3
 800a4cc:	009b      	lsls	r3, r3, #2
 800a4ce:	7b3a      	ldrb	r2, [r7, #12]
 800a4d0:	f3c2 1200 	ubfx	r2, r2, #4, #1
 800a4d4:	b2d2      	uxtb	r2, r2
 800a4d6:	4313      	orrs	r3, r2
 800a4d8:	2b03      	cmp	r3, #3
 800a4da:	d00e      	beq.n	800a4fa <lps22df_mode_get+0x17e>
 800a4dc:	2b03      	cmp	r3, #3
 800a4de:	dc10      	bgt.n	800a502 <lps22df_mode_get+0x186>
 800a4e0:	2b00      	cmp	r3, #0
 800a4e2:	d002      	beq.n	800a4ea <lps22df_mode_get+0x16e>
 800a4e4:	2b01      	cmp	r3, #1
 800a4e6:	d004      	beq.n	800a4f2 <lps22df_mode_get+0x176>
 800a4e8:	e00b      	b.n	800a502 <lps22df_mode_get+0x186>
    {
      case LPS22DF_LPF_DISABLE:
        val->lpf = LPS22DF_LPF_DISABLE;
 800a4ea:	683b      	ldr	r3, [r7, #0]
 800a4ec:	2200      	movs	r2, #0
 800a4ee:	709a      	strb	r2, [r3, #2]
        break;
 800a4f0:	e00b      	b.n	800a50a <lps22df_mode_get+0x18e>
      case LPS22DF_LPF_ODR_DIV_4:
        val->lpf = LPS22DF_LPF_ODR_DIV_4;
 800a4f2:	683b      	ldr	r3, [r7, #0]
 800a4f4:	2201      	movs	r2, #1
 800a4f6:	709a      	strb	r2, [r3, #2]
        break;
 800a4f8:	e007      	b.n	800a50a <lps22df_mode_get+0x18e>
      case LPS22DF_LPF_ODR_DIV_9:
        val->lpf = LPS22DF_LPF_ODR_DIV_9;
 800a4fa:	683b      	ldr	r3, [r7, #0]
 800a4fc:	2203      	movs	r2, #3
 800a4fe:	709a      	strb	r2, [r3, #2]
        break;
 800a500:	e003      	b.n	800a50a <lps22df_mode_get+0x18e>
      default:
        val->lpf = LPS22DF_LPF_DISABLE;
 800a502:	683b      	ldr	r3, [r7, #0]
 800a504:	2200      	movs	r2, #0
 800a506:	709a      	strb	r2, [r3, #2]
        break;
 800a508:	bf00      	nop
    }
  }
  return ret;
 800a50a:	697b      	ldr	r3, [r7, #20]
}
 800a50c:	4618      	mov	r0, r3
 800a50e:	3718      	adds	r7, #24
 800a510:	46bd      	mov	sp, r7
 800a512:	bd80      	pop	{r7, pc}

0800a514 <lps22df_data_get>:
  * @param  data  data retrieved from the sensor.(ptr)
  * @retval       interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lps22df_data_get(stmdev_ctx_t *ctx, lps22df_data_t *data)
{
 800a514:	b580      	push	{r7, lr}
 800a516:	b086      	sub	sp, #24
 800a518:	af00      	add	r7, sp, #0
 800a51a:	6078      	str	r0, [r7, #4]
 800a51c:	6039      	str	r1, [r7, #0]
  uint8_t buff[5];
  int32_t ret;

  ret = lps22df_read_reg(ctx, LPS22DF_PRESS_OUT_XL, buff, 5);
 800a51e:	f107 020c 	add.w	r2, r7, #12
 800a522:	2305      	movs	r3, #5
 800a524:	2128      	movs	r1, #40	@ 0x28
 800a526:	6878      	ldr	r0, [r7, #4]
 800a528:	f7ff fd62 	bl	8009ff0 <lps22df_read_reg>
 800a52c:	6178      	str	r0, [r7, #20]

  /* pressure conversion */
  data->pressure.raw = (int32_t)buff[2];
 800a52e:	7bbb      	ldrb	r3, [r7, #14]
 800a530:	461a      	mov	r2, r3
 800a532:	683b      	ldr	r3, [r7, #0]
 800a534:	605a      	str	r2, [r3, #4]
  data->pressure.raw = (data->pressure.raw * 256) + (int32_t) buff[1];
 800a536:	683b      	ldr	r3, [r7, #0]
 800a538:	685b      	ldr	r3, [r3, #4]
 800a53a:	021b      	lsls	r3, r3, #8
 800a53c:	7b7a      	ldrb	r2, [r7, #13]
 800a53e:	441a      	add	r2, r3
 800a540:	683b      	ldr	r3, [r7, #0]
 800a542:	605a      	str	r2, [r3, #4]
  data->pressure.raw = (data->pressure.raw * 256) + (int32_t) buff[0];
 800a544:	683b      	ldr	r3, [r7, #0]
 800a546:	685b      	ldr	r3, [r3, #4]
 800a548:	021b      	lsls	r3, r3, #8
 800a54a:	7b3a      	ldrb	r2, [r7, #12]
 800a54c:	441a      	add	r2, r3
 800a54e:	683b      	ldr	r3, [r7, #0]
 800a550:	605a      	str	r2, [r3, #4]
  data->pressure.raw = data->pressure.raw * 256;
 800a552:	683b      	ldr	r3, [r7, #0]
 800a554:	685b      	ldr	r3, [r3, #4]
 800a556:	021a      	lsls	r2, r3, #8
 800a558:	683b      	ldr	r3, [r7, #0]
 800a55a:	605a      	str	r2, [r3, #4]

  data->pressure.hpa = lps22df_from_lsb_to_hPa(data->pressure.raw);
 800a55c:	683b      	ldr	r3, [r7, #0]
 800a55e:	685b      	ldr	r3, [r3, #4]
 800a560:	4618      	mov	r0, r3
 800a562:	f7ff fd8b 	bl	800a07c <lps22df_from_lsb_to_hPa>
 800a566:	4602      	mov	r2, r0
 800a568:	683b      	ldr	r3, [r7, #0]
 800a56a:	601a      	str	r2, [r3, #0]


  /* temperature conversion */
  data->heat.raw = (int16_t)buff[4];
 800a56c:	7c3b      	ldrb	r3, [r7, #16]
 800a56e:	b21a      	sxth	r2, r3
 800a570:	683b      	ldr	r3, [r7, #0]
 800a572:	819a      	strh	r2, [r3, #12]
  data->heat.raw = (data->heat.raw * 256) + (int16_t) buff[3];
 800a574:	683b      	ldr	r3, [r7, #0]
 800a576:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 800a57a:	b29b      	uxth	r3, r3
 800a57c:	021b      	lsls	r3, r3, #8
 800a57e:	b29b      	uxth	r3, r3
 800a580:	7bfa      	ldrb	r2, [r7, #15]
 800a582:	4413      	add	r3, r2
 800a584:	b29b      	uxth	r3, r3
 800a586:	b21a      	sxth	r2, r3
 800a588:	683b      	ldr	r3, [r7, #0]
 800a58a:	819a      	strh	r2, [r3, #12]
  data->heat.deg_c = lps22df_from_lsb_to_celsius(data->heat.raw);
 800a58c:	683b      	ldr	r3, [r7, #0]
 800a58e:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 800a592:	4618      	mov	r0, r3
 800a594:	f7ff fd8a 	bl	800a0ac <lps22df_from_lsb_to_celsius>
 800a598:	4602      	mov	r2, r0
 800a59a:	683b      	ldr	r3, [r7, #0]
 800a59c:	609a      	str	r2, [r3, #8]

  return ret;
 800a59e:	697b      	ldr	r3, [r7, #20]
}
 800a5a0:	4618      	mov	r0, r3
 800a5a2:	3718      	adds	r7, #24
 800a5a4:	46bd      	mov	sp, r7
 800a5a6:	bd80      	pop	{r7, pc}

0800a5a8 <LSM6DSV16X_RegisterBusIO>:
  * @brief  Register Component Bus IO operations
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSV16X_RegisterBusIO(LSM6DSV16X_Object_t *pObj, LSM6DSV16X_IO_t *pIO)
{
 800a5a8:	b580      	push	{r7, lr}
 800a5aa:	b084      	sub	sp, #16
 800a5ac:	af00      	add	r7, sp, #0
 800a5ae:	6078      	str	r0, [r7, #4]
 800a5b0:	6039      	str	r1, [r7, #0]
  int32_t ret = LSM6DSV16X_OK;
 800a5b2:	2300      	movs	r3, #0
 800a5b4:	60fb      	str	r3, [r7, #12]

  if (pObj == NULL)
 800a5b6:	687b      	ldr	r3, [r7, #4]
 800a5b8:	2b00      	cmp	r3, #0
 800a5ba:	d103      	bne.n	800a5c4 <LSM6DSV16X_RegisterBusIO+0x1c>
  {
    ret = LSM6DSV16X_ERROR;
 800a5bc:	f04f 33ff 	mov.w	r3, #4294967295
 800a5c0:	60fb      	str	r3, [r7, #12]
 800a5c2:	e05d      	b.n	800a680 <LSM6DSV16X_RegisterBusIO+0xd8>
  }
  else
  {
    pObj->IO.Init       = pIO->Init;
 800a5c4:	683b      	ldr	r3, [r7, #0]
 800a5c6:	681a      	ldr	r2, [r3, #0]
 800a5c8:	687b      	ldr	r3, [r7, #4]
 800a5ca:	601a      	str	r2, [r3, #0]
    pObj->IO.DeInit     = pIO->DeInit;
 800a5cc:	683b      	ldr	r3, [r7, #0]
 800a5ce:	685a      	ldr	r2, [r3, #4]
 800a5d0:	687b      	ldr	r3, [r7, #4]
 800a5d2:	605a      	str	r2, [r3, #4]
    pObj->IO.BusType    = pIO->BusType;
 800a5d4:	683b      	ldr	r3, [r7, #0]
 800a5d6:	689a      	ldr	r2, [r3, #8]
 800a5d8:	687b      	ldr	r3, [r7, #4]
 800a5da:	609a      	str	r2, [r3, #8]
    pObj->IO.Address    = pIO->Address;
 800a5dc:	683b      	ldr	r3, [r7, #0]
 800a5de:	7b1a      	ldrb	r2, [r3, #12]
 800a5e0:	687b      	ldr	r3, [r7, #4]
 800a5e2:	731a      	strb	r2, [r3, #12]
    pObj->IO.WriteReg   = pIO->WriteReg;
 800a5e4:	683b      	ldr	r3, [r7, #0]
 800a5e6:	691a      	ldr	r2, [r3, #16]
 800a5e8:	687b      	ldr	r3, [r7, #4]
 800a5ea:	611a      	str	r2, [r3, #16]
    pObj->IO.ReadReg    = pIO->ReadReg;
 800a5ec:	683b      	ldr	r3, [r7, #0]
 800a5ee:	695a      	ldr	r2, [r3, #20]
 800a5f0:	687b      	ldr	r3, [r7, #4]
 800a5f2:	615a      	str	r2, [r3, #20]
    pObj->IO.GetTick    = pIO->GetTick;
 800a5f4:	683b      	ldr	r3, [r7, #0]
 800a5f6:	699a      	ldr	r2, [r3, #24]
 800a5f8:	687b      	ldr	r3, [r7, #4]
 800a5fa:	619a      	str	r2, [r3, #24]

    pObj->Ctx.read_reg  = ReadRegWrap;
 800a5fc:	687b      	ldr	r3, [r7, #4]
 800a5fe:	4a23      	ldr	r2, [pc, #140]	@ (800a68c <LSM6DSV16X_RegisterBusIO+0xe4>)
 800a600:	625a      	str	r2, [r3, #36]	@ 0x24
    pObj->Ctx.write_reg = WriteRegWrap;
 800a602:	687b      	ldr	r3, [r7, #4]
 800a604:	4a22      	ldr	r2, [pc, #136]	@ (800a690 <LSM6DSV16X_RegisterBusIO+0xe8>)
 800a606:	621a      	str	r2, [r3, #32]
    pObj->Ctx.mdelay    = pIO->Delay;
 800a608:	683b      	ldr	r3, [r7, #0]
 800a60a:	69da      	ldr	r2, [r3, #28]
 800a60c:	687b      	ldr	r3, [r7, #4]
 800a60e:	629a      	str	r2, [r3, #40]	@ 0x28
    pObj->Ctx.handle    = pObj;
 800a610:	687b      	ldr	r3, [r7, #4]
 800a612:	687a      	ldr	r2, [r7, #4]
 800a614:	62da      	str	r2, [r3, #44]	@ 0x2c

    if (pObj->IO.Init == NULL)
 800a616:	687b      	ldr	r3, [r7, #4]
 800a618:	681b      	ldr	r3, [r3, #0]
 800a61a:	2b00      	cmp	r3, #0
 800a61c:	d103      	bne.n	800a626 <LSM6DSV16X_RegisterBusIO+0x7e>
    {
      ret = LSM6DSV16X_ERROR;
 800a61e:	f04f 33ff 	mov.w	r3, #4294967295
 800a622:	60fb      	str	r3, [r7, #12]
 800a624:	e02c      	b.n	800a680 <LSM6DSV16X_RegisterBusIO+0xd8>
    }
    else if (pObj->IO.Init() != LSM6DSV16X_OK)
 800a626:	687b      	ldr	r3, [r7, #4]
 800a628:	681b      	ldr	r3, [r3, #0]
 800a62a:	4798      	blx	r3
 800a62c:	4603      	mov	r3, r0
 800a62e:	2b00      	cmp	r3, #0
 800a630:	d003      	beq.n	800a63a <LSM6DSV16X_RegisterBusIO+0x92>
    {
      ret = LSM6DSV16X_ERROR;
 800a632:	f04f 33ff 	mov.w	r3, #4294967295
 800a636:	60fb      	str	r3, [r7, #12]
 800a638:	e022      	b.n	800a680 <LSM6DSV16X_RegisterBusIO+0xd8>
    }
    else
    {
      if (pObj->IO.BusType == LSM6DSV16X_SPI_3WIRES_BUS) /* SPI 3-Wires */
 800a63a:	687b      	ldr	r3, [r7, #4]
 800a63c:	689b      	ldr	r3, [r3, #8]
 800a63e:	2b02      	cmp	r3, #2
 800a640:	d11e      	bne.n	800a680 <LSM6DSV16X_RegisterBusIO+0xd8>
      {
        /* Enable the SPI 3-Wires support only the first time */
        if (pObj->is_initialized == 0U)
 800a642:	687b      	ldr	r3, [r7, #4]
 800a644:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
 800a648:	2b00      	cmp	r3, #0
 800a64a:	d119      	bne.n	800a680 <LSM6DSV16X_RegisterBusIO+0xd8>
        {
          /* Enable SPI 3-Wires on the component */
          uint8_t data = 0x04;
 800a64c:	2304      	movs	r3, #4
 800a64e:	72fb      	strb	r3, [r7, #11]

          if (LSM6DSV16X_Write_Reg(pObj, LSM6DSV16X_CTRL3, data) != LSM6DSV16X_OK)
 800a650:	7afb      	ldrb	r3, [r7, #11]
 800a652:	461a      	mov	r2, r3
 800a654:	2112      	movs	r1, #18
 800a656:	6878      	ldr	r0, [r7, #4]
 800a658:	f000 fd91 	bl	800b17e <LSM6DSV16X_Write_Reg>
 800a65c:	4603      	mov	r3, r0
 800a65e:	2b00      	cmp	r3, #0
 800a660:	d002      	beq.n	800a668 <LSM6DSV16X_RegisterBusIO+0xc0>
          {
            ret = LSM6DSV16X_ERROR;
 800a662:	f04f 33ff 	mov.w	r3, #4294967295
 800a666:	60fb      	str	r3, [r7, #12]
          }

          if (LSM6DSV16X_Write_Reg(pObj, LSM6DSV16X_IF_CFG, data) != LSM6DSV16X_OK)
 800a668:	7afb      	ldrb	r3, [r7, #11]
 800a66a:	461a      	mov	r2, r3
 800a66c:	2103      	movs	r1, #3
 800a66e:	6878      	ldr	r0, [r7, #4]
 800a670:	f000 fd85 	bl	800b17e <LSM6DSV16X_Write_Reg>
 800a674:	4603      	mov	r3, r0
 800a676:	2b00      	cmp	r3, #0
 800a678:	d002      	beq.n	800a680 <LSM6DSV16X_RegisterBusIO+0xd8>
          {
            ret = LSM6DSV16X_ERROR;
 800a67a:	f04f 33ff 	mov.w	r3, #4294967295
 800a67e:	60fb      	str	r3, [r7, #12]
        }
      }
    }
  }

  return ret;
 800a680:	68fb      	ldr	r3, [r7, #12]
}
 800a682:	4618      	mov	r0, r3
 800a684:	3710      	adds	r7, #16
 800a686:	46bd      	mov	sp, r7
 800a688:	bd80      	pop	{r7, pc}
 800a68a:	bf00      	nop
 800a68c:	0800b669 	.word	0x0800b669
 800a690:	0800b69f 	.word	0x0800b69f

0800a694 <LSM6DSV16X_Init>:
  * @brief  Initialize the LSM6DSV16X sensor
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSV16X_Init(LSM6DSV16X_Object_t *pObj)
{
 800a694:	b580      	push	{r7, lr}
 800a696:	b084      	sub	sp, #16
 800a698:	af00      	add	r7, sp, #0
 800a69a:	6078      	str	r0, [r7, #4]
  /* Enable register address automatically incremented during a multiple byte
  access with a serial interface */
  if (lsm6dsv16x_auto_increment_set(&(pObj->Ctx), PROPERTY_ENABLE) != LSM6DSV16X_OK)
 800a69c:	687b      	ldr	r3, [r7, #4]
 800a69e:	3320      	adds	r3, #32
 800a6a0:	2101      	movs	r1, #1
 800a6a2:	4618      	mov	r0, r3
 800a6a4:	f001 fb18 	bl	800bcd8 <lsm6dsv16x_auto_increment_set>
 800a6a8:	4603      	mov	r3, r0
 800a6aa:	2b00      	cmp	r3, #0
 800a6ac:	d002      	beq.n	800a6b4 <LSM6DSV16X_Init+0x20>
  {
    return LSM6DSV16X_ERROR;
 800a6ae:	f04f 33ff 	mov.w	r3, #4294967295
 800a6b2:	e064      	b.n	800a77e <LSM6DSV16X_Init+0xea>
  }

  /* Enable BDU */
  if (lsm6dsv16x_block_data_update_set(&(pObj->Ctx), PROPERTY_ENABLE) != LSM6DSV16X_OK)
 800a6b4:	687b      	ldr	r3, [r7, #4]
 800a6b6:	3320      	adds	r3, #32
 800a6b8:	2101      	movs	r1, #1
 800a6ba:	4618      	mov	r0, r3
 800a6bc:	f001 fb32 	bl	800bd24 <lsm6dsv16x_block_data_update_set>
 800a6c0:	4603      	mov	r3, r0
 800a6c2:	2b00      	cmp	r3, #0
 800a6c4:	d002      	beq.n	800a6cc <LSM6DSV16X_Init+0x38>
  {
    return LSM6DSV16X_ERROR;
 800a6c6:	f04f 33ff 	mov.w	r3, #4294967295
 800a6ca:	e058      	b.n	800a77e <LSM6DSV16X_Init+0xea>
  }

  /* WAKE_UP mode selection */
  if (lsm6dsv16x_fifo_mode_set(&(pObj->Ctx), LSM6DSV16X_BYPASS_MODE) != LSM6DSV16X_OK)
 800a6cc:	687b      	ldr	r3, [r7, #4]
 800a6ce:	3320      	adds	r3, #32
 800a6d0:	2100      	movs	r1, #0
 800a6d2:	4618      	mov	r0, r3
 800a6d4:	f001 fcc8 	bl	800c068 <lsm6dsv16x_fifo_mode_set>
 800a6d8:	4603      	mov	r3, r0
 800a6da:	2b00      	cmp	r3, #0
 800a6dc:	d002      	beq.n	800a6e4 <LSM6DSV16X_Init+0x50>
  {
    return LSM6DSV16X_ERROR;
 800a6de:	f04f 33ff 	mov.w	r3, #4294967295
 800a6e2:	e04c      	b.n	800a77e <LSM6DSV16X_Init+0xea>
  }

  /* Select default output data rate */
  pObj->acc_odr = LSM6DSV16X_ODR_AT_120Hz;
 800a6e4:	687b      	ldr	r3, [r7, #4]
 800a6e6:	2206      	movs	r2, #6
 800a6e8:	f883 2033 	strb.w	r2, [r3, #51]	@ 0x33

  /* Output data rate selection - power down */
  if (lsm6dsv16x_xl_data_rate_set(&(pObj->Ctx), LSM6DSV16X_ODR_OFF) != LSM6DSV16X_OK)
 800a6ec:	687b      	ldr	r3, [r7, #4]
 800a6ee:	3320      	adds	r3, #32
 800a6f0:	2100      	movs	r1, #0
 800a6f2:	4618      	mov	r0, r3
 800a6f4:	f001 f82f 	bl	800b756 <lsm6dsv16x_xl_data_rate_set>
 800a6f8:	4603      	mov	r3, r0
 800a6fa:	2b00      	cmp	r3, #0
 800a6fc:	d002      	beq.n	800a704 <LSM6DSV16X_Init+0x70>
  {
    return LSM6DSV16X_ERROR;
 800a6fe:	f04f 33ff 	mov.w	r3, #4294967295
 800a702:	e03c      	b.n	800a77e <LSM6DSV16X_Init+0xea>
  }

  /* Full scale selection */
  if (lsm6dsv16x_xl_full_scale_set(&(pObj->Ctx), LSM6DSV16X_2g) != LSM6DSV16X_OK)
 800a704:	687b      	ldr	r3, [r7, #4]
 800a706:	3320      	adds	r3, #32
 800a708:	2100      	movs	r1, #0
 800a70a:	4618      	mov	r0, r3
 800a70c:	f001 fbae 	bl	800be6c <lsm6dsv16x_xl_full_scale_set>
 800a710:	4603      	mov	r3, r0
 800a712:	2b00      	cmp	r3, #0
 800a714:	d002      	beq.n	800a71c <LSM6DSV16X_Init+0x88>
  {
    return LSM6DSV16X_ERROR;
 800a716:	f04f 33ff 	mov.w	r3, #4294967295
 800a71a:	e030      	b.n	800a77e <LSM6DSV16X_Init+0xea>
  }

  /* Select default output data rate */
  pObj->gyro_odr = LSM6DSV16X_ODR_AT_120Hz;
 800a71c:	687b      	ldr	r3, [r7, #4]
 800a71e:	2206      	movs	r2, #6
 800a720:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34

  /* Output data rate selection - power down */
  if (lsm6dsv16x_gy_data_rate_set(&(pObj->Ctx), LSM6DSV16X_ODR_OFF) != LSM6DSV16X_OK)
 800a724:	687b      	ldr	r3, [r7, #4]
 800a726:	3320      	adds	r3, #32
 800a728:	2100      	movs	r1, #0
 800a72a:	4618      	mov	r0, r3
 800a72c:	f001 f974 	bl	800ba18 <lsm6dsv16x_gy_data_rate_set>
 800a730:	4603      	mov	r3, r0
 800a732:	2b00      	cmp	r3, #0
 800a734:	d002      	beq.n	800a73c <LSM6DSV16X_Init+0xa8>
  {
    return LSM6DSV16X_ERROR;
 800a736:	f04f 33ff 	mov.w	r3, #4294967295
 800a73a:	e020      	b.n	800a77e <LSM6DSV16X_Init+0xea>
  }

  /* Full scale selection */
  if (lsm6dsv16x_gy_full_scale_set(&(pObj->Ctx), LSM6DSV16X_2000dps) != LSM6DSV16X_OK)
 800a73c:	687b      	ldr	r3, [r7, #4]
 800a73e:	3320      	adds	r3, #32
 800a740:	2104      	movs	r1, #4
 800a742:	4618      	mov	r0, r3
 800a744:	f001 fb14 	bl	800bd70 <lsm6dsv16x_gy_full_scale_set>
 800a748:	4603      	mov	r3, r0
 800a74a:	2b00      	cmp	r3, #0
 800a74c:	d002      	beq.n	800a754 <LSM6DSV16X_Init+0xc0>
  {
    return LSM6DSV16X_ERROR;
 800a74e:	f04f 33ff 	mov.w	r3, #4294967295
 800a752:	e014      	b.n	800a77e <LSM6DSV16X_Init+0xea>
  }

  /* Enable Qvar functionality */
  lsm6dsv16x_ah_qvar_mode_t mode;
  mode.ah_qvar_en = 1;
 800a754:	7b3b      	ldrb	r3, [r7, #12]
 800a756:	f043 0301 	orr.w	r3, r3, #1
 800a75a:	733b      	strb	r3, [r7, #12]

  if (lsm6dsv16x_ah_qvar_mode_set(&(pObj->Ctx), mode) != LSM6DSV16X_OK)
 800a75c:	687b      	ldr	r3, [r7, #4]
 800a75e:	3320      	adds	r3, #32
 800a760:	7b39      	ldrb	r1, [r7, #12]
 800a762:	4618      	mov	r0, r3
 800a764:	f001 fca6 	bl	800c0b4 <lsm6dsv16x_ah_qvar_mode_set>
 800a768:	4603      	mov	r3, r0
 800a76a:	2b00      	cmp	r3, #0
 800a76c:	d002      	beq.n	800a774 <LSM6DSV16X_Init+0xe0>
  {
    return LSM6DSV16X_ERROR;
 800a76e:	f04f 33ff 	mov.w	r3, #4294967295
 800a772:	e004      	b.n	800a77e <LSM6DSV16X_Init+0xea>
  }

  pObj->is_initialized = 1;
 800a774:	687b      	ldr	r3, [r7, #4]
 800a776:	2201      	movs	r2, #1
 800a778:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30

  return LSM6DSV16X_OK;
 800a77c:	2300      	movs	r3, #0
}
 800a77e:	4618      	mov	r0, r3
 800a780:	3710      	adds	r7, #16
 800a782:	46bd      	mov	sp, r7
 800a784:	bd80      	pop	{r7, pc}

0800a786 <LSM6DSV16X_DeInit>:
  * @brief  Deinitialize the LSM6DSV16X sensor
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSV16X_DeInit(LSM6DSV16X_Object_t *pObj)
{
 800a786:	b580      	push	{r7, lr}
 800a788:	b084      	sub	sp, #16
 800a78a:	af00      	add	r7, sp, #0
 800a78c:	6078      	str	r0, [r7, #4]
  /* Disable the component */
  if (LSM6DSV16X_ACC_Disable(pObj) != LSM6DSV16X_OK)
 800a78e:	6878      	ldr	r0, [r7, #4]
 800a790:	f000 f898 	bl	800a8c4 <LSM6DSV16X_ACC_Disable>
 800a794:	4603      	mov	r3, r0
 800a796:	2b00      	cmp	r3, #0
 800a798:	d002      	beq.n	800a7a0 <LSM6DSV16X_DeInit+0x1a>
  {
    return LSM6DSV16X_ERROR;
 800a79a:	f04f 33ff 	mov.w	r3, #4294967295
 800a79e:	e025      	b.n	800a7ec <LSM6DSV16X_DeInit+0x66>
  }

  if (LSM6DSV16X_GYRO_Disable(pObj) != LSM6DSV16X_OK)
 800a7a0:	6878      	ldr	r0, [r7, #4]
 800a7a2:	f000 fab0 	bl	800ad06 <LSM6DSV16X_GYRO_Disable>
 800a7a6:	4603      	mov	r3, r0
 800a7a8:	2b00      	cmp	r3, #0
 800a7aa:	d002      	beq.n	800a7b2 <LSM6DSV16X_DeInit+0x2c>
  {
    return LSM6DSV16X_ERROR;
 800a7ac:	f04f 33ff 	mov.w	r3, #4294967295
 800a7b0:	e01c      	b.n	800a7ec <LSM6DSV16X_DeInit+0x66>
  }

  /* Reset output data rate */
  pObj->acc_odr = LSM6DSV16X_ODR_OFF;
 800a7b2:	687b      	ldr	r3, [r7, #4]
 800a7b4:	2200      	movs	r2, #0
 800a7b6:	f883 2033 	strb.w	r2, [r3, #51]	@ 0x33
  pObj->gyro_odr = LSM6DSV16X_ODR_OFF;
 800a7ba:	687b      	ldr	r3, [r7, #4]
 800a7bc:	2200      	movs	r2, #0
 800a7be:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34

  /* Disable Qvar functionality */
  lsm6dsv16x_ah_qvar_mode_t mode;
  mode.ah_qvar_en = 0;
 800a7c2:	7b3b      	ldrb	r3, [r7, #12]
 800a7c4:	f023 0301 	bic.w	r3, r3, #1
 800a7c8:	733b      	strb	r3, [r7, #12]

  if (lsm6dsv16x_ah_qvar_mode_set(&(pObj->Ctx), mode) != LSM6DSV16X_OK)
 800a7ca:	687b      	ldr	r3, [r7, #4]
 800a7cc:	3320      	adds	r3, #32
 800a7ce:	7b39      	ldrb	r1, [r7, #12]
 800a7d0:	4618      	mov	r0, r3
 800a7d2:	f001 fc6f 	bl	800c0b4 <lsm6dsv16x_ah_qvar_mode_set>
 800a7d6:	4603      	mov	r3, r0
 800a7d8:	2b00      	cmp	r3, #0
 800a7da:	d002      	beq.n	800a7e2 <LSM6DSV16X_DeInit+0x5c>
  {
    return LSM6DSV16X_ERROR;
 800a7dc:	f04f 33ff 	mov.w	r3, #4294967295
 800a7e0:	e004      	b.n	800a7ec <LSM6DSV16X_DeInit+0x66>
  }

  pObj->is_initialized = 0;
 800a7e2:	687b      	ldr	r3, [r7, #4]
 800a7e4:	2200      	movs	r2, #0
 800a7e6:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30

  return LSM6DSV16X_OK;
 800a7ea:	2300      	movs	r3, #0
}
 800a7ec:	4618      	mov	r0, r3
 800a7ee:	3710      	adds	r7, #16
 800a7f0:	46bd      	mov	sp, r7
 800a7f2:	bd80      	pop	{r7, pc}

0800a7f4 <LSM6DSV16X_ReadID>:
  * @param  pObj the device pObj
  * @param  Id the WHO_AM_I value
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSV16X_ReadID(LSM6DSV16X_Object_t *pObj, uint8_t *Id)
{
 800a7f4:	b580      	push	{r7, lr}
 800a7f6:	b082      	sub	sp, #8
 800a7f8:	af00      	add	r7, sp, #0
 800a7fa:	6078      	str	r0, [r7, #4]
 800a7fc:	6039      	str	r1, [r7, #0]
  if (lsm6dsv16x_device_id_get(&(pObj->Ctx), Id) != LSM6DSV16X_OK)
 800a7fe:	687b      	ldr	r3, [r7, #4]
 800a800:	3320      	adds	r3, #32
 800a802:	6839      	ldr	r1, [r7, #0]
 800a804:	4618      	mov	r0, r3
 800a806:	f000 ff95 	bl	800b734 <lsm6dsv16x_device_id_get>
 800a80a:	4603      	mov	r3, r0
 800a80c:	2b00      	cmp	r3, #0
 800a80e:	d002      	beq.n	800a816 <LSM6DSV16X_ReadID+0x22>
  {
    return LSM6DSV16X_ERROR;
 800a810:	f04f 33ff 	mov.w	r3, #4294967295
 800a814:	e000      	b.n	800a818 <LSM6DSV16X_ReadID+0x24>
  }

  return LSM6DSV16X_OK;
 800a816:	2300      	movs	r3, #0
}
 800a818:	4618      	mov	r0, r3
 800a81a:	3708      	adds	r7, #8
 800a81c:	46bd      	mov	sp, r7
 800a81e:	bd80      	pop	{r7, pc}

0800a820 <LSM6DSV16X_GetCapabilities>:
  * @param  pObj Component object pointer
  * @param  Capabilities pointer to LSM6DSV16X sensor capabilities
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSV16X_GetCapabilities(LSM6DSV16X_Object_t *pObj, LSM6DSV16X_Capabilities_t *Capabilities)
{
 800a820:	b480      	push	{r7}
 800a822:	b083      	sub	sp, #12
 800a824:	af00      	add	r7, sp, #0
 800a826:	6078      	str	r0, [r7, #4]
 800a828:	6039      	str	r1, [r7, #0]
  /* Prevent unused argument(s) compilation warning */
  (void)(pObj);

  Capabilities->Acc          = 1;
 800a82a:	683b      	ldr	r3, [r7, #0]
 800a82c:	2201      	movs	r2, #1
 800a82e:	701a      	strb	r2, [r3, #0]
  Capabilities->Gyro         = 1;
 800a830:	683b      	ldr	r3, [r7, #0]
 800a832:	2201      	movs	r2, #1
 800a834:	705a      	strb	r2, [r3, #1]
  Capabilities->Magneto      = 0;
 800a836:	683b      	ldr	r3, [r7, #0]
 800a838:	2200      	movs	r2, #0
 800a83a:	709a      	strb	r2, [r3, #2]
  Capabilities->LowPower     = 1;
 800a83c:	683b      	ldr	r3, [r7, #0]
 800a83e:	2201      	movs	r2, #1
 800a840:	70da      	strb	r2, [r3, #3]
  Capabilities->GyroMaxFS    = 4000;
 800a842:	683b      	ldr	r3, [r7, #0]
 800a844:	f44f 627a 	mov.w	r2, #4000	@ 0xfa0
 800a848:	605a      	str	r2, [r3, #4]
  Capabilities->AccMaxFS     = 16;
 800a84a:	683b      	ldr	r3, [r7, #0]
 800a84c:	2210      	movs	r2, #16
 800a84e:	609a      	str	r2, [r3, #8]
  Capabilities->MagMaxFS     = 0;
 800a850:	683b      	ldr	r3, [r7, #0]
 800a852:	2200      	movs	r2, #0
 800a854:	60da      	str	r2, [r3, #12]
  Capabilities->GyroMaxOdr   = 7680.0f;
 800a856:	683b      	ldr	r3, [r7, #0]
 800a858:	4a07      	ldr	r2, [pc, #28]	@ (800a878 <LSM6DSV16X_GetCapabilities+0x58>)
 800a85a:	611a      	str	r2, [r3, #16]
  Capabilities->AccMaxOdr    = 7680.0f;
 800a85c:	683b      	ldr	r3, [r7, #0]
 800a85e:	4a06      	ldr	r2, [pc, #24]	@ (800a878 <LSM6DSV16X_GetCapabilities+0x58>)
 800a860:	615a      	str	r2, [r3, #20]
  Capabilities->MagMaxOdr    = 0.0f;
 800a862:	683b      	ldr	r3, [r7, #0]
 800a864:	f04f 0200 	mov.w	r2, #0
 800a868:	619a      	str	r2, [r3, #24]
  return LSM6DSV16X_OK;
 800a86a:	2300      	movs	r3, #0
}
 800a86c:	4618      	mov	r0, r3
 800a86e:	370c      	adds	r7, #12
 800a870:	46bd      	mov	sp, r7
 800a872:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a876:	4770      	bx	lr
 800a878:	45f00000 	.word	0x45f00000

0800a87c <LSM6DSV16X_ACC_Enable>:
  * @brief  Enable the LSM6DSV16X accelerometer sensor
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSV16X_ACC_Enable(LSM6DSV16X_Object_t *pObj)
{
 800a87c:	b580      	push	{r7, lr}
 800a87e:	b082      	sub	sp, #8
 800a880:	af00      	add	r7, sp, #0
 800a882:	6078      	str	r0, [r7, #4]
  /* Check if the component is already enabled */
  if (pObj->acc_is_enabled == 1U)
 800a884:	687b      	ldr	r3, [r7, #4]
 800a886:	f893 3031 	ldrb.w	r3, [r3, #49]	@ 0x31
 800a88a:	2b01      	cmp	r3, #1
 800a88c:	d101      	bne.n	800a892 <LSM6DSV16X_ACC_Enable+0x16>
  {
    return LSM6DSV16X_OK;
 800a88e:	2300      	movs	r3, #0
 800a890:	e014      	b.n	800a8bc <LSM6DSV16X_ACC_Enable+0x40>
  }

  /* Output data rate selection */
  if (lsm6dsv16x_xl_data_rate_set(&(pObj->Ctx), pObj->acc_odr) != LSM6DSV16X_OK)
 800a892:	687b      	ldr	r3, [r7, #4]
 800a894:	f103 0220 	add.w	r2, r3, #32
 800a898:	687b      	ldr	r3, [r7, #4]
 800a89a:	f893 3033 	ldrb.w	r3, [r3, #51]	@ 0x33
 800a89e:	4619      	mov	r1, r3
 800a8a0:	4610      	mov	r0, r2
 800a8a2:	f000 ff58 	bl	800b756 <lsm6dsv16x_xl_data_rate_set>
 800a8a6:	4603      	mov	r3, r0
 800a8a8:	2b00      	cmp	r3, #0
 800a8aa:	d002      	beq.n	800a8b2 <LSM6DSV16X_ACC_Enable+0x36>
  {
    return LSM6DSV16X_ERROR;
 800a8ac:	f04f 33ff 	mov.w	r3, #4294967295
 800a8b0:	e004      	b.n	800a8bc <LSM6DSV16X_ACC_Enable+0x40>
  }

  pObj->acc_is_enabled = 1;
 800a8b2:	687b      	ldr	r3, [r7, #4]
 800a8b4:	2201      	movs	r2, #1
 800a8b6:	f883 2031 	strb.w	r2, [r3, #49]	@ 0x31

  return LSM6DSV16X_OK;
 800a8ba:	2300      	movs	r3, #0
}
 800a8bc:	4618      	mov	r0, r3
 800a8be:	3708      	adds	r7, #8
 800a8c0:	46bd      	mov	sp, r7
 800a8c2:	bd80      	pop	{r7, pc}

0800a8c4 <LSM6DSV16X_ACC_Disable>:
  * @brief  Disable the LSM6DSV16X accelerometer sensor
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSV16X_ACC_Disable(LSM6DSV16X_Object_t *pObj)
{
 800a8c4:	b580      	push	{r7, lr}
 800a8c6:	b082      	sub	sp, #8
 800a8c8:	af00      	add	r7, sp, #0
 800a8ca:	6078      	str	r0, [r7, #4]
  /* Check if the component is already disabled */
  if (pObj->acc_is_enabled == 0U)
 800a8cc:	687b      	ldr	r3, [r7, #4]
 800a8ce:	f893 3031 	ldrb.w	r3, [r3, #49]	@ 0x31
 800a8d2:	2b00      	cmp	r3, #0
 800a8d4:	d101      	bne.n	800a8da <LSM6DSV16X_ACC_Disable+0x16>
  {
    return LSM6DSV16X_OK;
 800a8d6:	2300      	movs	r3, #0
 800a8d8:	e01f      	b.n	800a91a <LSM6DSV16X_ACC_Disable+0x56>
  }

  /* Get current output data rate */
  if (lsm6dsv16x_xl_data_rate_get(&(pObj->Ctx), &pObj->acc_odr) != LSM6DSV16X_OK)
 800a8da:	687b      	ldr	r3, [r7, #4]
 800a8dc:	f103 0220 	add.w	r2, r3, #32
 800a8e0:	687b      	ldr	r3, [r7, #4]
 800a8e2:	3333      	adds	r3, #51	@ 0x33
 800a8e4:	4619      	mov	r1, r3
 800a8e6:	4610      	mov	r0, r2
 800a8e8:	f000 ff86 	bl	800b7f8 <lsm6dsv16x_xl_data_rate_get>
 800a8ec:	4603      	mov	r3, r0
 800a8ee:	2b00      	cmp	r3, #0
 800a8f0:	d002      	beq.n	800a8f8 <LSM6DSV16X_ACC_Disable+0x34>
  {
    return LSM6DSV16X_ERROR;
 800a8f2:	f04f 33ff 	mov.w	r3, #4294967295
 800a8f6:	e010      	b.n	800a91a <LSM6DSV16X_ACC_Disable+0x56>
  }

  /* Output data rate selection - power down */
  if (lsm6dsv16x_xl_data_rate_set(&(pObj->Ctx), LSM6DSV16X_ODR_OFF) != LSM6DSV16X_OK)
 800a8f8:	687b      	ldr	r3, [r7, #4]
 800a8fa:	3320      	adds	r3, #32
 800a8fc:	2100      	movs	r1, #0
 800a8fe:	4618      	mov	r0, r3
 800a900:	f000 ff29 	bl	800b756 <lsm6dsv16x_xl_data_rate_set>
 800a904:	4603      	mov	r3, r0
 800a906:	2b00      	cmp	r3, #0
 800a908:	d002      	beq.n	800a910 <LSM6DSV16X_ACC_Disable+0x4c>
  {
    return LSM6DSV16X_ERROR;
 800a90a:	f04f 33ff 	mov.w	r3, #4294967295
 800a90e:	e004      	b.n	800a91a <LSM6DSV16X_ACC_Disable+0x56>
  }

  pObj->acc_is_enabled = 0;
 800a910:	687b      	ldr	r3, [r7, #4]
 800a912:	2200      	movs	r2, #0
 800a914:	f883 2031 	strb.w	r2, [r3, #49]	@ 0x31

  return LSM6DSV16X_OK;
 800a918:	2300      	movs	r3, #0
}
 800a91a:	4618      	mov	r0, r3
 800a91c:	3708      	adds	r7, #8
 800a91e:	46bd      	mov	sp, r7
 800a920:	bd80      	pop	{r7, pc}
	...

0800a924 <LSM6DSV16X_ACC_GetSensitivity>:
  * @param  pObj the device pObj
  * @param  Sensitivity pointer
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSV16X_ACC_GetSensitivity(LSM6DSV16X_Object_t *pObj, float *Sensitivity)
{
 800a924:	b580      	push	{r7, lr}
 800a926:	b084      	sub	sp, #16
 800a928:	af00      	add	r7, sp, #0
 800a92a:	6078      	str	r0, [r7, #4]
 800a92c:	6039      	str	r1, [r7, #0]
  int32_t ret = LSM6DSV16X_OK;
 800a92e:	2300      	movs	r3, #0
 800a930:	60fb      	str	r3, [r7, #12]
  lsm6dsv16x_xl_full_scale_t full_scale;

  /* Read actual full scale selection from sensor */
  if (lsm6dsv16x_xl_full_scale_get(&(pObj->Ctx), &full_scale) != LSM6DSV16X_OK)
 800a932:	687b      	ldr	r3, [r7, #4]
 800a934:	3320      	adds	r3, #32
 800a936:	f107 020b 	add.w	r2, r7, #11
 800a93a:	4611      	mov	r1, r2
 800a93c:	4618      	mov	r0, r3
 800a93e:	f001 fabb 	bl	800beb8 <lsm6dsv16x_xl_full_scale_get>
 800a942:	4603      	mov	r3, r0
 800a944:	2b00      	cmp	r3, #0
 800a946:	d002      	beq.n	800a94e <LSM6DSV16X_ACC_GetSensitivity+0x2a>
  {
    return LSM6DSV16X_ERROR;
 800a948:	f04f 33ff 	mov.w	r3, #4294967295
 800a94c:	e023      	b.n	800a996 <LSM6DSV16X_ACC_GetSensitivity+0x72>
  }

  /* Store the Sensitivity based on actual full scale */
  switch (full_scale)
 800a94e:	7afb      	ldrb	r3, [r7, #11]
 800a950:	2b03      	cmp	r3, #3
 800a952:	d81b      	bhi.n	800a98c <LSM6DSV16X_ACC_GetSensitivity+0x68>
 800a954:	a201      	add	r2, pc, #4	@ (adr r2, 800a95c <LSM6DSV16X_ACC_GetSensitivity+0x38>)
 800a956:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800a95a:	bf00      	nop
 800a95c:	0800a96d 	.word	0x0800a96d
 800a960:	0800a975 	.word	0x0800a975
 800a964:	0800a97d 	.word	0x0800a97d
 800a968:	0800a985 	.word	0x0800a985
  {
    case LSM6DSV16X_2g:
      *Sensitivity = LSM6DSV16X_ACC_SENSITIVITY_FS_2G;
 800a96c:	683b      	ldr	r3, [r7, #0]
 800a96e:	4a0c      	ldr	r2, [pc, #48]	@ (800a9a0 <LSM6DSV16X_ACC_GetSensitivity+0x7c>)
 800a970:	601a      	str	r2, [r3, #0]
      break;
 800a972:	e00f      	b.n	800a994 <LSM6DSV16X_ACC_GetSensitivity+0x70>

    case LSM6DSV16X_4g:
      *Sensitivity = LSM6DSV16X_ACC_SENSITIVITY_FS_4G;
 800a974:	683b      	ldr	r3, [r7, #0]
 800a976:	4a0b      	ldr	r2, [pc, #44]	@ (800a9a4 <LSM6DSV16X_ACC_GetSensitivity+0x80>)
 800a978:	601a      	str	r2, [r3, #0]
      break;
 800a97a:	e00b      	b.n	800a994 <LSM6DSV16X_ACC_GetSensitivity+0x70>

    case LSM6DSV16X_8g:
      *Sensitivity = LSM6DSV16X_ACC_SENSITIVITY_FS_8G;
 800a97c:	683b      	ldr	r3, [r7, #0]
 800a97e:	4a0a      	ldr	r2, [pc, #40]	@ (800a9a8 <LSM6DSV16X_ACC_GetSensitivity+0x84>)
 800a980:	601a      	str	r2, [r3, #0]
      break;
 800a982:	e007      	b.n	800a994 <LSM6DSV16X_ACC_GetSensitivity+0x70>

    case LSM6DSV16X_16g:
      *Sensitivity = LSM6DSV16X_ACC_SENSITIVITY_FS_16G;
 800a984:	683b      	ldr	r3, [r7, #0]
 800a986:	4a09      	ldr	r2, [pc, #36]	@ (800a9ac <LSM6DSV16X_ACC_GetSensitivity+0x88>)
 800a988:	601a      	str	r2, [r3, #0]
      break;
 800a98a:	e003      	b.n	800a994 <LSM6DSV16X_ACC_GetSensitivity+0x70>

    default:
      ret = LSM6DSV16X_ERROR;
 800a98c:	f04f 33ff 	mov.w	r3, #4294967295
 800a990:	60fb      	str	r3, [r7, #12]
      break;
 800a992:	bf00      	nop
  }

  return ret;
 800a994:	68fb      	ldr	r3, [r7, #12]
}
 800a996:	4618      	mov	r0, r3
 800a998:	3710      	adds	r7, #16
 800a99a:	46bd      	mov	sp, r7
 800a99c:	bd80      	pop	{r7, pc}
 800a99e:	bf00      	nop
 800a9a0:	3d79db23 	.word	0x3d79db23
 800a9a4:	3df9db23 	.word	0x3df9db23
 800a9a8:	3e79db23 	.word	0x3e79db23
 800a9ac:	3ef9db23 	.word	0x3ef9db23

0800a9b0 <LSM6DSV16X_ACC_GetOutputDataRate>:
  * @param  pObj the device pObj
  * @param  Odr pointer where the output data rate is written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSV16X_ACC_GetOutputDataRate(LSM6DSV16X_Object_t *pObj, float *Odr)
{
 800a9b0:	b580      	push	{r7, lr}
 800a9b2:	b084      	sub	sp, #16
 800a9b4:	af00      	add	r7, sp, #0
 800a9b6:	6078      	str	r0, [r7, #4]
 800a9b8:	6039      	str	r1, [r7, #0]
  int32_t ret = LSM6DSV16X_OK;
 800a9ba:	2300      	movs	r3, #0
 800a9bc:	60fb      	str	r3, [r7, #12]
  lsm6dsv16x_data_rate_t odr_low_level;

  /* Get current output data rate */
  if (lsm6dsv16x_xl_data_rate_get(&(pObj->Ctx), &odr_low_level) != LSM6DSV16X_OK)
 800a9be:	687b      	ldr	r3, [r7, #4]
 800a9c0:	3320      	adds	r3, #32
 800a9c2:	f107 020b 	add.w	r2, r7, #11
 800a9c6:	4611      	mov	r1, r2
 800a9c8:	4618      	mov	r0, r3
 800a9ca:	f000 ff15 	bl	800b7f8 <lsm6dsv16x_xl_data_rate_get>
 800a9ce:	4603      	mov	r3, r0
 800a9d0:	2b00      	cmp	r3, #0
 800a9d2:	d002      	beq.n	800a9da <LSM6DSV16X_ACC_GetOutputDataRate+0x2a>
  {
    return LSM6DSV16X_ERROR;
 800a9d4:	f04f 33ff 	mov.w	r3, #4294967295
 800a9d8:	e05a      	b.n	800aa90 <LSM6DSV16X_ACC_GetOutputDataRate+0xe0>
  }

  switch (odr_low_level)
 800a9da:	7afb      	ldrb	r3, [r7, #11]
 800a9dc:	2b0c      	cmp	r3, #12
 800a9de:	d852      	bhi.n	800aa86 <LSM6DSV16X_ACC_GetOutputDataRate+0xd6>
 800a9e0:	a201      	add	r2, pc, #4	@ (adr r2, 800a9e8 <LSM6DSV16X_ACC_GetOutputDataRate+0x38>)
 800a9e2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800a9e6:	bf00      	nop
 800a9e8:	0800aa1d 	.word	0x0800aa1d
 800a9ec:	0800aa27 	.word	0x0800aa27
 800a9f0:	0800aa2f 	.word	0x0800aa2f
 800a9f4:	0800aa37 	.word	0x0800aa37
 800a9f8:	0800aa3f 	.word	0x0800aa3f
 800a9fc:	0800aa47 	.word	0x0800aa47
 800aa00:	0800aa4f 	.word	0x0800aa4f
 800aa04:	0800aa57 	.word	0x0800aa57
 800aa08:	0800aa5f 	.word	0x0800aa5f
 800aa0c:	0800aa67 	.word	0x0800aa67
 800aa10:	0800aa6f 	.word	0x0800aa6f
 800aa14:	0800aa77 	.word	0x0800aa77
 800aa18:	0800aa7f 	.word	0x0800aa7f
  {
    case LSM6DSV16X_ODR_OFF:
      *Odr = 0.0f;
 800aa1c:	683b      	ldr	r3, [r7, #0]
 800aa1e:	f04f 0200 	mov.w	r2, #0
 800aa22:	601a      	str	r2, [r3, #0]
      break;
 800aa24:	e033      	b.n	800aa8e <LSM6DSV16X_ACC_GetOutputDataRate+0xde>

    case LSM6DSV16X_ODR_AT_1Hz875:
      *Odr = 1.875f;
 800aa26:	683b      	ldr	r3, [r7, #0]
 800aa28:	4a1b      	ldr	r2, [pc, #108]	@ (800aa98 <LSM6DSV16X_ACC_GetOutputDataRate+0xe8>)
 800aa2a:	601a      	str	r2, [r3, #0]
      break;
 800aa2c:	e02f      	b.n	800aa8e <LSM6DSV16X_ACC_GetOutputDataRate+0xde>

    case LSM6DSV16X_ODR_AT_7Hz5:
      *Odr = 7.5f;
 800aa2e:	683b      	ldr	r3, [r7, #0]
 800aa30:	4a1a      	ldr	r2, [pc, #104]	@ (800aa9c <LSM6DSV16X_ACC_GetOutputDataRate+0xec>)
 800aa32:	601a      	str	r2, [r3, #0]
      break;
 800aa34:	e02b      	b.n	800aa8e <LSM6DSV16X_ACC_GetOutputDataRate+0xde>

    case LSM6DSV16X_ODR_AT_15Hz:
      *Odr = 15.0f;
 800aa36:	683b      	ldr	r3, [r7, #0]
 800aa38:	4a19      	ldr	r2, [pc, #100]	@ (800aaa0 <LSM6DSV16X_ACC_GetOutputDataRate+0xf0>)
 800aa3a:	601a      	str	r2, [r3, #0]
      break;
 800aa3c:	e027      	b.n	800aa8e <LSM6DSV16X_ACC_GetOutputDataRate+0xde>

    case LSM6DSV16X_ODR_AT_30Hz:
      *Odr = 30.0f;
 800aa3e:	683b      	ldr	r3, [r7, #0]
 800aa40:	4a18      	ldr	r2, [pc, #96]	@ (800aaa4 <LSM6DSV16X_ACC_GetOutputDataRate+0xf4>)
 800aa42:	601a      	str	r2, [r3, #0]
      break;
 800aa44:	e023      	b.n	800aa8e <LSM6DSV16X_ACC_GetOutputDataRate+0xde>

    case LSM6DSV16X_ODR_AT_60Hz:
      *Odr = 60.0f;
 800aa46:	683b      	ldr	r3, [r7, #0]
 800aa48:	4a17      	ldr	r2, [pc, #92]	@ (800aaa8 <LSM6DSV16X_ACC_GetOutputDataRate+0xf8>)
 800aa4a:	601a      	str	r2, [r3, #0]
      break;
 800aa4c:	e01f      	b.n	800aa8e <LSM6DSV16X_ACC_GetOutputDataRate+0xde>

    case LSM6DSV16X_ODR_AT_120Hz:
      *Odr = 120.0f;
 800aa4e:	683b      	ldr	r3, [r7, #0]
 800aa50:	4a16      	ldr	r2, [pc, #88]	@ (800aaac <LSM6DSV16X_ACC_GetOutputDataRate+0xfc>)
 800aa52:	601a      	str	r2, [r3, #0]
      break;
 800aa54:	e01b      	b.n	800aa8e <LSM6DSV16X_ACC_GetOutputDataRate+0xde>

    case LSM6DSV16X_ODR_AT_240Hz:
      *Odr = 240.0f;
 800aa56:	683b      	ldr	r3, [r7, #0]
 800aa58:	4a15      	ldr	r2, [pc, #84]	@ (800aab0 <LSM6DSV16X_ACC_GetOutputDataRate+0x100>)
 800aa5a:	601a      	str	r2, [r3, #0]
      break;
 800aa5c:	e017      	b.n	800aa8e <LSM6DSV16X_ACC_GetOutputDataRate+0xde>

    case LSM6DSV16X_ODR_AT_480Hz:
      *Odr = 480.0f;
 800aa5e:	683b      	ldr	r3, [r7, #0]
 800aa60:	4a14      	ldr	r2, [pc, #80]	@ (800aab4 <LSM6DSV16X_ACC_GetOutputDataRate+0x104>)
 800aa62:	601a      	str	r2, [r3, #0]
      break;
 800aa64:	e013      	b.n	800aa8e <LSM6DSV16X_ACC_GetOutputDataRate+0xde>

    case LSM6DSV16X_ODR_AT_960Hz:
      *Odr = 960.0f;
 800aa66:	683b      	ldr	r3, [r7, #0]
 800aa68:	4a13      	ldr	r2, [pc, #76]	@ (800aab8 <LSM6DSV16X_ACC_GetOutputDataRate+0x108>)
 800aa6a:	601a      	str	r2, [r3, #0]
      break;
 800aa6c:	e00f      	b.n	800aa8e <LSM6DSV16X_ACC_GetOutputDataRate+0xde>

    case LSM6DSV16X_ODR_AT_1920Hz:
      *Odr = 1920.0f;
 800aa6e:	683b      	ldr	r3, [r7, #0]
 800aa70:	4a12      	ldr	r2, [pc, #72]	@ (800aabc <LSM6DSV16X_ACC_GetOutputDataRate+0x10c>)
 800aa72:	601a      	str	r2, [r3, #0]
      break;
 800aa74:	e00b      	b.n	800aa8e <LSM6DSV16X_ACC_GetOutputDataRate+0xde>

    case LSM6DSV16X_ODR_AT_3840Hz:
      *Odr = 3840.0f;
 800aa76:	683b      	ldr	r3, [r7, #0]
 800aa78:	4a11      	ldr	r2, [pc, #68]	@ (800aac0 <LSM6DSV16X_ACC_GetOutputDataRate+0x110>)
 800aa7a:	601a      	str	r2, [r3, #0]
      break;
 800aa7c:	e007      	b.n	800aa8e <LSM6DSV16X_ACC_GetOutputDataRate+0xde>

    case LSM6DSV16X_ODR_AT_7680Hz:
      *Odr = 7680.0f;
 800aa7e:	683b      	ldr	r3, [r7, #0]
 800aa80:	4a10      	ldr	r2, [pc, #64]	@ (800aac4 <LSM6DSV16X_ACC_GetOutputDataRate+0x114>)
 800aa82:	601a      	str	r2, [r3, #0]
      break;
 800aa84:	e003      	b.n	800aa8e <LSM6DSV16X_ACC_GetOutputDataRate+0xde>

    default:
      ret = LSM6DSV16X_ERROR;
 800aa86:	f04f 33ff 	mov.w	r3, #4294967295
 800aa8a:	60fb      	str	r3, [r7, #12]
      break;
 800aa8c:	bf00      	nop
  }

  return ret;
 800aa8e:	68fb      	ldr	r3, [r7, #12]
}
 800aa90:	4618      	mov	r0, r3
 800aa92:	3710      	adds	r7, #16
 800aa94:	46bd      	mov	sp, r7
 800aa96:	bd80      	pop	{r7, pc}
 800aa98:	3ff00000 	.word	0x3ff00000
 800aa9c:	40f00000 	.word	0x40f00000
 800aaa0:	41700000 	.word	0x41700000
 800aaa4:	41f00000 	.word	0x41f00000
 800aaa8:	42700000 	.word	0x42700000
 800aaac:	42f00000 	.word	0x42f00000
 800aab0:	43700000 	.word	0x43700000
 800aab4:	43f00000 	.word	0x43f00000
 800aab8:	44700000 	.word	0x44700000
 800aabc:	44f00000 	.word	0x44f00000
 800aac0:	45700000 	.word	0x45700000
 800aac4:	45f00000 	.word	0x45f00000

0800aac8 <LSM6DSV16X_ACC_SetOutputDataRate>:
  * @param  pObj the device pObj
  * @param  Odr the output data rate value to be set
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSV16X_ACC_SetOutputDataRate(LSM6DSV16X_Object_t *pObj, float Odr)
{
 800aac8:	b580      	push	{r7, lr}
 800aaca:	b082      	sub	sp, #8
 800aacc:	af00      	add	r7, sp, #0
 800aace:	6078      	str	r0, [r7, #4]
 800aad0:	6039      	str	r1, [r7, #0]
  if (pObj->acc_is_enabled == 1U)
 800aad2:	687b      	ldr	r3, [r7, #4]
 800aad4:	f893 3031 	ldrb.w	r3, [r3, #49]	@ 0x31
 800aad8:	2b01      	cmp	r3, #1
 800aada:	d105      	bne.n	800aae8 <LSM6DSV16X_ACC_SetOutputDataRate+0x20>
  {
    return LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled(pObj, Odr);
 800aadc:	6839      	ldr	r1, [r7, #0]
 800aade:	6878      	ldr	r0, [r7, #4]
 800aae0:	f000 fb68 	bl	800b1b4 <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled>
 800aae4:	4603      	mov	r3, r0
 800aae6:	e004      	b.n	800aaf2 <LSM6DSV16X_ACC_SetOutputDataRate+0x2a>
  }
  else
  {
    return LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled(pObj, Odr);
 800aae8:	6839      	ldr	r1, [r7, #0]
 800aaea:	6878      	ldr	r0, [r7, #4]
 800aaec:	f000 fc02 	bl	800b2f4 <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled>
 800aaf0:	4603      	mov	r3, r0
  }
}
 800aaf2:	4618      	mov	r0, r3
 800aaf4:	3708      	adds	r7, #8
 800aaf6:	46bd      	mov	sp, r7
 800aaf8:	bd80      	pop	{r7, pc}
	...

0800aafc <LSM6DSV16X_ACC_GetFullScale>:
  * @param  pObj the device pObj
  * @param  FullScale pointer where the full scale is written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSV16X_ACC_GetFullScale(LSM6DSV16X_Object_t *pObj, int32_t *FullScale)
{
 800aafc:	b580      	push	{r7, lr}
 800aafe:	b084      	sub	sp, #16
 800ab00:	af00      	add	r7, sp, #0
 800ab02:	6078      	str	r0, [r7, #4]
 800ab04:	6039      	str	r1, [r7, #0]
  int32_t ret = LSM6DSV16X_OK;
 800ab06:	2300      	movs	r3, #0
 800ab08:	60fb      	str	r3, [r7, #12]
  lsm6dsv16x_xl_full_scale_t fs_low_level;

  /* Read actual full scale selection from sensor */
  if (lsm6dsv16x_xl_full_scale_get(&(pObj->Ctx), &fs_low_level) != LSM6DSV16X_OK)
 800ab0a:	687b      	ldr	r3, [r7, #4]
 800ab0c:	3320      	adds	r3, #32
 800ab0e:	f107 020b 	add.w	r2, r7, #11
 800ab12:	4611      	mov	r1, r2
 800ab14:	4618      	mov	r0, r3
 800ab16:	f001 f9cf 	bl	800beb8 <lsm6dsv16x_xl_full_scale_get>
 800ab1a:	4603      	mov	r3, r0
 800ab1c:	2b00      	cmp	r3, #0
 800ab1e:	d002      	beq.n	800ab26 <LSM6DSV16X_ACC_GetFullScale+0x2a>
  {
    return LSM6DSV16X_ERROR;
 800ab20:	f04f 33ff 	mov.w	r3, #4294967295
 800ab24:	e023      	b.n	800ab6e <LSM6DSV16X_ACC_GetFullScale+0x72>
  }

  switch (fs_low_level)
 800ab26:	7afb      	ldrb	r3, [r7, #11]
 800ab28:	2b03      	cmp	r3, #3
 800ab2a:	d81b      	bhi.n	800ab64 <LSM6DSV16X_ACC_GetFullScale+0x68>
 800ab2c:	a201      	add	r2, pc, #4	@ (adr r2, 800ab34 <LSM6DSV16X_ACC_GetFullScale+0x38>)
 800ab2e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800ab32:	bf00      	nop
 800ab34:	0800ab45 	.word	0x0800ab45
 800ab38:	0800ab4d 	.word	0x0800ab4d
 800ab3c:	0800ab55 	.word	0x0800ab55
 800ab40:	0800ab5d 	.word	0x0800ab5d
  {
    case LSM6DSV16X_2g:
      *FullScale =  2;
 800ab44:	683b      	ldr	r3, [r7, #0]
 800ab46:	2202      	movs	r2, #2
 800ab48:	601a      	str	r2, [r3, #0]
      break;
 800ab4a:	e00f      	b.n	800ab6c <LSM6DSV16X_ACC_GetFullScale+0x70>

    case LSM6DSV16X_4g:
      *FullScale =  4;
 800ab4c:	683b      	ldr	r3, [r7, #0]
 800ab4e:	2204      	movs	r2, #4
 800ab50:	601a      	str	r2, [r3, #0]
      break;
 800ab52:	e00b      	b.n	800ab6c <LSM6DSV16X_ACC_GetFullScale+0x70>

    case LSM6DSV16X_8g:
      *FullScale =  8;
 800ab54:	683b      	ldr	r3, [r7, #0]
 800ab56:	2208      	movs	r2, #8
 800ab58:	601a      	str	r2, [r3, #0]
      break;
 800ab5a:	e007      	b.n	800ab6c <LSM6DSV16X_ACC_GetFullScale+0x70>

    case LSM6DSV16X_16g:
      *FullScale = 16;
 800ab5c:	683b      	ldr	r3, [r7, #0]
 800ab5e:	2210      	movs	r2, #16
 800ab60:	601a      	str	r2, [r3, #0]
      break;
 800ab62:	e003      	b.n	800ab6c <LSM6DSV16X_ACC_GetFullScale+0x70>

    default:
      ret = LSM6DSV16X_ERROR;
 800ab64:	f04f 33ff 	mov.w	r3, #4294967295
 800ab68:	60fb      	str	r3, [r7, #12]
      break;
 800ab6a:	bf00      	nop
  }

  return ret;
 800ab6c:	68fb      	ldr	r3, [r7, #12]
}
 800ab6e:	4618      	mov	r0, r3
 800ab70:	3710      	adds	r7, #16
 800ab72:	46bd      	mov	sp, r7
 800ab74:	bd80      	pop	{r7, pc}
 800ab76:	bf00      	nop

0800ab78 <LSM6DSV16X_ACC_SetFullScale>:
  * @param  pObj the device pObj
  * @param  FullScale the functional full scale to be set
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSV16X_ACC_SetFullScale(LSM6DSV16X_Object_t *pObj, int32_t FullScale)
{
 800ab78:	b580      	push	{r7, lr}
 800ab7a:	b084      	sub	sp, #16
 800ab7c:	af00      	add	r7, sp, #0
 800ab7e:	6078      	str	r0, [r7, #4]
 800ab80:	6039      	str	r1, [r7, #0]
  lsm6dsv16x_xl_full_scale_t new_fs;

  /* Seems like MISRA C-2012 rule 14.3a violation but only from single file statical analysis point of view because
     the parameter passed to the function is not known at the moment of analysis */
  new_fs = (FullScale <= 2) ? LSM6DSV16X_2g
           : (FullScale <= 4) ? LSM6DSV16X_4g
 800ab82:	683b      	ldr	r3, [r7, #0]
 800ab84:	2b02      	cmp	r3, #2
 800ab86:	dd0b      	ble.n	800aba0 <LSM6DSV16X_ACC_SetFullScale+0x28>
 800ab88:	683b      	ldr	r3, [r7, #0]
 800ab8a:	2b04      	cmp	r3, #4
 800ab8c:	dd06      	ble.n	800ab9c <LSM6DSV16X_ACC_SetFullScale+0x24>
 800ab8e:	683b      	ldr	r3, [r7, #0]
 800ab90:	2b08      	cmp	r3, #8
 800ab92:	dc01      	bgt.n	800ab98 <LSM6DSV16X_ACC_SetFullScale+0x20>
 800ab94:	2302      	movs	r3, #2
 800ab96:	e004      	b.n	800aba2 <LSM6DSV16X_ACC_SetFullScale+0x2a>
 800ab98:	2303      	movs	r3, #3
 800ab9a:	e002      	b.n	800aba2 <LSM6DSV16X_ACC_SetFullScale+0x2a>
 800ab9c:	2301      	movs	r3, #1
 800ab9e:	e000      	b.n	800aba2 <LSM6DSV16X_ACC_SetFullScale+0x2a>
 800aba0:	2300      	movs	r3, #0
  new_fs = (FullScale <= 2) ? LSM6DSV16X_2g
 800aba2:	73fb      	strb	r3, [r7, #15]
           : (FullScale <= 8) ? LSM6DSV16X_8g
           :                    LSM6DSV16X_16g;

  if (lsm6dsv16x_xl_full_scale_set(&(pObj->Ctx), new_fs) != LSM6DSV16X_OK)
 800aba4:	687b      	ldr	r3, [r7, #4]
 800aba6:	3320      	adds	r3, #32
 800aba8:	7bfa      	ldrb	r2, [r7, #15]
 800abaa:	4611      	mov	r1, r2
 800abac:	4618      	mov	r0, r3
 800abae:	f001 f95d 	bl	800be6c <lsm6dsv16x_xl_full_scale_set>
 800abb2:	4603      	mov	r3, r0
 800abb4:	2b00      	cmp	r3, #0
 800abb6:	d002      	beq.n	800abbe <LSM6DSV16X_ACC_SetFullScale+0x46>
  {
    return LSM6DSV16X_ERROR;
 800abb8:	f04f 33ff 	mov.w	r3, #4294967295
 800abbc:	e000      	b.n	800abc0 <LSM6DSV16X_ACC_SetFullScale+0x48>
  }

  return LSM6DSV16X_OK;
 800abbe:	2300      	movs	r3, #0
}
 800abc0:	4618      	mov	r0, r3
 800abc2:	3710      	adds	r7, #16
 800abc4:	46bd      	mov	sp, r7
 800abc6:	bd80      	pop	{r7, pc}

0800abc8 <LSM6DSV16X_ACC_GetAxesRaw>:
  * @param  pObj the device pObj
  * @param  Value pointer where the raw values of the axes are written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSV16X_ACC_GetAxesRaw(LSM6DSV16X_Object_t *pObj, LSM6DSV16X_AxesRaw_t *Value)
{
 800abc8:	b580      	push	{r7, lr}
 800abca:	b084      	sub	sp, #16
 800abcc:	af00      	add	r7, sp, #0
 800abce:	6078      	str	r0, [r7, #4]
 800abd0:	6039      	str	r1, [r7, #0]
  lsm6dsv16x_axis3bit16_t data_raw;

  /* Read raw data values */
  if (lsm6dsv16x_acceleration_raw_get(&(pObj->Ctx), data_raw.i16bit) != LSM6DSV16X_OK)
 800abd2:	687b      	ldr	r3, [r7, #4]
 800abd4:	3320      	adds	r3, #32
 800abd6:	f107 0208 	add.w	r2, r7, #8
 800abda:	4611      	mov	r1, r2
 800abdc:	4618      	mov	r0, r3
 800abde:	f001 f9f6 	bl	800bfce <lsm6dsv16x_acceleration_raw_get>
 800abe2:	4603      	mov	r3, r0
 800abe4:	2b00      	cmp	r3, #0
 800abe6:	d002      	beq.n	800abee <LSM6DSV16X_ACC_GetAxesRaw+0x26>
  {
    return LSM6DSV16X_ERROR;
 800abe8:	f04f 33ff 	mov.w	r3, #4294967295
 800abec:	e00c      	b.n	800ac08 <LSM6DSV16X_ACC_GetAxesRaw+0x40>
  }

  /* Format the data */
  Value->x = data_raw.i16bit[0];
 800abee:	f9b7 2008 	ldrsh.w	r2, [r7, #8]
 800abf2:	683b      	ldr	r3, [r7, #0]
 800abf4:	801a      	strh	r2, [r3, #0]
  Value->y = data_raw.i16bit[1];
 800abf6:	f9b7 200a 	ldrsh.w	r2, [r7, #10]
 800abfa:	683b      	ldr	r3, [r7, #0]
 800abfc:	805a      	strh	r2, [r3, #2]
  Value->z = data_raw.i16bit[2];
 800abfe:	f9b7 200c 	ldrsh.w	r2, [r7, #12]
 800ac02:	683b      	ldr	r3, [r7, #0]
 800ac04:	809a      	strh	r2, [r3, #4]

  return LSM6DSV16X_OK;
 800ac06:	2300      	movs	r3, #0
}
 800ac08:	4618      	mov	r0, r3
 800ac0a:	3710      	adds	r7, #16
 800ac0c:	46bd      	mov	sp, r7
 800ac0e:	bd80      	pop	{r7, pc}

0800ac10 <LSM6DSV16X_ACC_GetAxes>:
  * @param  pObj the device pObj
  * @param  Acceleration pointer where the values of the axes are written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSV16X_ACC_GetAxes(LSM6DSV16X_Object_t *pObj, LSM6DSV16X_Axes_t *Acceleration)
{
 800ac10:	b580      	push	{r7, lr}
 800ac12:	b086      	sub	sp, #24
 800ac14:	af00      	add	r7, sp, #0
 800ac16:	6078      	str	r0, [r7, #4]
 800ac18:	6039      	str	r1, [r7, #0]
  lsm6dsv16x_axis3bit16_t data_raw;
  float sensitivity = 0.0f;
 800ac1a:	f04f 0300 	mov.w	r3, #0
 800ac1e:	60fb      	str	r3, [r7, #12]

  /* Read raw data values */
  if (lsm6dsv16x_acceleration_raw_get(&(pObj->Ctx), data_raw.i16bit) != LSM6DSV16X_OK)
 800ac20:	687b      	ldr	r3, [r7, #4]
 800ac22:	3320      	adds	r3, #32
 800ac24:	f107 0210 	add.w	r2, r7, #16
 800ac28:	4611      	mov	r1, r2
 800ac2a:	4618      	mov	r0, r3
 800ac2c:	f001 f9cf 	bl	800bfce <lsm6dsv16x_acceleration_raw_get>
 800ac30:	4603      	mov	r3, r0
 800ac32:	2b00      	cmp	r3, #0
 800ac34:	d002      	beq.n	800ac3c <LSM6DSV16X_ACC_GetAxes+0x2c>
  {
    return LSM6DSV16X_ERROR;
 800ac36:	f04f 33ff 	mov.w	r3, #4294967295
 800ac3a:	e03c      	b.n	800acb6 <LSM6DSV16X_ACC_GetAxes+0xa6>
  }

  /* Get LSM6DSV16X actual sensitivity */
  if (LSM6DSV16X_ACC_GetSensitivity(pObj, &sensitivity) != LSM6DSV16X_OK)
 800ac3c:	f107 030c 	add.w	r3, r7, #12
 800ac40:	4619      	mov	r1, r3
 800ac42:	6878      	ldr	r0, [r7, #4]
 800ac44:	f7ff fe6e 	bl	800a924 <LSM6DSV16X_ACC_GetSensitivity>
 800ac48:	4603      	mov	r3, r0
 800ac4a:	2b00      	cmp	r3, #0
 800ac4c:	d002      	beq.n	800ac54 <LSM6DSV16X_ACC_GetAxes+0x44>
  {
    return LSM6DSV16X_ERROR;
 800ac4e:	f04f 33ff 	mov.w	r3, #4294967295
 800ac52:	e030      	b.n	800acb6 <LSM6DSV16X_ACC_GetAxes+0xa6>
  }

  /* Calculate the data */
  Acceleration->x = (int32_t)((float)((float)data_raw.i16bit[0] * sensitivity));
 800ac54:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 800ac58:	ee07 3a90 	vmov	s15, r3
 800ac5c:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 800ac60:	edd7 7a03 	vldr	s15, [r7, #12]
 800ac64:	ee67 7a27 	vmul.f32	s15, s14, s15
 800ac68:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800ac6c:	ee17 2a90 	vmov	r2, s15
 800ac70:	683b      	ldr	r3, [r7, #0]
 800ac72:	601a      	str	r2, [r3, #0]
  Acceleration->y = (int32_t)((float)((float)data_raw.i16bit[1] * sensitivity));
 800ac74:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 800ac78:	ee07 3a90 	vmov	s15, r3
 800ac7c:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 800ac80:	edd7 7a03 	vldr	s15, [r7, #12]
 800ac84:	ee67 7a27 	vmul.f32	s15, s14, s15
 800ac88:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800ac8c:	ee17 2a90 	vmov	r2, s15
 800ac90:	683b      	ldr	r3, [r7, #0]
 800ac92:	605a      	str	r2, [r3, #4]
  Acceleration->z = (int32_t)((float)((float)data_raw.i16bit[2] * sensitivity));
 800ac94:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 800ac98:	ee07 3a90 	vmov	s15, r3
 800ac9c:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 800aca0:	edd7 7a03 	vldr	s15, [r7, #12]
 800aca4:	ee67 7a27 	vmul.f32	s15, s14, s15
 800aca8:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800acac:	ee17 2a90 	vmov	r2, s15
 800acb0:	683b      	ldr	r3, [r7, #0]
 800acb2:	609a      	str	r2, [r3, #8]

  return LSM6DSV16X_OK;
 800acb4:	2300      	movs	r3, #0
}
 800acb6:	4618      	mov	r0, r3
 800acb8:	3718      	adds	r7, #24
 800acba:	46bd      	mov	sp, r7
 800acbc:	bd80      	pop	{r7, pc}

0800acbe <LSM6DSV16X_GYRO_Enable>:
  * @brief  Enable the LSM6DSV16X gyroscope sensor
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSV16X_GYRO_Enable(LSM6DSV16X_Object_t *pObj)
{
 800acbe:	b580      	push	{r7, lr}
 800acc0:	b082      	sub	sp, #8
 800acc2:	af00      	add	r7, sp, #0
 800acc4:	6078      	str	r0, [r7, #4]
  /* Check if the component is already enabled */
  if (pObj->gyro_is_enabled == 1U)
 800acc6:	687b      	ldr	r3, [r7, #4]
 800acc8:	f893 3032 	ldrb.w	r3, [r3, #50]	@ 0x32
 800accc:	2b01      	cmp	r3, #1
 800acce:	d101      	bne.n	800acd4 <LSM6DSV16X_GYRO_Enable+0x16>
  {
    return LSM6DSV16X_OK;
 800acd0:	2300      	movs	r3, #0
 800acd2:	e014      	b.n	800acfe <LSM6DSV16X_GYRO_Enable+0x40>
  }

  /* Output data rate selection */
  if (lsm6dsv16x_gy_data_rate_set(&(pObj->Ctx), pObj->gyro_odr) != LSM6DSV16X_OK)
 800acd4:	687b      	ldr	r3, [r7, #4]
 800acd6:	f103 0220 	add.w	r2, r3, #32
 800acda:	687b      	ldr	r3, [r7, #4]
 800acdc:	f893 3034 	ldrb.w	r3, [r3, #52]	@ 0x34
 800ace0:	4619      	mov	r1, r3
 800ace2:	4610      	mov	r0, r2
 800ace4:	f000 fe98 	bl	800ba18 <lsm6dsv16x_gy_data_rate_set>
 800ace8:	4603      	mov	r3, r0
 800acea:	2b00      	cmp	r3, #0
 800acec:	d002      	beq.n	800acf4 <LSM6DSV16X_GYRO_Enable+0x36>
  {
    return LSM6DSV16X_ERROR;
 800acee:	f04f 33ff 	mov.w	r3, #4294967295
 800acf2:	e004      	b.n	800acfe <LSM6DSV16X_GYRO_Enable+0x40>
  }

  pObj->gyro_is_enabled = 1;
 800acf4:	687b      	ldr	r3, [r7, #4]
 800acf6:	2201      	movs	r2, #1
 800acf8:	f883 2032 	strb.w	r2, [r3, #50]	@ 0x32

  return LSM6DSV16X_OK;
 800acfc:	2300      	movs	r3, #0
}
 800acfe:	4618      	mov	r0, r3
 800ad00:	3708      	adds	r7, #8
 800ad02:	46bd      	mov	sp, r7
 800ad04:	bd80      	pop	{r7, pc}

0800ad06 <LSM6DSV16X_GYRO_Disable>:
  * @brief  Disable the LSM6DSV16X gyroscope sensor
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSV16X_GYRO_Disable(LSM6DSV16X_Object_t *pObj)
{
 800ad06:	b580      	push	{r7, lr}
 800ad08:	b082      	sub	sp, #8
 800ad0a:	af00      	add	r7, sp, #0
 800ad0c:	6078      	str	r0, [r7, #4]
  /* Check if the component is already disabled */
  if (pObj->gyro_is_enabled == 0U)
 800ad0e:	687b      	ldr	r3, [r7, #4]
 800ad10:	f893 3032 	ldrb.w	r3, [r3, #50]	@ 0x32
 800ad14:	2b00      	cmp	r3, #0
 800ad16:	d101      	bne.n	800ad1c <LSM6DSV16X_GYRO_Disable+0x16>
  {
    return LSM6DSV16X_OK;
 800ad18:	2300      	movs	r3, #0
 800ad1a:	e01f      	b.n	800ad5c <LSM6DSV16X_GYRO_Disable+0x56>
  }

  /* Get current output data rate */
  if (lsm6dsv16x_gy_data_rate_get(&(pObj->Ctx), &pObj->gyro_odr) != LSM6DSV16X_OK)
 800ad1c:	687b      	ldr	r3, [r7, #4]
 800ad1e:	f103 0220 	add.w	r2, r3, #32
 800ad22:	687b      	ldr	r3, [r7, #4]
 800ad24:	3334      	adds	r3, #52	@ 0x34
 800ad26:	4619      	mov	r1, r3
 800ad28:	4610      	mov	r0, r2
 800ad2a:	f000 fec5 	bl	800bab8 <lsm6dsv16x_gy_data_rate_get>
 800ad2e:	4603      	mov	r3, r0
 800ad30:	2b00      	cmp	r3, #0
 800ad32:	d002      	beq.n	800ad3a <LSM6DSV16X_GYRO_Disable+0x34>
  {
    return LSM6DSV16X_ERROR;
 800ad34:	f04f 33ff 	mov.w	r3, #4294967295
 800ad38:	e010      	b.n	800ad5c <LSM6DSV16X_GYRO_Disable+0x56>
  }

  /* Output data rate selection - power down */
  if (lsm6dsv16x_gy_data_rate_set(&(pObj->Ctx), LSM6DSV16X_ODR_OFF) != LSM6DSV16X_OK)
 800ad3a:	687b      	ldr	r3, [r7, #4]
 800ad3c:	3320      	adds	r3, #32
 800ad3e:	2100      	movs	r1, #0
 800ad40:	4618      	mov	r0, r3
 800ad42:	f000 fe69 	bl	800ba18 <lsm6dsv16x_gy_data_rate_set>
 800ad46:	4603      	mov	r3, r0
 800ad48:	2b00      	cmp	r3, #0
 800ad4a:	d002      	beq.n	800ad52 <LSM6DSV16X_GYRO_Disable+0x4c>
  {
    return LSM6DSV16X_ERROR;
 800ad4c:	f04f 33ff 	mov.w	r3, #4294967295
 800ad50:	e004      	b.n	800ad5c <LSM6DSV16X_GYRO_Disable+0x56>
  }

  pObj->gyro_is_enabled = 0;
 800ad52:	687b      	ldr	r3, [r7, #4]
 800ad54:	2200      	movs	r2, #0
 800ad56:	f883 2032 	strb.w	r2, [r3, #50]	@ 0x32

  return LSM6DSV16X_OK;
 800ad5a:	2300      	movs	r3, #0
}
 800ad5c:	4618      	mov	r0, r3
 800ad5e:	3708      	adds	r7, #8
 800ad60:	46bd      	mov	sp, r7
 800ad62:	bd80      	pop	{r7, pc}

0800ad64 <LSM6DSV16X_GYRO_GetSensitivity>:
  * @param  pObj the device pObj
  * @param  Sensitivity pointer
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSV16X_GYRO_GetSensitivity(LSM6DSV16X_Object_t *pObj, float *Sensitivity)
{
 800ad64:	b580      	push	{r7, lr}
 800ad66:	b084      	sub	sp, #16
 800ad68:	af00      	add	r7, sp, #0
 800ad6a:	6078      	str	r0, [r7, #4]
 800ad6c:	6039      	str	r1, [r7, #0]
  int32_t ret = LSM6DSV16X_OK;
 800ad6e:	2300      	movs	r3, #0
 800ad70:	60fb      	str	r3, [r7, #12]
  lsm6dsv16x_gy_full_scale_t full_scale;

  /* Read actual full scale selection from sensor */
  if (lsm6dsv16x_gy_full_scale_get(&(pObj->Ctx), &full_scale) != LSM6DSV16X_OK)
 800ad72:	687b      	ldr	r3, [r7, #4]
 800ad74:	3320      	adds	r3, #32
 800ad76:	f107 020b 	add.w	r2, r7, #11
 800ad7a:	4611      	mov	r1, r2
 800ad7c:	4618      	mov	r0, r3
 800ad7e:	f001 f81d 	bl	800bdbc <lsm6dsv16x_gy_full_scale_get>
 800ad82:	4603      	mov	r3, r0
 800ad84:	2b00      	cmp	r3, #0
 800ad86:	d002      	beq.n	800ad8e <LSM6DSV16X_GYRO_GetSensitivity+0x2a>
  {
    return LSM6DSV16X_ERROR;
 800ad88:	f04f 33ff 	mov.w	r3, #4294967295
 800ad8c:	e03d      	b.n	800ae0a <LSM6DSV16X_GYRO_GetSensitivity+0xa6>
  }

  /* Store the sensitivity based on actual full scale */
  switch (full_scale)
 800ad8e:	7afb      	ldrb	r3, [r7, #11]
 800ad90:	2b0c      	cmp	r3, #12
 800ad92:	d835      	bhi.n	800ae00 <LSM6DSV16X_GYRO_GetSensitivity+0x9c>
 800ad94:	a201      	add	r2, pc, #4	@ (adr r2, 800ad9c <LSM6DSV16X_GYRO_GetSensitivity+0x38>)
 800ad96:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800ad9a:	bf00      	nop
 800ad9c:	0800add1 	.word	0x0800add1
 800ada0:	0800add9 	.word	0x0800add9
 800ada4:	0800ade1 	.word	0x0800ade1
 800ada8:	0800ade9 	.word	0x0800ade9
 800adac:	0800adf1 	.word	0x0800adf1
 800adb0:	0800ae01 	.word	0x0800ae01
 800adb4:	0800ae01 	.word	0x0800ae01
 800adb8:	0800ae01 	.word	0x0800ae01
 800adbc:	0800ae01 	.word	0x0800ae01
 800adc0:	0800ae01 	.word	0x0800ae01
 800adc4:	0800ae01 	.word	0x0800ae01
 800adc8:	0800ae01 	.word	0x0800ae01
 800adcc:	0800adf9 	.word	0x0800adf9
  {
    case LSM6DSV16X_125dps:
      *Sensitivity = LSM6DSV16X_GYRO_SENSITIVITY_FS_125DPS;
 800add0:	683b      	ldr	r3, [r7, #0]
 800add2:	4a10      	ldr	r2, [pc, #64]	@ (800ae14 <LSM6DSV16X_GYRO_GetSensitivity+0xb0>)
 800add4:	601a      	str	r2, [r3, #0]
      break;
 800add6:	e017      	b.n	800ae08 <LSM6DSV16X_GYRO_GetSensitivity+0xa4>

    case LSM6DSV16X_250dps:
      *Sensitivity = LSM6DSV16X_GYRO_SENSITIVITY_FS_250DPS;
 800add8:	683b      	ldr	r3, [r7, #0]
 800adda:	4a0f      	ldr	r2, [pc, #60]	@ (800ae18 <LSM6DSV16X_GYRO_GetSensitivity+0xb4>)
 800addc:	601a      	str	r2, [r3, #0]
      break;
 800adde:	e013      	b.n	800ae08 <LSM6DSV16X_GYRO_GetSensitivity+0xa4>

    case LSM6DSV16X_500dps:
      *Sensitivity = LSM6DSV16X_GYRO_SENSITIVITY_FS_500DPS;
 800ade0:	683b      	ldr	r3, [r7, #0]
 800ade2:	4a0e      	ldr	r2, [pc, #56]	@ (800ae1c <LSM6DSV16X_GYRO_GetSensitivity+0xb8>)
 800ade4:	601a      	str	r2, [r3, #0]
      break;
 800ade6:	e00f      	b.n	800ae08 <LSM6DSV16X_GYRO_GetSensitivity+0xa4>

    case LSM6DSV16X_1000dps:
      *Sensitivity = LSM6DSV16X_GYRO_SENSITIVITY_FS_1000DPS;
 800ade8:	683b      	ldr	r3, [r7, #0]
 800adea:	4a0d      	ldr	r2, [pc, #52]	@ (800ae20 <LSM6DSV16X_GYRO_GetSensitivity+0xbc>)
 800adec:	601a      	str	r2, [r3, #0]
      break;
 800adee:	e00b      	b.n	800ae08 <LSM6DSV16X_GYRO_GetSensitivity+0xa4>

    case LSM6DSV16X_2000dps:
      *Sensitivity = LSM6DSV16X_GYRO_SENSITIVITY_FS_2000DPS;
 800adf0:	683b      	ldr	r3, [r7, #0]
 800adf2:	4a0c      	ldr	r2, [pc, #48]	@ (800ae24 <LSM6DSV16X_GYRO_GetSensitivity+0xc0>)
 800adf4:	601a      	str	r2, [r3, #0]
      break;
 800adf6:	e007      	b.n	800ae08 <LSM6DSV16X_GYRO_GetSensitivity+0xa4>

    case LSM6DSV16X_4000dps:
      *Sensitivity = LSM6DSV16X_GYRO_SENSITIVITY_FS_4000DPS;
 800adf8:	683b      	ldr	r3, [r7, #0]
 800adfa:	4a0b      	ldr	r2, [pc, #44]	@ (800ae28 <LSM6DSV16X_GYRO_GetSensitivity+0xc4>)
 800adfc:	601a      	str	r2, [r3, #0]
      break;
 800adfe:	e003      	b.n	800ae08 <LSM6DSV16X_GYRO_GetSensitivity+0xa4>

    default:
      ret = LSM6DSV16X_ERROR;
 800ae00:	f04f 33ff 	mov.w	r3, #4294967295
 800ae04:	60fb      	str	r3, [r7, #12]
      break;
 800ae06:	bf00      	nop
  }

  return ret;
 800ae08:	68fb      	ldr	r3, [r7, #12]
}
 800ae0a:	4618      	mov	r0, r3
 800ae0c:	3710      	adds	r7, #16
 800ae0e:	46bd      	mov	sp, r7
 800ae10:	bd80      	pop	{r7, pc}
 800ae12:	bf00      	nop
 800ae14:	408c0000 	.word	0x408c0000
 800ae18:	410c0000 	.word	0x410c0000
 800ae1c:	418c0000 	.word	0x418c0000
 800ae20:	420c0000 	.word	0x420c0000
 800ae24:	428c0000 	.word	0x428c0000
 800ae28:	430c0000 	.word	0x430c0000

0800ae2c <LSM6DSV16X_GYRO_GetOutputDataRate>:
  * @param  pObj the device pObj
  * @param  Odr pointer where the output data rate is written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSV16X_GYRO_GetOutputDataRate(LSM6DSV16X_Object_t *pObj, float *Odr)
{
 800ae2c:	b580      	push	{r7, lr}
 800ae2e:	b084      	sub	sp, #16
 800ae30:	af00      	add	r7, sp, #0
 800ae32:	6078      	str	r0, [r7, #4]
 800ae34:	6039      	str	r1, [r7, #0]
  int32_t ret = LSM6DSV16X_OK;
 800ae36:	2300      	movs	r3, #0
 800ae38:	60fb      	str	r3, [r7, #12]
  lsm6dsv16x_data_rate_t odr_low_level;

  /* Get current output data rate */
  if (lsm6dsv16x_gy_data_rate_get(&(pObj->Ctx), &odr_low_level) != LSM6DSV16X_OK)
 800ae3a:	687b      	ldr	r3, [r7, #4]
 800ae3c:	3320      	adds	r3, #32
 800ae3e:	f107 020b 	add.w	r2, r7, #11
 800ae42:	4611      	mov	r1, r2
 800ae44:	4618      	mov	r0, r3
 800ae46:	f000 fe37 	bl	800bab8 <lsm6dsv16x_gy_data_rate_get>
 800ae4a:	4603      	mov	r3, r0
 800ae4c:	2b00      	cmp	r3, #0
 800ae4e:	d002      	beq.n	800ae56 <LSM6DSV16X_GYRO_GetOutputDataRate+0x2a>
  {
    return LSM6DSV16X_ERROR;
 800ae50:	f04f 33ff 	mov.w	r3, #4294967295
 800ae54:	e056      	b.n	800af04 <LSM6DSV16X_GYRO_GetOutputDataRate+0xd8>
  }

  switch (odr_low_level)
 800ae56:	7afb      	ldrb	r3, [r7, #11]
 800ae58:	2b0c      	cmp	r3, #12
 800ae5a:	d84e      	bhi.n	800aefa <LSM6DSV16X_GYRO_GetOutputDataRate+0xce>
 800ae5c:	a201      	add	r2, pc, #4	@ (adr r2, 800ae64 <LSM6DSV16X_GYRO_GetOutputDataRate+0x38>)
 800ae5e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800ae62:	bf00      	nop
 800ae64:	0800ae99 	.word	0x0800ae99
 800ae68:	0800aefb 	.word	0x0800aefb
 800ae6c:	0800aea3 	.word	0x0800aea3
 800ae70:	0800aeab 	.word	0x0800aeab
 800ae74:	0800aeb3 	.word	0x0800aeb3
 800ae78:	0800aebb 	.word	0x0800aebb
 800ae7c:	0800aec3 	.word	0x0800aec3
 800ae80:	0800aecb 	.word	0x0800aecb
 800ae84:	0800aed3 	.word	0x0800aed3
 800ae88:	0800aedb 	.word	0x0800aedb
 800ae8c:	0800aee3 	.word	0x0800aee3
 800ae90:	0800aeeb 	.word	0x0800aeeb
 800ae94:	0800aef3 	.word	0x0800aef3
  {
    case LSM6DSV16X_ODR_OFF:
      *Odr = 0.0f;
 800ae98:	683b      	ldr	r3, [r7, #0]
 800ae9a:	f04f 0200 	mov.w	r2, #0
 800ae9e:	601a      	str	r2, [r3, #0]
      break;
 800aea0:	e02f      	b.n	800af02 <LSM6DSV16X_GYRO_GetOutputDataRate+0xd6>

    case LSM6DSV16X_ODR_AT_7Hz5:
      *Odr = 7.5f;
 800aea2:	683b      	ldr	r3, [r7, #0]
 800aea4:	4a19      	ldr	r2, [pc, #100]	@ (800af0c <LSM6DSV16X_GYRO_GetOutputDataRate+0xe0>)
 800aea6:	601a      	str	r2, [r3, #0]
      break;
 800aea8:	e02b      	b.n	800af02 <LSM6DSV16X_GYRO_GetOutputDataRate+0xd6>

    case LSM6DSV16X_ODR_AT_15Hz:
      *Odr = 15.0f;
 800aeaa:	683b      	ldr	r3, [r7, #0]
 800aeac:	4a18      	ldr	r2, [pc, #96]	@ (800af10 <LSM6DSV16X_GYRO_GetOutputDataRate+0xe4>)
 800aeae:	601a      	str	r2, [r3, #0]
      break;
 800aeb0:	e027      	b.n	800af02 <LSM6DSV16X_GYRO_GetOutputDataRate+0xd6>

    case LSM6DSV16X_ODR_AT_30Hz:
      *Odr = 30.0f;
 800aeb2:	683b      	ldr	r3, [r7, #0]
 800aeb4:	4a17      	ldr	r2, [pc, #92]	@ (800af14 <LSM6DSV16X_GYRO_GetOutputDataRate+0xe8>)
 800aeb6:	601a      	str	r2, [r3, #0]
      break;
 800aeb8:	e023      	b.n	800af02 <LSM6DSV16X_GYRO_GetOutputDataRate+0xd6>

    case LSM6DSV16X_ODR_AT_60Hz:
      *Odr = 60.0f;
 800aeba:	683b      	ldr	r3, [r7, #0]
 800aebc:	4a16      	ldr	r2, [pc, #88]	@ (800af18 <LSM6DSV16X_GYRO_GetOutputDataRate+0xec>)
 800aebe:	601a      	str	r2, [r3, #0]
      break;
 800aec0:	e01f      	b.n	800af02 <LSM6DSV16X_GYRO_GetOutputDataRate+0xd6>

    case LSM6DSV16X_ODR_AT_120Hz:
      *Odr = 120.0f;
 800aec2:	683b      	ldr	r3, [r7, #0]
 800aec4:	4a15      	ldr	r2, [pc, #84]	@ (800af1c <LSM6DSV16X_GYRO_GetOutputDataRate+0xf0>)
 800aec6:	601a      	str	r2, [r3, #0]
      break;
 800aec8:	e01b      	b.n	800af02 <LSM6DSV16X_GYRO_GetOutputDataRate+0xd6>

    case LSM6DSV16X_ODR_AT_240Hz:
      *Odr = 240.0f;
 800aeca:	683b      	ldr	r3, [r7, #0]
 800aecc:	4a14      	ldr	r2, [pc, #80]	@ (800af20 <LSM6DSV16X_GYRO_GetOutputDataRate+0xf4>)
 800aece:	601a      	str	r2, [r3, #0]
      break;
 800aed0:	e017      	b.n	800af02 <LSM6DSV16X_GYRO_GetOutputDataRate+0xd6>

    case LSM6DSV16X_ODR_AT_480Hz:
      *Odr = 480.0f;
 800aed2:	683b      	ldr	r3, [r7, #0]
 800aed4:	4a13      	ldr	r2, [pc, #76]	@ (800af24 <LSM6DSV16X_GYRO_GetOutputDataRate+0xf8>)
 800aed6:	601a      	str	r2, [r3, #0]
      break;
 800aed8:	e013      	b.n	800af02 <LSM6DSV16X_GYRO_GetOutputDataRate+0xd6>

    case LSM6DSV16X_ODR_AT_960Hz:
      *Odr = 960.0f;
 800aeda:	683b      	ldr	r3, [r7, #0]
 800aedc:	4a12      	ldr	r2, [pc, #72]	@ (800af28 <LSM6DSV16X_GYRO_GetOutputDataRate+0xfc>)
 800aede:	601a      	str	r2, [r3, #0]
      break;
 800aee0:	e00f      	b.n	800af02 <LSM6DSV16X_GYRO_GetOutputDataRate+0xd6>

    case LSM6DSV16X_ODR_AT_1920Hz:
      *Odr = 1920.0f;
 800aee2:	683b      	ldr	r3, [r7, #0]
 800aee4:	4a11      	ldr	r2, [pc, #68]	@ (800af2c <LSM6DSV16X_GYRO_GetOutputDataRate+0x100>)
 800aee6:	601a      	str	r2, [r3, #0]
      break;
 800aee8:	e00b      	b.n	800af02 <LSM6DSV16X_GYRO_GetOutputDataRate+0xd6>

    case LSM6DSV16X_ODR_AT_3840Hz:
      *Odr = 3840.0f;
 800aeea:	683b      	ldr	r3, [r7, #0]
 800aeec:	4a10      	ldr	r2, [pc, #64]	@ (800af30 <LSM6DSV16X_GYRO_GetOutputDataRate+0x104>)
 800aeee:	601a      	str	r2, [r3, #0]
      break;
 800aef0:	e007      	b.n	800af02 <LSM6DSV16X_GYRO_GetOutputDataRate+0xd6>

    case LSM6DSV16X_ODR_AT_7680Hz:
      *Odr = 7680.0f;
 800aef2:	683b      	ldr	r3, [r7, #0]
 800aef4:	4a0f      	ldr	r2, [pc, #60]	@ (800af34 <LSM6DSV16X_GYRO_GetOutputDataRate+0x108>)
 800aef6:	601a      	str	r2, [r3, #0]
      break;
 800aef8:	e003      	b.n	800af02 <LSM6DSV16X_GYRO_GetOutputDataRate+0xd6>

    default:
      ret = LSM6DSV16X_ERROR;
 800aefa:	f04f 33ff 	mov.w	r3, #4294967295
 800aefe:	60fb      	str	r3, [r7, #12]
      break;
 800af00:	bf00      	nop
  }

  return ret;
 800af02:	68fb      	ldr	r3, [r7, #12]
}
 800af04:	4618      	mov	r0, r3
 800af06:	3710      	adds	r7, #16
 800af08:	46bd      	mov	sp, r7
 800af0a:	bd80      	pop	{r7, pc}
 800af0c:	40f00000 	.word	0x40f00000
 800af10:	41700000 	.word	0x41700000
 800af14:	41f00000 	.word	0x41f00000
 800af18:	42700000 	.word	0x42700000
 800af1c:	42f00000 	.word	0x42f00000
 800af20:	43700000 	.word	0x43700000
 800af24:	43f00000 	.word	0x43f00000
 800af28:	44700000 	.word	0x44700000
 800af2c:	44f00000 	.word	0x44f00000
 800af30:	45700000 	.word	0x45700000
 800af34:	45f00000 	.word	0x45f00000

0800af38 <LSM6DSV16X_GYRO_SetOutputDataRate>:
  * @param  pObj the device pObj
  * @param  Odr the output data rate value to be set
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSV16X_GYRO_SetOutputDataRate(LSM6DSV16X_Object_t *pObj, float Odr)
{
 800af38:	b580      	push	{r7, lr}
 800af3a:	b082      	sub	sp, #8
 800af3c:	af00      	add	r7, sp, #0
 800af3e:	6078      	str	r0, [r7, #4]
 800af40:	6039      	str	r1, [r7, #0]
  if (pObj->gyro_is_enabled == 1U)
 800af42:	687b      	ldr	r3, [r7, #4]
 800af44:	f893 3032 	ldrb.w	r3, [r3, #50]	@ 0x32
 800af48:	2b01      	cmp	r3, #1
 800af4a:	d105      	bne.n	800af58 <LSM6DSV16X_GYRO_SetOutputDataRate+0x20>
  {
    return LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled(pObj, Odr);
 800af4c:	6839      	ldr	r1, [r7, #0]
 800af4e:	6878      	ldr	r0, [r7, #4]
 800af50:	f000 fa68 	bl	800b424 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled>
 800af54:	4603      	mov	r3, r0
 800af56:	e004      	b.n	800af62 <LSM6DSV16X_GYRO_SetOutputDataRate+0x2a>
  }
  else
  {
    return LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled(pObj, Odr);
 800af58:	6839      	ldr	r1, [r7, #0]
 800af5a:	6878      	ldr	r0, [r7, #4]
 800af5c:	f000 faf8 	bl	800b550 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled>
 800af60:	4603      	mov	r3, r0
  }
}
 800af62:	4618      	mov	r0, r3
 800af64:	3708      	adds	r7, #8
 800af66:	46bd      	mov	sp, r7
 800af68:	bd80      	pop	{r7, pc}
	...

0800af6c <LSM6DSV16X_GYRO_GetFullScale>:
  * @param  pObj the device pObj
  * @param  FullScale pointer where the full scale is written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSV16X_GYRO_GetFullScale(LSM6DSV16X_Object_t *pObj, int32_t  *FullScale)
{
 800af6c:	b580      	push	{r7, lr}
 800af6e:	b084      	sub	sp, #16
 800af70:	af00      	add	r7, sp, #0
 800af72:	6078      	str	r0, [r7, #4]
 800af74:	6039      	str	r1, [r7, #0]
  int32_t ret = LSM6DSV16X_OK;
 800af76:	2300      	movs	r3, #0
 800af78:	60fb      	str	r3, [r7, #12]
  lsm6dsv16x_gy_full_scale_t fs_low_level;

  /* Read actual full scale selection from sensor */
  if (lsm6dsv16x_gy_full_scale_get(&(pObj->Ctx), &fs_low_level) != LSM6DSV16X_OK)
 800af7a:	687b      	ldr	r3, [r7, #4]
 800af7c:	3320      	adds	r3, #32
 800af7e:	f107 020b 	add.w	r2, r7, #11
 800af82:	4611      	mov	r1, r2
 800af84:	4618      	mov	r0, r3
 800af86:	f000 ff19 	bl	800bdbc <lsm6dsv16x_gy_full_scale_get>
 800af8a:	4603      	mov	r3, r0
 800af8c:	2b00      	cmp	r3, #0
 800af8e:	d002      	beq.n	800af96 <LSM6DSV16X_GYRO_GetFullScale+0x2a>
  {
    return LSM6DSV16X_ERROR;
 800af90:	f04f 33ff 	mov.w	r3, #4294967295
 800af94:	e041      	b.n	800b01a <LSM6DSV16X_GYRO_GetFullScale+0xae>
  }

  switch (fs_low_level)
 800af96:	7afb      	ldrb	r3, [r7, #11]
 800af98:	2b0c      	cmp	r3, #12
 800af9a:	d839      	bhi.n	800b010 <LSM6DSV16X_GYRO_GetFullScale+0xa4>
 800af9c:	a201      	add	r2, pc, #4	@ (adr r2, 800afa4 <LSM6DSV16X_GYRO_GetFullScale+0x38>)
 800af9e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800afa2:	bf00      	nop
 800afa4:	0800afd9 	.word	0x0800afd9
 800afa8:	0800afe1 	.word	0x0800afe1
 800afac:	0800afe9 	.word	0x0800afe9
 800afb0:	0800aff3 	.word	0x0800aff3
 800afb4:	0800affd 	.word	0x0800affd
 800afb8:	0800b011 	.word	0x0800b011
 800afbc:	0800b011 	.word	0x0800b011
 800afc0:	0800b011 	.word	0x0800b011
 800afc4:	0800b011 	.word	0x0800b011
 800afc8:	0800b011 	.word	0x0800b011
 800afcc:	0800b011 	.word	0x0800b011
 800afd0:	0800b011 	.word	0x0800b011
 800afd4:	0800b007 	.word	0x0800b007
  {
    case LSM6DSV16X_125dps:
      *FullScale =  125;
 800afd8:	683b      	ldr	r3, [r7, #0]
 800afda:	227d      	movs	r2, #125	@ 0x7d
 800afdc:	601a      	str	r2, [r3, #0]
      break;
 800afde:	e01b      	b.n	800b018 <LSM6DSV16X_GYRO_GetFullScale+0xac>

    case LSM6DSV16X_250dps:
      *FullScale =  250;
 800afe0:	683b      	ldr	r3, [r7, #0]
 800afe2:	22fa      	movs	r2, #250	@ 0xfa
 800afe4:	601a      	str	r2, [r3, #0]
      break;
 800afe6:	e017      	b.n	800b018 <LSM6DSV16X_GYRO_GetFullScale+0xac>

    case LSM6DSV16X_500dps:
      *FullScale =  500;
 800afe8:	683b      	ldr	r3, [r7, #0]
 800afea:	f44f 72fa 	mov.w	r2, #500	@ 0x1f4
 800afee:	601a      	str	r2, [r3, #0]
      break;
 800aff0:	e012      	b.n	800b018 <LSM6DSV16X_GYRO_GetFullScale+0xac>

    case LSM6DSV16X_1000dps:
      *FullScale = 1000;
 800aff2:	683b      	ldr	r3, [r7, #0]
 800aff4:	f44f 727a 	mov.w	r2, #1000	@ 0x3e8
 800aff8:	601a      	str	r2, [r3, #0]
      break;
 800affa:	e00d      	b.n	800b018 <LSM6DSV16X_GYRO_GetFullScale+0xac>

    case LSM6DSV16X_2000dps:
      *FullScale = 2000;
 800affc:	683b      	ldr	r3, [r7, #0]
 800affe:	f44f 62fa 	mov.w	r2, #2000	@ 0x7d0
 800b002:	601a      	str	r2, [r3, #0]
      break;
 800b004:	e008      	b.n	800b018 <LSM6DSV16X_GYRO_GetFullScale+0xac>

    case LSM6DSV16X_4000dps:
      *FullScale = 4000;
 800b006:	683b      	ldr	r3, [r7, #0]
 800b008:	f44f 627a 	mov.w	r2, #4000	@ 0xfa0
 800b00c:	601a      	str	r2, [r3, #0]
      break;
 800b00e:	e003      	b.n	800b018 <LSM6DSV16X_GYRO_GetFullScale+0xac>

    default:
      ret = LSM6DSV16X_ERROR;
 800b010:	f04f 33ff 	mov.w	r3, #4294967295
 800b014:	60fb      	str	r3, [r7, #12]
      break;
 800b016:	bf00      	nop
  }

  return ret;
 800b018:	68fb      	ldr	r3, [r7, #12]
}
 800b01a:	4618      	mov	r0, r3
 800b01c:	3710      	adds	r7, #16
 800b01e:	46bd      	mov	sp, r7
 800b020:	bd80      	pop	{r7, pc}
 800b022:	bf00      	nop

0800b024 <LSM6DSV16X_GYRO_SetFullScale>:
  * @param  pObj the device pObj
  * @param  FullScale the functional full scale to be set
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSV16X_GYRO_SetFullScale(LSM6DSV16X_Object_t *pObj, int32_t FullScale)
{
 800b024:	b580      	push	{r7, lr}
 800b026:	b084      	sub	sp, #16
 800b028:	af00      	add	r7, sp, #0
 800b02a:	6078      	str	r0, [r7, #4]
 800b02c:	6039      	str	r1, [r7, #0]
  lsm6dsv16x_gy_full_scale_t new_fs;

  new_fs = (FullScale <= 125)  ? LSM6DSV16X_125dps
           : (FullScale <= 250)  ? LSM6DSV16X_250dps
 800b02e:	683b      	ldr	r3, [r7, #0]
 800b030:	2b7d      	cmp	r3, #125	@ 0x7d
 800b032:	dd18      	ble.n	800b066 <LSM6DSV16X_GYRO_SetFullScale+0x42>
 800b034:	683b      	ldr	r3, [r7, #0]
 800b036:	2bfa      	cmp	r3, #250	@ 0xfa
 800b038:	dd13      	ble.n	800b062 <LSM6DSV16X_GYRO_SetFullScale+0x3e>
 800b03a:	683b      	ldr	r3, [r7, #0]
 800b03c:	f5b3 7ffa 	cmp.w	r3, #500	@ 0x1f4
 800b040:	dd0d      	ble.n	800b05e <LSM6DSV16X_GYRO_SetFullScale+0x3a>
 800b042:	683b      	ldr	r3, [r7, #0]
 800b044:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 800b048:	dd07      	ble.n	800b05a <LSM6DSV16X_GYRO_SetFullScale+0x36>
 800b04a:	683b      	ldr	r3, [r7, #0]
 800b04c:	f5b3 6ffa 	cmp.w	r3, #2000	@ 0x7d0
 800b050:	dc01      	bgt.n	800b056 <LSM6DSV16X_GYRO_SetFullScale+0x32>
 800b052:	2304      	movs	r3, #4
 800b054:	e008      	b.n	800b068 <LSM6DSV16X_GYRO_SetFullScale+0x44>
 800b056:	230c      	movs	r3, #12
 800b058:	e006      	b.n	800b068 <LSM6DSV16X_GYRO_SetFullScale+0x44>
 800b05a:	2303      	movs	r3, #3
 800b05c:	e004      	b.n	800b068 <LSM6DSV16X_GYRO_SetFullScale+0x44>
 800b05e:	2302      	movs	r3, #2
 800b060:	e002      	b.n	800b068 <LSM6DSV16X_GYRO_SetFullScale+0x44>
 800b062:	2301      	movs	r3, #1
 800b064:	e000      	b.n	800b068 <LSM6DSV16X_GYRO_SetFullScale+0x44>
 800b066:	2300      	movs	r3, #0
  new_fs = (FullScale <= 125)  ? LSM6DSV16X_125dps
 800b068:	73fb      	strb	r3, [r7, #15]
           : (FullScale <= 500)  ? LSM6DSV16X_500dps
           : (FullScale <= 1000) ? LSM6DSV16X_1000dps
           : (FullScale <= 2000) ? LSM6DSV16X_2000dps
           :                       LSM6DSV16X_4000dps;

  if (lsm6dsv16x_gy_full_scale_set(&(pObj->Ctx), new_fs) != LSM6DSV16X_OK)
 800b06a:	687b      	ldr	r3, [r7, #4]
 800b06c:	3320      	adds	r3, #32
 800b06e:	7bfa      	ldrb	r2, [r7, #15]
 800b070:	4611      	mov	r1, r2
 800b072:	4618      	mov	r0, r3
 800b074:	f000 fe7c 	bl	800bd70 <lsm6dsv16x_gy_full_scale_set>
 800b078:	4603      	mov	r3, r0
 800b07a:	2b00      	cmp	r3, #0
 800b07c:	d002      	beq.n	800b084 <LSM6DSV16X_GYRO_SetFullScale+0x60>
  {
    return LSM6DSV16X_ERROR;
 800b07e:	f04f 33ff 	mov.w	r3, #4294967295
 800b082:	e000      	b.n	800b086 <LSM6DSV16X_GYRO_SetFullScale+0x62>
  }

  return LSM6DSV16X_OK;
 800b084:	2300      	movs	r3, #0
}
 800b086:	4618      	mov	r0, r3
 800b088:	3710      	adds	r7, #16
 800b08a:	46bd      	mov	sp, r7
 800b08c:	bd80      	pop	{r7, pc}

0800b08e <LSM6DSV16X_GYRO_GetAxesRaw>:
  * @param  pObj the device pObj
  * @param  Value pointer where the raw values of the axes are written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSV16X_GYRO_GetAxesRaw(LSM6DSV16X_Object_t *pObj, LSM6DSV16X_AxesRaw_t *Value)
{
 800b08e:	b580      	push	{r7, lr}
 800b090:	b084      	sub	sp, #16
 800b092:	af00      	add	r7, sp, #0
 800b094:	6078      	str	r0, [r7, #4]
 800b096:	6039      	str	r1, [r7, #0]
  lsm6dsv16x_axis3bit16_t data_raw;

  /* Read raw data values */
  if (lsm6dsv16x_angular_rate_raw_get(&(pObj->Ctx), data_raw.i16bit) != LSM6DSV16X_OK)
 800b098:	687b      	ldr	r3, [r7, #4]
 800b09a:	3320      	adds	r3, #32
 800b09c:	f107 0208 	add.w	r2, r7, #8
 800b0a0:	4611      	mov	r1, r2
 800b0a2:	4618      	mov	r0, r3
 800b0a4:	f000 ff46 	bl	800bf34 <lsm6dsv16x_angular_rate_raw_get>
 800b0a8:	4603      	mov	r3, r0
 800b0aa:	2b00      	cmp	r3, #0
 800b0ac:	d002      	beq.n	800b0b4 <LSM6DSV16X_GYRO_GetAxesRaw+0x26>
  {
    return LSM6DSV16X_ERROR;
 800b0ae:	f04f 33ff 	mov.w	r3, #4294967295
 800b0b2:	e00c      	b.n	800b0ce <LSM6DSV16X_GYRO_GetAxesRaw+0x40>
  }

  /* Format the data */
  Value->x = data_raw.i16bit[0];
 800b0b4:	f9b7 2008 	ldrsh.w	r2, [r7, #8]
 800b0b8:	683b      	ldr	r3, [r7, #0]
 800b0ba:	801a      	strh	r2, [r3, #0]
  Value->y = data_raw.i16bit[1];
 800b0bc:	f9b7 200a 	ldrsh.w	r2, [r7, #10]
 800b0c0:	683b      	ldr	r3, [r7, #0]
 800b0c2:	805a      	strh	r2, [r3, #2]
  Value->z = data_raw.i16bit[2];
 800b0c4:	f9b7 200c 	ldrsh.w	r2, [r7, #12]
 800b0c8:	683b      	ldr	r3, [r7, #0]
 800b0ca:	809a      	strh	r2, [r3, #4]

  return LSM6DSV16X_OK;
 800b0cc:	2300      	movs	r3, #0
}
 800b0ce:	4618      	mov	r0, r3
 800b0d0:	3710      	adds	r7, #16
 800b0d2:	46bd      	mov	sp, r7
 800b0d4:	bd80      	pop	{r7, pc}

0800b0d6 <LSM6DSV16X_GYRO_GetAxes>:
  * @param  pObj the device pObj
  * @param  AngularRate pointer where the values of the axes are written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSV16X_GYRO_GetAxes(LSM6DSV16X_Object_t *pObj, LSM6DSV16X_Axes_t *AngularRate)
{
 800b0d6:	b580      	push	{r7, lr}
 800b0d8:	b086      	sub	sp, #24
 800b0da:	af00      	add	r7, sp, #0
 800b0dc:	6078      	str	r0, [r7, #4]
 800b0de:	6039      	str	r1, [r7, #0]
  lsm6dsv16x_axis3bit16_t data_raw;
  float sensitivity;

  /* Read raw data values */
  if (lsm6dsv16x_angular_rate_raw_get(&(pObj->Ctx), data_raw.i16bit) != LSM6DSV16X_OK)
 800b0e0:	687b      	ldr	r3, [r7, #4]
 800b0e2:	3320      	adds	r3, #32
 800b0e4:	f107 0210 	add.w	r2, r7, #16
 800b0e8:	4611      	mov	r1, r2
 800b0ea:	4618      	mov	r0, r3
 800b0ec:	f000 ff22 	bl	800bf34 <lsm6dsv16x_angular_rate_raw_get>
 800b0f0:	4603      	mov	r3, r0
 800b0f2:	2b00      	cmp	r3, #0
 800b0f4:	d002      	beq.n	800b0fc <LSM6DSV16X_GYRO_GetAxes+0x26>
  {
    return LSM6DSV16X_ERROR;
 800b0f6:	f04f 33ff 	mov.w	r3, #4294967295
 800b0fa:	e03c      	b.n	800b176 <LSM6DSV16X_GYRO_GetAxes+0xa0>
  }

  /* Get LSM6DSV16X actual sensitivity */
  if (LSM6DSV16X_GYRO_GetSensitivity(pObj, &sensitivity) != LSM6DSV16X_OK)
 800b0fc:	f107 030c 	add.w	r3, r7, #12
 800b100:	4619      	mov	r1, r3
 800b102:	6878      	ldr	r0, [r7, #4]
 800b104:	f7ff fe2e 	bl	800ad64 <LSM6DSV16X_GYRO_GetSensitivity>
 800b108:	4603      	mov	r3, r0
 800b10a:	2b00      	cmp	r3, #0
 800b10c:	d002      	beq.n	800b114 <LSM6DSV16X_GYRO_GetAxes+0x3e>
  {
    return LSM6DSV16X_ERROR;
 800b10e:	f04f 33ff 	mov.w	r3, #4294967295
 800b112:	e030      	b.n	800b176 <LSM6DSV16X_GYRO_GetAxes+0xa0>
  }

  /* Calculate the data */
  AngularRate->x = (int32_t)((float)((float)data_raw.i16bit[0] * sensitivity));
 800b114:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 800b118:	ee07 3a90 	vmov	s15, r3
 800b11c:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 800b120:	edd7 7a03 	vldr	s15, [r7, #12]
 800b124:	ee67 7a27 	vmul.f32	s15, s14, s15
 800b128:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800b12c:	ee17 2a90 	vmov	r2, s15
 800b130:	683b      	ldr	r3, [r7, #0]
 800b132:	601a      	str	r2, [r3, #0]
  AngularRate->y = (int32_t)((float)((float)data_raw.i16bit[1] * sensitivity));
 800b134:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 800b138:	ee07 3a90 	vmov	s15, r3
 800b13c:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 800b140:	edd7 7a03 	vldr	s15, [r7, #12]
 800b144:	ee67 7a27 	vmul.f32	s15, s14, s15
 800b148:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800b14c:	ee17 2a90 	vmov	r2, s15
 800b150:	683b      	ldr	r3, [r7, #0]
 800b152:	605a      	str	r2, [r3, #4]
  AngularRate->z = (int32_t)((float)((float)data_raw.i16bit[2] * sensitivity));
 800b154:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 800b158:	ee07 3a90 	vmov	s15, r3
 800b15c:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 800b160:	edd7 7a03 	vldr	s15, [r7, #12]
 800b164:	ee67 7a27 	vmul.f32	s15, s14, s15
 800b168:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800b16c:	ee17 2a90 	vmov	r2, s15
 800b170:	683b      	ldr	r3, [r7, #0]
 800b172:	609a      	str	r2, [r3, #8]

  return LSM6DSV16X_OK;
 800b174:	2300      	movs	r3, #0
}
 800b176:	4618      	mov	r0, r3
 800b178:	3718      	adds	r7, #24
 800b17a:	46bd      	mov	sp, r7
 800b17c:	bd80      	pop	{r7, pc}

0800b17e <LSM6DSV16X_Write_Reg>:
  * @param  Reg address to be written
  * @param  Data value to be written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSV16X_Write_Reg(LSM6DSV16X_Object_t *pObj, uint8_t Reg, uint8_t Data)
{
 800b17e:	b580      	push	{r7, lr}
 800b180:	b082      	sub	sp, #8
 800b182:	af00      	add	r7, sp, #0
 800b184:	6078      	str	r0, [r7, #4]
 800b186:	460b      	mov	r3, r1
 800b188:	70fb      	strb	r3, [r7, #3]
 800b18a:	4613      	mov	r3, r2
 800b18c:	70bb      	strb	r3, [r7, #2]
  if (lsm6dsv16x_write_reg(&(pObj->Ctx), Reg, &Data, 1) != LSM6DSV16X_OK)
 800b18e:	687b      	ldr	r3, [r7, #4]
 800b190:	f103 0020 	add.w	r0, r3, #32
 800b194:	1cba      	adds	r2, r7, #2
 800b196:	78f9      	ldrb	r1, [r7, #3]
 800b198:	2301      	movs	r3, #1
 800b19a:	f000 fab3 	bl	800b704 <lsm6dsv16x_write_reg>
 800b19e:	4603      	mov	r3, r0
 800b1a0:	2b00      	cmp	r3, #0
 800b1a2:	d002      	beq.n	800b1aa <LSM6DSV16X_Write_Reg+0x2c>
  {
    return LSM6DSV16X_ERROR;
 800b1a4:	f04f 33ff 	mov.w	r3, #4294967295
 800b1a8:	e000      	b.n	800b1ac <LSM6DSV16X_Write_Reg+0x2e>
  }

  return LSM6DSV16X_OK;
 800b1aa:	2300      	movs	r3, #0
}
 800b1ac:	4618      	mov	r0, r3
 800b1ae:	3708      	adds	r7, #8
 800b1b0:	46bd      	mov	sp, r7
 800b1b2:	bd80      	pop	{r7, pc}

0800b1b4 <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled>:
  * @param  pObj the device pObj
  * @param  Odr the functional output data rate to be set
  * @retval 0 in case of success, an error code otherwise
  */
static int32_t LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled(LSM6DSV16X_Object_t *pObj, float Odr)
{
 800b1b4:	b580      	push	{r7, lr}
 800b1b6:	b084      	sub	sp, #16
 800b1b8:	af00      	add	r7, sp, #0
 800b1ba:	6078      	str	r0, [r7, #4]
 800b1bc:	6039      	str	r1, [r7, #0]
  lsm6dsv16x_data_rate_t new_odr;

  new_odr = (Odr <=  1.875f) ? LSM6DSV16X_ODR_AT_1Hz875
            : (Odr <=    7.5f) ? LSM6DSV16X_ODR_AT_7Hz5
 800b1be:	edd7 7a00 	vldr	s15, [r7]
 800b1c2:	eeb7 7a0e 	vmov.f32	s14, #126	@ 0x3ff00000  1.875
 800b1c6:	eef4 7ac7 	vcmpe.f32	s15, s14
 800b1ca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b1ce:	d801      	bhi.n	800b1d4 <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0x20>
 800b1d0:	2301      	movs	r3, #1
 800b1d2:	e06e      	b.n	800b2b2 <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0xfe>
 800b1d4:	edd7 7a00 	vldr	s15, [r7]
 800b1d8:	eeb1 7a0e 	vmov.f32	s14, #30	@ 0x40f00000  7.5
 800b1dc:	eef4 7ac7 	vcmpe.f32	s15, s14
 800b1e0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b1e4:	d801      	bhi.n	800b1ea <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0x36>
 800b1e6:	2302      	movs	r3, #2
 800b1e8:	e063      	b.n	800b2b2 <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0xfe>
 800b1ea:	edd7 7a00 	vldr	s15, [r7]
 800b1ee:	eeb2 7a0e 	vmov.f32	s14, #46	@ 0x41700000  15.0
 800b1f2:	eef4 7ac7 	vcmpe.f32	s15, s14
 800b1f6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b1fa:	d801      	bhi.n	800b200 <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0x4c>
 800b1fc:	2303      	movs	r3, #3
 800b1fe:	e058      	b.n	800b2b2 <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0xfe>
 800b200:	edd7 7a00 	vldr	s15, [r7]
 800b204:	eeb3 7a0e 	vmov.f32	s14, #62	@ 0x41f00000  30.0
 800b208:	eef4 7ac7 	vcmpe.f32	s15, s14
 800b20c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b210:	d801      	bhi.n	800b216 <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0x62>
 800b212:	2304      	movs	r3, #4
 800b214:	e04d      	b.n	800b2b2 <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0xfe>
 800b216:	edd7 7a00 	vldr	s15, [r7]
 800b21a:	ed9f 7a2f 	vldr	s14, [pc, #188]	@ 800b2d8 <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0x124>
 800b21e:	eef4 7ac7 	vcmpe.f32	s15, s14
 800b222:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b226:	d801      	bhi.n	800b22c <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0x78>
 800b228:	2305      	movs	r3, #5
 800b22a:	e042      	b.n	800b2b2 <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0xfe>
 800b22c:	edd7 7a00 	vldr	s15, [r7]
 800b230:	ed9f 7a2a 	vldr	s14, [pc, #168]	@ 800b2dc <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0x128>
 800b234:	eef4 7ac7 	vcmpe.f32	s15, s14
 800b238:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b23c:	d801      	bhi.n	800b242 <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0x8e>
 800b23e:	2306      	movs	r3, #6
 800b240:	e037      	b.n	800b2b2 <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0xfe>
 800b242:	edd7 7a00 	vldr	s15, [r7]
 800b246:	ed9f 7a26 	vldr	s14, [pc, #152]	@ 800b2e0 <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0x12c>
 800b24a:	eef4 7ac7 	vcmpe.f32	s15, s14
 800b24e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b252:	d801      	bhi.n	800b258 <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0xa4>
 800b254:	2307      	movs	r3, #7
 800b256:	e02c      	b.n	800b2b2 <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0xfe>
 800b258:	edd7 7a00 	vldr	s15, [r7]
 800b25c:	ed9f 7a21 	vldr	s14, [pc, #132]	@ 800b2e4 <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0x130>
 800b260:	eef4 7ac7 	vcmpe.f32	s15, s14
 800b264:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b268:	d801      	bhi.n	800b26e <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0xba>
 800b26a:	2308      	movs	r3, #8
 800b26c:	e021      	b.n	800b2b2 <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0xfe>
 800b26e:	edd7 7a00 	vldr	s15, [r7]
 800b272:	ed9f 7a1d 	vldr	s14, [pc, #116]	@ 800b2e8 <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0x134>
 800b276:	eef4 7ac7 	vcmpe.f32	s15, s14
 800b27a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b27e:	d801      	bhi.n	800b284 <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0xd0>
 800b280:	2309      	movs	r3, #9
 800b282:	e016      	b.n	800b2b2 <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0xfe>
 800b284:	edd7 7a00 	vldr	s15, [r7]
 800b288:	ed9f 7a18 	vldr	s14, [pc, #96]	@ 800b2ec <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0x138>
 800b28c:	eef4 7ac7 	vcmpe.f32	s15, s14
 800b290:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b294:	d801      	bhi.n	800b29a <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0xe6>
 800b296:	230a      	movs	r3, #10
 800b298:	e00b      	b.n	800b2b2 <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0xfe>
 800b29a:	edd7 7a00 	vldr	s15, [r7]
 800b29e:	ed9f 7a14 	vldr	s14, [pc, #80]	@ 800b2f0 <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0x13c>
 800b2a2:	eef4 7ac7 	vcmpe.f32	s15, s14
 800b2a6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b2aa:	d801      	bhi.n	800b2b0 <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0xfc>
 800b2ac:	230b      	movs	r3, #11
 800b2ae:	e000      	b.n	800b2b2 <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0xfe>
 800b2b0:	230c      	movs	r3, #12
  new_odr = (Odr <=  1.875f) ? LSM6DSV16X_ODR_AT_1Hz875
 800b2b2:	73fb      	strb	r3, [r7, #15]
            : (Odr <= 1920.0f) ? LSM6DSV16X_ODR_AT_1920Hz
            : (Odr <= 3840.0f) ? LSM6DSV16X_ODR_AT_3840Hz
            :                    LSM6DSV16X_ODR_AT_7680Hz;

  /* Output data rate selection */
  if (lsm6dsv16x_xl_data_rate_set(&(pObj->Ctx), new_odr) != LSM6DSV16X_OK)
 800b2b4:	687b      	ldr	r3, [r7, #4]
 800b2b6:	3320      	adds	r3, #32
 800b2b8:	7bfa      	ldrb	r2, [r7, #15]
 800b2ba:	4611      	mov	r1, r2
 800b2bc:	4618      	mov	r0, r3
 800b2be:	f000 fa4a 	bl	800b756 <lsm6dsv16x_xl_data_rate_set>
 800b2c2:	4603      	mov	r3, r0
 800b2c4:	2b00      	cmp	r3, #0
 800b2c6:	d002      	beq.n	800b2ce <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0x11a>
  {
    return LSM6DSV16X_ERROR;
 800b2c8:	f04f 33ff 	mov.w	r3, #4294967295
 800b2cc:	e000      	b.n	800b2d0 <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0x11c>
  }

  return LSM6DSV16X_OK;
 800b2ce:	2300      	movs	r3, #0
}
 800b2d0:	4618      	mov	r0, r3
 800b2d2:	3710      	adds	r7, #16
 800b2d4:	46bd      	mov	sp, r7
 800b2d6:	bd80      	pop	{r7, pc}
 800b2d8:	42700000 	.word	0x42700000
 800b2dc:	42f00000 	.word	0x42f00000
 800b2e0:	43700000 	.word	0x43700000
 800b2e4:	43f00000 	.word	0x43f00000
 800b2e8:	44700000 	.word	0x44700000
 800b2ec:	44f00000 	.word	0x44f00000
 800b2f0:	45700000 	.word	0x45700000

0800b2f4 <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled>:
  * @param  pObj the device pObj
  * @param  Odr the functional output data rate to be set
  * @retval 0 in case of success, an error code otherwise
  */
static int32_t LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled(LSM6DSV16X_Object_t *pObj, float Odr)
{
 800b2f4:	b480      	push	{r7}
 800b2f6:	b083      	sub	sp, #12
 800b2f8:	af00      	add	r7, sp, #0
 800b2fa:	6078      	str	r0, [r7, #4]
 800b2fc:	6039      	str	r1, [r7, #0]
  pObj->acc_odr = (Odr <=  1.875f) ? LSM6DSV16X_ODR_AT_1Hz875
                  : (Odr <=    7.5f) ? LSM6DSV16X_ODR_AT_7Hz5
 800b2fe:	edd7 7a00 	vldr	s15, [r7]
 800b302:	eeb7 7a0e 	vmov.f32	s14, #126	@ 0x3ff00000  1.875
 800b306:	eef4 7ac7 	vcmpe.f32	s15, s14
 800b30a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b30e:	d801      	bhi.n	800b314 <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled+0x20>
 800b310:	2301      	movs	r3, #1
 800b312:	e06e      	b.n	800b3f2 <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled+0xfe>
 800b314:	edd7 7a00 	vldr	s15, [r7]
 800b318:	eeb1 7a0e 	vmov.f32	s14, #30	@ 0x40f00000  7.5
 800b31c:	eef4 7ac7 	vcmpe.f32	s15, s14
 800b320:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b324:	d801      	bhi.n	800b32a <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled+0x36>
 800b326:	2302      	movs	r3, #2
 800b328:	e063      	b.n	800b3f2 <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled+0xfe>
 800b32a:	edd7 7a00 	vldr	s15, [r7]
 800b32e:	eeb2 7a0e 	vmov.f32	s14, #46	@ 0x41700000  15.0
 800b332:	eef4 7ac7 	vcmpe.f32	s15, s14
 800b336:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b33a:	d801      	bhi.n	800b340 <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled+0x4c>
 800b33c:	2303      	movs	r3, #3
 800b33e:	e058      	b.n	800b3f2 <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled+0xfe>
 800b340:	edd7 7a00 	vldr	s15, [r7]
 800b344:	eeb3 7a0e 	vmov.f32	s14, #62	@ 0x41f00000  30.0
 800b348:	eef4 7ac7 	vcmpe.f32	s15, s14
 800b34c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b350:	d801      	bhi.n	800b356 <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled+0x62>
 800b352:	2304      	movs	r3, #4
 800b354:	e04d      	b.n	800b3f2 <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled+0xfe>
 800b356:	edd7 7a00 	vldr	s15, [r7]
 800b35a:	ed9f 7a2b 	vldr	s14, [pc, #172]	@ 800b408 <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled+0x114>
 800b35e:	eef4 7ac7 	vcmpe.f32	s15, s14
 800b362:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b366:	d801      	bhi.n	800b36c <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled+0x78>
 800b368:	2305      	movs	r3, #5
 800b36a:	e042      	b.n	800b3f2 <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled+0xfe>
 800b36c:	edd7 7a00 	vldr	s15, [r7]
 800b370:	ed9f 7a26 	vldr	s14, [pc, #152]	@ 800b40c <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled+0x118>
 800b374:	eef4 7ac7 	vcmpe.f32	s15, s14
 800b378:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b37c:	d801      	bhi.n	800b382 <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled+0x8e>
 800b37e:	2306      	movs	r3, #6
 800b380:	e037      	b.n	800b3f2 <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled+0xfe>
 800b382:	edd7 7a00 	vldr	s15, [r7]
 800b386:	ed9f 7a22 	vldr	s14, [pc, #136]	@ 800b410 <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled+0x11c>
 800b38a:	eef4 7ac7 	vcmpe.f32	s15, s14
 800b38e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b392:	d801      	bhi.n	800b398 <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled+0xa4>
 800b394:	2307      	movs	r3, #7
 800b396:	e02c      	b.n	800b3f2 <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled+0xfe>
 800b398:	edd7 7a00 	vldr	s15, [r7]
 800b39c:	ed9f 7a1d 	vldr	s14, [pc, #116]	@ 800b414 <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled+0x120>
 800b3a0:	eef4 7ac7 	vcmpe.f32	s15, s14
 800b3a4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b3a8:	d801      	bhi.n	800b3ae <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled+0xba>
 800b3aa:	2308      	movs	r3, #8
 800b3ac:	e021      	b.n	800b3f2 <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled+0xfe>
 800b3ae:	edd7 7a00 	vldr	s15, [r7]
 800b3b2:	ed9f 7a19 	vldr	s14, [pc, #100]	@ 800b418 <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled+0x124>
 800b3b6:	eef4 7ac7 	vcmpe.f32	s15, s14
 800b3ba:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b3be:	d801      	bhi.n	800b3c4 <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled+0xd0>
 800b3c0:	2309      	movs	r3, #9
 800b3c2:	e016      	b.n	800b3f2 <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled+0xfe>
 800b3c4:	edd7 7a00 	vldr	s15, [r7]
 800b3c8:	ed9f 7a14 	vldr	s14, [pc, #80]	@ 800b41c <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled+0x128>
 800b3cc:	eef4 7ac7 	vcmpe.f32	s15, s14
 800b3d0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b3d4:	d801      	bhi.n	800b3da <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled+0xe6>
 800b3d6:	230a      	movs	r3, #10
 800b3d8:	e00b      	b.n	800b3f2 <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled+0xfe>
 800b3da:	edd7 7a00 	vldr	s15, [r7]
 800b3de:	ed9f 7a10 	vldr	s14, [pc, #64]	@ 800b420 <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled+0x12c>
 800b3e2:	eef4 7ac7 	vcmpe.f32	s15, s14
 800b3e6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b3ea:	d801      	bhi.n	800b3f0 <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled+0xfc>
 800b3ec:	230b      	movs	r3, #11
 800b3ee:	e000      	b.n	800b3f2 <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled+0xfe>
 800b3f0:	230c      	movs	r3, #12
  pObj->acc_odr = (Odr <=  1.875f) ? LSM6DSV16X_ODR_AT_1Hz875
 800b3f2:	687a      	ldr	r2, [r7, #4]
 800b3f4:	f882 3033 	strb.w	r3, [r2, #51]	@ 0x33
                  : (Odr <=  960.0f) ? LSM6DSV16X_ODR_AT_960Hz
                  : (Odr <= 1920.0f) ? LSM6DSV16X_ODR_AT_1920Hz
                  : (Odr <= 3840.0f) ? LSM6DSV16X_ODR_AT_3840Hz
                  :                    LSM6DSV16X_ODR_AT_7680Hz;

  return LSM6DSV16X_OK;
 800b3f8:	2300      	movs	r3, #0
}
 800b3fa:	4618      	mov	r0, r3
 800b3fc:	370c      	adds	r7, #12
 800b3fe:	46bd      	mov	sp, r7
 800b400:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b404:	4770      	bx	lr
 800b406:	bf00      	nop
 800b408:	42700000 	.word	0x42700000
 800b40c:	42f00000 	.word	0x42f00000
 800b410:	43700000 	.word	0x43700000
 800b414:	43f00000 	.word	0x43f00000
 800b418:	44700000 	.word	0x44700000
 800b41c:	44f00000 	.word	0x44f00000
 800b420:	45700000 	.word	0x45700000

0800b424 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled>:
  * @param  pObj the device pObj
  * @param  Odr the functional output data rate to be set
  * @retval 0 in case of success, an error code otherwise
  */
static int32_t LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled(LSM6DSV16X_Object_t *pObj, float Odr)
{
 800b424:	b580      	push	{r7, lr}
 800b426:	b084      	sub	sp, #16
 800b428:	af00      	add	r7, sp, #0
 800b42a:	6078      	str	r0, [r7, #4]
 800b42c:	6039      	str	r1, [r7, #0]
  lsm6dsv16x_data_rate_t new_odr;

  new_odr = (Odr <=    7.5f) ? LSM6DSV16X_ODR_AT_7Hz5
            : (Odr <=   15.0f) ? LSM6DSV16X_ODR_AT_15Hz
 800b42e:	edd7 7a00 	vldr	s15, [r7]
 800b432:	eeb1 7a0e 	vmov.f32	s14, #30	@ 0x40f00000  7.5
 800b436:	eef4 7ac7 	vcmpe.f32	s15, s14
 800b43a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b43e:	d801      	bhi.n	800b444 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled+0x20>
 800b440:	2302      	movs	r3, #2
 800b442:	e063      	b.n	800b50c <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled+0xe8>
 800b444:	edd7 7a00 	vldr	s15, [r7]
 800b448:	eeb2 7a0e 	vmov.f32	s14, #46	@ 0x41700000  15.0
 800b44c:	eef4 7ac7 	vcmpe.f32	s15, s14
 800b450:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b454:	d801      	bhi.n	800b45a <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled+0x36>
 800b456:	2303      	movs	r3, #3
 800b458:	e058      	b.n	800b50c <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled+0xe8>
 800b45a:	edd7 7a00 	vldr	s15, [r7]
 800b45e:	eeb3 7a0e 	vmov.f32	s14, #62	@ 0x41f00000  30.0
 800b462:	eef4 7ac7 	vcmpe.f32	s15, s14
 800b466:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b46a:	d801      	bhi.n	800b470 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled+0x4c>
 800b46c:	2304      	movs	r3, #4
 800b46e:	e04d      	b.n	800b50c <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled+0xe8>
 800b470:	edd7 7a00 	vldr	s15, [r7]
 800b474:	ed9f 7a2f 	vldr	s14, [pc, #188]	@ 800b534 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled+0x110>
 800b478:	eef4 7ac7 	vcmpe.f32	s15, s14
 800b47c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b480:	d801      	bhi.n	800b486 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled+0x62>
 800b482:	2305      	movs	r3, #5
 800b484:	e042      	b.n	800b50c <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled+0xe8>
 800b486:	edd7 7a00 	vldr	s15, [r7]
 800b48a:	ed9f 7a2b 	vldr	s14, [pc, #172]	@ 800b538 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled+0x114>
 800b48e:	eef4 7ac7 	vcmpe.f32	s15, s14
 800b492:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b496:	d801      	bhi.n	800b49c <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled+0x78>
 800b498:	2306      	movs	r3, #6
 800b49a:	e037      	b.n	800b50c <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled+0xe8>
 800b49c:	edd7 7a00 	vldr	s15, [r7]
 800b4a0:	ed9f 7a26 	vldr	s14, [pc, #152]	@ 800b53c <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled+0x118>
 800b4a4:	eef4 7ac7 	vcmpe.f32	s15, s14
 800b4a8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b4ac:	d801      	bhi.n	800b4b2 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled+0x8e>
 800b4ae:	2307      	movs	r3, #7
 800b4b0:	e02c      	b.n	800b50c <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled+0xe8>
 800b4b2:	edd7 7a00 	vldr	s15, [r7]
 800b4b6:	ed9f 7a22 	vldr	s14, [pc, #136]	@ 800b540 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled+0x11c>
 800b4ba:	eef4 7ac7 	vcmpe.f32	s15, s14
 800b4be:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b4c2:	d801      	bhi.n	800b4c8 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled+0xa4>
 800b4c4:	2308      	movs	r3, #8
 800b4c6:	e021      	b.n	800b50c <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled+0xe8>
 800b4c8:	edd7 7a00 	vldr	s15, [r7]
 800b4cc:	ed9f 7a1d 	vldr	s14, [pc, #116]	@ 800b544 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled+0x120>
 800b4d0:	eef4 7ac7 	vcmpe.f32	s15, s14
 800b4d4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b4d8:	d801      	bhi.n	800b4de <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled+0xba>
 800b4da:	2309      	movs	r3, #9
 800b4dc:	e016      	b.n	800b50c <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled+0xe8>
 800b4de:	edd7 7a00 	vldr	s15, [r7]
 800b4e2:	ed9f 7a19 	vldr	s14, [pc, #100]	@ 800b548 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled+0x124>
 800b4e6:	eef4 7ac7 	vcmpe.f32	s15, s14
 800b4ea:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b4ee:	d801      	bhi.n	800b4f4 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled+0xd0>
 800b4f0:	230a      	movs	r3, #10
 800b4f2:	e00b      	b.n	800b50c <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled+0xe8>
 800b4f4:	edd7 7a00 	vldr	s15, [r7]
 800b4f8:	ed9f 7a14 	vldr	s14, [pc, #80]	@ 800b54c <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled+0x128>
 800b4fc:	eef4 7ac7 	vcmpe.f32	s15, s14
 800b500:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b504:	d801      	bhi.n	800b50a <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled+0xe6>
 800b506:	230b      	movs	r3, #11
 800b508:	e000      	b.n	800b50c <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled+0xe8>
 800b50a:	230c      	movs	r3, #12
  new_odr = (Odr <=    7.5f) ? LSM6DSV16X_ODR_AT_7Hz5
 800b50c:	73fb      	strb	r3, [r7, #15]
            : (Odr <= 1920.0f) ? LSM6DSV16X_ODR_AT_1920Hz
            : (Odr <= 3840.0f) ? LSM6DSV16X_ODR_AT_3840Hz
            :                    LSM6DSV16X_ODR_AT_7680Hz;

  /* Output data rate selection */
  if (lsm6dsv16x_gy_data_rate_set(&(pObj->Ctx), new_odr) != LSM6DSV16X_OK)
 800b50e:	687b      	ldr	r3, [r7, #4]
 800b510:	3320      	adds	r3, #32
 800b512:	7bfa      	ldrb	r2, [r7, #15]
 800b514:	4611      	mov	r1, r2
 800b516:	4618      	mov	r0, r3
 800b518:	f000 fa7e 	bl	800ba18 <lsm6dsv16x_gy_data_rate_set>
 800b51c:	4603      	mov	r3, r0
 800b51e:	2b00      	cmp	r3, #0
 800b520:	d002      	beq.n	800b528 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled+0x104>
  {
    return LSM6DSV16X_ERROR;
 800b522:	f04f 33ff 	mov.w	r3, #4294967295
 800b526:	e000      	b.n	800b52a <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled+0x106>
  }

  return LSM6DSV16X_OK;
 800b528:	2300      	movs	r3, #0
}
 800b52a:	4618      	mov	r0, r3
 800b52c:	3710      	adds	r7, #16
 800b52e:	46bd      	mov	sp, r7
 800b530:	bd80      	pop	{r7, pc}
 800b532:	bf00      	nop
 800b534:	42700000 	.word	0x42700000
 800b538:	42f00000 	.word	0x42f00000
 800b53c:	43700000 	.word	0x43700000
 800b540:	43f00000 	.word	0x43f00000
 800b544:	44700000 	.word	0x44700000
 800b548:	44f00000 	.word	0x44f00000
 800b54c:	45700000 	.word	0x45700000

0800b550 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled>:
  * @param  pObj the device pObj
  * @param  Odr the functional output data rate to be set
  * @retval 0 in case of success, an error code otherwise
  */
static int32_t LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled(LSM6DSV16X_Object_t *pObj, float Odr)
{
 800b550:	b480      	push	{r7}
 800b552:	b083      	sub	sp, #12
 800b554:	af00      	add	r7, sp, #0
 800b556:	6078      	str	r0, [r7, #4]
 800b558:	6039      	str	r1, [r7, #0]
  pObj->gyro_odr = (Odr <=    7.5f) ? LSM6DSV16X_ODR_AT_7Hz5
                   : (Odr <=   15.0f) ? LSM6DSV16X_ODR_AT_15Hz
 800b55a:	edd7 7a00 	vldr	s15, [r7]
 800b55e:	eeb1 7a0e 	vmov.f32	s14, #30	@ 0x40f00000  7.5
 800b562:	eef4 7ac7 	vcmpe.f32	s15, s14
 800b566:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b56a:	d801      	bhi.n	800b570 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled+0x20>
 800b56c:	2302      	movs	r3, #2
 800b56e:	e063      	b.n	800b638 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled+0xe8>
 800b570:	edd7 7a00 	vldr	s15, [r7]
 800b574:	eeb2 7a0e 	vmov.f32	s14, #46	@ 0x41700000  15.0
 800b578:	eef4 7ac7 	vcmpe.f32	s15, s14
 800b57c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b580:	d801      	bhi.n	800b586 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled+0x36>
 800b582:	2303      	movs	r3, #3
 800b584:	e058      	b.n	800b638 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled+0xe8>
 800b586:	edd7 7a00 	vldr	s15, [r7]
 800b58a:	eeb3 7a0e 	vmov.f32	s14, #62	@ 0x41f00000  30.0
 800b58e:	eef4 7ac7 	vcmpe.f32	s15, s14
 800b592:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b596:	d801      	bhi.n	800b59c <LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled+0x4c>
 800b598:	2304      	movs	r3, #4
 800b59a:	e04d      	b.n	800b638 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled+0xe8>
 800b59c:	edd7 7a00 	vldr	s15, [r7]
 800b5a0:	ed9f 7a2a 	vldr	s14, [pc, #168]	@ 800b64c <LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled+0xfc>
 800b5a4:	eef4 7ac7 	vcmpe.f32	s15, s14
 800b5a8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b5ac:	d801      	bhi.n	800b5b2 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled+0x62>
 800b5ae:	2305      	movs	r3, #5
 800b5b0:	e042      	b.n	800b638 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled+0xe8>
 800b5b2:	edd7 7a00 	vldr	s15, [r7]
 800b5b6:	ed9f 7a26 	vldr	s14, [pc, #152]	@ 800b650 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled+0x100>
 800b5ba:	eef4 7ac7 	vcmpe.f32	s15, s14
 800b5be:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b5c2:	d801      	bhi.n	800b5c8 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled+0x78>
 800b5c4:	2306      	movs	r3, #6
 800b5c6:	e037      	b.n	800b638 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled+0xe8>
 800b5c8:	edd7 7a00 	vldr	s15, [r7]
 800b5cc:	ed9f 7a21 	vldr	s14, [pc, #132]	@ 800b654 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled+0x104>
 800b5d0:	eef4 7ac7 	vcmpe.f32	s15, s14
 800b5d4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b5d8:	d801      	bhi.n	800b5de <LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled+0x8e>
 800b5da:	2307      	movs	r3, #7
 800b5dc:	e02c      	b.n	800b638 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled+0xe8>
 800b5de:	edd7 7a00 	vldr	s15, [r7]
 800b5e2:	ed9f 7a1d 	vldr	s14, [pc, #116]	@ 800b658 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled+0x108>
 800b5e6:	eef4 7ac7 	vcmpe.f32	s15, s14
 800b5ea:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b5ee:	d801      	bhi.n	800b5f4 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled+0xa4>
 800b5f0:	2308      	movs	r3, #8
 800b5f2:	e021      	b.n	800b638 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled+0xe8>
 800b5f4:	edd7 7a00 	vldr	s15, [r7]
 800b5f8:	ed9f 7a18 	vldr	s14, [pc, #96]	@ 800b65c <LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled+0x10c>
 800b5fc:	eef4 7ac7 	vcmpe.f32	s15, s14
 800b600:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b604:	d801      	bhi.n	800b60a <LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled+0xba>
 800b606:	2309      	movs	r3, #9
 800b608:	e016      	b.n	800b638 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled+0xe8>
 800b60a:	edd7 7a00 	vldr	s15, [r7]
 800b60e:	ed9f 7a14 	vldr	s14, [pc, #80]	@ 800b660 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled+0x110>
 800b612:	eef4 7ac7 	vcmpe.f32	s15, s14
 800b616:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b61a:	d801      	bhi.n	800b620 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled+0xd0>
 800b61c:	230a      	movs	r3, #10
 800b61e:	e00b      	b.n	800b638 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled+0xe8>
 800b620:	edd7 7a00 	vldr	s15, [r7]
 800b624:	ed9f 7a0f 	vldr	s14, [pc, #60]	@ 800b664 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled+0x114>
 800b628:	eef4 7ac7 	vcmpe.f32	s15, s14
 800b62c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b630:	d801      	bhi.n	800b636 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled+0xe6>
 800b632:	230b      	movs	r3, #11
 800b634:	e000      	b.n	800b638 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled+0xe8>
 800b636:	230c      	movs	r3, #12
  pObj->gyro_odr = (Odr <=    7.5f) ? LSM6DSV16X_ODR_AT_7Hz5
 800b638:	687a      	ldr	r2, [r7, #4]
 800b63a:	f882 3034 	strb.w	r3, [r2, #52]	@ 0x34
                   : (Odr <=  960.0f) ? LSM6DSV16X_ODR_AT_960Hz
                   : (Odr <= 1920.0f) ? LSM6DSV16X_ODR_AT_1920Hz
                   : (Odr <= 3840.0f) ? LSM6DSV16X_ODR_AT_3840Hz
                   :                    LSM6DSV16X_ODR_AT_7680Hz;

  return LSM6DSV16X_OK;
 800b63e:	2300      	movs	r3, #0
}
 800b640:	4618      	mov	r0, r3
 800b642:	370c      	adds	r7, #12
 800b644:	46bd      	mov	sp, r7
 800b646:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b64a:	4770      	bx	lr
 800b64c:	42700000 	.word	0x42700000
 800b650:	42f00000 	.word	0x42f00000
 800b654:	43700000 	.word	0x43700000
 800b658:	43f00000 	.word	0x43f00000
 800b65c:	44700000 	.word	0x44700000
 800b660:	44f00000 	.word	0x44f00000
 800b664:	45700000 	.word	0x45700000

0800b668 <ReadRegWrap>:
  * @param  pData the stored data pointer
  * @param  Length the length
  * @retval 0 in case of success, an error code otherwise
  */
static int32_t ReadRegWrap(void *Handle, uint8_t Reg, uint8_t *pData, uint16_t Length)
{
 800b668:	b590      	push	{r4, r7, lr}
 800b66a:	b087      	sub	sp, #28
 800b66c:	af00      	add	r7, sp, #0
 800b66e:	60f8      	str	r0, [r7, #12]
 800b670:	607a      	str	r2, [r7, #4]
 800b672:	461a      	mov	r2, r3
 800b674:	460b      	mov	r3, r1
 800b676:	72fb      	strb	r3, [r7, #11]
 800b678:	4613      	mov	r3, r2
 800b67a:	813b      	strh	r3, [r7, #8]
  LSM6DSV16X_Object_t *pObj = (LSM6DSV16X_Object_t *)Handle;
 800b67c:	68fb      	ldr	r3, [r7, #12]
 800b67e:	617b      	str	r3, [r7, #20]

  return pObj->IO.ReadReg(pObj->IO.Address, Reg, pData, Length);
 800b680:	697b      	ldr	r3, [r7, #20]
 800b682:	695c      	ldr	r4, [r3, #20]
 800b684:	697b      	ldr	r3, [r7, #20]
 800b686:	7b1b      	ldrb	r3, [r3, #12]
 800b688:	4618      	mov	r0, r3
 800b68a:	7afb      	ldrb	r3, [r7, #11]
 800b68c:	b299      	uxth	r1, r3
 800b68e:	893b      	ldrh	r3, [r7, #8]
 800b690:	687a      	ldr	r2, [r7, #4]
 800b692:	47a0      	blx	r4
 800b694:	4603      	mov	r3, r0
}
 800b696:	4618      	mov	r0, r3
 800b698:	371c      	adds	r7, #28
 800b69a:	46bd      	mov	sp, r7
 800b69c:	bd90      	pop	{r4, r7, pc}

0800b69e <WriteRegWrap>:
  * @param  pData the stored data pointer
  * @param  Length the length
  * @retval 0 in case of success, an error code otherwise
  */
static int32_t WriteRegWrap(void *Handle, uint8_t Reg, uint8_t *pData, uint16_t Length)
{
 800b69e:	b590      	push	{r4, r7, lr}
 800b6a0:	b087      	sub	sp, #28
 800b6a2:	af00      	add	r7, sp, #0
 800b6a4:	60f8      	str	r0, [r7, #12]
 800b6a6:	607a      	str	r2, [r7, #4]
 800b6a8:	461a      	mov	r2, r3
 800b6aa:	460b      	mov	r3, r1
 800b6ac:	72fb      	strb	r3, [r7, #11]
 800b6ae:	4613      	mov	r3, r2
 800b6b0:	813b      	strh	r3, [r7, #8]
  LSM6DSV16X_Object_t *pObj = (LSM6DSV16X_Object_t *)Handle;
 800b6b2:	68fb      	ldr	r3, [r7, #12]
 800b6b4:	617b      	str	r3, [r7, #20]

  return pObj->IO.WriteReg(pObj->IO.Address, Reg, pData, Length);
 800b6b6:	697b      	ldr	r3, [r7, #20]
 800b6b8:	691c      	ldr	r4, [r3, #16]
 800b6ba:	697b      	ldr	r3, [r7, #20]
 800b6bc:	7b1b      	ldrb	r3, [r3, #12]
 800b6be:	4618      	mov	r0, r3
 800b6c0:	7afb      	ldrb	r3, [r7, #11]
 800b6c2:	b299      	uxth	r1, r3
 800b6c4:	893b      	ldrh	r3, [r7, #8]
 800b6c6:	687a      	ldr	r2, [r7, #4]
 800b6c8:	47a0      	blx	r4
 800b6ca:	4603      	mov	r3, r0
}
 800b6cc:	4618      	mov	r0, r3
 800b6ce:	371c      	adds	r7, #28
 800b6d0:	46bd      	mov	sp, r7
 800b6d2:	bd90      	pop	{r4, r7, pc}

0800b6d4 <lsm6dsv16x_read_reg>:
  *
  */
int32_t __weak lsm6dsv16x_read_reg(stmdev_ctx_t *ctx, uint8_t reg,
                                   uint8_t *data,
                                   uint16_t len)
{
 800b6d4:	b590      	push	{r4, r7, lr}
 800b6d6:	b087      	sub	sp, #28
 800b6d8:	af00      	add	r7, sp, #0
 800b6da:	60f8      	str	r0, [r7, #12]
 800b6dc:	607a      	str	r2, [r7, #4]
 800b6de:	461a      	mov	r2, r3
 800b6e0:	460b      	mov	r3, r1
 800b6e2:	72fb      	strb	r3, [r7, #11]
 800b6e4:	4613      	mov	r3, r2
 800b6e6:	813b      	strh	r3, [r7, #8]
  int32_t ret;

  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800b6e8:	68fb      	ldr	r3, [r7, #12]
 800b6ea:	685c      	ldr	r4, [r3, #4]
 800b6ec:	68fb      	ldr	r3, [r7, #12]
 800b6ee:	68d8      	ldr	r0, [r3, #12]
 800b6f0:	893b      	ldrh	r3, [r7, #8]
 800b6f2:	7af9      	ldrb	r1, [r7, #11]
 800b6f4:	687a      	ldr	r2, [r7, #4]
 800b6f6:	47a0      	blx	r4
 800b6f8:	6178      	str	r0, [r7, #20]

  return ret;
 800b6fa:	697b      	ldr	r3, [r7, #20]
}
 800b6fc:	4618      	mov	r0, r3
 800b6fe:	371c      	adds	r7, #28
 800b700:	46bd      	mov	sp, r7
 800b702:	bd90      	pop	{r4, r7, pc}

0800b704 <lsm6dsv16x_write_reg>:
  *
  */
int32_t __weak lsm6dsv16x_write_reg(stmdev_ctx_t *ctx, uint8_t reg,
                                    uint8_t *data,
                                    uint16_t len)
{
 800b704:	b590      	push	{r4, r7, lr}
 800b706:	b087      	sub	sp, #28
 800b708:	af00      	add	r7, sp, #0
 800b70a:	60f8      	str	r0, [r7, #12]
 800b70c:	607a      	str	r2, [r7, #4]
 800b70e:	461a      	mov	r2, r3
 800b710:	460b      	mov	r3, r1
 800b712:	72fb      	strb	r3, [r7, #11]
 800b714:	4613      	mov	r3, r2
 800b716:	813b      	strh	r3, [r7, #8]
  int32_t ret;

  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800b718:	68fb      	ldr	r3, [r7, #12]
 800b71a:	681c      	ldr	r4, [r3, #0]
 800b71c:	68fb      	ldr	r3, [r7, #12]
 800b71e:	68d8      	ldr	r0, [r3, #12]
 800b720:	893b      	ldrh	r3, [r7, #8]
 800b722:	7af9      	ldrb	r1, [r7, #11]
 800b724:	687a      	ldr	r2, [r7, #4]
 800b726:	47a0      	blx	r4
 800b728:	6178      	str	r0, [r7, #20]

  return ret;
 800b72a:	697b      	ldr	r3, [r7, #20]
}
 800b72c:	4618      	mov	r0, r3
 800b72e:	371c      	adds	r7, #28
 800b730:	46bd      	mov	sp, r7
 800b732:	bd90      	pop	{r4, r7, pc}

0800b734 <lsm6dsv16x_device_id_get>:
  * @param  val      Device ID.
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lsm6dsv16x_device_id_get(stmdev_ctx_t *ctx, uint8_t *val)
{
 800b734:	b580      	push	{r7, lr}
 800b736:	b084      	sub	sp, #16
 800b738:	af00      	add	r7, sp, #0
 800b73a:	6078      	str	r0, [r7, #4]
 800b73c:	6039      	str	r1, [r7, #0]
  int32_t ret;

  ret = lsm6dsv16x_read_reg(ctx, LSM6DSV16X_WHO_AM_I, val, 1);
 800b73e:	2301      	movs	r3, #1
 800b740:	683a      	ldr	r2, [r7, #0]
 800b742:	210f      	movs	r1, #15
 800b744:	6878      	ldr	r0, [r7, #4]
 800b746:	f7ff ffc5 	bl	800b6d4 <lsm6dsv16x_read_reg>
 800b74a:	60f8      	str	r0, [r7, #12]

  return ret;
 800b74c:	68fb      	ldr	r3, [r7, #12]
}
 800b74e:	4618      	mov	r0, r3
 800b750:	3710      	adds	r7, #16
 800b752:	46bd      	mov	sp, r7
 800b754:	bd80      	pop	{r7, pc}

0800b756 <lsm6dsv16x_xl_data_rate_set>:
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lsm6dsv16x_xl_data_rate_set(stmdev_ctx_t *ctx,
                                    lsm6dsv16x_data_rate_t val)
{
 800b756:	b580      	push	{r7, lr}
 800b758:	b086      	sub	sp, #24
 800b75a:	af00      	add	r7, sp, #0
 800b75c:	6078      	str	r0, [r7, #4]
 800b75e:	460b      	mov	r3, r1
 800b760:	70fb      	strb	r3, [r7, #3]
  lsm6dsv16x_ctrl1_t ctrl1;
  lsm6dsv16x_haodr_cfg_t haodr;
  uint8_t sel;
  int32_t ret;

  ret = lsm6dsv16x_read_reg(ctx, LSM6DSV16X_CTRL1, (uint8_t *)&ctrl1, 1);
 800b762:	f107 0210 	add.w	r2, r7, #16
 800b766:	2301      	movs	r3, #1
 800b768:	2110      	movs	r1, #16
 800b76a:	6878      	ldr	r0, [r7, #4]
 800b76c:	f7ff ffb2 	bl	800b6d4 <lsm6dsv16x_read_reg>
 800b770:	6178      	str	r0, [r7, #20]
  if (ret != 0) { return ret; }
 800b772:	697b      	ldr	r3, [r7, #20]
 800b774:	2b00      	cmp	r3, #0
 800b776:	d001      	beq.n	800b77c <lsm6dsv16x_xl_data_rate_set+0x26>
 800b778:	697b      	ldr	r3, [r7, #20]
 800b77a:	e039      	b.n	800b7f0 <lsm6dsv16x_xl_data_rate_set+0x9a>

  ctrl1.odr_xl = (uint8_t)val & 0x0Fu;
 800b77c:	78fb      	ldrb	r3, [r7, #3]
 800b77e:	f003 030f 	and.w	r3, r3, #15
 800b782:	b2da      	uxtb	r2, r3
 800b784:	7c3b      	ldrb	r3, [r7, #16]
 800b786:	f362 0303 	bfi	r3, r2, #0, #4
 800b78a:	743b      	strb	r3, [r7, #16]
  ret = lsm6dsv16x_write_reg(ctx, LSM6DSV16X_CTRL1, (uint8_t *)&ctrl1, 1);
 800b78c:	f107 0210 	add.w	r2, r7, #16
 800b790:	2301      	movs	r3, #1
 800b792:	2110      	movs	r1, #16
 800b794:	6878      	ldr	r0, [r7, #4]
 800b796:	f7ff ffb5 	bl	800b704 <lsm6dsv16x_write_reg>
 800b79a:	6178      	str	r0, [r7, #20]
  if (ret != 0) { return ret; }
 800b79c:	697b      	ldr	r3, [r7, #20]
 800b79e:	2b00      	cmp	r3, #0
 800b7a0:	d001      	beq.n	800b7a6 <lsm6dsv16x_xl_data_rate_set+0x50>
 800b7a2:	697b      	ldr	r3, [r7, #20]
 800b7a4:	e024      	b.n	800b7f0 <lsm6dsv16x_xl_data_rate_set+0x9a>

  sel = ((uint8_t)val >> 4) & 0xFU;
 800b7a6:	78fb      	ldrb	r3, [r7, #3]
 800b7a8:	091b      	lsrs	r3, r3, #4
 800b7aa:	74fb      	strb	r3, [r7, #19]
  if (sel != 0U)
 800b7ac:	7cfb      	ldrb	r3, [r7, #19]
 800b7ae:	2b00      	cmp	r3, #0
 800b7b0:	d01d      	beq.n	800b7ee <lsm6dsv16x_xl_data_rate_set+0x98>
  {
    ret += lsm6dsv16x_read_reg(ctx, LSM6DSV16X_HAODR_CFG, (uint8_t *)&haodr, 1);
 800b7b2:	f107 020c 	add.w	r2, r7, #12
 800b7b6:	2301      	movs	r3, #1
 800b7b8:	2162      	movs	r1, #98	@ 0x62
 800b7ba:	6878      	ldr	r0, [r7, #4]
 800b7bc:	f7ff ff8a 	bl	800b6d4 <lsm6dsv16x_read_reg>
 800b7c0:	4602      	mov	r2, r0
 800b7c2:	697b      	ldr	r3, [r7, #20]
 800b7c4:	4413      	add	r3, r2
 800b7c6:	617b      	str	r3, [r7, #20]
    haodr.haodr_sel = sel;
 800b7c8:	7cfb      	ldrb	r3, [r7, #19]
 800b7ca:	f003 0303 	and.w	r3, r3, #3
 800b7ce:	b2da      	uxtb	r2, r3
 800b7d0:	7b3b      	ldrb	r3, [r7, #12]
 800b7d2:	f362 0301 	bfi	r3, r2, #0, #2
 800b7d6:	733b      	strb	r3, [r7, #12]
    ret += lsm6dsv16x_write_reg(ctx, LSM6DSV16X_HAODR_CFG, (uint8_t *)&haodr, 1);
 800b7d8:	f107 020c 	add.w	r2, r7, #12
 800b7dc:	2301      	movs	r3, #1
 800b7de:	2162      	movs	r1, #98	@ 0x62
 800b7e0:	6878      	ldr	r0, [r7, #4]
 800b7e2:	f7ff ff8f 	bl	800b704 <lsm6dsv16x_write_reg>
 800b7e6:	4602      	mov	r2, r0
 800b7e8:	697b      	ldr	r3, [r7, #20]
 800b7ea:	4413      	add	r3, r2
 800b7ec:	617b      	str	r3, [r7, #20]
  }

  return ret;
 800b7ee:	697b      	ldr	r3, [r7, #20]
}
 800b7f0:	4618      	mov	r0, r3
 800b7f2:	3718      	adds	r7, #24
 800b7f4:	46bd      	mov	sp, r7
 800b7f6:	bd80      	pop	{r7, pc}

0800b7f8 <lsm6dsv16x_xl_data_rate_get>:
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lsm6dsv16x_xl_data_rate_get(stmdev_ctx_t *ctx,
                                    lsm6dsv16x_data_rate_t *val)
{
 800b7f8:	b580      	push	{r7, lr}
 800b7fa:	b086      	sub	sp, #24
 800b7fc:	af00      	add	r7, sp, #0
 800b7fe:	6078      	str	r0, [r7, #4]
 800b800:	6039      	str	r1, [r7, #0]
  lsm6dsv16x_ctrl1_t ctrl1;
  lsm6dsv16x_haodr_cfg_t haodr;
  uint8_t sel;
  int32_t ret;

  ret = lsm6dsv16x_read_reg(ctx, LSM6DSV16X_CTRL1, (uint8_t *)&ctrl1, 1);
 800b802:	f107 0210 	add.w	r2, r7, #16
 800b806:	2301      	movs	r3, #1
 800b808:	2110      	movs	r1, #16
 800b80a:	6878      	ldr	r0, [r7, #4]
 800b80c:	f7ff ff62 	bl	800b6d4 <lsm6dsv16x_read_reg>
 800b810:	6178      	str	r0, [r7, #20]
  ret += lsm6dsv16x_read_reg(ctx, LSM6DSV16X_HAODR_CFG, (uint8_t *)&haodr, 1);
 800b812:	f107 020c 	add.w	r2, r7, #12
 800b816:	2301      	movs	r3, #1
 800b818:	2162      	movs	r1, #98	@ 0x62
 800b81a:	6878      	ldr	r0, [r7, #4]
 800b81c:	f7ff ff5a 	bl	800b6d4 <lsm6dsv16x_read_reg>
 800b820:	4602      	mov	r2, r0
 800b822:	697b      	ldr	r3, [r7, #20]
 800b824:	4413      	add	r3, r2
 800b826:	617b      	str	r3, [r7, #20]
  if (ret != 0) { return ret; }
 800b828:	697b      	ldr	r3, [r7, #20]
 800b82a:	2b00      	cmp	r3, #0
 800b82c:	d001      	beq.n	800b832 <lsm6dsv16x_xl_data_rate_get+0x3a>
 800b82e:	697b      	ldr	r3, [r7, #20]
 800b830:	e0ed      	b.n	800ba0e <lsm6dsv16x_xl_data_rate_get+0x216>

  sel = haodr.haodr_sel;
 800b832:	7b3b      	ldrb	r3, [r7, #12]
 800b834:	f3c3 0301 	ubfx	r3, r3, #0, #2
 800b838:	b2db      	uxtb	r3, r3
 800b83a:	74fb      	strb	r3, [r7, #19]

  switch (ctrl1.odr_xl)
 800b83c:	7c3b      	ldrb	r3, [r7, #16]
 800b83e:	f3c3 0303 	ubfx	r3, r3, #0, #4
 800b842:	b2db      	uxtb	r3, r3
 800b844:	2b0c      	cmp	r3, #12
 800b846:	f200 80dd 	bhi.w	800ba04 <lsm6dsv16x_xl_data_rate_get+0x20c>
 800b84a:	a201      	add	r2, pc, #4	@ (adr r2, 800b850 <lsm6dsv16x_xl_data_rate_get+0x58>)
 800b84c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800b850:	0800b885 	.word	0x0800b885
 800b854:	0800b88d 	.word	0x0800b88d
 800b858:	0800b895 	.word	0x0800b895
 800b85c:	0800b89d 	.word	0x0800b89d
 800b860:	0800b8c1 	.word	0x0800b8c1
 800b864:	0800b8e5 	.word	0x0800b8e5
 800b868:	0800b909 	.word	0x0800b909
 800b86c:	0800b92d 	.word	0x0800b92d
 800b870:	0800b951 	.word	0x0800b951
 800b874:	0800b975 	.word	0x0800b975
 800b878:	0800b999 	.word	0x0800b999
 800b87c:	0800b9bd 	.word	0x0800b9bd
 800b880:	0800b9e1 	.word	0x0800b9e1
  {
    case LSM6DSV16X_ODR_OFF:
      *val = LSM6DSV16X_ODR_OFF;
 800b884:	683b      	ldr	r3, [r7, #0]
 800b886:	2200      	movs	r2, #0
 800b888:	701a      	strb	r2, [r3, #0]
      break;
 800b88a:	e0bf      	b.n	800ba0c <lsm6dsv16x_xl_data_rate_get+0x214>

    case LSM6DSV16X_ODR_AT_1Hz875:
      *val = LSM6DSV16X_ODR_AT_1Hz875;
 800b88c:	683b      	ldr	r3, [r7, #0]
 800b88e:	2201      	movs	r2, #1
 800b890:	701a      	strb	r2, [r3, #0]
      break;
 800b892:	e0bb      	b.n	800ba0c <lsm6dsv16x_xl_data_rate_get+0x214>

    case LSM6DSV16X_ODR_AT_7Hz5:
      *val = LSM6DSV16X_ODR_AT_7Hz5;
 800b894:	683b      	ldr	r3, [r7, #0]
 800b896:	2202      	movs	r2, #2
 800b898:	701a      	strb	r2, [r3, #0]
      break;
 800b89a:	e0b7      	b.n	800ba0c <lsm6dsv16x_xl_data_rate_get+0x214>

    case LSM6DSV16X_ODR_AT_15Hz:
      switch (sel) {
 800b89c:	7cfb      	ldrb	r3, [r7, #19]
 800b89e:	2b01      	cmp	r3, #1
 800b8a0:	d005      	beq.n	800b8ae <lsm6dsv16x_xl_data_rate_get+0xb6>
 800b8a2:	2b02      	cmp	r3, #2
 800b8a4:	d007      	beq.n	800b8b6 <lsm6dsv16x_xl_data_rate_get+0xbe>
      default:
      case 0:
        *val = LSM6DSV16X_ODR_AT_15Hz;
 800b8a6:	683b      	ldr	r3, [r7, #0]
 800b8a8:	2203      	movs	r2, #3
 800b8aa:	701a      	strb	r2, [r3, #0]
        break;
 800b8ac:	e007      	b.n	800b8be <lsm6dsv16x_xl_data_rate_get+0xc6>
      case 1:
        *val = LSM6DSV16X_ODR_HA01_AT_15Hz625;
 800b8ae:	683b      	ldr	r3, [r7, #0]
 800b8b0:	2213      	movs	r2, #19
 800b8b2:	701a      	strb	r2, [r3, #0]
        break;
 800b8b4:	e003      	b.n	800b8be <lsm6dsv16x_xl_data_rate_get+0xc6>
      case 2:
        *val = LSM6DSV16X_ODR_HA02_AT_12Hz5;
 800b8b6:	683b      	ldr	r3, [r7, #0]
 800b8b8:	2223      	movs	r2, #35	@ 0x23
 800b8ba:	701a      	strb	r2, [r3, #0]
        break;
 800b8bc:	bf00      	nop
      }
      break;
 800b8be:	e0a5      	b.n	800ba0c <lsm6dsv16x_xl_data_rate_get+0x214>

    case LSM6DSV16X_ODR_AT_30Hz:
      switch (sel) {
 800b8c0:	7cfb      	ldrb	r3, [r7, #19]
 800b8c2:	2b01      	cmp	r3, #1
 800b8c4:	d005      	beq.n	800b8d2 <lsm6dsv16x_xl_data_rate_get+0xda>
 800b8c6:	2b02      	cmp	r3, #2
 800b8c8:	d007      	beq.n	800b8da <lsm6dsv16x_xl_data_rate_get+0xe2>
      default:
      case 0:
        *val = LSM6DSV16X_ODR_AT_30Hz;
 800b8ca:	683b      	ldr	r3, [r7, #0]
 800b8cc:	2204      	movs	r2, #4
 800b8ce:	701a      	strb	r2, [r3, #0]
        break;
 800b8d0:	e007      	b.n	800b8e2 <lsm6dsv16x_xl_data_rate_get+0xea>
      case 1:
        *val = LSM6DSV16X_ODR_HA01_AT_31Hz25;
 800b8d2:	683b      	ldr	r3, [r7, #0]
 800b8d4:	2214      	movs	r2, #20
 800b8d6:	701a      	strb	r2, [r3, #0]
        break;
 800b8d8:	e003      	b.n	800b8e2 <lsm6dsv16x_xl_data_rate_get+0xea>
      case 2:
        *val = LSM6DSV16X_ODR_HA02_AT_25Hz;
 800b8da:	683b      	ldr	r3, [r7, #0]
 800b8dc:	2224      	movs	r2, #36	@ 0x24
 800b8de:	701a      	strb	r2, [r3, #0]
        break;
 800b8e0:	bf00      	nop
      }
      break;
 800b8e2:	e093      	b.n	800ba0c <lsm6dsv16x_xl_data_rate_get+0x214>

    case LSM6DSV16X_ODR_AT_60Hz:
      switch (sel) {
 800b8e4:	7cfb      	ldrb	r3, [r7, #19]
 800b8e6:	2b01      	cmp	r3, #1
 800b8e8:	d005      	beq.n	800b8f6 <lsm6dsv16x_xl_data_rate_get+0xfe>
 800b8ea:	2b02      	cmp	r3, #2
 800b8ec:	d007      	beq.n	800b8fe <lsm6dsv16x_xl_data_rate_get+0x106>
      default:
      case 0:
        *val = LSM6DSV16X_ODR_AT_60Hz;
 800b8ee:	683b      	ldr	r3, [r7, #0]
 800b8f0:	2205      	movs	r2, #5
 800b8f2:	701a      	strb	r2, [r3, #0]
        break;
 800b8f4:	e007      	b.n	800b906 <lsm6dsv16x_xl_data_rate_get+0x10e>
      case 1:
        *val = LSM6DSV16X_ODR_HA01_AT_62Hz5;
 800b8f6:	683b      	ldr	r3, [r7, #0]
 800b8f8:	2215      	movs	r2, #21
 800b8fa:	701a      	strb	r2, [r3, #0]
        break;
 800b8fc:	e003      	b.n	800b906 <lsm6dsv16x_xl_data_rate_get+0x10e>
      case 2:
        *val = LSM6DSV16X_ODR_HA02_AT_50Hz;
 800b8fe:	683b      	ldr	r3, [r7, #0]
 800b900:	2225      	movs	r2, #37	@ 0x25
 800b902:	701a      	strb	r2, [r3, #0]
        break;
 800b904:	bf00      	nop
      }
      break;
 800b906:	e081      	b.n	800ba0c <lsm6dsv16x_xl_data_rate_get+0x214>

    case LSM6DSV16X_ODR_AT_120Hz:
      switch (sel) {
 800b908:	7cfb      	ldrb	r3, [r7, #19]
 800b90a:	2b01      	cmp	r3, #1
 800b90c:	d005      	beq.n	800b91a <lsm6dsv16x_xl_data_rate_get+0x122>
 800b90e:	2b02      	cmp	r3, #2
 800b910:	d007      	beq.n	800b922 <lsm6dsv16x_xl_data_rate_get+0x12a>
      default:
      case 0:
        *val = LSM6DSV16X_ODR_AT_120Hz;
 800b912:	683b      	ldr	r3, [r7, #0]
 800b914:	2206      	movs	r2, #6
 800b916:	701a      	strb	r2, [r3, #0]
        break;
 800b918:	e007      	b.n	800b92a <lsm6dsv16x_xl_data_rate_get+0x132>
      case 1:
        *val = LSM6DSV16X_ODR_HA01_AT_125Hz;
 800b91a:	683b      	ldr	r3, [r7, #0]
 800b91c:	2216      	movs	r2, #22
 800b91e:	701a      	strb	r2, [r3, #0]
        break;
 800b920:	e003      	b.n	800b92a <lsm6dsv16x_xl_data_rate_get+0x132>
      case 2:
        *val = LSM6DSV16X_ODR_HA02_AT_100Hz;
 800b922:	683b      	ldr	r3, [r7, #0]
 800b924:	2226      	movs	r2, #38	@ 0x26
 800b926:	701a      	strb	r2, [r3, #0]
        break;
 800b928:	bf00      	nop
      }
      break;
 800b92a:	e06f      	b.n	800ba0c <lsm6dsv16x_xl_data_rate_get+0x214>

    case LSM6DSV16X_ODR_AT_240Hz:
      switch (sel) {
 800b92c:	7cfb      	ldrb	r3, [r7, #19]
 800b92e:	2b01      	cmp	r3, #1
 800b930:	d005      	beq.n	800b93e <lsm6dsv16x_xl_data_rate_get+0x146>
 800b932:	2b02      	cmp	r3, #2
 800b934:	d007      	beq.n	800b946 <lsm6dsv16x_xl_data_rate_get+0x14e>
      default:
      case 0:
        *val = LSM6DSV16X_ODR_AT_240Hz;
 800b936:	683b      	ldr	r3, [r7, #0]
 800b938:	2207      	movs	r2, #7
 800b93a:	701a      	strb	r2, [r3, #0]
        break;
 800b93c:	e007      	b.n	800b94e <lsm6dsv16x_xl_data_rate_get+0x156>
      case 1:
        *val = LSM6DSV16X_ODR_HA01_AT_250Hz;
 800b93e:	683b      	ldr	r3, [r7, #0]
 800b940:	2217      	movs	r2, #23
 800b942:	701a      	strb	r2, [r3, #0]
        break;
 800b944:	e003      	b.n	800b94e <lsm6dsv16x_xl_data_rate_get+0x156>
      case 2:
        *val = LSM6DSV16X_ODR_HA02_AT_200Hz;
 800b946:	683b      	ldr	r3, [r7, #0]
 800b948:	2227      	movs	r2, #39	@ 0x27
 800b94a:	701a      	strb	r2, [r3, #0]
        break;
 800b94c:	bf00      	nop
      }
      break;
 800b94e:	e05d      	b.n	800ba0c <lsm6dsv16x_xl_data_rate_get+0x214>

    case LSM6DSV16X_ODR_AT_480Hz:
      switch (sel) {
 800b950:	7cfb      	ldrb	r3, [r7, #19]
 800b952:	2b01      	cmp	r3, #1
 800b954:	d005      	beq.n	800b962 <lsm6dsv16x_xl_data_rate_get+0x16a>
 800b956:	2b02      	cmp	r3, #2
 800b958:	d007      	beq.n	800b96a <lsm6dsv16x_xl_data_rate_get+0x172>
      default:
      case 0:
        *val = LSM6DSV16X_ODR_AT_480Hz;
 800b95a:	683b      	ldr	r3, [r7, #0]
 800b95c:	2208      	movs	r2, #8
 800b95e:	701a      	strb	r2, [r3, #0]
        break;
 800b960:	e007      	b.n	800b972 <lsm6dsv16x_xl_data_rate_get+0x17a>
      case 1:
        *val = LSM6DSV16X_ODR_HA01_AT_500Hz;
 800b962:	683b      	ldr	r3, [r7, #0]
 800b964:	2218      	movs	r2, #24
 800b966:	701a      	strb	r2, [r3, #0]
        break;
 800b968:	e003      	b.n	800b972 <lsm6dsv16x_xl_data_rate_get+0x17a>
      case 2:
        *val = LSM6DSV16X_ODR_HA02_AT_400Hz;
 800b96a:	683b      	ldr	r3, [r7, #0]
 800b96c:	2228      	movs	r2, #40	@ 0x28
 800b96e:	701a      	strb	r2, [r3, #0]
        break;
 800b970:	bf00      	nop
      }
      break;
 800b972:	e04b      	b.n	800ba0c <lsm6dsv16x_xl_data_rate_get+0x214>

    case LSM6DSV16X_ODR_AT_960Hz:
      switch (sel) {
 800b974:	7cfb      	ldrb	r3, [r7, #19]
 800b976:	2b01      	cmp	r3, #1
 800b978:	d005      	beq.n	800b986 <lsm6dsv16x_xl_data_rate_get+0x18e>
 800b97a:	2b02      	cmp	r3, #2
 800b97c:	d007      	beq.n	800b98e <lsm6dsv16x_xl_data_rate_get+0x196>
      default:
      case 0:
        *val = LSM6DSV16X_ODR_AT_960Hz;
 800b97e:	683b      	ldr	r3, [r7, #0]
 800b980:	2209      	movs	r2, #9
 800b982:	701a      	strb	r2, [r3, #0]
        break;
 800b984:	e007      	b.n	800b996 <lsm6dsv16x_xl_data_rate_get+0x19e>
      case 1:
        *val = LSM6DSV16X_ODR_HA01_AT_1000Hz;
 800b986:	683b      	ldr	r3, [r7, #0]
 800b988:	2219      	movs	r2, #25
 800b98a:	701a      	strb	r2, [r3, #0]
        break;
 800b98c:	e003      	b.n	800b996 <lsm6dsv16x_xl_data_rate_get+0x19e>
      case 2:
        *val = LSM6DSV16X_ODR_HA02_AT_800Hz;
 800b98e:	683b      	ldr	r3, [r7, #0]
 800b990:	2229      	movs	r2, #41	@ 0x29
 800b992:	701a      	strb	r2, [r3, #0]
        break;
 800b994:	bf00      	nop
      }
      break;
 800b996:	e039      	b.n	800ba0c <lsm6dsv16x_xl_data_rate_get+0x214>

    case LSM6DSV16X_ODR_AT_1920Hz:
      switch (sel) {
 800b998:	7cfb      	ldrb	r3, [r7, #19]
 800b99a:	2b01      	cmp	r3, #1
 800b99c:	d005      	beq.n	800b9aa <lsm6dsv16x_xl_data_rate_get+0x1b2>
 800b99e:	2b02      	cmp	r3, #2
 800b9a0:	d007      	beq.n	800b9b2 <lsm6dsv16x_xl_data_rate_get+0x1ba>
      default:
      case 0:
        *val = LSM6DSV16X_ODR_AT_1920Hz;
 800b9a2:	683b      	ldr	r3, [r7, #0]
 800b9a4:	220a      	movs	r2, #10
 800b9a6:	701a      	strb	r2, [r3, #0]
        break;
 800b9a8:	e007      	b.n	800b9ba <lsm6dsv16x_xl_data_rate_get+0x1c2>
      case 1:
        *val = LSM6DSV16X_ODR_HA01_AT_2000Hz;
 800b9aa:	683b      	ldr	r3, [r7, #0]
 800b9ac:	221a      	movs	r2, #26
 800b9ae:	701a      	strb	r2, [r3, #0]
        break;
 800b9b0:	e003      	b.n	800b9ba <lsm6dsv16x_xl_data_rate_get+0x1c2>
      case 2:
        *val = LSM6DSV16X_ODR_HA02_AT_1600Hz;
 800b9b2:	683b      	ldr	r3, [r7, #0]
 800b9b4:	222a      	movs	r2, #42	@ 0x2a
 800b9b6:	701a      	strb	r2, [r3, #0]
        break;
 800b9b8:	bf00      	nop
      }
      break;
 800b9ba:	e027      	b.n	800ba0c <lsm6dsv16x_xl_data_rate_get+0x214>

    case LSM6DSV16X_ODR_AT_3840Hz:
      switch (sel) {
 800b9bc:	7cfb      	ldrb	r3, [r7, #19]
 800b9be:	2b01      	cmp	r3, #1
 800b9c0:	d005      	beq.n	800b9ce <lsm6dsv16x_xl_data_rate_get+0x1d6>
 800b9c2:	2b02      	cmp	r3, #2
 800b9c4:	d007      	beq.n	800b9d6 <lsm6dsv16x_xl_data_rate_get+0x1de>
      default:
      case 0:
        *val = LSM6DSV16X_ODR_AT_3840Hz;
 800b9c6:	683b      	ldr	r3, [r7, #0]
 800b9c8:	220b      	movs	r2, #11
 800b9ca:	701a      	strb	r2, [r3, #0]
        break;
 800b9cc:	e007      	b.n	800b9de <lsm6dsv16x_xl_data_rate_get+0x1e6>
      case 1:
        *val = LSM6DSV16X_ODR_HA01_AT_4000Hz;
 800b9ce:	683b      	ldr	r3, [r7, #0]
 800b9d0:	221b      	movs	r2, #27
 800b9d2:	701a      	strb	r2, [r3, #0]
        break;
 800b9d4:	e003      	b.n	800b9de <lsm6dsv16x_xl_data_rate_get+0x1e6>
      case 2:
        *val = LSM6DSV16X_ODR_HA02_AT_3200Hz;
 800b9d6:	683b      	ldr	r3, [r7, #0]
 800b9d8:	222b      	movs	r2, #43	@ 0x2b
 800b9da:	701a      	strb	r2, [r3, #0]
        break;
 800b9dc:	bf00      	nop
      }
      break;
 800b9de:	e015      	b.n	800ba0c <lsm6dsv16x_xl_data_rate_get+0x214>

    case LSM6DSV16X_ODR_AT_7680Hz:
      switch (sel) {
 800b9e0:	7cfb      	ldrb	r3, [r7, #19]
 800b9e2:	2b01      	cmp	r3, #1
 800b9e4:	d005      	beq.n	800b9f2 <lsm6dsv16x_xl_data_rate_get+0x1fa>
 800b9e6:	2b02      	cmp	r3, #2
 800b9e8:	d007      	beq.n	800b9fa <lsm6dsv16x_xl_data_rate_get+0x202>
      default:
      case 0:
        *val = LSM6DSV16X_ODR_AT_7680Hz;
 800b9ea:	683b      	ldr	r3, [r7, #0]
 800b9ec:	220c      	movs	r2, #12
 800b9ee:	701a      	strb	r2, [r3, #0]
        break;
 800b9f0:	e007      	b.n	800ba02 <lsm6dsv16x_xl_data_rate_get+0x20a>
      case 1:
        *val = LSM6DSV16X_ODR_HA01_AT_8000Hz;
 800b9f2:	683b      	ldr	r3, [r7, #0]
 800b9f4:	221c      	movs	r2, #28
 800b9f6:	701a      	strb	r2, [r3, #0]
        break;
 800b9f8:	e003      	b.n	800ba02 <lsm6dsv16x_xl_data_rate_get+0x20a>
      case 2:
        *val = LSM6DSV16X_ODR_HA02_AT_6400Hz;
 800b9fa:	683b      	ldr	r3, [r7, #0]
 800b9fc:	222c      	movs	r2, #44	@ 0x2c
 800b9fe:	701a      	strb	r2, [r3, #0]
        break;
 800ba00:	bf00      	nop
      }
      break;
 800ba02:	e003      	b.n	800ba0c <lsm6dsv16x_xl_data_rate_get+0x214>

    default:
      *val = LSM6DSV16X_ODR_OFF;
 800ba04:	683b      	ldr	r3, [r7, #0]
 800ba06:	2200      	movs	r2, #0
 800ba08:	701a      	strb	r2, [r3, #0]
      break;
 800ba0a:	bf00      	nop
  }

  return ret;
 800ba0c:	697b      	ldr	r3, [r7, #20]
}
 800ba0e:	4618      	mov	r0, r3
 800ba10:	3718      	adds	r7, #24
 800ba12:	46bd      	mov	sp, r7
 800ba14:	bd80      	pop	{r7, pc}
 800ba16:	bf00      	nop

0800ba18 <lsm6dsv16x_gy_data_rate_set>:
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lsm6dsv16x_gy_data_rate_set(stmdev_ctx_t *ctx,
                                    lsm6dsv16x_data_rate_t val)
{
 800ba18:	b580      	push	{r7, lr}
 800ba1a:	b086      	sub	sp, #24
 800ba1c:	af00      	add	r7, sp, #0
 800ba1e:	6078      	str	r0, [r7, #4]
 800ba20:	460b      	mov	r3, r1
 800ba22:	70fb      	strb	r3, [r7, #3]
  lsm6dsv16x_ctrl2_t ctrl2;
  lsm6dsv16x_haodr_cfg_t haodr;
  uint8_t sel;
  int32_t ret;

  ret = lsm6dsv16x_read_reg(ctx, LSM6DSV16X_CTRL2, (uint8_t *)&ctrl2, 1);
 800ba24:	f107 0210 	add.w	r2, r7, #16
 800ba28:	2301      	movs	r3, #1
 800ba2a:	2111      	movs	r1, #17
 800ba2c:	6878      	ldr	r0, [r7, #4]
 800ba2e:	f7ff fe51 	bl	800b6d4 <lsm6dsv16x_read_reg>
 800ba32:	6178      	str	r0, [r7, #20]
  ctrl2.odr_g = (uint8_t)val & 0x0Fu;
 800ba34:	78fb      	ldrb	r3, [r7, #3]
 800ba36:	f003 030f 	and.w	r3, r3, #15
 800ba3a:	b2da      	uxtb	r2, r3
 800ba3c:	7c3b      	ldrb	r3, [r7, #16]
 800ba3e:	f362 0303 	bfi	r3, r2, #0, #4
 800ba42:	743b      	strb	r3, [r7, #16]
  ret += lsm6dsv16x_write_reg(ctx, LSM6DSV16X_CTRL2, (uint8_t *)&ctrl2, 1);
 800ba44:	f107 0210 	add.w	r2, r7, #16
 800ba48:	2301      	movs	r3, #1
 800ba4a:	2111      	movs	r1, #17
 800ba4c:	6878      	ldr	r0, [r7, #4]
 800ba4e:	f7ff fe59 	bl	800b704 <lsm6dsv16x_write_reg>
 800ba52:	4602      	mov	r2, r0
 800ba54:	697b      	ldr	r3, [r7, #20]
 800ba56:	4413      	add	r3, r2
 800ba58:	617b      	str	r3, [r7, #20]
  if (ret != 0) { return ret; }
 800ba5a:	697b      	ldr	r3, [r7, #20]
 800ba5c:	2b00      	cmp	r3, #0
 800ba5e:	d001      	beq.n	800ba64 <lsm6dsv16x_gy_data_rate_set+0x4c>
 800ba60:	697b      	ldr	r3, [r7, #20]
 800ba62:	e024      	b.n	800baae <lsm6dsv16x_gy_data_rate_set+0x96>

  sel = ((uint8_t)val >> 4) & 0xFU;
 800ba64:	78fb      	ldrb	r3, [r7, #3]
 800ba66:	091b      	lsrs	r3, r3, #4
 800ba68:	74fb      	strb	r3, [r7, #19]
  if (sel != 0U)
 800ba6a:	7cfb      	ldrb	r3, [r7, #19]
 800ba6c:	2b00      	cmp	r3, #0
 800ba6e:	d01d      	beq.n	800baac <lsm6dsv16x_gy_data_rate_set+0x94>
  {
    ret += lsm6dsv16x_read_reg(ctx, LSM6DSV16X_HAODR_CFG, (uint8_t *)&haodr, 1);
 800ba70:	f107 020c 	add.w	r2, r7, #12
 800ba74:	2301      	movs	r3, #1
 800ba76:	2162      	movs	r1, #98	@ 0x62
 800ba78:	6878      	ldr	r0, [r7, #4]
 800ba7a:	f7ff fe2b 	bl	800b6d4 <lsm6dsv16x_read_reg>
 800ba7e:	4602      	mov	r2, r0
 800ba80:	697b      	ldr	r3, [r7, #20]
 800ba82:	4413      	add	r3, r2
 800ba84:	617b      	str	r3, [r7, #20]
    haodr.haodr_sel = sel;
 800ba86:	7cfb      	ldrb	r3, [r7, #19]
 800ba88:	f003 0303 	and.w	r3, r3, #3
 800ba8c:	b2da      	uxtb	r2, r3
 800ba8e:	7b3b      	ldrb	r3, [r7, #12]
 800ba90:	f362 0301 	bfi	r3, r2, #0, #2
 800ba94:	733b      	strb	r3, [r7, #12]
    ret += lsm6dsv16x_write_reg(ctx, LSM6DSV16X_HAODR_CFG, (uint8_t *)&haodr, 1);
 800ba96:	f107 020c 	add.w	r2, r7, #12
 800ba9a:	2301      	movs	r3, #1
 800ba9c:	2162      	movs	r1, #98	@ 0x62
 800ba9e:	6878      	ldr	r0, [r7, #4]
 800baa0:	f7ff fe30 	bl	800b704 <lsm6dsv16x_write_reg>
 800baa4:	4602      	mov	r2, r0
 800baa6:	697b      	ldr	r3, [r7, #20]
 800baa8:	4413      	add	r3, r2
 800baaa:	617b      	str	r3, [r7, #20]
  }

  return ret;
 800baac:	697b      	ldr	r3, [r7, #20]
}
 800baae:	4618      	mov	r0, r3
 800bab0:	3718      	adds	r7, #24
 800bab2:	46bd      	mov	sp, r7
 800bab4:	bd80      	pop	{r7, pc}
	...

0800bab8 <lsm6dsv16x_gy_data_rate_get>:
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lsm6dsv16x_gy_data_rate_get(stmdev_ctx_t *ctx,
                                    lsm6dsv16x_data_rate_t *val)
{
 800bab8:	b580      	push	{r7, lr}
 800baba:	b086      	sub	sp, #24
 800babc:	af00      	add	r7, sp, #0
 800babe:	6078      	str	r0, [r7, #4]
 800bac0:	6039      	str	r1, [r7, #0]
  lsm6dsv16x_ctrl2_t ctrl2;
  lsm6dsv16x_haodr_cfg_t haodr;
  uint8_t sel;
  int32_t ret;

  ret = lsm6dsv16x_read_reg(ctx, LSM6DSV16X_CTRL2, (uint8_t *)&ctrl2, 1);
 800bac2:	f107 0210 	add.w	r2, r7, #16
 800bac6:	2301      	movs	r3, #1
 800bac8:	2111      	movs	r1, #17
 800baca:	6878      	ldr	r0, [r7, #4]
 800bacc:	f7ff fe02 	bl	800b6d4 <lsm6dsv16x_read_reg>
 800bad0:	6178      	str	r0, [r7, #20]
  ret += lsm6dsv16x_read_reg(ctx, LSM6DSV16X_HAODR_CFG, (uint8_t *)&haodr, 1);
 800bad2:	f107 020c 	add.w	r2, r7, #12
 800bad6:	2301      	movs	r3, #1
 800bad8:	2162      	movs	r1, #98	@ 0x62
 800bada:	6878      	ldr	r0, [r7, #4]
 800badc:	f7ff fdfa 	bl	800b6d4 <lsm6dsv16x_read_reg>
 800bae0:	4602      	mov	r2, r0
 800bae2:	697b      	ldr	r3, [r7, #20]
 800bae4:	4413      	add	r3, r2
 800bae6:	617b      	str	r3, [r7, #20]
  if (ret != 0) { return ret; }
 800bae8:	697b      	ldr	r3, [r7, #20]
 800baea:	2b00      	cmp	r3, #0
 800baec:	d001      	beq.n	800baf2 <lsm6dsv16x_gy_data_rate_get+0x3a>
 800baee:	697b      	ldr	r3, [r7, #20]
 800baf0:	e0ed      	b.n	800bcce <lsm6dsv16x_gy_data_rate_get+0x216>

  sel = haodr.haodr_sel;
 800baf2:	7b3b      	ldrb	r3, [r7, #12]
 800baf4:	f3c3 0301 	ubfx	r3, r3, #0, #2
 800baf8:	b2db      	uxtb	r3, r3
 800bafa:	74fb      	strb	r3, [r7, #19]

  switch (ctrl2.odr_g)
 800bafc:	7c3b      	ldrb	r3, [r7, #16]
 800bafe:	f3c3 0303 	ubfx	r3, r3, #0, #4
 800bb02:	b2db      	uxtb	r3, r3
 800bb04:	2b0c      	cmp	r3, #12
 800bb06:	f200 80dd 	bhi.w	800bcc4 <lsm6dsv16x_gy_data_rate_get+0x20c>
 800bb0a:	a201      	add	r2, pc, #4	@ (adr r2, 800bb10 <lsm6dsv16x_gy_data_rate_get+0x58>)
 800bb0c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800bb10:	0800bb45 	.word	0x0800bb45
 800bb14:	0800bb4d 	.word	0x0800bb4d
 800bb18:	0800bb55 	.word	0x0800bb55
 800bb1c:	0800bb5d 	.word	0x0800bb5d
 800bb20:	0800bb81 	.word	0x0800bb81
 800bb24:	0800bba5 	.word	0x0800bba5
 800bb28:	0800bbc9 	.word	0x0800bbc9
 800bb2c:	0800bbed 	.word	0x0800bbed
 800bb30:	0800bc11 	.word	0x0800bc11
 800bb34:	0800bc35 	.word	0x0800bc35
 800bb38:	0800bc59 	.word	0x0800bc59
 800bb3c:	0800bc7d 	.word	0x0800bc7d
 800bb40:	0800bca1 	.word	0x0800bca1
  {
    case LSM6DSV16X_ODR_OFF:
      *val = LSM6DSV16X_ODR_OFF;
 800bb44:	683b      	ldr	r3, [r7, #0]
 800bb46:	2200      	movs	r2, #0
 800bb48:	701a      	strb	r2, [r3, #0]
      break;
 800bb4a:	e0bf      	b.n	800bccc <lsm6dsv16x_gy_data_rate_get+0x214>

    case LSM6DSV16X_ODR_AT_1Hz875:
      *val = LSM6DSV16X_ODR_AT_1Hz875;
 800bb4c:	683b      	ldr	r3, [r7, #0]
 800bb4e:	2201      	movs	r2, #1
 800bb50:	701a      	strb	r2, [r3, #0]
      break;
 800bb52:	e0bb      	b.n	800bccc <lsm6dsv16x_gy_data_rate_get+0x214>

    case LSM6DSV16X_ODR_AT_7Hz5:
      *val = LSM6DSV16X_ODR_AT_7Hz5;
 800bb54:	683b      	ldr	r3, [r7, #0]
 800bb56:	2202      	movs	r2, #2
 800bb58:	701a      	strb	r2, [r3, #0]
      break;
 800bb5a:	e0b7      	b.n	800bccc <lsm6dsv16x_gy_data_rate_get+0x214>

    case LSM6DSV16X_ODR_AT_15Hz:
      switch (sel) {
 800bb5c:	7cfb      	ldrb	r3, [r7, #19]
 800bb5e:	2b01      	cmp	r3, #1
 800bb60:	d005      	beq.n	800bb6e <lsm6dsv16x_gy_data_rate_get+0xb6>
 800bb62:	2b02      	cmp	r3, #2
 800bb64:	d007      	beq.n	800bb76 <lsm6dsv16x_gy_data_rate_get+0xbe>
      default:
      case 0:
        *val = LSM6DSV16X_ODR_AT_15Hz;
 800bb66:	683b      	ldr	r3, [r7, #0]
 800bb68:	2203      	movs	r2, #3
 800bb6a:	701a      	strb	r2, [r3, #0]
        break;
 800bb6c:	e007      	b.n	800bb7e <lsm6dsv16x_gy_data_rate_get+0xc6>
      case 1:
        *val = LSM6DSV16X_ODR_HA01_AT_15Hz625;
 800bb6e:	683b      	ldr	r3, [r7, #0]
 800bb70:	2213      	movs	r2, #19
 800bb72:	701a      	strb	r2, [r3, #0]
        break;
 800bb74:	e003      	b.n	800bb7e <lsm6dsv16x_gy_data_rate_get+0xc6>
      case 2:
        *val = LSM6DSV16X_ODR_HA02_AT_12Hz5;
 800bb76:	683b      	ldr	r3, [r7, #0]
 800bb78:	2223      	movs	r2, #35	@ 0x23
 800bb7a:	701a      	strb	r2, [r3, #0]
        break;
 800bb7c:	bf00      	nop
      }
      break;
 800bb7e:	e0a5      	b.n	800bccc <lsm6dsv16x_gy_data_rate_get+0x214>

    case LSM6DSV16X_ODR_AT_30Hz:
      switch (sel) {
 800bb80:	7cfb      	ldrb	r3, [r7, #19]
 800bb82:	2b01      	cmp	r3, #1
 800bb84:	d005      	beq.n	800bb92 <lsm6dsv16x_gy_data_rate_get+0xda>
 800bb86:	2b02      	cmp	r3, #2
 800bb88:	d007      	beq.n	800bb9a <lsm6dsv16x_gy_data_rate_get+0xe2>
      default:
      case 0:
        *val = LSM6DSV16X_ODR_AT_30Hz;
 800bb8a:	683b      	ldr	r3, [r7, #0]
 800bb8c:	2204      	movs	r2, #4
 800bb8e:	701a      	strb	r2, [r3, #0]
        break;
 800bb90:	e007      	b.n	800bba2 <lsm6dsv16x_gy_data_rate_get+0xea>
      case 1:
        *val = LSM6DSV16X_ODR_HA01_AT_31Hz25;
 800bb92:	683b      	ldr	r3, [r7, #0]
 800bb94:	2214      	movs	r2, #20
 800bb96:	701a      	strb	r2, [r3, #0]
        break;
 800bb98:	e003      	b.n	800bba2 <lsm6dsv16x_gy_data_rate_get+0xea>
      case 2:
        *val = LSM6DSV16X_ODR_HA02_AT_25Hz;
 800bb9a:	683b      	ldr	r3, [r7, #0]
 800bb9c:	2224      	movs	r2, #36	@ 0x24
 800bb9e:	701a      	strb	r2, [r3, #0]
        break;
 800bba0:	bf00      	nop
      }
      break;
 800bba2:	e093      	b.n	800bccc <lsm6dsv16x_gy_data_rate_get+0x214>

    case LSM6DSV16X_ODR_AT_60Hz:
      switch (sel) {
 800bba4:	7cfb      	ldrb	r3, [r7, #19]
 800bba6:	2b01      	cmp	r3, #1
 800bba8:	d005      	beq.n	800bbb6 <lsm6dsv16x_gy_data_rate_get+0xfe>
 800bbaa:	2b02      	cmp	r3, #2
 800bbac:	d007      	beq.n	800bbbe <lsm6dsv16x_gy_data_rate_get+0x106>
      default:
      case 0:
        *val = LSM6DSV16X_ODR_AT_60Hz;
 800bbae:	683b      	ldr	r3, [r7, #0]
 800bbb0:	2205      	movs	r2, #5
 800bbb2:	701a      	strb	r2, [r3, #0]
        break;
 800bbb4:	e007      	b.n	800bbc6 <lsm6dsv16x_gy_data_rate_get+0x10e>
      case 1:
        *val = LSM6DSV16X_ODR_HA01_AT_62Hz5;
 800bbb6:	683b      	ldr	r3, [r7, #0]
 800bbb8:	2215      	movs	r2, #21
 800bbba:	701a      	strb	r2, [r3, #0]
        break;
 800bbbc:	e003      	b.n	800bbc6 <lsm6dsv16x_gy_data_rate_get+0x10e>
      case 2:
        *val = LSM6DSV16X_ODR_HA02_AT_50Hz;
 800bbbe:	683b      	ldr	r3, [r7, #0]
 800bbc0:	2225      	movs	r2, #37	@ 0x25
 800bbc2:	701a      	strb	r2, [r3, #0]
        break;
 800bbc4:	bf00      	nop
      }
      break;
 800bbc6:	e081      	b.n	800bccc <lsm6dsv16x_gy_data_rate_get+0x214>

    case LSM6DSV16X_ODR_AT_120Hz:
      switch (sel) {
 800bbc8:	7cfb      	ldrb	r3, [r7, #19]
 800bbca:	2b01      	cmp	r3, #1
 800bbcc:	d005      	beq.n	800bbda <lsm6dsv16x_gy_data_rate_get+0x122>
 800bbce:	2b02      	cmp	r3, #2
 800bbd0:	d007      	beq.n	800bbe2 <lsm6dsv16x_gy_data_rate_get+0x12a>
      default:
      case 0:
        *val = LSM6DSV16X_ODR_AT_120Hz;
 800bbd2:	683b      	ldr	r3, [r7, #0]
 800bbd4:	2206      	movs	r2, #6
 800bbd6:	701a      	strb	r2, [r3, #0]
        break;
 800bbd8:	e007      	b.n	800bbea <lsm6dsv16x_gy_data_rate_get+0x132>
      case 1:
        *val = LSM6DSV16X_ODR_HA01_AT_125Hz;
 800bbda:	683b      	ldr	r3, [r7, #0]
 800bbdc:	2216      	movs	r2, #22
 800bbde:	701a      	strb	r2, [r3, #0]
        break;
 800bbe0:	e003      	b.n	800bbea <lsm6dsv16x_gy_data_rate_get+0x132>
      case 2:
        *val = LSM6DSV16X_ODR_HA02_AT_100Hz;
 800bbe2:	683b      	ldr	r3, [r7, #0]
 800bbe4:	2226      	movs	r2, #38	@ 0x26
 800bbe6:	701a      	strb	r2, [r3, #0]
        break;
 800bbe8:	bf00      	nop
      }
      break;
 800bbea:	e06f      	b.n	800bccc <lsm6dsv16x_gy_data_rate_get+0x214>

    case LSM6DSV16X_ODR_AT_240Hz:
      switch (sel) {
 800bbec:	7cfb      	ldrb	r3, [r7, #19]
 800bbee:	2b01      	cmp	r3, #1
 800bbf0:	d005      	beq.n	800bbfe <lsm6dsv16x_gy_data_rate_get+0x146>
 800bbf2:	2b02      	cmp	r3, #2
 800bbf4:	d007      	beq.n	800bc06 <lsm6dsv16x_gy_data_rate_get+0x14e>
      default:
      case 0:
        *val = LSM6DSV16X_ODR_AT_240Hz;
 800bbf6:	683b      	ldr	r3, [r7, #0]
 800bbf8:	2207      	movs	r2, #7
 800bbfa:	701a      	strb	r2, [r3, #0]
        break;
 800bbfc:	e007      	b.n	800bc0e <lsm6dsv16x_gy_data_rate_get+0x156>
      case 1:
        *val = LSM6DSV16X_ODR_HA01_AT_250Hz;
 800bbfe:	683b      	ldr	r3, [r7, #0]
 800bc00:	2217      	movs	r2, #23
 800bc02:	701a      	strb	r2, [r3, #0]
        break;
 800bc04:	e003      	b.n	800bc0e <lsm6dsv16x_gy_data_rate_get+0x156>
      case 2:
        *val = LSM6DSV16X_ODR_HA02_AT_200Hz;
 800bc06:	683b      	ldr	r3, [r7, #0]
 800bc08:	2227      	movs	r2, #39	@ 0x27
 800bc0a:	701a      	strb	r2, [r3, #0]
        break;
 800bc0c:	bf00      	nop
      }
      break;
 800bc0e:	e05d      	b.n	800bccc <lsm6dsv16x_gy_data_rate_get+0x214>

    case LSM6DSV16X_ODR_AT_480Hz:
      switch (sel) {
 800bc10:	7cfb      	ldrb	r3, [r7, #19]
 800bc12:	2b01      	cmp	r3, #1
 800bc14:	d005      	beq.n	800bc22 <lsm6dsv16x_gy_data_rate_get+0x16a>
 800bc16:	2b02      	cmp	r3, #2
 800bc18:	d007      	beq.n	800bc2a <lsm6dsv16x_gy_data_rate_get+0x172>
      default:
      case 0:
        *val = LSM6DSV16X_ODR_AT_480Hz;
 800bc1a:	683b      	ldr	r3, [r7, #0]
 800bc1c:	2208      	movs	r2, #8
 800bc1e:	701a      	strb	r2, [r3, #0]
        break;
 800bc20:	e007      	b.n	800bc32 <lsm6dsv16x_gy_data_rate_get+0x17a>
      case 1:
        *val = LSM6DSV16X_ODR_HA01_AT_500Hz;
 800bc22:	683b      	ldr	r3, [r7, #0]
 800bc24:	2218      	movs	r2, #24
 800bc26:	701a      	strb	r2, [r3, #0]
        break;
 800bc28:	e003      	b.n	800bc32 <lsm6dsv16x_gy_data_rate_get+0x17a>
      case 2:
        *val = LSM6DSV16X_ODR_HA02_AT_400Hz;
 800bc2a:	683b      	ldr	r3, [r7, #0]
 800bc2c:	2228      	movs	r2, #40	@ 0x28
 800bc2e:	701a      	strb	r2, [r3, #0]
        break;
 800bc30:	bf00      	nop
      }
      break;
 800bc32:	e04b      	b.n	800bccc <lsm6dsv16x_gy_data_rate_get+0x214>

    case LSM6DSV16X_ODR_AT_960Hz:
      switch (sel) {
 800bc34:	7cfb      	ldrb	r3, [r7, #19]
 800bc36:	2b01      	cmp	r3, #1
 800bc38:	d005      	beq.n	800bc46 <lsm6dsv16x_gy_data_rate_get+0x18e>
 800bc3a:	2b02      	cmp	r3, #2
 800bc3c:	d007      	beq.n	800bc4e <lsm6dsv16x_gy_data_rate_get+0x196>
      default:
      case 0:
        *val = LSM6DSV16X_ODR_AT_960Hz;
 800bc3e:	683b      	ldr	r3, [r7, #0]
 800bc40:	2209      	movs	r2, #9
 800bc42:	701a      	strb	r2, [r3, #0]
        break;
 800bc44:	e007      	b.n	800bc56 <lsm6dsv16x_gy_data_rate_get+0x19e>
      case 1:
        *val = LSM6DSV16X_ODR_HA01_AT_1000Hz;
 800bc46:	683b      	ldr	r3, [r7, #0]
 800bc48:	2219      	movs	r2, #25
 800bc4a:	701a      	strb	r2, [r3, #0]
        break;
 800bc4c:	e003      	b.n	800bc56 <lsm6dsv16x_gy_data_rate_get+0x19e>
      case 2:
        *val = LSM6DSV16X_ODR_HA02_AT_800Hz;
 800bc4e:	683b      	ldr	r3, [r7, #0]
 800bc50:	2229      	movs	r2, #41	@ 0x29
 800bc52:	701a      	strb	r2, [r3, #0]
        break;
 800bc54:	bf00      	nop
      }
      break;
 800bc56:	e039      	b.n	800bccc <lsm6dsv16x_gy_data_rate_get+0x214>

    case LSM6DSV16X_ODR_AT_1920Hz:
      switch (sel) {
 800bc58:	7cfb      	ldrb	r3, [r7, #19]
 800bc5a:	2b01      	cmp	r3, #1
 800bc5c:	d005      	beq.n	800bc6a <lsm6dsv16x_gy_data_rate_get+0x1b2>
 800bc5e:	2b02      	cmp	r3, #2
 800bc60:	d007      	beq.n	800bc72 <lsm6dsv16x_gy_data_rate_get+0x1ba>
      default:
      case 0:
        *val = LSM6DSV16X_ODR_AT_1920Hz;
 800bc62:	683b      	ldr	r3, [r7, #0]
 800bc64:	220a      	movs	r2, #10
 800bc66:	701a      	strb	r2, [r3, #0]
        break;
 800bc68:	e007      	b.n	800bc7a <lsm6dsv16x_gy_data_rate_get+0x1c2>
      case 1:
        *val = LSM6DSV16X_ODR_HA01_AT_2000Hz;
 800bc6a:	683b      	ldr	r3, [r7, #0]
 800bc6c:	221a      	movs	r2, #26
 800bc6e:	701a      	strb	r2, [r3, #0]
        break;
 800bc70:	e003      	b.n	800bc7a <lsm6dsv16x_gy_data_rate_get+0x1c2>
      case 2:
        *val = LSM6DSV16X_ODR_HA02_AT_1600Hz;
 800bc72:	683b      	ldr	r3, [r7, #0]
 800bc74:	222a      	movs	r2, #42	@ 0x2a
 800bc76:	701a      	strb	r2, [r3, #0]
        break;
 800bc78:	bf00      	nop
      }
      break;
 800bc7a:	e027      	b.n	800bccc <lsm6dsv16x_gy_data_rate_get+0x214>

    case LSM6DSV16X_ODR_AT_3840Hz:
      switch (sel) {
 800bc7c:	7cfb      	ldrb	r3, [r7, #19]
 800bc7e:	2b01      	cmp	r3, #1
 800bc80:	d005      	beq.n	800bc8e <lsm6dsv16x_gy_data_rate_get+0x1d6>
 800bc82:	2b02      	cmp	r3, #2
 800bc84:	d007      	beq.n	800bc96 <lsm6dsv16x_gy_data_rate_get+0x1de>
      default:
      case 0:
        *val = LSM6DSV16X_ODR_AT_3840Hz;
 800bc86:	683b      	ldr	r3, [r7, #0]
 800bc88:	220b      	movs	r2, #11
 800bc8a:	701a      	strb	r2, [r3, #0]
        break;
 800bc8c:	e007      	b.n	800bc9e <lsm6dsv16x_gy_data_rate_get+0x1e6>
      case 1:
        *val = LSM6DSV16X_ODR_HA01_AT_4000Hz;
 800bc8e:	683b      	ldr	r3, [r7, #0]
 800bc90:	221b      	movs	r2, #27
 800bc92:	701a      	strb	r2, [r3, #0]
        break;
 800bc94:	e003      	b.n	800bc9e <lsm6dsv16x_gy_data_rate_get+0x1e6>
      case 2:
        *val = LSM6DSV16X_ODR_HA02_AT_3200Hz;
 800bc96:	683b      	ldr	r3, [r7, #0]
 800bc98:	222b      	movs	r2, #43	@ 0x2b
 800bc9a:	701a      	strb	r2, [r3, #0]
        break;
 800bc9c:	bf00      	nop
      }
      break;
 800bc9e:	e015      	b.n	800bccc <lsm6dsv16x_gy_data_rate_get+0x214>

    case LSM6DSV16X_ODR_AT_7680Hz:
      switch (sel) {
 800bca0:	7cfb      	ldrb	r3, [r7, #19]
 800bca2:	2b01      	cmp	r3, #1
 800bca4:	d005      	beq.n	800bcb2 <lsm6dsv16x_gy_data_rate_get+0x1fa>
 800bca6:	2b02      	cmp	r3, #2
 800bca8:	d007      	beq.n	800bcba <lsm6dsv16x_gy_data_rate_get+0x202>
      default:
      case 0:
        *val = LSM6DSV16X_ODR_AT_7680Hz;
 800bcaa:	683b      	ldr	r3, [r7, #0]
 800bcac:	220c      	movs	r2, #12
 800bcae:	701a      	strb	r2, [r3, #0]
        break;
 800bcb0:	e007      	b.n	800bcc2 <lsm6dsv16x_gy_data_rate_get+0x20a>
      case 1:
        *val = LSM6DSV16X_ODR_HA01_AT_8000Hz;
 800bcb2:	683b      	ldr	r3, [r7, #0]
 800bcb4:	221c      	movs	r2, #28
 800bcb6:	701a      	strb	r2, [r3, #0]
        break;
 800bcb8:	e003      	b.n	800bcc2 <lsm6dsv16x_gy_data_rate_get+0x20a>
      case 2:
        *val = LSM6DSV16X_ODR_HA02_AT_6400Hz;
 800bcba:	683b      	ldr	r3, [r7, #0]
 800bcbc:	222c      	movs	r2, #44	@ 0x2c
 800bcbe:	701a      	strb	r2, [r3, #0]
        break;
 800bcc0:	bf00      	nop
      }
      break;
 800bcc2:	e003      	b.n	800bccc <lsm6dsv16x_gy_data_rate_get+0x214>

    default:
      *val = LSM6DSV16X_ODR_OFF;
 800bcc4:	683b      	ldr	r3, [r7, #0]
 800bcc6:	2200      	movs	r2, #0
 800bcc8:	701a      	strb	r2, [r3, #0]
      break;
 800bcca:	bf00      	nop
  }

  return ret;
 800bccc:	697b      	ldr	r3, [r7, #20]
}
 800bcce:	4618      	mov	r0, r3
 800bcd0:	3718      	adds	r7, #24
 800bcd2:	46bd      	mov	sp, r7
 800bcd4:	bd80      	pop	{r7, pc}
 800bcd6:	bf00      	nop

0800bcd8 <lsm6dsv16x_auto_increment_set>:
  * @param  val      Register address automatically incremented during a multiple byte access with a serial interface (enable by default).
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lsm6dsv16x_auto_increment_set(stmdev_ctx_t *ctx, uint8_t val)
{
 800bcd8:	b580      	push	{r7, lr}
 800bcda:	b084      	sub	sp, #16
 800bcdc:	af00      	add	r7, sp, #0
 800bcde:	6078      	str	r0, [r7, #4]
 800bce0:	460b      	mov	r3, r1
 800bce2:	70fb      	strb	r3, [r7, #3]
  lsm6dsv16x_ctrl3_t ctrl3;
  int32_t ret;

  ret = lsm6dsv16x_read_reg(ctx, LSM6DSV16X_CTRL3, (uint8_t *)&ctrl3, 1);
 800bce4:	f107 0208 	add.w	r2, r7, #8
 800bce8:	2301      	movs	r3, #1
 800bcea:	2112      	movs	r1, #18
 800bcec:	6878      	ldr	r0, [r7, #4]
 800bcee:	f7ff fcf1 	bl	800b6d4 <lsm6dsv16x_read_reg>
 800bcf2:	60f8      	str	r0, [r7, #12]
  if (ret == 0)
 800bcf4:	68fb      	ldr	r3, [r7, #12]
 800bcf6:	2b00      	cmp	r3, #0
 800bcf8:	d10f      	bne.n	800bd1a <lsm6dsv16x_auto_increment_set+0x42>
  {
    ctrl3.if_inc = val;
 800bcfa:	78fb      	ldrb	r3, [r7, #3]
 800bcfc:	f003 0301 	and.w	r3, r3, #1
 800bd00:	b2da      	uxtb	r2, r3
 800bd02:	7a3b      	ldrb	r3, [r7, #8]
 800bd04:	f362 0382 	bfi	r3, r2, #2, #1
 800bd08:	723b      	strb	r3, [r7, #8]
    ret = lsm6dsv16x_write_reg(ctx, LSM6DSV16X_CTRL3, (uint8_t *)&ctrl3, 1);
 800bd0a:	f107 0208 	add.w	r2, r7, #8
 800bd0e:	2301      	movs	r3, #1
 800bd10:	2112      	movs	r1, #18
 800bd12:	6878      	ldr	r0, [r7, #4]
 800bd14:	f7ff fcf6 	bl	800b704 <lsm6dsv16x_write_reg>
 800bd18:	60f8      	str	r0, [r7, #12]
  }

  return ret;
 800bd1a:	68fb      	ldr	r3, [r7, #12]
}
 800bd1c:	4618      	mov	r0, r3
 800bd1e:	3710      	adds	r7, #16
 800bd20:	46bd      	mov	sp, r7
 800bd22:	bd80      	pop	{r7, pc}

0800bd24 <lsm6dsv16x_block_data_update_set>:
  * @param  val      Block Data Update (BDU): output registers are not updated until LSB and MSB have been read).
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lsm6dsv16x_block_data_update_set(stmdev_ctx_t *ctx, uint8_t val)
{
 800bd24:	b580      	push	{r7, lr}
 800bd26:	b084      	sub	sp, #16
 800bd28:	af00      	add	r7, sp, #0
 800bd2a:	6078      	str	r0, [r7, #4]
 800bd2c:	460b      	mov	r3, r1
 800bd2e:	70fb      	strb	r3, [r7, #3]
  lsm6dsv16x_ctrl3_t ctrl3;
  int32_t ret;

  ret = lsm6dsv16x_read_reg(ctx, LSM6DSV16X_CTRL3, (uint8_t *)&ctrl3, 1);
 800bd30:	f107 0208 	add.w	r2, r7, #8
 800bd34:	2301      	movs	r3, #1
 800bd36:	2112      	movs	r1, #18
 800bd38:	6878      	ldr	r0, [r7, #4]
 800bd3a:	f7ff fccb 	bl	800b6d4 <lsm6dsv16x_read_reg>
 800bd3e:	60f8      	str	r0, [r7, #12]

  if (ret == 0)
 800bd40:	68fb      	ldr	r3, [r7, #12]
 800bd42:	2b00      	cmp	r3, #0
 800bd44:	d10f      	bne.n	800bd66 <lsm6dsv16x_block_data_update_set+0x42>
  {
    ctrl3.bdu = val;
 800bd46:	78fb      	ldrb	r3, [r7, #3]
 800bd48:	f003 0301 	and.w	r3, r3, #1
 800bd4c:	b2da      	uxtb	r2, r3
 800bd4e:	7a3b      	ldrb	r3, [r7, #8]
 800bd50:	f362 1386 	bfi	r3, r2, #6, #1
 800bd54:	723b      	strb	r3, [r7, #8]
    ret = lsm6dsv16x_write_reg(ctx, LSM6DSV16X_CTRL3, (uint8_t *)&ctrl3, 1);
 800bd56:	f107 0208 	add.w	r2, r7, #8
 800bd5a:	2301      	movs	r3, #1
 800bd5c:	2112      	movs	r1, #18
 800bd5e:	6878      	ldr	r0, [r7, #4]
 800bd60:	f7ff fcd0 	bl	800b704 <lsm6dsv16x_write_reg>
 800bd64:	60f8      	str	r0, [r7, #12]
  }

  return ret;
 800bd66:	68fb      	ldr	r3, [r7, #12]
}
 800bd68:	4618      	mov	r0, r3
 800bd6a:	3710      	adds	r7, #16
 800bd6c:	46bd      	mov	sp, r7
 800bd6e:	bd80      	pop	{r7, pc}

0800bd70 <lsm6dsv16x_gy_full_scale_set>:
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lsm6dsv16x_gy_full_scale_set(stmdev_ctx_t *ctx,
                                     lsm6dsv16x_gy_full_scale_t val)
{
 800bd70:	b580      	push	{r7, lr}
 800bd72:	b084      	sub	sp, #16
 800bd74:	af00      	add	r7, sp, #0
 800bd76:	6078      	str	r0, [r7, #4]
 800bd78:	460b      	mov	r3, r1
 800bd7a:	70fb      	strb	r3, [r7, #3]
  lsm6dsv16x_ctrl6_t ctrl6;
  int32_t ret;

  ret = lsm6dsv16x_read_reg(ctx, LSM6DSV16X_CTRL6, (uint8_t *)&ctrl6, 1);
 800bd7c:	f107 0208 	add.w	r2, r7, #8
 800bd80:	2301      	movs	r3, #1
 800bd82:	2115      	movs	r1, #21
 800bd84:	6878      	ldr	r0, [r7, #4]
 800bd86:	f7ff fca5 	bl	800b6d4 <lsm6dsv16x_read_reg>
 800bd8a:	60f8      	str	r0, [r7, #12]

  if (ret == 0)
 800bd8c:	68fb      	ldr	r3, [r7, #12]
 800bd8e:	2b00      	cmp	r3, #0
 800bd90:	d10f      	bne.n	800bdb2 <lsm6dsv16x_gy_full_scale_set+0x42>
  {
    ctrl6.fs_g = (uint8_t)val & 0xfu;
 800bd92:	78fb      	ldrb	r3, [r7, #3]
 800bd94:	f003 030f 	and.w	r3, r3, #15
 800bd98:	b2da      	uxtb	r2, r3
 800bd9a:	7a3b      	ldrb	r3, [r7, #8]
 800bd9c:	f362 0303 	bfi	r3, r2, #0, #4
 800bda0:	723b      	strb	r3, [r7, #8]
    ret = lsm6dsv16x_write_reg(ctx, LSM6DSV16X_CTRL6, (uint8_t *)&ctrl6, 1);
 800bda2:	f107 0208 	add.w	r2, r7, #8
 800bda6:	2301      	movs	r3, #1
 800bda8:	2115      	movs	r1, #21
 800bdaa:	6878      	ldr	r0, [r7, #4]
 800bdac:	f7ff fcaa 	bl	800b704 <lsm6dsv16x_write_reg>
 800bdb0:	60f8      	str	r0, [r7, #12]
  }

  return ret;
 800bdb2:	68fb      	ldr	r3, [r7, #12]
}
 800bdb4:	4618      	mov	r0, r3
 800bdb6:	3710      	adds	r7, #16
 800bdb8:	46bd      	mov	sp, r7
 800bdba:	bd80      	pop	{r7, pc}

0800bdbc <lsm6dsv16x_gy_full_scale_get>:
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lsm6dsv16x_gy_full_scale_get(stmdev_ctx_t *ctx,
                                     lsm6dsv16x_gy_full_scale_t *val)
{
 800bdbc:	b580      	push	{r7, lr}
 800bdbe:	b084      	sub	sp, #16
 800bdc0:	af00      	add	r7, sp, #0
 800bdc2:	6078      	str	r0, [r7, #4]
 800bdc4:	6039      	str	r1, [r7, #0]
  lsm6dsv16x_ctrl6_t ctrl6;
  int32_t ret;

  ret = lsm6dsv16x_read_reg(ctx, LSM6DSV16X_CTRL6, (uint8_t *)&ctrl6, 1);
 800bdc6:	f107 0208 	add.w	r2, r7, #8
 800bdca:	2301      	movs	r3, #1
 800bdcc:	2115      	movs	r1, #21
 800bdce:	6878      	ldr	r0, [r7, #4]
 800bdd0:	f7ff fc80 	bl	800b6d4 <lsm6dsv16x_read_reg>
 800bdd4:	60f8      	str	r0, [r7, #12]
  if (ret != 0) { return ret; }
 800bdd6:	68fb      	ldr	r3, [r7, #12]
 800bdd8:	2b00      	cmp	r3, #0
 800bdda:	d001      	beq.n	800bde0 <lsm6dsv16x_gy_full_scale_get+0x24>
 800bddc:	68fb      	ldr	r3, [r7, #12]
 800bdde:	e040      	b.n	800be62 <lsm6dsv16x_gy_full_scale_get+0xa6>

  switch (ctrl6.fs_g)
 800bde0:	7a3b      	ldrb	r3, [r7, #8]
 800bde2:	f3c3 0303 	ubfx	r3, r3, #0, #4
 800bde6:	b2db      	uxtb	r3, r3
 800bde8:	2b0c      	cmp	r3, #12
 800bdea:	d835      	bhi.n	800be58 <lsm6dsv16x_gy_full_scale_get+0x9c>
 800bdec:	a201      	add	r2, pc, #4	@ (adr r2, 800bdf4 <lsm6dsv16x_gy_full_scale_get+0x38>)
 800bdee:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800bdf2:	bf00      	nop
 800bdf4:	0800be29 	.word	0x0800be29
 800bdf8:	0800be31 	.word	0x0800be31
 800bdfc:	0800be39 	.word	0x0800be39
 800be00:	0800be41 	.word	0x0800be41
 800be04:	0800be49 	.word	0x0800be49
 800be08:	0800be59 	.word	0x0800be59
 800be0c:	0800be59 	.word	0x0800be59
 800be10:	0800be59 	.word	0x0800be59
 800be14:	0800be59 	.word	0x0800be59
 800be18:	0800be59 	.word	0x0800be59
 800be1c:	0800be59 	.word	0x0800be59
 800be20:	0800be59 	.word	0x0800be59
 800be24:	0800be51 	.word	0x0800be51
  {
    case LSM6DSV16X_125dps:
      *val = LSM6DSV16X_125dps;
 800be28:	683b      	ldr	r3, [r7, #0]
 800be2a:	2200      	movs	r2, #0
 800be2c:	701a      	strb	r2, [r3, #0]
      break;
 800be2e:	e017      	b.n	800be60 <lsm6dsv16x_gy_full_scale_get+0xa4>

    case LSM6DSV16X_250dps:
      *val = LSM6DSV16X_250dps;
 800be30:	683b      	ldr	r3, [r7, #0]
 800be32:	2201      	movs	r2, #1
 800be34:	701a      	strb	r2, [r3, #0]
      break;
 800be36:	e013      	b.n	800be60 <lsm6dsv16x_gy_full_scale_get+0xa4>

    case LSM6DSV16X_500dps:
      *val = LSM6DSV16X_500dps;
 800be38:	683b      	ldr	r3, [r7, #0]
 800be3a:	2202      	movs	r2, #2
 800be3c:	701a      	strb	r2, [r3, #0]
      break;
 800be3e:	e00f      	b.n	800be60 <lsm6dsv16x_gy_full_scale_get+0xa4>

    case LSM6DSV16X_1000dps:
      *val = LSM6DSV16X_1000dps;
 800be40:	683b      	ldr	r3, [r7, #0]
 800be42:	2203      	movs	r2, #3
 800be44:	701a      	strb	r2, [r3, #0]
      break;
 800be46:	e00b      	b.n	800be60 <lsm6dsv16x_gy_full_scale_get+0xa4>

    case LSM6DSV16X_2000dps:
      *val = LSM6DSV16X_2000dps;
 800be48:	683b      	ldr	r3, [r7, #0]
 800be4a:	2204      	movs	r2, #4
 800be4c:	701a      	strb	r2, [r3, #0]
      break;
 800be4e:	e007      	b.n	800be60 <lsm6dsv16x_gy_full_scale_get+0xa4>

    case LSM6DSV16X_4000dps:
      *val = LSM6DSV16X_4000dps;
 800be50:	683b      	ldr	r3, [r7, #0]
 800be52:	220c      	movs	r2, #12
 800be54:	701a      	strb	r2, [r3, #0]
      break;
 800be56:	e003      	b.n	800be60 <lsm6dsv16x_gy_full_scale_get+0xa4>

    default:
      *val = LSM6DSV16X_125dps;
 800be58:	683b      	ldr	r3, [r7, #0]
 800be5a:	2200      	movs	r2, #0
 800be5c:	701a      	strb	r2, [r3, #0]
      break;
 800be5e:	bf00      	nop
  }

  return ret;
 800be60:	68fb      	ldr	r3, [r7, #12]
}
 800be62:	4618      	mov	r0, r3
 800be64:	3710      	adds	r7, #16
 800be66:	46bd      	mov	sp, r7
 800be68:	bd80      	pop	{r7, pc}
 800be6a:	bf00      	nop

0800be6c <lsm6dsv16x_xl_full_scale_set>:
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lsm6dsv16x_xl_full_scale_set(stmdev_ctx_t *ctx,
                                     lsm6dsv16x_xl_full_scale_t val)
{
 800be6c:	b580      	push	{r7, lr}
 800be6e:	b084      	sub	sp, #16
 800be70:	af00      	add	r7, sp, #0
 800be72:	6078      	str	r0, [r7, #4]
 800be74:	460b      	mov	r3, r1
 800be76:	70fb      	strb	r3, [r7, #3]
  lsm6dsv16x_ctrl8_t ctrl8;
  int32_t ret;

  ret = lsm6dsv16x_read_reg(ctx, LSM6DSV16X_CTRL8, (uint8_t *)&ctrl8, 1);
 800be78:	f107 0208 	add.w	r2, r7, #8
 800be7c:	2301      	movs	r3, #1
 800be7e:	2117      	movs	r1, #23
 800be80:	6878      	ldr	r0, [r7, #4]
 800be82:	f7ff fc27 	bl	800b6d4 <lsm6dsv16x_read_reg>
 800be86:	60f8      	str	r0, [r7, #12]

  if (ret == 0)
 800be88:	68fb      	ldr	r3, [r7, #12]
 800be8a:	2b00      	cmp	r3, #0
 800be8c:	d10f      	bne.n	800beae <lsm6dsv16x_xl_full_scale_set+0x42>
  {
    ctrl8.fs_xl = (uint8_t)val & 0x3U;
 800be8e:	78fb      	ldrb	r3, [r7, #3]
 800be90:	f003 0303 	and.w	r3, r3, #3
 800be94:	b2da      	uxtb	r2, r3
 800be96:	7a3b      	ldrb	r3, [r7, #8]
 800be98:	f362 0301 	bfi	r3, r2, #0, #2
 800be9c:	723b      	strb	r3, [r7, #8]
    ret = lsm6dsv16x_write_reg(ctx, LSM6DSV16X_CTRL8, (uint8_t *)&ctrl8, 1);
 800be9e:	f107 0208 	add.w	r2, r7, #8
 800bea2:	2301      	movs	r3, #1
 800bea4:	2117      	movs	r1, #23
 800bea6:	6878      	ldr	r0, [r7, #4]
 800bea8:	f7ff fc2c 	bl	800b704 <lsm6dsv16x_write_reg>
 800beac:	60f8      	str	r0, [r7, #12]
  }

  return ret;
 800beae:	68fb      	ldr	r3, [r7, #12]
}
 800beb0:	4618      	mov	r0, r3
 800beb2:	3710      	adds	r7, #16
 800beb4:	46bd      	mov	sp, r7
 800beb6:	bd80      	pop	{r7, pc}

0800beb8 <lsm6dsv16x_xl_full_scale_get>:
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lsm6dsv16x_xl_full_scale_get(stmdev_ctx_t *ctx,
                                     lsm6dsv16x_xl_full_scale_t *val)
{
 800beb8:	b580      	push	{r7, lr}
 800beba:	b084      	sub	sp, #16
 800bebc:	af00      	add	r7, sp, #0
 800bebe:	6078      	str	r0, [r7, #4]
 800bec0:	6039      	str	r1, [r7, #0]
  lsm6dsv16x_ctrl8_t ctrl8;
  int32_t ret;

  ret = lsm6dsv16x_read_reg(ctx, LSM6DSV16X_CTRL8, (uint8_t *)&ctrl8, 1);
 800bec2:	f107 0208 	add.w	r2, r7, #8
 800bec6:	2301      	movs	r3, #1
 800bec8:	2117      	movs	r1, #23
 800beca:	6878      	ldr	r0, [r7, #4]
 800becc:	f7ff fc02 	bl	800b6d4 <lsm6dsv16x_read_reg>
 800bed0:	60f8      	str	r0, [r7, #12]
  if (ret != 0) { return ret; }
 800bed2:	68fb      	ldr	r3, [r7, #12]
 800bed4:	2b00      	cmp	r3, #0
 800bed6:	d001      	beq.n	800bedc <lsm6dsv16x_xl_full_scale_get+0x24>
 800bed8:	68fb      	ldr	r3, [r7, #12]
 800beda:	e026      	b.n	800bf2a <lsm6dsv16x_xl_full_scale_get+0x72>

  switch (ctrl8.fs_xl)
 800bedc:	7a3b      	ldrb	r3, [r7, #8]
 800bede:	f3c3 0301 	ubfx	r3, r3, #0, #2
 800bee2:	b2db      	uxtb	r3, r3
 800bee4:	2b03      	cmp	r3, #3
 800bee6:	d81b      	bhi.n	800bf20 <lsm6dsv16x_xl_full_scale_get+0x68>
 800bee8:	a201      	add	r2, pc, #4	@ (adr r2, 800bef0 <lsm6dsv16x_xl_full_scale_get+0x38>)
 800beea:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800beee:	bf00      	nop
 800bef0:	0800bf01 	.word	0x0800bf01
 800bef4:	0800bf09 	.word	0x0800bf09
 800bef8:	0800bf11 	.word	0x0800bf11
 800befc:	0800bf19 	.word	0x0800bf19
  {
    case LSM6DSV16X_2g:
      *val = LSM6DSV16X_2g;
 800bf00:	683b      	ldr	r3, [r7, #0]
 800bf02:	2200      	movs	r2, #0
 800bf04:	701a      	strb	r2, [r3, #0]
      break;
 800bf06:	e00f      	b.n	800bf28 <lsm6dsv16x_xl_full_scale_get+0x70>

    case LSM6DSV16X_4g:
      *val = LSM6DSV16X_4g;
 800bf08:	683b      	ldr	r3, [r7, #0]
 800bf0a:	2201      	movs	r2, #1
 800bf0c:	701a      	strb	r2, [r3, #0]
      break;
 800bf0e:	e00b      	b.n	800bf28 <lsm6dsv16x_xl_full_scale_get+0x70>

    case LSM6DSV16X_8g:
      *val = LSM6DSV16X_8g;
 800bf10:	683b      	ldr	r3, [r7, #0]
 800bf12:	2202      	movs	r2, #2
 800bf14:	701a      	strb	r2, [r3, #0]
      break;
 800bf16:	e007      	b.n	800bf28 <lsm6dsv16x_xl_full_scale_get+0x70>

    case LSM6DSV16X_16g:
      *val = LSM6DSV16X_16g;
 800bf18:	683b      	ldr	r3, [r7, #0]
 800bf1a:	2203      	movs	r2, #3
 800bf1c:	701a      	strb	r2, [r3, #0]
      break;
 800bf1e:	e003      	b.n	800bf28 <lsm6dsv16x_xl_full_scale_get+0x70>

    default:
      *val = LSM6DSV16X_2g;
 800bf20:	683b      	ldr	r3, [r7, #0]
 800bf22:	2200      	movs	r2, #0
 800bf24:	701a      	strb	r2, [r3, #0]
      break;
 800bf26:	bf00      	nop
  }

  return ret;
 800bf28:	68fb      	ldr	r3, [r7, #12]
}
 800bf2a:	4618      	mov	r0, r3
 800bf2c:	3710      	adds	r7, #16
 800bf2e:	46bd      	mov	sp, r7
 800bf30:	bd80      	pop	{r7, pc}
 800bf32:	bf00      	nop

0800bf34 <lsm6dsv16x_angular_rate_raw_get>:
  * @param  val      Angular rate sensor.
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lsm6dsv16x_angular_rate_raw_get(stmdev_ctx_t *ctx, int16_t *val)
{
 800bf34:	b580      	push	{r7, lr}
 800bf36:	b086      	sub	sp, #24
 800bf38:	af00      	add	r7, sp, #0
 800bf3a:	6078      	str	r0, [r7, #4]
 800bf3c:	6039      	str	r1, [r7, #0]
  uint8_t buff[6];
  int32_t ret;

  ret = lsm6dsv16x_read_reg(ctx, LSM6DSV16X_OUTX_L_G, &buff[0], 6);
 800bf3e:	f107 020c 	add.w	r2, r7, #12
 800bf42:	2306      	movs	r3, #6
 800bf44:	2122      	movs	r1, #34	@ 0x22
 800bf46:	6878      	ldr	r0, [r7, #4]
 800bf48:	f7ff fbc4 	bl	800b6d4 <lsm6dsv16x_read_reg>
 800bf4c:	6178      	str	r0, [r7, #20]
  if (ret != 0) { return ret; }
 800bf4e:	697b      	ldr	r3, [r7, #20]
 800bf50:	2b00      	cmp	r3, #0
 800bf52:	d001      	beq.n	800bf58 <lsm6dsv16x_angular_rate_raw_get+0x24>
 800bf54:	697b      	ldr	r3, [r7, #20]
 800bf56:	e036      	b.n	800bfc6 <lsm6dsv16x_angular_rate_raw_get+0x92>

  val[0] = (int16_t)buff[1];
 800bf58:	7b7b      	ldrb	r3, [r7, #13]
 800bf5a:	b21a      	sxth	r2, r3
 800bf5c:	683b      	ldr	r3, [r7, #0]
 800bf5e:	801a      	strh	r2, [r3, #0]
  val[0] = (val[0] * 256) + (int16_t)buff[0];
 800bf60:	683b      	ldr	r3, [r7, #0]
 800bf62:	f9b3 3000 	ldrsh.w	r3, [r3]
 800bf66:	b29b      	uxth	r3, r3
 800bf68:	021b      	lsls	r3, r3, #8
 800bf6a:	b29b      	uxth	r3, r3
 800bf6c:	7b3a      	ldrb	r2, [r7, #12]
 800bf6e:	4413      	add	r3, r2
 800bf70:	b29b      	uxth	r3, r3
 800bf72:	b21a      	sxth	r2, r3
 800bf74:	683b      	ldr	r3, [r7, #0]
 800bf76:	801a      	strh	r2, [r3, #0]
  val[1] = (int16_t)buff[3];
 800bf78:	7bfa      	ldrb	r2, [r7, #15]
 800bf7a:	683b      	ldr	r3, [r7, #0]
 800bf7c:	3302      	adds	r3, #2
 800bf7e:	b212      	sxth	r2, r2
 800bf80:	801a      	strh	r2, [r3, #0]
  val[1] = (val[1] * 256) + (int16_t)buff[2];
 800bf82:	683b      	ldr	r3, [r7, #0]
 800bf84:	3302      	adds	r3, #2
 800bf86:	f9b3 3000 	ldrsh.w	r3, [r3]
 800bf8a:	b29b      	uxth	r3, r3
 800bf8c:	021b      	lsls	r3, r3, #8
 800bf8e:	b29b      	uxth	r3, r3
 800bf90:	7bba      	ldrb	r2, [r7, #14]
 800bf92:	4413      	add	r3, r2
 800bf94:	b29a      	uxth	r2, r3
 800bf96:	683b      	ldr	r3, [r7, #0]
 800bf98:	3302      	adds	r3, #2
 800bf9a:	b212      	sxth	r2, r2
 800bf9c:	801a      	strh	r2, [r3, #0]
  val[2] = (int16_t)buff[5];
 800bf9e:	7c7a      	ldrb	r2, [r7, #17]
 800bfa0:	683b      	ldr	r3, [r7, #0]
 800bfa2:	3304      	adds	r3, #4
 800bfa4:	b212      	sxth	r2, r2
 800bfa6:	801a      	strh	r2, [r3, #0]
  val[2] = (val[2] * 256) + (int16_t)buff[4];
 800bfa8:	683b      	ldr	r3, [r7, #0]
 800bfaa:	3304      	adds	r3, #4
 800bfac:	f9b3 3000 	ldrsh.w	r3, [r3]
 800bfb0:	b29b      	uxth	r3, r3
 800bfb2:	021b      	lsls	r3, r3, #8
 800bfb4:	b29b      	uxth	r3, r3
 800bfb6:	7c3a      	ldrb	r2, [r7, #16]
 800bfb8:	4413      	add	r3, r2
 800bfba:	b29a      	uxth	r2, r3
 800bfbc:	683b      	ldr	r3, [r7, #0]
 800bfbe:	3304      	adds	r3, #4
 800bfc0:	b212      	sxth	r2, r2
 800bfc2:	801a      	strh	r2, [r3, #0]

  return ret;
 800bfc4:	697b      	ldr	r3, [r7, #20]
}
 800bfc6:	4618      	mov	r0, r3
 800bfc8:	3718      	adds	r7, #24
 800bfca:	46bd      	mov	sp, r7
 800bfcc:	bd80      	pop	{r7, pc}

0800bfce <lsm6dsv16x_acceleration_raw_get>:
  * @param  val      Linear acceleration sensor.
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lsm6dsv16x_acceleration_raw_get(stmdev_ctx_t *ctx, int16_t *val)
{
 800bfce:	b580      	push	{r7, lr}
 800bfd0:	b086      	sub	sp, #24
 800bfd2:	af00      	add	r7, sp, #0
 800bfd4:	6078      	str	r0, [r7, #4]
 800bfd6:	6039      	str	r1, [r7, #0]
  uint8_t buff[6];
  int32_t ret;

  ret = lsm6dsv16x_read_reg(ctx, LSM6DSV16X_OUTX_L_A, &buff[0], 6);
 800bfd8:	f107 020c 	add.w	r2, r7, #12
 800bfdc:	2306      	movs	r3, #6
 800bfde:	2128      	movs	r1, #40	@ 0x28
 800bfe0:	6878      	ldr	r0, [r7, #4]
 800bfe2:	f7ff fb77 	bl	800b6d4 <lsm6dsv16x_read_reg>
 800bfe6:	6178      	str	r0, [r7, #20]
  if (ret != 0) { return ret; }
 800bfe8:	697b      	ldr	r3, [r7, #20]
 800bfea:	2b00      	cmp	r3, #0
 800bfec:	d001      	beq.n	800bff2 <lsm6dsv16x_acceleration_raw_get+0x24>
 800bfee:	697b      	ldr	r3, [r7, #20]
 800bff0:	e036      	b.n	800c060 <lsm6dsv16x_acceleration_raw_get+0x92>

  val[0] = (int16_t)buff[1];
 800bff2:	7b7b      	ldrb	r3, [r7, #13]
 800bff4:	b21a      	sxth	r2, r3
 800bff6:	683b      	ldr	r3, [r7, #0]
 800bff8:	801a      	strh	r2, [r3, #0]
  val[0] = (val[0] * 256) + (int16_t)buff[0];
 800bffa:	683b      	ldr	r3, [r7, #0]
 800bffc:	f9b3 3000 	ldrsh.w	r3, [r3]
 800c000:	b29b      	uxth	r3, r3
 800c002:	021b      	lsls	r3, r3, #8
 800c004:	b29b      	uxth	r3, r3
 800c006:	7b3a      	ldrb	r2, [r7, #12]
 800c008:	4413      	add	r3, r2
 800c00a:	b29b      	uxth	r3, r3
 800c00c:	b21a      	sxth	r2, r3
 800c00e:	683b      	ldr	r3, [r7, #0]
 800c010:	801a      	strh	r2, [r3, #0]
  val[1] = (int16_t)buff[3];
 800c012:	7bfa      	ldrb	r2, [r7, #15]
 800c014:	683b      	ldr	r3, [r7, #0]
 800c016:	3302      	adds	r3, #2
 800c018:	b212      	sxth	r2, r2
 800c01a:	801a      	strh	r2, [r3, #0]
  val[1] = (val[1] * 256) + (int16_t)buff[2];
 800c01c:	683b      	ldr	r3, [r7, #0]
 800c01e:	3302      	adds	r3, #2
 800c020:	f9b3 3000 	ldrsh.w	r3, [r3]
 800c024:	b29b      	uxth	r3, r3
 800c026:	021b      	lsls	r3, r3, #8
 800c028:	b29b      	uxth	r3, r3
 800c02a:	7bba      	ldrb	r2, [r7, #14]
 800c02c:	4413      	add	r3, r2
 800c02e:	b29a      	uxth	r2, r3
 800c030:	683b      	ldr	r3, [r7, #0]
 800c032:	3302      	adds	r3, #2
 800c034:	b212      	sxth	r2, r2
 800c036:	801a      	strh	r2, [r3, #0]
  val[2] = (int16_t)buff[5];
 800c038:	7c7a      	ldrb	r2, [r7, #17]
 800c03a:	683b      	ldr	r3, [r7, #0]
 800c03c:	3304      	adds	r3, #4
 800c03e:	b212      	sxth	r2, r2
 800c040:	801a      	strh	r2, [r3, #0]
  val[2] = (val[2] * 256) + (int16_t)buff[4];
 800c042:	683b      	ldr	r3, [r7, #0]
 800c044:	3304      	adds	r3, #4
 800c046:	f9b3 3000 	ldrsh.w	r3, [r3]
 800c04a:	b29b      	uxth	r3, r3
 800c04c:	021b      	lsls	r3, r3, #8
 800c04e:	b29b      	uxth	r3, r3
 800c050:	7c3a      	ldrb	r2, [r7, #16]
 800c052:	4413      	add	r3, r2
 800c054:	b29a      	uxth	r2, r3
 800c056:	683b      	ldr	r3, [r7, #0]
 800c058:	3304      	adds	r3, #4
 800c05a:	b212      	sxth	r2, r2
 800c05c:	801a      	strh	r2, [r3, #0]

  return ret;
 800c05e:	697b      	ldr	r3, [r7, #20]
}
 800c060:	4618      	mov	r0, r3
 800c062:	3718      	adds	r7, #24
 800c064:	46bd      	mov	sp, r7
 800c066:	bd80      	pop	{r7, pc}

0800c068 <lsm6dsv16x_fifo_mode_set>:
  * @param  val      BYPASS_MODE, FIFO_MODE, STREAM_WTM_TO_FULL_MODE, STREAM_TO_FIFO_MODE, BYPASS_TO_STREAM_MODE, STREAM_MODE, BYPASS_TO_FIFO_MODE,
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lsm6dsv16x_fifo_mode_set(stmdev_ctx_t *ctx, lsm6dsv16x_fifo_mode_t val)
{
 800c068:	b580      	push	{r7, lr}
 800c06a:	b084      	sub	sp, #16
 800c06c:	af00      	add	r7, sp, #0
 800c06e:	6078      	str	r0, [r7, #4]
 800c070:	460b      	mov	r3, r1
 800c072:	70fb      	strb	r3, [r7, #3]
  lsm6dsv16x_fifo_ctrl4_t fifo_ctrl4;
  int32_t ret;

  ret = lsm6dsv16x_read_reg(ctx, LSM6DSV16X_FIFO_CTRL4, (uint8_t *)&fifo_ctrl4, 1);
 800c074:	f107 0208 	add.w	r2, r7, #8
 800c078:	2301      	movs	r3, #1
 800c07a:	210a      	movs	r1, #10
 800c07c:	6878      	ldr	r0, [r7, #4]
 800c07e:	f7ff fb29 	bl	800b6d4 <lsm6dsv16x_read_reg>
 800c082:	60f8      	str	r0, [r7, #12]
  if (ret == 0)
 800c084:	68fb      	ldr	r3, [r7, #12]
 800c086:	2b00      	cmp	r3, #0
 800c088:	d10f      	bne.n	800c0aa <lsm6dsv16x_fifo_mode_set+0x42>
  {
    fifo_ctrl4.fifo_mode = (uint8_t)val & 0x07U;
 800c08a:	78fb      	ldrb	r3, [r7, #3]
 800c08c:	f003 0307 	and.w	r3, r3, #7
 800c090:	b2da      	uxtb	r2, r3
 800c092:	7a3b      	ldrb	r3, [r7, #8]
 800c094:	f362 0302 	bfi	r3, r2, #0, #3
 800c098:	723b      	strb	r3, [r7, #8]
    ret = lsm6dsv16x_write_reg(ctx, LSM6DSV16X_FIFO_CTRL4, (uint8_t *)&fifo_ctrl4, 1);
 800c09a:	f107 0208 	add.w	r2, r7, #8
 800c09e:	2301      	movs	r3, #1
 800c0a0:	210a      	movs	r1, #10
 800c0a2:	6878      	ldr	r0, [r7, #4]
 800c0a4:	f7ff fb2e 	bl	800b704 <lsm6dsv16x_write_reg>
 800c0a8:	60f8      	str	r0, [r7, #12]
  }

  return ret;
 800c0aa:	68fb      	ldr	r3, [r7, #12]
}
 800c0ac:	4618      	mov	r0, r3
 800c0ae:	3710      	adds	r7, #16
 800c0b0:	46bd      	mov	sp, r7
 800c0b2:	bd80      	pop	{r7, pc}

0800c0b4 <lsm6dsv16x_ah_qvar_mode_set>:
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lsm6dsv16x_ah_qvar_mode_set(stmdev_ctx_t *ctx,
                                    lsm6dsv16x_ah_qvar_mode_t val)
{
 800c0b4:	b580      	push	{r7, lr}
 800c0b6:	b084      	sub	sp, #16
 800c0b8:	af00      	add	r7, sp, #0
 800c0ba:	6078      	str	r0, [r7, #4]
 800c0bc:	7039      	strb	r1, [r7, #0]
  lsm6dsv16x_ctrl7_t ctrl7;
  int32_t ret;

  ret = lsm6dsv16x_read_reg(ctx, LSM6DSV16X_CTRL7, (uint8_t *)&ctrl7, 1);
 800c0be:	f107 0208 	add.w	r2, r7, #8
 800c0c2:	2301      	movs	r3, #1
 800c0c4:	2116      	movs	r1, #22
 800c0c6:	6878      	ldr	r0, [r7, #4]
 800c0c8:	f7ff fb04 	bl	800b6d4 <lsm6dsv16x_read_reg>
 800c0cc:	60f8      	str	r0, [r7, #12]
  if (ret == 0)
 800c0ce:	68fb      	ldr	r3, [r7, #12]
 800c0d0:	2b00      	cmp	r3, #0
 800c0d2:	d10f      	bne.n	800c0f4 <lsm6dsv16x_ah_qvar_mode_set+0x40>
  {
    ctrl7.ah_qvar_en = val.ah_qvar_en;
 800c0d4:	783b      	ldrb	r3, [r7, #0]
 800c0d6:	f3c3 0300 	ubfx	r3, r3, #0, #1
 800c0da:	b2da      	uxtb	r2, r3
 800c0dc:	7a3b      	ldrb	r3, [r7, #8]
 800c0de:	f362 13c7 	bfi	r3, r2, #7, #1
 800c0e2:	723b      	strb	r3, [r7, #8]
    ret = lsm6dsv16x_write_reg(ctx, LSM6DSV16X_CTRL7, (uint8_t *)&ctrl7, 1);
 800c0e4:	f107 0208 	add.w	r2, r7, #8
 800c0e8:	2301      	movs	r3, #1
 800c0ea:	2116      	movs	r1, #22
 800c0ec:	6878      	ldr	r0, [r7, #4]
 800c0ee:	f7ff fb09 	bl	800b704 <lsm6dsv16x_write_reg>
 800c0f2:	60f8      	str	r0, [r7, #12]
  }

  return ret;
 800c0f4:	68fb      	ldr	r3, [r7, #12]
}
 800c0f6:	4618      	mov	r0, r3
 800c0f8:	3710      	adds	r7, #16
 800c0fa:	46bd      	mov	sp, r7
 800c0fc:	bd80      	pop	{r7, pc}
	...

0800c100 <STTS22H_RegisterBusIO>:
  * @brief  Register Component Bus IO operations
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t STTS22H_RegisterBusIO(STTS22H_Object_t *pObj, STTS22H_IO_t *pIO)
{
 800c100:	b580      	push	{r7, lr}
 800c102:	b084      	sub	sp, #16
 800c104:	af00      	add	r7, sp, #0
 800c106:	6078      	str	r0, [r7, #4]
 800c108:	6039      	str	r1, [r7, #0]
  int32_t ret;

  if (pObj == NULL)
 800c10a:	687b      	ldr	r3, [r7, #4]
 800c10c:	2b00      	cmp	r3, #0
 800c10e:	d103      	bne.n	800c118 <STTS22H_RegisterBusIO+0x18>
  {
    ret = STTS22H_ERROR;
 800c110:	f04f 33ff 	mov.w	r3, #4294967295
 800c114:	60fb      	str	r3, [r7, #12]
 800c116:	e034      	b.n	800c182 <STTS22H_RegisterBusIO+0x82>
  }
  else
  {
    pObj->IO.Init      = pIO->Init;
 800c118:	683b      	ldr	r3, [r7, #0]
 800c11a:	681a      	ldr	r2, [r3, #0]
 800c11c:	687b      	ldr	r3, [r7, #4]
 800c11e:	601a      	str	r2, [r3, #0]
    pObj->IO.DeInit    = pIO->DeInit;
 800c120:	683b      	ldr	r3, [r7, #0]
 800c122:	685a      	ldr	r2, [r3, #4]
 800c124:	687b      	ldr	r3, [r7, #4]
 800c126:	605a      	str	r2, [r3, #4]
    pObj->IO.BusType   = pIO->BusType;
 800c128:	683b      	ldr	r3, [r7, #0]
 800c12a:	689a      	ldr	r2, [r3, #8]
 800c12c:	687b      	ldr	r3, [r7, #4]
 800c12e:	609a      	str	r2, [r3, #8]
    pObj->IO.Address   = pIO->Address;
 800c130:	683b      	ldr	r3, [r7, #0]
 800c132:	7b1a      	ldrb	r2, [r3, #12]
 800c134:	687b      	ldr	r3, [r7, #4]
 800c136:	731a      	strb	r2, [r3, #12]
    pObj->IO.WriteReg  = pIO->WriteReg;
 800c138:	683b      	ldr	r3, [r7, #0]
 800c13a:	691a      	ldr	r2, [r3, #16]
 800c13c:	687b      	ldr	r3, [r7, #4]
 800c13e:	611a      	str	r2, [r3, #16]
    pObj->IO.ReadReg   = pIO->ReadReg;
 800c140:	683b      	ldr	r3, [r7, #0]
 800c142:	695a      	ldr	r2, [r3, #20]
 800c144:	687b      	ldr	r3, [r7, #4]
 800c146:	615a      	str	r2, [r3, #20]
    pObj->IO.GetTick   = pIO->GetTick;
 800c148:	683b      	ldr	r3, [r7, #0]
 800c14a:	699a      	ldr	r2, [r3, #24]
 800c14c:	687b      	ldr	r3, [r7, #4]
 800c14e:	619a      	str	r2, [r3, #24]

    pObj->Ctx.read_reg  = ReadRegWrap;
 800c150:	687b      	ldr	r3, [r7, #4]
 800c152:	4a0e      	ldr	r2, [pc, #56]	@ (800c18c <STTS22H_RegisterBusIO+0x8c>)
 800c154:	625a      	str	r2, [r3, #36]	@ 0x24
    pObj->Ctx.write_reg = WriteRegWrap;
 800c156:	687b      	ldr	r3, [r7, #4]
 800c158:	4a0d      	ldr	r2, [pc, #52]	@ (800c190 <STTS22H_RegisterBusIO+0x90>)
 800c15a:	621a      	str	r2, [r3, #32]
    pObj->Ctx.mdelay    = pIO->Delay;
 800c15c:	683b      	ldr	r3, [r7, #0]
 800c15e:	69da      	ldr	r2, [r3, #28]
 800c160:	687b      	ldr	r3, [r7, #4]
 800c162:	629a      	str	r2, [r3, #40]	@ 0x28
    pObj->Ctx.handle   = pObj;
 800c164:	687b      	ldr	r3, [r7, #4]
 800c166:	687a      	ldr	r2, [r7, #4]
 800c168:	62da      	str	r2, [r3, #44]	@ 0x2c

    if (pObj->IO.Init != NULL)
 800c16a:	687b      	ldr	r3, [r7, #4]
 800c16c:	681b      	ldr	r3, [r3, #0]
 800c16e:	2b00      	cmp	r3, #0
 800c170:	d004      	beq.n	800c17c <STTS22H_RegisterBusIO+0x7c>
    {
      ret = pObj->IO.Init();
 800c172:	687b      	ldr	r3, [r7, #4]
 800c174:	681b      	ldr	r3, [r3, #0]
 800c176:	4798      	blx	r3
 800c178:	60f8      	str	r0, [r7, #12]
 800c17a:	e002      	b.n	800c182 <STTS22H_RegisterBusIO+0x82>
    }
    else
    {
      ret = STTS22H_ERROR;
 800c17c:	f04f 33ff 	mov.w	r3, #4294967295
 800c180:	60fb      	str	r3, [r7, #12]
    }
  }

  return ret;
 800c182:	68fb      	ldr	r3, [r7, #12]
}
 800c184:	4618      	mov	r0, r3
 800c186:	3710      	adds	r7, #16
 800c188:	46bd      	mov	sp, r7
 800c18a:	bd80      	pop	{r7, pc}
 800c18c:	0800c595 	.word	0x0800c595
 800c190:	0800c603 	.word	0x0800c603

0800c194 <STTS22H_Init>:
  * @brief  Initialize the STTS22H sensor
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t STTS22H_Init(STTS22H_Object_t *pObj)
{
 800c194:	b580      	push	{r7, lr}
 800c196:	b082      	sub	sp, #8
 800c198:	af00      	add	r7, sp, #0
 800c19a:	6078      	str	r0, [r7, #4]
  if (pObj->is_initialized == 0U)
 800c19c:	687b      	ldr	r3, [r7, #4]
 800c19e:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
 800c1a2:	2b00      	cmp	r3, #0
 800c1a4:	d127      	bne.n	800c1f6 <STTS22H_Init+0x62>
  {
    /* Set default ODR */
    pObj->temp_odr = 1.0f;
 800c1a6:	687b      	ldr	r3, [r7, #4]
 800c1a8:	f04f 527e 	mov.w	r2, #1065353216	@ 0x3f800000
 800c1ac:	635a      	str	r2, [r3, #52]	@ 0x34

    /* Enable BDU */
    if (stts22h_block_data_update_set(&(pObj->Ctx), PROPERTY_ENABLE) != STTS22H_OK)
 800c1ae:	687b      	ldr	r3, [r7, #4]
 800c1b0:	3320      	adds	r3, #32
 800c1b2:	2101      	movs	r1, #1
 800c1b4:	4618      	mov	r0, r3
 800c1b6:	f000 fc21 	bl	800c9fc <stts22h_block_data_update_set>
 800c1ba:	4603      	mov	r3, r0
 800c1bc:	2b00      	cmp	r3, #0
 800c1be:	d002      	beq.n	800c1c6 <STTS22H_Init+0x32>
    {
      return STTS22H_ERROR;
 800c1c0:	f04f 33ff 	mov.w	r3, #4294967295
 800c1c4:	e01c      	b.n	800c200 <STTS22H_Init+0x6c>
    }

    /* Enable Automatic Address Increment */
    if (stts22h_auto_increment_set(&(pObj->Ctx), PROPERTY_ENABLE) != STTS22H_OK)
 800c1c6:	687b      	ldr	r3, [r7, #4]
 800c1c8:	3320      	adds	r3, #32
 800c1ca:	2101      	movs	r1, #1
 800c1cc:	4618      	mov	r0, r3
 800c1ce:	f000 fc6e 	bl	800caae <stts22h_auto_increment_set>
 800c1d2:	4603      	mov	r3, r0
 800c1d4:	2b00      	cmp	r3, #0
 800c1d6:	d002      	beq.n	800c1de <STTS22H_Init+0x4a>
    {
      return STTS22H_ERROR;
 800c1d8:	f04f 33ff 	mov.w	r3, #4294967295
 800c1dc:	e010      	b.n	800c200 <STTS22H_Init+0x6c>
    }

    /* Put the component in standby mode. */
    if (stts22h_temp_data_rate_set(&(pObj->Ctx), STTS22H_POWER_DOWN) != STTS22H_OK)
 800c1de:	687b      	ldr	r3, [r7, #4]
 800c1e0:	3320      	adds	r3, #32
 800c1e2:	2100      	movs	r1, #0
 800c1e4:	4618      	mov	r0, r3
 800c1e6:	f000 fa8d 	bl	800c704 <stts22h_temp_data_rate_set>
 800c1ea:	4603      	mov	r3, r0
 800c1ec:	2b00      	cmp	r3, #0
 800c1ee:	d002      	beq.n	800c1f6 <STTS22H_Init+0x62>
    {
      return STTS22H_ERROR;
 800c1f0:	f04f 33ff 	mov.w	r3, #4294967295
 800c1f4:	e004      	b.n	800c200 <STTS22H_Init+0x6c>
    }
  }

  pObj->is_initialized = 1;
 800c1f6:	687b      	ldr	r3, [r7, #4]
 800c1f8:	2201      	movs	r2, #1
 800c1fa:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30

  return STTS22H_OK;
 800c1fe:	2300      	movs	r3, #0
}
 800c200:	4618      	mov	r0, r3
 800c202:	3708      	adds	r7, #8
 800c204:	46bd      	mov	sp, r7
 800c206:	bd80      	pop	{r7, pc}

0800c208 <STTS22H_DeInit>:
  * @brief  Deinitialize the STTS22H sensor
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t STTS22H_DeInit(STTS22H_Object_t *pObj)
{
 800c208:	b580      	push	{r7, lr}
 800c20a:	b082      	sub	sp, #8
 800c20c:	af00      	add	r7, sp, #0
 800c20e:	6078      	str	r0, [r7, #4]
  if (pObj->is_initialized == 1U)
 800c210:	687b      	ldr	r3, [r7, #4]
 800c212:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
 800c216:	2b01      	cmp	r3, #1
 800c218:	d108      	bne.n	800c22c <STTS22H_DeInit+0x24>
  {
    /* Put the component in standby mode */
    if (STTS22H_TEMP_Disable(pObj) != STTS22H_OK)
 800c21a:	6878      	ldr	r0, [r7, #4]
 800c21c:	f000 f876 	bl	800c30c <STTS22H_TEMP_Disable>
 800c220:	4603      	mov	r3, r0
 800c222:	2b00      	cmp	r3, #0
 800c224:	d002      	beq.n	800c22c <STTS22H_DeInit+0x24>
    {
      return STTS22H_ERROR;
 800c226:	f04f 33ff 	mov.w	r3, #4294967295
 800c22a:	e004      	b.n	800c236 <STTS22H_DeInit+0x2e>
    }
  }

  pObj->is_initialized = 0;
 800c22c:	687b      	ldr	r3, [r7, #4]
 800c22e:	2200      	movs	r2, #0
 800c230:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30

  return STTS22H_OK;
 800c234:	2300      	movs	r3, #0
}
 800c236:	4618      	mov	r0, r3
 800c238:	3708      	adds	r7, #8
 800c23a:	46bd      	mov	sp, r7
 800c23c:	bd80      	pop	{r7, pc}

0800c23e <STTS22H_ReadID>:
  * @param  pObj the device pObj
  * @param  Id the WHO_AM_I value
  * @retval 0 in case of success, an error code otherwise
  */
int32_t STTS22H_ReadID(STTS22H_Object_t *pObj, uint8_t *Id)
{
 800c23e:	b580      	push	{r7, lr}
 800c240:	b084      	sub	sp, #16
 800c242:	af00      	add	r7, sp, #0
 800c244:	6078      	str	r0, [r7, #4]
 800c246:	6039      	str	r1, [r7, #0]
  uint8_t buf;

  if (stts22h_dev_id_get(&(pObj->Ctx), &buf) != STTS22H_OK)
 800c248:	687b      	ldr	r3, [r7, #4]
 800c24a:	3320      	adds	r3, #32
 800c24c:	f107 020f 	add.w	r2, r7, #15
 800c250:	4611      	mov	r1, r2
 800c252:	4618      	mov	r0, r3
 800c254:	f000 fc1a 	bl	800ca8c <stts22h_dev_id_get>
 800c258:	4603      	mov	r3, r0
 800c25a:	2b00      	cmp	r3, #0
 800c25c:	d002      	beq.n	800c264 <STTS22H_ReadID+0x26>
  {
    return STTS22H_ERROR;
 800c25e:	f04f 33ff 	mov.w	r3, #4294967295
 800c262:	e003      	b.n	800c26c <STTS22H_ReadID+0x2e>
  }

  *Id = buf;
 800c264:	7bfa      	ldrb	r2, [r7, #15]
 800c266:	683b      	ldr	r3, [r7, #0]
 800c268:	701a      	strb	r2, [r3, #0]

  return STTS22H_OK;
 800c26a:	2300      	movs	r3, #0
}
 800c26c:	4618      	mov	r0, r3
 800c26e:	3710      	adds	r7, #16
 800c270:	46bd      	mov	sp, r7
 800c272:	bd80      	pop	{r7, pc}

0800c274 <STTS22H_GetCapabilities>:
  * @param  pObj Component object pointer
  * @param  Capabilities pointer to STTS22H sensor capabilities
  * @retval 0 in case of success, an error code otherwise
  */
int32_t STTS22H_GetCapabilities(STTS22H_Object_t *pObj, STTS22H_Capabilities_t *Capabilities)
{
 800c274:	b480      	push	{r7}
 800c276:	b083      	sub	sp, #12
 800c278:	af00      	add	r7, sp, #0
 800c27a:	6078      	str	r0, [r7, #4]
 800c27c:	6039      	str	r1, [r7, #0]
  /* Prevent unused argument(s) compilation warning */
  (void)(pObj);

  Capabilities->Humidity    = 0;
 800c27e:	683b      	ldr	r3, [r7, #0]
 800c280:	2200      	movs	r2, #0
 800c282:	709a      	strb	r2, [r3, #2]
  Capabilities->Pressure    = 0;
 800c284:	683b      	ldr	r3, [r7, #0]
 800c286:	2200      	movs	r2, #0
 800c288:	705a      	strb	r2, [r3, #1]
  Capabilities->Temperature = 1;
 800c28a:	683b      	ldr	r3, [r7, #0]
 800c28c:	2201      	movs	r2, #1
 800c28e:	701a      	strb	r2, [r3, #0]
  Capabilities->Gas         = 0;
 800c290:	683b      	ldr	r3, [r7, #0]
 800c292:	2200      	movs	r2, #0
 800c294:	70da      	strb	r2, [r3, #3]
  Capabilities->LowPower    = 0;
 800c296:	683b      	ldr	r3, [r7, #0]
 800c298:	2200      	movs	r2, #0
 800c29a:	711a      	strb	r2, [r3, #4]
  Capabilities->HumMaxOdr   = 0.0f;
 800c29c:	683b      	ldr	r3, [r7, #0]
 800c29e:	f04f 0200 	mov.w	r2, #0
 800c2a2:	609a      	str	r2, [r3, #8]
  Capabilities->TempMaxOdr  = 200.0f;
 800c2a4:	683b      	ldr	r3, [r7, #0]
 800c2a6:	4a08      	ldr	r2, [pc, #32]	@ (800c2c8 <STTS22H_GetCapabilities+0x54>)
 800c2a8:	60da      	str	r2, [r3, #12]
  Capabilities->PressMaxOdr = 0.0f;
 800c2aa:	683b      	ldr	r3, [r7, #0]
 800c2ac:	f04f 0200 	mov.w	r2, #0
 800c2b0:	611a      	str	r2, [r3, #16]
  Capabilities->GasMaxOdr   = 0.0f;
 800c2b2:	683b      	ldr	r3, [r7, #0]
 800c2b4:	f04f 0200 	mov.w	r2, #0
 800c2b8:	615a      	str	r2, [r3, #20]
  return STTS22H_OK;
 800c2ba:	2300      	movs	r3, #0
}
 800c2bc:	4618      	mov	r0, r3
 800c2be:	370c      	adds	r7, #12
 800c2c0:	46bd      	mov	sp, r7
 800c2c2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c2c6:	4770      	bx	lr
 800c2c8:	43480000 	.word	0x43480000

0800c2cc <STTS22H_TEMP_Enable>:
  * @brief  Enable the STTS22H temperature sensor
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t STTS22H_TEMP_Enable(STTS22H_Object_t *pObj)
{
 800c2cc:	b580      	push	{r7, lr}
 800c2ce:	b082      	sub	sp, #8
 800c2d0:	af00      	add	r7, sp, #0
 800c2d2:	6078      	str	r0, [r7, #4]
  /* Check if the component is already enabled */
  if (pObj->temp_is_enabled == 1U)
 800c2d4:	687b      	ldr	r3, [r7, #4]
 800c2d6:	f893 3031 	ldrb.w	r3, [r3, #49]	@ 0x31
 800c2da:	2b01      	cmp	r3, #1
 800c2dc:	d101      	bne.n	800c2e2 <STTS22H_TEMP_Enable+0x16>
  {
    return STTS22H_OK;
 800c2de:	2300      	movs	r3, #0
 800c2e0:	e010      	b.n	800c304 <STTS22H_TEMP_Enable+0x38>
  }

  /* Power on the component and set the odr. */
  if (STTS22H_TEMP_SetOutputDataRate(pObj, pObj->temp_odr) != STTS22H_OK)
 800c2e2:	687b      	ldr	r3, [r7, #4]
 800c2e4:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800c2e6:	4619      	mov	r1, r3
 800c2e8:	6878      	ldr	r0, [r7, #4]
 800c2ea:	f000 f8e9 	bl	800c4c0 <STTS22H_TEMP_SetOutputDataRate>
 800c2ee:	4603      	mov	r3, r0
 800c2f0:	2b00      	cmp	r3, #0
 800c2f2:	d002      	beq.n	800c2fa <STTS22H_TEMP_Enable+0x2e>
  {
    return STTS22H_ERROR;
 800c2f4:	f04f 33ff 	mov.w	r3, #4294967295
 800c2f8:	e004      	b.n	800c304 <STTS22H_TEMP_Enable+0x38>
  }

  pObj->temp_is_enabled = 1;
 800c2fa:	687b      	ldr	r3, [r7, #4]
 800c2fc:	2201      	movs	r2, #1
 800c2fe:	f883 2031 	strb.w	r2, [r3, #49]	@ 0x31

  return STTS22H_OK;
 800c302:	2300      	movs	r3, #0
}
 800c304:	4618      	mov	r0, r3
 800c306:	3708      	adds	r7, #8
 800c308:	46bd      	mov	sp, r7
 800c30a:	bd80      	pop	{r7, pc}

0800c30c <STTS22H_TEMP_Disable>:
  * @brief  Disable the STTS22H temperature sensor
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t STTS22H_TEMP_Disable(STTS22H_Object_t *pObj)
{
 800c30c:	b580      	push	{r7, lr}
 800c30e:	b082      	sub	sp, #8
 800c310:	af00      	add	r7, sp, #0
 800c312:	6078      	str	r0, [r7, #4]
  /* Check if the component is already disabled */
  if (pObj->temp_is_enabled == 0U)
 800c314:	687b      	ldr	r3, [r7, #4]
 800c316:	f893 3031 	ldrb.w	r3, [r3, #49]	@ 0x31
 800c31a:	2b00      	cmp	r3, #0
 800c31c:	d101      	bne.n	800c322 <STTS22H_TEMP_Disable+0x16>
  {
    return STTS22H_OK;
 800c31e:	2300      	movs	r3, #0
 800c320:	e01c      	b.n	800c35c <STTS22H_TEMP_Disable+0x50>
  }

  /* Save the current odr. */
  if (STTS22H_TEMP_GetOutputDataRate(pObj, &pObj->temp_odr) != STTS22H_OK)
 800c322:	687b      	ldr	r3, [r7, #4]
 800c324:	3334      	adds	r3, #52	@ 0x34
 800c326:	4619      	mov	r1, r3
 800c328:	6878      	ldr	r0, [r7, #4]
 800c32a:	f000 f81b 	bl	800c364 <STTS22H_TEMP_GetOutputDataRate>
 800c32e:	4603      	mov	r3, r0
 800c330:	2b00      	cmp	r3, #0
 800c332:	d002      	beq.n	800c33a <STTS22H_TEMP_Disable+0x2e>
  {
    return STTS22H_ERROR;
 800c334:	f04f 33ff 	mov.w	r3, #4294967295
 800c338:	e010      	b.n	800c35c <STTS22H_TEMP_Disable+0x50>
  }

  /* Put the component in standby mode. */
  if (stts22h_temp_data_rate_set(&(pObj->Ctx), STTS22H_POWER_DOWN) != STTS22H_OK)
 800c33a:	687b      	ldr	r3, [r7, #4]
 800c33c:	3320      	adds	r3, #32
 800c33e:	2100      	movs	r1, #0
 800c340:	4618      	mov	r0, r3
 800c342:	f000 f9df 	bl	800c704 <stts22h_temp_data_rate_set>
 800c346:	4603      	mov	r3, r0
 800c348:	2b00      	cmp	r3, #0
 800c34a:	d002      	beq.n	800c352 <STTS22H_TEMP_Disable+0x46>
  {
    return STTS22H_ERROR;
 800c34c:	f04f 33ff 	mov.w	r3, #4294967295
 800c350:	e004      	b.n	800c35c <STTS22H_TEMP_Disable+0x50>
  }

  pObj->temp_is_enabled = 0;
 800c352:	687b      	ldr	r3, [r7, #4]
 800c354:	2200      	movs	r2, #0
 800c356:	f883 2031 	strb.w	r2, [r3, #49]	@ 0x31

  return STTS22H_OK;
 800c35a:	2300      	movs	r3, #0
}
 800c35c:	4618      	mov	r0, r3
 800c35e:	3708      	adds	r7, #8
 800c360:	46bd      	mov	sp, r7
 800c362:	bd80      	pop	{r7, pc}

0800c364 <STTS22H_TEMP_GetOutputDataRate>:
  * @param  pObj the device pObj
  * @param  Odr pointer where the output data rate is written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t STTS22H_TEMP_GetOutputDataRate(STTS22H_Object_t *pObj, float *Odr)
{
 800c364:	b580      	push	{r7, lr}
 800c366:	b084      	sub	sp, #16
 800c368:	af00      	add	r7, sp, #0
 800c36a:	6078      	str	r0, [r7, #4]
 800c36c:	6039      	str	r1, [r7, #0]
  int32_t ret = STTS22H_OK;
 800c36e:	2300      	movs	r3, #0
 800c370:	60fb      	str	r3, [r7, #12]
  stts22h_odr_temp_t odr_low_level;

  if (stts22h_temp_data_rate_get(&(pObj->Ctx), &odr_low_level) != STTS22H_OK)
 800c372:	687b      	ldr	r3, [r7, #4]
 800c374:	3320      	adds	r3, #32
 800c376:	f107 020b 	add.w	r2, r7, #11
 800c37a:	4611      	mov	r1, r2
 800c37c:	4618      	mov	r0, r3
 800c37e:	f000 fa87 	bl	800c890 <stts22h_temp_data_rate_get>
 800c382:	4603      	mov	r3, r0
 800c384:	2b00      	cmp	r3, #0
 800c386:	d002      	beq.n	800c38e <STTS22H_TEMP_GetOutputDataRate+0x2a>
  {
    return STTS22H_ERROR;
 800c388:	f04f 33ff 	mov.w	r3, #4294967295
 800c38c:	e08b      	b.n	800c4a6 <STTS22H_TEMP_GetOutputDataRate+0x142>
  }

  switch (odr_low_level)
 800c38e:	7afb      	ldrb	r3, [r7, #11]
 800c390:	2b32      	cmp	r3, #50	@ 0x32
 800c392:	f200 8083 	bhi.w	800c49c <STTS22H_TEMP_GetOutputDataRate+0x138>
 800c396:	a201      	add	r2, pc, #4	@ (adr r2, 800c39c <STTS22H_TEMP_GetOutputDataRate+0x38>)
 800c398:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800c39c:	0800c469 	.word	0x0800c469
 800c3a0:	0800c469 	.word	0x0800c469
 800c3a4:	0800c47d 	.word	0x0800c47d
 800c3a8:	0800c49d 	.word	0x0800c49d
 800c3ac:	0800c473 	.word	0x0800c473
 800c3b0:	0800c49d 	.word	0x0800c49d
 800c3b4:	0800c49d 	.word	0x0800c49d
 800c3b8:	0800c49d 	.word	0x0800c49d
 800c3bc:	0800c49d 	.word	0x0800c49d
 800c3c0:	0800c49d 	.word	0x0800c49d
 800c3c4:	0800c49d 	.word	0x0800c49d
 800c3c8:	0800c49d 	.word	0x0800c49d
 800c3cc:	0800c49d 	.word	0x0800c49d
 800c3d0:	0800c49d 	.word	0x0800c49d
 800c3d4:	0800c49d 	.word	0x0800c49d
 800c3d8:	0800c49d 	.word	0x0800c49d
 800c3dc:	0800c49d 	.word	0x0800c49d
 800c3e0:	0800c49d 	.word	0x0800c49d
 800c3e4:	0800c485 	.word	0x0800c485
 800c3e8:	0800c49d 	.word	0x0800c49d
 800c3ec:	0800c49d 	.word	0x0800c49d
 800c3f0:	0800c49d 	.word	0x0800c49d
 800c3f4:	0800c49d 	.word	0x0800c49d
 800c3f8:	0800c49d 	.word	0x0800c49d
 800c3fc:	0800c49d 	.word	0x0800c49d
 800c400:	0800c49d 	.word	0x0800c49d
 800c404:	0800c49d 	.word	0x0800c49d
 800c408:	0800c49d 	.word	0x0800c49d
 800c40c:	0800c49d 	.word	0x0800c49d
 800c410:	0800c49d 	.word	0x0800c49d
 800c414:	0800c49d 	.word	0x0800c49d
 800c418:	0800c49d 	.word	0x0800c49d
 800c41c:	0800c49d 	.word	0x0800c49d
 800c420:	0800c49d 	.word	0x0800c49d
 800c424:	0800c48d 	.word	0x0800c48d
 800c428:	0800c49d 	.word	0x0800c49d
 800c42c:	0800c49d 	.word	0x0800c49d
 800c430:	0800c49d 	.word	0x0800c49d
 800c434:	0800c49d 	.word	0x0800c49d
 800c438:	0800c49d 	.word	0x0800c49d
 800c43c:	0800c49d 	.word	0x0800c49d
 800c440:	0800c49d 	.word	0x0800c49d
 800c444:	0800c49d 	.word	0x0800c49d
 800c448:	0800c49d 	.word	0x0800c49d
 800c44c:	0800c49d 	.word	0x0800c49d
 800c450:	0800c49d 	.word	0x0800c49d
 800c454:	0800c49d 	.word	0x0800c49d
 800c458:	0800c49d 	.word	0x0800c49d
 800c45c:	0800c49d 	.word	0x0800c49d
 800c460:	0800c49d 	.word	0x0800c49d
 800c464:	0800c495 	.word	0x0800c495
  {
    case STTS22H_POWER_DOWN:
    case STTS22H_ONE_SHOT:
      *Odr = 0.0f;
 800c468:	683b      	ldr	r3, [r7, #0]
 800c46a:	f04f 0200 	mov.w	r2, #0
 800c46e:	601a      	str	r2, [r3, #0]
      break;
 800c470:	e018      	b.n	800c4a4 <STTS22H_TEMP_GetOutputDataRate+0x140>

    case STTS22H_1Hz:
      *Odr = 1.0f;
 800c472:	683b      	ldr	r3, [r7, #0]
 800c474:	f04f 527e 	mov.w	r2, #1065353216	@ 0x3f800000
 800c478:	601a      	str	r2, [r3, #0]
      break;
 800c47a:	e013      	b.n	800c4a4 <STTS22H_TEMP_GetOutputDataRate+0x140>

    case STTS22H_25Hz:
      *Odr = 25.0f;
 800c47c:	683b      	ldr	r3, [r7, #0]
 800c47e:	4a0c      	ldr	r2, [pc, #48]	@ (800c4b0 <STTS22H_TEMP_GetOutputDataRate+0x14c>)
 800c480:	601a      	str	r2, [r3, #0]
      break;
 800c482:	e00f      	b.n	800c4a4 <STTS22H_TEMP_GetOutputDataRate+0x140>

    case STTS22H_50Hz:
      *Odr = 50.0f;
 800c484:	683b      	ldr	r3, [r7, #0]
 800c486:	4a0b      	ldr	r2, [pc, #44]	@ (800c4b4 <STTS22H_TEMP_GetOutputDataRate+0x150>)
 800c488:	601a      	str	r2, [r3, #0]
      break;
 800c48a:	e00b      	b.n	800c4a4 <STTS22H_TEMP_GetOutputDataRate+0x140>

    case STTS22H_100Hz:
      *Odr = 100.0f;
 800c48c:	683b      	ldr	r3, [r7, #0]
 800c48e:	4a0a      	ldr	r2, [pc, #40]	@ (800c4b8 <STTS22H_TEMP_GetOutputDataRate+0x154>)
 800c490:	601a      	str	r2, [r3, #0]
      break;
 800c492:	e007      	b.n	800c4a4 <STTS22H_TEMP_GetOutputDataRate+0x140>

    case STTS22H_200Hz:
      *Odr = 200.0f;
 800c494:	683b      	ldr	r3, [r7, #0]
 800c496:	4a09      	ldr	r2, [pc, #36]	@ (800c4bc <STTS22H_TEMP_GetOutputDataRate+0x158>)
 800c498:	601a      	str	r2, [r3, #0]
      break;
 800c49a:	e003      	b.n	800c4a4 <STTS22H_TEMP_GetOutputDataRate+0x140>

    default:
      ret = STTS22H_ERROR;
 800c49c:	f04f 33ff 	mov.w	r3, #4294967295
 800c4a0:	60fb      	str	r3, [r7, #12]
      break;
 800c4a2:	bf00      	nop
  }

  return ret;
 800c4a4:	68fb      	ldr	r3, [r7, #12]
}
 800c4a6:	4618      	mov	r0, r3
 800c4a8:	3710      	adds	r7, #16
 800c4aa:	46bd      	mov	sp, r7
 800c4ac:	bd80      	pop	{r7, pc}
 800c4ae:	bf00      	nop
 800c4b0:	41c80000 	.word	0x41c80000
 800c4b4:	42480000 	.word	0x42480000
 800c4b8:	42c80000 	.word	0x42c80000
 800c4bc:	43480000 	.word	0x43480000

0800c4c0 <STTS22H_TEMP_SetOutputDataRate>:
  * @param  pObj the device pObj
  * @param  Odr the output data rate value to be set
  * @retval 0 in case of success, an error code otherwise
  */
int32_t STTS22H_TEMP_SetOutputDataRate(STTS22H_Object_t *pObj, float Odr)
{
 800c4c0:	b580      	push	{r7, lr}
 800c4c2:	b084      	sub	sp, #16
 800c4c4:	af00      	add	r7, sp, #0
 800c4c6:	6078      	str	r0, [r7, #4]
 800c4c8:	6039      	str	r1, [r7, #0]
  stts22h_odr_temp_t new_odr;

  new_odr = (Odr <= 1.0f) ? STTS22H_1Hz
            : (Odr <= 25.0f) ? STTS22H_25Hz
 800c4ca:	edd7 7a00 	vldr	s15, [r7]
 800c4ce:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 800c4d2:	eef4 7ac7 	vcmpe.f32	s15, s14
 800c4d6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c4da:	d801      	bhi.n	800c4e0 <STTS22H_TEMP_SetOutputDataRate+0x20>
 800c4dc:	2304      	movs	r3, #4
 800c4de:	e021      	b.n	800c524 <STTS22H_TEMP_SetOutputDataRate+0x64>
 800c4e0:	edd7 7a00 	vldr	s15, [r7]
 800c4e4:	eeb3 7a09 	vmov.f32	s14, #57	@ 0x41c80000  25.0
 800c4e8:	eef4 7ac7 	vcmpe.f32	s15, s14
 800c4ec:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c4f0:	d801      	bhi.n	800c4f6 <STTS22H_TEMP_SetOutputDataRate+0x36>
 800c4f2:	2302      	movs	r3, #2
 800c4f4:	e016      	b.n	800c524 <STTS22H_TEMP_SetOutputDataRate+0x64>
 800c4f6:	edd7 7a00 	vldr	s15, [r7]
 800c4fa:	ed9f 7a14 	vldr	s14, [pc, #80]	@ 800c54c <STTS22H_TEMP_SetOutputDataRate+0x8c>
 800c4fe:	eef4 7ac7 	vcmpe.f32	s15, s14
 800c502:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c506:	d801      	bhi.n	800c50c <STTS22H_TEMP_SetOutputDataRate+0x4c>
 800c508:	2312      	movs	r3, #18
 800c50a:	e00b      	b.n	800c524 <STTS22H_TEMP_SetOutputDataRate+0x64>
 800c50c:	edd7 7a00 	vldr	s15, [r7]
 800c510:	ed9f 7a0f 	vldr	s14, [pc, #60]	@ 800c550 <STTS22H_TEMP_SetOutputDataRate+0x90>
 800c514:	eef4 7ac7 	vcmpe.f32	s15, s14
 800c518:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c51c:	d801      	bhi.n	800c522 <STTS22H_TEMP_SetOutputDataRate+0x62>
 800c51e:	2322      	movs	r3, #34	@ 0x22
 800c520:	e000      	b.n	800c524 <STTS22H_TEMP_SetOutputDataRate+0x64>
 800c522:	2332      	movs	r3, #50	@ 0x32
  new_odr = (Odr <= 1.0f) ? STTS22H_1Hz
 800c524:	73fb      	strb	r3, [r7, #15]
            : (Odr <= 50.0f) ? STTS22H_50Hz
            : (Odr <= 100.0f) ? STTS22H_100Hz
            :                    STTS22H_200Hz;

  if (stts22h_temp_data_rate_set(&(pObj->Ctx), new_odr) != STTS22H_OK)
 800c526:	687b      	ldr	r3, [r7, #4]
 800c528:	3320      	adds	r3, #32
 800c52a:	7bfa      	ldrb	r2, [r7, #15]
 800c52c:	4611      	mov	r1, r2
 800c52e:	4618      	mov	r0, r3
 800c530:	f000 f8e8 	bl	800c704 <stts22h_temp_data_rate_set>
 800c534:	4603      	mov	r3, r0
 800c536:	2b00      	cmp	r3, #0
 800c538:	d002      	beq.n	800c540 <STTS22H_TEMP_SetOutputDataRate+0x80>
  {
    return STTS22H_ERROR;
 800c53a:	f04f 33ff 	mov.w	r3, #4294967295
 800c53e:	e000      	b.n	800c542 <STTS22H_TEMP_SetOutputDataRate+0x82>
  }

  return STTS22H_OK;
 800c540:	2300      	movs	r3, #0
}
 800c542:	4618      	mov	r0, r3
 800c544:	3710      	adds	r7, #16
 800c546:	46bd      	mov	sp, r7
 800c548:	bd80      	pop	{r7, pc}
 800c54a:	bf00      	nop
 800c54c:	42480000 	.word	0x42480000
 800c550:	42c80000 	.word	0x42c80000

0800c554 <STTS22H_TEMP_GetTemperature>:
  * @param  pObj the device pObj
  * @param  Value pointer where the temperature value is written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t STTS22H_TEMP_GetTemperature(STTS22H_Object_t *pObj, float *Value)
{
 800c554:	b580      	push	{r7, lr}
 800c556:	b084      	sub	sp, #16
 800c558:	af00      	add	r7, sp, #0
 800c55a:	6078      	str	r0, [r7, #4]
 800c55c:	6039      	str	r1, [r7, #0]
  int16_t raw_value;

  /* Get the temperature */
  if (stts22h_temperature_raw_get(&(pObj->Ctx), &raw_value) != STTS22H_OK)
 800c55e:	687b      	ldr	r3, [r7, #4]
 800c560:	3320      	adds	r3, #32
 800c562:	f107 020e 	add.w	r2, r7, #14
 800c566:	4611      	mov	r1, r2
 800c568:	4618      	mov	r0, r3
 800c56a:	f000 fa6d 	bl	800ca48 <stts22h_temperature_raw_get>
 800c56e:	4603      	mov	r3, r0
 800c570:	2b00      	cmp	r3, #0
 800c572:	d002      	beq.n	800c57a <STTS22H_TEMP_GetTemperature+0x26>
  {
    return STTS22H_ERROR;
 800c574:	f04f 33ff 	mov.w	r3, #4294967295
 800c578:	e008      	b.n	800c58c <STTS22H_TEMP_GetTemperature+0x38>
  }

  *Value = stts22h_from_lsb_to_celsius(raw_value);
 800c57a:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 800c57e:	4618      	mov	r0, r3
 800c580:	f000 f8a6 	bl	800c6d0 <stts22h_from_lsb_to_celsius>
 800c584:	4602      	mov	r2, r0
 800c586:	683b      	ldr	r3, [r7, #0]
 800c588:	601a      	str	r2, [r3, #0]

  return STTS22H_OK;
 800c58a:	2300      	movs	r3, #0
}
 800c58c:	4618      	mov	r0, r3
 800c58e:	3710      	adds	r7, #16
 800c590:	46bd      	mov	sp, r7
 800c592:	bd80      	pop	{r7, pc}

0800c594 <ReadRegWrap>:
  * @param  pData the stored data pointer
  * @param  Length the length
  * @retval 0 in case of success, an error code otherwise
  */
static int32_t ReadRegWrap(void *Handle, uint8_t Reg, uint8_t *pData, uint16_t Length)
{
 800c594:	b590      	push	{r4, r7, lr}
 800c596:	b089      	sub	sp, #36	@ 0x24
 800c598:	af00      	add	r7, sp, #0
 800c59a:	60f8      	str	r0, [r7, #12]
 800c59c:	607a      	str	r2, [r7, #4]
 800c59e:	461a      	mov	r2, r3
 800c5a0:	460b      	mov	r3, r1
 800c5a2:	72fb      	strb	r3, [r7, #11]
 800c5a4:	4613      	mov	r3, r2
 800c5a6:	813b      	strh	r3, [r7, #8]
  uint16_t i;
  int32_t ret = STTS22H_OK;
 800c5a8:	2300      	movs	r3, #0
 800c5aa:	61bb      	str	r3, [r7, #24]
  STTS22H_Object_t *pObj = (STTS22H_Object_t *)Handle;
 800c5ac:	68fb      	ldr	r3, [r7, #12]
 800c5ae:	617b      	str	r3, [r7, #20]

  if (pObj->IO.BusType == (uint32_t)STTS22H_I2C_BUS) /* I2C */
 800c5b0:	697b      	ldr	r3, [r7, #20]
 800c5b2:	689b      	ldr	r3, [r3, #8]
 800c5b4:	2b00      	cmp	r3, #0
 800c5b6:	d11f      	bne.n	800c5f8 <ReadRegWrap+0x64>
  {
    for (i = 0; i < Length; i++)
 800c5b8:	2300      	movs	r3, #0
 800c5ba:	83fb      	strh	r3, [r7, #30]
 800c5bc:	e018      	b.n	800c5f0 <ReadRegWrap+0x5c>
    {
      ret = pObj->IO.ReadReg(pObj->IO.Address, (Reg + i), &pData[i], 1);
 800c5be:	697b      	ldr	r3, [r7, #20]
 800c5c0:	695c      	ldr	r4, [r3, #20]
 800c5c2:	697b      	ldr	r3, [r7, #20]
 800c5c4:	7b1b      	ldrb	r3, [r3, #12]
 800c5c6:	4618      	mov	r0, r3
 800c5c8:	7afb      	ldrb	r3, [r7, #11]
 800c5ca:	b29a      	uxth	r2, r3
 800c5cc:	8bfb      	ldrh	r3, [r7, #30]
 800c5ce:	4413      	add	r3, r2
 800c5d0:	b299      	uxth	r1, r3
 800c5d2:	8bfb      	ldrh	r3, [r7, #30]
 800c5d4:	687a      	ldr	r2, [r7, #4]
 800c5d6:	441a      	add	r2, r3
 800c5d8:	2301      	movs	r3, #1
 800c5da:	47a0      	blx	r4
 800c5dc:	61b8      	str	r0, [r7, #24]
      if (ret != STTS22H_OK)
 800c5de:	69bb      	ldr	r3, [r7, #24]
 800c5e0:	2b00      	cmp	r3, #0
 800c5e2:	d002      	beq.n	800c5ea <ReadRegWrap+0x56>
      {
        return STTS22H_ERROR;
 800c5e4:	f04f 33ff 	mov.w	r3, #4294967295
 800c5e8:	e007      	b.n	800c5fa <ReadRegWrap+0x66>
    for (i = 0; i < Length; i++)
 800c5ea:	8bfb      	ldrh	r3, [r7, #30]
 800c5ec:	3301      	adds	r3, #1
 800c5ee:	83fb      	strh	r3, [r7, #30]
 800c5f0:	8bfa      	ldrh	r2, [r7, #30]
 800c5f2:	893b      	ldrh	r3, [r7, #8]
 800c5f4:	429a      	cmp	r2, r3
 800c5f6:	d3e2      	bcc.n	800c5be <ReadRegWrap+0x2a>
      }
    }
  }

  return ret;
 800c5f8:	69bb      	ldr	r3, [r7, #24]
}
 800c5fa:	4618      	mov	r0, r3
 800c5fc:	3724      	adds	r7, #36	@ 0x24
 800c5fe:	46bd      	mov	sp, r7
 800c600:	bd90      	pop	{r4, r7, pc}

0800c602 <WriteRegWrap>:
  * @param  pData the stored data pointer
  * @param  Length the length
  * @retval 0 in case of success, an error code otherwise
  */
static int32_t WriteRegWrap(void *Handle, uint8_t Reg, uint8_t *pData, uint16_t Length)
{
 800c602:	b590      	push	{r4, r7, lr}
 800c604:	b089      	sub	sp, #36	@ 0x24
 800c606:	af00      	add	r7, sp, #0
 800c608:	60f8      	str	r0, [r7, #12]
 800c60a:	607a      	str	r2, [r7, #4]
 800c60c:	461a      	mov	r2, r3
 800c60e:	460b      	mov	r3, r1
 800c610:	72fb      	strb	r3, [r7, #11]
 800c612:	4613      	mov	r3, r2
 800c614:	813b      	strh	r3, [r7, #8]
  uint16_t i;
  int32_t ret = STTS22H_OK;
 800c616:	2300      	movs	r3, #0
 800c618:	61bb      	str	r3, [r7, #24]
  STTS22H_Object_t *pObj = (STTS22H_Object_t *)Handle;
 800c61a:	68fb      	ldr	r3, [r7, #12]
 800c61c:	617b      	str	r3, [r7, #20]

  if (pObj->IO.BusType == (uint32_t)STTS22H_I2C_BUS) /* I2C */
 800c61e:	697b      	ldr	r3, [r7, #20]
 800c620:	689b      	ldr	r3, [r3, #8]
 800c622:	2b00      	cmp	r3, #0
 800c624:	d11f      	bne.n	800c666 <WriteRegWrap+0x64>
  {
    for (i = 0; i < Length; i++)
 800c626:	2300      	movs	r3, #0
 800c628:	83fb      	strh	r3, [r7, #30]
 800c62a:	e018      	b.n	800c65e <WriteRegWrap+0x5c>
    {
      ret = pObj->IO.WriteReg(pObj->IO.Address, (Reg + i), &pData[i], 1);
 800c62c:	697b      	ldr	r3, [r7, #20]
 800c62e:	691c      	ldr	r4, [r3, #16]
 800c630:	697b      	ldr	r3, [r7, #20]
 800c632:	7b1b      	ldrb	r3, [r3, #12]
 800c634:	4618      	mov	r0, r3
 800c636:	7afb      	ldrb	r3, [r7, #11]
 800c638:	b29a      	uxth	r2, r3
 800c63a:	8bfb      	ldrh	r3, [r7, #30]
 800c63c:	4413      	add	r3, r2
 800c63e:	b299      	uxth	r1, r3
 800c640:	8bfb      	ldrh	r3, [r7, #30]
 800c642:	687a      	ldr	r2, [r7, #4]
 800c644:	441a      	add	r2, r3
 800c646:	2301      	movs	r3, #1
 800c648:	47a0      	blx	r4
 800c64a:	61b8      	str	r0, [r7, #24]
      if (ret != STTS22H_OK)
 800c64c:	69bb      	ldr	r3, [r7, #24]
 800c64e:	2b00      	cmp	r3, #0
 800c650:	d002      	beq.n	800c658 <WriteRegWrap+0x56>
      {
        return STTS22H_ERROR;
 800c652:	f04f 33ff 	mov.w	r3, #4294967295
 800c656:	e007      	b.n	800c668 <WriteRegWrap+0x66>
    for (i = 0; i < Length; i++)
 800c658:	8bfb      	ldrh	r3, [r7, #30]
 800c65a:	3301      	adds	r3, #1
 800c65c:	83fb      	strh	r3, [r7, #30]
 800c65e:	8bfa      	ldrh	r2, [r7, #30]
 800c660:	893b      	ldrh	r3, [r7, #8]
 800c662:	429a      	cmp	r2, r3
 800c664:	d3e2      	bcc.n	800c62c <WriteRegWrap+0x2a>
      }
    }
  }

  return ret;
 800c666:	69bb      	ldr	r3, [r7, #24]
}
 800c668:	4618      	mov	r0, r3
 800c66a:	3724      	adds	r7, #36	@ 0x24
 800c66c:	46bd      	mov	sp, r7
 800c66e:	bd90      	pop	{r4, r7, pc}

0800c670 <stts22h_read_reg>:
  *
  */
int32_t __weak stts22h_read_reg(stmdev_ctx_t *ctx, uint8_t reg,
                                uint8_t *data,
                                uint16_t len)
{
 800c670:	b590      	push	{r4, r7, lr}
 800c672:	b087      	sub	sp, #28
 800c674:	af00      	add	r7, sp, #0
 800c676:	60f8      	str	r0, [r7, #12]
 800c678:	607a      	str	r2, [r7, #4]
 800c67a:	461a      	mov	r2, r3
 800c67c:	460b      	mov	r3, r1
 800c67e:	72fb      	strb	r3, [r7, #11]
 800c680:	4613      	mov	r3, r2
 800c682:	813b      	strh	r3, [r7, #8]
  int32_t ret;

  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800c684:	68fb      	ldr	r3, [r7, #12]
 800c686:	685c      	ldr	r4, [r3, #4]
 800c688:	68fb      	ldr	r3, [r7, #12]
 800c68a:	68d8      	ldr	r0, [r3, #12]
 800c68c:	893b      	ldrh	r3, [r7, #8]
 800c68e:	7af9      	ldrb	r1, [r7, #11]
 800c690:	687a      	ldr	r2, [r7, #4]
 800c692:	47a0      	blx	r4
 800c694:	6178      	str	r0, [r7, #20]

  return ret;
 800c696:	697b      	ldr	r3, [r7, #20]
}
 800c698:	4618      	mov	r0, r3
 800c69a:	371c      	adds	r7, #28
 800c69c:	46bd      	mov	sp, r7
 800c69e:	bd90      	pop	{r4, r7, pc}

0800c6a0 <stts22h_write_reg>:
  *
  */
int32_t __weak stts22h_write_reg(stmdev_ctx_t *ctx, uint8_t reg,
                                 uint8_t *data,
                                 uint16_t len)
{
 800c6a0:	b590      	push	{r4, r7, lr}
 800c6a2:	b087      	sub	sp, #28
 800c6a4:	af00      	add	r7, sp, #0
 800c6a6:	60f8      	str	r0, [r7, #12]
 800c6a8:	607a      	str	r2, [r7, #4]
 800c6aa:	461a      	mov	r2, r3
 800c6ac:	460b      	mov	r3, r1
 800c6ae:	72fb      	strb	r3, [r7, #11]
 800c6b0:	4613      	mov	r3, r2
 800c6b2:	813b      	strh	r3, [r7, #8]
  int32_t ret;

  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800c6b4:	68fb      	ldr	r3, [r7, #12]
 800c6b6:	681c      	ldr	r4, [r3, #0]
 800c6b8:	68fb      	ldr	r3, [r7, #12]
 800c6ba:	68d8      	ldr	r0, [r3, #12]
 800c6bc:	893b      	ldrh	r3, [r7, #8]
 800c6be:	7af9      	ldrb	r1, [r7, #11]
 800c6c0:	687a      	ldr	r2, [r7, #4]
 800c6c2:	47a0      	blx	r4
 800c6c4:	6178      	str	r0, [r7, #20]

  return ret;
 800c6c6:	697b      	ldr	r3, [r7, #20]
}
 800c6c8:	4618      	mov	r0, r3
 800c6ca:	371c      	adds	r7, #28
 800c6cc:	46bd      	mov	sp, r7
 800c6ce:	bd90      	pop	{r4, r7, pc}

0800c6d0 <stts22h_from_lsb_to_celsius>:
  * @{
  *
  */

float_t stts22h_from_lsb_to_celsius(int16_t lsb)
{
 800c6d0:	b480      	push	{r7}
 800c6d2:	b083      	sub	sp, #12
 800c6d4:	af00      	add	r7, sp, #0
 800c6d6:	4603      	mov	r3, r0
 800c6d8:	80fb      	strh	r3, [r7, #6]
  return ((float_t)lsb / 100.0f);
 800c6da:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 800c6de:	ee07 3a90 	vmov	s15, r3
 800c6e2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800c6e6:	ed9f 7a06 	vldr	s14, [pc, #24]	@ 800c700 <stts22h_from_lsb_to_celsius+0x30>
 800c6ea:	eec7 6a87 	vdiv.f32	s13, s15, s14
 800c6ee:	ee16 3a90 	vmov	r3, s13
}
 800c6f2:	4618      	mov	r0, r3
 800c6f4:	370c      	adds	r7, #12
 800c6f6:	46bd      	mov	sp, r7
 800c6f8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c6fc:	4770      	bx	lr
 800c6fe:	bf00      	nop
 800c700:	42c80000 	.word	0x42c80000

0800c704 <stts22h_temp_data_rate_set>:
  * @retval        Interface status (MANDATORY: return 0 -> no Error).
  *
  */
int32_t stts22h_temp_data_rate_set(stmdev_ctx_t *ctx,
                                   stts22h_odr_temp_t val)
{
 800c704:	b580      	push	{r7, lr}
 800c706:	b086      	sub	sp, #24
 800c708:	af00      	add	r7, sp, #0
 800c70a:	6078      	str	r0, [r7, #4]
 800c70c:	460b      	mov	r3, r1
 800c70e:	70fb      	strb	r3, [r7, #3]
  stts22h_software_reset_t software_reset;
  stts22h_ctrl_t ctrl;
  int32_t ret;

  ret = stts22h_read_reg(ctx, STTS22H_CTRL, (uint8_t *)&ctrl, 1);
 800c710:	f107 020c 	add.w	r2, r7, #12
 800c714:	2301      	movs	r3, #1
 800c716:	2104      	movs	r1, #4
 800c718:	6878      	ldr	r0, [r7, #4]
 800c71a:	f7ff ffa9 	bl	800c670 <stts22h_read_reg>
 800c71e:	6178      	str	r0, [r7, #20]

  if (ret == 0)
 800c720:	697b      	ldr	r3, [r7, #20]
 800c722:	2b00      	cmp	r3, #0
 800c724:	d107      	bne.n	800c736 <stts22h_temp_data_rate_set+0x32>
  {
    ret = stts22h_read_reg(ctx, STTS22H_SOFTWARE_RESET,
 800c726:	f107 0210 	add.w	r2, r7, #16
 800c72a:	2301      	movs	r3, #1
 800c72c:	210c      	movs	r1, #12
 800c72e:	6878      	ldr	r0, [r7, #4]
 800c730:	f7ff ff9e 	bl	800c670 <stts22h_read_reg>
 800c734:	6178      	str	r0, [r7, #20]
                           (uint8_t *)&software_reset, 1);
  }

  if ((val == STTS22H_ONE_SHOT) && (ret == 0))
 800c736:	78fb      	ldrb	r3, [r7, #3]
 800c738:	2b01      	cmp	r3, #1
 800c73a:	d11d      	bne.n	800c778 <stts22h_temp_data_rate_set+0x74>
 800c73c:	697b      	ldr	r3, [r7, #20]
 800c73e:	2b00      	cmp	r3, #0
 800c740:	d11a      	bne.n	800c778 <stts22h_temp_data_rate_set+0x74>
  {
    software_reset.sw_reset = PROPERTY_ENABLE;
 800c742:	7c3b      	ldrb	r3, [r7, #16]
 800c744:	f043 0302 	orr.w	r3, r3, #2
 800c748:	743b      	strb	r3, [r7, #16]
    ret = stts22h_write_reg(ctx, STTS22H_SOFTWARE_RESET,
 800c74a:	f107 0210 	add.w	r2, r7, #16
 800c74e:	2301      	movs	r3, #1
 800c750:	210c      	movs	r1, #12
 800c752:	6878      	ldr	r0, [r7, #4]
 800c754:	f7ff ffa4 	bl	800c6a0 <stts22h_write_reg>
 800c758:	6178      	str	r0, [r7, #20]
                            (uint8_t *)&software_reset, 1);

    if (ret == 0)
 800c75a:	697b      	ldr	r3, [r7, #20]
 800c75c:	2b00      	cmp	r3, #0
 800c75e:	d10b      	bne.n	800c778 <stts22h_temp_data_rate_set+0x74>
    {
      software_reset.sw_reset = PROPERTY_DISABLE;
 800c760:	7c3b      	ldrb	r3, [r7, #16]
 800c762:	f023 0302 	bic.w	r3, r3, #2
 800c766:	743b      	strb	r3, [r7, #16]
      ret = stts22h_write_reg(ctx, STTS22H_SOFTWARE_RESET,
 800c768:	f107 0210 	add.w	r2, r7, #16
 800c76c:	2301      	movs	r3, #1
 800c76e:	210c      	movs	r1, #12
 800c770:	6878      	ldr	r0, [r7, #4]
 800c772:	f7ff ff95 	bl	800c6a0 <stts22h_write_reg>
 800c776:	6178      	str	r0, [r7, #20]
                              (uint8_t *)&software_reset, 1);
    }
  }

  if (((val == STTS22H_25Hz)  || (val == STTS22H_50Hz)   ||
 800c778:	78fb      	ldrb	r3, [r7, #3]
 800c77a:	2b02      	cmp	r3, #2
 800c77c:	d008      	beq.n	800c790 <stts22h_temp_data_rate_set+0x8c>
 800c77e:	78fb      	ldrb	r3, [r7, #3]
 800c780:	2b12      	cmp	r3, #18
 800c782:	d005      	beq.n	800c790 <stts22h_temp_data_rate_set+0x8c>
 800c784:	78fb      	ldrb	r3, [r7, #3]
 800c786:	2b22      	cmp	r3, #34	@ 0x22
 800c788:	d002      	beq.n	800c790 <stts22h_temp_data_rate_set+0x8c>
       (val == STTS22H_100Hz) || (val == STTS22H_200Hz)) &&
 800c78a:	78fb      	ldrb	r3, [r7, #3]
 800c78c:	2b32      	cmp	r3, #50	@ 0x32
 800c78e:	d123      	bne.n	800c7d8 <stts22h_temp_data_rate_set+0xd4>
      (ctrl.freerun == PROPERTY_DISABLE) && (ret == 0))
 800c790:	7b3b      	ldrb	r3, [r7, #12]
 800c792:	f003 0304 	and.w	r3, r3, #4
 800c796:	b2db      	uxtb	r3, r3
       (val == STTS22H_100Hz) || (val == STTS22H_200Hz)) &&
 800c798:	2b00      	cmp	r3, #0
 800c79a:	d11d      	bne.n	800c7d8 <stts22h_temp_data_rate_set+0xd4>
      (ctrl.freerun == PROPERTY_DISABLE) && (ret == 0))
 800c79c:	697b      	ldr	r3, [r7, #20]
 800c79e:	2b00      	cmp	r3, #0
 800c7a0:	d11a      	bne.n	800c7d8 <stts22h_temp_data_rate_set+0xd4>
  {
    software_reset.sw_reset = PROPERTY_ENABLE;
 800c7a2:	7c3b      	ldrb	r3, [r7, #16]
 800c7a4:	f043 0302 	orr.w	r3, r3, #2
 800c7a8:	743b      	strb	r3, [r7, #16]
    ret = stts22h_write_reg(ctx, STTS22H_SOFTWARE_RESET,
 800c7aa:	f107 0210 	add.w	r2, r7, #16
 800c7ae:	2301      	movs	r3, #1
 800c7b0:	210c      	movs	r1, #12
 800c7b2:	6878      	ldr	r0, [r7, #4]
 800c7b4:	f7ff ff74 	bl	800c6a0 <stts22h_write_reg>
 800c7b8:	6178      	str	r0, [r7, #20]
                            (uint8_t *)&software_reset, 1);

    if (ret == 0)
 800c7ba:	697b      	ldr	r3, [r7, #20]
 800c7bc:	2b00      	cmp	r3, #0
 800c7be:	d10b      	bne.n	800c7d8 <stts22h_temp_data_rate_set+0xd4>
    {
      software_reset.sw_reset = PROPERTY_DISABLE;
 800c7c0:	7c3b      	ldrb	r3, [r7, #16]
 800c7c2:	f023 0302 	bic.w	r3, r3, #2
 800c7c6:	743b      	strb	r3, [r7, #16]
      ret = stts22h_write_reg(ctx, STTS22H_SOFTWARE_RESET,
 800c7c8:	f107 0210 	add.w	r2, r7, #16
 800c7cc:	2301      	movs	r3, #1
 800c7ce:	210c      	movs	r1, #12
 800c7d0:	6878      	ldr	r0, [r7, #4]
 800c7d2:	f7ff ff65 	bl	800c6a0 <stts22h_write_reg>
 800c7d6:	6178      	str	r0, [r7, #20]
                              (uint8_t *)&software_reset, 1);
    }
  }

  if ((val == STTS22H_1Hz) && (ret == 0))
 800c7d8:	78fb      	ldrb	r3, [r7, #3]
 800c7da:	2b04      	cmp	r3, #4
 800c7dc:	d125      	bne.n	800c82a <stts22h_temp_data_rate_set+0x126>
 800c7de:	697b      	ldr	r3, [r7, #20]
 800c7e0:	2b00      	cmp	r3, #0
 800c7e2:	d122      	bne.n	800c82a <stts22h_temp_data_rate_set+0x126>
  {
    software_reset.sw_reset = PROPERTY_ENABLE;
 800c7e4:	7c3b      	ldrb	r3, [r7, #16]
 800c7e6:	f043 0302 	orr.w	r3, r3, #2
 800c7ea:	743b      	strb	r3, [r7, #16]
    software_reset.low_odr_enable = PROPERTY_ENABLE;
 800c7ec:	7c3b      	ldrb	r3, [r7, #16]
 800c7ee:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 800c7f2:	743b      	strb	r3, [r7, #16]
    ret = stts22h_write_reg(ctx, STTS22H_SOFTWARE_RESET,
 800c7f4:	f107 0210 	add.w	r2, r7, #16
 800c7f8:	2301      	movs	r3, #1
 800c7fa:	210c      	movs	r1, #12
 800c7fc:	6878      	ldr	r0, [r7, #4]
 800c7fe:	f7ff ff4f 	bl	800c6a0 <stts22h_write_reg>
 800c802:	6178      	str	r0, [r7, #20]
                            (uint8_t *)&software_reset, 1);

    if (ret == 0)
 800c804:	697b      	ldr	r3, [r7, #20]
 800c806:	2b00      	cmp	r3, #0
 800c808:	d10f      	bne.n	800c82a <stts22h_temp_data_rate_set+0x126>
    {
      software_reset.sw_reset = PROPERTY_DISABLE;
 800c80a:	7c3b      	ldrb	r3, [r7, #16]
 800c80c:	f023 0302 	bic.w	r3, r3, #2
 800c810:	743b      	strb	r3, [r7, #16]
      software_reset.low_odr_enable = PROPERTY_ENABLE;
 800c812:	7c3b      	ldrb	r3, [r7, #16]
 800c814:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 800c818:	743b      	strb	r3, [r7, #16]
      ret = stts22h_write_reg(ctx, STTS22H_SOFTWARE_RESET,
 800c81a:	f107 0210 	add.w	r2, r7, #16
 800c81e:	2301      	movs	r3, #1
 800c820:	210c      	movs	r1, #12
 800c822:	6878      	ldr	r0, [r7, #4]
 800c824:	f7ff ff3c 	bl	800c6a0 <stts22h_write_reg>
 800c828:	6178      	str	r0, [r7, #20]
                              (uint8_t *)&software_reset, 1);
    }
  }

  if (ret == 0)
 800c82a:	697b      	ldr	r3, [r7, #20]
 800c82c:	2b00      	cmp	r3, #0
 800c82e:	d12a      	bne.n	800c886 <stts22h_temp_data_rate_set+0x182>
  {
    ctrl.one_shot = (uint8_t)val & 0x01U;
 800c830:	78fb      	ldrb	r3, [r7, #3]
 800c832:	f003 0301 	and.w	r3, r3, #1
 800c836:	b2da      	uxtb	r2, r3
 800c838:	7b3b      	ldrb	r3, [r7, #12]
 800c83a:	f362 0300 	bfi	r3, r2, #0, #1
 800c83e:	733b      	strb	r3, [r7, #12]
    ctrl.freerun = ((uint8_t)val & 0x02U) >> 1;
 800c840:	78fb      	ldrb	r3, [r7, #3]
 800c842:	085b      	lsrs	r3, r3, #1
 800c844:	f003 0301 	and.w	r3, r3, #1
 800c848:	b2da      	uxtb	r2, r3
 800c84a:	7b3b      	ldrb	r3, [r7, #12]
 800c84c:	f362 0382 	bfi	r3, r2, #2, #1
 800c850:	733b      	strb	r3, [r7, #12]
    ctrl.low_odr_start = ((uint8_t)val & 0x04U) >> 2;
 800c852:	78fb      	ldrb	r3, [r7, #3]
 800c854:	089b      	lsrs	r3, r3, #2
 800c856:	f003 0301 	and.w	r3, r3, #1
 800c85a:	b2da      	uxtb	r2, r3
 800c85c:	7b3b      	ldrb	r3, [r7, #12]
 800c85e:	f362 13c7 	bfi	r3, r2, #7, #1
 800c862:	733b      	strb	r3, [r7, #12]
    ctrl.avg = ((uint8_t)val & 0x30U) >> 4;
 800c864:	78fb      	ldrb	r3, [r7, #3]
 800c866:	091b      	lsrs	r3, r3, #4
 800c868:	f003 0303 	and.w	r3, r3, #3
 800c86c:	b2da      	uxtb	r2, r3
 800c86e:	7b3b      	ldrb	r3, [r7, #12]
 800c870:	f362 1305 	bfi	r3, r2, #4, #2
 800c874:	733b      	strb	r3, [r7, #12]
    ret = stts22h_write_reg(ctx, STTS22H_CTRL, (uint8_t *)&ctrl, 1);
 800c876:	f107 020c 	add.w	r2, r7, #12
 800c87a:	2301      	movs	r3, #1
 800c87c:	2104      	movs	r1, #4
 800c87e:	6878      	ldr	r0, [r7, #4]
 800c880:	f7ff ff0e 	bl	800c6a0 <stts22h_write_reg>
 800c884:	6178      	str	r0, [r7, #20]
  }

  return ret;
 800c886:	697b      	ldr	r3, [r7, #20]
}
 800c888:	4618      	mov	r0, r3
 800c88a:	3718      	adds	r7, #24
 800c88c:	46bd      	mov	sp, r7
 800c88e:	bd80      	pop	{r7, pc}

0800c890 <stts22h_temp_data_rate_get>:
  * @retval        Interface status (MANDATORY: return 0 -> no Error).
  *
  */
int32_t stts22h_temp_data_rate_get(stmdev_ctx_t *ctx,
                                   stts22h_odr_temp_t *val)
{
 800c890:	b580      	push	{r7, lr}
 800c892:	b084      	sub	sp, #16
 800c894:	af00      	add	r7, sp, #0
 800c896:	6078      	str	r0, [r7, #4]
 800c898:	6039      	str	r1, [r7, #0]
  stts22h_ctrl_t ctrl;
  int32_t ret;

  ret = stts22h_read_reg(ctx, STTS22H_CTRL,
 800c89a:	f107 0208 	add.w	r2, r7, #8
 800c89e:	2301      	movs	r3, #1
 800c8a0:	2104      	movs	r1, #4
 800c8a2:	6878      	ldr	r0, [r7, #4]
 800c8a4:	f7ff fee4 	bl	800c670 <stts22h_read_reg>
 800c8a8:	60f8      	str	r0, [r7, #12]
                         (uint8_t *)&ctrl, 1);

  switch (ctrl.one_shot | (ctrl.freerun << 1) | (ctrl.low_odr_start <<
 800c8aa:	7a3b      	ldrb	r3, [r7, #8]
 800c8ac:	f3c3 0300 	ubfx	r3, r3, #0, #1
 800c8b0:	b2db      	uxtb	r3, r3
 800c8b2:	461a      	mov	r2, r3
 800c8b4:	7a3b      	ldrb	r3, [r7, #8]
 800c8b6:	f3c3 0380 	ubfx	r3, r3, #2, #1
 800c8ba:	b2db      	uxtb	r3, r3
 800c8bc:	005b      	lsls	r3, r3, #1
 800c8be:	431a      	orrs	r2, r3
 800c8c0:	7a3b      	ldrb	r3, [r7, #8]
 800c8c2:	f3c3 13c0 	ubfx	r3, r3, #7, #1
 800c8c6:	b2db      	uxtb	r3, r3
 800c8c8:	009b      	lsls	r3, r3, #2
 800c8ca:	431a      	orrs	r2, r3
                                                 2) |
          (ctrl.avg << 4))
 800c8cc:	7a3b      	ldrb	r3, [r7, #8]
 800c8ce:	f3c3 1301 	ubfx	r3, r3, #4, #2
 800c8d2:	b2db      	uxtb	r3, r3
 800c8d4:	011b      	lsls	r3, r3, #4
                                                 2) |
 800c8d6:	4313      	orrs	r3, r2
  switch (ctrl.one_shot | (ctrl.freerun << 1) | (ctrl.low_odr_start <<
 800c8d8:	2b32      	cmp	r3, #50	@ 0x32
 800c8da:	f200 8085 	bhi.w	800c9e8 <stts22h_temp_data_rate_get+0x158>
 800c8de:	a201      	add	r2, pc, #4	@ (adr r2, 800c8e4 <stts22h_temp_data_rate_get+0x54>)
 800c8e0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800c8e4:	0800c9b1 	.word	0x0800c9b1
 800c8e8:	0800c9b9 	.word	0x0800c9b9
 800c8ec:	0800c9c9 	.word	0x0800c9c9
 800c8f0:	0800c9e9 	.word	0x0800c9e9
 800c8f4:	0800c9c1 	.word	0x0800c9c1
 800c8f8:	0800c9e9 	.word	0x0800c9e9
 800c8fc:	0800c9e9 	.word	0x0800c9e9
 800c900:	0800c9e9 	.word	0x0800c9e9
 800c904:	0800c9e9 	.word	0x0800c9e9
 800c908:	0800c9e9 	.word	0x0800c9e9
 800c90c:	0800c9e9 	.word	0x0800c9e9
 800c910:	0800c9e9 	.word	0x0800c9e9
 800c914:	0800c9e9 	.word	0x0800c9e9
 800c918:	0800c9e9 	.word	0x0800c9e9
 800c91c:	0800c9e9 	.word	0x0800c9e9
 800c920:	0800c9e9 	.word	0x0800c9e9
 800c924:	0800c9e9 	.word	0x0800c9e9
 800c928:	0800c9e9 	.word	0x0800c9e9
 800c92c:	0800c9d1 	.word	0x0800c9d1
 800c930:	0800c9e9 	.word	0x0800c9e9
 800c934:	0800c9e9 	.word	0x0800c9e9
 800c938:	0800c9e9 	.word	0x0800c9e9
 800c93c:	0800c9e9 	.word	0x0800c9e9
 800c940:	0800c9e9 	.word	0x0800c9e9
 800c944:	0800c9e9 	.word	0x0800c9e9
 800c948:	0800c9e9 	.word	0x0800c9e9
 800c94c:	0800c9e9 	.word	0x0800c9e9
 800c950:	0800c9e9 	.word	0x0800c9e9
 800c954:	0800c9e9 	.word	0x0800c9e9
 800c958:	0800c9e9 	.word	0x0800c9e9
 800c95c:	0800c9e9 	.word	0x0800c9e9
 800c960:	0800c9e9 	.word	0x0800c9e9
 800c964:	0800c9e9 	.word	0x0800c9e9
 800c968:	0800c9e9 	.word	0x0800c9e9
 800c96c:	0800c9d9 	.word	0x0800c9d9
 800c970:	0800c9e9 	.word	0x0800c9e9
 800c974:	0800c9e9 	.word	0x0800c9e9
 800c978:	0800c9e9 	.word	0x0800c9e9
 800c97c:	0800c9e9 	.word	0x0800c9e9
 800c980:	0800c9e9 	.word	0x0800c9e9
 800c984:	0800c9e9 	.word	0x0800c9e9
 800c988:	0800c9e9 	.word	0x0800c9e9
 800c98c:	0800c9e9 	.word	0x0800c9e9
 800c990:	0800c9e9 	.word	0x0800c9e9
 800c994:	0800c9e9 	.word	0x0800c9e9
 800c998:	0800c9e9 	.word	0x0800c9e9
 800c99c:	0800c9e9 	.word	0x0800c9e9
 800c9a0:	0800c9e9 	.word	0x0800c9e9
 800c9a4:	0800c9e9 	.word	0x0800c9e9
 800c9a8:	0800c9e9 	.word	0x0800c9e9
 800c9ac:	0800c9e1 	.word	0x0800c9e1
  {
    case STTS22H_POWER_DOWN:
      *val = STTS22H_POWER_DOWN;
 800c9b0:	683b      	ldr	r3, [r7, #0]
 800c9b2:	2200      	movs	r2, #0
 800c9b4:	701a      	strb	r2, [r3, #0]
      break;
 800c9b6:	e01b      	b.n	800c9f0 <stts22h_temp_data_rate_get+0x160>

    case STTS22H_ONE_SHOT:
      *val = STTS22H_ONE_SHOT;
 800c9b8:	683b      	ldr	r3, [r7, #0]
 800c9ba:	2201      	movs	r2, #1
 800c9bc:	701a      	strb	r2, [r3, #0]
      break;
 800c9be:	e017      	b.n	800c9f0 <stts22h_temp_data_rate_get+0x160>

    case STTS22H_1Hz:
      *val = STTS22H_1Hz;
 800c9c0:	683b      	ldr	r3, [r7, #0]
 800c9c2:	2204      	movs	r2, #4
 800c9c4:	701a      	strb	r2, [r3, #0]
      break;
 800c9c6:	e013      	b.n	800c9f0 <stts22h_temp_data_rate_get+0x160>

    case STTS22H_25Hz:
      *val = STTS22H_25Hz;
 800c9c8:	683b      	ldr	r3, [r7, #0]
 800c9ca:	2202      	movs	r2, #2
 800c9cc:	701a      	strb	r2, [r3, #0]
      break;
 800c9ce:	e00f      	b.n	800c9f0 <stts22h_temp_data_rate_get+0x160>

    case STTS22H_50Hz:
      *val = STTS22H_50Hz;
 800c9d0:	683b      	ldr	r3, [r7, #0]
 800c9d2:	2212      	movs	r2, #18
 800c9d4:	701a      	strb	r2, [r3, #0]
      break;
 800c9d6:	e00b      	b.n	800c9f0 <stts22h_temp_data_rate_get+0x160>

    case STTS22H_100Hz:
      *val = STTS22H_100Hz;
 800c9d8:	683b      	ldr	r3, [r7, #0]
 800c9da:	2222      	movs	r2, #34	@ 0x22
 800c9dc:	701a      	strb	r2, [r3, #0]
      break;
 800c9de:	e007      	b.n	800c9f0 <stts22h_temp_data_rate_get+0x160>

    case STTS22H_200Hz:
      *val = STTS22H_200Hz;
 800c9e0:	683b      	ldr	r3, [r7, #0]
 800c9e2:	2232      	movs	r2, #50	@ 0x32
 800c9e4:	701a      	strb	r2, [r3, #0]
      break;
 800c9e6:	e003      	b.n	800c9f0 <stts22h_temp_data_rate_get+0x160>

    default:
      *val = STTS22H_POWER_DOWN;
 800c9e8:	683b      	ldr	r3, [r7, #0]
 800c9ea:	2200      	movs	r2, #0
 800c9ec:	701a      	strb	r2, [r3, #0]
      break;
 800c9ee:	bf00      	nop
  }

  return ret;
 800c9f0:	68fb      	ldr	r3, [r7, #12]
}
 800c9f2:	4618      	mov	r0, r3
 800c9f4:	3710      	adds	r7, #16
 800c9f6:	46bd      	mov	sp, r7
 800c9f8:	bd80      	pop	{r7, pc}
 800c9fa:	bf00      	nop

0800c9fc <stts22h_block_data_update_set>:
  * @param  val    Change the values of bdu in reg CTRL.
  * @retval        Interface status (MANDATORY: return 0 -> no Error).
  *
  */
int32_t stts22h_block_data_update_set(stmdev_ctx_t *ctx, uint8_t val)
{
 800c9fc:	b580      	push	{r7, lr}
 800c9fe:	b084      	sub	sp, #16
 800ca00:	af00      	add	r7, sp, #0
 800ca02:	6078      	str	r0, [r7, #4]
 800ca04:	460b      	mov	r3, r1
 800ca06:	70fb      	strb	r3, [r7, #3]
  stts22h_ctrl_t ctrl;
  int32_t ret;

  ret = stts22h_read_reg(ctx, STTS22H_CTRL, (uint8_t *)&ctrl, 1);
 800ca08:	f107 0208 	add.w	r2, r7, #8
 800ca0c:	2301      	movs	r3, #1
 800ca0e:	2104      	movs	r1, #4
 800ca10:	6878      	ldr	r0, [r7, #4]
 800ca12:	f7ff fe2d 	bl	800c670 <stts22h_read_reg>
 800ca16:	60f8      	str	r0, [r7, #12]

  if (ret == 0)
 800ca18:	68fb      	ldr	r3, [r7, #12]
 800ca1a:	2b00      	cmp	r3, #0
 800ca1c:	d10f      	bne.n	800ca3e <stts22h_block_data_update_set+0x42>
  {
    ctrl.bdu = val;
 800ca1e:	78fb      	ldrb	r3, [r7, #3]
 800ca20:	f003 0301 	and.w	r3, r3, #1
 800ca24:	b2da      	uxtb	r2, r3
 800ca26:	7a3b      	ldrb	r3, [r7, #8]
 800ca28:	f362 1386 	bfi	r3, r2, #6, #1
 800ca2c:	723b      	strb	r3, [r7, #8]
    ret = stts22h_write_reg(ctx, STTS22H_CTRL, (uint8_t *)&ctrl, 1);
 800ca2e:	f107 0208 	add.w	r2, r7, #8
 800ca32:	2301      	movs	r3, #1
 800ca34:	2104      	movs	r1, #4
 800ca36:	6878      	ldr	r0, [r7, #4]
 800ca38:	f7ff fe32 	bl	800c6a0 <stts22h_write_reg>
 800ca3c:	60f8      	str	r0, [r7, #12]
  }

  return ret;
 800ca3e:	68fb      	ldr	r3, [r7, #12]
}
 800ca40:	4618      	mov	r0, r3
 800ca42:	3710      	adds	r7, #16
 800ca44:	46bd      	mov	sp, r7
 800ca46:	bd80      	pop	{r7, pc}

0800ca48 <stts22h_temperature_raw_get>:
  * @param  buff   Buffer that stores the data read.(ptr)
  * @retval        Interface status (MANDATORY: return 0 -> no Error).
  *
  */
int32_t stts22h_temperature_raw_get(stmdev_ctx_t *ctx, int16_t *val)
{
 800ca48:	b580      	push	{r7, lr}
 800ca4a:	b084      	sub	sp, #16
 800ca4c:	af00      	add	r7, sp, #0
 800ca4e:	6078      	str	r0, [r7, #4]
 800ca50:	6039      	str	r1, [r7, #0]
  uint8_t buff[2];
  int32_t ret;

  ret = stts22h_read_reg(ctx, STTS22H_TEMP_L_OUT, buff, 2);
 800ca52:	f107 0208 	add.w	r2, r7, #8
 800ca56:	2302      	movs	r3, #2
 800ca58:	2106      	movs	r1, #6
 800ca5a:	6878      	ldr	r0, [r7, #4]
 800ca5c:	f7ff fe08 	bl	800c670 <stts22h_read_reg>
 800ca60:	60f8      	str	r0, [r7, #12]
  *val = (int16_t)buff[1];
 800ca62:	7a7b      	ldrb	r3, [r7, #9]
 800ca64:	b21a      	sxth	r2, r3
 800ca66:	683b      	ldr	r3, [r7, #0]
 800ca68:	801a      	strh	r2, [r3, #0]
  *val = (*val * 256) + (int16_t)buff[0];
 800ca6a:	683b      	ldr	r3, [r7, #0]
 800ca6c:	f9b3 3000 	ldrsh.w	r3, [r3]
 800ca70:	b29b      	uxth	r3, r3
 800ca72:	021b      	lsls	r3, r3, #8
 800ca74:	b29b      	uxth	r3, r3
 800ca76:	7a3a      	ldrb	r2, [r7, #8]
 800ca78:	4413      	add	r3, r2
 800ca7a:	b29b      	uxth	r3, r3
 800ca7c:	b21a      	sxth	r2, r3
 800ca7e:	683b      	ldr	r3, [r7, #0]
 800ca80:	801a      	strh	r2, [r3, #0]

  return ret;
 800ca82:	68fb      	ldr	r3, [r7, #12]
}
 800ca84:	4618      	mov	r0, r3
 800ca86:	3710      	adds	r7, #16
 800ca88:	46bd      	mov	sp, r7
 800ca8a:	bd80      	pop	{r7, pc}

0800ca8c <stts22h_dev_id_get>:
  * @param  buff   Buffer that stores the data read.(ptr)
  * @retval        Interface status (MANDATORY: return 0 -> no Error).
  *
  */
int32_t stts22h_dev_id_get(stmdev_ctx_t *ctx, uint8_t *buff)
{
 800ca8c:	b580      	push	{r7, lr}
 800ca8e:	b084      	sub	sp, #16
 800ca90:	af00      	add	r7, sp, #0
 800ca92:	6078      	str	r0, [r7, #4]
 800ca94:	6039      	str	r1, [r7, #0]
  int32_t ret;

  ret = stts22h_read_reg(ctx, STTS22H_WHOAMI, buff, 1);
 800ca96:	2301      	movs	r3, #1
 800ca98:	683a      	ldr	r2, [r7, #0]
 800ca9a:	2101      	movs	r1, #1
 800ca9c:	6878      	ldr	r0, [r7, #4]
 800ca9e:	f7ff fde7 	bl	800c670 <stts22h_read_reg>
 800caa2:	60f8      	str	r0, [r7, #12]

  return ret;
 800caa4:	68fb      	ldr	r3, [r7, #12]
}
 800caa6:	4618      	mov	r0, r3
 800caa8:	3710      	adds	r7, #16
 800caaa:	46bd      	mov	sp, r7
 800caac:	bd80      	pop	{r7, pc}

0800caae <stts22h_auto_increment_set>:
  * @param  val    Change the values of "if_add_inc" in reg STTS22H.
  * @retval        Interface status (MANDATORY: return 0 -> no Error).
  *
  */
int32_t stts22h_auto_increment_set(stmdev_ctx_t *ctx, uint8_t val)
{
 800caae:	b580      	push	{r7, lr}
 800cab0:	b084      	sub	sp, #16
 800cab2:	af00      	add	r7, sp, #0
 800cab4:	6078      	str	r0, [r7, #4]
 800cab6:	460b      	mov	r3, r1
 800cab8:	70fb      	strb	r3, [r7, #3]
  stts22h_ctrl_t ctrl;
  int32_t ret;

  ret = stts22h_read_reg(ctx, STTS22H_CTRL, (uint8_t *)&ctrl, 1);
 800caba:	f107 0208 	add.w	r2, r7, #8
 800cabe:	2301      	movs	r3, #1
 800cac0:	2104      	movs	r1, #4
 800cac2:	6878      	ldr	r0, [r7, #4]
 800cac4:	f7ff fdd4 	bl	800c670 <stts22h_read_reg>
 800cac8:	60f8      	str	r0, [r7, #12]

  if (ret == 0)
 800caca:	68fb      	ldr	r3, [r7, #12]
 800cacc:	2b00      	cmp	r3, #0
 800cace:	d10f      	bne.n	800caf0 <stts22h_auto_increment_set+0x42>
  {
    ctrl.if_add_inc = (uint8_t)val;
 800cad0:	78fb      	ldrb	r3, [r7, #3]
 800cad2:	f003 0301 	and.w	r3, r3, #1
 800cad6:	b2da      	uxtb	r2, r3
 800cad8:	7a3b      	ldrb	r3, [r7, #8]
 800cada:	f362 03c3 	bfi	r3, r2, #3, #1
 800cade:	723b      	strb	r3, [r7, #8]
    ret = stts22h_write_reg(ctx, STTS22H_CTRL, (uint8_t *)&ctrl, 1);
 800cae0:	f107 0208 	add.w	r2, r7, #8
 800cae4:	2301      	movs	r3, #1
 800cae6:	2104      	movs	r1, #4
 800cae8:	6878      	ldr	r0, [r7, #4]
 800caea:	f7ff fdd9 	bl	800c6a0 <stts22h_write_reg>
 800caee:	60f8      	str	r0, [r7, #12]
  }

  return ret;
 800caf0:	68fb      	ldr	r3, [r7, #12]
}
 800caf2:	4618      	mov	r0, r3
 800caf4:	3710      	adds	r7, #16
 800caf6:	46bd      	mov	sp, r7
 800caf8:	bd80      	pop	{r7, pc}
	...

0800cafc <BSP_ENV_SENSOR_Init>:
  *         - ENV_TEMPERATURE
  *         - ENV_PRESSURE
  * @retval BSP status
  */
int32_t BSP_ENV_SENSOR_Init(uint32_t Instance, uint32_t Functions)
{
 800cafc:	b580      	push	{r7, lr}
 800cafe:	b08a      	sub	sp, #40	@ 0x28
 800cb00:	af00      	add	r7, sp, #0
 800cb02:	6078      	str	r0, [r7, #4]
 800cb04:	6039      	str	r1, [r7, #0]
  int32_t ret = BSP_ERROR_NONE;
 800cb06:	2300      	movs	r3, #0
 800cb08:	627b      	str	r3, [r7, #36]	@ 0x24
  uint32_t function = ENV_TEMPERATURE;
 800cb0a:	2301      	movs	r3, #1
 800cb0c:	623b      	str	r3, [r7, #32]
  uint32_t i;
  uint32_t component_functions = 0;
 800cb0e:	2300      	movs	r3, #0
 800cb10:	61bb      	str	r3, [r7, #24]
  BSP_ENV_SENSOR_Capabilities_t cap;

  switch (Instance)
 800cb12:	687b      	ldr	r3, [r7, #4]
 800cb14:	2b00      	cmp	r3, #0
 800cb16:	d003      	beq.n	800cb20 <BSP_ENV_SENSOR_Init+0x24>
 800cb18:	687b      	ldr	r3, [r7, #4]
 800cb1a:	2b01      	cmp	r3, #1
 800cb1c:	d02b      	beq.n	800cb76 <BSP_ENV_SENSOR_Init+0x7a>
 800cb1e:	e055      	b.n	800cbcc <BSP_ENV_SENSOR_Init+0xd0>
  {
#if (USE_ENV_SENSOR_STTS22H_0 == 1)
    case STTS22H_0:
      if (STTS22H_0_Probe(Functions) != BSP_ERROR_NONE)
 800cb20:	6838      	ldr	r0, [r7, #0]
 800cb22:	f000 f91f 	bl	800cd64 <STTS22H_0_Probe>
 800cb26:	4603      	mov	r3, r0
 800cb28:	2b00      	cmp	r3, #0
 800cb2a:	d002      	beq.n	800cb32 <BSP_ENV_SENSOR_Init+0x36>
      {
        return BSP_ERROR_NO_INIT;
 800cb2c:	f04f 33ff 	mov.w	r3, #4294967295
 800cb30:	e088      	b.n	800cc44 <BSP_ENV_SENSOR_Init+0x148>
      }
      if (EnvDrv[Instance]->GetCapabilities(EnvCompObj[Instance], (void *)&cap) != BSP_ERROR_NONE)
 800cb32:	4a46      	ldr	r2, [pc, #280]	@ (800cc4c <BSP_ENV_SENSOR_Init+0x150>)
 800cb34:	687b      	ldr	r3, [r7, #4]
 800cb36:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800cb3a:	68db      	ldr	r3, [r3, #12]
 800cb3c:	4944      	ldr	r1, [pc, #272]	@ (800cc50 <BSP_ENV_SENSOR_Init+0x154>)
 800cb3e:	687a      	ldr	r2, [r7, #4]
 800cb40:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 800cb44:	f107 0108 	add.w	r1, r7, #8
 800cb48:	4610      	mov	r0, r2
 800cb4a:	4798      	blx	r3
 800cb4c:	4603      	mov	r3, r0
 800cb4e:	2b00      	cmp	r3, #0
 800cb50:	d002      	beq.n	800cb58 <BSP_ENV_SENSOR_Init+0x5c>
      {
        return BSP_ERROR_UNKNOWN_COMPONENT;
 800cb52:	f06f 0306 	mvn.w	r3, #6
 800cb56:	e075      	b.n	800cc44 <BSP_ENV_SENSOR_Init+0x148>
      }
      if (cap.Temperature == 1U)
 800cb58:	7a3b      	ldrb	r3, [r7, #8]
 800cb5a:	2b01      	cmp	r3, #1
 800cb5c:	d103      	bne.n	800cb66 <BSP_ENV_SENSOR_Init+0x6a>
      {
        component_functions |= ENV_TEMPERATURE;
 800cb5e:	69bb      	ldr	r3, [r7, #24]
 800cb60:	f043 0301 	orr.w	r3, r3, #1
 800cb64:	61bb      	str	r3, [r7, #24]
      }
      if (cap.Pressure == 1U)
 800cb66:	7a7b      	ldrb	r3, [r7, #9]
 800cb68:	2b01      	cmp	r3, #1
 800cb6a:	d133      	bne.n	800cbd4 <BSP_ENV_SENSOR_Init+0xd8>
      {
        component_functions |= ENV_PRESSURE;
 800cb6c:	69bb      	ldr	r3, [r7, #24]
 800cb6e:	f043 0302 	orr.w	r3, r3, #2
 800cb72:	61bb      	str	r3, [r7, #24]
      }
      break;
 800cb74:	e02e      	b.n	800cbd4 <BSP_ENV_SENSOR_Init+0xd8>
#endif /* USE_ENV_SENSOR_STTS22H_0 == 1 */
#if (USE_ENV_SENSOR_LPS22DF_0 == 1)
    case LPS22DF_0:
      if (LPS22DF_0_Probe(Functions) != BSP_ERROR_NONE)
 800cb76:	6838      	ldr	r0, [r7, #0]
 800cb78:	f000 f98c 	bl	800ce94 <LPS22DF_0_Probe>
 800cb7c:	4603      	mov	r3, r0
 800cb7e:	2b00      	cmp	r3, #0
 800cb80:	d002      	beq.n	800cb88 <BSP_ENV_SENSOR_Init+0x8c>
      {
        return BSP_ERROR_NO_INIT;
 800cb82:	f04f 33ff 	mov.w	r3, #4294967295
 800cb86:	e05d      	b.n	800cc44 <BSP_ENV_SENSOR_Init+0x148>
      }
      if (EnvDrv[Instance]->GetCapabilities(EnvCompObj[Instance], (void *)&cap) != BSP_ERROR_NONE)
 800cb88:	4a30      	ldr	r2, [pc, #192]	@ (800cc4c <BSP_ENV_SENSOR_Init+0x150>)
 800cb8a:	687b      	ldr	r3, [r7, #4]
 800cb8c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800cb90:	68db      	ldr	r3, [r3, #12]
 800cb92:	492f      	ldr	r1, [pc, #188]	@ (800cc50 <BSP_ENV_SENSOR_Init+0x154>)
 800cb94:	687a      	ldr	r2, [r7, #4]
 800cb96:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 800cb9a:	f107 0108 	add.w	r1, r7, #8
 800cb9e:	4610      	mov	r0, r2
 800cba0:	4798      	blx	r3
 800cba2:	4603      	mov	r3, r0
 800cba4:	2b00      	cmp	r3, #0
 800cba6:	d002      	beq.n	800cbae <BSP_ENV_SENSOR_Init+0xb2>
      {
        return BSP_ERROR_UNKNOWN_COMPONENT;
 800cba8:	f06f 0306 	mvn.w	r3, #6
 800cbac:	e04a      	b.n	800cc44 <BSP_ENV_SENSOR_Init+0x148>
      }
      if (cap.Temperature == 1U)
 800cbae:	7a3b      	ldrb	r3, [r7, #8]
 800cbb0:	2b01      	cmp	r3, #1
 800cbb2:	d103      	bne.n	800cbbc <BSP_ENV_SENSOR_Init+0xc0>
      {
        component_functions |= ENV_TEMPERATURE;
 800cbb4:	69bb      	ldr	r3, [r7, #24]
 800cbb6:	f043 0301 	orr.w	r3, r3, #1
 800cbba:	61bb      	str	r3, [r7, #24]
      }
      if (cap.Pressure == 1U)
 800cbbc:	7a7b      	ldrb	r3, [r7, #9]
 800cbbe:	2b01      	cmp	r3, #1
 800cbc0:	d10a      	bne.n	800cbd8 <BSP_ENV_SENSOR_Init+0xdc>
      {
        component_functions |= ENV_PRESSURE;
 800cbc2:	69bb      	ldr	r3, [r7, #24]
 800cbc4:	f043 0302 	orr.w	r3, r3, #2
 800cbc8:	61bb      	str	r3, [r7, #24]
      }
      break;
 800cbca:	e005      	b.n	800cbd8 <BSP_ENV_SENSOR_Init+0xdc>
#endif /* USE_ENV_SENSOR_LPS22DF_0 == 1 */
    default:
      ret = BSP_ERROR_WRONG_PARAM;
 800cbcc:	f06f 0301 	mvn.w	r3, #1
 800cbd0:	627b      	str	r3, [r7, #36]	@ 0x24
      break;
 800cbd2:	e002      	b.n	800cbda <BSP_ENV_SENSOR_Init+0xde>
      break;
 800cbd4:	bf00      	nop
 800cbd6:	e000      	b.n	800cbda <BSP_ENV_SENSOR_Init+0xde>
      break;
 800cbd8:	bf00      	nop
  }

  if (ret != BSP_ERROR_NONE)
 800cbda:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800cbdc:	2b00      	cmp	r3, #0
 800cbde:	d001      	beq.n	800cbe4 <BSP_ENV_SENSOR_Init+0xe8>
  {
    return ret;
 800cbe0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800cbe2:	e02f      	b.n	800cc44 <BSP_ENV_SENSOR_Init+0x148>
  }

  for (i = 0; i < BSP_ENV_FUNCTIONS_NBR; i++)
 800cbe4:	2300      	movs	r3, #0
 800cbe6:	61fb      	str	r3, [r7, #28]
 800cbe8:	e028      	b.n	800cc3c <BSP_ENV_SENSOR_Init+0x140>
  {
    if (((Functions & function) == function) && ((component_functions & function) == function))
 800cbea:	683a      	ldr	r2, [r7, #0]
 800cbec:	6a3b      	ldr	r3, [r7, #32]
 800cbee:	4013      	ands	r3, r2
 800cbf0:	6a3a      	ldr	r2, [r7, #32]
 800cbf2:	429a      	cmp	r2, r3
 800cbf4:	d11c      	bne.n	800cc30 <BSP_ENV_SENSOR_Init+0x134>
 800cbf6:	69ba      	ldr	r2, [r7, #24]
 800cbf8:	6a3b      	ldr	r3, [r7, #32]
 800cbfa:	4013      	ands	r3, r2
 800cbfc:	6a3a      	ldr	r2, [r7, #32]
 800cbfe:	429a      	cmp	r2, r3
 800cc00:	d116      	bne.n	800cc30 <BSP_ENV_SENSOR_Init+0x134>
    {
      if (EnvFuncDrv[Instance][FunctionIndex[function]]->Enable(EnvCompObj[Instance]) != BSP_ERROR_NONE)
 800cc02:	4a14      	ldr	r2, [pc, #80]	@ (800cc54 <BSP_ENV_SENSOR_Init+0x158>)
 800cc04:	6a3b      	ldr	r3, [r7, #32]
 800cc06:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800cc0a:	4913      	ldr	r1, [pc, #76]	@ (800cc58 <BSP_ENV_SENSOR_Init+0x15c>)
 800cc0c:	687a      	ldr	r2, [r7, #4]
 800cc0e:	0052      	lsls	r2, r2, #1
 800cc10:	4413      	add	r3, r2
 800cc12:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800cc16:	681b      	ldr	r3, [r3, #0]
 800cc18:	490d      	ldr	r1, [pc, #52]	@ (800cc50 <BSP_ENV_SENSOR_Init+0x154>)
 800cc1a:	687a      	ldr	r2, [r7, #4]
 800cc1c:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 800cc20:	4610      	mov	r0, r2
 800cc22:	4798      	blx	r3
 800cc24:	4603      	mov	r3, r0
 800cc26:	2b00      	cmp	r3, #0
 800cc28:	d002      	beq.n	800cc30 <BSP_ENV_SENSOR_Init+0x134>
      {
        return BSP_ERROR_COMPONENT_FAILURE;
 800cc2a:	f06f 0304 	mvn.w	r3, #4
 800cc2e:	e009      	b.n	800cc44 <BSP_ENV_SENSOR_Init+0x148>
      }
    }
    function = function << 1;
 800cc30:	6a3b      	ldr	r3, [r7, #32]
 800cc32:	005b      	lsls	r3, r3, #1
 800cc34:	623b      	str	r3, [r7, #32]
  for (i = 0; i < BSP_ENV_FUNCTIONS_NBR; i++)
 800cc36:	69fb      	ldr	r3, [r7, #28]
 800cc38:	3301      	adds	r3, #1
 800cc3a:	61fb      	str	r3, [r7, #28]
 800cc3c:	69fb      	ldr	r3, [r7, #28]
 800cc3e:	2b01      	cmp	r3, #1
 800cc40:	d9d3      	bls.n	800cbea <BSP_ENV_SENSOR_Init+0xee>
  }

  return ret;
 800cc42:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 800cc44:	4618      	mov	r0, r3
 800cc46:	3728      	adds	r7, #40	@ 0x28
 800cc48:	46bd      	mov	sp, r7
 800cc4a:	bd80      	pop	{r7, pc}
 800cc4c:	20000be0 	.word	0x20000be0
 800cc50:	20000bc8 	.word	0x20000bc8
 800cc54:	200001ac 	.word	0x200001ac
 800cc58:	20000bd0 	.word	0x20000bd0

0800cc5c <BSP_ENV_SENSOR_SetOutputDataRate>:
  *         - ENV_PRESSURE
  * @param  Odr Output Data Rate value to be set
  * @retval BSP status
  */
int32_t BSP_ENV_SENSOR_SetOutputDataRate(uint32_t Instance, uint32_t Function, float Odr)
{
 800cc5c:	b580      	push	{r7, lr}
 800cc5e:	b086      	sub	sp, #24
 800cc60:	af00      	add	r7, sp, #0
 800cc62:	60f8      	str	r0, [r7, #12]
 800cc64:	60b9      	str	r1, [r7, #8]
 800cc66:	607a      	str	r2, [r7, #4]
  int32_t ret;

  if (Instance >= BSP_ENV_INSTANCES_NBR)
 800cc68:	68fb      	ldr	r3, [r7, #12]
 800cc6a:	2b01      	cmp	r3, #1
 800cc6c:	d903      	bls.n	800cc76 <BSP_ENV_SENSOR_SetOutputDataRate+0x1a>
  {
    ret = BSP_ERROR_WRONG_PARAM;
 800cc6e:	f06f 0301 	mvn.w	r3, #1
 800cc72:	617b      	str	r3, [r7, #20]
 800cc74:	e027      	b.n	800ccc6 <BSP_ENV_SENSOR_SetOutputDataRate+0x6a>
  }
  else
  {
    if ((EnvCtx[Instance].Functions & Function) == Function)
 800cc76:	4a16      	ldr	r2, [pc, #88]	@ (800ccd0 <BSP_ENV_SENSOR_SetOutputDataRate+0x74>)
 800cc78:	68fb      	ldr	r3, [r7, #12]
 800cc7a:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 800cc7e:	68bb      	ldr	r3, [r7, #8]
 800cc80:	4013      	ands	r3, r2
 800cc82:	68ba      	ldr	r2, [r7, #8]
 800cc84:	429a      	cmp	r2, r3
 800cc86:	d11b      	bne.n	800ccc0 <BSP_ENV_SENSOR_SetOutputDataRate+0x64>
    {
      if (EnvFuncDrv[Instance][FunctionIndex[Function]]->SetOutputDataRate(EnvCompObj[Instance], Odr) != BSP_ERROR_NONE)
 800cc88:	4a12      	ldr	r2, [pc, #72]	@ (800ccd4 <BSP_ENV_SENSOR_SetOutputDataRate+0x78>)
 800cc8a:	68bb      	ldr	r3, [r7, #8]
 800cc8c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800cc90:	4911      	ldr	r1, [pc, #68]	@ (800ccd8 <BSP_ENV_SENSOR_SetOutputDataRate+0x7c>)
 800cc92:	68fa      	ldr	r2, [r7, #12]
 800cc94:	0052      	lsls	r2, r2, #1
 800cc96:	4413      	add	r3, r2
 800cc98:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800cc9c:	68db      	ldr	r3, [r3, #12]
 800cc9e:	490f      	ldr	r1, [pc, #60]	@ (800ccdc <BSP_ENV_SENSOR_SetOutputDataRate+0x80>)
 800cca0:	68fa      	ldr	r2, [r7, #12]
 800cca2:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 800cca6:	6879      	ldr	r1, [r7, #4]
 800cca8:	4610      	mov	r0, r2
 800ccaa:	4798      	blx	r3
 800ccac:	4603      	mov	r3, r0
 800ccae:	2b00      	cmp	r3, #0
 800ccb0:	d003      	beq.n	800ccba <BSP_ENV_SENSOR_SetOutputDataRate+0x5e>
      {
        ret = BSP_ERROR_COMPONENT_FAILURE;
 800ccb2:	f06f 0304 	mvn.w	r3, #4
 800ccb6:	617b      	str	r3, [r7, #20]
 800ccb8:	e005      	b.n	800ccc6 <BSP_ENV_SENSOR_SetOutputDataRate+0x6a>
      }
      else
      {
        ret = BSP_ERROR_NONE;
 800ccba:	2300      	movs	r3, #0
 800ccbc:	617b      	str	r3, [r7, #20]
 800ccbe:	e002      	b.n	800ccc6 <BSP_ENV_SENSOR_SetOutputDataRate+0x6a>
      }
    }
    else
    {
      ret = BSP_ERROR_WRONG_PARAM;
 800ccc0:	f06f 0301 	mvn.w	r3, #1
 800ccc4:	617b      	str	r3, [r7, #20]
    }
  }

  return ret;
 800ccc6:	697b      	ldr	r3, [r7, #20]
}
 800ccc8:	4618      	mov	r0, r3
 800ccca:	3718      	adds	r7, #24
 800cccc:	46bd      	mov	sp, r7
 800ccce:	bd80      	pop	{r7, pc}
 800ccd0:	20000be8 	.word	0x20000be8
 800ccd4:	200001ac 	.word	0x200001ac
 800ccd8:	20000bd0 	.word	0x20000bd0
 800ccdc:	20000bc8 	.word	0x20000bc8

0800cce0 <BSP_ENV_SENSOR_GetValue>:
  *         - ENV_PRESSURE
  * @param  Value pointer to environmental sensor value
  * @retval BSP status
  */
int32_t BSP_ENV_SENSOR_GetValue(uint32_t Instance, uint32_t Function, float *Value)
{
 800cce0:	b580      	push	{r7, lr}
 800cce2:	b086      	sub	sp, #24
 800cce4:	af00      	add	r7, sp, #0
 800cce6:	60f8      	str	r0, [r7, #12]
 800cce8:	60b9      	str	r1, [r7, #8]
 800ccea:	607a      	str	r2, [r7, #4]
  int32_t ret;

  if (Instance >= BSP_ENV_INSTANCES_NBR)
 800ccec:	68fb      	ldr	r3, [r7, #12]
 800ccee:	2b01      	cmp	r3, #1
 800ccf0:	d903      	bls.n	800ccfa <BSP_ENV_SENSOR_GetValue+0x1a>
  {
    ret = BSP_ERROR_WRONG_PARAM;
 800ccf2:	f06f 0301 	mvn.w	r3, #1
 800ccf6:	617b      	str	r3, [r7, #20]
 800ccf8:	e027      	b.n	800cd4a <BSP_ENV_SENSOR_GetValue+0x6a>
  }
  else
  {
    if ((EnvCtx[Instance].Functions & Function) == Function)
 800ccfa:	4a16      	ldr	r2, [pc, #88]	@ (800cd54 <BSP_ENV_SENSOR_GetValue+0x74>)
 800ccfc:	68fb      	ldr	r3, [r7, #12]
 800ccfe:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 800cd02:	68bb      	ldr	r3, [r7, #8]
 800cd04:	4013      	ands	r3, r2
 800cd06:	68ba      	ldr	r2, [r7, #8]
 800cd08:	429a      	cmp	r2, r3
 800cd0a:	d11b      	bne.n	800cd44 <BSP_ENV_SENSOR_GetValue+0x64>
    {
      if (EnvFuncDrv[Instance][FunctionIndex[Function]]->GetValue(EnvCompObj[Instance], Value) != BSP_ERROR_NONE)
 800cd0c:	4a12      	ldr	r2, [pc, #72]	@ (800cd58 <BSP_ENV_SENSOR_GetValue+0x78>)
 800cd0e:	68bb      	ldr	r3, [r7, #8]
 800cd10:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800cd14:	4911      	ldr	r1, [pc, #68]	@ (800cd5c <BSP_ENV_SENSOR_GetValue+0x7c>)
 800cd16:	68fa      	ldr	r2, [r7, #12]
 800cd18:	0052      	lsls	r2, r2, #1
 800cd1a:	4413      	add	r3, r2
 800cd1c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800cd20:	691b      	ldr	r3, [r3, #16]
 800cd22:	490f      	ldr	r1, [pc, #60]	@ (800cd60 <BSP_ENV_SENSOR_GetValue+0x80>)
 800cd24:	68fa      	ldr	r2, [r7, #12]
 800cd26:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 800cd2a:	6879      	ldr	r1, [r7, #4]
 800cd2c:	4610      	mov	r0, r2
 800cd2e:	4798      	blx	r3
 800cd30:	4603      	mov	r3, r0
 800cd32:	2b00      	cmp	r3, #0
 800cd34:	d003      	beq.n	800cd3e <BSP_ENV_SENSOR_GetValue+0x5e>
      {
        ret = BSP_ERROR_COMPONENT_FAILURE;
 800cd36:	f06f 0304 	mvn.w	r3, #4
 800cd3a:	617b      	str	r3, [r7, #20]
 800cd3c:	e005      	b.n	800cd4a <BSP_ENV_SENSOR_GetValue+0x6a>
      }
      else
      {
        ret = BSP_ERROR_NONE;
 800cd3e:	2300      	movs	r3, #0
 800cd40:	617b      	str	r3, [r7, #20]
 800cd42:	e002      	b.n	800cd4a <BSP_ENV_SENSOR_GetValue+0x6a>
      }
    }
    else
    {
      ret = BSP_ERROR_WRONG_PARAM;
 800cd44:	f06f 0301 	mvn.w	r3, #1
 800cd48:	617b      	str	r3, [r7, #20]
    }
  }

  return ret;
 800cd4a:	697b      	ldr	r3, [r7, #20]
}
 800cd4c:	4618      	mov	r0, r3
 800cd4e:	3718      	adds	r7, #24
 800cd50:	46bd      	mov	sp, r7
 800cd52:	bd80      	pop	{r7, pc}
 800cd54:	20000be8 	.word	0x20000be8
 800cd58:	200001ac 	.word	0x200001ac
 800cd5c:	20000bd0 	.word	0x20000bd0
 800cd60:	20000bc8 	.word	0x20000bc8

0800cd64 <STTS22H_0_Probe>:
  * @param  Functions Environmental sensor functions. Could be :
  *         - ENV_TEMPERATURE
  * @retval BSP status
  */
static int32_t STTS22H_0_Probe(uint32_t Functions)
{
 800cd64:	b580      	push	{r7, lr}
 800cd66:	b092      	sub	sp, #72	@ 0x48
 800cd68:	af00      	add	r7, sp, #0
 800cd6a:	6078      	str	r0, [r7, #4]
  STTS22H_IO_t            io_ctx;
  uint8_t                 id;
  int32_t                 ret = BSP_ERROR_NONE;
 800cd6c:	2300      	movs	r3, #0
 800cd6e:	647b      	str	r3, [r7, #68]	@ 0x44
  static STTS22H_Object_t stts22h_obj_0;
  STTS22H_Capabilities_t  cap;

  /* Configure the environmental sensor driver */
  io_ctx.BusType     = STTS22H_I2C_BUS; /* I2C */
 800cd70:	2300      	movs	r3, #0
 800cd72:	62fb      	str	r3, [r7, #44]	@ 0x2c
  io_ctx.Address     = STTS22H_I2C_ADD_H; /* ADDR pin = VDD */
 800cd74:	2371      	movs	r3, #113	@ 0x71
 800cd76:	f887 3030 	strb.w	r3, [r7, #48]	@ 0x30
  io_ctx.Init        = BSP_STTS22H_0_I2C_INIT;
 800cd7a:	4b39      	ldr	r3, [pc, #228]	@ (800ce60 <STTS22H_0_Probe+0xfc>)
 800cd7c:	627b      	str	r3, [r7, #36]	@ 0x24
  io_ctx.DeInit      = BSP_STTS22H_0_I2C_DEINIT;
 800cd7e:	4b39      	ldr	r3, [pc, #228]	@ (800ce64 <STTS22H_0_Probe+0x100>)
 800cd80:	62bb      	str	r3, [r7, #40]	@ 0x28
  io_ctx.ReadReg     = BSP_STTS22H_0_I2C_READ_REG;
 800cd82:	4b39      	ldr	r3, [pc, #228]	@ (800ce68 <STTS22H_0_Probe+0x104>)
 800cd84:	63bb      	str	r3, [r7, #56]	@ 0x38
  io_ctx.WriteReg    = BSP_STTS22H_0_I2C_WRITE_REG;
 800cd86:	4b39      	ldr	r3, [pc, #228]	@ (800ce6c <STTS22H_0_Probe+0x108>)
 800cd88:	637b      	str	r3, [r7, #52]	@ 0x34
  io_ctx.GetTick     = BSP_GetTick;
 800cd8a:	4b39      	ldr	r3, [pc, #228]	@ (800ce70 <STTS22H_0_Probe+0x10c>)
 800cd8c:	63fb      	str	r3, [r7, #60]	@ 0x3c

  if (STTS22H_RegisterBusIO(&stts22h_obj_0, &io_ctx) != STTS22H_OK)
 800cd8e:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 800cd92:	4619      	mov	r1, r3
 800cd94:	4837      	ldr	r0, [pc, #220]	@ (800ce74 <STTS22H_0_Probe+0x110>)
 800cd96:	f7ff f9b3 	bl	800c100 <STTS22H_RegisterBusIO>
 800cd9a:	4603      	mov	r3, r0
 800cd9c:	2b00      	cmp	r3, #0
 800cd9e:	d003      	beq.n	800cda8 <STTS22H_0_Probe+0x44>
  {
    ret = BSP_ERROR_UNKNOWN_COMPONENT;
 800cda0:	f06f 0306 	mvn.w	r3, #6
 800cda4:	647b      	str	r3, [r7, #68]	@ 0x44
 800cda6:	e056      	b.n	800ce56 <STTS22H_0_Probe+0xf2>
  }
  else if (STTS22H_ReadID(&stts22h_obj_0, &id) != STTS22H_OK)
 800cda8:	f107 0323 	add.w	r3, r7, #35	@ 0x23
 800cdac:	4619      	mov	r1, r3
 800cdae:	4831      	ldr	r0, [pc, #196]	@ (800ce74 <STTS22H_0_Probe+0x110>)
 800cdb0:	f7ff fa45 	bl	800c23e <STTS22H_ReadID>
 800cdb4:	4603      	mov	r3, r0
 800cdb6:	2b00      	cmp	r3, #0
 800cdb8:	d003      	beq.n	800cdc2 <STTS22H_0_Probe+0x5e>
  {
    ret = BSP_ERROR_UNKNOWN_COMPONENT;
 800cdba:	f06f 0306 	mvn.w	r3, #6
 800cdbe:	647b      	str	r3, [r7, #68]	@ 0x44
 800cdc0:	e049      	b.n	800ce56 <STTS22H_0_Probe+0xf2>
  }
  else if (id != STTS22H_ID)
 800cdc2:	f897 3023 	ldrb.w	r3, [r7, #35]	@ 0x23
 800cdc6:	2ba0      	cmp	r3, #160	@ 0xa0
 800cdc8:	d003      	beq.n	800cdd2 <STTS22H_0_Probe+0x6e>
  {
    ret = BSP_ERROR_UNKNOWN_COMPONENT;
 800cdca:	f06f 0306 	mvn.w	r3, #6
 800cdce:	647b      	str	r3, [r7, #68]	@ 0x44
 800cdd0:	e041      	b.n	800ce56 <STTS22H_0_Probe+0xf2>
  }
  else
  {
    (void)STTS22H_GetCapabilities(&stts22h_obj_0, &cap);
 800cdd2:	f107 0308 	add.w	r3, r7, #8
 800cdd6:	4619      	mov	r1, r3
 800cdd8:	4826      	ldr	r0, [pc, #152]	@ (800ce74 <STTS22H_0_Probe+0x110>)
 800cdda:	f7ff fa4b 	bl	800c274 <STTS22H_GetCapabilities>
    EnvCtx[STTS22H_0].Functions = ((uint32_t)cap.Temperature) | ((uint32_t)cap.Pressure << 1) | ((
 800cdde:	7a3b      	ldrb	r3, [r7, #8]
 800cde0:	461a      	mov	r2, r3
 800cde2:	7a7b      	ldrb	r3, [r7, #9]
 800cde4:	005b      	lsls	r3, r3, #1
 800cde6:	431a      	orrs	r2, r3
                                    uint32_t)cap.Humidity << 2);
 800cde8:	7abb      	ldrb	r3, [r7, #10]
 800cdea:	009b      	lsls	r3, r3, #2
    EnvCtx[STTS22H_0].Functions = ((uint32_t)cap.Temperature) | ((uint32_t)cap.Pressure << 1) | ((
 800cdec:	4313      	orrs	r3, r2
 800cdee:	4a22      	ldr	r2, [pc, #136]	@ (800ce78 <STTS22H_0_Probe+0x114>)
 800cdf0:	6013      	str	r3, [r2, #0]

    EnvCompObj[STTS22H_0] = &stts22h_obj_0;
 800cdf2:	4b22      	ldr	r3, [pc, #136]	@ (800ce7c <STTS22H_0_Probe+0x118>)
 800cdf4:	4a1f      	ldr	r2, [pc, #124]	@ (800ce74 <STTS22H_0_Probe+0x110>)
 800cdf6:	601a      	str	r2, [r3, #0]
    /* The second cast (void *) is added to bypass Misra R11.3 rule */
    EnvDrv[STTS22H_0] = (ENV_SENSOR_CommonDrv_t *)(void *)&STTS22H_COMMON_Driver;
 800cdf8:	4b21      	ldr	r3, [pc, #132]	@ (800ce80 <STTS22H_0_Probe+0x11c>)
 800cdfa:	4a22      	ldr	r2, [pc, #136]	@ (800ce84 <STTS22H_0_Probe+0x120>)
 800cdfc:	601a      	str	r2, [r3, #0]

    if ((ret == BSP_ERROR_NONE) && ((Functions & ENV_TEMPERATURE) == ENV_TEMPERATURE) && (cap.Temperature == 1U))
 800cdfe:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800ce00:	2b00      	cmp	r3, #0
 800ce02:	d11d      	bne.n	800ce40 <STTS22H_0_Probe+0xdc>
 800ce04:	687b      	ldr	r3, [r7, #4]
 800ce06:	f003 0301 	and.w	r3, r3, #1
 800ce0a:	2b00      	cmp	r3, #0
 800ce0c:	d018      	beq.n	800ce40 <STTS22H_0_Probe+0xdc>
 800ce0e:	7a3b      	ldrb	r3, [r7, #8]
 800ce10:	2b01      	cmp	r3, #1
 800ce12:	d115      	bne.n	800ce40 <STTS22H_0_Probe+0xdc>
    {
      /* The second cast (void *) is added to bypass Misra R11.3 rule */
      EnvFuncDrv[STTS22H_0][FunctionIndex[ENV_TEMPERATURE]] = (ENV_SENSOR_FuncDrv_t *)(void *)&STTS22H_TEMP_Driver;
 800ce14:	4b1c      	ldr	r3, [pc, #112]	@ (800ce88 <STTS22H_0_Probe+0x124>)
 800ce16:	685b      	ldr	r3, [r3, #4]
 800ce18:	4a1c      	ldr	r2, [pc, #112]	@ (800ce8c <STTS22H_0_Probe+0x128>)
 800ce1a:	491d      	ldr	r1, [pc, #116]	@ (800ce90 <STTS22H_0_Probe+0x12c>)
 800ce1c:	f842 1023 	str.w	r1, [r2, r3, lsl #2]

      if (EnvDrv[STTS22H_0]->Init(EnvCompObj[STTS22H_0]) != STTS22H_OK)
 800ce20:	4b17      	ldr	r3, [pc, #92]	@ (800ce80 <STTS22H_0_Probe+0x11c>)
 800ce22:	681b      	ldr	r3, [r3, #0]
 800ce24:	681b      	ldr	r3, [r3, #0]
 800ce26:	4a15      	ldr	r2, [pc, #84]	@ (800ce7c <STTS22H_0_Probe+0x118>)
 800ce28:	6812      	ldr	r2, [r2, #0]
 800ce2a:	4610      	mov	r0, r2
 800ce2c:	4798      	blx	r3
 800ce2e:	4603      	mov	r3, r0
 800ce30:	2b00      	cmp	r3, #0
 800ce32:	d003      	beq.n	800ce3c <STTS22H_0_Probe+0xd8>
      {
        ret = BSP_ERROR_COMPONENT_FAILURE;
 800ce34:	f06f 0304 	mvn.w	r3, #4
 800ce38:	647b      	str	r3, [r7, #68]	@ 0x44
 800ce3a:	e001      	b.n	800ce40 <STTS22H_0_Probe+0xdc>
      }
      else
      {
        ret = BSP_ERROR_NONE;
 800ce3c:	2300      	movs	r3, #0
 800ce3e:	647b      	str	r3, [r7, #68]	@ 0x44
      }
    }
    if ((ret == BSP_ERROR_NONE) && ((Functions & ENV_PRESSURE) == ENV_PRESSURE))
 800ce40:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800ce42:	2b00      	cmp	r3, #0
 800ce44:	d107      	bne.n	800ce56 <STTS22H_0_Probe+0xf2>
 800ce46:	687b      	ldr	r3, [r7, #4]
 800ce48:	f003 0302 	and.w	r3, r3, #2
 800ce4c:	2b00      	cmp	r3, #0
 800ce4e:	d002      	beq.n	800ce56 <STTS22H_0_Probe+0xf2>
    {
      /* Return an error if the application try to initialize a function not supported by the component */
      ret = BSP_ERROR_COMPONENT_FAILURE;
 800ce50:	f06f 0304 	mvn.w	r3, #4
 800ce54:	647b      	str	r3, [r7, #68]	@ 0x44
    }
  }

  return ret;
 800ce56:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
}
 800ce58:	4618      	mov	r0, r3
 800ce5a:	3748      	adds	r7, #72	@ 0x48
 800ce5c:	46bd      	mov	sp, r7
 800ce5e:	bd80      	pop	{r7, pc}
 800ce60:	080057d9 	.word	0x080057d9
 800ce64:	08005855 	.word	0x08005855
 800ce68:	08005909 	.word	0x08005909
 800ce6c:	080058a5 	.word	0x080058a5
 800ce70:	0800596d 	.word	0x0800596d
 800ce74:	20000bf0 	.word	0x20000bf0
 800ce78:	20000be8 	.word	0x20000be8
 800ce7c:	20000bc8 	.word	0x20000bc8
 800ce80:	20000be0 	.word	0x20000be0
 800ce84:	20000188 	.word	0x20000188
 800ce88:	200001ac 	.word	0x200001ac
 800ce8c:	20000bd0 	.word	0x20000bd0
 800ce90:	20000198 	.word	0x20000198

0800ce94 <LPS22DF_0_Probe>:
  * @param  Functions Environmental sensor functions. Could be :
  *         - ENV_TEMPERATURE and/or ENV_PRESSURE
  * @retval BSP status
  */
static int32_t LPS22DF_0_Probe(uint32_t Functions)
{
 800ce94:	b580      	push	{r7, lr}
 800ce96:	b092      	sub	sp, #72	@ 0x48
 800ce98:	af00      	add	r7, sp, #0
 800ce9a:	6078      	str	r0, [r7, #4]
  LPS22DF_IO_t            io_ctx;
  uint8_t                 id;
  int32_t                 ret = BSP_ERROR_NONE;
 800ce9c:	2300      	movs	r3, #0
 800ce9e:	647b      	str	r3, [r7, #68]	@ 0x44
  static LPS22DF_Object_t lps22df_obj_0;
  LPS22DF_Capabilities_t  cap;

  /* Configure the pressure driver */
  io_ctx.BusType     = LPS22DF_I2C_BUS; /* I2C */
 800cea0:	2300      	movs	r3, #0
 800cea2:	62fb      	str	r3, [r7, #44]	@ 0x2c
  io_ctx.Address     = LPS22DF_I2C_ADD_H; /* SA0 = VDD */
 800cea4:	23bb      	movs	r3, #187	@ 0xbb
 800cea6:	f887 3030 	strb.w	r3, [r7, #48]	@ 0x30
  io_ctx.Init        = BSP_LPS22DF_0_I2C_INIT;
 800ceaa:	4b45      	ldr	r3, [pc, #276]	@ (800cfc0 <LPS22DF_0_Probe+0x12c>)
 800ceac:	627b      	str	r3, [r7, #36]	@ 0x24
  io_ctx.DeInit      = BSP_LPS22DF_0_I2C_DEINIT;
 800ceae:	4b45      	ldr	r3, [pc, #276]	@ (800cfc4 <LPS22DF_0_Probe+0x130>)
 800ceb0:	62bb      	str	r3, [r7, #40]	@ 0x28
  io_ctx.ReadReg     = BSP_LPS22DF_0_I2C_READ_REG;
 800ceb2:	4b45      	ldr	r3, [pc, #276]	@ (800cfc8 <LPS22DF_0_Probe+0x134>)
 800ceb4:	63bb      	str	r3, [r7, #56]	@ 0x38
  io_ctx.WriteReg    = BSP_LPS22DF_0_I2C_WRITE_REG;
 800ceb6:	4b45      	ldr	r3, [pc, #276]	@ (800cfcc <LPS22DF_0_Probe+0x138>)
 800ceb8:	637b      	str	r3, [r7, #52]	@ 0x34
  io_ctx.GetTick     = BSP_GetTick;
 800ceba:	4b45      	ldr	r3, [pc, #276]	@ (800cfd0 <LPS22DF_0_Probe+0x13c>)
 800cebc:	63fb      	str	r3, [r7, #60]	@ 0x3c

  if (LPS22DF_RegisterBusIO(&lps22df_obj_0, &io_ctx) != LPS22DF_OK)
 800cebe:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 800cec2:	4619      	mov	r1, r3
 800cec4:	4843      	ldr	r0, [pc, #268]	@ (800cfd4 <LPS22DF_0_Probe+0x140>)
 800cec6:	f7fc fc53 	bl	8009770 <LPS22DF_RegisterBusIO>
 800ceca:	4603      	mov	r3, r0
 800cecc:	2b00      	cmp	r3, #0
 800cece:	d003      	beq.n	800ced8 <LPS22DF_0_Probe+0x44>
  {
    ret = BSP_ERROR_UNKNOWN_COMPONENT;
 800ced0:	f06f 0306 	mvn.w	r3, #6
 800ced4:	647b      	str	r3, [r7, #68]	@ 0x44
 800ced6:	e06e      	b.n	800cfb6 <LPS22DF_0_Probe+0x122>
  }
  else if (LPS22DF_ReadID(&lps22df_obj_0, &id) != LPS22DF_OK)
 800ced8:	f107 0323 	add.w	r3, r7, #35	@ 0x23
 800cedc:	4619      	mov	r1, r3
 800cede:	483d      	ldr	r0, [pc, #244]	@ (800cfd4 <LPS22DF_0_Probe+0x140>)
 800cee0:	f7fc fcef 	bl	80098c2 <LPS22DF_ReadID>
 800cee4:	4603      	mov	r3, r0
 800cee6:	2b00      	cmp	r3, #0
 800cee8:	d003      	beq.n	800cef2 <LPS22DF_0_Probe+0x5e>
  {
    ret = BSP_ERROR_UNKNOWN_COMPONENT;
 800ceea:	f06f 0306 	mvn.w	r3, #6
 800ceee:	647b      	str	r3, [r7, #68]	@ 0x44
 800cef0:	e061      	b.n	800cfb6 <LPS22DF_0_Probe+0x122>
  }
  else if (id != LPS22DF_ID)
 800cef2:	f897 3023 	ldrb.w	r3, [r7, #35]	@ 0x23
 800cef6:	2bb4      	cmp	r3, #180	@ 0xb4
 800cef8:	d003      	beq.n	800cf02 <LPS22DF_0_Probe+0x6e>
  {
    ret = BSP_ERROR_UNKNOWN_COMPONENT;
 800cefa:	f06f 0306 	mvn.w	r3, #6
 800cefe:	647b      	str	r3, [r7, #68]	@ 0x44
 800cf00:	e059      	b.n	800cfb6 <LPS22DF_0_Probe+0x122>
  }
  else
  {
    (void)LPS22DF_GetCapabilities(&lps22df_obj_0, &cap);
 800cf02:	f107 0308 	add.w	r3, r7, #8
 800cf06:	4619      	mov	r1, r3
 800cf08:	4832      	ldr	r0, [pc, #200]	@ (800cfd4 <LPS22DF_0_Probe+0x140>)
 800cf0a:	f7fc fcf5 	bl	80098f8 <LPS22DF_GetCapabilities>

    EnvCtx[LPS22DF_0].Functions = ((uint32_t)cap.Temperature) | ((uint32_t)cap.Pressure << 1) | ((
 800cf0e:	7a3b      	ldrb	r3, [r7, #8]
 800cf10:	461a      	mov	r2, r3
 800cf12:	7a7b      	ldrb	r3, [r7, #9]
 800cf14:	005b      	lsls	r3, r3, #1
 800cf16:	431a      	orrs	r2, r3
                                    uint32_t)cap.Humidity << 2);
 800cf18:	7abb      	ldrb	r3, [r7, #10]
 800cf1a:	009b      	lsls	r3, r3, #2
    EnvCtx[LPS22DF_0].Functions = ((uint32_t)cap.Temperature) | ((uint32_t)cap.Pressure << 1) | ((
 800cf1c:	4313      	orrs	r3, r2
 800cf1e:	4a2e      	ldr	r2, [pc, #184]	@ (800cfd8 <LPS22DF_0_Probe+0x144>)
 800cf20:	6053      	str	r3, [r2, #4]

    EnvCompObj[LPS22DF_0] = &lps22df_obj_0;
 800cf22:	4b2e      	ldr	r3, [pc, #184]	@ (800cfdc <LPS22DF_0_Probe+0x148>)
 800cf24:	4a2b      	ldr	r2, [pc, #172]	@ (800cfd4 <LPS22DF_0_Probe+0x140>)
 800cf26:	605a      	str	r2, [r3, #4]
    /* The second cast (void *) is added to bypass Misra R11.3 rule */
    EnvDrv[LPS22DF_0] = (ENV_SENSOR_CommonDrv_t *)(void *)&LPS22DF_COMMON_Driver;
 800cf28:	4b2d      	ldr	r3, [pc, #180]	@ (800cfe0 <LPS22DF_0_Probe+0x14c>)
 800cf2a:	4a2e      	ldr	r2, [pc, #184]	@ (800cfe4 <LPS22DF_0_Probe+0x150>)
 800cf2c:	605a      	str	r2, [r3, #4]

    if ((ret == BSP_ERROR_NONE) && ((Functions & ENV_TEMPERATURE) == ENV_TEMPERATURE) && (cap.Temperature == 1U))
 800cf2e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800cf30:	2b00      	cmp	r3, #0
 800cf32:	d11e      	bne.n	800cf72 <LPS22DF_0_Probe+0xde>
 800cf34:	687b      	ldr	r3, [r7, #4]
 800cf36:	f003 0301 	and.w	r3, r3, #1
 800cf3a:	2b00      	cmp	r3, #0
 800cf3c:	d019      	beq.n	800cf72 <LPS22DF_0_Probe+0xde>
 800cf3e:	7a3b      	ldrb	r3, [r7, #8]
 800cf40:	2b01      	cmp	r3, #1
 800cf42:	d116      	bne.n	800cf72 <LPS22DF_0_Probe+0xde>
    {
      /* The second cast (void *) is added to bypass Misra R11.3 rule */
      EnvFuncDrv[LPS22DF_0][FunctionIndex[ENV_TEMPERATURE]] = (ENV_SENSOR_FuncDrv_t *)(void *)&LPS22DF_TEMP_Driver;
 800cf44:	4b28      	ldr	r3, [pc, #160]	@ (800cfe8 <LPS22DF_0_Probe+0x154>)
 800cf46:	685b      	ldr	r3, [r3, #4]
 800cf48:	4a28      	ldr	r2, [pc, #160]	@ (800cfec <LPS22DF_0_Probe+0x158>)
 800cf4a:	3302      	adds	r3, #2
 800cf4c:	4928      	ldr	r1, [pc, #160]	@ (800cff0 <LPS22DF_0_Probe+0x15c>)
 800cf4e:	f842 1023 	str.w	r1, [r2, r3, lsl #2]

      if (EnvDrv[LPS22DF_0]->Init(EnvCompObj[LPS22DF_0]) != LPS22DF_OK)
 800cf52:	4b23      	ldr	r3, [pc, #140]	@ (800cfe0 <LPS22DF_0_Probe+0x14c>)
 800cf54:	685b      	ldr	r3, [r3, #4]
 800cf56:	681b      	ldr	r3, [r3, #0]
 800cf58:	4a20      	ldr	r2, [pc, #128]	@ (800cfdc <LPS22DF_0_Probe+0x148>)
 800cf5a:	6852      	ldr	r2, [r2, #4]
 800cf5c:	4610      	mov	r0, r2
 800cf5e:	4798      	blx	r3
 800cf60:	4603      	mov	r3, r0
 800cf62:	2b00      	cmp	r3, #0
 800cf64:	d003      	beq.n	800cf6e <LPS22DF_0_Probe+0xda>
      {
        ret = BSP_ERROR_COMPONENT_FAILURE;
 800cf66:	f06f 0304 	mvn.w	r3, #4
 800cf6a:	647b      	str	r3, [r7, #68]	@ 0x44
 800cf6c:	e001      	b.n	800cf72 <LPS22DF_0_Probe+0xde>
      }
      else
      {
        ret = BSP_ERROR_NONE;
 800cf6e:	2300      	movs	r3, #0
 800cf70:	647b      	str	r3, [r7, #68]	@ 0x44
      }
    }
    if ((ret == BSP_ERROR_NONE) && ((Functions & ENV_PRESSURE) == ENV_PRESSURE) && (cap.Pressure == 1U))
 800cf72:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800cf74:	2b00      	cmp	r3, #0
 800cf76:	d11e      	bne.n	800cfb6 <LPS22DF_0_Probe+0x122>
 800cf78:	687b      	ldr	r3, [r7, #4]
 800cf7a:	f003 0302 	and.w	r3, r3, #2
 800cf7e:	2b00      	cmp	r3, #0
 800cf80:	d019      	beq.n	800cfb6 <LPS22DF_0_Probe+0x122>
 800cf82:	7a7b      	ldrb	r3, [r7, #9]
 800cf84:	2b01      	cmp	r3, #1
 800cf86:	d116      	bne.n	800cfb6 <LPS22DF_0_Probe+0x122>
    {
      /* The second cast (void *) is added to bypass Misra R11.3 rule */
      EnvFuncDrv[LPS22DF_0][FunctionIndex[ENV_PRESSURE]] = (ENV_SENSOR_FuncDrv_t *)(void *)&LPS22DF_PRESS_Driver;
 800cf88:	4b17      	ldr	r3, [pc, #92]	@ (800cfe8 <LPS22DF_0_Probe+0x154>)
 800cf8a:	689b      	ldr	r3, [r3, #8]
 800cf8c:	4a17      	ldr	r2, [pc, #92]	@ (800cfec <LPS22DF_0_Probe+0x158>)
 800cf8e:	3302      	adds	r3, #2
 800cf90:	4918      	ldr	r1, [pc, #96]	@ (800cff4 <LPS22DF_0_Probe+0x160>)
 800cf92:	f842 1023 	str.w	r1, [r2, r3, lsl #2]

      if (EnvDrv[LPS22DF_0]->Init(EnvCompObj[LPS22DF_0]) != LPS22DF_OK)
 800cf96:	4b12      	ldr	r3, [pc, #72]	@ (800cfe0 <LPS22DF_0_Probe+0x14c>)
 800cf98:	685b      	ldr	r3, [r3, #4]
 800cf9a:	681b      	ldr	r3, [r3, #0]
 800cf9c:	4a0f      	ldr	r2, [pc, #60]	@ (800cfdc <LPS22DF_0_Probe+0x148>)
 800cf9e:	6852      	ldr	r2, [r2, #4]
 800cfa0:	4610      	mov	r0, r2
 800cfa2:	4798      	blx	r3
 800cfa4:	4603      	mov	r3, r0
 800cfa6:	2b00      	cmp	r3, #0
 800cfa8:	d003      	beq.n	800cfb2 <LPS22DF_0_Probe+0x11e>
      {
        ret = BSP_ERROR_COMPONENT_FAILURE;
 800cfaa:	f06f 0304 	mvn.w	r3, #4
 800cfae:	647b      	str	r3, [r7, #68]	@ 0x44
 800cfb0:	e001      	b.n	800cfb6 <LPS22DF_0_Probe+0x122>
      }
      else
      {
        ret = BSP_ERROR_NONE;
 800cfb2:	2300      	movs	r3, #0
 800cfb4:	647b      	str	r3, [r7, #68]	@ 0x44
      }
    }
  }

  return ret;
 800cfb6:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
}
 800cfb8:	4618      	mov	r0, r3
 800cfba:	3748      	adds	r7, #72	@ 0x48
 800cfbc:	46bd      	mov	sp, r7
 800cfbe:	bd80      	pop	{r7, pc}
 800cfc0:	080057d9 	.word	0x080057d9
 800cfc4:	08005855 	.word	0x08005855
 800cfc8:	08005909 	.word	0x08005909
 800cfcc:	080058a5 	.word	0x080058a5
 800cfd0:	0800596d 	.word	0x0800596d
 800cfd4:	20000c28 	.word	0x20000c28
 800cfd8:	20000be8 	.word	0x20000be8
 800cfdc:	20000bc8 	.word	0x20000bc8
 800cfe0:	20000be0 	.word	0x20000be0
 800cfe4:	200000f8 	.word	0x200000f8
 800cfe8:	200001ac 	.word	0x200001ac
 800cfec:	20000bd0 	.word	0x20000bd0
 800cff0:	2000011c 	.word	0x2000011c
 800cff4:	20000108 	.word	0x20000108

0800cff8 <BSP_GG_Init>:
  * @param handle pointer to the device handle
  * @retval COMPONENT_OK in case of success
  * @retval COMPONENT_ERROR in case of failure
  */
DrvStatusTypeDef BSP_GG_Init(void **handle)
{
 800cff8:	b580      	push	{r7, lr}
 800cffa:	b084      	sub	sp, #16
 800cffc:	af00      	add	r7, sp, #0
 800cffe:	6078      	str	r0, [r7, #4]
  GG_Drv_t *driver = NULL;
 800d000:	2300      	movs	r3, #0
 800d002:	60fb      	str	r3, [r7, #12]

  if (GG_SensorHandle[ STC3115_0 ].isInitialized == 1U)
 800d004:	4b25      	ldr	r3, [pc, #148]	@ (800d09c <BSP_GG_Init+0xa4>)
 800d006:	795b      	ldrb	r3, [r3, #5]
 800d008:	2b01      	cmp	r3, #1
 800d00a:	d101      	bne.n	800d010 <BSP_GG_Init+0x18>
  {
    /* We have reached the max num of instance for this component */
    return COMPONENT_ERROR;
 800d00c:	2301      	movs	r3, #1
 800d00e:	e041      	b.n	800d094 <BSP_GG_Init+0x9c>
  }

  if (BSP_STC3115_0_I2C_INIT() != BSP_ERROR_NONE)
 800d010:	f7f8 faf0 	bl	80055f4 <BSP_I2C4_Init>
 800d014:	4603      	mov	r3, r0
 800d016:	2b00      	cmp	r3, #0
 800d018:	d001      	beq.n	800d01e <BSP_GG_Init+0x26>
  {
    return COMPONENT_ERROR;
 800d01a:	2301      	movs	r3, #1
 800d01c:	e03a      	b.n	800d094 <BSP_GG_Init+0x9c>
  }

  /* Setup sensor handle. */
  GG_SensorHandle[ STC3115_0 ].who_am_i      = STC3115_ID;
 800d01e:	4b1f      	ldr	r3, [pc, #124]	@ (800d09c <BSP_GG_Init+0xa4>)
 800d020:	2214      	movs	r2, #20
 800d022:	701a      	strb	r2, [r3, #0]
  GG_SensorHandle[ STC3115_0 ].ifType        = 0; /* SPI interface */
 800d024:	4b1d      	ldr	r3, [pc, #116]	@ (800d09c <BSP_GG_Init+0xa4>)
 800d026:	2200      	movs	r2, #0
 800d028:	705a      	strb	r2, [r3, #1]
  GG_SensorHandle[ STC3115_0 ].address       = STC3115_SLAVE_ADDRESS;
 800d02a:	4b1c      	ldr	r3, [pc, #112]	@ (800d09c <BSP_GG_Init+0xa4>)
 800d02c:	22e0      	movs	r2, #224	@ 0xe0
 800d02e:	709a      	strb	r2, [r3, #2]
  GG_SensorHandle[ STC3115_0 ].spiDevice     = 0;
 800d030:	4b1a      	ldr	r3, [pc, #104]	@ (800d09c <BSP_GG_Init+0xa4>)
 800d032:	2200      	movs	r2, #0
 800d034:	70da      	strb	r2, [r3, #3]
  GG_SensorHandle[ STC3115_0 ].instance      = (uint8_t) STC3115_0;
 800d036:	4b19      	ldr	r3, [pc, #100]	@ (800d09c <BSP_GG_Init+0xa4>)
 800d038:	2200      	movs	r2, #0
 800d03a:	711a      	strb	r2, [r3, #4]
  GG_SensorHandle[ STC3115_0 ].isInitialized = 0;
 800d03c:	4b17      	ldr	r3, [pc, #92]	@ (800d09c <BSP_GG_Init+0xa4>)
 800d03e:	2200      	movs	r2, #0
 800d040:	715a      	strb	r2, [r3, #5]
  GG_SensorHandle[ STC3115_0 ].isEnabled     = 0;
 800d042:	4b16      	ldr	r3, [pc, #88]	@ (800d09c <BSP_GG_Init+0xa4>)
 800d044:	2200      	movs	r2, #0
 800d046:	719a      	strb	r2, [r3, #6]
  GG_SensorHandle[ STC3115_0 ].isCombo       = 1;
 800d048:	4b14      	ldr	r3, [pc, #80]	@ (800d09c <BSP_GG_Init+0xa4>)
 800d04a:	2201      	movs	r2, #1
 800d04c:	71da      	strb	r2, [r3, #7]
  GG_SensorHandle[ STC3115_0 ].pData         = (void *)&GG_Data[ STC3115_0 ];
 800d04e:	4b13      	ldr	r3, [pc, #76]	@ (800d09c <BSP_GG_Init+0xa4>)
 800d050:	4a13      	ldr	r2, [pc, #76]	@ (800d0a0 <BSP_GG_Init+0xa8>)
 800d052:	609a      	str	r2, [r3, #8]
  GG_SensorHandle[ STC3115_0 ].pVTable       = (void *)&STC3115_Drv;
 800d054:	4b11      	ldr	r3, [pc, #68]	@ (800d09c <BSP_GG_Init+0xa4>)
 800d056:	4a13      	ldr	r2, [pc, #76]	@ (800d0a4 <BSP_GG_Init+0xac>)
 800d058:	60da      	str	r2, [r3, #12]
  GG_SensorHandle[ STC3115_0 ].pExtVTable    = 0;
 800d05a:	4b10      	ldr	r3, [pc, #64]	@ (800d09c <BSP_GG_Init+0xa4>)
 800d05c:	2200      	movs	r2, #0
 800d05e:	611a      	str	r2, [r3, #16]

  GG_Data[ STC3115_0 ].pComponentData = (void *)&STC3115_0_Data;
 800d060:	4b0f      	ldr	r3, [pc, #60]	@ (800d0a0 <BSP_GG_Init+0xa8>)
 800d062:	4a11      	ldr	r2, [pc, #68]	@ (800d0a8 <BSP_GG_Init+0xb0>)
 800d064:	601a      	str	r2, [r3, #0]
  GG_Data[ STC3115_0 ].pExtData       = 0;
 800d066:	4b0e      	ldr	r3, [pc, #56]	@ (800d0a0 <BSP_GG_Init+0xa8>)
 800d068:	2200      	movs	r2, #0
 800d06a:	605a      	str	r2, [r3, #4]

  *handle = (void *)&GG_SensorHandle[ STC3115_0 ];
 800d06c:	687b      	ldr	r3, [r7, #4]
 800d06e:	4a0b      	ldr	r2, [pc, #44]	@ (800d09c <BSP_GG_Init+0xa4>)
 800d070:	601a      	str	r2, [r3, #0]
  /*  *handle = (void *)GG_SensorHandle; */

  driver = (GG_Drv_t *)((DrvContextTypeDef *)(*handle))->pVTable;
 800d072:	687b      	ldr	r3, [r7, #4]
 800d074:	681b      	ldr	r3, [r3, #0]
 800d076:	68db      	ldr	r3, [r3, #12]
 800d078:	60fb      	str	r3, [r7, #12]

  if (driver->Init == NULL)
 800d07a:	68fb      	ldr	r3, [r7, #12]
 800d07c:	681b      	ldr	r3, [r3, #0]
 800d07e:	2b00      	cmp	r3, #0
 800d080:	d101      	bne.n	800d086 <BSP_GG_Init+0x8e>
  {
    return COMPONENT_ERROR;
 800d082:	2301      	movs	r3, #1
 800d084:	e006      	b.n	800d094 <BSP_GG_Init+0x9c>
  }

  return driver->Init((DrvContextTypeDef *)(*handle));
 800d086:	68fb      	ldr	r3, [r7, #12]
 800d088:	681b      	ldr	r3, [r3, #0]
 800d08a:	687a      	ldr	r2, [r7, #4]
 800d08c:	6812      	ldr	r2, [r2, #0]
 800d08e:	4610      	mov	r0, r2
 800d090:	4798      	blx	r3
 800d092:	4603      	mov	r3, r0
}
 800d094:	4618      	mov	r0, r3
 800d096:	3710      	adds	r7, #16
 800d098:	46bd      	mov	sp, r7
 800d09a:	bd80      	pop	{r7, pc}
 800d09c:	20000c60 	.word	0x20000c60
 800d0a0:	20000c74 	.word	0x20000c74
 800d0a4:	20000030 	.word	0x20000030
 800d0a8:	20000c7c 	.word	0x20000c7c

0800d0ac <BSP_GG_GetPresence>:
  * @param presence the pointer to the value refers to battery presence
  * @retval COMPONENT_OK in case of success
  * @retval COMPONENT_ERROR in case of failure
  */
DrvStatusTypeDef BSP_GG_GetPresence(void *handle, uint32_t *presence)
{
 800d0ac:	b580      	push	{r7, lr}
 800d0ae:	b084      	sub	sp, #16
 800d0b0:	af00      	add	r7, sp, #0
 800d0b2:	6078      	str	r0, [r7, #4]
 800d0b4:	6039      	str	r1, [r7, #0]
  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
 800d0b6:	687b      	ldr	r3, [r7, #4]
 800d0b8:	60fb      	str	r3, [r7, #12]
  GG_Drv_t *driver = NULL;
 800d0ba:	2300      	movs	r3, #0
 800d0bc:	60bb      	str	r3, [r7, #8]

  if (ctx == NULL)
 800d0be:	68fb      	ldr	r3, [r7, #12]
 800d0c0:	2b00      	cmp	r3, #0
 800d0c2:	d101      	bne.n	800d0c8 <BSP_GG_GetPresence+0x1c>
  {
    return COMPONENT_ERROR;
 800d0c4:	2301      	movs	r3, #1
 800d0c6:	e00e      	b.n	800d0e6 <BSP_GG_GetPresence+0x3a>
  }

  driver = (GG_Drv_t *)ctx->pVTable;
 800d0c8:	68fb      	ldr	r3, [r7, #12]
 800d0ca:	68db      	ldr	r3, [r3, #12]
 800d0cc:	60bb      	str	r3, [r7, #8]

  if (driver->GetPresence == NULL)
 800d0ce:	68bb      	ldr	r3, [r7, #8]
 800d0d0:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800d0d2:	2b00      	cmp	r3, #0
 800d0d4:	d101      	bne.n	800d0da <BSP_GG_GetPresence+0x2e>
  {
    return COMPONENT_ERROR;
 800d0d6:	2301      	movs	r3, #1
 800d0d8:	e005      	b.n	800d0e6 <BSP_GG_GetPresence+0x3a>
  }

  return driver->GetPresence(ctx, presence);
 800d0da:	68bb      	ldr	r3, [r7, #8]
 800d0dc:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800d0de:	6839      	ldr	r1, [r7, #0]
 800d0e0:	68f8      	ldr	r0, [r7, #12]
 800d0e2:	4798      	blx	r3
 800d0e4:	4603      	mov	r3, r0
}
 800d0e6:	4618      	mov	r0, r3
 800d0e8:	3710      	adds	r7, #16
 800d0ea:	46bd      	mov	sp, r7
 800d0ec:	bd80      	pop	{r7, pc}

0800d0ee <Sensor_IO_Write>:
  * @param  nBytesToWrite number of bytes to be written
  * @retval 0 in case of success
  * @retval 1 in case of failure
  */
int32_t Sensor_IO_Write(void *handle, uint8_t WriteAddr, uint8_t *pBuffer, uint16_t nBytesToWrite)
{
 800d0ee:	b580      	push	{r7, lr}
 800d0f0:	b086      	sub	sp, #24
 800d0f2:	af00      	add	r7, sp, #0
 800d0f4:	60f8      	str	r0, [r7, #12]
 800d0f6:	607a      	str	r2, [r7, #4]
 800d0f8:	461a      	mov	r2, r3
 800d0fa:	460b      	mov	r3, r1
 800d0fc:	72fb      	strb	r3, [r7, #11]
 800d0fe:	4613      	mov	r3, r2
 800d100:	813b      	strh	r3, [r7, #8]

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
 800d102:	68fb      	ldr	r3, [r7, #12]
 800d104:	617b      	str	r3, [r7, #20]

  if (ctx->ifType == 0U)
 800d106:	697b      	ldr	r3, [r7, #20]
 800d108:	785b      	ldrb	r3, [r3, #1]
 800d10a:	2b00      	cmp	r3, #0
 800d10c:	d108      	bne.n	800d120 <Sensor_IO_Write+0x32>
  {
    return BSP_STC3115_0_I2C_WRITE_REG(STC3115_SLAVE_ADDRESS, WriteAddr, pBuffer, nBytesToWrite);
 800d10e:	7afb      	ldrb	r3, [r7, #11]
 800d110:	b299      	uxth	r1, r3
 800d112:	893b      	ldrh	r3, [r7, #8]
 800d114:	687a      	ldr	r2, [r7, #4]
 800d116:	20e0      	movs	r0, #224	@ 0xe0
 800d118:	f7f8 faaa 	bl	8005670 <BSP_I2C4_WriteReg>
 800d11c:	4603      	mov	r3, r0
 800d11e:	e000      	b.n	800d122 <Sensor_IO_Write+0x34>
  }

  return (int32_t) COMPONENT_ERROR;
 800d120:	2301      	movs	r3, #1
}
 800d122:	4618      	mov	r0, r3
 800d124:	3718      	adds	r7, #24
 800d126:	46bd      	mov	sp, r7
 800d128:	bd80      	pop	{r7, pc}

0800d12a <Sensor_IO_Read>:
  * @param  nBytesToRead number of bytes to be read
  * @retval 0 in case of success
  * @retval 1 in case of failure
  */
int32_t Sensor_IO_Read(void *handle, uint8_t ReadAddr, uint8_t *pBuffer, uint16_t nBytesToRead)
{
 800d12a:	b580      	push	{r7, lr}
 800d12c:	b086      	sub	sp, #24
 800d12e:	af00      	add	r7, sp, #0
 800d130:	60f8      	str	r0, [r7, #12]
 800d132:	607a      	str	r2, [r7, #4]
 800d134:	461a      	mov	r2, r3
 800d136:	460b      	mov	r3, r1
 800d138:	72fb      	strb	r3, [r7, #11]
 800d13a:	4613      	mov	r3, r2
 800d13c:	813b      	strh	r3, [r7, #8]

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
 800d13e:	68fb      	ldr	r3, [r7, #12]
 800d140:	617b      	str	r3, [r7, #20]

  if (ctx->ifType == 0U)
 800d142:	697b      	ldr	r3, [r7, #20]
 800d144:	785b      	ldrb	r3, [r3, #1]
 800d146:	2b00      	cmp	r3, #0
 800d148:	d108      	bne.n	800d15c <Sensor_IO_Read+0x32>
  {
    return BSP_STC3115_0_I2C_READ_REG(STC3115_SLAVE_ADDRESS, ReadAddr, pBuffer, nBytesToRead);
 800d14a:	7afb      	ldrb	r3, [r7, #11]
 800d14c:	b299      	uxth	r1, r3
 800d14e:	893b      	ldrh	r3, [r7, #8]
 800d150:	687a      	ldr	r2, [r7, #4]
 800d152:	20e0      	movs	r0, #224	@ 0xe0
 800d154:	f7f8 fabe 	bl	80056d4 <BSP_I2C4_ReadReg>
 800d158:	4603      	mov	r3, r0
 800d15a:	e000      	b.n	800d15e <Sensor_IO_Read+0x34>
  }

  return (int32_t) COMPONENT_ERROR;
 800d15c:	2301      	movs	r3, #1
}
 800d15e:	4618      	mov	r0, r3
 800d160:	3718      	adds	r7, #24
 800d162:	46bd      	mov	sp, r7
 800d164:	bd80      	pop	{r7, pc}
	...

0800d168 <BSP_MOTION_SENSOR_Init>:
  *         - MOTION_ACCELERO
  *         - MOTION_MAGNETO
  * @retval BSP status
  */
int32_t BSP_MOTION_SENSOR_Init(uint32_t Instance, uint32_t Functions)
{
 800d168:	b580      	push	{r7, lr}
 800d16a:	b08e      	sub	sp, #56	@ 0x38
 800d16c:	af00      	add	r7, sp, #0
 800d16e:	6078      	str	r0, [r7, #4]
 800d170:	6039      	str	r1, [r7, #0]
  int32_t ret = BSP_ERROR_NONE;
 800d172:	2300      	movs	r3, #0
 800d174:	637b      	str	r3, [r7, #52]	@ 0x34
  uint32_t function = MOTION_GYRO;
 800d176:	2301      	movs	r3, #1
 800d178:	633b      	str	r3, [r7, #48]	@ 0x30
  uint32_t i;
  uint32_t component_functions = 0;
 800d17a:	2300      	movs	r3, #0
 800d17c:	62bb      	str	r3, [r7, #40]	@ 0x28
  BSP_MOTION_SENSOR_Capabilities_t cap;

  switch (Instance)
 800d17e:	687b      	ldr	r3, [r7, #4]
 800d180:	2b02      	cmp	r3, #2
 800d182:	d06e      	beq.n	800d262 <BSP_MOTION_SENSOR_Init+0xfa>
 800d184:	687b      	ldr	r3, [r7, #4]
 800d186:	2b02      	cmp	r3, #2
 800d188:	f200 809d 	bhi.w	800d2c6 <BSP_MOTION_SENSOR_Init+0x15e>
 800d18c:	687b      	ldr	r3, [r7, #4]
 800d18e:	2b00      	cmp	r3, #0
 800d190:	d003      	beq.n	800d19a <BSP_MOTION_SENSOR_Init+0x32>
 800d192:	687b      	ldr	r3, [r7, #4]
 800d194:	2b01      	cmp	r3, #1
 800d196:	d032      	beq.n	800d1fe <BSP_MOTION_SENSOR_Init+0x96>
 800d198:	e095      	b.n	800d2c6 <BSP_MOTION_SENSOR_Init+0x15e>
  {
#if (USE_MOTION_SENSOR_LIS2MDL_0 == 1)
    case LIS2MDL_0:
      if (LIS2MDL_0_Probe(Functions) != BSP_ERROR_NONE)
 800d19a:	6838      	ldr	r0, [r7, #0]
 800d19c:	f000 f968 	bl	800d470 <LIS2MDL_0_Probe>
 800d1a0:	4603      	mov	r3, r0
 800d1a2:	2b00      	cmp	r3, #0
 800d1a4:	d002      	beq.n	800d1ac <BSP_MOTION_SENSOR_Init+0x44>
      {
        return BSP_ERROR_NO_INIT;
 800d1a6:	f04f 33ff 	mov.w	r3, #4294967295
 800d1aa:	e0cc      	b.n	800d346 <BSP_MOTION_SENSOR_Init+0x1de>
      }
      if (MotionDrv[Instance]->GetCapabilities(MotionCompObj[Instance], (void *)&cap) != BSP_ERROR_NONE)
 800d1ac:	4a68      	ldr	r2, [pc, #416]	@ (800d350 <BSP_MOTION_SENSOR_Init+0x1e8>)
 800d1ae:	687b      	ldr	r3, [r7, #4]
 800d1b0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800d1b4:	68db      	ldr	r3, [r3, #12]
 800d1b6:	4967      	ldr	r1, [pc, #412]	@ (800d354 <BSP_MOTION_SENSOR_Init+0x1ec>)
 800d1b8:	687a      	ldr	r2, [r7, #4]
 800d1ba:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 800d1be:	f107 010c 	add.w	r1, r7, #12
 800d1c2:	4610      	mov	r0, r2
 800d1c4:	4798      	blx	r3
 800d1c6:	4603      	mov	r3, r0
 800d1c8:	2b00      	cmp	r3, #0
 800d1ca:	d002      	beq.n	800d1d2 <BSP_MOTION_SENSOR_Init+0x6a>
      {
        return BSP_ERROR_UNKNOWN_COMPONENT;
 800d1cc:	f06f 0306 	mvn.w	r3, #6
 800d1d0:	e0b9      	b.n	800d346 <BSP_MOTION_SENSOR_Init+0x1de>
      }
      if (cap.Acc == 1U)
 800d1d2:	7b3b      	ldrb	r3, [r7, #12]
 800d1d4:	2b01      	cmp	r3, #1
 800d1d6:	d103      	bne.n	800d1e0 <BSP_MOTION_SENSOR_Init+0x78>
      {
        component_functions |= MOTION_ACCELERO;
 800d1d8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800d1da:	f043 0302 	orr.w	r3, r3, #2
 800d1de:	62bb      	str	r3, [r7, #40]	@ 0x28
      }
      if (cap.Gyro == 1U)
 800d1e0:	7b7b      	ldrb	r3, [r7, #13]
 800d1e2:	2b01      	cmp	r3, #1
 800d1e4:	d103      	bne.n	800d1ee <BSP_MOTION_SENSOR_Init+0x86>
      {
        component_functions |= MOTION_GYRO;
 800d1e6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800d1e8:	f043 0301 	orr.w	r3, r3, #1
 800d1ec:	62bb      	str	r3, [r7, #40]	@ 0x28
      }
      if (cap.Magneto == 1U)
 800d1ee:	7bbb      	ldrb	r3, [r7, #14]
 800d1f0:	2b01      	cmp	r3, #1
 800d1f2:	d16c      	bne.n	800d2ce <BSP_MOTION_SENSOR_Init+0x166>
      {
        component_functions |= MOTION_MAGNETO;
 800d1f4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800d1f6:	f043 0304 	orr.w	r3, r3, #4
 800d1fa:	62bb      	str	r3, [r7, #40]	@ 0x28
      }
      break;
 800d1fc:	e067      	b.n	800d2ce <BSP_MOTION_SENSOR_Init+0x166>
#endif /* USE_MOTION_SENSOR_LIS2MDL_0 == 1 */
#if (USE_MOTION_SENSOR_LIS2DU12_0 == 1)
    case LIS2DU12_0:
      if (LIS2DU12_0_Probe(Functions) != BSP_ERROR_NONE)
 800d1fe:	6838      	ldr	r0, [r7, #0]
 800d200:	f000 f9da 	bl	800d5b8 <LIS2DU12_0_Probe>
 800d204:	4603      	mov	r3, r0
 800d206:	2b00      	cmp	r3, #0
 800d208:	d002      	beq.n	800d210 <BSP_MOTION_SENSOR_Init+0xa8>
      {
        return BSP_ERROR_NO_INIT;
 800d20a:	f04f 33ff 	mov.w	r3, #4294967295
 800d20e:	e09a      	b.n	800d346 <BSP_MOTION_SENSOR_Init+0x1de>
      }
      if (MotionDrv[Instance]->GetCapabilities(MotionCompObj[Instance], (void *)&cap) != BSP_ERROR_NONE)
 800d210:	4a4f      	ldr	r2, [pc, #316]	@ (800d350 <BSP_MOTION_SENSOR_Init+0x1e8>)
 800d212:	687b      	ldr	r3, [r7, #4]
 800d214:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800d218:	68db      	ldr	r3, [r3, #12]
 800d21a:	494e      	ldr	r1, [pc, #312]	@ (800d354 <BSP_MOTION_SENSOR_Init+0x1ec>)
 800d21c:	687a      	ldr	r2, [r7, #4]
 800d21e:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 800d222:	f107 010c 	add.w	r1, r7, #12
 800d226:	4610      	mov	r0, r2
 800d228:	4798      	blx	r3
 800d22a:	4603      	mov	r3, r0
 800d22c:	2b00      	cmp	r3, #0
 800d22e:	d002      	beq.n	800d236 <BSP_MOTION_SENSOR_Init+0xce>
      {
        return BSP_ERROR_UNKNOWN_COMPONENT;
 800d230:	f06f 0306 	mvn.w	r3, #6
 800d234:	e087      	b.n	800d346 <BSP_MOTION_SENSOR_Init+0x1de>
      }
      if (cap.Acc == 1U)
 800d236:	7b3b      	ldrb	r3, [r7, #12]
 800d238:	2b01      	cmp	r3, #1
 800d23a:	d103      	bne.n	800d244 <BSP_MOTION_SENSOR_Init+0xdc>
      {
        component_functions |= MOTION_ACCELERO;
 800d23c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800d23e:	f043 0302 	orr.w	r3, r3, #2
 800d242:	62bb      	str	r3, [r7, #40]	@ 0x28
      }
      if (cap.Gyro == 1U)
 800d244:	7b7b      	ldrb	r3, [r7, #13]
 800d246:	2b01      	cmp	r3, #1
 800d248:	d103      	bne.n	800d252 <BSP_MOTION_SENSOR_Init+0xea>
      {
        component_functions |= MOTION_GYRO;
 800d24a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800d24c:	f043 0301 	orr.w	r3, r3, #1
 800d250:	62bb      	str	r3, [r7, #40]	@ 0x28
      }
      if (cap.Magneto == 1U)
 800d252:	7bbb      	ldrb	r3, [r7, #14]
 800d254:	2b01      	cmp	r3, #1
 800d256:	d13c      	bne.n	800d2d2 <BSP_MOTION_SENSOR_Init+0x16a>
      {
        component_functions |= MOTION_MAGNETO;
 800d258:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800d25a:	f043 0304 	orr.w	r3, r3, #4
 800d25e:	62bb      	str	r3, [r7, #40]	@ 0x28
      }
      break;
 800d260:	e037      	b.n	800d2d2 <BSP_MOTION_SENSOR_Init+0x16a>
#endif /* USE_MOTION_SENSOR_LIS2DU12_0 == 1 */
#if (USE_MOTION_SENSOR_LSM6DSV16X_0 == 1)
    case LSM6DSV16X_0:
      if (LSM6DSV16X_0_Probe(Functions) != BSP_ERROR_NONE)
 800d262:	6838      	ldr	r0, [r7, #0]
 800d264:	f000 fa4c 	bl	800d700 <LSM6DSV16X_0_Probe>
 800d268:	4603      	mov	r3, r0
 800d26a:	2b00      	cmp	r3, #0
 800d26c:	d002      	beq.n	800d274 <BSP_MOTION_SENSOR_Init+0x10c>
      {
        return BSP_ERROR_NO_INIT;
 800d26e:	f04f 33ff 	mov.w	r3, #4294967295
 800d272:	e068      	b.n	800d346 <BSP_MOTION_SENSOR_Init+0x1de>
      }
      if (MotionDrv[Instance]->GetCapabilities(MotionCompObj[Instance], (void *)&cap) != BSP_ERROR_NONE)
 800d274:	4a36      	ldr	r2, [pc, #216]	@ (800d350 <BSP_MOTION_SENSOR_Init+0x1e8>)
 800d276:	687b      	ldr	r3, [r7, #4]
 800d278:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800d27c:	68db      	ldr	r3, [r3, #12]
 800d27e:	4935      	ldr	r1, [pc, #212]	@ (800d354 <BSP_MOTION_SENSOR_Init+0x1ec>)
 800d280:	687a      	ldr	r2, [r7, #4]
 800d282:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 800d286:	f107 010c 	add.w	r1, r7, #12
 800d28a:	4610      	mov	r0, r2
 800d28c:	4798      	blx	r3
 800d28e:	4603      	mov	r3, r0
 800d290:	2b00      	cmp	r3, #0
 800d292:	d002      	beq.n	800d29a <BSP_MOTION_SENSOR_Init+0x132>
      {
        return BSP_ERROR_UNKNOWN_COMPONENT;
 800d294:	f06f 0306 	mvn.w	r3, #6
 800d298:	e055      	b.n	800d346 <BSP_MOTION_SENSOR_Init+0x1de>
      }
      if (cap.Acc == 1U)
 800d29a:	7b3b      	ldrb	r3, [r7, #12]
 800d29c:	2b01      	cmp	r3, #1
 800d29e:	d103      	bne.n	800d2a8 <BSP_MOTION_SENSOR_Init+0x140>
      {
        component_functions |= MOTION_ACCELERO;
 800d2a0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800d2a2:	f043 0302 	orr.w	r3, r3, #2
 800d2a6:	62bb      	str	r3, [r7, #40]	@ 0x28
      }
      if (cap.Gyro == 1U)
 800d2a8:	7b7b      	ldrb	r3, [r7, #13]
 800d2aa:	2b01      	cmp	r3, #1
 800d2ac:	d103      	bne.n	800d2b6 <BSP_MOTION_SENSOR_Init+0x14e>
      {
        component_functions |= MOTION_GYRO;
 800d2ae:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800d2b0:	f043 0301 	orr.w	r3, r3, #1
 800d2b4:	62bb      	str	r3, [r7, #40]	@ 0x28
      }
      if (cap.Magneto == 1U)
 800d2b6:	7bbb      	ldrb	r3, [r7, #14]
 800d2b8:	2b01      	cmp	r3, #1
 800d2ba:	d10c      	bne.n	800d2d6 <BSP_MOTION_SENSOR_Init+0x16e>
      {
        component_functions |= MOTION_MAGNETO;
 800d2bc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800d2be:	f043 0304 	orr.w	r3, r3, #4
 800d2c2:	62bb      	str	r3, [r7, #40]	@ 0x28
      }
      break;
 800d2c4:	e007      	b.n	800d2d6 <BSP_MOTION_SENSOR_Init+0x16e>
#endif /* USE_MOTION_SENSOR_LSM6DSV16X_0 == 1 */
    default:
      ret = BSP_ERROR_WRONG_PARAM;
 800d2c6:	f06f 0301 	mvn.w	r3, #1
 800d2ca:	637b      	str	r3, [r7, #52]	@ 0x34
      break;
 800d2cc:	e004      	b.n	800d2d8 <BSP_MOTION_SENSOR_Init+0x170>
      break;
 800d2ce:	bf00      	nop
 800d2d0:	e002      	b.n	800d2d8 <BSP_MOTION_SENSOR_Init+0x170>
      break;
 800d2d2:	bf00      	nop
 800d2d4:	e000      	b.n	800d2d8 <BSP_MOTION_SENSOR_Init+0x170>
      break;
 800d2d6:	bf00      	nop
  }

  if (ret != BSP_ERROR_NONE)
 800d2d8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800d2da:	2b00      	cmp	r3, #0
 800d2dc:	d001      	beq.n	800d2e2 <BSP_MOTION_SENSOR_Init+0x17a>
  {
    return ret;
 800d2de:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800d2e0:	e031      	b.n	800d346 <BSP_MOTION_SENSOR_Init+0x1de>
  }

  for (i = 0; i < BSP_MOTION_FUNCTIONS_NBR; i++)
 800d2e2:	2300      	movs	r3, #0
 800d2e4:	62fb      	str	r3, [r7, #44]	@ 0x2c
 800d2e6:	e02a      	b.n	800d33e <BSP_MOTION_SENSOR_Init+0x1d6>
  {
    if (((Functions & function) == function) && ((component_functions & function) == function))
 800d2e8:	683a      	ldr	r2, [r7, #0]
 800d2ea:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800d2ec:	4013      	ands	r3, r2
 800d2ee:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 800d2f0:	429a      	cmp	r2, r3
 800d2f2:	d11e      	bne.n	800d332 <BSP_MOTION_SENSOR_Init+0x1ca>
 800d2f4:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 800d2f6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800d2f8:	4013      	ands	r3, r2
 800d2fa:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 800d2fc:	429a      	cmp	r2, r3
 800d2fe:	d118      	bne.n	800d332 <BSP_MOTION_SENSOR_Init+0x1ca>
    {
      if (MotionFuncDrv[Instance][FunctionIndex[function]]->Enable(MotionCompObj[Instance]) != BSP_ERROR_NONE)
 800d300:	4a15      	ldr	r2, [pc, #84]	@ (800d358 <BSP_MOTION_SENSOR_Init+0x1f0>)
 800d302:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800d304:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
 800d308:	4814      	ldr	r0, [pc, #80]	@ (800d35c <BSP_MOTION_SENSOR_Init+0x1f4>)
 800d30a:	687a      	ldr	r2, [r7, #4]
 800d30c:	4613      	mov	r3, r2
 800d30e:	005b      	lsls	r3, r3, #1
 800d310:	4413      	add	r3, r2
 800d312:	440b      	add	r3, r1
 800d314:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 800d318:	681b      	ldr	r3, [r3, #0]
 800d31a:	490e      	ldr	r1, [pc, #56]	@ (800d354 <BSP_MOTION_SENSOR_Init+0x1ec>)
 800d31c:	687a      	ldr	r2, [r7, #4]
 800d31e:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 800d322:	4610      	mov	r0, r2
 800d324:	4798      	blx	r3
 800d326:	4603      	mov	r3, r0
 800d328:	2b00      	cmp	r3, #0
 800d32a:	d002      	beq.n	800d332 <BSP_MOTION_SENSOR_Init+0x1ca>
      {
        return BSP_ERROR_COMPONENT_FAILURE;
 800d32c:	f06f 0304 	mvn.w	r3, #4
 800d330:	e009      	b.n	800d346 <BSP_MOTION_SENSOR_Init+0x1de>
      }
    }
    function = function << 1;
 800d332:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800d334:	005b      	lsls	r3, r3, #1
 800d336:	633b      	str	r3, [r7, #48]	@ 0x30
  for (i = 0; i < BSP_MOTION_FUNCTIONS_NBR; i++)
 800d338:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800d33a:	3301      	adds	r3, #1
 800d33c:	62fb      	str	r3, [r7, #44]	@ 0x2c
 800d33e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800d340:	2b02      	cmp	r3, #2
 800d342:	d9d1      	bls.n	800d2e8 <BSP_MOTION_SENSOR_Init+0x180>
  }

  return ret;
 800d344:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
}
 800d346:	4618      	mov	r0, r3
 800d348:	3738      	adds	r7, #56	@ 0x38
 800d34a:	46bd      	mov	sp, r7
 800d34c:	bd80      	pop	{r7, pc}
 800d34e:	bf00      	nop
 800d350:	20000d18 	.word	0x20000d18
 800d354:	20000ce8 	.word	0x20000ce8
 800d358:	200001c0 	.word	0x200001c0
 800d35c:	20000cf4 	.word	0x20000cf4

0800d360 <BSP_MOTION_SENSOR_SetOutputDataRate>:
  *         - MOTION_MAGNETO
  * @param  Odr Output Data Rate value to be set
  * @retval BSP status
  */
int32_t BSP_MOTION_SENSOR_SetOutputDataRate(uint32_t Instance, uint32_t Function, float Odr)
{
 800d360:	b580      	push	{r7, lr}
 800d362:	b086      	sub	sp, #24
 800d364:	af00      	add	r7, sp, #0
 800d366:	60f8      	str	r0, [r7, #12]
 800d368:	60b9      	str	r1, [r7, #8]
 800d36a:	607a      	str	r2, [r7, #4]
  int32_t ret;

  if (Instance >= BSP_MOTION_INSTANCES_NBR)
 800d36c:	68fb      	ldr	r3, [r7, #12]
 800d36e:	2b02      	cmp	r3, #2
 800d370:	d903      	bls.n	800d37a <BSP_MOTION_SENSOR_SetOutputDataRate+0x1a>
  {
    ret = BSP_ERROR_WRONG_PARAM;
 800d372:	f06f 0301 	mvn.w	r3, #1
 800d376:	617b      	str	r3, [r7, #20]
 800d378:	e029      	b.n	800d3ce <BSP_MOTION_SENSOR_SetOutputDataRate+0x6e>
  }
  else
  {
    if ((MotionCtx[Instance].Functions & Function) == Function)
 800d37a:	4a17      	ldr	r2, [pc, #92]	@ (800d3d8 <BSP_MOTION_SENSOR_SetOutputDataRate+0x78>)
 800d37c:	68fb      	ldr	r3, [r7, #12]
 800d37e:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 800d382:	68bb      	ldr	r3, [r7, #8]
 800d384:	4013      	ands	r3, r2
 800d386:	68ba      	ldr	r2, [r7, #8]
 800d388:	429a      	cmp	r2, r3
 800d38a:	d11d      	bne.n	800d3c8 <BSP_MOTION_SENSOR_SetOutputDataRate+0x68>
    {
      if (MotionFuncDrv[Instance][FunctionIndex[Function]]->SetOutputDataRate(MotionCompObj[Instance],
 800d38c:	4a13      	ldr	r2, [pc, #76]	@ (800d3dc <BSP_MOTION_SENSOR_SetOutputDataRate+0x7c>)
 800d38e:	68bb      	ldr	r3, [r7, #8]
 800d390:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
 800d394:	4812      	ldr	r0, [pc, #72]	@ (800d3e0 <BSP_MOTION_SENSOR_SetOutputDataRate+0x80>)
 800d396:	68fa      	ldr	r2, [r7, #12]
 800d398:	4613      	mov	r3, r2
 800d39a:	005b      	lsls	r3, r3, #1
 800d39c:	4413      	add	r3, r2
 800d39e:	440b      	add	r3, r1
 800d3a0:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 800d3a4:	691b      	ldr	r3, [r3, #16]
 800d3a6:	490f      	ldr	r1, [pc, #60]	@ (800d3e4 <BSP_MOTION_SENSOR_SetOutputDataRate+0x84>)
 800d3a8:	68fa      	ldr	r2, [r7, #12]
 800d3aa:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 800d3ae:	6879      	ldr	r1, [r7, #4]
 800d3b0:	4610      	mov	r0, r2
 800d3b2:	4798      	blx	r3
 800d3b4:	4603      	mov	r3, r0
 800d3b6:	2b00      	cmp	r3, #0
 800d3b8:	d003      	beq.n	800d3c2 <BSP_MOTION_SENSOR_SetOutputDataRate+0x62>
                                                                              Odr) != BSP_ERROR_NONE)
      {
        ret = BSP_ERROR_COMPONENT_FAILURE;
 800d3ba:	f06f 0304 	mvn.w	r3, #4
 800d3be:	617b      	str	r3, [r7, #20]
 800d3c0:	e005      	b.n	800d3ce <BSP_MOTION_SENSOR_SetOutputDataRate+0x6e>
      }
      else
      {
        ret = BSP_ERROR_NONE;
 800d3c2:	2300      	movs	r3, #0
 800d3c4:	617b      	str	r3, [r7, #20]
 800d3c6:	e002      	b.n	800d3ce <BSP_MOTION_SENSOR_SetOutputDataRate+0x6e>
      }
    }
    else
    {
      ret = BSP_ERROR_WRONG_PARAM;
 800d3c8:	f06f 0301 	mvn.w	r3, #1
 800d3cc:	617b      	str	r3, [r7, #20]
    }
  }

  return ret;
 800d3ce:	697b      	ldr	r3, [r7, #20]
}
 800d3d0:	4618      	mov	r0, r3
 800d3d2:	3718      	adds	r7, #24
 800d3d4:	46bd      	mov	sp, r7
 800d3d6:	bd80      	pop	{r7, pc}
 800d3d8:	20000d24 	.word	0x20000d24
 800d3dc:	200001c0 	.word	0x200001c0
 800d3e0:	20000cf4 	.word	0x20000cf4
 800d3e4:	20000ce8 	.word	0x20000ce8

0800d3e8 <BSP_MOTION_SENSOR_SetFullScale>:
  *         - MOTION_MAGNETO
  * @param  Fullscale Fullscale value to be set
  * @retval BSP status
  */
int32_t BSP_MOTION_SENSOR_SetFullScale(uint32_t Instance, uint32_t Function, int32_t Fullscale)
{
 800d3e8:	b580      	push	{r7, lr}
 800d3ea:	b086      	sub	sp, #24
 800d3ec:	af00      	add	r7, sp, #0
 800d3ee:	60f8      	str	r0, [r7, #12]
 800d3f0:	60b9      	str	r1, [r7, #8]
 800d3f2:	607a      	str	r2, [r7, #4]
  int32_t ret;

  if (Instance >= BSP_MOTION_INSTANCES_NBR)
 800d3f4:	68fb      	ldr	r3, [r7, #12]
 800d3f6:	2b02      	cmp	r3, #2
 800d3f8:	d903      	bls.n	800d402 <BSP_MOTION_SENSOR_SetFullScale+0x1a>
  {
    ret = BSP_ERROR_WRONG_PARAM;
 800d3fa:	f06f 0301 	mvn.w	r3, #1
 800d3fe:	617b      	str	r3, [r7, #20]
 800d400:	e029      	b.n	800d456 <BSP_MOTION_SENSOR_SetFullScale+0x6e>
  }
  else
  {
    if ((MotionCtx[Instance].Functions & Function) == Function)
 800d402:	4a17      	ldr	r2, [pc, #92]	@ (800d460 <BSP_MOTION_SENSOR_SetFullScale+0x78>)
 800d404:	68fb      	ldr	r3, [r7, #12]
 800d406:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 800d40a:	68bb      	ldr	r3, [r7, #8]
 800d40c:	4013      	ands	r3, r2
 800d40e:	68ba      	ldr	r2, [r7, #8]
 800d410:	429a      	cmp	r2, r3
 800d412:	d11d      	bne.n	800d450 <BSP_MOTION_SENSOR_SetFullScale+0x68>
    {
      if (MotionFuncDrv[Instance][FunctionIndex[Function]]->SetFullScale(MotionCompObj[Instance],
 800d414:	4a13      	ldr	r2, [pc, #76]	@ (800d464 <BSP_MOTION_SENSOR_SetFullScale+0x7c>)
 800d416:	68bb      	ldr	r3, [r7, #8]
 800d418:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
 800d41c:	4812      	ldr	r0, [pc, #72]	@ (800d468 <BSP_MOTION_SENSOR_SetFullScale+0x80>)
 800d41e:	68fa      	ldr	r2, [r7, #12]
 800d420:	4613      	mov	r3, r2
 800d422:	005b      	lsls	r3, r3, #1
 800d424:	4413      	add	r3, r2
 800d426:	440b      	add	r3, r1
 800d428:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 800d42c:	699b      	ldr	r3, [r3, #24]
 800d42e:	490f      	ldr	r1, [pc, #60]	@ (800d46c <BSP_MOTION_SENSOR_SetFullScale+0x84>)
 800d430:	68fa      	ldr	r2, [r7, #12]
 800d432:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 800d436:	6879      	ldr	r1, [r7, #4]
 800d438:	4610      	mov	r0, r2
 800d43a:	4798      	blx	r3
 800d43c:	4603      	mov	r3, r0
 800d43e:	2b00      	cmp	r3, #0
 800d440:	d003      	beq.n	800d44a <BSP_MOTION_SENSOR_SetFullScale+0x62>
                                                                         Fullscale) != BSP_ERROR_NONE)
      {
        ret = BSP_ERROR_COMPONENT_FAILURE;
 800d442:	f06f 0304 	mvn.w	r3, #4
 800d446:	617b      	str	r3, [r7, #20]
 800d448:	e005      	b.n	800d456 <BSP_MOTION_SENSOR_SetFullScale+0x6e>
      }
      else
      {
        ret = BSP_ERROR_NONE;
 800d44a:	2300      	movs	r3, #0
 800d44c:	617b      	str	r3, [r7, #20]
 800d44e:	e002      	b.n	800d456 <BSP_MOTION_SENSOR_SetFullScale+0x6e>
      }
    }
    else
    {
      ret = BSP_ERROR_WRONG_PARAM;
 800d450:	f06f 0301 	mvn.w	r3, #1
 800d454:	617b      	str	r3, [r7, #20]
    }
  }

  return ret;
 800d456:	697b      	ldr	r3, [r7, #20]
}
 800d458:	4618      	mov	r0, r3
 800d45a:	3718      	adds	r7, #24
 800d45c:	46bd      	mov	sp, r7
 800d45e:	bd80      	pop	{r7, pc}
 800d460:	20000d24 	.word	0x20000d24
 800d464:	200001c0 	.word	0x200001c0
 800d468:	20000cf4 	.word	0x20000cf4
 800d46c:	20000ce8 	.word	0x20000ce8

0800d470 <LIS2MDL_0_Probe>:
  * @param  Functions Motion sensor functions. Could be :
  *         - MOTION_MAGNETO
  * @retval BSP status
  */
static int32_t LIS2MDL_0_Probe(uint32_t Functions)
{
 800d470:	b580      	push	{r7, lr}
 800d472:	b094      	sub	sp, #80	@ 0x50
 800d474:	af00      	add	r7, sp, #0
 800d476:	6078      	str	r0, [r7, #4]
  LIS2MDL_IO_t            io_ctx;
  uint8_t                 id;
  static LIS2MDL_Object_t lis2mdl_obj_0;
  LIS2MDL_Capabilities_t  cap;
  int32_t                 ret = BSP_ERROR_NONE;
 800d478:	2300      	movs	r3, #0
 800d47a:	64fb      	str	r3, [r7, #76]	@ 0x4c

  /* Configure the driver */
  io_ctx.BusType     = LIS2MDL_I2C_BUS; /* I2C */
 800d47c:	2300      	movs	r3, #0
 800d47e:	637b      	str	r3, [r7, #52]	@ 0x34
  io_ctx.Address     = LIS2MDL_I2C_ADD;
 800d480:	233d      	movs	r3, #61	@ 0x3d
 800d482:	f887 3038 	strb.w	r3, [r7, #56]	@ 0x38
  io_ctx.Init        = BSP_LIS2MDL_0_I2C_INIT;
 800d486:	4b3f      	ldr	r3, [pc, #252]	@ (800d584 <LIS2MDL_0_Probe+0x114>)
 800d488:	62fb      	str	r3, [r7, #44]	@ 0x2c
  io_ctx.DeInit      = BSP_LIS2MDL_0_I2C_DEINIT;
 800d48a:	4b3f      	ldr	r3, [pc, #252]	@ (800d588 <LIS2MDL_0_Probe+0x118>)
 800d48c:	633b      	str	r3, [r7, #48]	@ 0x30
  io_ctx.ReadReg     = BSP_LIS2MDL_0_I2C_READ_REG;
 800d48e:	4b3f      	ldr	r3, [pc, #252]	@ (800d58c <LIS2MDL_0_Probe+0x11c>)
 800d490:	643b      	str	r3, [r7, #64]	@ 0x40
  io_ctx.WriteReg    = BSP_LIS2MDL_0_I2C_WRITE_REG;
 800d492:	4b3f      	ldr	r3, [pc, #252]	@ (800d590 <LIS2MDL_0_Probe+0x120>)
 800d494:	63fb      	str	r3, [r7, #60]	@ 0x3c
  io_ctx.GetTick     = BSP_GetTick;
 800d496:	4b3f      	ldr	r3, [pc, #252]	@ (800d594 <LIS2MDL_0_Probe+0x124>)
 800d498:	647b      	str	r3, [r7, #68]	@ 0x44

  if (LIS2MDL_RegisterBusIO(&lis2mdl_obj_0, &io_ctx) != LIS2MDL_OK)
 800d49a:	f107 032c 	add.w	r3, r7, #44	@ 0x2c
 800d49e:	4619      	mov	r1, r3
 800d4a0:	483d      	ldr	r0, [pc, #244]	@ (800d598 <LIS2MDL_0_Probe+0x128>)
 800d4a2:	f7fb f967 	bl	8008774 <LIS2MDL_RegisterBusIO>
 800d4a6:	4603      	mov	r3, r0
 800d4a8:	2b00      	cmp	r3, #0
 800d4aa:	d003      	beq.n	800d4b4 <LIS2MDL_0_Probe+0x44>
  {
    ret = BSP_ERROR_UNKNOWN_COMPONENT;
 800d4ac:	f06f 0306 	mvn.w	r3, #6
 800d4b0:	64fb      	str	r3, [r7, #76]	@ 0x4c
 800d4b2:	e061      	b.n	800d578 <LIS2MDL_0_Probe+0x108>
  }
  else if (LIS2MDL_ReadID(&lis2mdl_obj_0, &id) != LIS2MDL_OK)
 800d4b4:	f107 032b 	add.w	r3, r7, #43	@ 0x2b
 800d4b8:	4619      	mov	r1, r3
 800d4ba:	4837      	ldr	r0, [pc, #220]	@ (800d598 <LIS2MDL_0_Probe+0x128>)
 800d4bc:	f7fb fa76 	bl	80089ac <LIS2MDL_ReadID>
 800d4c0:	4603      	mov	r3, r0
 800d4c2:	2b00      	cmp	r3, #0
 800d4c4:	d003      	beq.n	800d4ce <LIS2MDL_0_Probe+0x5e>
  {
    ret = BSP_ERROR_UNKNOWN_COMPONENT;
 800d4c6:	f06f 0306 	mvn.w	r3, #6
 800d4ca:	64fb      	str	r3, [r7, #76]	@ 0x4c
 800d4cc:	e054      	b.n	800d578 <LIS2MDL_0_Probe+0x108>
  }
  else if (id != (uint8_t)LIS2MDL_ID)
 800d4ce:	f897 302b 	ldrb.w	r3, [r7, #43]	@ 0x2b
 800d4d2:	2b40      	cmp	r3, #64	@ 0x40
 800d4d4:	d003      	beq.n	800d4de <LIS2MDL_0_Probe+0x6e>
  {
    ret = BSP_ERROR_UNKNOWN_COMPONENT;
 800d4d6:	f06f 0306 	mvn.w	r3, #6
 800d4da:	64fb      	str	r3, [r7, #76]	@ 0x4c
 800d4dc:	e04c      	b.n	800d578 <LIS2MDL_0_Probe+0x108>
  }
  else
  {
    (void)LIS2MDL_GetCapabilities(&lis2mdl_obj_0, &cap);
 800d4de:	f107 030c 	add.w	r3, r7, #12
 800d4e2:	4619      	mov	r1, r3
 800d4e4:	482c      	ldr	r0, [pc, #176]	@ (800d598 <LIS2MDL_0_Probe+0x128>)
 800d4e6:	f7fb fa87 	bl	80089f8 <LIS2MDL_GetCapabilities>
    MotionCtx[LIS2MDL_0].Functions = ((uint32_t)cap.Gyro) | ((uint32_t)cap.Acc << 1) | ((uint32_t)cap.Magneto << 2);
 800d4ea:	7b7b      	ldrb	r3, [r7, #13]
 800d4ec:	461a      	mov	r2, r3
 800d4ee:	7b3b      	ldrb	r3, [r7, #12]
 800d4f0:	005b      	lsls	r3, r3, #1
 800d4f2:	431a      	orrs	r2, r3
 800d4f4:	7bbb      	ldrb	r3, [r7, #14]
 800d4f6:	009b      	lsls	r3, r3, #2
 800d4f8:	4313      	orrs	r3, r2
 800d4fa:	4a28      	ldr	r2, [pc, #160]	@ (800d59c <LIS2MDL_0_Probe+0x12c>)
 800d4fc:	6013      	str	r3, [r2, #0]

    MotionCompObj[LIS2MDL_0] = &lis2mdl_obj_0;
 800d4fe:	4b28      	ldr	r3, [pc, #160]	@ (800d5a0 <LIS2MDL_0_Probe+0x130>)
 800d500:	4a25      	ldr	r2, [pc, #148]	@ (800d598 <LIS2MDL_0_Probe+0x128>)
 800d502:	601a      	str	r2, [r3, #0]
    /* The second cast (void *) is added to bypass Misra R11.3 rule */
    MotionDrv[LIS2MDL_0] = (MOTION_SENSOR_CommonDrv_t *)(void *)&LIS2MDL_COMMON_Driver;
 800d504:	4b27      	ldr	r3, [pc, #156]	@ (800d5a4 <LIS2MDL_0_Probe+0x134>)
 800d506:	4a28      	ldr	r2, [pc, #160]	@ (800d5a8 <LIS2MDL_0_Probe+0x138>)
 800d508:	601a      	str	r2, [r3, #0]

    if ((ret == BSP_ERROR_NONE) && ((Functions & MOTION_MAGNETO) == MOTION_MAGNETO) && (cap.Magneto == 1U))
 800d50a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800d50c:	2b00      	cmp	r3, #0
 800d50e:	d11d      	bne.n	800d54c <LIS2MDL_0_Probe+0xdc>
 800d510:	687b      	ldr	r3, [r7, #4]
 800d512:	f003 0304 	and.w	r3, r3, #4
 800d516:	2b00      	cmp	r3, #0
 800d518:	d018      	beq.n	800d54c <LIS2MDL_0_Probe+0xdc>
 800d51a:	7bbb      	ldrb	r3, [r7, #14]
 800d51c:	2b01      	cmp	r3, #1
 800d51e:	d115      	bne.n	800d54c <LIS2MDL_0_Probe+0xdc>
    {
      /* The second cast (void *) is added to bypass Misra R11.3 rule */
      MotionFuncDrv[LIS2MDL_0][FunctionIndex[MOTION_MAGNETO]] = (MOTION_SENSOR_FuncDrv_t *)(void *)&LIS2MDL_MAG_Driver;
 800d520:	4b22      	ldr	r3, [pc, #136]	@ (800d5ac <LIS2MDL_0_Probe+0x13c>)
 800d522:	691b      	ldr	r3, [r3, #16]
 800d524:	4a22      	ldr	r2, [pc, #136]	@ (800d5b0 <LIS2MDL_0_Probe+0x140>)
 800d526:	4923      	ldr	r1, [pc, #140]	@ (800d5b4 <LIS2MDL_0_Probe+0x144>)
 800d528:	f842 1023 	str.w	r1, [r2, r3, lsl #2]

      if (MotionDrv[LIS2MDL_0]->Init(MotionCompObj[LIS2MDL_0]) != LIS2MDL_OK)
 800d52c:	4b1d      	ldr	r3, [pc, #116]	@ (800d5a4 <LIS2MDL_0_Probe+0x134>)
 800d52e:	681b      	ldr	r3, [r3, #0]
 800d530:	681b      	ldr	r3, [r3, #0]
 800d532:	4a1b      	ldr	r2, [pc, #108]	@ (800d5a0 <LIS2MDL_0_Probe+0x130>)
 800d534:	6812      	ldr	r2, [r2, #0]
 800d536:	4610      	mov	r0, r2
 800d538:	4798      	blx	r3
 800d53a:	4603      	mov	r3, r0
 800d53c:	2b00      	cmp	r3, #0
 800d53e:	d003      	beq.n	800d548 <LIS2MDL_0_Probe+0xd8>
      {
        ret = BSP_ERROR_COMPONENT_FAILURE;
 800d540:	f06f 0304 	mvn.w	r3, #4
 800d544:	64fb      	str	r3, [r7, #76]	@ 0x4c
 800d546:	e001      	b.n	800d54c <LIS2MDL_0_Probe+0xdc>
      }
      else
      {
        ret = BSP_ERROR_NONE;
 800d548:	2300      	movs	r3, #0
 800d54a:	64fb      	str	r3, [r7, #76]	@ 0x4c
      }
    }
    if ((ret == BSP_ERROR_NONE) && ((Functions & MOTION_ACCELERO) == MOTION_ACCELERO))
 800d54c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800d54e:	2b00      	cmp	r3, #0
 800d550:	d107      	bne.n	800d562 <LIS2MDL_0_Probe+0xf2>
 800d552:	687b      	ldr	r3, [r7, #4]
 800d554:	f003 0302 	and.w	r3, r3, #2
 800d558:	2b00      	cmp	r3, #0
 800d55a:	d002      	beq.n	800d562 <LIS2MDL_0_Probe+0xf2>
    {
      /* Return an error if the application try to initialize a function not supported by the component */
      ret = BSP_ERROR_COMPONENT_FAILURE;
 800d55c:	f06f 0304 	mvn.w	r3, #4
 800d560:	64fb      	str	r3, [r7, #76]	@ 0x4c
    }
    if ((ret == BSP_ERROR_NONE) && ((Functions & MOTION_GYRO) == MOTION_GYRO))
 800d562:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800d564:	2b00      	cmp	r3, #0
 800d566:	d107      	bne.n	800d578 <LIS2MDL_0_Probe+0x108>
 800d568:	687b      	ldr	r3, [r7, #4]
 800d56a:	f003 0301 	and.w	r3, r3, #1
 800d56e:	2b00      	cmp	r3, #0
 800d570:	d002      	beq.n	800d578 <LIS2MDL_0_Probe+0x108>
    {
      /* Return an error if the application try to initialize a function not supported by the component */
      ret = BSP_ERROR_COMPONENT_FAILURE;
 800d572:	f06f 0304 	mvn.w	r3, #4
 800d576:	64fb      	str	r3, [r7, #76]	@ 0x4c
    }
  }

  return ret;
 800d578:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
}
 800d57a:	4618      	mov	r0, r3
 800d57c:	3750      	adds	r7, #80	@ 0x50
 800d57e:	46bd      	mov	sp, r7
 800d580:	bd80      	pop	{r7, pc}
 800d582:	bf00      	nop
 800d584:	080057d9 	.word	0x080057d9
 800d588:	08005855 	.word	0x08005855
 800d58c:	08005909 	.word	0x08005909
 800d590:	080058a5 	.word	0x080058a5
 800d594:	0800596d 	.word	0x0800596d
 800d598:	20000d30 	.word	0x20000d30
 800d59c:	20000d24 	.word	0x20000d24
 800d5a0:	20000ce8 	.word	0x20000ce8
 800d5a4:	20000d18 	.word	0x20000d18
 800d5a8:	200000c4 	.word	0x200000c4
 800d5ac:	200001c0 	.word	0x200001c0
 800d5b0:	20000cf4 	.word	0x20000cf4
 800d5b4:	200000d4 	.word	0x200000d4

0800d5b8 <LIS2DU12_0_Probe>:
  * @param  Functions Motion sensor functions. Could be :
  *         - MOTION_GYRO and/or MOTION_ACCELERO
  * @retval BSP status
  */
static int32_t LIS2DU12_0_Probe(uint32_t Functions)
{
 800d5b8:	b580      	push	{r7, lr}
 800d5ba:	b094      	sub	sp, #80	@ 0x50
 800d5bc:	af00      	add	r7, sp, #0
 800d5be:	6078      	str	r0, [r7, #4]
  LIS2DU12_IO_t            io_ctx;
  uint8_t                  id;
  static LIS2DU12_Object_t lis2du12_obj_0;
  LIS2DU12_Capabilities_t  cap;
  int32_t                  ret = BSP_ERROR_NONE;
 800d5c0:	2300      	movs	r3, #0
 800d5c2:	64fb      	str	r3, [r7, #76]	@ 0x4c
  io_ctx.Init        = BSP_LIS2DU12_Init;
  io_ctx.DeInit      = BSP_LIS2DU12_DeInit;
  io_ctx.ReadReg     = BSP_LIS2DU12_ReadReg;
  io_ctx.WriteReg    = BSP_LIS2DU12_WriteReg;
#else
  io_ctx.BusType     = LIS2DU12_I2C_BUS; /* I2C */
 800d5c4:	2300      	movs	r3, #0
 800d5c6:	637b      	str	r3, [r7, #52]	@ 0x34
  io_ctx.Address     = LIS2DU12_I2C_ADD_H;
 800d5c8:	2333      	movs	r3, #51	@ 0x33
 800d5ca:	f887 3038 	strb.w	r3, [r7, #56]	@ 0x38
  io_ctx.Init        = BSP_LIS2DU12_0_I2C_INIT;
 800d5ce:	4b3f      	ldr	r3, [pc, #252]	@ (800d6cc <LIS2DU12_0_Probe+0x114>)
 800d5d0:	62fb      	str	r3, [r7, #44]	@ 0x2c
  io_ctx.DeInit      = BSP_LIS2DU12_0_I2C_DEINIT;
 800d5d2:	4b3f      	ldr	r3, [pc, #252]	@ (800d6d0 <LIS2DU12_0_Probe+0x118>)
 800d5d4:	633b      	str	r3, [r7, #48]	@ 0x30
  io_ctx.ReadReg     = BSP_LIS2DU12_0_I2C_READ_REG;
 800d5d6:	4b3f      	ldr	r3, [pc, #252]	@ (800d6d4 <LIS2DU12_0_Probe+0x11c>)
 800d5d8:	643b      	str	r3, [r7, #64]	@ 0x40
  io_ctx.WriteReg    = BSP_LIS2DU12_0_I2C_WRITE_REG;
 800d5da:	4b3f      	ldr	r3, [pc, #252]	@ (800d6d8 <LIS2DU12_0_Probe+0x120>)
 800d5dc:	63fb      	str	r3, [r7, #60]	@ 0x3c
#endif /* ALL_SENSORS_I2C */
  io_ctx.GetTick     = BSP_GetTick;
 800d5de:	4b3f      	ldr	r3, [pc, #252]	@ (800d6dc <LIS2DU12_0_Probe+0x124>)
 800d5e0:	647b      	str	r3, [r7, #68]	@ 0x44

  if (LIS2DU12_RegisterBusIO(&lis2du12_obj_0, &io_ctx) != LIS2DU12_OK)
 800d5e2:	f107 032c 	add.w	r3, r7, #44	@ 0x2c
 800d5e6:	4619      	mov	r1, r3
 800d5e8:	483d      	ldr	r0, [pc, #244]	@ (800d6e0 <LIS2DU12_0_Probe+0x128>)
 800d5ea:	f7f9 ffb1 	bl	8007550 <LIS2DU12_RegisterBusIO>
 800d5ee:	4603      	mov	r3, r0
 800d5f0:	2b00      	cmp	r3, #0
 800d5f2:	d003      	beq.n	800d5fc <LIS2DU12_0_Probe+0x44>
  {
    ret = BSP_ERROR_UNKNOWN_COMPONENT;
 800d5f4:	f06f 0306 	mvn.w	r3, #6
 800d5f8:	64fb      	str	r3, [r7, #76]	@ 0x4c
 800d5fa:	e062      	b.n	800d6c2 <LIS2DU12_0_Probe+0x10a>
  }
  else if (LIS2DU12_ReadID(&lis2du12_obj_0, &id) != LIS2DU12_OK)
 800d5fc:	f107 032b 	add.w	r3, r7, #43	@ 0x2b
 800d600:	4619      	mov	r1, r3
 800d602:	4837      	ldr	r0, [pc, #220]	@ (800d6e0 <LIS2DU12_0_Probe+0x128>)
 800d604:	f7fa f888 	bl	8007718 <LIS2DU12_ReadID>
 800d608:	4603      	mov	r3, r0
 800d60a:	2b00      	cmp	r3, #0
 800d60c:	d003      	beq.n	800d616 <LIS2DU12_0_Probe+0x5e>
  {
    ret = BSP_ERROR_UNKNOWN_COMPONENT;
 800d60e:	f06f 0306 	mvn.w	r3, #6
 800d612:	64fb      	str	r3, [r7, #76]	@ 0x4c
 800d614:	e055      	b.n	800d6c2 <LIS2DU12_0_Probe+0x10a>
  }
  else if (id != LIS2DU12_ID)
 800d616:	f897 302b 	ldrb.w	r3, [r7, #43]	@ 0x2b
 800d61a:	2b45      	cmp	r3, #69	@ 0x45
 800d61c:	d003      	beq.n	800d626 <LIS2DU12_0_Probe+0x6e>
  {
    ret = BSP_ERROR_UNKNOWN_COMPONENT;
 800d61e:	f06f 0306 	mvn.w	r3, #6
 800d622:	64fb      	str	r3, [r7, #76]	@ 0x4c
 800d624:	e04d      	b.n	800d6c2 <LIS2DU12_0_Probe+0x10a>
  }
  else
  {
    (void)LIS2DU12_GetCapabilities(&lis2du12_obj_0, &cap);
 800d626:	f107 030c 	add.w	r3, r7, #12
 800d62a:	4619      	mov	r1, r3
 800d62c:	482c      	ldr	r0, [pc, #176]	@ (800d6e0 <LIS2DU12_0_Probe+0x128>)
 800d62e:	f7fa f88f 	bl	8007750 <LIS2DU12_GetCapabilities>
    MotionCtx[LIS2DU12_0].Functions = ((uint32_t)cap.Gyro) | ((uint32_t)cap.Acc << 1) | ((uint32_t)cap.Magneto << 2);
 800d632:	7b7b      	ldrb	r3, [r7, #13]
 800d634:	461a      	mov	r2, r3
 800d636:	7b3b      	ldrb	r3, [r7, #12]
 800d638:	005b      	lsls	r3, r3, #1
 800d63a:	431a      	orrs	r2, r3
 800d63c:	7bbb      	ldrb	r3, [r7, #14]
 800d63e:	009b      	lsls	r3, r3, #2
 800d640:	4313      	orrs	r3, r2
 800d642:	4a28      	ldr	r2, [pc, #160]	@ (800d6e4 <LIS2DU12_0_Probe+0x12c>)
 800d644:	6053      	str	r3, [r2, #4]

    MotionCompObj[LIS2DU12_0] = &lis2du12_obj_0;
 800d646:	4b28      	ldr	r3, [pc, #160]	@ (800d6e8 <LIS2DU12_0_Probe+0x130>)
 800d648:	4a25      	ldr	r2, [pc, #148]	@ (800d6e0 <LIS2DU12_0_Probe+0x128>)
 800d64a:	605a      	str	r2, [r3, #4]
    /* The second cast (void *) is added to bypass Misra R11.3 rule */
    MotionDrv[LIS2DU12_0] = (MOTION_SENSOR_CommonDrv_t *)(void *)&LIS2DU12_COMMON_Driver;
 800d64c:	4b27      	ldr	r3, [pc, #156]	@ (800d6ec <LIS2DU12_0_Probe+0x134>)
 800d64e:	4a28      	ldr	r2, [pc, #160]	@ (800d6f0 <LIS2DU12_0_Probe+0x138>)
 800d650:	605a      	str	r2, [r3, #4]

    if ((ret == BSP_ERROR_NONE) && ((Functions & MOTION_ACCELERO) == MOTION_ACCELERO) && (cap.Acc == 1U))
 800d652:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800d654:	2b00      	cmp	r3, #0
 800d656:	d11e      	bne.n	800d696 <LIS2DU12_0_Probe+0xde>
 800d658:	687b      	ldr	r3, [r7, #4]
 800d65a:	f003 0302 	and.w	r3, r3, #2
 800d65e:	2b00      	cmp	r3, #0
 800d660:	d019      	beq.n	800d696 <LIS2DU12_0_Probe+0xde>
 800d662:	7b3b      	ldrb	r3, [r7, #12]
 800d664:	2b01      	cmp	r3, #1
 800d666:	d116      	bne.n	800d696 <LIS2DU12_0_Probe+0xde>
    {
      /* The second cast (void *) is added to bypass Misra R11.3 rule */
      MotionFuncDrv[LIS2DU12_0][FunctionIndex[MOTION_ACCELERO]] =
 800d668:	4b22      	ldr	r3, [pc, #136]	@ (800d6f4 <LIS2DU12_0_Probe+0x13c>)
 800d66a:	689b      	ldr	r3, [r3, #8]
 800d66c:	4a22      	ldr	r2, [pc, #136]	@ (800d6f8 <LIS2DU12_0_Probe+0x140>)
 800d66e:	3303      	adds	r3, #3
 800d670:	4922      	ldr	r1, [pc, #136]	@ (800d6fc <LIS2DU12_0_Probe+0x144>)
 800d672:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
        (MOTION_SENSOR_FuncDrv_t *)(void *)&LIS2DU12_ACC_Driver;

      if (MotionDrv[LIS2DU12_0]->Init(MotionCompObj[LIS2DU12_0]) != LIS2DU12_OK)
 800d676:	4b1d      	ldr	r3, [pc, #116]	@ (800d6ec <LIS2DU12_0_Probe+0x134>)
 800d678:	685b      	ldr	r3, [r3, #4]
 800d67a:	681b      	ldr	r3, [r3, #0]
 800d67c:	4a1a      	ldr	r2, [pc, #104]	@ (800d6e8 <LIS2DU12_0_Probe+0x130>)
 800d67e:	6852      	ldr	r2, [r2, #4]
 800d680:	4610      	mov	r0, r2
 800d682:	4798      	blx	r3
 800d684:	4603      	mov	r3, r0
 800d686:	2b00      	cmp	r3, #0
 800d688:	d003      	beq.n	800d692 <LIS2DU12_0_Probe+0xda>
      {
        ret = BSP_ERROR_COMPONENT_FAILURE;
 800d68a:	f06f 0304 	mvn.w	r3, #4
 800d68e:	64fb      	str	r3, [r7, #76]	@ 0x4c
 800d690:	e001      	b.n	800d696 <LIS2DU12_0_Probe+0xde>
      }
      else
      {
        ret = BSP_ERROR_NONE;
 800d692:	2300      	movs	r3, #0
 800d694:	64fb      	str	r3, [r7, #76]	@ 0x4c
      }
    }
    if ((ret == BSP_ERROR_NONE) && ((Functions & MOTION_GYRO) == MOTION_GYRO))
 800d696:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800d698:	2b00      	cmp	r3, #0
 800d69a:	d107      	bne.n	800d6ac <LIS2DU12_0_Probe+0xf4>
 800d69c:	687b      	ldr	r3, [r7, #4]
 800d69e:	f003 0301 	and.w	r3, r3, #1
 800d6a2:	2b00      	cmp	r3, #0
 800d6a4:	d002      	beq.n	800d6ac <LIS2DU12_0_Probe+0xf4>
    {
      /* Return an error if the application try to initialize a function not supported by the component */
      ret = BSP_ERROR_COMPONENT_FAILURE;
 800d6a6:	f06f 0304 	mvn.w	r3, #4
 800d6aa:	64fb      	str	r3, [r7, #76]	@ 0x4c
    }
    if ((ret == BSP_ERROR_NONE) && ((Functions & MOTION_MAGNETO) == MOTION_MAGNETO))
 800d6ac:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800d6ae:	2b00      	cmp	r3, #0
 800d6b0:	d107      	bne.n	800d6c2 <LIS2DU12_0_Probe+0x10a>
 800d6b2:	687b      	ldr	r3, [r7, #4]
 800d6b4:	f003 0304 	and.w	r3, r3, #4
 800d6b8:	2b00      	cmp	r3, #0
 800d6ba:	d002      	beq.n	800d6c2 <LIS2DU12_0_Probe+0x10a>
    {
      /* Return an error if the application try to initialize a function not supported by the component */
      ret = BSP_ERROR_COMPONENT_FAILURE;
 800d6bc:	f06f 0304 	mvn.w	r3, #4
 800d6c0:	64fb      	str	r3, [r7, #76]	@ 0x4c
    }
  }

  return ret;
 800d6c2:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
}
 800d6c4:	4618      	mov	r0, r3
 800d6c6:	3750      	adds	r7, #80	@ 0x50
 800d6c8:	46bd      	mov	sp, r7
 800d6ca:	bd80      	pop	{r7, pc}
 800d6cc:	080057d9 	.word	0x080057d9
 800d6d0:	08005855 	.word	0x08005855
 800d6d4:	08005909 	.word	0x08005909
 800d6d8:	080058a5 	.word	0x080058a5
 800d6dc:	0800596d 	.word	0x0800596d
 800d6e0:	20000d64 	.word	0x20000d64
 800d6e4:	20000d24 	.word	0x20000d24
 800d6e8:	20000ce8 	.word	0x20000ce8
 800d6ec:	20000d18 	.word	0x20000d18
 800d6f0:	20000090 	.word	0x20000090
 800d6f4:	200001c0 	.word	0x200001c0
 800d6f8:	20000cf4 	.word	0x20000cf4
 800d6fc:	200000a0 	.word	0x200000a0

0800d700 <LSM6DSV16X_0_Probe>:
  * @param  Functions Motion sensor functions. Could be :
  *         - MOTION_GYRO and/or MOTION_ACCELERO
  * @retval BSP status
  */
static int32_t LSM6DSV16X_0_Probe(uint32_t Functions)
{
 800d700:	b580      	push	{r7, lr}
 800d702:	b094      	sub	sp, #80	@ 0x50
 800d704:	af00      	add	r7, sp, #0
 800d706:	6078      	str	r0, [r7, #4]
  LSM6DSV16X_IO_t            io_ctx;
  uint8_t                    id;
  static LSM6DSV16X_Object_t lsm6dsv16x_obj_0;
  LSM6DSV16X_Capabilities_t  cap;
  int32_t                    ret = BSP_ERROR_NONE;
 800d708:	2300      	movs	r3, #0
 800d70a:	64fb      	str	r3, [r7, #76]	@ 0x4c
  io_ctx.Init        = BSP_LSM6DSV16X_Init;
  io_ctx.DeInit      = BSP_LSM6DSV16X_DeInit;
  io_ctx.ReadReg     = BSP_LSM6DSV16X_ReadReg;
  io_ctx.WriteReg    = BSP_LSM6DSV16X_WriteReg;
#else
  io_ctx.BusType     = LSM6DSV16X_I2C_BUS; /* I2C */
 800d70c:	2300      	movs	r3, #0
 800d70e:	637b      	str	r3, [r7, #52]	@ 0x34
  io_ctx.Address     = LSM6DSV16X_I2C_ADD_H;
 800d710:	23d7      	movs	r3, #215	@ 0xd7
 800d712:	f887 3038 	strb.w	r3, [r7, #56]	@ 0x38
  io_ctx.Init        = BSP_LSM6DSV16X_0_I2C_INIT;
 800d716:	4b4b      	ldr	r3, [pc, #300]	@ (800d844 <LSM6DSV16X_0_Probe+0x144>)
 800d718:	62fb      	str	r3, [r7, #44]	@ 0x2c
  io_ctx.DeInit      = BSP_LSM6DSV16X_0_I2C_DEINIT;
 800d71a:	4b4b      	ldr	r3, [pc, #300]	@ (800d848 <LSM6DSV16X_0_Probe+0x148>)
 800d71c:	633b      	str	r3, [r7, #48]	@ 0x30
  io_ctx.ReadReg     = BSP_LSM6DSV16X_0_I2C_READ_REG;
 800d71e:	4b4b      	ldr	r3, [pc, #300]	@ (800d84c <LSM6DSV16X_0_Probe+0x14c>)
 800d720:	643b      	str	r3, [r7, #64]	@ 0x40
  io_ctx.WriteReg    = BSP_LSM6DSV16X_0_I2C_WRITE_REG;
 800d722:	4b4b      	ldr	r3, [pc, #300]	@ (800d850 <LSM6DSV16X_0_Probe+0x150>)
 800d724:	63fb      	str	r3, [r7, #60]	@ 0x3c
#endif /* ALL_SENSORS_I2C */
  io_ctx.GetTick     = BSP_GetTick;
 800d726:	4b4b      	ldr	r3, [pc, #300]	@ (800d854 <LSM6DSV16X_0_Probe+0x154>)
 800d728:	647b      	str	r3, [r7, #68]	@ 0x44

  if (LSM6DSV16X_RegisterBusIO(&lsm6dsv16x_obj_0, &io_ctx) != LSM6DSV16X_OK)
 800d72a:	f107 032c 	add.w	r3, r7, #44	@ 0x2c
 800d72e:	4619      	mov	r1, r3
 800d730:	4849      	ldr	r0, [pc, #292]	@ (800d858 <LSM6DSV16X_0_Probe+0x158>)
 800d732:	f7fc ff39 	bl	800a5a8 <LSM6DSV16X_RegisterBusIO>
 800d736:	4603      	mov	r3, r0
 800d738:	2b00      	cmp	r3, #0
 800d73a:	d003      	beq.n	800d744 <LSM6DSV16X_0_Probe+0x44>
  {
    ret = BSP_ERROR_UNKNOWN_COMPONENT;
 800d73c:	f06f 0306 	mvn.w	r3, #6
 800d740:	64fb      	str	r3, [r7, #76]	@ 0x4c
 800d742:	e079      	b.n	800d838 <LSM6DSV16X_0_Probe+0x138>
  }
  else if (LSM6DSV16X_ReadID(&lsm6dsv16x_obj_0, &id) != LSM6DSV16X_OK)
 800d744:	f107 032b 	add.w	r3, r7, #43	@ 0x2b
 800d748:	4619      	mov	r1, r3
 800d74a:	4843      	ldr	r0, [pc, #268]	@ (800d858 <LSM6DSV16X_0_Probe+0x158>)
 800d74c:	f7fd f852 	bl	800a7f4 <LSM6DSV16X_ReadID>
 800d750:	4603      	mov	r3, r0
 800d752:	2b00      	cmp	r3, #0
 800d754:	d003      	beq.n	800d75e <LSM6DSV16X_0_Probe+0x5e>
  {
    ret = BSP_ERROR_UNKNOWN_COMPONENT;
 800d756:	f06f 0306 	mvn.w	r3, #6
 800d75a:	64fb      	str	r3, [r7, #76]	@ 0x4c
 800d75c:	e06c      	b.n	800d838 <LSM6DSV16X_0_Probe+0x138>
  }
  else if (id != LSM6DSV16X_ID)
 800d75e:	f897 302b 	ldrb.w	r3, [r7, #43]	@ 0x2b
 800d762:	2b70      	cmp	r3, #112	@ 0x70
 800d764:	d003      	beq.n	800d76e <LSM6DSV16X_0_Probe+0x6e>
  {
    ret = BSP_ERROR_UNKNOWN_COMPONENT;
 800d766:	f06f 0306 	mvn.w	r3, #6
 800d76a:	64fb      	str	r3, [r7, #76]	@ 0x4c
 800d76c:	e064      	b.n	800d838 <LSM6DSV16X_0_Probe+0x138>
  }
  else
  {
    (void)LSM6DSV16X_GetCapabilities(&lsm6dsv16x_obj_0, &cap);
 800d76e:	f107 030c 	add.w	r3, r7, #12
 800d772:	4619      	mov	r1, r3
 800d774:	4838      	ldr	r0, [pc, #224]	@ (800d858 <LSM6DSV16X_0_Probe+0x158>)
 800d776:	f7fd f853 	bl	800a820 <LSM6DSV16X_GetCapabilities>
    MotionCtx[LSM6DSV16X_0].Functions = ((uint32_t)cap.Gyro) | ((uint32_t)cap.Acc << 1) | ((uint32_t)cap.Magneto << 2);
 800d77a:	7b7b      	ldrb	r3, [r7, #13]
 800d77c:	461a      	mov	r2, r3
 800d77e:	7b3b      	ldrb	r3, [r7, #12]
 800d780:	005b      	lsls	r3, r3, #1
 800d782:	431a      	orrs	r2, r3
 800d784:	7bbb      	ldrb	r3, [r7, #14]
 800d786:	009b      	lsls	r3, r3, #2
 800d788:	4313      	orrs	r3, r2
 800d78a:	4a34      	ldr	r2, [pc, #208]	@ (800d85c <LSM6DSV16X_0_Probe+0x15c>)
 800d78c:	6093      	str	r3, [r2, #8]

    MotionCompObj[LSM6DSV16X_0] = &lsm6dsv16x_obj_0;
 800d78e:	4b34      	ldr	r3, [pc, #208]	@ (800d860 <LSM6DSV16X_0_Probe+0x160>)
 800d790:	4a31      	ldr	r2, [pc, #196]	@ (800d858 <LSM6DSV16X_0_Probe+0x158>)
 800d792:	609a      	str	r2, [r3, #8]
    /* The second cast (void *) is added to bypass Misra R11.3 rule */
    MotionDrv[LSM6DSV16X_0] = (MOTION_SENSOR_CommonDrv_t *)(void *)&LSM6DSV16X_COMMON_Driver;
 800d794:	4b33      	ldr	r3, [pc, #204]	@ (800d864 <LSM6DSV16X_0_Probe+0x164>)
 800d796:	4a34      	ldr	r2, [pc, #208]	@ (800d868 <LSM6DSV16X_0_Probe+0x168>)
 800d798:	609a      	str	r2, [r3, #8]

    if ((ret == BSP_ERROR_NONE) && ((Functions & MOTION_GYRO) == MOTION_GYRO) && (cap.Gyro == 1U))
 800d79a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800d79c:	2b00      	cmp	r3, #0
 800d79e:	d11e      	bne.n	800d7de <LSM6DSV16X_0_Probe+0xde>
 800d7a0:	687b      	ldr	r3, [r7, #4]
 800d7a2:	f003 0301 	and.w	r3, r3, #1
 800d7a6:	2b00      	cmp	r3, #0
 800d7a8:	d019      	beq.n	800d7de <LSM6DSV16X_0_Probe+0xde>
 800d7aa:	7b7b      	ldrb	r3, [r7, #13]
 800d7ac:	2b01      	cmp	r3, #1
 800d7ae:	d116      	bne.n	800d7de <LSM6DSV16X_0_Probe+0xde>
    {
      /* The second cast (void *) is added to bypass Misra R11.3 rule */
      MotionFuncDrv[LSM6DSV16X_0][FunctionIndex[MOTION_GYRO]] =
 800d7b0:	4b2e      	ldr	r3, [pc, #184]	@ (800d86c <LSM6DSV16X_0_Probe+0x16c>)
 800d7b2:	685b      	ldr	r3, [r3, #4]
 800d7b4:	4a2e      	ldr	r2, [pc, #184]	@ (800d870 <LSM6DSV16X_0_Probe+0x170>)
 800d7b6:	3306      	adds	r3, #6
 800d7b8:	492e      	ldr	r1, [pc, #184]	@ (800d874 <LSM6DSV16X_0_Probe+0x174>)
 800d7ba:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
        (MOTION_SENSOR_FuncDrv_t *)(void *)&LSM6DSV16X_GYRO_Driver;

      if (MotionDrv[LSM6DSV16X_0]->Init(MotionCompObj[LSM6DSV16X_0]) != LSM6DSV16X_OK)
 800d7be:	4b29      	ldr	r3, [pc, #164]	@ (800d864 <LSM6DSV16X_0_Probe+0x164>)
 800d7c0:	689b      	ldr	r3, [r3, #8]
 800d7c2:	681b      	ldr	r3, [r3, #0]
 800d7c4:	4a26      	ldr	r2, [pc, #152]	@ (800d860 <LSM6DSV16X_0_Probe+0x160>)
 800d7c6:	6892      	ldr	r2, [r2, #8]
 800d7c8:	4610      	mov	r0, r2
 800d7ca:	4798      	blx	r3
 800d7cc:	4603      	mov	r3, r0
 800d7ce:	2b00      	cmp	r3, #0
 800d7d0:	d003      	beq.n	800d7da <LSM6DSV16X_0_Probe+0xda>
      {
        ret = BSP_ERROR_COMPONENT_FAILURE;
 800d7d2:	f06f 0304 	mvn.w	r3, #4
 800d7d6:	64fb      	str	r3, [r7, #76]	@ 0x4c
 800d7d8:	e001      	b.n	800d7de <LSM6DSV16X_0_Probe+0xde>
      }
      else
      {
        ret = BSP_ERROR_NONE;
 800d7da:	2300      	movs	r3, #0
 800d7dc:	64fb      	str	r3, [r7, #76]	@ 0x4c
      }
    }
    if ((ret == BSP_ERROR_NONE) && ((Functions & MOTION_ACCELERO) == MOTION_ACCELERO) && (cap.Acc == 1U))
 800d7de:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800d7e0:	2b00      	cmp	r3, #0
 800d7e2:	d11e      	bne.n	800d822 <LSM6DSV16X_0_Probe+0x122>
 800d7e4:	687b      	ldr	r3, [r7, #4]
 800d7e6:	f003 0302 	and.w	r3, r3, #2
 800d7ea:	2b00      	cmp	r3, #0
 800d7ec:	d019      	beq.n	800d822 <LSM6DSV16X_0_Probe+0x122>
 800d7ee:	7b3b      	ldrb	r3, [r7, #12]
 800d7f0:	2b01      	cmp	r3, #1
 800d7f2:	d116      	bne.n	800d822 <LSM6DSV16X_0_Probe+0x122>
    {
      /* The second cast (void *) is added to bypass Misra R11.3 rule */
      MotionFuncDrv[LSM6DSV16X_0][FunctionIndex[MOTION_ACCELERO]] =
 800d7f4:	4b1d      	ldr	r3, [pc, #116]	@ (800d86c <LSM6DSV16X_0_Probe+0x16c>)
 800d7f6:	689b      	ldr	r3, [r3, #8]
 800d7f8:	4a1d      	ldr	r2, [pc, #116]	@ (800d870 <LSM6DSV16X_0_Probe+0x170>)
 800d7fa:	3306      	adds	r3, #6
 800d7fc:	491e      	ldr	r1, [pc, #120]	@ (800d878 <LSM6DSV16X_0_Probe+0x178>)
 800d7fe:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
        (MOTION_SENSOR_FuncDrv_t *)(void *)&LSM6DSV16X_ACC_Driver;

      if (MotionDrv[LSM6DSV16X_0]->Init(MotionCompObj[LSM6DSV16X_0]) != LSM6DSV16X_OK)
 800d802:	4b18      	ldr	r3, [pc, #96]	@ (800d864 <LSM6DSV16X_0_Probe+0x164>)
 800d804:	689b      	ldr	r3, [r3, #8]
 800d806:	681b      	ldr	r3, [r3, #0]
 800d808:	4a15      	ldr	r2, [pc, #84]	@ (800d860 <LSM6DSV16X_0_Probe+0x160>)
 800d80a:	6892      	ldr	r2, [r2, #8]
 800d80c:	4610      	mov	r0, r2
 800d80e:	4798      	blx	r3
 800d810:	4603      	mov	r3, r0
 800d812:	2b00      	cmp	r3, #0
 800d814:	d003      	beq.n	800d81e <LSM6DSV16X_0_Probe+0x11e>
      {
        ret = BSP_ERROR_COMPONENT_FAILURE;
 800d816:	f06f 0304 	mvn.w	r3, #4
 800d81a:	64fb      	str	r3, [r7, #76]	@ 0x4c
 800d81c:	e001      	b.n	800d822 <LSM6DSV16X_0_Probe+0x122>
      }
      else
      {
        ret = BSP_ERROR_NONE;
 800d81e:	2300      	movs	r3, #0
 800d820:	64fb      	str	r3, [r7, #76]	@ 0x4c
      }
    }
    if ((ret == BSP_ERROR_NONE) && ((Functions & MOTION_MAGNETO) == MOTION_MAGNETO))
 800d822:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800d824:	2b00      	cmp	r3, #0
 800d826:	d107      	bne.n	800d838 <LSM6DSV16X_0_Probe+0x138>
 800d828:	687b      	ldr	r3, [r7, #4]
 800d82a:	f003 0304 	and.w	r3, r3, #4
 800d82e:	2b00      	cmp	r3, #0
 800d830:	d002      	beq.n	800d838 <LSM6DSV16X_0_Probe+0x138>
    {
      /* Return an error if the application try to initialize a function not supported by the component */
      ret = BSP_ERROR_COMPONENT_FAILURE;
 800d832:	f06f 0304 	mvn.w	r3, #4
 800d836:	64fb      	str	r3, [r7, #76]	@ 0x4c
    }
  }

  return ret;
 800d838:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
}
 800d83a:	4618      	mov	r0, r3
 800d83c:	3750      	adds	r7, #80	@ 0x50
 800d83e:	46bd      	mov	sp, r7
 800d840:	bd80      	pop	{r7, pc}
 800d842:	bf00      	nop
 800d844:	080057d9 	.word	0x080057d9
 800d848:	08005855 	.word	0x08005855
 800d84c:	08005909 	.word	0x08005909
 800d850:	080058a5 	.word	0x080058a5
 800d854:	0800596d 	.word	0x0800596d
 800d858:	20000da0 	.word	0x20000da0
 800d85c:	20000d24 	.word	0x20000d24
 800d860:	20000ce8 	.word	0x20000ce8
 800d864:	20000d18 	.word	0x20000d18
 800d868:	20000130 	.word	0x20000130
 800d86c:	200001c0 	.word	0x200001c0
 800d870:	20000cf4 	.word	0x20000cf4
 800d874:	20000164 	.word	0x20000164
 800d878:	20000140 	.word	0x20000140

0800d87c <SystemInit>:
  * @param  None
  * @retval None
  */

void SystemInit(void)
{
 800d87c:	b480      	push	{r7}
 800d87e:	af00      	add	r7, sp, #0
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
   SCB->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
 800d880:	4b18      	ldr	r3, [pc, #96]	@ (800d8e4 <SystemInit+0x68>)
 800d882:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 800d886:	4a17      	ldr	r2, [pc, #92]	@ (800d8e4 <SystemInit+0x68>)
 800d888:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
 800d88c:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88
  #endif

  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set MSION bit */
  RCC->CR = RCC_CR_MSISON;
 800d890:	4b15      	ldr	r3, [pc, #84]	@ (800d8e8 <SystemInit+0x6c>)
 800d892:	2201      	movs	r2, #1
 800d894:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR1 = 0U;
 800d896:	4b14      	ldr	r3, [pc, #80]	@ (800d8e8 <SystemInit+0x6c>)
 800d898:	2200      	movs	r2, #0
 800d89a:	61da      	str	r2, [r3, #28]
  RCC->CFGR2 = 0U;
 800d89c:	4b12      	ldr	r3, [pc, #72]	@ (800d8e8 <SystemInit+0x6c>)
 800d89e:	2200      	movs	r2, #0
 800d8a0:	621a      	str	r2, [r3, #32]
  RCC->CFGR3 = 0U;
 800d8a2:	4b11      	ldr	r3, [pc, #68]	@ (800d8e8 <SystemInit+0x6c>)
 800d8a4:	2200      	movs	r2, #0
 800d8a6:	625a      	str	r2, [r3, #36]	@ 0x24

  /* Reset HSEON, CSSON , HSION, PLLxON bits */
  RCC->CR &= ~(RCC_CR_HSEON | RCC_CR_CSSON | RCC_CR_PLL1ON | RCC_CR_PLL2ON | RCC_CR_PLL3ON);
 800d8a8:	4b0f      	ldr	r3, [pc, #60]	@ (800d8e8 <SystemInit+0x6c>)
 800d8aa:	681b      	ldr	r3, [r3, #0]
 800d8ac:	4a0e      	ldr	r2, [pc, #56]	@ (800d8e8 <SystemInit+0x6c>)
 800d8ae:	f023 53a8 	bic.w	r3, r3, #352321536	@ 0x15000000
 800d8b2:	f423 2310 	bic.w	r3, r3, #589824	@ 0x90000
 800d8b6:	6013      	str	r3, [r2, #0]

  /* Reset PLLCFGR register */
  RCC->PLL1CFGR = 0U;
 800d8b8:	4b0b      	ldr	r3, [pc, #44]	@ (800d8e8 <SystemInit+0x6c>)
 800d8ba:	2200      	movs	r2, #0
 800d8bc:	629a      	str	r2, [r3, #40]	@ 0x28

  /* Reset HSEBYP bit */
  RCC->CR &= ~(RCC_CR_HSEBYP);
 800d8be:	4b0a      	ldr	r3, [pc, #40]	@ (800d8e8 <SystemInit+0x6c>)
 800d8c0:	681b      	ldr	r3, [r3, #0]
 800d8c2:	4a09      	ldr	r2, [pc, #36]	@ (800d8e8 <SystemInit+0x6c>)
 800d8c4:	f423 2380 	bic.w	r3, r3, #262144	@ 0x40000
 800d8c8:	6013      	str	r3, [r2, #0]

  /* Disable all interrupts */
  RCC->CIER = 0U;
 800d8ca:	4b07      	ldr	r3, [pc, #28]	@ (800d8e8 <SystemInit+0x6c>)
 800d8cc:	2200      	movs	r2, #0
 800d8ce:	651a      	str	r2, [r3, #80]	@ 0x50

  /* Configure the Vector Table location add offset address ------------------*/
  #ifdef VECT_TAB_SRAM
    SCB->VTOR = SRAM1_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
  #else
    SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 800d8d0:	4b04      	ldr	r3, [pc, #16]	@ (800d8e4 <SystemInit+0x68>)
 800d8d2:	f04f 6200 	mov.w	r2, #134217728	@ 0x8000000
 800d8d6:	609a      	str	r2, [r3, #8]
  #endif
}
 800d8d8:	bf00      	nop
 800d8da:	46bd      	mov	sp, r7
 800d8dc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d8e0:	4770      	bx	lr
 800d8e2:	bf00      	nop
 800d8e4:	e000ed00 	.word	0xe000ed00
 800d8e8:	46020c00 	.word	0x46020c00

0800d8ec <HAL_Init>:
  *         each 1ms in the SysTick_Handler() interrupt handler.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 800d8ec:	b580      	push	{r7, lr}
 800d8ee:	af00      	add	r7, sp, #0
  /* Configure Flash prefetch */
#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 800d8f0:	4b12      	ldr	r3, [pc, #72]	@ (800d93c <HAL_Init+0x50>)
 800d8f2:	681b      	ldr	r3, [r3, #0]
 800d8f4:	4a11      	ldr	r2, [pc, #68]	@ (800d93c <HAL_Init+0x50>)
 800d8f6:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 800d8fa:	6013      	str	r3, [r2, #0]
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 800d8fc:	2003      	movs	r0, #3
 800d8fe:	f000 f9ad 	bl	800dc5c <HAL_NVIC_SetPriorityGrouping>

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR2 & RCC_CFGR2_HPRE) >> RCC_CFGR2_HPRE_Pos];
 800d902:	f005 f901 	bl	8012b08 <HAL_RCC_GetSysClockFreq>
 800d906:	4602      	mov	r2, r0
 800d908:	4b0d      	ldr	r3, [pc, #52]	@ (800d940 <HAL_Init+0x54>)
 800d90a:	6a1b      	ldr	r3, [r3, #32]
 800d90c:	f003 030f 	and.w	r3, r3, #15
 800d910:	490c      	ldr	r1, [pc, #48]	@ (800d944 <HAL_Init+0x58>)
 800d912:	5ccb      	ldrb	r3, [r1, r3]
 800d914:	fa22 f303 	lsr.w	r3, r2, r3
 800d918:	4a0b      	ldr	r2, [pc, #44]	@ (800d948 <HAL_Init+0x5c>)
 800d91a:	6013      	str	r3, [r2, #0]

  /* Select HCLK as SysTick clock source */
  HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
 800d91c:	2004      	movs	r0, #4
 800d91e:	f000 fa05 	bl	800dd2c <HAL_SYSTICK_CLKSourceConfig>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 800d922:	200f      	movs	r0, #15
 800d924:	f000 f812 	bl	800d94c <HAL_InitTick>
 800d928:	4603      	mov	r3, r0
 800d92a:	2b00      	cmp	r3, #0
 800d92c:	d001      	beq.n	800d932 <HAL_Init+0x46>
  {
    return HAL_ERROR;
 800d92e:	2301      	movs	r3, #1
 800d930:	e002      	b.n	800d938 <HAL_Init+0x4c>
  }

  /* Init the low level hardware */
  HAL_MspInit();
 800d932:	f7f8 fc19 	bl	8006168 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
 800d936:	2300      	movs	r3, #0
}
 800d938:	4618      	mov	r0, r3
 800d93a:	bd80      	pop	{r7, pc}
 800d93c:	40022000 	.word	0x40022000
 800d940:	46020c00 	.word	0x46020c00
 800d944:	0802a4c8 	.word	0x0802a4c8
 800d948:	200001e0 	.word	0x200001e0

0800d94c <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 800d94c:	b580      	push	{r7, lr}
 800d94e:	b084      	sub	sp, #16
 800d950:	af00      	add	r7, sp, #0
 800d952:	6078      	str	r0, [r7, #4]
  uint32_t ticknumber = 0U;
 800d954:	2300      	movs	r3, #0
 800d956:	60fb      	str	r3, [r7, #12]
  uint32_t systicksel;

  /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that don't take the value zero)*/
  if ((uint32_t)uwTickFreq == 0UL)
 800d958:	4b33      	ldr	r3, [pc, #204]	@ (800da28 <HAL_InitTick+0xdc>)
 800d95a:	781b      	ldrb	r3, [r3, #0]
 800d95c:	2b00      	cmp	r3, #0
 800d95e:	d101      	bne.n	800d964 <HAL_InitTick+0x18>
  {
    return HAL_ERROR;
 800d960:	2301      	movs	r3, #1
 800d962:	e05c      	b.n	800da1e <HAL_InitTick+0xd2>
  }

  /* Check Clock source to calculate the tickNumber */
  if (READ_BIT(SysTick->CTRL, SysTick_CTRL_CLKSOURCE_Msk) == SysTick_CTRL_CLKSOURCE_Msk)
 800d964:	4b31      	ldr	r3, [pc, #196]	@ (800da2c <HAL_InitTick+0xe0>)
 800d966:	681b      	ldr	r3, [r3, #0]
 800d968:	f003 0304 	and.w	r3, r3, #4
 800d96c:	2b04      	cmp	r3, #4
 800d96e:	d10c      	bne.n	800d98a <HAL_InitTick+0x3e>
  {
    /* HCLK selected as SysTick clock source */
    ticknumber = SystemCoreClock / (1000UL / (uint32_t)uwTickFreq);
 800d970:	4b2f      	ldr	r3, [pc, #188]	@ (800da30 <HAL_InitTick+0xe4>)
 800d972:	681a      	ldr	r2, [r3, #0]
 800d974:	4b2c      	ldr	r3, [pc, #176]	@ (800da28 <HAL_InitTick+0xdc>)
 800d976:	781b      	ldrb	r3, [r3, #0]
 800d978:	4619      	mov	r1, r3
 800d97a:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
 800d97e:	fbb3 f3f1 	udiv	r3, r3, r1
 800d982:	fbb2 f3f3 	udiv	r3, r2, r3
 800d986:	60fb      	str	r3, [r7, #12]
 800d988:	e037      	b.n	800d9fa <HAL_InitTick+0xae>
  }
  else
  {
    systicksel = HAL_SYSTICK_GetCLKSourceConfig();
 800d98a:	f000 fa27 	bl	800dddc <HAL_SYSTICK_GetCLKSourceConfig>
 800d98e:	60b8      	str	r0, [r7, #8]
    switch (systicksel)
 800d990:	68bb      	ldr	r3, [r7, #8]
 800d992:	2b02      	cmp	r3, #2
 800d994:	d023      	beq.n	800d9de <HAL_InitTick+0x92>
 800d996:	68bb      	ldr	r3, [r7, #8]
 800d998:	2b02      	cmp	r3, #2
 800d99a:	d82d      	bhi.n	800d9f8 <HAL_InitTick+0xac>
 800d99c:	68bb      	ldr	r3, [r7, #8]
 800d99e:	2b00      	cmp	r3, #0
 800d9a0:	d003      	beq.n	800d9aa <HAL_InitTick+0x5e>
 800d9a2:	68bb      	ldr	r3, [r7, #8]
 800d9a4:	2b01      	cmp	r3, #1
 800d9a6:	d00d      	beq.n	800d9c4 <HAL_InitTick+0x78>
        /* Calculate tick value */
        ticknumber = (LSE_VALUE / (1000UL / (uint32_t)uwTickFreq));
        break;
      default:
        /* Nothing to do */
        break;
 800d9a8:	e026      	b.n	800d9f8 <HAL_InitTick+0xac>
        ticknumber = (SystemCoreClock / (8000UL / (uint32_t)uwTickFreq));
 800d9aa:	4b21      	ldr	r3, [pc, #132]	@ (800da30 <HAL_InitTick+0xe4>)
 800d9ac:	681a      	ldr	r2, [r3, #0]
 800d9ae:	4b1e      	ldr	r3, [pc, #120]	@ (800da28 <HAL_InitTick+0xdc>)
 800d9b0:	781b      	ldrb	r3, [r3, #0]
 800d9b2:	4619      	mov	r1, r3
 800d9b4:	f44f 53fa 	mov.w	r3, #8000	@ 0x1f40
 800d9b8:	fbb3 f3f1 	udiv	r3, r3, r1
 800d9bc:	fbb2 f3f3 	udiv	r3, r2, r3
 800d9c0:	60fb      	str	r3, [r7, #12]
        break;
 800d9c2:	e01a      	b.n	800d9fa <HAL_InitTick+0xae>
        ticknumber = (LSI_VALUE / (1000UL / (uint32_t)uwTickFreq));
 800d9c4:	4b18      	ldr	r3, [pc, #96]	@ (800da28 <HAL_InitTick+0xdc>)
 800d9c6:	781b      	ldrb	r3, [r3, #0]
 800d9c8:	461a      	mov	r2, r3
 800d9ca:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
 800d9ce:	fbb3 f3f2 	udiv	r3, r3, r2
 800d9d2:	f44f 42fa 	mov.w	r2, #32000	@ 0x7d00
 800d9d6:	fbb2 f3f3 	udiv	r3, r2, r3
 800d9da:	60fb      	str	r3, [r7, #12]
        break;
 800d9dc:	e00d      	b.n	800d9fa <HAL_InitTick+0xae>
        ticknumber = (LSE_VALUE / (1000UL / (uint32_t)uwTickFreq));
 800d9de:	4b12      	ldr	r3, [pc, #72]	@ (800da28 <HAL_InitTick+0xdc>)
 800d9e0:	781b      	ldrb	r3, [r3, #0]
 800d9e2:	461a      	mov	r2, r3
 800d9e4:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
 800d9e8:	fbb3 f3f2 	udiv	r3, r3, r2
 800d9ec:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
 800d9f0:	fbb2 f3f3 	udiv	r3, r2, r3
 800d9f4:	60fb      	str	r3, [r7, #12]
        break;
 800d9f6:	e000      	b.n	800d9fa <HAL_InitTick+0xae>
        break;
 800d9f8:	bf00      	nop
    }
  }

  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(ticknumber) > 0U)
 800d9fa:	68f8      	ldr	r0, [r7, #12]
 800d9fc:	f000 f974 	bl	800dce8 <HAL_SYSTICK_Config>
 800da00:	4603      	mov	r3, r0
 800da02:	2b00      	cmp	r3, #0
 800da04:	d001      	beq.n	800da0a <HAL_InitTick+0xbe>
  {
    return HAL_ERROR;
 800da06:	2301      	movs	r3, #1
 800da08:	e009      	b.n	800da1e <HAL_InitTick+0xd2>
  }

  /* Configure the SysTick IRQ priority */
  HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 800da0a:	2200      	movs	r2, #0
 800da0c:	6879      	ldr	r1, [r7, #4]
 800da0e:	f04f 30ff 	mov.w	r0, #4294967295
 800da12:	f000 f92e 	bl	800dc72 <HAL_NVIC_SetPriority>
  uwTickPrio = TickPriority;
 800da16:	4a07      	ldr	r2, [pc, #28]	@ (800da34 <HAL_InitTick+0xe8>)
 800da18:	687b      	ldr	r3, [r7, #4]
 800da1a:	6013      	str	r3, [r2, #0]

  /* Return function status */
  return HAL_OK;
 800da1c:	2300      	movs	r3, #0
}
 800da1e:	4618      	mov	r0, r3
 800da20:	3710      	adds	r7, #16
 800da22:	46bd      	mov	sp, r7
 800da24:	bd80      	pop	{r7, pc}
 800da26:	bf00      	nop
 800da28:	200001e8 	.word	0x200001e8
 800da2c:	e000e010 	.word	0xe000e010
 800da30:	200001e0 	.word	0x200001e0
 800da34:	200001e4 	.word	0x200001e4

0800da38 <HAL_IncTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 800da38:	b480      	push	{r7}
 800da3a:	af00      	add	r7, sp, #0
  uwTick += (uint32_t)uwTickFreq;
 800da3c:	4b06      	ldr	r3, [pc, #24]	@ (800da58 <HAL_IncTick+0x20>)
 800da3e:	781b      	ldrb	r3, [r3, #0]
 800da40:	461a      	mov	r2, r3
 800da42:	4b06      	ldr	r3, [pc, #24]	@ (800da5c <HAL_IncTick+0x24>)
 800da44:	681b      	ldr	r3, [r3, #0]
 800da46:	4413      	add	r3, r2
 800da48:	4a04      	ldr	r2, [pc, #16]	@ (800da5c <HAL_IncTick+0x24>)
 800da4a:	6013      	str	r3, [r2, #0]
}
 800da4c:	bf00      	nop
 800da4e:	46bd      	mov	sp, r7
 800da50:	f85d 7b04 	ldr.w	r7, [sp], #4
 800da54:	4770      	bx	lr
 800da56:	bf00      	nop
 800da58:	200001e8 	.word	0x200001e8
 800da5c:	20000dd8 	.word	0x20000dd8

0800da60 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 800da60:	b480      	push	{r7}
 800da62:	af00      	add	r7, sp, #0
  return uwTick;
 800da64:	4b03      	ldr	r3, [pc, #12]	@ (800da74 <HAL_GetTick+0x14>)
 800da66:	681b      	ldr	r3, [r3, #0]
}
 800da68:	4618      	mov	r0, r3
 800da6a:	46bd      	mov	sp, r7
 800da6c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800da70:	4770      	bx	lr
 800da72:	bf00      	nop
 800da74:	20000dd8 	.word	0x20000dd8

0800da78 <HAL_GetHalVersion>:
/**
  * @brief  Returns the HAL revision
  * @retval version : 0xXYZR (8bits for each decimal, R for RC)
  */
uint32_t HAL_GetHalVersion(void)
{
 800da78:	b480      	push	{r7}
 800da7a:	af00      	add	r7, sp, #0
  return __STM32U5xx_HAL_VERSION;
 800da7c:	4b02      	ldr	r3, [pc, #8]	@ (800da88 <HAL_GetHalVersion+0x10>)
}
 800da7e:	4618      	mov	r0, r3
 800da80:	46bd      	mov	sp, r7
 800da82:	f85d 7b04 	ldr.w	r7, [sp], #4
 800da86:	4770      	bx	lr
 800da88:	01050000 	.word	0x01050000

0800da8c <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 800da8c:	b480      	push	{r7}
 800da8e:	b085      	sub	sp, #20
 800da90:	af00      	add	r7, sp, #0
 800da92:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 800da94:	687b      	ldr	r3, [r7, #4]
 800da96:	f003 0307 	and.w	r3, r3, #7
 800da9a:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800da9c:	4b0c      	ldr	r3, [pc, #48]	@ (800dad0 <__NVIC_SetPriorityGrouping+0x44>)
 800da9e:	68db      	ldr	r3, [r3, #12]
 800daa0:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 800daa2:	68ba      	ldr	r2, [r7, #8]
 800daa4:	f64f 03ff 	movw	r3, #63743	@ 0xf8ff
 800daa8:	4013      	ands	r3, r2
 800daaa:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 800daac:	68fb      	ldr	r3, [r7, #12]
 800daae:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 800dab0:	68bb      	ldr	r3, [r7, #8]
 800dab2:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 800dab4:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
 800dab8:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 800dabc:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
 800dabe:	4a04      	ldr	r2, [pc, #16]	@ (800dad0 <__NVIC_SetPriorityGrouping+0x44>)
 800dac0:	68bb      	ldr	r3, [r7, #8]
 800dac2:	60d3      	str	r3, [r2, #12]
}
 800dac4:	bf00      	nop
 800dac6:	3714      	adds	r7, #20
 800dac8:	46bd      	mov	sp, r7
 800daca:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dace:	4770      	bx	lr
 800dad0:	e000ed00 	.word	0xe000ed00

0800dad4 <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
 800dad4:	b480      	push	{r7}
 800dad6:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 800dad8:	4b04      	ldr	r3, [pc, #16]	@ (800daec <__NVIC_GetPriorityGrouping+0x18>)
 800dada:	68db      	ldr	r3, [r3, #12]
 800dadc:	0a1b      	lsrs	r3, r3, #8
 800dade:	f003 0307 	and.w	r3, r3, #7
}
 800dae2:	4618      	mov	r0, r3
 800dae4:	46bd      	mov	sp, r7
 800dae6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800daea:	4770      	bx	lr
 800daec:	e000ed00 	.word	0xe000ed00

0800daf0 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
 800daf0:	b480      	push	{r7}
 800daf2:	b083      	sub	sp, #12
 800daf4:	af00      	add	r7, sp, #0
 800daf6:	4603      	mov	r3, r0
 800daf8:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 800dafa:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800dafe:	2b00      	cmp	r3, #0
 800db00:	db0b      	blt.n	800db1a <__NVIC_EnableIRQ+0x2a>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800db02:	79fb      	ldrb	r3, [r7, #7]
 800db04:	f003 021f 	and.w	r2, r3, #31
 800db08:	4907      	ldr	r1, [pc, #28]	@ (800db28 <__NVIC_EnableIRQ+0x38>)
 800db0a:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800db0e:	095b      	lsrs	r3, r3, #5
 800db10:	2001      	movs	r0, #1
 800db12:	fa00 f202 	lsl.w	r2, r0, r2
 800db16:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    __COMPILER_BARRIER();
  }
}
 800db1a:	bf00      	nop
 800db1c:	370c      	adds	r7, #12
 800db1e:	46bd      	mov	sp, r7
 800db20:	f85d 7b04 	ldr.w	r7, [sp], #4
 800db24:	4770      	bx	lr
 800db26:	bf00      	nop
 800db28:	e000e100 	.word	0xe000e100

0800db2c <__NVIC_DisableIRQ>:
  \details Disables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
 800db2c:	b480      	push	{r7}
 800db2e:	b083      	sub	sp, #12
 800db30:	af00      	add	r7, sp, #0
 800db32:	4603      	mov	r3, r0
 800db34:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 800db36:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800db3a:	2b00      	cmp	r3, #0
 800db3c:	db12      	blt.n	800db64 <__NVIC_DisableIRQ+0x38>
  {
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800db3e:	79fb      	ldrb	r3, [r7, #7]
 800db40:	f003 021f 	and.w	r2, r3, #31
 800db44:	490a      	ldr	r1, [pc, #40]	@ (800db70 <__NVIC_DisableIRQ+0x44>)
 800db46:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800db4a:	095b      	lsrs	r3, r3, #5
 800db4c:	2001      	movs	r0, #1
 800db4e:	fa00 f202 	lsl.w	r2, r0, r2
 800db52:	3320      	adds	r3, #32
 800db54:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 800db58:	f3bf 8f4f 	dsb	sy
}
 800db5c:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 800db5e:	f3bf 8f6f 	isb	sy
}
 800db62:	bf00      	nop
    __DSB();
    __ISB();
  }
}
 800db64:	bf00      	nop
 800db66:	370c      	adds	r7, #12
 800db68:	46bd      	mov	sp, r7
 800db6a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800db6e:	4770      	bx	lr
 800db70:	e000e100 	.word	0xe000e100

0800db74 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 800db74:	b480      	push	{r7}
 800db76:	b083      	sub	sp, #12
 800db78:	af00      	add	r7, sp, #0
 800db7a:	4603      	mov	r3, r0
 800db7c:	6039      	str	r1, [r7, #0]
 800db7e:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 800db80:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800db84:	2b00      	cmp	r3, #0
 800db86:	db0a      	blt.n	800db9e <__NVIC_SetPriority+0x2a>
  {
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800db88:	683b      	ldr	r3, [r7, #0]
 800db8a:	b2da      	uxtb	r2, r3
 800db8c:	490c      	ldr	r1, [pc, #48]	@ (800dbc0 <__NVIC_SetPriority+0x4c>)
 800db8e:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800db92:	0112      	lsls	r2, r2, #4
 800db94:	b2d2      	uxtb	r2, r2
 800db96:	440b      	add	r3, r1
 800db98:	f883 2300 	strb.w	r2, [r3, #768]	@ 0x300
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
 800db9c:	e00a      	b.n	800dbb4 <__NVIC_SetPriority+0x40>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800db9e:	683b      	ldr	r3, [r7, #0]
 800dba0:	b2da      	uxtb	r2, r3
 800dba2:	4908      	ldr	r1, [pc, #32]	@ (800dbc4 <__NVIC_SetPriority+0x50>)
 800dba4:	79fb      	ldrb	r3, [r7, #7]
 800dba6:	f003 030f 	and.w	r3, r3, #15
 800dbaa:	3b04      	subs	r3, #4
 800dbac:	0112      	lsls	r2, r2, #4
 800dbae:	b2d2      	uxtb	r2, r2
 800dbb0:	440b      	add	r3, r1
 800dbb2:	761a      	strb	r2, [r3, #24]
}
 800dbb4:	bf00      	nop
 800dbb6:	370c      	adds	r7, #12
 800dbb8:	46bd      	mov	sp, r7
 800dbba:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dbbe:	4770      	bx	lr
 800dbc0:	e000e100 	.word	0xe000e100
 800dbc4:	e000ed00 	.word	0xe000ed00

0800dbc8 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 800dbc8:	b480      	push	{r7}
 800dbca:	b089      	sub	sp, #36	@ 0x24
 800dbcc:	af00      	add	r7, sp, #0
 800dbce:	60f8      	str	r0, [r7, #12]
 800dbd0:	60b9      	str	r1, [r7, #8]
 800dbd2:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 800dbd4:	68fb      	ldr	r3, [r7, #12]
 800dbd6:	f003 0307 	and.w	r3, r3, #7
 800dbda:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800dbdc:	69fb      	ldr	r3, [r7, #28]
 800dbde:	f1c3 0307 	rsb	r3, r3, #7
 800dbe2:	2b04      	cmp	r3, #4
 800dbe4:	bf28      	it	cs
 800dbe6:	2304      	movcs	r3, #4
 800dbe8:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800dbea:	69fb      	ldr	r3, [r7, #28]
 800dbec:	3304      	adds	r3, #4
 800dbee:	2b06      	cmp	r3, #6
 800dbf0:	d902      	bls.n	800dbf8 <NVIC_EncodePriority+0x30>
 800dbf2:	69fb      	ldr	r3, [r7, #28]
 800dbf4:	3b03      	subs	r3, #3
 800dbf6:	e000      	b.n	800dbfa <NVIC_EncodePriority+0x32>
 800dbf8:	2300      	movs	r3, #0
 800dbfa:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800dbfc:	f04f 32ff 	mov.w	r2, #4294967295
 800dc00:	69bb      	ldr	r3, [r7, #24]
 800dc02:	fa02 f303 	lsl.w	r3, r2, r3
 800dc06:	43da      	mvns	r2, r3
 800dc08:	68bb      	ldr	r3, [r7, #8]
 800dc0a:	401a      	ands	r2, r3
 800dc0c:	697b      	ldr	r3, [r7, #20]
 800dc0e:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 800dc10:	f04f 31ff 	mov.w	r1, #4294967295
 800dc14:	697b      	ldr	r3, [r7, #20]
 800dc16:	fa01 f303 	lsl.w	r3, r1, r3
 800dc1a:	43d9      	mvns	r1, r3
 800dc1c:	687b      	ldr	r3, [r7, #4]
 800dc1e:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800dc20:	4313      	orrs	r3, r2
         );
}
 800dc22:	4618      	mov	r0, r3
 800dc24:	3724      	adds	r7, #36	@ 0x24
 800dc26:	46bd      	mov	sp, r7
 800dc28:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dc2c:	4770      	bx	lr
	...

0800dc30 <__NVIC_SystemReset>:
/**
  \brief   System Reset
  \details Initiates a system reset request to reset the MCU.
 */
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
 800dc30:	b480      	push	{r7}
 800dc32:	af00      	add	r7, sp, #0
  __ASM volatile ("dsb 0xF":::"memory");
 800dc34:	f3bf 8f4f 	dsb	sy
}
 800dc38:	bf00      	nop
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 800dc3a:	4b06      	ldr	r3, [pc, #24]	@ (800dc54 <__NVIC_SystemReset+0x24>)
 800dc3c:	68db      	ldr	r3, [r3, #12]
 800dc3e:	f403 62e0 	and.w	r2, r3, #1792	@ 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 800dc42:	4904      	ldr	r1, [pc, #16]	@ (800dc54 <__NVIC_SystemReset+0x24>)
 800dc44:	4b04      	ldr	r3, [pc, #16]	@ (800dc58 <__NVIC_SystemReset+0x28>)
 800dc46:	4313      	orrs	r3, r2
 800dc48:	60cb      	str	r3, [r1, #12]
  __ASM volatile ("dsb 0xF":::"memory");
 800dc4a:	f3bf 8f4f 	dsb	sy
}
 800dc4e:	bf00      	nop
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
 800dc50:	bf00      	nop
 800dc52:	e7fd      	b.n	800dc50 <__NVIC_SystemReset+0x20>
 800dc54:	e000ed00 	.word	0xe000ed00
 800dc58:	05fa0004 	.word	0x05fa0004

0800dc5c <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ pre-emption is no more possible.
  *         The pending IRQ priority will be managed only by the subpriority.
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 800dc5c:	b580      	push	{r7, lr}
 800dc5e:	b082      	sub	sp, #8
 800dc60:	af00      	add	r7, sp, #0
 800dc62:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
 800dc64:	6878      	ldr	r0, [r7, #4]
 800dc66:	f7ff ff11 	bl	800da8c <__NVIC_SetPriorityGrouping>
}
 800dc6a:	bf00      	nop
 800dc6c:	3708      	adds	r7, #8
 800dc6e:	46bd      	mov	sp, r7
 800dc70:	bd80      	pop	{r7, pc}

0800dc72 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 800dc72:	b580      	push	{r7, lr}
 800dc74:	b086      	sub	sp, #24
 800dc76:	af00      	add	r7, sp, #0
 800dc78:	4603      	mov	r3, r0
 800dc7a:	60b9      	str	r1, [r7, #8]
 800dc7c:	607a      	str	r2, [r7, #4]
 800dc7e:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();
 800dc80:	f7ff ff28 	bl	800dad4 <__NVIC_GetPriorityGrouping>
 800dc84:	6178      	str	r0, [r7, #20]

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 800dc86:	687a      	ldr	r2, [r7, #4]
 800dc88:	68b9      	ldr	r1, [r7, #8]
 800dc8a:	6978      	ldr	r0, [r7, #20]
 800dc8c:	f7ff ff9c 	bl	800dbc8 <NVIC_EncodePriority>
 800dc90:	4602      	mov	r2, r0
 800dc92:	f997 300f 	ldrsb.w	r3, [r7, #15]
 800dc96:	4611      	mov	r1, r2
 800dc98:	4618      	mov	r0, r3
 800dc9a:	f7ff ff6b 	bl	800db74 <__NVIC_SetPriority>
}
 800dc9e:	bf00      	nop
 800dca0:	3718      	adds	r7, #24
 800dca2:	46bd      	mov	sp, r7
 800dca4:	bd80      	pop	{r7, pc}

0800dca6 <HAL_NVIC_EnableIRQ>:
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate
  *          CMSIS device file (stm32u5xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 800dca6:	b580      	push	{r7, lr}
 800dca8:	b082      	sub	sp, #8
 800dcaa:	af00      	add	r7, sp, #0
 800dcac:	4603      	mov	r3, r0
 800dcae:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 800dcb0:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800dcb4:	4618      	mov	r0, r3
 800dcb6:	f7ff ff1b 	bl	800daf0 <__NVIC_EnableIRQ>
}
 800dcba:	bf00      	nop
 800dcbc:	3708      	adds	r7, #8
 800dcbe:	46bd      	mov	sp, r7
 800dcc0:	bd80      	pop	{r7, pc}

0800dcc2 <HAL_NVIC_DisableIRQ>:
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate
  *          CMSIS device file (stm32u5xxxx.h))
  * @retval None
  */
void HAL_NVIC_DisableIRQ(IRQn_Type IRQn)
{
 800dcc2:	b580      	push	{r7, lr}
 800dcc4:	b082      	sub	sp, #8
 800dcc6:	af00      	add	r7, sp, #0
 800dcc8:	4603      	mov	r3, r0
 800dcca:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Disable interrupt */
  NVIC_DisableIRQ(IRQn);
 800dccc:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800dcd0:	4618      	mov	r0, r3
 800dcd2:	f7ff ff2b 	bl	800db2c <__NVIC_DisableIRQ>
}
 800dcd6:	bf00      	nop
 800dcd8:	3708      	adds	r7, #8
 800dcda:	46bd      	mov	sp, r7
 800dcdc:	bd80      	pop	{r7, pc}

0800dcde <HAL_NVIC_SystemReset>:
/**
  * @brief  Initiate a system reset request to reset the MCU.
  * @retval None
  */
void HAL_NVIC_SystemReset(void)
{
 800dcde:	b580      	push	{r7, lr}
 800dce0:	af00      	add	r7, sp, #0
  /* System Reset */
  NVIC_SystemReset();
 800dce2:	f7ff ffa5 	bl	800dc30 <__NVIC_SystemReset>
	...

0800dce8 <HAL_SYSTICK_Config>:
  * @param  TicksNumb: Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 800dce8:	b480      	push	{r7}
 800dcea:	b083      	sub	sp, #12
 800dcec:	af00      	add	r7, sp, #0
 800dcee:	6078      	str	r0, [r7, #4]
  if ((TicksNumb - 1UL) > SysTick_LOAD_RELOAD_Msk)
 800dcf0:	687b      	ldr	r3, [r7, #4]
 800dcf2:	3b01      	subs	r3, #1
 800dcf4:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
 800dcf8:	d301      	bcc.n	800dcfe <HAL_SYSTICK_Config+0x16>
  {
    /* Reload value impossible */
    return (1UL);
 800dcfa:	2301      	movs	r3, #1
 800dcfc:	e00d      	b.n	800dd1a <HAL_SYSTICK_Config+0x32>
  }

  /* Set reload register */
  WRITE_REG(SysTick->LOAD, (uint32_t)(TicksNumb - 1UL));
 800dcfe:	4a0a      	ldr	r2, [pc, #40]	@ (800dd28 <HAL_SYSTICK_Config+0x40>)
 800dd00:	687b      	ldr	r3, [r7, #4]
 800dd02:	3b01      	subs	r3, #1
 800dd04:	6053      	str	r3, [r2, #4]

  /* Load the SysTick Counter Value */
  WRITE_REG(SysTick->VAL, 0UL);
 800dd06:	4b08      	ldr	r3, [pc, #32]	@ (800dd28 <HAL_SYSTICK_Config+0x40>)
 800dd08:	2200      	movs	r2, #0
 800dd0a:	609a      	str	r2, [r3, #8]

  /* Enable SysTick IRQ and SysTick Timer */
  SET_BIT(SysTick->CTRL, (SysTick_CTRL_TICKINT_Msk | SysTick_CTRL_ENABLE_Msk));
 800dd0c:	4b06      	ldr	r3, [pc, #24]	@ (800dd28 <HAL_SYSTICK_Config+0x40>)
 800dd0e:	681b      	ldr	r3, [r3, #0]
 800dd10:	4a05      	ldr	r2, [pc, #20]	@ (800dd28 <HAL_SYSTICK_Config+0x40>)
 800dd12:	f043 0303 	orr.w	r3, r3, #3
 800dd16:	6013      	str	r3, [r2, #0]

  /* Function successful */
  return (0UL);
 800dd18:	2300      	movs	r3, #0
}
 800dd1a:	4618      	mov	r0, r3
 800dd1c:	370c      	adds	r7, #12
 800dd1e:	46bd      	mov	sp, r7
 800dd20:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dd24:	4770      	bx	lr
 800dd26:	bf00      	nop
 800dd28:	e000e010 	.word	0xe000e010

0800dd2c <HAL_SYSTICK_CLKSourceConfig>:
  *             @arg SYSTICK_CLKSOURCE_HCLK: AHB clock selected as SysTick clock source.
  *             @arg SYSTICK_CLKSOURCE_HCLK_DIV8: AHB clock divided by 8 selected as SysTick clock source.
  * @retval None
  */
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
 800dd2c:	b480      	push	{r7}
 800dd2e:	b083      	sub	sp, #12
 800dd30:	af00      	add	r7, sp, #0
 800dd32:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  switch (CLKSource)
 800dd34:	687b      	ldr	r3, [r7, #4]
 800dd36:	2b04      	cmp	r3, #4
 800dd38:	d844      	bhi.n	800ddc4 <HAL_SYSTICK_CLKSourceConfig+0x98>
 800dd3a:	a201      	add	r2, pc, #4	@ (adr r2, 800dd40 <HAL_SYSTICK_CLKSourceConfig+0x14>)
 800dd3c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800dd40:	0800dd63 	.word	0x0800dd63
 800dd44:	0800dd81 	.word	0x0800dd81
 800dd48:	0800dda3 	.word	0x0800dda3
 800dd4c:	0800ddc5 	.word	0x0800ddc5
 800dd50:	0800dd55 	.word	0x0800dd55
  {
    /* Select HCLK as Systick clock source */
    case SYSTICK_CLKSOURCE_HCLK:
      SET_BIT(SysTick->CTRL, SysTick_CTRL_CLKSOURCE_Msk);
 800dd54:	4b1f      	ldr	r3, [pc, #124]	@ (800ddd4 <HAL_SYSTICK_CLKSourceConfig+0xa8>)
 800dd56:	681b      	ldr	r3, [r3, #0]
 800dd58:	4a1e      	ldr	r2, [pc, #120]	@ (800ddd4 <HAL_SYSTICK_CLKSourceConfig+0xa8>)
 800dd5a:	f043 0304 	orr.w	r3, r3, #4
 800dd5e:	6013      	str	r3, [r2, #0]
      break;
 800dd60:	e031      	b.n	800ddc6 <HAL_SYSTICK_CLKSourceConfig+0x9a>
    /* Select HCLK_DIV8 as Systick clock source */
    case SYSTICK_CLKSOURCE_HCLK_DIV8:
      CLEAR_BIT(SysTick->CTRL, SysTick_CTRL_CLKSOURCE_Msk);
 800dd62:	4b1c      	ldr	r3, [pc, #112]	@ (800ddd4 <HAL_SYSTICK_CLKSourceConfig+0xa8>)
 800dd64:	681b      	ldr	r3, [r3, #0]
 800dd66:	4a1b      	ldr	r2, [pc, #108]	@ (800ddd4 <HAL_SYSTICK_CLKSourceConfig+0xa8>)
 800dd68:	f023 0304 	bic.w	r3, r3, #4
 800dd6c:	6013      	str	r3, [r2, #0]
      MODIFY_REG(RCC->CCIPR1, RCC_CCIPR1_SYSTICKSEL, (0x00000000U));
 800dd6e:	4b1a      	ldr	r3, [pc, #104]	@ (800ddd8 <HAL_SYSTICK_CLKSourceConfig+0xac>)
 800dd70:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 800dd74:	4a18      	ldr	r2, [pc, #96]	@ (800ddd8 <HAL_SYSTICK_CLKSourceConfig+0xac>)
 800dd76:	f423 0340 	bic.w	r3, r3, #12582912	@ 0xc00000
 800dd7a:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
      break;
 800dd7e:	e022      	b.n	800ddc6 <HAL_SYSTICK_CLKSourceConfig+0x9a>
    /* Select LSI as Systick clock source */
    case SYSTICK_CLKSOURCE_LSI:
      CLEAR_BIT(SysTick->CTRL, SysTick_CTRL_CLKSOURCE_Msk);
 800dd80:	4b14      	ldr	r3, [pc, #80]	@ (800ddd4 <HAL_SYSTICK_CLKSourceConfig+0xa8>)
 800dd82:	681b      	ldr	r3, [r3, #0]
 800dd84:	4a13      	ldr	r2, [pc, #76]	@ (800ddd4 <HAL_SYSTICK_CLKSourceConfig+0xa8>)
 800dd86:	f023 0304 	bic.w	r3, r3, #4
 800dd8a:	6013      	str	r3, [r2, #0]
      MODIFY_REG(RCC->CCIPR1, RCC_CCIPR1_SYSTICKSEL, RCC_CCIPR1_SYSTICKSEL_0);
 800dd8c:	4b12      	ldr	r3, [pc, #72]	@ (800ddd8 <HAL_SYSTICK_CLKSourceConfig+0xac>)
 800dd8e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 800dd92:	f423 0340 	bic.w	r3, r3, #12582912	@ 0xc00000
 800dd96:	4a10      	ldr	r2, [pc, #64]	@ (800ddd8 <HAL_SYSTICK_CLKSourceConfig+0xac>)
 800dd98:	f443 0380 	orr.w	r3, r3, #4194304	@ 0x400000
 800dd9c:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
      break;
 800dda0:	e011      	b.n	800ddc6 <HAL_SYSTICK_CLKSourceConfig+0x9a>
    /* Select LSE as Systick clock source */
    case SYSTICK_CLKSOURCE_LSE:
      CLEAR_BIT(SysTick->CTRL, SysTick_CTRL_CLKSOURCE_Msk);
 800dda2:	4b0c      	ldr	r3, [pc, #48]	@ (800ddd4 <HAL_SYSTICK_CLKSourceConfig+0xa8>)
 800dda4:	681b      	ldr	r3, [r3, #0]
 800dda6:	4a0b      	ldr	r2, [pc, #44]	@ (800ddd4 <HAL_SYSTICK_CLKSourceConfig+0xa8>)
 800dda8:	f023 0304 	bic.w	r3, r3, #4
 800ddac:	6013      	str	r3, [r2, #0]
      MODIFY_REG(RCC->CCIPR1, RCC_CCIPR1_SYSTICKSEL, RCC_CCIPR1_SYSTICKSEL_1);
 800ddae:	4b0a      	ldr	r3, [pc, #40]	@ (800ddd8 <HAL_SYSTICK_CLKSourceConfig+0xac>)
 800ddb0:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 800ddb4:	f423 0340 	bic.w	r3, r3, #12582912	@ 0xc00000
 800ddb8:	4a07      	ldr	r2, [pc, #28]	@ (800ddd8 <HAL_SYSTICK_CLKSourceConfig+0xac>)
 800ddba:	f443 0300 	orr.w	r3, r3, #8388608	@ 0x800000
 800ddbe:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
      break;
 800ddc2:	e000      	b.n	800ddc6 <HAL_SYSTICK_CLKSourceConfig+0x9a>
    default:
      /* Nothing to do */
      break;
 800ddc4:	bf00      	nop
  }
}
 800ddc6:	bf00      	nop
 800ddc8:	370c      	adds	r7, #12
 800ddca:	46bd      	mov	sp, r7
 800ddcc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ddd0:	4770      	bx	lr
 800ddd2:	bf00      	nop
 800ddd4:	e000e010 	.word	0xe000e010
 800ddd8:	46020c00 	.word	0x46020c00

0800dddc <HAL_SYSTICK_GetCLKSourceConfig>:
  *             @arg SYSTICK_CLKSOURCE_LSE: LSE clock selected as SysTick clock source.
  *             @arg SYSTICK_CLKSOURCE_HCLK: AHB clock selected as SysTick clock source.
  *             @arg SYSTICK_CLKSOURCE_HCLK_DIV8: AHB clock divided by 8 selected as SysTick clock source.
  */
uint32_t HAL_SYSTICK_GetCLKSourceConfig(void)
{
 800dddc:	b480      	push	{r7}
 800ddde:	b083      	sub	sp, #12
 800dde0:	af00      	add	r7, sp, #0
  uint32_t systick_source;
  uint32_t systick_rcc_source;

  /* Read SysTick->CTRL register for internal or external clock source */
  if (READ_BIT(SysTick->CTRL, SysTick_CTRL_CLKSOURCE_Msk) != 0U)
 800dde2:	4b19      	ldr	r3, [pc, #100]	@ (800de48 <HAL_SYSTICK_GetCLKSourceConfig+0x6c>)
 800dde4:	681b      	ldr	r3, [r3, #0]
 800dde6:	f003 0304 	and.w	r3, r3, #4
 800ddea:	2b00      	cmp	r3, #0
 800ddec:	d002      	beq.n	800ddf4 <HAL_SYSTICK_GetCLKSourceConfig+0x18>
  {
    /* Internal clock source */
    systick_source = SYSTICK_CLKSOURCE_HCLK;
 800ddee:	2304      	movs	r3, #4
 800ddf0:	607b      	str	r3, [r7, #4]
 800ddf2:	e021      	b.n	800de38 <HAL_SYSTICK_GetCLKSourceConfig+0x5c>
  }
  else
  {
    /* External clock source, check the selected one in RCC */
    systick_rcc_source = READ_BIT(RCC->CCIPR1, RCC_CCIPR1_SYSTICKSEL);
 800ddf4:	4b15      	ldr	r3, [pc, #84]	@ (800de4c <HAL_SYSTICK_GetCLKSourceConfig+0x70>)
 800ddf6:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 800ddfa:	f403 0340 	and.w	r3, r3, #12582912	@ 0xc00000
 800ddfe:	603b      	str	r3, [r7, #0]

    switch (systick_rcc_source)
 800de00:	683b      	ldr	r3, [r7, #0]
 800de02:	f5b3 0f00 	cmp.w	r3, #8388608	@ 0x800000
 800de06:	d011      	beq.n	800de2c <HAL_SYSTICK_GetCLKSourceConfig+0x50>
 800de08:	683b      	ldr	r3, [r7, #0]
 800de0a:	f5b3 0f00 	cmp.w	r3, #8388608	@ 0x800000
 800de0e:	d810      	bhi.n	800de32 <HAL_SYSTICK_GetCLKSourceConfig+0x56>
 800de10:	683b      	ldr	r3, [r7, #0]
 800de12:	2b00      	cmp	r3, #0
 800de14:	d004      	beq.n	800de20 <HAL_SYSTICK_GetCLKSourceConfig+0x44>
 800de16:	683b      	ldr	r3, [r7, #0]
 800de18:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
 800de1c:	d003      	beq.n	800de26 <HAL_SYSTICK_GetCLKSourceConfig+0x4a>
 800de1e:	e008      	b.n	800de32 <HAL_SYSTICK_GetCLKSourceConfig+0x56>
    {
      case (0x00000000U):
        systick_source = SYSTICK_CLKSOURCE_HCLK_DIV8;
 800de20:	2300      	movs	r3, #0
 800de22:	607b      	str	r3, [r7, #4]
        break;
 800de24:	e008      	b.n	800de38 <HAL_SYSTICK_GetCLKSourceConfig+0x5c>

      case (RCC_CCIPR1_SYSTICKSEL_0):
        systick_source = SYSTICK_CLKSOURCE_LSI;
 800de26:	2301      	movs	r3, #1
 800de28:	607b      	str	r3, [r7, #4]
        break;
 800de2a:	e005      	b.n	800de38 <HAL_SYSTICK_GetCLKSourceConfig+0x5c>

      case (RCC_CCIPR1_SYSTICKSEL_1):
        systick_source = SYSTICK_CLKSOURCE_LSE;
 800de2c:	2302      	movs	r3, #2
 800de2e:	607b      	str	r3, [r7, #4]
        break;
 800de30:	e002      	b.n	800de38 <HAL_SYSTICK_GetCLKSourceConfig+0x5c>

      default:
        systick_source = SYSTICK_CLKSOURCE_HCLK_DIV8;
 800de32:	2300      	movs	r3, #0
 800de34:	607b      	str	r3, [r7, #4]
        break;
 800de36:	bf00      	nop
    }
  }
  return systick_source;
 800de38:	687b      	ldr	r3, [r7, #4]
}
 800de3a:	4618      	mov	r0, r3
 800de3c:	370c      	adds	r7, #12
 800de3e:	46bd      	mov	sp, r7
 800de40:	f85d 7b04 	ldr.w	r7, [sp], #4
 800de44:	4770      	bx	lr
 800de46:	bf00      	nop
 800de48:	e000e010 	.word	0xe000e010
 800de4c:	46020c00 	.word	0x46020c00

0800de50 <HAL_CRC_Init>:
  *         parameters in the CRC_InitTypeDef and create the associated handle.
  * @param  hcrc CRC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CRC_Init(CRC_HandleTypeDef *hcrc)
{
 800de50:	b580      	push	{r7, lr}
 800de52:	b082      	sub	sp, #8
 800de54:	af00      	add	r7, sp, #0
 800de56:	6078      	str	r0, [r7, #4]
  /* Check the CRC handle allocation */
  if (hcrc == NULL)
 800de58:	687b      	ldr	r3, [r7, #4]
 800de5a:	2b00      	cmp	r3, #0
 800de5c:	d101      	bne.n	800de62 <HAL_CRC_Init+0x12>
  {
    return HAL_ERROR;
 800de5e:	2301      	movs	r3, #1
 800de60:	e054      	b.n	800df0c <HAL_CRC_Init+0xbc>
  }

  /* Check the parameters */
  assert_param(IS_CRC_ALL_INSTANCE(hcrc->Instance));

  if (hcrc->State == HAL_CRC_STATE_RESET)
 800de62:	687b      	ldr	r3, [r7, #4]
 800de64:	7f5b      	ldrb	r3, [r3, #29]
 800de66:	b2db      	uxtb	r3, r3
 800de68:	2b00      	cmp	r3, #0
 800de6a:	d105      	bne.n	800de78 <HAL_CRC_Init+0x28>
  {
    /* Allocate lock resource and initialize it */
    hcrc->Lock = HAL_UNLOCKED;
 800de6c:	687b      	ldr	r3, [r7, #4]
 800de6e:	2200      	movs	r2, #0
 800de70:	771a      	strb	r2, [r3, #28]
    /* Init the low level hardware */
    HAL_CRC_MspInit(hcrc);
 800de72:	6878      	ldr	r0, [r7, #4]
 800de74:	f7f8 f992 	bl	800619c <HAL_CRC_MspInit>
  }

  hcrc->State = HAL_CRC_STATE_BUSY;
 800de78:	687b      	ldr	r3, [r7, #4]
 800de7a:	2202      	movs	r2, #2
 800de7c:	775a      	strb	r2, [r3, #29]

  /* check whether or not non-default generating polynomial has been
   * picked up by user */
  assert_param(IS_DEFAULT_POLYNOMIAL(hcrc->Init.DefaultPolynomialUse));
  if (hcrc->Init.DefaultPolynomialUse == DEFAULT_POLYNOMIAL_ENABLE)
 800de7e:	687b      	ldr	r3, [r7, #4]
 800de80:	791b      	ldrb	r3, [r3, #4]
 800de82:	2b00      	cmp	r3, #0
 800de84:	d10c      	bne.n	800dea0 <HAL_CRC_Init+0x50>
  {
    /* initialize peripheral with default generating polynomial */
    WRITE_REG(hcrc->Instance->POL, DEFAULT_CRC32_POLY);
 800de86:	687b      	ldr	r3, [r7, #4]
 800de88:	681b      	ldr	r3, [r3, #0]
 800de8a:	4a22      	ldr	r2, [pc, #136]	@ (800df14 <HAL_CRC_Init+0xc4>)
 800de8c:	615a      	str	r2, [r3, #20]
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, CRC_POLYLENGTH_32B);
 800de8e:	687b      	ldr	r3, [r7, #4]
 800de90:	681b      	ldr	r3, [r3, #0]
 800de92:	689a      	ldr	r2, [r3, #8]
 800de94:	687b      	ldr	r3, [r7, #4]
 800de96:	681b      	ldr	r3, [r3, #0]
 800de98:	f022 0218 	bic.w	r2, r2, #24
 800de9c:	609a      	str	r2, [r3, #8]
 800de9e:	e00c      	b.n	800deba <HAL_CRC_Init+0x6a>
  }
  else
  {
    /* initialize CRC peripheral with generating polynomial defined by user */
    if (HAL_CRCEx_Polynomial_Set(hcrc, hcrc->Init.GeneratingPolynomial, hcrc->Init.CRCLength) != HAL_OK)
 800dea0:	687b      	ldr	r3, [r7, #4]
 800dea2:	6899      	ldr	r1, [r3, #8]
 800dea4:	687b      	ldr	r3, [r7, #4]
 800dea6:	68db      	ldr	r3, [r3, #12]
 800dea8:	461a      	mov	r2, r3
 800deaa:	6878      	ldr	r0, [r7, #4]
 800deac:	f000 f984 	bl	800e1b8 <HAL_CRCEx_Polynomial_Set>
 800deb0:	4603      	mov	r3, r0
 800deb2:	2b00      	cmp	r3, #0
 800deb4:	d001      	beq.n	800deba <HAL_CRC_Init+0x6a>
    {
      return HAL_ERROR;
 800deb6:	2301      	movs	r3, #1
 800deb8:	e028      	b.n	800df0c <HAL_CRC_Init+0xbc>
  }

  /* check whether or not non-default CRC initial value has been
   * picked up by user */
  assert_param(IS_DEFAULT_INIT_VALUE(hcrc->Init.DefaultInitValueUse));
  if (hcrc->Init.DefaultInitValueUse == DEFAULT_INIT_VALUE_ENABLE)
 800deba:	687b      	ldr	r3, [r7, #4]
 800debc:	795b      	ldrb	r3, [r3, #5]
 800debe:	2b00      	cmp	r3, #0
 800dec0:	d105      	bne.n	800dece <HAL_CRC_Init+0x7e>
  {
    WRITE_REG(hcrc->Instance->INIT, DEFAULT_CRC_INITVALUE);
 800dec2:	687b      	ldr	r3, [r7, #4]
 800dec4:	681b      	ldr	r3, [r3, #0]
 800dec6:	f04f 32ff 	mov.w	r2, #4294967295
 800deca:	611a      	str	r2, [r3, #16]
 800decc:	e004      	b.n	800ded8 <HAL_CRC_Init+0x88>
  }
  else
  {
    WRITE_REG(hcrc->Instance->INIT, hcrc->Init.InitValue);
 800dece:	687b      	ldr	r3, [r7, #4]
 800ded0:	681b      	ldr	r3, [r3, #0]
 800ded2:	687a      	ldr	r2, [r7, #4]
 800ded4:	6912      	ldr	r2, [r2, #16]
 800ded6:	611a      	str	r2, [r3, #16]
  }


  /* set input data inversion mode */
  assert_param(IS_CRC_INPUTDATA_INVERSION_MODE(hcrc->Init.InputDataInversionMode));
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_IN, hcrc->Init.InputDataInversionMode);
 800ded8:	687b      	ldr	r3, [r7, #4]
 800deda:	681b      	ldr	r3, [r3, #0]
 800dedc:	689b      	ldr	r3, [r3, #8]
 800dede:	f023 0160 	bic.w	r1, r3, #96	@ 0x60
 800dee2:	687b      	ldr	r3, [r7, #4]
 800dee4:	695a      	ldr	r2, [r3, #20]
 800dee6:	687b      	ldr	r3, [r7, #4]
 800dee8:	681b      	ldr	r3, [r3, #0]
 800deea:	430a      	orrs	r2, r1
 800deec:	609a      	str	r2, [r3, #8]

  /* set output data inversion mode */
  assert_param(IS_CRC_OUTPUTDATA_INVERSION_MODE(hcrc->Init.OutputDataInversionMode));
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_OUT, hcrc->Init.OutputDataInversionMode);
 800deee:	687b      	ldr	r3, [r7, #4]
 800def0:	681b      	ldr	r3, [r3, #0]
 800def2:	689b      	ldr	r3, [r3, #8]
 800def4:	f023 0180 	bic.w	r1, r3, #128	@ 0x80
 800def8:	687b      	ldr	r3, [r7, #4]
 800defa:	699a      	ldr	r2, [r3, #24]
 800defc:	687b      	ldr	r3, [r7, #4]
 800defe:	681b      	ldr	r3, [r3, #0]
 800df00:	430a      	orrs	r2, r1
 800df02:	609a      	str	r2, [r3, #8]
  /* makes sure the input data format (bytes, halfwords or words stream)
   * is properly specified by user */
  assert_param(IS_CRC_INPUTDATA_FORMAT(hcrc->InputDataFormat));

  /* Change CRC peripheral state */
  hcrc->State = HAL_CRC_STATE_READY;
 800df04:	687b      	ldr	r3, [r7, #4]
 800df06:	2201      	movs	r2, #1
 800df08:	775a      	strb	r2, [r3, #29]

  /* Return function status */
  return HAL_OK;
 800df0a:	2300      	movs	r3, #0
}
 800df0c:	4618      	mov	r0, r3
 800df0e:	3708      	adds	r7, #8
 800df10:	46bd      	mov	sp, r7
 800df12:	bd80      	pop	{r7, pc}
 800df14:	04c11db7 	.word	0x04c11db7

0800df18 <HAL_CRC_DeInit>:
  * @brief  DeInitialize the CRC peripheral.
  * @param  hcrc CRC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CRC_DeInit(CRC_HandleTypeDef *hcrc)
{
 800df18:	b580      	push	{r7, lr}
 800df1a:	b082      	sub	sp, #8
 800df1c:	af00      	add	r7, sp, #0
 800df1e:	6078      	str	r0, [r7, #4]
  /* Check the CRC handle allocation */
  if (hcrc == NULL)
 800df20:	687b      	ldr	r3, [r7, #4]
 800df22:	2b00      	cmp	r3, #0
 800df24:	d101      	bne.n	800df2a <HAL_CRC_DeInit+0x12>
  {
    return HAL_ERROR;
 800df26:	2301      	movs	r3, #1
 800df28:	e01f      	b.n	800df6a <HAL_CRC_DeInit+0x52>

  /* Check the parameters */
  assert_param(IS_CRC_ALL_INSTANCE(hcrc->Instance));

  /* Check the CRC peripheral state */
  if (hcrc->State == HAL_CRC_STATE_BUSY)
 800df2a:	687b      	ldr	r3, [r7, #4]
 800df2c:	7f5b      	ldrb	r3, [r3, #29]
 800df2e:	b2db      	uxtb	r3, r3
 800df30:	2b02      	cmp	r3, #2
 800df32:	d101      	bne.n	800df38 <HAL_CRC_DeInit+0x20>
  {
    return HAL_BUSY;
 800df34:	2302      	movs	r3, #2
 800df36:	e018      	b.n	800df6a <HAL_CRC_DeInit+0x52>
  }

  /* Change CRC peripheral state */
  hcrc->State = HAL_CRC_STATE_BUSY;
 800df38:	687b      	ldr	r3, [r7, #4]
 800df3a:	2202      	movs	r2, #2
 800df3c:	775a      	strb	r2, [r3, #29]

  /* Reset CRC calculation unit */
  __HAL_CRC_DR_RESET(hcrc);
 800df3e:	687b      	ldr	r3, [r7, #4]
 800df40:	681b      	ldr	r3, [r3, #0]
 800df42:	689a      	ldr	r2, [r3, #8]
 800df44:	687b      	ldr	r3, [r7, #4]
 800df46:	681b      	ldr	r3, [r3, #0]
 800df48:	f042 0201 	orr.w	r2, r2, #1
 800df4c:	609a      	str	r2, [r3, #8]

  /* Reset IDR register content */
  CLEAR_REG(hcrc->Instance->IDR);
 800df4e:	687b      	ldr	r3, [r7, #4]
 800df50:	681b      	ldr	r3, [r3, #0]
 800df52:	2200      	movs	r2, #0
 800df54:	605a      	str	r2, [r3, #4]

  /* DeInit the low level hardware */
  HAL_CRC_MspDeInit(hcrc);
 800df56:	6878      	ldr	r0, [r7, #4]
 800df58:	f7f8 f942 	bl	80061e0 <HAL_CRC_MspDeInit>

  /* Change CRC peripheral state */
  hcrc->State = HAL_CRC_STATE_RESET;
 800df5c:	687b      	ldr	r3, [r7, #4]
 800df5e:	2200      	movs	r2, #0
 800df60:	775a      	strb	r2, [r3, #29]

  /* Process unlocked */
  __HAL_UNLOCK(hcrc);
 800df62:	687b      	ldr	r3, [r7, #4]
 800df64:	2200      	movs	r2, #0
 800df66:	771a      	strb	r2, [r3, #28]

  /* Return function status */
  return HAL_OK;
 800df68:	2300      	movs	r3, #0
}
 800df6a:	4618      	mov	r0, r3
 800df6c:	3708      	adds	r7, #8
 800df6e:	46bd      	mov	sp, r7
 800df70:	bd80      	pop	{r7, pc}

0800df72 <HAL_CRC_Calculate>:
  *        and the API will internally adjust its input data processing based on the
  *        handle field hcrc->InputDataFormat.
  * @retval uint32_t CRC (returned value LSBs for CRC shorter than 32 bits)
  */
uint32_t HAL_CRC_Calculate(CRC_HandleTypeDef *hcrc, uint32_t pBuffer[], uint32_t BufferLength)
{
 800df72:	b580      	push	{r7, lr}
 800df74:	b086      	sub	sp, #24
 800df76:	af00      	add	r7, sp, #0
 800df78:	60f8      	str	r0, [r7, #12]
 800df7a:	60b9      	str	r1, [r7, #8]
 800df7c:	607a      	str	r2, [r7, #4]
  uint32_t index;      /* CRC input data buffer index */
  uint32_t temp = 0U;  /* CRC output (read from hcrc->Instance->DR register) */
 800df7e:	2300      	movs	r3, #0
 800df80:	613b      	str	r3, [r7, #16]

  /* Change CRC peripheral state */
  hcrc->State = HAL_CRC_STATE_BUSY;
 800df82:	68fb      	ldr	r3, [r7, #12]
 800df84:	2202      	movs	r2, #2
 800df86:	775a      	strb	r2, [r3, #29]

  /* Reset CRC Calculation Unit (hcrc->Instance->INIT is
  *  written in hcrc->Instance->DR) */
  __HAL_CRC_DR_RESET(hcrc);
 800df88:	68fb      	ldr	r3, [r7, #12]
 800df8a:	681b      	ldr	r3, [r3, #0]
 800df8c:	689a      	ldr	r2, [r3, #8]
 800df8e:	68fb      	ldr	r3, [r7, #12]
 800df90:	681b      	ldr	r3, [r3, #0]
 800df92:	f042 0201 	orr.w	r2, r2, #1
 800df96:	609a      	str	r2, [r3, #8]

  switch (hcrc->InputDataFormat)
 800df98:	68fb      	ldr	r3, [r7, #12]
 800df9a:	6a1b      	ldr	r3, [r3, #32]
 800df9c:	2b03      	cmp	r3, #3
 800df9e:	d006      	beq.n	800dfae <HAL_CRC_Calculate+0x3c>
 800dfa0:	2b03      	cmp	r3, #3
 800dfa2:	d829      	bhi.n	800dff8 <HAL_CRC_Calculate+0x86>
 800dfa4:	2b01      	cmp	r3, #1
 800dfa6:	d019      	beq.n	800dfdc <HAL_CRC_Calculate+0x6a>
 800dfa8:	2b02      	cmp	r3, #2
 800dfaa:	d01e      	beq.n	800dfea <HAL_CRC_Calculate+0x78>
      /* Specific 16-bit input data handling  */
      temp = CRC_Handle_16(hcrc, (uint16_t *)(void *)pBuffer, BufferLength);    /* Derogation MisraC2012 R.11.5 */
      break;

    default:
      break;
 800dfac:	e024      	b.n	800dff8 <HAL_CRC_Calculate+0x86>
      for (index = 0U; index < BufferLength; index++)
 800dfae:	2300      	movs	r3, #0
 800dfb0:	617b      	str	r3, [r7, #20]
 800dfb2:	e00a      	b.n	800dfca <HAL_CRC_Calculate+0x58>
        hcrc->Instance->DR = pBuffer[index];
 800dfb4:	697b      	ldr	r3, [r7, #20]
 800dfb6:	009b      	lsls	r3, r3, #2
 800dfb8:	68ba      	ldr	r2, [r7, #8]
 800dfba:	441a      	add	r2, r3
 800dfbc:	68fb      	ldr	r3, [r7, #12]
 800dfbe:	681b      	ldr	r3, [r3, #0]
 800dfc0:	6812      	ldr	r2, [r2, #0]
 800dfc2:	601a      	str	r2, [r3, #0]
      for (index = 0U; index < BufferLength; index++)
 800dfc4:	697b      	ldr	r3, [r7, #20]
 800dfc6:	3301      	adds	r3, #1
 800dfc8:	617b      	str	r3, [r7, #20]
 800dfca:	697a      	ldr	r2, [r7, #20]
 800dfcc:	687b      	ldr	r3, [r7, #4]
 800dfce:	429a      	cmp	r2, r3
 800dfd0:	d3f0      	bcc.n	800dfb4 <HAL_CRC_Calculate+0x42>
      temp = hcrc->Instance->DR;
 800dfd2:	68fb      	ldr	r3, [r7, #12]
 800dfd4:	681b      	ldr	r3, [r3, #0]
 800dfd6:	681b      	ldr	r3, [r3, #0]
 800dfd8:	613b      	str	r3, [r7, #16]
      break;
 800dfda:	e00e      	b.n	800dffa <HAL_CRC_Calculate+0x88>
      temp = CRC_Handle_8(hcrc, (uint8_t *)pBuffer, BufferLength);
 800dfdc:	687a      	ldr	r2, [r7, #4]
 800dfde:	68b9      	ldr	r1, [r7, #8]
 800dfe0:	68f8      	ldr	r0, [r7, #12]
 800dfe2:	f000 f81f 	bl	800e024 <CRC_Handle_8>
 800dfe6:	6138      	str	r0, [r7, #16]
      break;
 800dfe8:	e007      	b.n	800dffa <HAL_CRC_Calculate+0x88>
      temp = CRC_Handle_16(hcrc, (uint16_t *)(void *)pBuffer, BufferLength);    /* Derogation MisraC2012 R.11.5 */
 800dfea:	687a      	ldr	r2, [r7, #4]
 800dfec:	68b9      	ldr	r1, [r7, #8]
 800dfee:	68f8      	ldr	r0, [r7, #12]
 800dff0:	f000 f8a8 	bl	800e144 <CRC_Handle_16>
 800dff4:	6138      	str	r0, [r7, #16]
      break;
 800dff6:	e000      	b.n	800dffa <HAL_CRC_Calculate+0x88>
      break;
 800dff8:	bf00      	nop
  }

  /* Change CRC peripheral state */
  hcrc->State = HAL_CRC_STATE_READY;
 800dffa:	68fb      	ldr	r3, [r7, #12]
 800dffc:	2201      	movs	r2, #1
 800dffe:	775a      	strb	r2, [r3, #29]

  /* Return the CRC computed value */
  return temp;
 800e000:	693b      	ldr	r3, [r7, #16]
}
 800e002:	4618      	mov	r0, r3
 800e004:	3718      	adds	r7, #24
 800e006:	46bd      	mov	sp, r7
 800e008:	bd80      	pop	{r7, pc}

0800e00a <HAL_CRC_GetState>:
  * @brief  Return the CRC handle state.
  * @param  hcrc CRC handle
  * @retval HAL state
  */
HAL_CRC_StateTypeDef HAL_CRC_GetState(const CRC_HandleTypeDef *hcrc)
{
 800e00a:	b480      	push	{r7}
 800e00c:	b083      	sub	sp, #12
 800e00e:	af00      	add	r7, sp, #0
 800e010:	6078      	str	r0, [r7, #4]
  /* Return CRC handle state */
  return hcrc->State;
 800e012:	687b      	ldr	r3, [r7, #4]
 800e014:	7f5b      	ldrb	r3, [r3, #29]
 800e016:	b2db      	uxtb	r3, r3
}
 800e018:	4618      	mov	r0, r3
 800e01a:	370c      	adds	r7, #12
 800e01c:	46bd      	mov	sp, r7
 800e01e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e022:	4770      	bx	lr

0800e024 <CRC_Handle_8>:
  * @param  pBuffer pointer to the input data buffer
  * @param  BufferLength input data buffer length
  * @retval uint32_t CRC (returned value LSBs for CRC shorter than 32 bits)
  */
static uint32_t CRC_Handle_8(CRC_HandleTypeDef *hcrc, uint8_t pBuffer[], uint32_t BufferLength)
{
 800e024:	b480      	push	{r7}
 800e026:	b089      	sub	sp, #36	@ 0x24
 800e028:	af00      	add	r7, sp, #0
 800e02a:	60f8      	str	r0, [r7, #12]
 800e02c:	60b9      	str	r1, [r7, #8]
 800e02e:	607a      	str	r2, [r7, #4]
  __IO uint16_t *pReg;

  /* Processing time optimization: 4 bytes are entered in a row with a single word write,
   * last bytes must be carefully fed to the CRC calculator to ensure a correct type
   * handling by the peripheral */
  for (i = 0U; i < (BufferLength / 4U); i++)
 800e030:	2300      	movs	r3, #0
 800e032:	61fb      	str	r3, [r7, #28]
 800e034:	e023      	b.n	800e07e <CRC_Handle_8+0x5a>
  {
    hcrc->Instance->DR = ((uint32_t)pBuffer[4U * i] << 24U) | \
 800e036:	69fb      	ldr	r3, [r7, #28]
 800e038:	009b      	lsls	r3, r3, #2
 800e03a:	68ba      	ldr	r2, [r7, #8]
 800e03c:	4413      	add	r3, r2
 800e03e:	781b      	ldrb	r3, [r3, #0]
 800e040:	061a      	lsls	r2, r3, #24
                         ((uint32_t)pBuffer[(4U * i) + 1U] << 16U) | \
 800e042:	69fb      	ldr	r3, [r7, #28]
 800e044:	009b      	lsls	r3, r3, #2
 800e046:	3301      	adds	r3, #1
 800e048:	68b9      	ldr	r1, [r7, #8]
 800e04a:	440b      	add	r3, r1
 800e04c:	781b      	ldrb	r3, [r3, #0]
 800e04e:	041b      	lsls	r3, r3, #16
    hcrc->Instance->DR = ((uint32_t)pBuffer[4U * i] << 24U) | \
 800e050:	431a      	orrs	r2, r3
                         ((uint32_t)pBuffer[(4U * i) + 2U] << 8U)  | \
 800e052:	69fb      	ldr	r3, [r7, #28]
 800e054:	009b      	lsls	r3, r3, #2
 800e056:	3302      	adds	r3, #2
 800e058:	68b9      	ldr	r1, [r7, #8]
 800e05a:	440b      	add	r3, r1
 800e05c:	781b      	ldrb	r3, [r3, #0]
 800e05e:	021b      	lsls	r3, r3, #8
                         ((uint32_t)pBuffer[(4U * i) + 1U] << 16U) | \
 800e060:	431a      	orrs	r2, r3
                         (uint32_t)pBuffer[(4U * i) + 3U];
 800e062:	69fb      	ldr	r3, [r7, #28]
 800e064:	009b      	lsls	r3, r3, #2
 800e066:	3303      	adds	r3, #3
 800e068:	68b9      	ldr	r1, [r7, #8]
 800e06a:	440b      	add	r3, r1
 800e06c:	781b      	ldrb	r3, [r3, #0]
 800e06e:	4619      	mov	r1, r3
    hcrc->Instance->DR = ((uint32_t)pBuffer[4U * i] << 24U) | \
 800e070:	68fb      	ldr	r3, [r7, #12]
 800e072:	681b      	ldr	r3, [r3, #0]
                         ((uint32_t)pBuffer[(4U * i) + 2U] << 8U)  | \
 800e074:	430a      	orrs	r2, r1
    hcrc->Instance->DR = ((uint32_t)pBuffer[4U * i] << 24U) | \
 800e076:	601a      	str	r2, [r3, #0]
  for (i = 0U; i < (BufferLength / 4U); i++)
 800e078:	69fb      	ldr	r3, [r7, #28]
 800e07a:	3301      	adds	r3, #1
 800e07c:	61fb      	str	r3, [r7, #28]
 800e07e:	687b      	ldr	r3, [r7, #4]
 800e080:	089b      	lsrs	r3, r3, #2
 800e082:	69fa      	ldr	r2, [r7, #28]
 800e084:	429a      	cmp	r2, r3
 800e086:	d3d6      	bcc.n	800e036 <CRC_Handle_8+0x12>
  }
  /* last bytes specific handling */
  if ((BufferLength % 4U) != 0U)
 800e088:	687b      	ldr	r3, [r7, #4]
 800e08a:	f003 0303 	and.w	r3, r3, #3
 800e08e:	2b00      	cmp	r3, #0
 800e090:	d04f      	beq.n	800e132 <CRC_Handle_8+0x10e>
  {
    if ((BufferLength % 4U) == 1U)
 800e092:	687b      	ldr	r3, [r7, #4]
 800e094:	f003 0303 	and.w	r3, r3, #3
 800e098:	2b01      	cmp	r3, #1
 800e09a:	d107      	bne.n	800e0ac <CRC_Handle_8+0x88>
    {
      *(__IO uint8_t *)(__IO void *)(&hcrc->Instance->DR) = pBuffer[4U * i];         /* Derogation MisraC2012 R.11.5 */
 800e09c:	69fb      	ldr	r3, [r7, #28]
 800e09e:	009b      	lsls	r3, r3, #2
 800e0a0:	68ba      	ldr	r2, [r7, #8]
 800e0a2:	4413      	add	r3, r2
 800e0a4:	68fa      	ldr	r2, [r7, #12]
 800e0a6:	6812      	ldr	r2, [r2, #0]
 800e0a8:	781b      	ldrb	r3, [r3, #0]
 800e0aa:	7013      	strb	r3, [r2, #0]
    }
    if ((BufferLength % 4U) == 2U)
 800e0ac:	687b      	ldr	r3, [r7, #4]
 800e0ae:	f003 0303 	and.w	r3, r3, #3
 800e0b2:	2b02      	cmp	r3, #2
 800e0b4:	d117      	bne.n	800e0e6 <CRC_Handle_8+0xc2>
    {
      data = ((uint16_t)(pBuffer[4U * i]) << 8U) | (uint16_t)pBuffer[(4U * i) + 1U];
 800e0b6:	69fb      	ldr	r3, [r7, #28]
 800e0b8:	009b      	lsls	r3, r3, #2
 800e0ba:	68ba      	ldr	r2, [r7, #8]
 800e0bc:	4413      	add	r3, r2
 800e0be:	781b      	ldrb	r3, [r3, #0]
 800e0c0:	b21b      	sxth	r3, r3
 800e0c2:	021b      	lsls	r3, r3, #8
 800e0c4:	b21a      	sxth	r2, r3
 800e0c6:	69fb      	ldr	r3, [r7, #28]
 800e0c8:	009b      	lsls	r3, r3, #2
 800e0ca:	3301      	adds	r3, #1
 800e0cc:	68b9      	ldr	r1, [r7, #8]
 800e0ce:	440b      	add	r3, r1
 800e0d0:	781b      	ldrb	r3, [r3, #0]
 800e0d2:	b21b      	sxth	r3, r3
 800e0d4:	4313      	orrs	r3, r2
 800e0d6:	b21b      	sxth	r3, r3
 800e0d8:	837b      	strh	r3, [r7, #26]
      pReg = (__IO uint16_t *)(__IO void *)(&hcrc->Instance->DR);                    /* Derogation MisraC2012 R.11.5 */
 800e0da:	68fb      	ldr	r3, [r7, #12]
 800e0dc:	681b      	ldr	r3, [r3, #0]
 800e0de:	617b      	str	r3, [r7, #20]
      *pReg = data;
 800e0e0:	697b      	ldr	r3, [r7, #20]
 800e0e2:	8b7a      	ldrh	r2, [r7, #26]
 800e0e4:	801a      	strh	r2, [r3, #0]
    }
    if ((BufferLength % 4U) == 3U)
 800e0e6:	687b      	ldr	r3, [r7, #4]
 800e0e8:	f003 0303 	and.w	r3, r3, #3
 800e0ec:	2b03      	cmp	r3, #3
 800e0ee:	d120      	bne.n	800e132 <CRC_Handle_8+0x10e>
    {
      data = ((uint16_t)(pBuffer[4U * i]) << 8U) | (uint16_t)pBuffer[(4U * i) + 1U];
 800e0f0:	69fb      	ldr	r3, [r7, #28]
 800e0f2:	009b      	lsls	r3, r3, #2
 800e0f4:	68ba      	ldr	r2, [r7, #8]
 800e0f6:	4413      	add	r3, r2
 800e0f8:	781b      	ldrb	r3, [r3, #0]
 800e0fa:	b21b      	sxth	r3, r3
 800e0fc:	021b      	lsls	r3, r3, #8
 800e0fe:	b21a      	sxth	r2, r3
 800e100:	69fb      	ldr	r3, [r7, #28]
 800e102:	009b      	lsls	r3, r3, #2
 800e104:	3301      	adds	r3, #1
 800e106:	68b9      	ldr	r1, [r7, #8]
 800e108:	440b      	add	r3, r1
 800e10a:	781b      	ldrb	r3, [r3, #0]
 800e10c:	b21b      	sxth	r3, r3
 800e10e:	4313      	orrs	r3, r2
 800e110:	b21b      	sxth	r3, r3
 800e112:	837b      	strh	r3, [r7, #26]
      pReg = (__IO uint16_t *)(__IO void *)(&hcrc->Instance->DR);                    /* Derogation MisraC2012 R.11.5 */
 800e114:	68fb      	ldr	r3, [r7, #12]
 800e116:	681b      	ldr	r3, [r3, #0]
 800e118:	617b      	str	r3, [r7, #20]
      *pReg = data;
 800e11a:	697b      	ldr	r3, [r7, #20]
 800e11c:	8b7a      	ldrh	r2, [r7, #26]
 800e11e:	801a      	strh	r2, [r3, #0]

      *(__IO uint8_t *)(__IO void *)(&hcrc->Instance->DR) = pBuffer[(4U * i) + 2U];  /* Derogation MisraC2012 R.11.5 */
 800e120:	69fb      	ldr	r3, [r7, #28]
 800e122:	009b      	lsls	r3, r3, #2
 800e124:	3302      	adds	r3, #2
 800e126:	68ba      	ldr	r2, [r7, #8]
 800e128:	4413      	add	r3, r2
 800e12a:	68fa      	ldr	r2, [r7, #12]
 800e12c:	6812      	ldr	r2, [r2, #0]
 800e12e:	781b      	ldrb	r3, [r3, #0]
 800e130:	7013      	strb	r3, [r2, #0]
    }
  }

  /* Return the CRC computed value */
  return hcrc->Instance->DR;
 800e132:	68fb      	ldr	r3, [r7, #12]
 800e134:	681b      	ldr	r3, [r3, #0]
 800e136:	681b      	ldr	r3, [r3, #0]
}
 800e138:	4618      	mov	r0, r3
 800e13a:	3724      	adds	r7, #36	@ 0x24
 800e13c:	46bd      	mov	sp, r7
 800e13e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e142:	4770      	bx	lr

0800e144 <CRC_Handle_16>:
  * @param  pBuffer pointer to the input data buffer
  * @param  BufferLength input data buffer length
  * @retval uint32_t CRC (returned value LSBs for CRC shorter than 32 bits)
  */
static uint32_t CRC_Handle_16(CRC_HandleTypeDef *hcrc, uint16_t pBuffer[], uint32_t BufferLength)
{
 800e144:	b480      	push	{r7}
 800e146:	b087      	sub	sp, #28
 800e148:	af00      	add	r7, sp, #0
 800e14a:	60f8      	str	r0, [r7, #12]
 800e14c:	60b9      	str	r1, [r7, #8]
 800e14e:	607a      	str	r2, [r7, #4]
  __IO uint16_t *pReg;

  /* Processing time optimization: 2 HalfWords are entered in a row with a single word write,
   * in case of odd length, last HalfWord must be carefully fed to the CRC calculator to ensure
   * a correct type handling by the peripheral */
  for (i = 0U; i < (BufferLength / 2U); i++)
 800e150:	2300      	movs	r3, #0
 800e152:	617b      	str	r3, [r7, #20]
 800e154:	e013      	b.n	800e17e <CRC_Handle_16+0x3a>
  {
    hcrc->Instance->DR = ((uint32_t)pBuffer[2U * i] << 16U) | (uint32_t)pBuffer[(2U * i) + 1U];
 800e156:	697b      	ldr	r3, [r7, #20]
 800e158:	009b      	lsls	r3, r3, #2
 800e15a:	68ba      	ldr	r2, [r7, #8]
 800e15c:	4413      	add	r3, r2
 800e15e:	881b      	ldrh	r3, [r3, #0]
 800e160:	041a      	lsls	r2, r3, #16
 800e162:	697b      	ldr	r3, [r7, #20]
 800e164:	009b      	lsls	r3, r3, #2
 800e166:	3302      	adds	r3, #2
 800e168:	68b9      	ldr	r1, [r7, #8]
 800e16a:	440b      	add	r3, r1
 800e16c:	881b      	ldrh	r3, [r3, #0]
 800e16e:	4619      	mov	r1, r3
 800e170:	68fb      	ldr	r3, [r7, #12]
 800e172:	681b      	ldr	r3, [r3, #0]
 800e174:	430a      	orrs	r2, r1
 800e176:	601a      	str	r2, [r3, #0]
  for (i = 0U; i < (BufferLength / 2U); i++)
 800e178:	697b      	ldr	r3, [r7, #20]
 800e17a:	3301      	adds	r3, #1
 800e17c:	617b      	str	r3, [r7, #20]
 800e17e:	687b      	ldr	r3, [r7, #4]
 800e180:	085b      	lsrs	r3, r3, #1
 800e182:	697a      	ldr	r2, [r7, #20]
 800e184:	429a      	cmp	r2, r3
 800e186:	d3e6      	bcc.n	800e156 <CRC_Handle_16+0x12>
  }
  if ((BufferLength % 2U) != 0U)
 800e188:	687b      	ldr	r3, [r7, #4]
 800e18a:	f003 0301 	and.w	r3, r3, #1
 800e18e:	2b00      	cmp	r3, #0
 800e190:	d009      	beq.n	800e1a6 <CRC_Handle_16+0x62>
  {
    pReg = (__IO uint16_t *)(__IO void *)(&hcrc->Instance->DR);                 /* Derogation MisraC2012 R.11.5 */
 800e192:	68fb      	ldr	r3, [r7, #12]
 800e194:	681b      	ldr	r3, [r3, #0]
 800e196:	613b      	str	r3, [r7, #16]
    *pReg = pBuffer[2U * i];
 800e198:	697b      	ldr	r3, [r7, #20]
 800e19a:	009b      	lsls	r3, r3, #2
 800e19c:	68ba      	ldr	r2, [r7, #8]
 800e19e:	4413      	add	r3, r2
 800e1a0:	881a      	ldrh	r2, [r3, #0]
 800e1a2:	693b      	ldr	r3, [r7, #16]
 800e1a4:	801a      	strh	r2, [r3, #0]
  }

  /* Return the CRC computed value */
  return hcrc->Instance->DR;
 800e1a6:	68fb      	ldr	r3, [r7, #12]
 800e1a8:	681b      	ldr	r3, [r3, #0]
 800e1aa:	681b      	ldr	r3, [r3, #0]
}
 800e1ac:	4618      	mov	r0, r3
 800e1ae:	371c      	adds	r7, #28
 800e1b0:	46bd      	mov	sp, r7
 800e1b2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e1b6:	4770      	bx	lr

0800e1b8 <HAL_CRCEx_Polynomial_Set>:
  *          @arg @ref CRC_POLYLENGTH_16B 16-bit long CRC (generating polynomial of degree 16)
  *          @arg @ref CRC_POLYLENGTH_32B 32-bit long CRC (generating polynomial of degree 32)
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CRCEx_Polynomial_Set(CRC_HandleTypeDef *hcrc, uint32_t Pol, uint32_t PolyLength)
{
 800e1b8:	b480      	push	{r7}
 800e1ba:	b087      	sub	sp, #28
 800e1bc:	af00      	add	r7, sp, #0
 800e1be:	60f8      	str	r0, [r7, #12]
 800e1c0:	60b9      	str	r1, [r7, #8]
 800e1c2:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 800e1c4:	2300      	movs	r3, #0
 800e1c6:	75fb      	strb	r3, [r7, #23]
  uint32_t msb = 31U; /* polynomial degree is 32 at most, so msb is initialized to max value */
 800e1c8:	231f      	movs	r3, #31
 800e1ca:	613b      	str	r3, [r7, #16]

  /* Check the parameters */
  assert_param(IS_CRC_POL_LENGTH(PolyLength));

  /* Ensure that the generating polynomial is odd */
  if ((Pol & (uint32_t)(0x1U)) ==  0U)
 800e1cc:	68bb      	ldr	r3, [r7, #8]
 800e1ce:	f003 0301 	and.w	r3, r3, #1
 800e1d2:	2b00      	cmp	r3, #0
 800e1d4:	d102      	bne.n	800e1dc <HAL_CRCEx_Polynomial_Set+0x24>
  {
    status =  HAL_ERROR;
 800e1d6:	2301      	movs	r3, #1
 800e1d8:	75fb      	strb	r3, [r7, #23]
 800e1da:	e063      	b.n	800e2a4 <HAL_CRCEx_Polynomial_Set+0xec>
     * definition. HAL_ERROR is reported if Pol degree is
     * larger than that indicated by PolyLength.
     * Look for MSB position: msb will contain the degree of
     *  the second to the largest polynomial member. E.g., for
     *  X^7 + X^6 + X^5 + X^2 + 1, msb = 6. */
    while ((msb-- > 0U) && ((Pol & ((uint32_t)(0x1U) << (msb & 0x1FU))) == 0U))
 800e1dc:	bf00      	nop
 800e1de:	693b      	ldr	r3, [r7, #16]
 800e1e0:	1e5a      	subs	r2, r3, #1
 800e1e2:	613a      	str	r2, [r7, #16]
 800e1e4:	2b00      	cmp	r3, #0
 800e1e6:	d009      	beq.n	800e1fc <HAL_CRCEx_Polynomial_Set+0x44>
 800e1e8:	693b      	ldr	r3, [r7, #16]
 800e1ea:	f003 031f 	and.w	r3, r3, #31
 800e1ee:	68ba      	ldr	r2, [r7, #8]
 800e1f0:	fa22 f303 	lsr.w	r3, r2, r3
 800e1f4:	f003 0301 	and.w	r3, r3, #1
 800e1f8:	2b00      	cmp	r3, #0
 800e1fa:	d0f0      	beq.n	800e1de <HAL_CRCEx_Polynomial_Set+0x26>
    {
    }

    switch (PolyLength)
 800e1fc:	687b      	ldr	r3, [r7, #4]
 800e1fe:	2b18      	cmp	r3, #24
 800e200:	d846      	bhi.n	800e290 <HAL_CRCEx_Polynomial_Set+0xd8>
 800e202:	a201      	add	r2, pc, #4	@ (adr r2, 800e208 <HAL_CRCEx_Polynomial_Set+0x50>)
 800e204:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800e208:	0800e297 	.word	0x0800e297
 800e20c:	0800e291 	.word	0x0800e291
 800e210:	0800e291 	.word	0x0800e291
 800e214:	0800e291 	.word	0x0800e291
 800e218:	0800e291 	.word	0x0800e291
 800e21c:	0800e291 	.word	0x0800e291
 800e220:	0800e291 	.word	0x0800e291
 800e224:	0800e291 	.word	0x0800e291
 800e228:	0800e285 	.word	0x0800e285
 800e22c:	0800e291 	.word	0x0800e291
 800e230:	0800e291 	.word	0x0800e291
 800e234:	0800e291 	.word	0x0800e291
 800e238:	0800e291 	.word	0x0800e291
 800e23c:	0800e291 	.word	0x0800e291
 800e240:	0800e291 	.word	0x0800e291
 800e244:	0800e291 	.word	0x0800e291
 800e248:	0800e279 	.word	0x0800e279
 800e24c:	0800e291 	.word	0x0800e291
 800e250:	0800e291 	.word	0x0800e291
 800e254:	0800e291 	.word	0x0800e291
 800e258:	0800e291 	.word	0x0800e291
 800e25c:	0800e291 	.word	0x0800e291
 800e260:	0800e291 	.word	0x0800e291
 800e264:	0800e291 	.word	0x0800e291
 800e268:	0800e26d 	.word	0x0800e26d
    {

      case CRC_POLYLENGTH_7B:
        if (msb >= HAL_CRC_LENGTH_7B)
 800e26c:	693b      	ldr	r3, [r7, #16]
 800e26e:	2b06      	cmp	r3, #6
 800e270:	d913      	bls.n	800e29a <HAL_CRCEx_Polynomial_Set+0xe2>
        {
          status =   HAL_ERROR;
 800e272:	2301      	movs	r3, #1
 800e274:	75fb      	strb	r3, [r7, #23]
        }
        break;
 800e276:	e010      	b.n	800e29a <HAL_CRCEx_Polynomial_Set+0xe2>
      case CRC_POLYLENGTH_8B:
        if (msb >= HAL_CRC_LENGTH_8B)
 800e278:	693b      	ldr	r3, [r7, #16]
 800e27a:	2b07      	cmp	r3, #7
 800e27c:	d90f      	bls.n	800e29e <HAL_CRCEx_Polynomial_Set+0xe6>
        {
          status =   HAL_ERROR;
 800e27e:	2301      	movs	r3, #1
 800e280:	75fb      	strb	r3, [r7, #23]
        }
        break;
 800e282:	e00c      	b.n	800e29e <HAL_CRCEx_Polynomial_Set+0xe6>
      case CRC_POLYLENGTH_16B:
        if (msb >= HAL_CRC_LENGTH_16B)
 800e284:	693b      	ldr	r3, [r7, #16]
 800e286:	2b0f      	cmp	r3, #15
 800e288:	d90b      	bls.n	800e2a2 <HAL_CRCEx_Polynomial_Set+0xea>
        {
          status =   HAL_ERROR;
 800e28a:	2301      	movs	r3, #1
 800e28c:	75fb      	strb	r3, [r7, #23]
        }
        break;
 800e28e:	e008      	b.n	800e2a2 <HAL_CRCEx_Polynomial_Set+0xea>

      case CRC_POLYLENGTH_32B:
        /* no polynomial definition vs. polynomial length issue possible */
        break;
      default:
        status =  HAL_ERROR;
 800e290:	2301      	movs	r3, #1
 800e292:	75fb      	strb	r3, [r7, #23]
        break;
 800e294:	e006      	b.n	800e2a4 <HAL_CRCEx_Polynomial_Set+0xec>
        break;
 800e296:	bf00      	nop
 800e298:	e004      	b.n	800e2a4 <HAL_CRCEx_Polynomial_Set+0xec>
        break;
 800e29a:	bf00      	nop
 800e29c:	e002      	b.n	800e2a4 <HAL_CRCEx_Polynomial_Set+0xec>
        break;
 800e29e:	bf00      	nop
 800e2a0:	e000      	b.n	800e2a4 <HAL_CRCEx_Polynomial_Set+0xec>
        break;
 800e2a2:	bf00      	nop
    }
  }
  if (status == HAL_OK)
 800e2a4:	7dfb      	ldrb	r3, [r7, #23]
 800e2a6:	2b00      	cmp	r3, #0
 800e2a8:	d10d      	bne.n	800e2c6 <HAL_CRCEx_Polynomial_Set+0x10e>
  {
    /* set generating polynomial */
    WRITE_REG(hcrc->Instance->POL, Pol);
 800e2aa:	68fb      	ldr	r3, [r7, #12]
 800e2ac:	681b      	ldr	r3, [r3, #0]
 800e2ae:	68ba      	ldr	r2, [r7, #8]
 800e2b0:	615a      	str	r2, [r3, #20]

    /* set generating polynomial size */
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, PolyLength);
 800e2b2:	68fb      	ldr	r3, [r7, #12]
 800e2b4:	681b      	ldr	r3, [r3, #0]
 800e2b6:	689b      	ldr	r3, [r3, #8]
 800e2b8:	f023 0118 	bic.w	r1, r3, #24
 800e2bc:	68fb      	ldr	r3, [r7, #12]
 800e2be:	681b      	ldr	r3, [r3, #0]
 800e2c0:	687a      	ldr	r2, [r7, #4]
 800e2c2:	430a      	orrs	r2, r1
 800e2c4:	609a      	str	r2, [r3, #8]
  }
  /* Return function status */
  return status;
 800e2c6:	7dfb      	ldrb	r3, [r7, #23]
}
 800e2c8:	4618      	mov	r0, r3
 800e2ca:	371c      	adds	r7, #28
 800e2cc:	46bd      	mov	sp, r7
 800e2ce:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e2d2:	4770      	bx	lr

0800e2d4 <HAL_DMA_Init>:
  * @param  hdma : Pointer to a DMA_HandleTypeDef structure that contains the configuration information for the
  *                specified DMA Channel.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *const hdma)
{
 800e2d4:	b580      	push	{r7, lr}
 800e2d6:	b084      	sub	sp, #16
 800e2d8:	af00      	add	r7, sp, #0
 800e2da:	6078      	str	r0, [r7, #4]
  /* Get tick number */
  uint32_t tickstart = HAL_GetTick();
 800e2dc:	f7ff fbc0 	bl	800da60 <HAL_GetTick>
 800e2e0:	60f8      	str	r0, [r7, #12]

  /* Check the DMA peripheral handle parameter */
  if (hdma == NULL)
 800e2e2:	687b      	ldr	r3, [r7, #4]
 800e2e4:	2b00      	cmp	r3, #0
 800e2e6:	d101      	bne.n	800e2ec <HAL_DMA_Init+0x18>
  {
    return HAL_ERROR;
 800e2e8:	2301      	movs	r3, #1
 800e2ea:	e0db      	b.n	800e4a4 <HAL_DMA_Init+0x1d0>
  assert_param(IS_DMA_DESTINATION_DATA_WIDTH(hdma->Init.DestDataWidth));
  assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));
  assert_param(IS_DMA_TCEM_EVENT_MODE(hdma->Init.TransferEventMode));
  assert_param(IS_DMA_MODE(hdma->Init.Mode));
  /* Check DMA channel instance */
  if (IS_GPDMA_INSTANCE(hdma->Instance) != 0U)
 800e2ec:	687b      	ldr	r3, [r7, #4]
 800e2ee:	681b      	ldr	r3, [r3, #0]
 800e2f0:	4a6e      	ldr	r2, [pc, #440]	@ (800e4ac <HAL_DMA_Init+0x1d8>)
 800e2f2:	4293      	cmp	r3, r2
 800e2f4:	f000 809f 	beq.w	800e436 <HAL_DMA_Init+0x162>
 800e2f8:	687b      	ldr	r3, [r7, #4]
 800e2fa:	681b      	ldr	r3, [r3, #0]
 800e2fc:	4a6c      	ldr	r2, [pc, #432]	@ (800e4b0 <HAL_DMA_Init+0x1dc>)
 800e2fe:	4293      	cmp	r3, r2
 800e300:	f000 8099 	beq.w	800e436 <HAL_DMA_Init+0x162>
 800e304:	687b      	ldr	r3, [r7, #4]
 800e306:	681b      	ldr	r3, [r3, #0]
 800e308:	4a6a      	ldr	r2, [pc, #424]	@ (800e4b4 <HAL_DMA_Init+0x1e0>)
 800e30a:	4293      	cmp	r3, r2
 800e30c:	f000 8093 	beq.w	800e436 <HAL_DMA_Init+0x162>
 800e310:	687b      	ldr	r3, [r7, #4]
 800e312:	681b      	ldr	r3, [r3, #0]
 800e314:	4a68      	ldr	r2, [pc, #416]	@ (800e4b8 <HAL_DMA_Init+0x1e4>)
 800e316:	4293      	cmp	r3, r2
 800e318:	f000 808d 	beq.w	800e436 <HAL_DMA_Init+0x162>
 800e31c:	687b      	ldr	r3, [r7, #4]
 800e31e:	681b      	ldr	r3, [r3, #0]
 800e320:	4a66      	ldr	r2, [pc, #408]	@ (800e4bc <HAL_DMA_Init+0x1e8>)
 800e322:	4293      	cmp	r3, r2
 800e324:	f000 8087 	beq.w	800e436 <HAL_DMA_Init+0x162>
 800e328:	687b      	ldr	r3, [r7, #4]
 800e32a:	681b      	ldr	r3, [r3, #0]
 800e32c:	4a64      	ldr	r2, [pc, #400]	@ (800e4c0 <HAL_DMA_Init+0x1ec>)
 800e32e:	4293      	cmp	r3, r2
 800e330:	f000 8081 	beq.w	800e436 <HAL_DMA_Init+0x162>
 800e334:	687b      	ldr	r3, [r7, #4]
 800e336:	681b      	ldr	r3, [r3, #0]
 800e338:	4a62      	ldr	r2, [pc, #392]	@ (800e4c4 <HAL_DMA_Init+0x1f0>)
 800e33a:	4293      	cmp	r3, r2
 800e33c:	d07b      	beq.n	800e436 <HAL_DMA_Init+0x162>
 800e33e:	687b      	ldr	r3, [r7, #4]
 800e340:	681b      	ldr	r3, [r3, #0]
 800e342:	4a61      	ldr	r2, [pc, #388]	@ (800e4c8 <HAL_DMA_Init+0x1f4>)
 800e344:	4293      	cmp	r3, r2
 800e346:	d076      	beq.n	800e436 <HAL_DMA_Init+0x162>
 800e348:	687b      	ldr	r3, [r7, #4]
 800e34a:	681b      	ldr	r3, [r3, #0]
 800e34c:	4a5f      	ldr	r2, [pc, #380]	@ (800e4cc <HAL_DMA_Init+0x1f8>)
 800e34e:	4293      	cmp	r3, r2
 800e350:	d071      	beq.n	800e436 <HAL_DMA_Init+0x162>
 800e352:	687b      	ldr	r3, [r7, #4]
 800e354:	681b      	ldr	r3, [r3, #0]
 800e356:	4a5e      	ldr	r2, [pc, #376]	@ (800e4d0 <HAL_DMA_Init+0x1fc>)
 800e358:	4293      	cmp	r3, r2
 800e35a:	d06c      	beq.n	800e436 <HAL_DMA_Init+0x162>
 800e35c:	687b      	ldr	r3, [r7, #4]
 800e35e:	681b      	ldr	r3, [r3, #0]
 800e360:	4a5c      	ldr	r2, [pc, #368]	@ (800e4d4 <HAL_DMA_Init+0x200>)
 800e362:	4293      	cmp	r3, r2
 800e364:	d067      	beq.n	800e436 <HAL_DMA_Init+0x162>
 800e366:	687b      	ldr	r3, [r7, #4]
 800e368:	681b      	ldr	r3, [r3, #0]
 800e36a:	4a5b      	ldr	r2, [pc, #364]	@ (800e4d8 <HAL_DMA_Init+0x204>)
 800e36c:	4293      	cmp	r3, r2
 800e36e:	d062      	beq.n	800e436 <HAL_DMA_Init+0x162>
 800e370:	687b      	ldr	r3, [r7, #4]
 800e372:	681b      	ldr	r3, [r3, #0]
 800e374:	4a59      	ldr	r2, [pc, #356]	@ (800e4dc <HAL_DMA_Init+0x208>)
 800e376:	4293      	cmp	r3, r2
 800e378:	d05d      	beq.n	800e436 <HAL_DMA_Init+0x162>
 800e37a:	687b      	ldr	r3, [r7, #4]
 800e37c:	681b      	ldr	r3, [r3, #0]
 800e37e:	4a58      	ldr	r2, [pc, #352]	@ (800e4e0 <HAL_DMA_Init+0x20c>)
 800e380:	4293      	cmp	r3, r2
 800e382:	d058      	beq.n	800e436 <HAL_DMA_Init+0x162>
 800e384:	687b      	ldr	r3, [r7, #4]
 800e386:	681b      	ldr	r3, [r3, #0]
 800e388:	4a56      	ldr	r2, [pc, #344]	@ (800e4e4 <HAL_DMA_Init+0x210>)
 800e38a:	4293      	cmp	r3, r2
 800e38c:	d053      	beq.n	800e436 <HAL_DMA_Init+0x162>
 800e38e:	687b      	ldr	r3, [r7, #4]
 800e390:	681b      	ldr	r3, [r3, #0]
 800e392:	4a55      	ldr	r2, [pc, #340]	@ (800e4e8 <HAL_DMA_Init+0x214>)
 800e394:	4293      	cmp	r3, r2
 800e396:	d04e      	beq.n	800e436 <HAL_DMA_Init+0x162>
 800e398:	687b      	ldr	r3, [r7, #4]
 800e39a:	681b      	ldr	r3, [r3, #0]
 800e39c:	4a53      	ldr	r2, [pc, #332]	@ (800e4ec <HAL_DMA_Init+0x218>)
 800e39e:	4293      	cmp	r3, r2
 800e3a0:	d049      	beq.n	800e436 <HAL_DMA_Init+0x162>
 800e3a2:	687b      	ldr	r3, [r7, #4]
 800e3a4:	681b      	ldr	r3, [r3, #0]
 800e3a6:	4a52      	ldr	r2, [pc, #328]	@ (800e4f0 <HAL_DMA_Init+0x21c>)
 800e3a8:	4293      	cmp	r3, r2
 800e3aa:	d044      	beq.n	800e436 <HAL_DMA_Init+0x162>
 800e3ac:	687b      	ldr	r3, [r7, #4]
 800e3ae:	681b      	ldr	r3, [r3, #0]
 800e3b0:	4a50      	ldr	r2, [pc, #320]	@ (800e4f4 <HAL_DMA_Init+0x220>)
 800e3b2:	4293      	cmp	r3, r2
 800e3b4:	d03f      	beq.n	800e436 <HAL_DMA_Init+0x162>
 800e3b6:	687b      	ldr	r3, [r7, #4]
 800e3b8:	681b      	ldr	r3, [r3, #0]
 800e3ba:	4a4f      	ldr	r2, [pc, #316]	@ (800e4f8 <HAL_DMA_Init+0x224>)
 800e3bc:	4293      	cmp	r3, r2
 800e3be:	d03a      	beq.n	800e436 <HAL_DMA_Init+0x162>
 800e3c0:	687b      	ldr	r3, [r7, #4]
 800e3c2:	681b      	ldr	r3, [r3, #0]
 800e3c4:	4a4d      	ldr	r2, [pc, #308]	@ (800e4fc <HAL_DMA_Init+0x228>)
 800e3c6:	4293      	cmp	r3, r2
 800e3c8:	d035      	beq.n	800e436 <HAL_DMA_Init+0x162>
 800e3ca:	687b      	ldr	r3, [r7, #4]
 800e3cc:	681b      	ldr	r3, [r3, #0]
 800e3ce:	4a4c      	ldr	r2, [pc, #304]	@ (800e500 <HAL_DMA_Init+0x22c>)
 800e3d0:	4293      	cmp	r3, r2
 800e3d2:	d030      	beq.n	800e436 <HAL_DMA_Init+0x162>
 800e3d4:	687b      	ldr	r3, [r7, #4]
 800e3d6:	681b      	ldr	r3, [r3, #0]
 800e3d8:	4a4a      	ldr	r2, [pc, #296]	@ (800e504 <HAL_DMA_Init+0x230>)
 800e3da:	4293      	cmp	r3, r2
 800e3dc:	d02b      	beq.n	800e436 <HAL_DMA_Init+0x162>
 800e3de:	687b      	ldr	r3, [r7, #4]
 800e3e0:	681b      	ldr	r3, [r3, #0]
 800e3e2:	4a49      	ldr	r2, [pc, #292]	@ (800e508 <HAL_DMA_Init+0x234>)
 800e3e4:	4293      	cmp	r3, r2
 800e3e6:	d026      	beq.n	800e436 <HAL_DMA_Init+0x162>
 800e3e8:	687b      	ldr	r3, [r7, #4]
 800e3ea:	681b      	ldr	r3, [r3, #0]
 800e3ec:	4a47      	ldr	r2, [pc, #284]	@ (800e50c <HAL_DMA_Init+0x238>)
 800e3ee:	4293      	cmp	r3, r2
 800e3f0:	d021      	beq.n	800e436 <HAL_DMA_Init+0x162>
 800e3f2:	687b      	ldr	r3, [r7, #4]
 800e3f4:	681b      	ldr	r3, [r3, #0]
 800e3f6:	4a46      	ldr	r2, [pc, #280]	@ (800e510 <HAL_DMA_Init+0x23c>)
 800e3f8:	4293      	cmp	r3, r2
 800e3fa:	d01c      	beq.n	800e436 <HAL_DMA_Init+0x162>
 800e3fc:	687b      	ldr	r3, [r7, #4]
 800e3fe:	681b      	ldr	r3, [r3, #0]
 800e400:	4a44      	ldr	r2, [pc, #272]	@ (800e514 <HAL_DMA_Init+0x240>)
 800e402:	4293      	cmp	r3, r2
 800e404:	d017      	beq.n	800e436 <HAL_DMA_Init+0x162>
 800e406:	687b      	ldr	r3, [r7, #4]
 800e408:	681b      	ldr	r3, [r3, #0]
 800e40a:	4a43      	ldr	r2, [pc, #268]	@ (800e518 <HAL_DMA_Init+0x244>)
 800e40c:	4293      	cmp	r3, r2
 800e40e:	d012      	beq.n	800e436 <HAL_DMA_Init+0x162>
 800e410:	687b      	ldr	r3, [r7, #4]
 800e412:	681b      	ldr	r3, [r3, #0]
 800e414:	4a41      	ldr	r2, [pc, #260]	@ (800e51c <HAL_DMA_Init+0x248>)
 800e416:	4293      	cmp	r3, r2
 800e418:	d00d      	beq.n	800e436 <HAL_DMA_Init+0x162>
 800e41a:	687b      	ldr	r3, [r7, #4]
 800e41c:	681b      	ldr	r3, [r3, #0]
 800e41e:	4a40      	ldr	r2, [pc, #256]	@ (800e520 <HAL_DMA_Init+0x24c>)
 800e420:	4293      	cmp	r3, r2
 800e422:	d008      	beq.n	800e436 <HAL_DMA_Init+0x162>
 800e424:	687b      	ldr	r3, [r7, #4]
 800e426:	681b      	ldr	r3, [r3, #0]
 800e428:	4a3e      	ldr	r2, [pc, #248]	@ (800e524 <HAL_DMA_Init+0x250>)
 800e42a:	4293      	cmp	r3, r2
 800e42c:	d003      	beq.n	800e436 <HAL_DMA_Init+0x162>
 800e42e:	687b      	ldr	r3, [r7, #4]
 800e430:	681b      	ldr	r3, [r3, #0]
 800e432:	4a3d      	ldr	r2, [pc, #244]	@ (800e528 <HAL_DMA_Init+0x254>)
 800e434:	4293      	cmp	r3, r2
    assert_param(IS_DMA_BURST_LENGTH(hdma->Init.DestBurstLength));
    assert_param(IS_DMA_TRANSFER_ALLOCATED_PORT(hdma->Init.TransferAllocatedPort));
  }

  /* Allocate lock resource */
  __HAL_UNLOCK(hdma);
 800e436:	687b      	ldr	r3, [r7, #4]
 800e438:	2200      	movs	r2, #0
 800e43a:	f883 204c 	strb.w	r2, [r3, #76]	@ 0x4c

  /* Update the DMA channel state */
  hdma->State = HAL_DMA_STATE_BUSY;
 800e43e:	687b      	ldr	r3, [r7, #4]
 800e440:	2202      	movs	r2, #2
 800e442:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54

  /* Disable the DMA channel */
  __HAL_DMA_DISABLE(hdma);
 800e446:	687b      	ldr	r3, [r7, #4]
 800e448:	681b      	ldr	r3, [r3, #0]
 800e44a:	695a      	ldr	r2, [r3, #20]
 800e44c:	687b      	ldr	r3, [r7, #4]
 800e44e:	681b      	ldr	r3, [r3, #0]
 800e450:	f042 0206 	orr.w	r2, r2, #6
 800e454:	615a      	str	r2, [r3, #20]

  /* Check if the DMA channel is effectively disabled */
  while ((hdma->Instance->CCR & DMA_CCR_EN) != 0U)
 800e456:	e00f      	b.n	800e478 <HAL_DMA_Init+0x1a4>
  {
    /* Check for the Timeout */
    if ((HAL_GetTick() - tickstart) > HAL_TIMEOUT_DMA_ABORT)
 800e458:	f7ff fb02 	bl	800da60 <HAL_GetTick>
 800e45c:	4602      	mov	r2, r0
 800e45e:	68fb      	ldr	r3, [r7, #12]
 800e460:	1ad3      	subs	r3, r2, r3
 800e462:	2b05      	cmp	r3, #5
 800e464:	d908      	bls.n	800e478 <HAL_DMA_Init+0x1a4>
    {
      /* Update the DMA channel error code */
      hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 800e466:	687b      	ldr	r3, [r7, #4]
 800e468:	2210      	movs	r2, #16
 800e46a:	659a      	str	r2, [r3, #88]	@ 0x58

      /* Update the DMA channel state */
      hdma->State = HAL_DMA_STATE_ERROR;
 800e46c:	687b      	ldr	r3, [r7, #4]
 800e46e:	2203      	movs	r2, #3
 800e470:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54

      return HAL_ERROR;
 800e474:	2301      	movs	r3, #1
 800e476:	e015      	b.n	800e4a4 <HAL_DMA_Init+0x1d0>
  while ((hdma->Instance->CCR & DMA_CCR_EN) != 0U)
 800e478:	687b      	ldr	r3, [r7, #4]
 800e47a:	681b      	ldr	r3, [r3, #0]
 800e47c:	695b      	ldr	r3, [r3, #20]
 800e47e:	f003 0301 	and.w	r3, r3, #1
 800e482:	2b00      	cmp	r3, #0
 800e484:	d1e8      	bne.n	800e458 <HAL_DMA_Init+0x184>
    }
  }

  /* Initialize the DMA channel registers */
  DMA_Init(hdma);
 800e486:	6878      	ldr	r0, [r7, #4]
 800e488:	f000 fafe 	bl	800ea88 <DMA_Init>

  /* Update DMA channel operation mode */
  hdma->Mode = hdma->Init.Mode;
 800e48c:	687b      	ldr	r3, [r7, #4]
 800e48e:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 800e490:	687b      	ldr	r3, [r7, #4]
 800e492:	651a      	str	r2, [r3, #80]	@ 0x50

  /* Update the DMA channel error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 800e494:	687b      	ldr	r3, [r7, #4]
 800e496:	2200      	movs	r2, #0
 800e498:	659a      	str	r2, [r3, #88]	@ 0x58

  /* Update the DMA channel state */
  hdma->State = HAL_DMA_STATE_READY;
 800e49a:	687b      	ldr	r3, [r7, #4]
 800e49c:	2201      	movs	r2, #1
 800e49e:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54

  return HAL_OK;
 800e4a2:	2300      	movs	r3, #0
}
 800e4a4:	4618      	mov	r0, r3
 800e4a6:	3710      	adds	r7, #16
 800e4a8:	46bd      	mov	sp, r7
 800e4aa:	bd80      	pop	{r7, pc}
 800e4ac:	40020050 	.word	0x40020050
 800e4b0:	50020050 	.word	0x50020050
 800e4b4:	400200d0 	.word	0x400200d0
 800e4b8:	500200d0 	.word	0x500200d0
 800e4bc:	40020150 	.word	0x40020150
 800e4c0:	50020150 	.word	0x50020150
 800e4c4:	400201d0 	.word	0x400201d0
 800e4c8:	500201d0 	.word	0x500201d0
 800e4cc:	40020250 	.word	0x40020250
 800e4d0:	50020250 	.word	0x50020250
 800e4d4:	400202d0 	.word	0x400202d0
 800e4d8:	500202d0 	.word	0x500202d0
 800e4dc:	40020350 	.word	0x40020350
 800e4e0:	50020350 	.word	0x50020350
 800e4e4:	400203d0 	.word	0x400203d0
 800e4e8:	500203d0 	.word	0x500203d0
 800e4ec:	40020450 	.word	0x40020450
 800e4f0:	50020450 	.word	0x50020450
 800e4f4:	400204d0 	.word	0x400204d0
 800e4f8:	500204d0 	.word	0x500204d0
 800e4fc:	40020550 	.word	0x40020550
 800e500:	50020550 	.word	0x50020550
 800e504:	400205d0 	.word	0x400205d0
 800e508:	500205d0 	.word	0x500205d0
 800e50c:	40020650 	.word	0x40020650
 800e510:	50020650 	.word	0x50020650
 800e514:	400206d0 	.word	0x400206d0
 800e518:	500206d0 	.word	0x500206d0
 800e51c:	40020750 	.word	0x40020750
 800e520:	50020750 	.word	0x50020750
 800e524:	400207d0 	.word	0x400207d0
 800e528:	500207d0 	.word	0x500207d0

0800e52c <HAL_DMA_DeInit>:
  * @param  hdma : Pointer to a DMA_HandleTypeDef structure that contains the configuration information for the
  *                specified DMA Channel.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_DMA_DeInit(DMA_HandleTypeDef *const hdma)
{
 800e52c:	b580      	push	{r7, lr}
 800e52e:	b084      	sub	sp, #16
 800e530:	af00      	add	r7, sp, #0
 800e532:	6078      	str	r0, [r7, #4]

  DMA_TypeDef *p_dma_instance;

  uint32_t tickstart = HAL_GetTick();
 800e534:	f7ff fa94 	bl	800da60 <HAL_GetTick>
 800e538:	60f8      	str	r0, [r7, #12]

  /* Check the DMA peripheral handle parameter */
  if (hdma == NULL)
 800e53a:	687b      	ldr	r3, [r7, #4]
 800e53c:	2b00      	cmp	r3, #0
 800e53e:	d101      	bne.n	800e544 <HAL_DMA_DeInit+0x18>
  {
    return HAL_ERROR;
 800e540:	2301      	movs	r3, #1
 800e542:	e0b9      	b.n	800e6b8 <HAL_DMA_DeInit+0x18c>

  /* Check the parameters */
  assert_param(IS_DMA_ALL_INSTANCE(hdma->Instance));

  /* Get DMA instance */
  p_dma_instance = GET_DMA_INSTANCE(hdma);
 800e544:	687b      	ldr	r3, [r7, #4]
 800e546:	681b      	ldr	r3, [r3, #0]
 800e548:	f423 637f 	bic.w	r3, r3, #4080	@ 0xff0
 800e54c:	f023 030f 	bic.w	r3, r3, #15
 800e550:	60bb      	str	r3, [r7, #8]

  /* Disable the selected DMA Channel */
  __HAL_DMA_DISABLE(hdma);
 800e552:	687b      	ldr	r3, [r7, #4]
 800e554:	681b      	ldr	r3, [r3, #0]
 800e556:	695a      	ldr	r2, [r3, #20]
 800e558:	687b      	ldr	r3, [r7, #4]
 800e55a:	681b      	ldr	r3, [r3, #0]
 800e55c:	f042 0206 	orr.w	r2, r2, #6
 800e560:	615a      	str	r2, [r3, #20]

  /* Check if the DMA channel is effectively disabled */
  while ((hdma->Instance->CCR & DMA_CCR_EN) != 0U)
 800e562:	e00f      	b.n	800e584 <HAL_DMA_DeInit+0x58>
  {
    /* Check for the Timeout */
    if ((HAL_GetTick() - tickstart) > HAL_TIMEOUT_DMA_ABORT)
 800e564:	f7ff fa7c 	bl	800da60 <HAL_GetTick>
 800e568:	4602      	mov	r2, r0
 800e56a:	68fb      	ldr	r3, [r7, #12]
 800e56c:	1ad3      	subs	r3, r2, r3
 800e56e:	2b05      	cmp	r3, #5
 800e570:	d908      	bls.n	800e584 <HAL_DMA_DeInit+0x58>
    {
      /* Update the DMA channel error code */
      hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 800e572:	687b      	ldr	r3, [r7, #4]
 800e574:	2210      	movs	r2, #16
 800e576:	659a      	str	r2, [r3, #88]	@ 0x58

      /* Update the DMA channel state */
      hdma->State = HAL_DMA_STATE_ERROR;
 800e578:	687b      	ldr	r3, [r7, #4]
 800e57a:	2203      	movs	r2, #3
 800e57c:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54

      return HAL_ERROR;
 800e580:	2301      	movs	r3, #1
 800e582:	e099      	b.n	800e6b8 <HAL_DMA_DeInit+0x18c>
  while ((hdma->Instance->CCR & DMA_CCR_EN) != 0U)
 800e584:	687b      	ldr	r3, [r7, #4]
 800e586:	681b      	ldr	r3, [r3, #0]
 800e588:	695b      	ldr	r3, [r3, #20]
 800e58a:	f003 0301 	and.w	r3, r3, #1
 800e58e:	2b00      	cmp	r3, #0
 800e590:	d1e8      	bne.n	800e564 <HAL_DMA_DeInit+0x38>
    }
  }

  /* Reset DMA Channel registers */
  hdma->Instance->CLBAR = 0U;
 800e592:	687b      	ldr	r3, [r7, #4]
 800e594:	681b      	ldr	r3, [r3, #0]
 800e596:	2200      	movs	r2, #0
 800e598:	601a      	str	r2, [r3, #0]
  hdma->Instance->CCR   = 0U;
 800e59a:	687b      	ldr	r3, [r7, #4]
 800e59c:	681b      	ldr	r3, [r3, #0]
 800e59e:	2200      	movs	r2, #0
 800e5a0:	615a      	str	r2, [r3, #20]
  hdma->Instance->CTR1  = 0U;
 800e5a2:	687b      	ldr	r3, [r7, #4]
 800e5a4:	681b      	ldr	r3, [r3, #0]
 800e5a6:	2200      	movs	r2, #0
 800e5a8:	641a      	str	r2, [r3, #64]	@ 0x40
  hdma->Instance->CTR2  = 0U;
 800e5aa:	687b      	ldr	r3, [r7, #4]
 800e5ac:	681b      	ldr	r3, [r3, #0]
 800e5ae:	2200      	movs	r2, #0
 800e5b0:	645a      	str	r2, [r3, #68]	@ 0x44
  hdma->Instance->CBR1  = 0U;
 800e5b2:	687b      	ldr	r3, [r7, #4]
 800e5b4:	681b      	ldr	r3, [r3, #0]
 800e5b6:	2200      	movs	r2, #0
 800e5b8:	649a      	str	r2, [r3, #72]	@ 0x48
  hdma->Instance->CSAR  = 0U;
 800e5ba:	687b      	ldr	r3, [r7, #4]
 800e5bc:	681b      	ldr	r3, [r3, #0]
 800e5be:	2200      	movs	r2, #0
 800e5c0:	64da      	str	r2, [r3, #76]	@ 0x4c
  hdma->Instance->CDAR  = 0U;
 800e5c2:	687b      	ldr	r3, [r7, #4]
 800e5c4:	681b      	ldr	r3, [r3, #0]
 800e5c6:	2200      	movs	r2, #0
 800e5c8:	651a      	str	r2, [r3, #80]	@ 0x50
  hdma->Instance->CLLR  = 0U;
 800e5ca:	687b      	ldr	r3, [r7, #4]
 800e5cc:	681b      	ldr	r3, [r3, #0]
 800e5ce:	2200      	movs	r2, #0
 800e5d0:	67da      	str	r2, [r3, #124]	@ 0x7c

  /* Reset 2D Addressing registers */
  if (IS_DMA_2D_ADDRESSING_INSTANCE(hdma->Instance) != 0U)
 800e5d2:	687b      	ldr	r3, [r7, #4]
 800e5d4:	681b      	ldr	r3, [r3, #0]
 800e5d6:	4a3a      	ldr	r2, [pc, #232]	@ (800e6c0 <HAL_DMA_DeInit+0x194>)
 800e5d8:	4293      	cmp	r3, r2
 800e5da:	d022      	beq.n	800e622 <HAL_DMA_DeInit+0xf6>
 800e5dc:	687b      	ldr	r3, [r7, #4]
 800e5de:	681b      	ldr	r3, [r3, #0]
 800e5e0:	4a38      	ldr	r2, [pc, #224]	@ (800e6c4 <HAL_DMA_DeInit+0x198>)
 800e5e2:	4293      	cmp	r3, r2
 800e5e4:	d01d      	beq.n	800e622 <HAL_DMA_DeInit+0xf6>
 800e5e6:	687b      	ldr	r3, [r7, #4]
 800e5e8:	681b      	ldr	r3, [r3, #0]
 800e5ea:	4a37      	ldr	r2, [pc, #220]	@ (800e6c8 <HAL_DMA_DeInit+0x19c>)
 800e5ec:	4293      	cmp	r3, r2
 800e5ee:	d018      	beq.n	800e622 <HAL_DMA_DeInit+0xf6>
 800e5f0:	687b      	ldr	r3, [r7, #4]
 800e5f2:	681b      	ldr	r3, [r3, #0]
 800e5f4:	4a35      	ldr	r2, [pc, #212]	@ (800e6cc <HAL_DMA_DeInit+0x1a0>)
 800e5f6:	4293      	cmp	r3, r2
 800e5f8:	d013      	beq.n	800e622 <HAL_DMA_DeInit+0xf6>
 800e5fa:	687b      	ldr	r3, [r7, #4]
 800e5fc:	681b      	ldr	r3, [r3, #0]
 800e5fe:	4a34      	ldr	r2, [pc, #208]	@ (800e6d0 <HAL_DMA_DeInit+0x1a4>)
 800e600:	4293      	cmp	r3, r2
 800e602:	d00e      	beq.n	800e622 <HAL_DMA_DeInit+0xf6>
 800e604:	687b      	ldr	r3, [r7, #4]
 800e606:	681b      	ldr	r3, [r3, #0]
 800e608:	4a32      	ldr	r2, [pc, #200]	@ (800e6d4 <HAL_DMA_DeInit+0x1a8>)
 800e60a:	4293      	cmp	r3, r2
 800e60c:	d009      	beq.n	800e622 <HAL_DMA_DeInit+0xf6>
 800e60e:	687b      	ldr	r3, [r7, #4]
 800e610:	681b      	ldr	r3, [r3, #0]
 800e612:	4a31      	ldr	r2, [pc, #196]	@ (800e6d8 <HAL_DMA_DeInit+0x1ac>)
 800e614:	4293      	cmp	r3, r2
 800e616:	d004      	beq.n	800e622 <HAL_DMA_DeInit+0xf6>
 800e618:	687b      	ldr	r3, [r7, #4]
 800e61a:	681b      	ldr	r3, [r3, #0]
 800e61c:	4a2f      	ldr	r2, [pc, #188]	@ (800e6dc <HAL_DMA_DeInit+0x1b0>)
 800e61e:	4293      	cmp	r3, r2
 800e620:	d101      	bne.n	800e626 <HAL_DMA_DeInit+0xfa>
 800e622:	2301      	movs	r3, #1
 800e624:	e000      	b.n	800e628 <HAL_DMA_DeInit+0xfc>
 800e626:	2300      	movs	r3, #0
 800e628:	2b00      	cmp	r3, #0
 800e62a:	d007      	beq.n	800e63c <HAL_DMA_DeInit+0x110>
  {
    hdma->Instance->CTR3 = 0U;
 800e62c:	687b      	ldr	r3, [r7, #4]
 800e62e:	681b      	ldr	r3, [r3, #0]
 800e630:	2200      	movs	r2, #0
 800e632:	655a      	str	r2, [r3, #84]	@ 0x54
    hdma->Instance->CBR2 = 0U;
 800e634:	687b      	ldr	r3, [r7, #4]
 800e636:	681b      	ldr	r3, [r3, #0]
 800e638:	2200      	movs	r2, #0
 800e63a:	659a      	str	r2, [r3, #88]	@ 0x58
  }

  /* Clear privilege attribute */
  CLEAR_BIT(p_dma_instance->PRIVCFGR, (1UL << (GET_DMA_CHANNEL(hdma) & 0x1FU)));
 800e63c:	68bb      	ldr	r3, [r7, #8]
 800e63e:	685a      	ldr	r2, [r3, #4]
 800e640:	687b      	ldr	r3, [r7, #4]
 800e642:	681b      	ldr	r3, [r3, #0]
 800e644:	f3c3 030b 	ubfx	r3, r3, #0, #12
 800e648:	3b50      	subs	r3, #80	@ 0x50
 800e64a:	09db      	lsrs	r3, r3, #7
 800e64c:	f003 031f 	and.w	r3, r3, #31
 800e650:	2101      	movs	r1, #1
 800e652:	fa01 f303 	lsl.w	r3, r1, r3
 800e656:	43db      	mvns	r3, r3
 800e658:	401a      	ands	r2, r3
 800e65a:	68bb      	ldr	r3, [r7, #8]
 800e65c:	605a      	str	r2, [r3, #4]
  /* Clear secure attribute */
  CLEAR_BIT(p_dma_instance->SECCFGR, (1UL << (GET_DMA_CHANNEL(hdma) & 0x1FU)));
#endif /* (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U) */

  /* Clear all flags */
  __HAL_DMA_CLEAR_FLAG(hdma, (DMA_FLAG_TC | DMA_FLAG_HT | DMA_FLAG_DTE | DMA_FLAG_ULE | DMA_FLAG_USE | DMA_FLAG_SUSP |
 800e65e:	687b      	ldr	r3, [r7, #4]
 800e660:	681b      	ldr	r3, [r3, #0]
 800e662:	f44f 42fe 	mov.w	r2, #32512	@ 0x7f00
 800e666:	60da      	str	r2, [r3, #12]
                              DMA_FLAG_TO));

  /* Clean all callbacks */
  hdma->XferCpltCallback     = NULL;
 800e668:	687b      	ldr	r3, [r7, #4]
 800e66a:	2200      	movs	r2, #0
 800e66c:	661a      	str	r2, [r3, #96]	@ 0x60
  hdma->XferHalfCpltCallback = NULL;
 800e66e:	687b      	ldr	r3, [r7, #4]
 800e670:	2200      	movs	r2, #0
 800e672:	665a      	str	r2, [r3, #100]	@ 0x64
  hdma->XferErrorCallback    = NULL;
 800e674:	687b      	ldr	r3, [r7, #4]
 800e676:	2200      	movs	r2, #0
 800e678:	669a      	str	r2, [r3, #104]	@ 0x68
  hdma->XferAbortCallback    = NULL;
 800e67a:	687b      	ldr	r3, [r7, #4]
 800e67c:	2200      	movs	r2, #0
 800e67e:	66da      	str	r2, [r3, #108]	@ 0x6c
  hdma->XferSuspendCallback  = NULL;
 800e680:	687b      	ldr	r3, [r7, #4]
 800e682:	2200      	movs	r2, #0
 800e684:	671a      	str	r2, [r3, #112]	@ 0x70

  /* Clean DMA queue */
  hdma->LinkedListQueue = NULL;
 800e686:	687b      	ldr	r3, [r7, #4]
 800e688:	2200      	movs	r2, #0
 800e68a:	675a      	str	r2, [r3, #116]	@ 0x74

  /* Clean DMA parent */
  if (hdma->Parent != NULL)
 800e68c:	687b      	ldr	r3, [r7, #4]
 800e68e:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 800e690:	2b00      	cmp	r3, #0
 800e692:	d002      	beq.n	800e69a <HAL_DMA_DeInit+0x16e>
  {
    hdma->Parent = NULL;
 800e694:	687b      	ldr	r3, [r7, #4]
 800e696:	2200      	movs	r2, #0
 800e698:	65da      	str	r2, [r3, #92]	@ 0x5c
  }

  /* Update DMA channel operation mode */
  hdma->Mode = DMA_NORMAL;
 800e69a:	687b      	ldr	r3, [r7, #4]
 800e69c:	2200      	movs	r2, #0
 800e69e:	651a      	str	r2, [r3, #80]	@ 0x50

  /* Update the DMA channel error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 800e6a0:	687b      	ldr	r3, [r7, #4]
 800e6a2:	2200      	movs	r2, #0
 800e6a4:	659a      	str	r2, [r3, #88]	@ 0x58

  /* Update the DMA channel state */
  hdma->State = HAL_DMA_STATE_RESET;
 800e6a6:	687b      	ldr	r3, [r7, #4]
 800e6a8:	2200      	movs	r2, #0
 800e6aa:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54

  /* Release Lock */
  __HAL_UNLOCK(hdma);
 800e6ae:	687b      	ldr	r3, [r7, #4]
 800e6b0:	2200      	movs	r2, #0
 800e6b2:	f883 204c 	strb.w	r2, [r3, #76]	@ 0x4c

  return HAL_OK;
 800e6b6:	2300      	movs	r3, #0
}
 800e6b8:	4618      	mov	r0, r3
 800e6ba:	3710      	adds	r7, #16
 800e6bc:	46bd      	mov	sp, r7
 800e6be:	bd80      	pop	{r7, pc}
 800e6c0:	40020650 	.word	0x40020650
 800e6c4:	50020650 	.word	0x50020650
 800e6c8:	400206d0 	.word	0x400206d0
 800e6cc:	500206d0 	.word	0x500206d0
 800e6d0:	40020750 	.word	0x40020750
 800e6d4:	50020750 	.word	0x50020750
 800e6d8:	400207d0 	.word	0x400207d0
 800e6dc:	500207d0 	.word	0x500207d0

0800e6e0 <HAL_DMA_Abort_IT>:
  * @param  hdma : Pointer to a DMA_HandleTypeDef structure that contains the configuration information for the
  *                specified DMA Channel.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *const hdma)
{
 800e6e0:	b480      	push	{r7}
 800e6e2:	b083      	sub	sp, #12
 800e6e4:	af00      	add	r7, sp, #0
 800e6e6:	6078      	str	r0, [r7, #4]
  /* Check the DMA peripheral handle parameter */
  if (hdma == NULL)
 800e6e8:	687b      	ldr	r3, [r7, #4]
 800e6ea:	2b00      	cmp	r3, #0
 800e6ec:	d101      	bne.n	800e6f2 <HAL_DMA_Abort_IT+0x12>
  {
    return HAL_ERROR;
 800e6ee:	2301      	movs	r3, #1
 800e6f0:	e019      	b.n	800e726 <HAL_DMA_Abort_IT+0x46>
  }

  /* Check DMA channel state */
  if (hdma->State != HAL_DMA_STATE_BUSY)
 800e6f2:	687b      	ldr	r3, [r7, #4]
 800e6f4:	f893 3054 	ldrb.w	r3, [r3, #84]	@ 0x54
 800e6f8:	b2db      	uxtb	r3, r3
 800e6fa:	2b02      	cmp	r3, #2
 800e6fc:	d004      	beq.n	800e708 <HAL_DMA_Abort_IT+0x28>
  {
    /* Update the DMA channel error code */
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 800e6fe:	687b      	ldr	r3, [r7, #4]
 800e700:	2220      	movs	r2, #32
 800e702:	659a      	str	r2, [r3, #88]	@ 0x58

    return HAL_ERROR;
 800e704:	2301      	movs	r3, #1
 800e706:	e00e      	b.n	800e726 <HAL_DMA_Abort_IT+0x46>
  }
  else
  {
    /* Update the DMA channel state */
    hdma->State = HAL_DMA_STATE_ABORT;
 800e708:	687b      	ldr	r3, [r7, #4]
 800e70a:	2204      	movs	r2, #4
 800e70c:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54

    /* Suspend the channel and activate suspend interrupt */
    hdma->Instance->CCR |= (DMA_CCR_SUSP | DMA_CCR_SUSPIE);
 800e710:	687b      	ldr	r3, [r7, #4]
 800e712:	681b      	ldr	r3, [r3, #0]
 800e714:	695b      	ldr	r3, [r3, #20]
 800e716:	687a      	ldr	r2, [r7, #4]
 800e718:	6812      	ldr	r2, [r2, #0]
 800e71a:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
 800e71e:	f043 0304 	orr.w	r3, r3, #4
 800e722:	6153      	str	r3, [r2, #20]
  }

  return HAL_OK;
 800e724:	2300      	movs	r3, #0
}
 800e726:	4618      	mov	r0, r3
 800e728:	370c      	adds	r7, #12
 800e72a:	46bd      	mov	sp, r7
 800e72c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e730:	4770      	bx	lr

0800e732 <HAL_DMA_IRQHandler>:
  * @param  hdma : Pointer to a DMA_HandleTypeDef structure that contains the configuration information for the
  *                specified DMA Channel.
  * @retval None.
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *const hdma)
{
 800e732:	b580      	push	{r7, lr}
 800e734:	b086      	sub	sp, #24
 800e736:	af00      	add	r7, sp, #0
 800e738:	6078      	str	r0, [r7, #4]
  const DMA_TypeDef *p_dma_instance = GET_DMA_INSTANCE(hdma);
 800e73a:	687b      	ldr	r3, [r7, #4]
 800e73c:	681b      	ldr	r3, [r3, #0]
 800e73e:	f423 637f 	bic.w	r3, r3, #4080	@ 0xff0
 800e742:	f023 030f 	bic.w	r3, r3, #15
 800e746:	617b      	str	r3, [r7, #20]
  uint32_t global_it_flag =  1UL << (GET_DMA_CHANNEL(hdma) & 0x1FU);
 800e748:	687b      	ldr	r3, [r7, #4]
 800e74a:	681b      	ldr	r3, [r3, #0]
 800e74c:	f3c3 030b 	ubfx	r3, r3, #0, #12
 800e750:	3b50      	subs	r3, #80	@ 0x50
 800e752:	09db      	lsrs	r3, r3, #7
 800e754:	f003 031f 	and.w	r3, r3, #31
 800e758:	2201      	movs	r2, #1
 800e75a:	fa02 f303 	lsl.w	r3, r2, r3
 800e75e:	613b      	str	r3, [r7, #16]
  uint32_t global_active_flag_ns = IS_DMA_GLOBAL_ACTIVE_FLAG_NS(p_dma_instance, global_it_flag);
 800e760:	697b      	ldr	r3, [r7, #20]
 800e762:	68db      	ldr	r3, [r3, #12]
 800e764:	693a      	ldr	r2, [r7, #16]
 800e766:	4013      	ands	r3, r2
 800e768:	60fb      	str	r3, [r7, #12]

  /* Global Interrupt Flag management *********************************************************************************/
#if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
  if ((global_active_flag_s == 0U) && (global_active_flag_ns == 0U))
#else
  if (global_active_flag_ns == 0U)
 800e76a:	68fb      	ldr	r3, [r7, #12]
 800e76c:	2b00      	cmp	r3, #0
 800e76e:	f000 813b 	beq.w	800e9e8 <HAL_DMA_IRQHandler+0x2b6>
  {
    return; /* the global interrupt flag for the current channel is down , nothing to do */
  }

  /* Data Transfer Error Interrupt management *************************************************************************/
  if ((__HAL_DMA_GET_FLAG(hdma, DMA_FLAG_DTE) != 0U))
 800e772:	687b      	ldr	r3, [r7, #4]
 800e774:	681b      	ldr	r3, [r3, #0]
 800e776:	691b      	ldr	r3, [r3, #16]
 800e778:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 800e77c:	2b00      	cmp	r3, #0
 800e77e:	d011      	beq.n	800e7a4 <HAL_DMA_IRQHandler+0x72>
  {
    /* Check if interrupt source is enabled */
    if (__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DTE) != 0U)
 800e780:	687b      	ldr	r3, [r7, #4]
 800e782:	681b      	ldr	r3, [r3, #0]
 800e784:	695b      	ldr	r3, [r3, #20]
 800e786:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 800e78a:	2b00      	cmp	r3, #0
 800e78c:	d00a      	beq.n	800e7a4 <HAL_DMA_IRQHandler+0x72>
    {
      /* Clear the transfer error flag */
      __HAL_DMA_CLEAR_FLAG(hdma, DMA_FLAG_DTE);
 800e78e:	687b      	ldr	r3, [r7, #4]
 800e790:	681b      	ldr	r3, [r3, #0]
 800e792:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 800e796:	60da      	str	r2, [r3, #12]

      /* Update the DMA channel error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_DTE;
 800e798:	687b      	ldr	r3, [r7, #4]
 800e79a:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800e79c:	f043 0201 	orr.w	r2, r3, #1
 800e7a0:	687b      	ldr	r3, [r7, #4]
 800e7a2:	659a      	str	r2, [r3, #88]	@ 0x58
    }
  }

  /* Update Linked-list Error Interrupt management ********************************************************************/
  if ((__HAL_DMA_GET_FLAG(hdma, DMA_FLAG_ULE) != 0U))
 800e7a4:	687b      	ldr	r3, [r7, #4]
 800e7a6:	681b      	ldr	r3, [r3, #0]
 800e7a8:	691b      	ldr	r3, [r3, #16]
 800e7aa:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 800e7ae:	2b00      	cmp	r3, #0
 800e7b0:	d011      	beq.n	800e7d6 <HAL_DMA_IRQHandler+0xa4>
  {
    /* Check if interrupt source is enabled */
    if (__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_ULE) != 0U)
 800e7b2:	687b      	ldr	r3, [r7, #4]
 800e7b4:	681b      	ldr	r3, [r3, #0]
 800e7b6:	695b      	ldr	r3, [r3, #20]
 800e7b8:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 800e7bc:	2b00      	cmp	r3, #0
 800e7be:	d00a      	beq.n	800e7d6 <HAL_DMA_IRQHandler+0xa4>
    {
      /* Clear the update linked-list error flag */
      __HAL_DMA_CLEAR_FLAG(hdma, DMA_FLAG_ULE);
 800e7c0:	687b      	ldr	r3, [r7, #4]
 800e7c2:	681b      	ldr	r3, [r3, #0]
 800e7c4:	f44f 6200 	mov.w	r2, #2048	@ 0x800
 800e7c8:	60da      	str	r2, [r3, #12]

      /* Update the DMA channel error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_ULE;
 800e7ca:	687b      	ldr	r3, [r7, #4]
 800e7cc:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800e7ce:	f043 0202 	orr.w	r2, r3, #2
 800e7d2:	687b      	ldr	r3, [r7, #4]
 800e7d4:	659a      	str	r2, [r3, #88]	@ 0x58
    }
  }

  /* User Setting Error Interrupt management **************************************************************************/
  if ((__HAL_DMA_GET_FLAG(hdma, DMA_FLAG_USE) != 0U))
 800e7d6:	687b      	ldr	r3, [r7, #4]
 800e7d8:	681b      	ldr	r3, [r3, #0]
 800e7da:	691b      	ldr	r3, [r3, #16]
 800e7dc:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
 800e7e0:	2b00      	cmp	r3, #0
 800e7e2:	d011      	beq.n	800e808 <HAL_DMA_IRQHandler+0xd6>
  {
    /* Check if interrupt source is enabled */
    if (__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_USE) != 0U)
 800e7e4:	687b      	ldr	r3, [r7, #4]
 800e7e6:	681b      	ldr	r3, [r3, #0]
 800e7e8:	695b      	ldr	r3, [r3, #20]
 800e7ea:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
 800e7ee:	2b00      	cmp	r3, #0
 800e7f0:	d00a      	beq.n	800e808 <HAL_DMA_IRQHandler+0xd6>
    {
      /* Clear the user setting error flag */
      __HAL_DMA_CLEAR_FLAG(hdma, DMA_FLAG_USE);
 800e7f2:	687b      	ldr	r3, [r7, #4]
 800e7f4:	681b      	ldr	r3, [r3, #0]
 800e7f6:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
 800e7fa:	60da      	str	r2, [r3, #12]

      /* Update the DMA channel error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_USE;
 800e7fc:	687b      	ldr	r3, [r7, #4]
 800e7fe:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800e800:	f043 0204 	orr.w	r2, r3, #4
 800e804:	687b      	ldr	r3, [r7, #4]
 800e806:	659a      	str	r2, [r3, #88]	@ 0x58
    }
  }

  /* Trigger Overrun Interrupt management *****************************************************************************/
  if ((__HAL_DMA_GET_FLAG(hdma, DMA_FLAG_TO) != 0U))
 800e808:	687b      	ldr	r3, [r7, #4]
 800e80a:	681b      	ldr	r3, [r3, #0]
 800e80c:	691b      	ldr	r3, [r3, #16]
 800e80e:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
 800e812:	2b00      	cmp	r3, #0
 800e814:	d011      	beq.n	800e83a <HAL_DMA_IRQHandler+0x108>
  {
    /* Check if interrupt source is enabled */
    if (__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TO) != 0U)
 800e816:	687b      	ldr	r3, [r7, #4]
 800e818:	681b      	ldr	r3, [r3, #0]
 800e81a:	695b      	ldr	r3, [r3, #20]
 800e81c:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
 800e820:	2b00      	cmp	r3, #0
 800e822:	d00a      	beq.n	800e83a <HAL_DMA_IRQHandler+0x108>
    {
      /* Clear the trigger overrun flag */
      __HAL_DMA_CLEAR_FLAG(hdma, DMA_FLAG_TO);
 800e824:	687b      	ldr	r3, [r7, #4]
 800e826:	681b      	ldr	r3, [r3, #0]
 800e828:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
 800e82c:	60da      	str	r2, [r3, #12]

      /* Update the DMA channel error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_TO;
 800e82e:	687b      	ldr	r3, [r7, #4]
 800e830:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800e832:	f043 0208 	orr.w	r2, r3, #8
 800e836:	687b      	ldr	r3, [r7, #4]
 800e838:	659a      	str	r2, [r3, #88]	@ 0x58
    }
  }

  /* Half Transfer Complete Interrupt management **********************************************************************/
  if ((__HAL_DMA_GET_FLAG(hdma, DMA_FLAG_HT) != 0U))
 800e83a:	687b      	ldr	r3, [r7, #4]
 800e83c:	681b      	ldr	r3, [r3, #0]
 800e83e:	691b      	ldr	r3, [r3, #16]
 800e840:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 800e844:	2b00      	cmp	r3, #0
 800e846:	d013      	beq.n	800e870 <HAL_DMA_IRQHandler+0x13e>
  {
    /* Check if interrupt source is enabled */
    if (__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != 0U)
 800e848:	687b      	ldr	r3, [r7, #4]
 800e84a:	681b      	ldr	r3, [r3, #0]
 800e84c:	695b      	ldr	r3, [r3, #20]
 800e84e:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 800e852:	2b00      	cmp	r3, #0
 800e854:	d00c      	beq.n	800e870 <HAL_DMA_IRQHandler+0x13e>
    {
      /* Clear the half transfer flag */
      __HAL_DMA_CLEAR_FLAG(hdma, DMA_FLAG_HT);
 800e856:	687b      	ldr	r3, [r7, #4]
 800e858:	681b      	ldr	r3, [r3, #0]
 800e85a:	f44f 7200 	mov.w	r2, #512	@ 0x200
 800e85e:	60da      	str	r2, [r3, #12]

      /* Check half transfer complete callback */
      if (hdma->XferHalfCpltCallback != NULL)
 800e860:	687b      	ldr	r3, [r7, #4]
 800e862:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 800e864:	2b00      	cmp	r3, #0
 800e866:	d003      	beq.n	800e870 <HAL_DMA_IRQHandler+0x13e>
      {
        /* Half transfer callback */
        hdma->XferHalfCpltCallback(hdma);
 800e868:	687b      	ldr	r3, [r7, #4]
 800e86a:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 800e86c:	6878      	ldr	r0, [r7, #4]
 800e86e:	4798      	blx	r3
      }
    }
  }

  /* Suspend Transfer Interrupt management ****************************************************************************/
  if ((__HAL_DMA_GET_FLAG(hdma, DMA_FLAG_SUSP) != 0U))
 800e870:	687b      	ldr	r3, [r7, #4]
 800e872:	681b      	ldr	r3, [r3, #0]
 800e874:	691b      	ldr	r3, [r3, #16]
 800e876:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 800e87a:	2b00      	cmp	r3, #0
 800e87c:	d04c      	beq.n	800e918 <HAL_DMA_IRQHandler+0x1e6>
  {
    /* Check if interrupt source is enabled */
    if (__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_SUSP) != 0U)
 800e87e:	687b      	ldr	r3, [r7, #4]
 800e880:	681b      	ldr	r3, [r3, #0]
 800e882:	695b      	ldr	r3, [r3, #20]
 800e884:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 800e888:	2b00      	cmp	r3, #0
 800e88a:	d045      	beq.n	800e918 <HAL_DMA_IRQHandler+0x1e6>
    {
      /* Clear the block transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, DMA_FLAG_SUSP);
 800e88c:	687b      	ldr	r3, [r7, #4]
 800e88e:	681b      	ldr	r3, [r3, #0]
 800e890:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
 800e894:	60da      	str	r2, [r3, #12]

      /* Check DMA channel state */
      if (hdma->State == HAL_DMA_STATE_ABORT)
 800e896:	687b      	ldr	r3, [r7, #4]
 800e898:	f893 3054 	ldrb.w	r3, [r3, #84]	@ 0x54
 800e89c:	b2db      	uxtb	r3, r3
 800e89e:	2b04      	cmp	r3, #4
 800e8a0:	d12e      	bne.n	800e900 <HAL_DMA_IRQHandler+0x1ce>
      {
        /* Disable the suspend transfer interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_SUSP);
 800e8a2:	687b      	ldr	r3, [r7, #4]
 800e8a4:	681b      	ldr	r3, [r3, #0]
 800e8a6:	695a      	ldr	r2, [r3, #20]
 800e8a8:	687b      	ldr	r3, [r7, #4]
 800e8aa:	681b      	ldr	r3, [r3, #0]
 800e8ac:	f422 5200 	bic.w	r2, r2, #8192	@ 0x2000
 800e8b0:	615a      	str	r2, [r3, #20]

        /* Reset the channel internal state and reset the FIFO */
        hdma->Instance->CCR |= DMA_CCR_RESET;
 800e8b2:	687b      	ldr	r3, [r7, #4]
 800e8b4:	681b      	ldr	r3, [r3, #0]
 800e8b6:	695a      	ldr	r2, [r3, #20]
 800e8b8:	687b      	ldr	r3, [r7, #4]
 800e8ba:	681b      	ldr	r3, [r3, #0]
 800e8bc:	f042 0202 	orr.w	r2, r2, #2
 800e8c0:	615a      	str	r2, [r3, #20]

        /* Update the DMA channel state */
        hdma->State = HAL_DMA_STATE_READY;
 800e8c2:	687b      	ldr	r3, [r7, #4]
 800e8c4:	2201      	movs	r2, #1
 800e8c6:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54

        /* Check DMA channel transfer mode */
        if ((hdma->Mode & DMA_LINKEDLIST) == DMA_LINKEDLIST)
 800e8ca:	687b      	ldr	r3, [r7, #4]
 800e8cc:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800e8ce:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 800e8d2:	2b00      	cmp	r3, #0
 800e8d4:	d007      	beq.n	800e8e6 <HAL_DMA_IRQHandler+0x1b4>
        {
          /* Update the linked-list queue state */
          hdma->LinkedListQueue->State = HAL_DMA_QUEUE_STATE_READY;
 800e8d6:	687b      	ldr	r3, [r7, #4]
 800e8d8:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 800e8da:	2201      	movs	r2, #1
 800e8dc:	731a      	strb	r2, [r3, #12]

          /* Clear remaining data size to ensure loading linked-list from memory next start */
          hdma->Instance->CBR1 = 0U;
 800e8de:	687b      	ldr	r3, [r7, #4]
 800e8e0:	681b      	ldr	r3, [r3, #0]
 800e8e2:	2200      	movs	r2, #0
 800e8e4:	649a      	str	r2, [r3, #72]	@ 0x48
        }

        /* Process Unlocked */
        __HAL_UNLOCK(hdma);
 800e8e6:	687b      	ldr	r3, [r7, #4]
 800e8e8:	2200      	movs	r2, #0
 800e8ea:	f883 204c 	strb.w	r2, [r3, #76]	@ 0x4c

        /* Check transfer abort callback */
        if (hdma->XferAbortCallback != NULL)
 800e8ee:	687b      	ldr	r3, [r7, #4]
 800e8f0:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 800e8f2:	2b00      	cmp	r3, #0
 800e8f4:	d07a      	beq.n	800e9ec <HAL_DMA_IRQHandler+0x2ba>
        {
          /* Transfer abort callback */
          hdma->XferAbortCallback(hdma);
 800e8f6:	687b      	ldr	r3, [r7, #4]
 800e8f8:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 800e8fa:	6878      	ldr	r0, [r7, #4]
 800e8fc:	4798      	blx	r3
        }

        return;
 800e8fe:	e075      	b.n	800e9ec <HAL_DMA_IRQHandler+0x2ba>
      }
      else
      {
        /* Update the DMA channel state */
        hdma->State = HAL_DMA_STATE_SUSPEND;
 800e900:	687b      	ldr	r3, [r7, #4]
 800e902:	2205      	movs	r2, #5
 800e904:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54

        /* Check transfer suspend callback */
        if (hdma->XferSuspendCallback != NULL)
 800e908:	687b      	ldr	r3, [r7, #4]
 800e90a:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 800e90c:	2b00      	cmp	r3, #0
 800e90e:	d003      	beq.n	800e918 <HAL_DMA_IRQHandler+0x1e6>
        {
          /* Transfer suspend callback */
          hdma->XferSuspendCallback(hdma);
 800e910:	687b      	ldr	r3, [r7, #4]
 800e912:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 800e914:	6878      	ldr	r0, [r7, #4]
 800e916:	4798      	blx	r3
      }
    }
  }

  /* Transfer Complete Interrupt management ***************************************************************************/
  if ((__HAL_DMA_GET_FLAG(hdma, DMA_FLAG_TC) != 0U))
 800e918:	687b      	ldr	r3, [r7, #4]
 800e91a:	681b      	ldr	r3, [r3, #0]
 800e91c:	691b      	ldr	r3, [r3, #16]
 800e91e:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 800e922:	2b00      	cmp	r3, #0
 800e924:	d039      	beq.n	800e99a <HAL_DMA_IRQHandler+0x268>
  {
    /* Check if interrupt source is enabled */
    if (__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != 0U)
 800e926:	687b      	ldr	r3, [r7, #4]
 800e928:	681b      	ldr	r3, [r3, #0]
 800e92a:	695b      	ldr	r3, [r3, #20]
 800e92c:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 800e930:	2b00      	cmp	r3, #0
 800e932:	d032      	beq.n	800e99a <HAL_DMA_IRQHandler+0x268>
    {
      /* Check DMA channel transfer mode */
      if ((hdma->Mode & DMA_LINKEDLIST) == DMA_LINKEDLIST)
 800e934:	687b      	ldr	r3, [r7, #4]
 800e936:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800e938:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 800e93c:	2b00      	cmp	r3, #0
 800e93e:	d012      	beq.n	800e966 <HAL_DMA_IRQHandler+0x234>
      {
        /* If linked-list transfer */
        if (hdma->Instance->CLLR == 0U)
 800e940:	687b      	ldr	r3, [r7, #4]
 800e942:	681b      	ldr	r3, [r3, #0]
 800e944:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
 800e946:	2b00      	cmp	r3, #0
 800e948:	d116      	bne.n	800e978 <HAL_DMA_IRQHandler+0x246>
        {
          if (hdma->Instance->CBR1 == 0U)
 800e94a:	687b      	ldr	r3, [r7, #4]
 800e94c:	681b      	ldr	r3, [r3, #0]
 800e94e:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 800e950:	2b00      	cmp	r3, #0
 800e952:	d111      	bne.n	800e978 <HAL_DMA_IRQHandler+0x246>
          {
            /* Update the DMA channel state */
            hdma->State = HAL_DMA_STATE_READY;
 800e954:	687b      	ldr	r3, [r7, #4]
 800e956:	2201      	movs	r2, #1
 800e958:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54

            /* Update the linked-list queue state */
            hdma->LinkedListQueue->State = HAL_DMA_QUEUE_STATE_READY;
 800e95c:	687b      	ldr	r3, [r7, #4]
 800e95e:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 800e960:	2201      	movs	r2, #1
 800e962:	731a      	strb	r2, [r3, #12]
 800e964:	e008      	b.n	800e978 <HAL_DMA_IRQHandler+0x246>
        }
      }
      else
      {
        /* If normal transfer */
        if (hdma->Instance->CBR1 == 0U)
 800e966:	687b      	ldr	r3, [r7, #4]
 800e968:	681b      	ldr	r3, [r3, #0]
 800e96a:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 800e96c:	2b00      	cmp	r3, #0
 800e96e:	d103      	bne.n	800e978 <HAL_DMA_IRQHandler+0x246>
        {
          /* Update the DMA channel state */
          hdma->State = HAL_DMA_STATE_READY;
 800e970:	687b      	ldr	r3, [r7, #4]
 800e972:	2201      	movs	r2, #1
 800e974:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54
        }
      }

      /* Clear TC and HT transfer flags */
      __HAL_DMA_CLEAR_FLAG(hdma, (DMA_FLAG_TC | DMA_FLAG_HT));
 800e978:	687b      	ldr	r3, [r7, #4]
 800e97a:	681b      	ldr	r3, [r3, #0]
 800e97c:	f44f 7240 	mov.w	r2, #768	@ 0x300
 800e980:	60da      	str	r2, [r3, #12]

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
 800e982:	687b      	ldr	r3, [r7, #4]
 800e984:	2200      	movs	r2, #0
 800e986:	f883 204c 	strb.w	r2, [r3, #76]	@ 0x4c

      /* Check transfer complete callback */
      if (hdma->XferCpltCallback != NULL)
 800e98a:	687b      	ldr	r3, [r7, #4]
 800e98c:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 800e98e:	2b00      	cmp	r3, #0
 800e990:	d003      	beq.n	800e99a <HAL_DMA_IRQHandler+0x268>
      {
        /* Channel Transfer Complete callback */
        hdma->XferCpltCallback(hdma);
 800e992:	687b      	ldr	r3, [r7, #4]
 800e994:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 800e996:	6878      	ldr	r0, [r7, #4]
 800e998:	4798      	blx	r3
      }
    }
  }

  /* Manage error case ************************************************************************************************/
  if (hdma->ErrorCode != HAL_DMA_ERROR_NONE)
 800e99a:	687b      	ldr	r3, [r7, #4]
 800e99c:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800e99e:	2b00      	cmp	r3, #0
 800e9a0:	d025      	beq.n	800e9ee <HAL_DMA_IRQHandler+0x2bc>
  {
    /* Reset the channel internal state and reset the FIFO */
    hdma->Instance->CCR |= DMA_CCR_RESET;
 800e9a2:	687b      	ldr	r3, [r7, #4]
 800e9a4:	681b      	ldr	r3, [r3, #0]
 800e9a6:	695a      	ldr	r2, [r3, #20]
 800e9a8:	687b      	ldr	r3, [r7, #4]
 800e9aa:	681b      	ldr	r3, [r3, #0]
 800e9ac:	f042 0202 	orr.w	r2, r2, #2
 800e9b0:	615a      	str	r2, [r3, #20]

    /* Update the DMA channel state */
    hdma->State = HAL_DMA_STATE_READY;
 800e9b2:	687b      	ldr	r3, [r7, #4]
 800e9b4:	2201      	movs	r2, #1
 800e9b6:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54

    /* Check DMA channel transfer mode */
    if ((hdma->Mode & DMA_LINKEDLIST) == DMA_LINKEDLIST)
 800e9ba:	687b      	ldr	r3, [r7, #4]
 800e9bc:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800e9be:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 800e9c2:	2b00      	cmp	r3, #0
 800e9c4:	d003      	beq.n	800e9ce <HAL_DMA_IRQHandler+0x29c>
    {
      /* Update the linked-list queue state */
      hdma->LinkedListQueue->State = HAL_DMA_QUEUE_STATE_READY;
 800e9c6:	687b      	ldr	r3, [r7, #4]
 800e9c8:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 800e9ca:	2201      	movs	r2, #1
 800e9cc:	731a      	strb	r2, [r3, #12]
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 800e9ce:	687b      	ldr	r3, [r7, #4]
 800e9d0:	2200      	movs	r2, #0
 800e9d2:	f883 204c 	strb.w	r2, [r3, #76]	@ 0x4c

    /* Check transfer error callback */
    if (hdma->XferErrorCallback != NULL)
 800e9d6:	687b      	ldr	r3, [r7, #4]
 800e9d8:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 800e9da:	2b00      	cmp	r3, #0
 800e9dc:	d007      	beq.n	800e9ee <HAL_DMA_IRQHandler+0x2bc>
    {
      /* Transfer error callback */
      hdma->XferErrorCallback(hdma);
 800e9de:	687b      	ldr	r3, [r7, #4]
 800e9e0:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 800e9e2:	6878      	ldr	r0, [r7, #4]
 800e9e4:	4798      	blx	r3
 800e9e6:	e002      	b.n	800e9ee <HAL_DMA_IRQHandler+0x2bc>
    return; /* the global interrupt flag for the current channel is down , nothing to do */
 800e9e8:	bf00      	nop
 800e9ea:	e000      	b.n	800e9ee <HAL_DMA_IRQHandler+0x2bc>
        return;
 800e9ec:	bf00      	nop
    }
  }
}
 800e9ee:	3718      	adds	r7, #24
 800e9f0:	46bd      	mov	sp, r7
 800e9f2:	bd80      	pop	{r7, pc}

0800e9f4 <HAL_DMA_GetState>:
  * @param  hdma : Pointer to a DMA_HandleTypeDef structure that contains the configuration information for the
  *                specified DMA Channel.
  * @retval DMA state.
  */
HAL_DMA_StateTypeDef HAL_DMA_GetState(DMA_HandleTypeDef const *const hdma)
{
 800e9f4:	b480      	push	{r7}
 800e9f6:	b083      	sub	sp, #12
 800e9f8:	af00      	add	r7, sp, #0
 800e9fa:	6078      	str	r0, [r7, #4]
  /* Return the DMA channel state */
  return hdma->State;
 800e9fc:	687b      	ldr	r3, [r7, #4]
 800e9fe:	f893 3054 	ldrb.w	r3, [r3, #84]	@ 0x54
 800ea02:	b2db      	uxtb	r3, r3
}
 800ea04:	4618      	mov	r0, r3
 800ea06:	370c      	adds	r7, #12
 800ea08:	46bd      	mov	sp, r7
 800ea0a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ea0e:	4770      	bx	lr

0800ea10 <HAL_DMA_ConfigChannelAttributes>:
  * @param  ChannelAttributes : Specifies the DMA channel secure/privilege attributes.
  *                             This parameter can be a one or a combination of @ref DMA_Channel_Attributes.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_DMA_ConfigChannelAttributes(DMA_HandleTypeDef *const hdma, uint32_t ChannelAttributes)
{
 800ea10:	b480      	push	{r7}
 800ea12:	b085      	sub	sp, #20
 800ea14:	af00      	add	r7, sp, #0
 800ea16:	6078      	str	r0, [r7, #4]
 800ea18:	6039      	str	r1, [r7, #0]
  DMA_TypeDef *p_dma_instance;
  uint32_t channel_idx;

  /* Check the DMA peripheral handle parameter */
  if (hdma == NULL)
 800ea1a:	687b      	ldr	r3, [r7, #4]
 800ea1c:	2b00      	cmp	r3, #0
 800ea1e:	d101      	bne.n	800ea24 <HAL_DMA_ConfigChannelAttributes+0x14>
  {
    return HAL_ERROR;
 800ea20:	2301      	movs	r3, #1
 800ea22:	e02b      	b.n	800ea7c <HAL_DMA_ConfigChannelAttributes+0x6c>

  /* Check the parameters */
  assert_param(IS_DMA_ATTRIBUTES(ChannelAttributes));

  /* Get DMA instance */
  p_dma_instance = GET_DMA_INSTANCE(hdma);
 800ea24:	687b      	ldr	r3, [r7, #4]
 800ea26:	681b      	ldr	r3, [r3, #0]
 800ea28:	f423 637f 	bic.w	r3, r3, #4080	@ 0xff0
 800ea2c:	f023 030f 	bic.w	r3, r3, #15
 800ea30:	60fb      	str	r3, [r7, #12]

  /* Get channel index */
  channel_idx = 1UL << (GET_DMA_CHANNEL(hdma) & 0x1FU);
 800ea32:	687b      	ldr	r3, [r7, #4]
 800ea34:	681b      	ldr	r3, [r3, #0]
 800ea36:	f3c3 030b 	ubfx	r3, r3, #0, #12
 800ea3a:	3b50      	subs	r3, #80	@ 0x50
 800ea3c:	09db      	lsrs	r3, r3, #7
 800ea3e:	f003 031f 	and.w	r3, r3, #31
 800ea42:	2201      	movs	r2, #1
 800ea44:	fa02 f303 	lsl.w	r3, r2, r3
 800ea48:	60bb      	str	r3, [r7, #8]

  /* Check DMA channel privilege attribute management */
  if ((ChannelAttributes & DMA_CHANNEL_ATTR_PRIV_MASK) == DMA_CHANNEL_ATTR_PRIV_MASK)
 800ea4a:	683b      	ldr	r3, [r7, #0]
 800ea4c:	f003 0310 	and.w	r3, r3, #16
 800ea50:	2b00      	cmp	r3, #0
 800ea52:	d012      	beq.n	800ea7a <HAL_DMA_ConfigChannelAttributes+0x6a>
  {
    /* Configure DMA channel privilege attribute */
    if ((ChannelAttributes & DMA_CHANNEL_PRIV) == DMA_CHANNEL_PRIV)
 800ea54:	683b      	ldr	r3, [r7, #0]
 800ea56:	f003 0311 	and.w	r3, r3, #17
 800ea5a:	2b11      	cmp	r3, #17
 800ea5c:	d106      	bne.n	800ea6c <HAL_DMA_ConfigChannelAttributes+0x5c>
    {
      p_dma_instance->PRIVCFGR |= channel_idx;
 800ea5e:	68fb      	ldr	r3, [r7, #12]
 800ea60:	685a      	ldr	r2, [r3, #4]
 800ea62:	68bb      	ldr	r3, [r7, #8]
 800ea64:	431a      	orrs	r2, r3
 800ea66:	68fb      	ldr	r3, [r7, #12]
 800ea68:	605a      	str	r2, [r3, #4]
 800ea6a:	e006      	b.n	800ea7a <HAL_DMA_ConfigChannelAttributes+0x6a>
    }
    else
    {
      p_dma_instance->PRIVCFGR &= (~channel_idx);
 800ea6c:	68fb      	ldr	r3, [r7, #12]
 800ea6e:	685a      	ldr	r2, [r3, #4]
 800ea70:	68bb      	ldr	r3, [r7, #8]
 800ea72:	43db      	mvns	r3, r3
 800ea74:	401a      	ands	r2, r3
 800ea76:	68fb      	ldr	r3, [r7, #12]
 800ea78:	605a      	str	r2, [r3, #4]
      hdma->Instance->CTR1 &= (~DMA_CTR1_DSEC);
    }
  }
#endif /* (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U) */

  return HAL_OK;
 800ea7a:	2300      	movs	r3, #0
}
 800ea7c:	4618      	mov	r0, r3
 800ea7e:	3714      	adds	r7, #20
 800ea80:	46bd      	mov	sp, r7
 800ea82:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ea86:	4770      	bx	lr

0800ea88 <DMA_Init>:
  * @param  hdma : pointer to a DMA_HandleTypeDef structure that contains the configuration information for the
  *                specified DMA Channel.
  * @retval None.
  */
static void DMA_Init(DMA_HandleTypeDef const *const hdma)
{
 800ea88:	b480      	push	{r7}
 800ea8a:	b085      	sub	sp, #20
 800ea8c:	af00      	add	r7, sp, #0
 800ea8e:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg;

  /* Prepare DMA Channel Control Register (CCR) value *****************************************************************/
  tmpreg = hdma->Init.Priority;
 800ea90:	687b      	ldr	r3, [r7, #4]
 800ea92:	6a1b      	ldr	r3, [r3, #32]
 800ea94:	60fb      	str	r3, [r7, #12]

  /* Write DMA Channel Control Register (CCR) */
  MODIFY_REG(hdma->Instance->CCR, DMA_CCR_PRIO | DMA_CCR_LAP | DMA_CCR_LSM, tmpreg);
 800ea96:	687b      	ldr	r3, [r7, #4]
 800ea98:	681b      	ldr	r3, [r3, #0]
 800ea9a:	695b      	ldr	r3, [r3, #20]
 800ea9c:	f423 0143 	bic.w	r1, r3, #12779520	@ 0xc30000
 800eaa0:	687b      	ldr	r3, [r7, #4]
 800eaa2:	681b      	ldr	r3, [r3, #0]
 800eaa4:	68fa      	ldr	r2, [r7, #12]
 800eaa6:	430a      	orrs	r2, r1
 800eaa8:	615a      	str	r2, [r3, #20]

  /* Prepare DMA Channel Transfer Register (CTR1) value ***************************************************************/
  tmpreg = hdma->Init.DestInc | hdma->Init.DestDataWidth | hdma->Init.SrcInc | hdma->Init.SrcDataWidth;
 800eaaa:	687b      	ldr	r3, [r7, #4]
 800eaac:	695a      	ldr	r2, [r3, #20]
 800eaae:	687b      	ldr	r3, [r7, #4]
 800eab0:	69db      	ldr	r3, [r3, #28]
 800eab2:	431a      	orrs	r2, r3
 800eab4:	687b      	ldr	r3, [r7, #4]
 800eab6:	691b      	ldr	r3, [r3, #16]
 800eab8:	431a      	orrs	r2, r3
 800eaba:	687b      	ldr	r3, [r7, #4]
 800eabc:	699b      	ldr	r3, [r3, #24]
 800eabe:	4313      	orrs	r3, r2
 800eac0:	60fb      	str	r3, [r7, #12]

  /* Add parameters specific to GPDMA */
  if (IS_GPDMA_INSTANCE(hdma->Instance) != 0U)
 800eac2:	687b      	ldr	r3, [r7, #4]
 800eac4:	681b      	ldr	r3, [r3, #0]
 800eac6:	4a53      	ldr	r2, [pc, #332]	@ (800ec14 <DMA_Init+0x18c>)
 800eac8:	4293      	cmp	r3, r2
 800eaca:	f000 80a0 	beq.w	800ec0e <DMA_Init+0x186>
 800eace:	687b      	ldr	r3, [r7, #4]
 800ead0:	681b      	ldr	r3, [r3, #0]
 800ead2:	4a51      	ldr	r2, [pc, #324]	@ (800ec18 <DMA_Init+0x190>)
 800ead4:	4293      	cmp	r3, r2
 800ead6:	f000 809a 	beq.w	800ec0e <DMA_Init+0x186>
 800eada:	687b      	ldr	r3, [r7, #4]
 800eadc:	681b      	ldr	r3, [r3, #0]
 800eade:	4a4f      	ldr	r2, [pc, #316]	@ (800ec1c <DMA_Init+0x194>)
 800eae0:	4293      	cmp	r3, r2
 800eae2:	f000 8094 	beq.w	800ec0e <DMA_Init+0x186>
 800eae6:	687b      	ldr	r3, [r7, #4]
 800eae8:	681b      	ldr	r3, [r3, #0]
 800eaea:	4a4d      	ldr	r2, [pc, #308]	@ (800ec20 <DMA_Init+0x198>)
 800eaec:	4293      	cmp	r3, r2
 800eaee:	f000 808e 	beq.w	800ec0e <DMA_Init+0x186>
 800eaf2:	687b      	ldr	r3, [r7, #4]
 800eaf4:	681b      	ldr	r3, [r3, #0]
 800eaf6:	4a4b      	ldr	r2, [pc, #300]	@ (800ec24 <DMA_Init+0x19c>)
 800eaf8:	4293      	cmp	r3, r2
 800eafa:	f000 8088 	beq.w	800ec0e <DMA_Init+0x186>
 800eafe:	687b      	ldr	r3, [r7, #4]
 800eb00:	681b      	ldr	r3, [r3, #0]
 800eb02:	4a49      	ldr	r2, [pc, #292]	@ (800ec28 <DMA_Init+0x1a0>)
 800eb04:	4293      	cmp	r3, r2
 800eb06:	f000 8082 	beq.w	800ec0e <DMA_Init+0x186>
 800eb0a:	687b      	ldr	r3, [r7, #4]
 800eb0c:	681b      	ldr	r3, [r3, #0]
 800eb0e:	4a47      	ldr	r2, [pc, #284]	@ (800ec2c <DMA_Init+0x1a4>)
 800eb10:	4293      	cmp	r3, r2
 800eb12:	d07c      	beq.n	800ec0e <DMA_Init+0x186>
 800eb14:	687b      	ldr	r3, [r7, #4]
 800eb16:	681b      	ldr	r3, [r3, #0]
 800eb18:	4a45      	ldr	r2, [pc, #276]	@ (800ec30 <DMA_Init+0x1a8>)
 800eb1a:	4293      	cmp	r3, r2
 800eb1c:	d077      	beq.n	800ec0e <DMA_Init+0x186>
 800eb1e:	687b      	ldr	r3, [r7, #4]
 800eb20:	681b      	ldr	r3, [r3, #0]
 800eb22:	4a44      	ldr	r2, [pc, #272]	@ (800ec34 <DMA_Init+0x1ac>)
 800eb24:	4293      	cmp	r3, r2
 800eb26:	d072      	beq.n	800ec0e <DMA_Init+0x186>
 800eb28:	687b      	ldr	r3, [r7, #4]
 800eb2a:	681b      	ldr	r3, [r3, #0]
 800eb2c:	4a42      	ldr	r2, [pc, #264]	@ (800ec38 <DMA_Init+0x1b0>)
 800eb2e:	4293      	cmp	r3, r2
 800eb30:	d06d      	beq.n	800ec0e <DMA_Init+0x186>
 800eb32:	687b      	ldr	r3, [r7, #4]
 800eb34:	681b      	ldr	r3, [r3, #0]
 800eb36:	4a41      	ldr	r2, [pc, #260]	@ (800ec3c <DMA_Init+0x1b4>)
 800eb38:	4293      	cmp	r3, r2
 800eb3a:	d068      	beq.n	800ec0e <DMA_Init+0x186>
 800eb3c:	687b      	ldr	r3, [r7, #4]
 800eb3e:	681b      	ldr	r3, [r3, #0]
 800eb40:	4a3f      	ldr	r2, [pc, #252]	@ (800ec40 <DMA_Init+0x1b8>)
 800eb42:	4293      	cmp	r3, r2
 800eb44:	d063      	beq.n	800ec0e <DMA_Init+0x186>
 800eb46:	687b      	ldr	r3, [r7, #4]
 800eb48:	681b      	ldr	r3, [r3, #0]
 800eb4a:	4a3e      	ldr	r2, [pc, #248]	@ (800ec44 <DMA_Init+0x1bc>)
 800eb4c:	4293      	cmp	r3, r2
 800eb4e:	d05e      	beq.n	800ec0e <DMA_Init+0x186>
 800eb50:	687b      	ldr	r3, [r7, #4]
 800eb52:	681b      	ldr	r3, [r3, #0]
 800eb54:	4a3c      	ldr	r2, [pc, #240]	@ (800ec48 <DMA_Init+0x1c0>)
 800eb56:	4293      	cmp	r3, r2
 800eb58:	d059      	beq.n	800ec0e <DMA_Init+0x186>
 800eb5a:	687b      	ldr	r3, [r7, #4]
 800eb5c:	681b      	ldr	r3, [r3, #0]
 800eb5e:	4a3b      	ldr	r2, [pc, #236]	@ (800ec4c <DMA_Init+0x1c4>)
 800eb60:	4293      	cmp	r3, r2
 800eb62:	d054      	beq.n	800ec0e <DMA_Init+0x186>
 800eb64:	687b      	ldr	r3, [r7, #4]
 800eb66:	681b      	ldr	r3, [r3, #0]
 800eb68:	4a39      	ldr	r2, [pc, #228]	@ (800ec50 <DMA_Init+0x1c8>)
 800eb6a:	4293      	cmp	r3, r2
 800eb6c:	d04f      	beq.n	800ec0e <DMA_Init+0x186>
 800eb6e:	687b      	ldr	r3, [r7, #4]
 800eb70:	681b      	ldr	r3, [r3, #0]
 800eb72:	4a38      	ldr	r2, [pc, #224]	@ (800ec54 <DMA_Init+0x1cc>)
 800eb74:	4293      	cmp	r3, r2
 800eb76:	d04a      	beq.n	800ec0e <DMA_Init+0x186>
 800eb78:	687b      	ldr	r3, [r7, #4]
 800eb7a:	681b      	ldr	r3, [r3, #0]
 800eb7c:	4a36      	ldr	r2, [pc, #216]	@ (800ec58 <DMA_Init+0x1d0>)
 800eb7e:	4293      	cmp	r3, r2
 800eb80:	d045      	beq.n	800ec0e <DMA_Init+0x186>
 800eb82:	687b      	ldr	r3, [r7, #4]
 800eb84:	681b      	ldr	r3, [r3, #0]
 800eb86:	4a35      	ldr	r2, [pc, #212]	@ (800ec5c <DMA_Init+0x1d4>)
 800eb88:	4293      	cmp	r3, r2
 800eb8a:	d040      	beq.n	800ec0e <DMA_Init+0x186>
 800eb8c:	687b      	ldr	r3, [r7, #4]
 800eb8e:	681b      	ldr	r3, [r3, #0]
 800eb90:	4a33      	ldr	r2, [pc, #204]	@ (800ec60 <DMA_Init+0x1d8>)
 800eb92:	4293      	cmp	r3, r2
 800eb94:	d03b      	beq.n	800ec0e <DMA_Init+0x186>
 800eb96:	687b      	ldr	r3, [r7, #4]
 800eb98:	681b      	ldr	r3, [r3, #0]
 800eb9a:	4a32      	ldr	r2, [pc, #200]	@ (800ec64 <DMA_Init+0x1dc>)
 800eb9c:	4293      	cmp	r3, r2
 800eb9e:	d036      	beq.n	800ec0e <DMA_Init+0x186>
 800eba0:	687b      	ldr	r3, [r7, #4]
 800eba2:	681b      	ldr	r3, [r3, #0]
 800eba4:	4a30      	ldr	r2, [pc, #192]	@ (800ec68 <DMA_Init+0x1e0>)
 800eba6:	4293      	cmp	r3, r2
 800eba8:	d031      	beq.n	800ec0e <DMA_Init+0x186>
 800ebaa:	687b      	ldr	r3, [r7, #4]
 800ebac:	681b      	ldr	r3, [r3, #0]
 800ebae:	4a2f      	ldr	r2, [pc, #188]	@ (800ec6c <DMA_Init+0x1e4>)
 800ebb0:	4293      	cmp	r3, r2
 800ebb2:	d02c      	beq.n	800ec0e <DMA_Init+0x186>
 800ebb4:	687b      	ldr	r3, [r7, #4]
 800ebb6:	681b      	ldr	r3, [r3, #0]
 800ebb8:	4a2d      	ldr	r2, [pc, #180]	@ (800ec70 <DMA_Init+0x1e8>)
 800ebba:	4293      	cmp	r3, r2
 800ebbc:	d027      	beq.n	800ec0e <DMA_Init+0x186>
 800ebbe:	687b      	ldr	r3, [r7, #4]
 800ebc0:	681b      	ldr	r3, [r3, #0]
 800ebc2:	4a2c      	ldr	r2, [pc, #176]	@ (800ec74 <DMA_Init+0x1ec>)
 800ebc4:	4293      	cmp	r3, r2
 800ebc6:	d022      	beq.n	800ec0e <DMA_Init+0x186>
 800ebc8:	687b      	ldr	r3, [r7, #4]
 800ebca:	681b      	ldr	r3, [r3, #0]
 800ebcc:	4a2a      	ldr	r2, [pc, #168]	@ (800ec78 <DMA_Init+0x1f0>)
 800ebce:	4293      	cmp	r3, r2
 800ebd0:	d01d      	beq.n	800ec0e <DMA_Init+0x186>
 800ebd2:	687b      	ldr	r3, [r7, #4]
 800ebd4:	681b      	ldr	r3, [r3, #0]
 800ebd6:	4a29      	ldr	r2, [pc, #164]	@ (800ec7c <DMA_Init+0x1f4>)
 800ebd8:	4293      	cmp	r3, r2
 800ebda:	d018      	beq.n	800ec0e <DMA_Init+0x186>
 800ebdc:	687b      	ldr	r3, [r7, #4]
 800ebde:	681b      	ldr	r3, [r3, #0]
 800ebe0:	4a27      	ldr	r2, [pc, #156]	@ (800ec80 <DMA_Init+0x1f8>)
 800ebe2:	4293      	cmp	r3, r2
 800ebe4:	d013      	beq.n	800ec0e <DMA_Init+0x186>
 800ebe6:	687b      	ldr	r3, [r7, #4]
 800ebe8:	681b      	ldr	r3, [r3, #0]
 800ebea:	4a26      	ldr	r2, [pc, #152]	@ (800ec84 <DMA_Init+0x1fc>)
 800ebec:	4293      	cmp	r3, r2
 800ebee:	d00e      	beq.n	800ec0e <DMA_Init+0x186>
 800ebf0:	687b      	ldr	r3, [r7, #4]
 800ebf2:	681b      	ldr	r3, [r3, #0]
 800ebf4:	4a24      	ldr	r2, [pc, #144]	@ (800ec88 <DMA_Init+0x200>)
 800ebf6:	4293      	cmp	r3, r2
 800ebf8:	d009      	beq.n	800ec0e <DMA_Init+0x186>
 800ebfa:	687b      	ldr	r3, [r7, #4]
 800ebfc:	681b      	ldr	r3, [r3, #0]
 800ebfe:	4a23      	ldr	r2, [pc, #140]	@ (800ec8c <DMA_Init+0x204>)
 800ec00:	4293      	cmp	r3, r2
 800ec02:	d004      	beq.n	800ec0e <DMA_Init+0x186>
 800ec04:	687b      	ldr	r3, [r7, #4]
 800ec06:	681b      	ldr	r3, [r3, #0]
 800ec08:	4a21      	ldr	r2, [pc, #132]	@ (800ec90 <DMA_Init+0x208>)
 800ec0a:	4293      	cmp	r3, r2
 800ec0c:	d142      	bne.n	800ec94 <DMA_Init+0x20c>
 800ec0e:	2301      	movs	r3, #1
 800ec10:	e041      	b.n	800ec96 <DMA_Init+0x20e>
 800ec12:	bf00      	nop
 800ec14:	40020050 	.word	0x40020050
 800ec18:	50020050 	.word	0x50020050
 800ec1c:	400200d0 	.word	0x400200d0
 800ec20:	500200d0 	.word	0x500200d0
 800ec24:	40020150 	.word	0x40020150
 800ec28:	50020150 	.word	0x50020150
 800ec2c:	400201d0 	.word	0x400201d0
 800ec30:	500201d0 	.word	0x500201d0
 800ec34:	40020250 	.word	0x40020250
 800ec38:	50020250 	.word	0x50020250
 800ec3c:	400202d0 	.word	0x400202d0
 800ec40:	500202d0 	.word	0x500202d0
 800ec44:	40020350 	.word	0x40020350
 800ec48:	50020350 	.word	0x50020350
 800ec4c:	400203d0 	.word	0x400203d0
 800ec50:	500203d0 	.word	0x500203d0
 800ec54:	40020450 	.word	0x40020450
 800ec58:	50020450 	.word	0x50020450
 800ec5c:	400204d0 	.word	0x400204d0
 800ec60:	500204d0 	.word	0x500204d0
 800ec64:	40020550 	.word	0x40020550
 800ec68:	50020550 	.word	0x50020550
 800ec6c:	400205d0 	.word	0x400205d0
 800ec70:	500205d0 	.word	0x500205d0
 800ec74:	40020650 	.word	0x40020650
 800ec78:	50020650 	.word	0x50020650
 800ec7c:	400206d0 	.word	0x400206d0
 800ec80:	500206d0 	.word	0x500206d0
 800ec84:	40020750 	.word	0x40020750
 800ec88:	50020750 	.word	0x50020750
 800ec8c:	400207d0 	.word	0x400207d0
 800ec90:	500207d0 	.word	0x500207d0
 800ec94:	2300      	movs	r3, #0
 800ec96:	2b00      	cmp	r3, #0
 800ec98:	d012      	beq.n	800ecc0 <DMA_Init+0x238>
  {
    tmpreg |= (hdma->Init.TransferAllocatedPort                                             |
 800ec9a:	687b      	ldr	r3, [r7, #4]
 800ec9c:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
               (((hdma->Init.DestBurstLength - 1U) << DMA_CTR1_DBL_1_Pos) & DMA_CTR1_DBL_1) |
 800ec9e:	687b      	ldr	r3, [r7, #4]
 800eca0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800eca2:	3b01      	subs	r3, #1
 800eca4:	051b      	lsls	r3, r3, #20
 800eca6:	f003 737c 	and.w	r3, r3, #66060288	@ 0x3f00000
    tmpreg |= (hdma->Init.TransferAllocatedPort                                             |
 800ecaa:	431a      	orrs	r2, r3
               (((hdma->Init.SrcBurstLength - 1U) << DMA_CTR1_SBL_1_Pos) & DMA_CTR1_SBL_1));
 800ecac:	687b      	ldr	r3, [r7, #4]
 800ecae:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800ecb0:	3b01      	subs	r3, #1
 800ecb2:	011b      	lsls	r3, r3, #4
 800ecb4:	f403 737c 	and.w	r3, r3, #1008	@ 0x3f0
               (((hdma->Init.DestBurstLength - 1U) << DMA_CTR1_DBL_1_Pos) & DMA_CTR1_DBL_1) |
 800ecb8:	4313      	orrs	r3, r2
    tmpreg |= (hdma->Init.TransferAllocatedPort                                             |
 800ecba:	68fa      	ldr	r2, [r7, #12]
 800ecbc:	4313      	orrs	r3, r2
 800ecbe:	60fb      	str	r3, [r7, #12]
  }

  /* Write DMA Channel Transfer Register 1 (CTR1) */
  MODIFY_REG(hdma->Instance->CTR1, ~(DMA_CTR1_SSEC | DMA_CTR1_DSEC), tmpreg);
 800ecc0:	687b      	ldr	r3, [r7, #4]
 800ecc2:	681b      	ldr	r3, [r3, #0]
 800ecc4:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800ecc6:	f003 2180 	and.w	r1, r3, #2147516416	@ 0x80008000
 800ecca:	687b      	ldr	r3, [r7, #4]
 800eccc:	681b      	ldr	r3, [r3, #0]
 800ecce:	68fa      	ldr	r2, [r7, #12]
 800ecd0:	430a      	orrs	r2, r1
 800ecd2:	641a      	str	r2, [r3, #64]	@ 0x40

  /* Prepare DMA Channel Transfer Register 2 (CTR2) value *************************************************************/
  tmpreg = hdma->Init.BlkHWRequest | (hdma->Init.Request & DMA_CTR2_REQSEL) | hdma->Init.TransferEventMode;
 800ecd4:	687b      	ldr	r3, [r7, #4]
 800ecd6:	689a      	ldr	r2, [r3, #8]
 800ecd8:	687b      	ldr	r3, [r7, #4]
 800ecda:	685b      	ldr	r3, [r3, #4]
 800ecdc:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 800ece0:	431a      	orrs	r2, r3
 800ece2:	687b      	ldr	r3, [r7, #4]
 800ece4:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800ece6:	4313      	orrs	r3, r2
 800ece8:	60fb      	str	r3, [r7, #12]

  /* Memory to Peripheral Transfer */
  if ((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 800ecea:	687b      	ldr	r3, [r7, #4]
 800ecec:	68db      	ldr	r3, [r3, #12]
 800ecee:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 800ecf2:	f040 80b0 	bne.w	800ee56 <DMA_Init+0x3ce>
  {
    if (IS_GPDMA_INSTANCE(hdma->Instance) != 0U)
 800ecf6:	687b      	ldr	r3, [r7, #4]
 800ecf8:	681b      	ldr	r3, [r3, #0]
 800ecfa:	4a82      	ldr	r2, [pc, #520]	@ (800ef04 <DMA_Init+0x47c>)
 800ecfc:	4293      	cmp	r3, r2
 800ecfe:	f000 80a0 	beq.w	800ee42 <DMA_Init+0x3ba>
 800ed02:	687b      	ldr	r3, [r7, #4]
 800ed04:	681b      	ldr	r3, [r3, #0]
 800ed06:	4a80      	ldr	r2, [pc, #512]	@ (800ef08 <DMA_Init+0x480>)
 800ed08:	4293      	cmp	r3, r2
 800ed0a:	f000 809a 	beq.w	800ee42 <DMA_Init+0x3ba>
 800ed0e:	687b      	ldr	r3, [r7, #4]
 800ed10:	681b      	ldr	r3, [r3, #0]
 800ed12:	4a7e      	ldr	r2, [pc, #504]	@ (800ef0c <DMA_Init+0x484>)
 800ed14:	4293      	cmp	r3, r2
 800ed16:	f000 8094 	beq.w	800ee42 <DMA_Init+0x3ba>
 800ed1a:	687b      	ldr	r3, [r7, #4]
 800ed1c:	681b      	ldr	r3, [r3, #0]
 800ed1e:	4a7c      	ldr	r2, [pc, #496]	@ (800ef10 <DMA_Init+0x488>)
 800ed20:	4293      	cmp	r3, r2
 800ed22:	f000 808e 	beq.w	800ee42 <DMA_Init+0x3ba>
 800ed26:	687b      	ldr	r3, [r7, #4]
 800ed28:	681b      	ldr	r3, [r3, #0]
 800ed2a:	4a7a      	ldr	r2, [pc, #488]	@ (800ef14 <DMA_Init+0x48c>)
 800ed2c:	4293      	cmp	r3, r2
 800ed2e:	f000 8088 	beq.w	800ee42 <DMA_Init+0x3ba>
 800ed32:	687b      	ldr	r3, [r7, #4]
 800ed34:	681b      	ldr	r3, [r3, #0]
 800ed36:	4a78      	ldr	r2, [pc, #480]	@ (800ef18 <DMA_Init+0x490>)
 800ed38:	4293      	cmp	r3, r2
 800ed3a:	f000 8082 	beq.w	800ee42 <DMA_Init+0x3ba>
 800ed3e:	687b      	ldr	r3, [r7, #4]
 800ed40:	681b      	ldr	r3, [r3, #0]
 800ed42:	4a76      	ldr	r2, [pc, #472]	@ (800ef1c <DMA_Init+0x494>)
 800ed44:	4293      	cmp	r3, r2
 800ed46:	d07c      	beq.n	800ee42 <DMA_Init+0x3ba>
 800ed48:	687b      	ldr	r3, [r7, #4]
 800ed4a:	681b      	ldr	r3, [r3, #0]
 800ed4c:	4a74      	ldr	r2, [pc, #464]	@ (800ef20 <DMA_Init+0x498>)
 800ed4e:	4293      	cmp	r3, r2
 800ed50:	d077      	beq.n	800ee42 <DMA_Init+0x3ba>
 800ed52:	687b      	ldr	r3, [r7, #4]
 800ed54:	681b      	ldr	r3, [r3, #0]
 800ed56:	4a73      	ldr	r2, [pc, #460]	@ (800ef24 <DMA_Init+0x49c>)
 800ed58:	4293      	cmp	r3, r2
 800ed5a:	d072      	beq.n	800ee42 <DMA_Init+0x3ba>
 800ed5c:	687b      	ldr	r3, [r7, #4]
 800ed5e:	681b      	ldr	r3, [r3, #0]
 800ed60:	4a71      	ldr	r2, [pc, #452]	@ (800ef28 <DMA_Init+0x4a0>)
 800ed62:	4293      	cmp	r3, r2
 800ed64:	d06d      	beq.n	800ee42 <DMA_Init+0x3ba>
 800ed66:	687b      	ldr	r3, [r7, #4]
 800ed68:	681b      	ldr	r3, [r3, #0]
 800ed6a:	4a70      	ldr	r2, [pc, #448]	@ (800ef2c <DMA_Init+0x4a4>)
 800ed6c:	4293      	cmp	r3, r2
 800ed6e:	d068      	beq.n	800ee42 <DMA_Init+0x3ba>
 800ed70:	687b      	ldr	r3, [r7, #4]
 800ed72:	681b      	ldr	r3, [r3, #0]
 800ed74:	4a6e      	ldr	r2, [pc, #440]	@ (800ef30 <DMA_Init+0x4a8>)
 800ed76:	4293      	cmp	r3, r2
 800ed78:	d063      	beq.n	800ee42 <DMA_Init+0x3ba>
 800ed7a:	687b      	ldr	r3, [r7, #4]
 800ed7c:	681b      	ldr	r3, [r3, #0]
 800ed7e:	4a6d      	ldr	r2, [pc, #436]	@ (800ef34 <DMA_Init+0x4ac>)
 800ed80:	4293      	cmp	r3, r2
 800ed82:	d05e      	beq.n	800ee42 <DMA_Init+0x3ba>
 800ed84:	687b      	ldr	r3, [r7, #4]
 800ed86:	681b      	ldr	r3, [r3, #0]
 800ed88:	4a6b      	ldr	r2, [pc, #428]	@ (800ef38 <DMA_Init+0x4b0>)
 800ed8a:	4293      	cmp	r3, r2
 800ed8c:	d059      	beq.n	800ee42 <DMA_Init+0x3ba>
 800ed8e:	687b      	ldr	r3, [r7, #4]
 800ed90:	681b      	ldr	r3, [r3, #0]
 800ed92:	4a6a      	ldr	r2, [pc, #424]	@ (800ef3c <DMA_Init+0x4b4>)
 800ed94:	4293      	cmp	r3, r2
 800ed96:	d054      	beq.n	800ee42 <DMA_Init+0x3ba>
 800ed98:	687b      	ldr	r3, [r7, #4]
 800ed9a:	681b      	ldr	r3, [r3, #0]
 800ed9c:	4a68      	ldr	r2, [pc, #416]	@ (800ef40 <DMA_Init+0x4b8>)
 800ed9e:	4293      	cmp	r3, r2
 800eda0:	d04f      	beq.n	800ee42 <DMA_Init+0x3ba>
 800eda2:	687b      	ldr	r3, [r7, #4]
 800eda4:	681b      	ldr	r3, [r3, #0]
 800eda6:	4a67      	ldr	r2, [pc, #412]	@ (800ef44 <DMA_Init+0x4bc>)
 800eda8:	4293      	cmp	r3, r2
 800edaa:	d04a      	beq.n	800ee42 <DMA_Init+0x3ba>
 800edac:	687b      	ldr	r3, [r7, #4]
 800edae:	681b      	ldr	r3, [r3, #0]
 800edb0:	4a65      	ldr	r2, [pc, #404]	@ (800ef48 <DMA_Init+0x4c0>)
 800edb2:	4293      	cmp	r3, r2
 800edb4:	d045      	beq.n	800ee42 <DMA_Init+0x3ba>
 800edb6:	687b      	ldr	r3, [r7, #4]
 800edb8:	681b      	ldr	r3, [r3, #0]
 800edba:	4a64      	ldr	r2, [pc, #400]	@ (800ef4c <DMA_Init+0x4c4>)
 800edbc:	4293      	cmp	r3, r2
 800edbe:	d040      	beq.n	800ee42 <DMA_Init+0x3ba>
 800edc0:	687b      	ldr	r3, [r7, #4]
 800edc2:	681b      	ldr	r3, [r3, #0]
 800edc4:	4a62      	ldr	r2, [pc, #392]	@ (800ef50 <DMA_Init+0x4c8>)
 800edc6:	4293      	cmp	r3, r2
 800edc8:	d03b      	beq.n	800ee42 <DMA_Init+0x3ba>
 800edca:	687b      	ldr	r3, [r7, #4]
 800edcc:	681b      	ldr	r3, [r3, #0]
 800edce:	4a61      	ldr	r2, [pc, #388]	@ (800ef54 <DMA_Init+0x4cc>)
 800edd0:	4293      	cmp	r3, r2
 800edd2:	d036      	beq.n	800ee42 <DMA_Init+0x3ba>
 800edd4:	687b      	ldr	r3, [r7, #4]
 800edd6:	681b      	ldr	r3, [r3, #0]
 800edd8:	4a5f      	ldr	r2, [pc, #380]	@ (800ef58 <DMA_Init+0x4d0>)
 800edda:	4293      	cmp	r3, r2
 800eddc:	d031      	beq.n	800ee42 <DMA_Init+0x3ba>
 800edde:	687b      	ldr	r3, [r7, #4]
 800ede0:	681b      	ldr	r3, [r3, #0]
 800ede2:	4a5e      	ldr	r2, [pc, #376]	@ (800ef5c <DMA_Init+0x4d4>)
 800ede4:	4293      	cmp	r3, r2
 800ede6:	d02c      	beq.n	800ee42 <DMA_Init+0x3ba>
 800ede8:	687b      	ldr	r3, [r7, #4]
 800edea:	681b      	ldr	r3, [r3, #0]
 800edec:	4a5c      	ldr	r2, [pc, #368]	@ (800ef60 <DMA_Init+0x4d8>)
 800edee:	4293      	cmp	r3, r2
 800edf0:	d027      	beq.n	800ee42 <DMA_Init+0x3ba>
 800edf2:	687b      	ldr	r3, [r7, #4]
 800edf4:	681b      	ldr	r3, [r3, #0]
 800edf6:	4a5b      	ldr	r2, [pc, #364]	@ (800ef64 <DMA_Init+0x4dc>)
 800edf8:	4293      	cmp	r3, r2
 800edfa:	d022      	beq.n	800ee42 <DMA_Init+0x3ba>
 800edfc:	687b      	ldr	r3, [r7, #4]
 800edfe:	681b      	ldr	r3, [r3, #0]
 800ee00:	4a59      	ldr	r2, [pc, #356]	@ (800ef68 <DMA_Init+0x4e0>)
 800ee02:	4293      	cmp	r3, r2
 800ee04:	d01d      	beq.n	800ee42 <DMA_Init+0x3ba>
 800ee06:	687b      	ldr	r3, [r7, #4]
 800ee08:	681b      	ldr	r3, [r3, #0]
 800ee0a:	4a58      	ldr	r2, [pc, #352]	@ (800ef6c <DMA_Init+0x4e4>)
 800ee0c:	4293      	cmp	r3, r2
 800ee0e:	d018      	beq.n	800ee42 <DMA_Init+0x3ba>
 800ee10:	687b      	ldr	r3, [r7, #4]
 800ee12:	681b      	ldr	r3, [r3, #0]
 800ee14:	4a56      	ldr	r2, [pc, #344]	@ (800ef70 <DMA_Init+0x4e8>)
 800ee16:	4293      	cmp	r3, r2
 800ee18:	d013      	beq.n	800ee42 <DMA_Init+0x3ba>
 800ee1a:	687b      	ldr	r3, [r7, #4]
 800ee1c:	681b      	ldr	r3, [r3, #0]
 800ee1e:	4a55      	ldr	r2, [pc, #340]	@ (800ef74 <DMA_Init+0x4ec>)
 800ee20:	4293      	cmp	r3, r2
 800ee22:	d00e      	beq.n	800ee42 <DMA_Init+0x3ba>
 800ee24:	687b      	ldr	r3, [r7, #4]
 800ee26:	681b      	ldr	r3, [r3, #0]
 800ee28:	4a53      	ldr	r2, [pc, #332]	@ (800ef78 <DMA_Init+0x4f0>)
 800ee2a:	4293      	cmp	r3, r2
 800ee2c:	d009      	beq.n	800ee42 <DMA_Init+0x3ba>
 800ee2e:	687b      	ldr	r3, [r7, #4]
 800ee30:	681b      	ldr	r3, [r3, #0]
 800ee32:	4a52      	ldr	r2, [pc, #328]	@ (800ef7c <DMA_Init+0x4f4>)
 800ee34:	4293      	cmp	r3, r2
 800ee36:	d004      	beq.n	800ee42 <DMA_Init+0x3ba>
 800ee38:	687b      	ldr	r3, [r7, #4]
 800ee3a:	681b      	ldr	r3, [r3, #0]
 800ee3c:	4a50      	ldr	r2, [pc, #320]	@ (800ef80 <DMA_Init+0x4f8>)
 800ee3e:	4293      	cmp	r3, r2
 800ee40:	d101      	bne.n	800ee46 <DMA_Init+0x3be>
 800ee42:	2301      	movs	r3, #1
 800ee44:	e000      	b.n	800ee48 <DMA_Init+0x3c0>
 800ee46:	2300      	movs	r3, #0
 800ee48:	2b00      	cmp	r3, #0
 800ee4a:	d00d      	beq.n	800ee68 <DMA_Init+0x3e0>
    {
      tmpreg |= DMA_CTR2_DREQ;
 800ee4c:	68fb      	ldr	r3, [r7, #12]
 800ee4e:	f443 6380 	orr.w	r3, r3, #1024	@ 0x400
 800ee52:	60fb      	str	r3, [r7, #12]
 800ee54:	e008      	b.n	800ee68 <DMA_Init+0x3e0>
    }
  }
  /* Memory to Memory Transfer */
  else if ((hdma->Init.Direction) == DMA_MEMORY_TO_MEMORY)
 800ee56:	687b      	ldr	r3, [r7, #4]
 800ee58:	68db      	ldr	r3, [r3, #12]
 800ee5a:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 800ee5e:	d103      	bne.n	800ee68 <DMA_Init+0x3e0>
  {
    tmpreg |= DMA_CTR2_SWREQ;
 800ee60:	68fb      	ldr	r3, [r7, #12]
 800ee62:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
 800ee66:	60fb      	str	r3, [r7, #12]
  {
    /* Nothing to do */
  }

  /* Write DMA Channel Transfer Register 2 (CTR2) */
  MODIFY_REG(hdma->Instance->CTR2, (DMA_CTR2_TCEM  | DMA_CTR2_TRIGPOL | DMA_CTR2_TRIGSEL | DMA_CTR2_TRIGM |
 800ee68:	687b      	ldr	r3, [r7, #4]
 800ee6a:	681b      	ldr	r3, [r3, #0]
 800ee6c:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 800ee6e:	4b45      	ldr	r3, [pc, #276]	@ (800ef84 <DMA_Init+0x4fc>)
 800ee70:	4013      	ands	r3, r2
 800ee72:	687a      	ldr	r2, [r7, #4]
 800ee74:	6812      	ldr	r2, [r2, #0]
 800ee76:	68f9      	ldr	r1, [r7, #12]
 800ee78:	430b      	orrs	r3, r1
 800ee7a:	6453      	str	r3, [r2, #68]	@ 0x44
                                    DMA_CTR2_BREQ  | DMA_CTR2_DREQ    | DMA_CTR2_SWREQ   | DMA_CTR2_REQSEL), tmpreg);


  /* Write DMA Channel Block Register 1 (CBR1) ************************************************************************/
  WRITE_REG(hdma->Instance->CBR1, 0U);
 800ee7c:	687b      	ldr	r3, [r7, #4]
 800ee7e:	681b      	ldr	r3, [r3, #0]
 800ee80:	2200      	movs	r2, #0
 800ee82:	649a      	str	r2, [r3, #72]	@ 0x48

  /* If 2D Addressing is supported by current channel */
  if (IS_DMA_2D_ADDRESSING_INSTANCE(hdma->Instance) != 0U)
 800ee84:	687b      	ldr	r3, [r7, #4]
 800ee86:	681b      	ldr	r3, [r3, #0]
 800ee88:	4a36      	ldr	r2, [pc, #216]	@ (800ef64 <DMA_Init+0x4dc>)
 800ee8a:	4293      	cmp	r3, r2
 800ee8c:	d022      	beq.n	800eed4 <DMA_Init+0x44c>
 800ee8e:	687b      	ldr	r3, [r7, #4]
 800ee90:	681b      	ldr	r3, [r3, #0]
 800ee92:	4a35      	ldr	r2, [pc, #212]	@ (800ef68 <DMA_Init+0x4e0>)
 800ee94:	4293      	cmp	r3, r2
 800ee96:	d01d      	beq.n	800eed4 <DMA_Init+0x44c>
 800ee98:	687b      	ldr	r3, [r7, #4]
 800ee9a:	681b      	ldr	r3, [r3, #0]
 800ee9c:	4a33      	ldr	r2, [pc, #204]	@ (800ef6c <DMA_Init+0x4e4>)
 800ee9e:	4293      	cmp	r3, r2
 800eea0:	d018      	beq.n	800eed4 <DMA_Init+0x44c>
 800eea2:	687b      	ldr	r3, [r7, #4]
 800eea4:	681b      	ldr	r3, [r3, #0]
 800eea6:	4a32      	ldr	r2, [pc, #200]	@ (800ef70 <DMA_Init+0x4e8>)
 800eea8:	4293      	cmp	r3, r2
 800eeaa:	d013      	beq.n	800eed4 <DMA_Init+0x44c>
 800eeac:	687b      	ldr	r3, [r7, #4]
 800eeae:	681b      	ldr	r3, [r3, #0]
 800eeb0:	4a30      	ldr	r2, [pc, #192]	@ (800ef74 <DMA_Init+0x4ec>)
 800eeb2:	4293      	cmp	r3, r2
 800eeb4:	d00e      	beq.n	800eed4 <DMA_Init+0x44c>
 800eeb6:	687b      	ldr	r3, [r7, #4]
 800eeb8:	681b      	ldr	r3, [r3, #0]
 800eeba:	4a2f      	ldr	r2, [pc, #188]	@ (800ef78 <DMA_Init+0x4f0>)
 800eebc:	4293      	cmp	r3, r2
 800eebe:	d009      	beq.n	800eed4 <DMA_Init+0x44c>
 800eec0:	687b      	ldr	r3, [r7, #4]
 800eec2:	681b      	ldr	r3, [r3, #0]
 800eec4:	4a2d      	ldr	r2, [pc, #180]	@ (800ef7c <DMA_Init+0x4f4>)
 800eec6:	4293      	cmp	r3, r2
 800eec8:	d004      	beq.n	800eed4 <DMA_Init+0x44c>
 800eeca:	687b      	ldr	r3, [r7, #4]
 800eecc:	681b      	ldr	r3, [r3, #0]
 800eece:	4a2c      	ldr	r2, [pc, #176]	@ (800ef80 <DMA_Init+0x4f8>)
 800eed0:	4293      	cmp	r3, r2
 800eed2:	d101      	bne.n	800eed8 <DMA_Init+0x450>
 800eed4:	2301      	movs	r3, #1
 800eed6:	e000      	b.n	800eeda <DMA_Init+0x452>
 800eed8:	2300      	movs	r3, #0
 800eeda:	2b00      	cmp	r3, #0
 800eedc:	d007      	beq.n	800eeee <DMA_Init+0x466>
  {
    /* Write DMA Channel Transfer Register 3 (CTR3) *******************************************************************/
    WRITE_REG(hdma->Instance->CTR3, 0U);
 800eede:	687b      	ldr	r3, [r7, #4]
 800eee0:	681b      	ldr	r3, [r3, #0]
 800eee2:	2200      	movs	r2, #0
 800eee4:	655a      	str	r2, [r3, #84]	@ 0x54

    /* Write DMA Channel Block Register 2 (CBR2) **********************************************************************/
    WRITE_REG(hdma->Instance->CBR2, 0U);
 800eee6:	687b      	ldr	r3, [r7, #4]
 800eee8:	681b      	ldr	r3, [r3, #0]
 800eeea:	2200      	movs	r2, #0
 800eeec:	659a      	str	r2, [r3, #88]	@ 0x58
  }

  /* Write DMA Channel linked-list address register (CLLR) ************************************************************/
  WRITE_REG(hdma->Instance->CLLR, 0U);
 800eeee:	687b      	ldr	r3, [r7, #4]
 800eef0:	681b      	ldr	r3, [r3, #0]
 800eef2:	2200      	movs	r2, #0
 800eef4:	67da      	str	r2, [r3, #124]	@ 0x7c
}
 800eef6:	bf00      	nop
 800eef8:	3714      	adds	r7, #20
 800eefa:	46bd      	mov	sp, r7
 800eefc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ef00:	4770      	bx	lr
 800ef02:	bf00      	nop
 800ef04:	40020050 	.word	0x40020050
 800ef08:	50020050 	.word	0x50020050
 800ef0c:	400200d0 	.word	0x400200d0
 800ef10:	500200d0 	.word	0x500200d0
 800ef14:	40020150 	.word	0x40020150
 800ef18:	50020150 	.word	0x50020150
 800ef1c:	400201d0 	.word	0x400201d0
 800ef20:	500201d0 	.word	0x500201d0
 800ef24:	40020250 	.word	0x40020250
 800ef28:	50020250 	.word	0x50020250
 800ef2c:	400202d0 	.word	0x400202d0
 800ef30:	500202d0 	.word	0x500202d0
 800ef34:	40020350 	.word	0x40020350
 800ef38:	50020350 	.word	0x50020350
 800ef3c:	400203d0 	.word	0x400203d0
 800ef40:	500203d0 	.word	0x500203d0
 800ef44:	40020450 	.word	0x40020450
 800ef48:	50020450 	.word	0x50020450
 800ef4c:	400204d0 	.word	0x400204d0
 800ef50:	500204d0 	.word	0x500204d0
 800ef54:	40020550 	.word	0x40020550
 800ef58:	50020550 	.word	0x50020550
 800ef5c:	400205d0 	.word	0x400205d0
 800ef60:	500205d0 	.word	0x500205d0
 800ef64:	40020650 	.word	0x40020650
 800ef68:	50020650 	.word	0x50020650
 800ef6c:	400206d0 	.word	0x400206d0
 800ef70:	500206d0 	.word	0x500206d0
 800ef74:	40020750 	.word	0x40020750
 800ef78:	50020750 	.word	0x50020750
 800ef7c:	400207d0 	.word	0x400207d0
 800ef80:	500207d0 	.word	0x500207d0
 800ef84:	3cc03180 	.word	0x3cc03180

0800ef88 <HAL_DMAEx_GetFifoLevel>:
  * @param  hdma : Pointer to a DMA_HandleTypeDef structure that contains the configuration information for the
  *                specified DMA Channel.
  * @retval Returns the number of available beats in FIFO.
  */
uint32_t HAL_DMAEx_GetFifoLevel(DMA_HandleTypeDef const *const hdma)
{
 800ef88:	b480      	push	{r7}
 800ef8a:	b083      	sub	sp, #12
 800ef8c:	af00      	add	r7, sp, #0
 800ef8e:	6078      	str	r0, [r7, #4]
  return ((hdma->Instance->CSR & DMA_CSR_FIFOL) >> DMA_CSR_FIFOL_Pos);
 800ef90:	687b      	ldr	r3, [r7, #4]
 800ef92:	681b      	ldr	r3, [r3, #0]
 800ef94:	691b      	ldr	r3, [r3, #16]
 800ef96:	0c1b      	lsrs	r3, r3, #16
 800ef98:	b2db      	uxtb	r3, r3
}
 800ef9a:	4618      	mov	r0, r3
 800ef9c:	370c      	adds	r7, #12
 800ef9e:	46bd      	mov	sp, r7
 800efa0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800efa4:	4770      	bx	lr

0800efa6 <HAL_EXTI_RegisterCallback>:
  * @param  pPendingCbfn function pointer to be stored as callback.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_RegisterCallback(EXTI_HandleTypeDef *hexti, EXTI_CallbackIDTypeDef CallbackID,
                                            void (*pPendingCbfn)(void))
{
 800efa6:	b480      	push	{r7}
 800efa8:	b087      	sub	sp, #28
 800efaa:	af00      	add	r7, sp, #0
 800efac:	60f8      	str	r0, [r7, #12]
 800efae:	460b      	mov	r3, r1
 800efb0:	607a      	str	r2, [r7, #4]
 800efb2:	72fb      	strb	r3, [r7, #11]
  HAL_StatusTypeDef status = HAL_OK;
 800efb4:	2300      	movs	r3, #0
 800efb6:	75fb      	strb	r3, [r7, #23]

  switch (CallbackID)
 800efb8:	7afb      	ldrb	r3, [r7, #11]
 800efba:	2b02      	cmp	r3, #2
 800efbc:	d011      	beq.n	800efe2 <HAL_EXTI_RegisterCallback+0x3c>
 800efbe:	2b02      	cmp	r3, #2
 800efc0:	dc13      	bgt.n	800efea <HAL_EXTI_RegisterCallback+0x44>
 800efc2:	2b00      	cmp	r3, #0
 800efc4:	d002      	beq.n	800efcc <HAL_EXTI_RegisterCallback+0x26>
 800efc6:	2b01      	cmp	r3, #1
 800efc8:	d007      	beq.n	800efda <HAL_EXTI_RegisterCallback+0x34>
 800efca:	e00e      	b.n	800efea <HAL_EXTI_RegisterCallback+0x44>
  {
    case  HAL_EXTI_COMMON_CB_ID:
      hexti->RisingCallback = pPendingCbfn;
 800efcc:	68fb      	ldr	r3, [r7, #12]
 800efce:	687a      	ldr	r2, [r7, #4]
 800efd0:	605a      	str	r2, [r3, #4]
      hexti->FallingCallback = pPendingCbfn;
 800efd2:	68fb      	ldr	r3, [r7, #12]
 800efd4:	687a      	ldr	r2, [r7, #4]
 800efd6:	609a      	str	r2, [r3, #8]
      break;
 800efd8:	e00a      	b.n	800eff0 <HAL_EXTI_RegisterCallback+0x4a>

    case  HAL_EXTI_RISING_CB_ID:
      hexti->RisingCallback = pPendingCbfn;
 800efda:	68fb      	ldr	r3, [r7, #12]
 800efdc:	687a      	ldr	r2, [r7, #4]
 800efde:	605a      	str	r2, [r3, #4]
      break;
 800efe0:	e006      	b.n	800eff0 <HAL_EXTI_RegisterCallback+0x4a>

    case  HAL_EXTI_FALLING_CB_ID:
      hexti->FallingCallback = pPendingCbfn;
 800efe2:	68fb      	ldr	r3, [r7, #12]
 800efe4:	687a      	ldr	r2, [r7, #4]
 800efe6:	609a      	str	r2, [r3, #8]
      break;
 800efe8:	e002      	b.n	800eff0 <HAL_EXTI_RegisterCallback+0x4a>

    default:
      status = HAL_ERROR;
 800efea:	2301      	movs	r3, #1
 800efec:	75fb      	strb	r3, [r7, #23]
      break;
 800efee:	bf00      	nop
  }

  return status;
 800eff0:	7dfb      	ldrb	r3, [r7, #23]
}
 800eff2:	4618      	mov	r0, r3
 800eff4:	371c      	adds	r7, #28
 800eff6:	46bd      	mov	sp, r7
 800eff8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800effc:	4770      	bx	lr

0800effe <HAL_EXTI_GetHandle>:
  * @param  ExtiLine Exti line number.
  *         This parameter can be from 0 to @ref EXTI_LINE_NB.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_GetHandle(EXTI_HandleTypeDef *hexti, uint32_t ExtiLine)
{
 800effe:	b480      	push	{r7}
 800f000:	b083      	sub	sp, #12
 800f002:	af00      	add	r7, sp, #0
 800f004:	6078      	str	r0, [r7, #4]
 800f006:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(ExtiLine));

  /* Check null pointer */
  if (hexti == NULL)
 800f008:	687b      	ldr	r3, [r7, #4]
 800f00a:	2b00      	cmp	r3, #0
 800f00c:	d101      	bne.n	800f012 <HAL_EXTI_GetHandle+0x14>
  {
    return HAL_ERROR;
 800f00e:	2301      	movs	r3, #1
 800f010:	e003      	b.n	800f01a <HAL_EXTI_GetHandle+0x1c>
  }
  else
  {
    /* Store line number as handle private field */
    hexti->Line = ExtiLine;
 800f012:	687b      	ldr	r3, [r7, #4]
 800f014:	683a      	ldr	r2, [r7, #0]
 800f016:	601a      	str	r2, [r3, #0]

    return HAL_OK;
 800f018:	2300      	movs	r3, #0
  }
}
 800f01a:	4618      	mov	r0, r3
 800f01c:	370c      	adds	r7, #12
 800f01e:	46bd      	mov	sp, r7
 800f020:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f024:	4770      	bx	lr
	...

0800f028 <HAL_EXTI_IRQHandler>:
  * @brief  Handle EXTI interrupt request.
  * @param  hexti Exti handle.
  * @retval none.
  */
void HAL_EXTI_IRQHandler(const EXTI_HandleTypeDef *hexti)
{
 800f028:	b580      	push	{r7, lr}
 800f02a:	b086      	sub	sp, #24
 800f02c:	af00      	add	r7, sp, #0
 800f02e:	6078      	str	r0, [r7, #4]
  uint32_t regval;
  uint32_t maskline;
  uint32_t offset;

  /* Compute line register offset and line mask */
  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
 800f030:	687b      	ldr	r3, [r7, #4]
 800f032:	681b      	ldr	r3, [r3, #0]
 800f034:	0c1b      	lsrs	r3, r3, #16
 800f036:	f003 0301 	and.w	r3, r3, #1
 800f03a:	617b      	str	r3, [r7, #20]
  maskline = (1UL << (hexti->Line & EXTI_PIN_MASK));
 800f03c:	687b      	ldr	r3, [r7, #4]
 800f03e:	681b      	ldr	r3, [r3, #0]
 800f040:	f003 031f 	and.w	r3, r3, #31
 800f044:	2201      	movs	r2, #1
 800f046:	fa02 f303 	lsl.w	r3, r2, r3
 800f04a:	613b      	str	r3, [r7, #16]

  /* Get rising edge pending bit  */
  regaddr = (__IO uint32_t *)(&EXTI->RPR1 + (EXTI_CONFIG_OFFSET * offset));
 800f04c:	697b      	ldr	r3, [r7, #20]
 800f04e:	015a      	lsls	r2, r3, #5
 800f050:	4b17      	ldr	r3, [pc, #92]	@ (800f0b0 <HAL_EXTI_IRQHandler+0x88>)
 800f052:	4413      	add	r3, r2
 800f054:	60fb      	str	r3, [r7, #12]
  regval = (*regaddr & maskline);
 800f056:	68fb      	ldr	r3, [r7, #12]
 800f058:	681b      	ldr	r3, [r3, #0]
 800f05a:	693a      	ldr	r2, [r7, #16]
 800f05c:	4013      	ands	r3, r2
 800f05e:	60bb      	str	r3, [r7, #8]

  if (regval != 0U)
 800f060:	68bb      	ldr	r3, [r7, #8]
 800f062:	2b00      	cmp	r3, #0
 800f064:	d009      	beq.n	800f07a <HAL_EXTI_IRQHandler+0x52>
  {
    /* Clear pending bit */
    *regaddr = maskline;
 800f066:	68fb      	ldr	r3, [r7, #12]
 800f068:	693a      	ldr	r2, [r7, #16]
 800f06a:	601a      	str	r2, [r3, #0]

    /* Call rising callback */
    if (hexti->RisingCallback != NULL)
 800f06c:	687b      	ldr	r3, [r7, #4]
 800f06e:	685b      	ldr	r3, [r3, #4]
 800f070:	2b00      	cmp	r3, #0
 800f072:	d002      	beq.n	800f07a <HAL_EXTI_IRQHandler+0x52>
    {
      hexti->RisingCallback();
 800f074:	687b      	ldr	r3, [r7, #4]
 800f076:	685b      	ldr	r3, [r3, #4]
 800f078:	4798      	blx	r3
    }
  }

  /* Get falling edge pending bit  */
  regaddr = (__IO uint32_t *)(&EXTI->FPR1 + (EXTI_CONFIG_OFFSET * offset));
 800f07a:	697b      	ldr	r3, [r7, #20]
 800f07c:	015a      	lsls	r2, r3, #5
 800f07e:	4b0d      	ldr	r3, [pc, #52]	@ (800f0b4 <HAL_EXTI_IRQHandler+0x8c>)
 800f080:	4413      	add	r3, r2
 800f082:	60fb      	str	r3, [r7, #12]
  regval = (*regaddr & maskline);
 800f084:	68fb      	ldr	r3, [r7, #12]
 800f086:	681b      	ldr	r3, [r3, #0]
 800f088:	693a      	ldr	r2, [r7, #16]
 800f08a:	4013      	ands	r3, r2
 800f08c:	60bb      	str	r3, [r7, #8]

  if (regval != 0U)
 800f08e:	68bb      	ldr	r3, [r7, #8]
 800f090:	2b00      	cmp	r3, #0
 800f092:	d009      	beq.n	800f0a8 <HAL_EXTI_IRQHandler+0x80>
  {
    /* Clear pending bit */
    *regaddr = maskline;
 800f094:	68fb      	ldr	r3, [r7, #12]
 800f096:	693a      	ldr	r2, [r7, #16]
 800f098:	601a      	str	r2, [r3, #0]

    /* Call rising callback */
    if (hexti->FallingCallback != NULL)
 800f09a:	687b      	ldr	r3, [r7, #4]
 800f09c:	689b      	ldr	r3, [r3, #8]
 800f09e:	2b00      	cmp	r3, #0
 800f0a0:	d002      	beq.n	800f0a8 <HAL_EXTI_IRQHandler+0x80>
    {
      hexti->FallingCallback();
 800f0a2:	687b      	ldr	r3, [r7, #4]
 800f0a4:	689b      	ldr	r3, [r3, #8]
 800f0a6:	4798      	blx	r3
    }
  }
}
 800f0a8:	bf00      	nop
 800f0aa:	3718      	adds	r7, #24
 800f0ac:	46bd      	mov	sp, r7
 800f0ae:	bd80      	pop	{r7, pc}
 800f0b0:	4602200c 	.word	0x4602200c
 800f0b4:	46022010 	.word	0x46022010

0800f0b8 <HAL_FLASH_Program>:
  *         This parameter shall be 32-bit aligned
  *
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Program(uint32_t TypeProgram, uint32_t Address, uint32_t DataAddress)
{
 800f0b8:	b580      	push	{r7, lr}
 800f0ba:	b086      	sub	sp, #24
 800f0bc:	af00      	add	r7, sp, #0
 800f0be:	60f8      	str	r0, [r7, #12]
 800f0c0:	60b9      	str	r1, [r7, #8]
 800f0c2:	607a      	str	r2, [r7, #4]

  /* Check the parameters */
  assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));

  /* Process Locked */
  __HAL_LOCK(&pFlash);
 800f0c4:	4b1f      	ldr	r3, [pc, #124]	@ (800f144 <HAL_FLASH_Program+0x8c>)
 800f0c6:	781b      	ldrb	r3, [r3, #0]
 800f0c8:	2b01      	cmp	r3, #1
 800f0ca:	d101      	bne.n	800f0d0 <HAL_FLASH_Program+0x18>
 800f0cc:	2302      	movs	r3, #2
 800f0ce:	e034      	b.n	800f13a <HAL_FLASH_Program+0x82>
 800f0d0:	4b1c      	ldr	r3, [pc, #112]	@ (800f144 <HAL_FLASH_Program+0x8c>)
 800f0d2:	2201      	movs	r2, #1
 800f0d4:	701a      	strb	r2, [r3, #0]

  /* Reset error code */
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 800f0d6:	4b1b      	ldr	r3, [pc, #108]	@ (800f144 <HAL_FLASH_Program+0x8c>)
 800f0d8:	2200      	movs	r2, #0
 800f0da:	605a      	str	r2, [r3, #4]

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 800f0dc:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
 800f0e0:	f000 f8aa 	bl	800f238 <FLASH_WaitForLastOperation>
 800f0e4:	4603      	mov	r3, r0
 800f0e6:	75fb      	strb	r3, [r7, #23]

  if (status == HAL_OK)
 800f0e8:	7dfb      	ldrb	r3, [r7, #23]
 800f0ea:	2b00      	cmp	r3, #0
 800f0ec:	d121      	bne.n	800f132 <HAL_FLASH_Program+0x7a>
  {
    /* Set current operation type */
    pFlash.ProcedureOnGoing = TypeProgram;
 800f0ee:	4a15      	ldr	r2, [pc, #84]	@ (800f144 <HAL_FLASH_Program+0x8c>)
 800f0f0:	68fb      	ldr	r3, [r7, #12]
 800f0f2:	6093      	str	r3, [r2, #8]

    /* Access to SECCR or NSCR depends on operation type */
    reg_cr = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH_NS->NSCR);
 800f0f4:	4b14      	ldr	r3, [pc, #80]	@ (800f148 <HAL_FLASH_Program+0x90>)
 800f0f6:	613b      	str	r3, [r7, #16]

    if ((TypeProgram & (~FLASH_NON_SECURE_MASK)) == FLASH_TYPEPROGRAM_QUADWORD)
 800f0f8:	68fb      	ldr	r3, [r7, #12]
 800f0fa:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 800f0fe:	2b01      	cmp	r3, #1
 800f100:	d104      	bne.n	800f10c <HAL_FLASH_Program+0x54>
    {
      /* Program a quad-word (128-bit) at a specified address */
      FLASH_Program_QuadWord(Address, DataAddress);
 800f102:	6879      	ldr	r1, [r7, #4]
 800f104:	68b8      	ldr	r0, [r7, #8]
 800f106:	f000 f8dd 	bl	800f2c4 <FLASH_Program_QuadWord>
 800f10a:	e003      	b.n	800f114 <HAL_FLASH_Program+0x5c>
    }
    else
    {
      /* Program a burst of 8 quad-words at a specified address */
      FLASH_Program_Burst(Address, DataAddress);
 800f10c:	6879      	ldr	r1, [r7, #4]
 800f10e:	68b8      	ldr	r0, [r7, #8]
 800f110:	f000 f914 	bl	800f33c <FLASH_Program_Burst>
    }

    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 800f114:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
 800f118:	f000 f88e 	bl	800f238 <FLASH_WaitForLastOperation>
 800f11c:	4603      	mov	r3, r0
 800f11e:	75fb      	strb	r3, [r7, #23]

    /* If the program operation is completed, disable the PG (and BWR Bit in Burst programming mode) */
    CLEAR_BIT((*reg_cr), (TypeProgram & ~(FLASH_NON_SECURE_MASK)));
 800f120:	693b      	ldr	r3, [r7, #16]
 800f122:	681a      	ldr	r2, [r3, #0]
 800f124:	68fb      	ldr	r3, [r7, #12]
 800f126:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 800f12a:	43db      	mvns	r3, r3
 800f12c:	401a      	ands	r2, r3
 800f12e:	693b      	ldr	r3, [r7, #16]
 800f130:	601a      	str	r2, [r3, #0]
  }

  /* Process Unlocked */
  __HAL_UNLOCK(&pFlash);
 800f132:	4b04      	ldr	r3, [pc, #16]	@ (800f144 <HAL_FLASH_Program+0x8c>)
 800f134:	2200      	movs	r2, #0
 800f136:	701a      	strb	r2, [r3, #0]

  /* return status */
  return status;
 800f138:	7dfb      	ldrb	r3, [r7, #23]
}
 800f13a:	4618      	mov	r0, r3
 800f13c:	3718      	adds	r7, #24
 800f13e:	46bd      	mov	sp, r7
 800f140:	bd80      	pop	{r7, pc}
 800f142:	bf00      	nop
 800f144:	200001ec 	.word	0x200001ec
 800f148:	40022028 	.word	0x40022028

0800f14c <HAL_FLASH_Unlock>:
/**
  * @brief  Unlock the FLASH control register access.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Unlock(void)
{
 800f14c:	b480      	push	{r7}
 800f14e:	b083      	sub	sp, #12
 800f150:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef status = HAL_OK;
 800f152:	2300      	movs	r3, #0
 800f154:	71fb      	strb	r3, [r7, #7]

  if (READ_BIT(FLASH->NSCR, FLASH_NSCR_LOCK) != 0U)
 800f156:	4b0b      	ldr	r3, [pc, #44]	@ (800f184 <HAL_FLASH_Unlock+0x38>)
 800f158:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800f15a:	2b00      	cmp	r3, #0
 800f15c:	da0b      	bge.n	800f176 <HAL_FLASH_Unlock+0x2a>
  {
    /* Authorize the FLASH Registers access */
    WRITE_REG(FLASH->NSKEYR, FLASH_KEY1);
 800f15e:	4b09      	ldr	r3, [pc, #36]	@ (800f184 <HAL_FLASH_Unlock+0x38>)
 800f160:	4a09      	ldr	r2, [pc, #36]	@ (800f188 <HAL_FLASH_Unlock+0x3c>)
 800f162:	609a      	str	r2, [r3, #8]
    WRITE_REG(FLASH->NSKEYR, FLASH_KEY2);
 800f164:	4b07      	ldr	r3, [pc, #28]	@ (800f184 <HAL_FLASH_Unlock+0x38>)
 800f166:	4a09      	ldr	r2, [pc, #36]	@ (800f18c <HAL_FLASH_Unlock+0x40>)
 800f168:	609a      	str	r2, [r3, #8]

    /* verify Flash is unlocked */
    if (READ_BIT(FLASH->NSCR, FLASH_NSCR_LOCK) != 0U)
 800f16a:	4b06      	ldr	r3, [pc, #24]	@ (800f184 <HAL_FLASH_Unlock+0x38>)
 800f16c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800f16e:	2b00      	cmp	r3, #0
 800f170:	da01      	bge.n	800f176 <HAL_FLASH_Unlock+0x2a>
    {
      status = HAL_ERROR;
 800f172:	2301      	movs	r3, #1
 800f174:	71fb      	strb	r3, [r7, #7]
      }
    }
  }
#endif /* __ARM_FEATURE_CMSE */

  return status;
 800f176:	79fb      	ldrb	r3, [r7, #7]
}
 800f178:	4618      	mov	r0, r3
 800f17a:	370c      	adds	r7, #12
 800f17c:	46bd      	mov	sp, r7
 800f17e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f182:	4770      	bx	lr
 800f184:	40022000 	.word	0x40022000
 800f188:	45670123 	.word	0x45670123
 800f18c:	cdef89ab 	.word	0xcdef89ab

0800f190 <HAL_FLASH_Lock>:
/**
  * @brief  Lock the FLASH control register access.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Lock(void)
{
 800f190:	b480      	push	{r7}
 800f192:	b083      	sub	sp, #12
 800f194:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef status = HAL_ERROR;
 800f196:	2301      	movs	r3, #1
 800f198:	71fb      	strb	r3, [r7, #7]

  /* Set the LOCK Bit to lock the FLASH Registers access */
  SET_BIT(FLASH->NSCR, FLASH_NSCR_LOCK);
 800f19a:	4b09      	ldr	r3, [pc, #36]	@ (800f1c0 <HAL_FLASH_Lock+0x30>)
 800f19c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800f19e:	4a08      	ldr	r2, [pc, #32]	@ (800f1c0 <HAL_FLASH_Lock+0x30>)
 800f1a0:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 800f1a4:	6293      	str	r3, [r2, #40]	@ 0x28

  /* verify Flash is locked */
  if (READ_BIT(FLASH->NSCR, FLASH_NSCR_LOCK) != 0U)
 800f1a6:	4b06      	ldr	r3, [pc, #24]	@ (800f1c0 <HAL_FLASH_Lock+0x30>)
 800f1a8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800f1aa:	2b00      	cmp	r3, #0
 800f1ac:	da01      	bge.n	800f1b2 <HAL_FLASH_Lock+0x22>
  {
    status = HAL_OK;
 800f1ae:	2300      	movs	r3, #0
 800f1b0:	71fb      	strb	r3, [r7, #7]
      status = HAL_OK;
    }
  }
#endif /* __ARM_FEATURE_CMSE */

  return status;
 800f1b2:	79fb      	ldrb	r3, [r7, #7]
}
 800f1b4:	4618      	mov	r0, r3
 800f1b6:	370c      	adds	r7, #12
 800f1b8:	46bd      	mov	sp, r7
 800f1ba:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f1be:	4770      	bx	lr
 800f1c0:	40022000 	.word	0x40022000

0800f1c4 <HAL_FLASH_OB_Unlock>:
/**
  * @brief  Unlock the FLASH Option Bytes Registers access.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_OB_Unlock(void)
{
 800f1c4:	b480      	push	{r7}
 800f1c6:	af00      	add	r7, sp, #0
  if (READ_BIT(FLASH->NSCR, FLASH_NSCR_OPTLOCK) != 0U)
 800f1c8:	4b0c      	ldr	r3, [pc, #48]	@ (800f1fc <HAL_FLASH_OB_Unlock+0x38>)
 800f1ca:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800f1cc:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
 800f1d0:	2b00      	cmp	r3, #0
 800f1d2:	d00d      	beq.n	800f1f0 <HAL_FLASH_OB_Unlock+0x2c>
  {
    /* Authorizes the Option Byte register programming */
    WRITE_REG(FLASH->OPTKEYR, FLASH_OPTKEY1);
 800f1d4:	4b09      	ldr	r3, [pc, #36]	@ (800f1fc <HAL_FLASH_OB_Unlock+0x38>)
 800f1d6:	4a0a      	ldr	r2, [pc, #40]	@ (800f200 <HAL_FLASH_OB_Unlock+0x3c>)
 800f1d8:	611a      	str	r2, [r3, #16]
    WRITE_REG(FLASH->OPTKEYR, FLASH_OPTKEY2);
 800f1da:	4b08      	ldr	r3, [pc, #32]	@ (800f1fc <HAL_FLASH_OB_Unlock+0x38>)
 800f1dc:	4a09      	ldr	r2, [pc, #36]	@ (800f204 <HAL_FLASH_OB_Unlock+0x40>)
 800f1de:	611a      	str	r2, [r3, #16]

    /* Verify that the Option Bytes are unlocked */
    if (READ_BIT(FLASH->NSCR, FLASH_NSCR_OPTLOCK) != 0U)
 800f1e0:	4b06      	ldr	r3, [pc, #24]	@ (800f1fc <HAL_FLASH_OB_Unlock+0x38>)
 800f1e2:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800f1e4:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
 800f1e8:	2b00      	cmp	r3, #0
 800f1ea:	d001      	beq.n	800f1f0 <HAL_FLASH_OB_Unlock+0x2c>
    {
      return HAL_ERROR;
 800f1ec:	2301      	movs	r3, #1
 800f1ee:	e000      	b.n	800f1f2 <HAL_FLASH_OB_Unlock+0x2e>
    }
  }

  return HAL_OK;
 800f1f0:	2300      	movs	r3, #0
}
 800f1f2:	4618      	mov	r0, r3
 800f1f4:	46bd      	mov	sp, r7
 800f1f6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f1fa:	4770      	bx	lr
 800f1fc:	40022000 	.word	0x40022000
 800f200:	08192a3b 	.word	0x08192a3b
 800f204:	4c5d6e7f 	.word	0x4c5d6e7f

0800f208 <HAL_FLASH_OB_Lock>:
/**
  * @brief  Lock the FLASH Option Bytes Registers access.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_OB_Lock(void)
{
 800f208:	b480      	push	{r7}
 800f20a:	af00      	add	r7, sp, #0
  /* Set the OPTLOCK Bit to lock the FLASH Option Byte Registers access */
  SET_BIT(FLASH->NSCR, FLASH_NSCR_OPTLOCK);
 800f20c:	4b09      	ldr	r3, [pc, #36]	@ (800f234 <HAL_FLASH_OB_Lock+0x2c>)
 800f20e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800f210:	4a08      	ldr	r2, [pc, #32]	@ (800f234 <HAL_FLASH_OB_Lock+0x2c>)
 800f212:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 800f216:	6293      	str	r3, [r2, #40]	@ 0x28

  /* Verify that the Option Bytes are locked */
  if (READ_BIT(FLASH->NSCR, FLASH_NSCR_OPTLOCK) != 0U)
 800f218:	4b06      	ldr	r3, [pc, #24]	@ (800f234 <HAL_FLASH_OB_Lock+0x2c>)
 800f21a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800f21c:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
 800f220:	2b00      	cmp	r3, #0
 800f222:	d001      	beq.n	800f228 <HAL_FLASH_OB_Lock+0x20>
  {
    return HAL_OK;
 800f224:	2300      	movs	r3, #0
 800f226:	e000      	b.n	800f22a <HAL_FLASH_OB_Lock+0x22>
  }

  return HAL_ERROR;
 800f228:	2301      	movs	r3, #1
}
 800f22a:	4618      	mov	r0, r3
 800f22c:	46bd      	mov	sp, r7
 800f22e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f232:	4770      	bx	lr
 800f234:	40022000 	.word	0x40022000

0800f238 <FLASH_WaitForLastOperation>:
  * @brief  Wait for a FLASH operation to complete.
  * @param  Timeout maximum flash operation timeout
  * @retval HAL Status
  */
HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout)
{
 800f238:	b580      	push	{r7, lr}
 800f23a:	b086      	sub	sp, #24
 800f23c:	af00      	add	r7, sp, #0
 800f23e:	6078      	str	r0, [r7, #4]
  /* Wait for the FLASH operation to complete by polling on BUSY and WDW flags to be reset.
     Even if the FLASH operation fails, the BUSY & WDW flags will be reset, and an error flag will be set */

  uint32_t timeout = HAL_GetTick() + Timeout;
 800f240:	f7fe fc0e 	bl	800da60 <HAL_GetTick>
 800f244:	4602      	mov	r2, r0
 800f246:	687b      	ldr	r3, [r7, #4]
 800f248:	4413      	add	r3, r2
 800f24a:	617b      	str	r3, [r7, #20]
  uint32_t error;
  __IO uint32_t *reg_sr;

  /* Access to SECSR or NSSR registers depends on operation type */
  reg_sr = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECSR) : &(FLASH_NS->NSSR);
 800f24c:	4b1b      	ldr	r3, [pc, #108]	@ (800f2bc <FLASH_WaitForLastOperation+0x84>)
 800f24e:	613b      	str	r3, [r7, #16]

  while (((*reg_sr) & (FLASH_FLAG_BSY | FLASH_FLAG_WDW)) != 0U)
 800f250:	e00b      	b.n	800f26a <FLASH_WaitForLastOperation+0x32>
  {
    if (Timeout != HAL_MAX_DELAY)
 800f252:	687b      	ldr	r3, [r7, #4]
 800f254:	f1b3 3fff 	cmp.w	r3, #4294967295
 800f258:	d007      	beq.n	800f26a <FLASH_WaitForLastOperation+0x32>
    {
      if (HAL_GetTick() >= timeout)
 800f25a:	f7fe fc01 	bl	800da60 <HAL_GetTick>
 800f25e:	4602      	mov	r2, r0
 800f260:	697b      	ldr	r3, [r7, #20]
 800f262:	4293      	cmp	r3, r2
 800f264:	d801      	bhi.n	800f26a <FLASH_WaitForLastOperation+0x32>
      {
        return HAL_TIMEOUT;
 800f266:	2303      	movs	r3, #3
 800f268:	e023      	b.n	800f2b2 <FLASH_WaitForLastOperation+0x7a>
  while (((*reg_sr) & (FLASH_FLAG_BSY | FLASH_FLAG_WDW)) != 0U)
 800f26a:	693b      	ldr	r3, [r7, #16]
 800f26c:	681b      	ldr	r3, [r3, #0]
 800f26e:	f403 3340 	and.w	r3, r3, #196608	@ 0x30000
 800f272:	2b00      	cmp	r3, #0
 800f274:	d1ed      	bne.n	800f252 <FLASH_WaitForLastOperation+0x1a>
      }
    }
  }

  /* Check FLASH operation error flags */
  error = ((*reg_sr) & FLASH_FLAG_SR_ERRORS);
 800f276:	693b      	ldr	r3, [r7, #16]
 800f278:	681a      	ldr	r2, [r3, #0]
 800f27a:	f242 03fa 	movw	r3, #8442	@ 0x20fa
 800f27e:	4013      	ands	r3, r2
 800f280:	60fb      	str	r3, [r7, #12]
#if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
  error |= (FLASH->NSSR & FLASH_FLAG_OPTWERR);
#endif /* __ARM_FEATURE_CMSE */

  if (error != 0U)
 800f282:	68fb      	ldr	r3, [r7, #12]
 800f284:	2b00      	cmp	r3, #0
 800f286:	d00a      	beq.n	800f29e <FLASH_WaitForLastOperation+0x66>
  {
    /*Save the error code*/
    pFlash.ErrorCode |= error;
 800f288:	4b0d      	ldr	r3, [pc, #52]	@ (800f2c0 <FLASH_WaitForLastOperation+0x88>)
 800f28a:	685a      	ldr	r2, [r3, #4]
 800f28c:	68fb      	ldr	r3, [r7, #12]
 800f28e:	4313      	orrs	r3, r2
 800f290:	4a0b      	ldr	r2, [pc, #44]	@ (800f2c0 <FLASH_WaitForLastOperation+0x88>)
 800f292:	6053      	str	r3, [r2, #4]

    /* Clear error programming flags */
    (*reg_sr) = error;
 800f294:	693b      	ldr	r3, [r7, #16]
 800f296:	68fa      	ldr	r2, [r7, #12]
 800f298:	601a      	str	r2, [r3, #0]
    {
      FLASH->NSSR = FLASH_FLAG_OPTWERR;
    }
#endif /* __ARM_FEATURE_CMSE */

    return HAL_ERROR;
 800f29a:	2301      	movs	r3, #1
 800f29c:	e009      	b.n	800f2b2 <FLASH_WaitForLastOperation+0x7a>
  }

  /* Check FLASH End of Operation flag  */
  if (((*reg_sr) & FLASH_FLAG_EOP) != 0U)
 800f29e:	693b      	ldr	r3, [r7, #16]
 800f2a0:	681b      	ldr	r3, [r3, #0]
 800f2a2:	f003 0301 	and.w	r3, r3, #1
 800f2a6:	2b00      	cmp	r3, #0
 800f2a8:	d002      	beq.n	800f2b0 <FLASH_WaitForLastOperation+0x78>
  {
    /* Clear FLASH End of Operation pending bit */
    (*reg_sr) = FLASH_FLAG_EOP;
 800f2aa:	693b      	ldr	r3, [r7, #16]
 800f2ac:	2201      	movs	r2, #1
 800f2ae:	601a      	str	r2, [r3, #0]
  }

  /* If there is no error flag set */
  return HAL_OK;
 800f2b0:	2300      	movs	r3, #0
}
 800f2b2:	4618      	mov	r0, r3
 800f2b4:	3718      	adds	r7, #24
 800f2b6:	46bd      	mov	sp, r7
 800f2b8:	bd80      	pop	{r7, pc}
 800f2ba:	bf00      	nop
 800f2bc:	40022020 	.word	0x40022020
 800f2c0:	200001ec 	.word	0x200001ec

0800f2c4 <FLASH_Program_QuadWord>:
  * @param  Address specifies the address to be programmed.
  * @param  DataAddress specifies the address of data to be programmed.
  * @retval None
  */
static void FLASH_Program_QuadWord(uint32_t Address, uint32_t DataAddress)
{
 800f2c4:	b480      	push	{r7}
 800f2c6:	b08b      	sub	sp, #44	@ 0x2c
 800f2c8:	af00      	add	r7, sp, #0
 800f2ca:	6078      	str	r0, [r7, #4]
 800f2cc:	6039      	str	r1, [r7, #0]
  uint8_t index = 4;
 800f2ce:	2304      	movs	r3, #4
 800f2d0:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  uint32_t *dest_addr = (uint32_t *)Address;
 800f2d4:	687b      	ldr	r3, [r7, #4]
 800f2d6:	623b      	str	r3, [r7, #32]
  uint32_t *src_addr  = (uint32_t *)DataAddress;
 800f2d8:	683b      	ldr	r3, [r7, #0]
 800f2da:	61fb      	str	r3, [r7, #28]

  /* Check the parameters */
  assert_param(IS_FLASH_PROGRAM_ADDRESS(Address));

  /* Access to SECCR or NSCR registers depends on operation type */
  reg_cr = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH_NS->NSCR);
 800f2dc:	4b16      	ldr	r3, [pc, #88]	@ (800f338 <FLASH_Program_QuadWord+0x74>)
 800f2de:	61bb      	str	r3, [r7, #24]

  /* Set PG bit */
  SET_BIT((*reg_cr), FLASH_NSCR_PG);
 800f2e0:	69bb      	ldr	r3, [r7, #24]
 800f2e2:	681b      	ldr	r3, [r3, #0]
 800f2e4:	f043 0201 	orr.w	r2, r3, #1
 800f2e8:	69bb      	ldr	r3, [r7, #24]
 800f2ea:	601a      	str	r2, [r3, #0]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800f2ec:	f3ef 8310 	mrs	r3, PRIMASK
 800f2f0:	613b      	str	r3, [r7, #16]
  return(result);
 800f2f2:	693b      	ldr	r3, [r7, #16]

  /* Enter critical section: Disable interrupts to avoid any interruption during the loop */
  primask_bit = __get_PRIMASK();
 800f2f4:	617b      	str	r3, [r7, #20]
  __ASM volatile ("cpsid i" : : : "memory");
 800f2f6:	b672      	cpsid	i
}
 800f2f8:	bf00      	nop
  __disable_irq();

  /* Program the quad-word */
  do
  {
    *dest_addr = *src_addr;
 800f2fa:	69fb      	ldr	r3, [r7, #28]
 800f2fc:	681a      	ldr	r2, [r3, #0]
 800f2fe:	6a3b      	ldr	r3, [r7, #32]
 800f300:	601a      	str	r2, [r3, #0]
    dest_addr++;
 800f302:	6a3b      	ldr	r3, [r7, #32]
 800f304:	3304      	adds	r3, #4
 800f306:	623b      	str	r3, [r7, #32]
    src_addr++;
 800f308:	69fb      	ldr	r3, [r7, #28]
 800f30a:	3304      	adds	r3, #4
 800f30c:	61fb      	str	r3, [r7, #28]
    index--;
 800f30e:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 800f312:	3b01      	subs	r3, #1
 800f314:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  } while (index != 0U);
 800f318:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 800f31c:	2b00      	cmp	r3, #0
 800f31e:	d1ec      	bne.n	800f2fa <FLASH_Program_QuadWord+0x36>
 800f320:	697b      	ldr	r3, [r7, #20]
 800f322:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800f324:	68fb      	ldr	r3, [r7, #12]
 800f326:	f383 8810 	msr	PRIMASK, r3
}
 800f32a:	bf00      	nop

  /* Exit critical section: restore previous priority mask */
  __set_PRIMASK(primask_bit);
}
 800f32c:	bf00      	nop
 800f32e:	372c      	adds	r7, #44	@ 0x2c
 800f330:	46bd      	mov	sp, r7
 800f332:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f336:	4770      	bx	lr
 800f338:	40022028 	.word	0x40022028

0800f33c <FLASH_Program_Burst>:
  * @param  Address: specifies the address to be programmed.
  * @param  DataAddress: specifies the address where the data are stored.
  * @retval None
  */
static void FLASH_Program_Burst(uint32_t Address, uint32_t DataAddress)
{
 800f33c:	b480      	push	{r7}
 800f33e:	b08b      	sub	sp, #44	@ 0x2c
 800f340:	af00      	add	r7, sp, #0
 800f342:	6078      	str	r0, [r7, #4]
 800f344:	6039      	str	r1, [r7, #0]
  uint8_t burst_index = FLASH_NB_WORDS_IN_BURST;
 800f346:	2320      	movs	r3, #32
 800f348:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  uint32_t *dest_addr = (uint32_t *)Address;
 800f34c:	687b      	ldr	r3, [r7, #4]
 800f34e:	623b      	str	r3, [r7, #32]
  uint32_t *src_addr = (uint32_t *)DataAddress;
 800f350:	683b      	ldr	r3, [r7, #0]
 800f352:	61fb      	str	r3, [r7, #28]

  /* Check the parameters */
  assert_param(IS_FLASH_MAIN_MEM_ADDRESS(Address));

  /* Access to SECCR or NSCR registers depends on operation type */
  reg_cr = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH_NS->NSCR);
 800f354:	4b17      	ldr	r3, [pc, #92]	@ (800f3b4 <FLASH_Program_Burst+0x78>)
 800f356:	61bb      	str	r3, [r7, #24]

  /* Set PG and BWR bits */
  SET_BIT((*reg_cr), (FLASH_NSCR_PG | FLASH_NSCR_BWR));
 800f358:	69bb      	ldr	r3, [r7, #24]
 800f35a:	681b      	ldr	r3, [r3, #0]
 800f35c:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 800f360:	f043 0301 	orr.w	r3, r3, #1
 800f364:	69ba      	ldr	r2, [r7, #24]
 800f366:	6013      	str	r3, [r2, #0]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800f368:	f3ef 8310 	mrs	r3, PRIMASK
 800f36c:	613b      	str	r3, [r7, #16]
  return(result);
 800f36e:	693b      	ldr	r3, [r7, #16]

  /* Enter critical section: Disable interrupts to avoid any interruption during the loop */
  primask_bit = __get_PRIMASK();
 800f370:	617b      	str	r3, [r7, #20]
  __ASM volatile ("cpsid i" : : : "memory");
 800f372:	b672      	cpsid	i
}
 800f374:	bf00      	nop
  __disable_irq();

  /* Program the burst */
  do
  {
    *dest_addr = *src_addr;
 800f376:	69fb      	ldr	r3, [r7, #28]
 800f378:	681a      	ldr	r2, [r3, #0]
 800f37a:	6a3b      	ldr	r3, [r7, #32]
 800f37c:	601a      	str	r2, [r3, #0]
    dest_addr++;
 800f37e:	6a3b      	ldr	r3, [r7, #32]
 800f380:	3304      	adds	r3, #4
 800f382:	623b      	str	r3, [r7, #32]
    src_addr++;
 800f384:	69fb      	ldr	r3, [r7, #28]
 800f386:	3304      	adds	r3, #4
 800f388:	61fb      	str	r3, [r7, #28]
    burst_index--;
 800f38a:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 800f38e:	3b01      	subs	r3, #1
 800f390:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  } while (burst_index != 0U);
 800f394:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 800f398:	2b00      	cmp	r3, #0
 800f39a:	d1ec      	bne.n	800f376 <FLASH_Program_Burst+0x3a>
 800f39c:	697b      	ldr	r3, [r7, #20]
 800f39e:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800f3a0:	68fb      	ldr	r3, [r7, #12]
 800f3a2:	f383 8810 	msr	PRIMASK, r3
}
 800f3a6:	bf00      	nop

  /* Exit critical section: restore previous priority mask */
  __set_PRIMASK(primask_bit);
}
 800f3a8:	bf00      	nop
 800f3aa:	372c      	adds	r7, #44	@ 0x2c
 800f3ac:	46bd      	mov	sp, r7
 800f3ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f3b2:	4770      	bx	lr
 800f3b4:	40022028 	.word	0x40022028

0800f3b8 <HAL_FLASHEx_Erase>:
  *         the pages have been correctly erased).
  *
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_Erase(FLASH_EraseInitTypeDef *pEraseInit, uint32_t *PageError)
{
 800f3b8:	b580      	push	{r7, lr}
 800f3ba:	b086      	sub	sp, #24
 800f3bc:	af00      	add	r7, sp, #0
 800f3be:	6078      	str	r0, [r7, #4]
 800f3c0:	6039      	str	r1, [r7, #0]

  /* Check the parameters */
  assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));

  /* Process Locked */
  __HAL_LOCK(&pFlash);
 800f3c2:	4b33      	ldr	r3, [pc, #204]	@ (800f490 <HAL_FLASHEx_Erase+0xd8>)
 800f3c4:	781b      	ldrb	r3, [r3, #0]
 800f3c6:	2b01      	cmp	r3, #1
 800f3c8:	d101      	bne.n	800f3ce <HAL_FLASHEx_Erase+0x16>
 800f3ca:	2302      	movs	r3, #2
 800f3cc:	e05c      	b.n	800f488 <HAL_FLASHEx_Erase+0xd0>
 800f3ce:	4b30      	ldr	r3, [pc, #192]	@ (800f490 <HAL_FLASHEx_Erase+0xd8>)
 800f3d0:	2201      	movs	r2, #1
 800f3d2:	701a      	strb	r2, [r3, #0]

  /* Reset error code */
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 800f3d4:	4b2e      	ldr	r3, [pc, #184]	@ (800f490 <HAL_FLASHEx_Erase+0xd8>)
 800f3d6:	2200      	movs	r2, #0
 800f3d8:	605a      	str	r2, [r3, #4]

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 800f3da:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
 800f3de:	f7ff ff2b 	bl	800f238 <FLASH_WaitForLastOperation>
 800f3e2:	4603      	mov	r3, r0
 800f3e4:	75fb      	strb	r3, [r7, #23]

  if (status == HAL_OK)
 800f3e6:	7dfb      	ldrb	r3, [r7, #23]
 800f3e8:	2b00      	cmp	r3, #0
 800f3ea:	d149      	bne.n	800f480 <HAL_FLASHEx_Erase+0xc8>
  {
    /* Current operation type */
    pFlash.ProcedureOnGoing = pEraseInit->TypeErase;
 800f3ec:	687b      	ldr	r3, [r7, #4]
 800f3ee:	681b      	ldr	r3, [r3, #0]
 800f3f0:	4a27      	ldr	r2, [pc, #156]	@ (800f490 <HAL_FLASHEx_Erase+0xd8>)
 800f3f2:	6093      	str	r3, [r2, #8]

    /* Access to SECCR or NSCR depends on operation type */
    reg_cr = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH->NSCR);
 800f3f4:	4b27      	ldr	r3, [pc, #156]	@ (800f494 <HAL_FLASHEx_Erase+0xdc>)
 800f3f6:	60fb      	str	r3, [r7, #12]

    if ((pEraseInit->TypeErase & (~FLASH_NON_SECURE_MASK)) == FLASH_TYPEERASE_MASSERASE)
 800f3f8:	687b      	ldr	r3, [r7, #4]
 800f3fa:	681b      	ldr	r3, [r3, #0]
 800f3fc:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 800f400:	f248 0204 	movw	r2, #32772	@ 0x8004
 800f404:	4293      	cmp	r3, r2
 800f406:	d10b      	bne.n	800f420 <HAL_FLASHEx_Erase+0x68>
    {
      /* Mass erase to be done */
      FLASH_MassErase(pEraseInit->Banks);
 800f408:	687b      	ldr	r3, [r7, #4]
 800f40a:	685b      	ldr	r3, [r3, #4]
 800f40c:	4618      	mov	r0, r3
 800f40e:	f000 f891 	bl	800f534 <FLASH_MassErase>

      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 800f412:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
 800f416:	f7ff ff0f 	bl	800f238 <FLASH_WaitForLastOperation>
 800f41a:	4603      	mov	r3, r0
 800f41c:	75fb      	strb	r3, [r7, #23]
 800f41e:	e025      	b.n	800f46c <HAL_FLASHEx_Erase+0xb4>
    }
    else
    {
      /*Initialization of PageError variable*/
      *PageError = 0xFFFFFFFFU;
 800f420:	683b      	ldr	r3, [r7, #0]
 800f422:	f04f 32ff 	mov.w	r2, #4294967295
 800f426:	601a      	str	r2, [r3, #0]

      for (page_index = pEraseInit->Page; page_index < (pEraseInit->Page + pEraseInit->NbPages); page_index++)
 800f428:	687b      	ldr	r3, [r7, #4]
 800f42a:	689b      	ldr	r3, [r3, #8]
 800f42c:	613b      	str	r3, [r7, #16]
 800f42e:	e015      	b.n	800f45c <HAL_FLASHEx_Erase+0xa4>
      {
        FLASH_PageErase(page_index, pEraseInit->Banks);
 800f430:	687b      	ldr	r3, [r7, #4]
 800f432:	685b      	ldr	r3, [r3, #4]
 800f434:	4619      	mov	r1, r3
 800f436:	6938      	ldr	r0, [r7, #16]
 800f438:	f000 f8a2 	bl	800f580 <FLASH_PageErase>

        /* Wait for last operation to be completed */
        status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 800f43c:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
 800f440:	f7ff fefa 	bl	800f238 <FLASH_WaitForLastOperation>
 800f444:	4603      	mov	r3, r0
 800f446:	75fb      	strb	r3, [r7, #23]

        if (status != HAL_OK)
 800f448:	7dfb      	ldrb	r3, [r7, #23]
 800f44a:	2b00      	cmp	r3, #0
 800f44c:	d003      	beq.n	800f456 <HAL_FLASHEx_Erase+0x9e>
        {
          /* In case of error, stop erase procedure and return the faulty page */
          *PageError = page_index;
 800f44e:	683b      	ldr	r3, [r7, #0]
 800f450:	693a      	ldr	r2, [r7, #16]
 800f452:	601a      	str	r2, [r3, #0]
          break;
 800f454:	e00a      	b.n	800f46c <HAL_FLASHEx_Erase+0xb4>
      for (page_index = pEraseInit->Page; page_index < (pEraseInit->Page + pEraseInit->NbPages); page_index++)
 800f456:	693b      	ldr	r3, [r7, #16]
 800f458:	3301      	adds	r3, #1
 800f45a:	613b      	str	r3, [r7, #16]
 800f45c:	687b      	ldr	r3, [r7, #4]
 800f45e:	689a      	ldr	r2, [r3, #8]
 800f460:	687b      	ldr	r3, [r7, #4]
 800f462:	68db      	ldr	r3, [r3, #12]
 800f464:	4413      	add	r3, r2
 800f466:	693a      	ldr	r2, [r7, #16]
 800f468:	429a      	cmp	r2, r3
 800f46a:	d3e1      	bcc.n	800f430 <HAL_FLASHEx_Erase+0x78>
        }
      }
    }

    /* If the erase operation is completed, disable the associated bits */
    CLEAR_BIT((*reg_cr), (pEraseInit->TypeErase) & (~(FLASH_NON_SECURE_MASK)));
 800f46c:	68fb      	ldr	r3, [r7, #12]
 800f46e:	681a      	ldr	r2, [r3, #0]
 800f470:	687b      	ldr	r3, [r7, #4]
 800f472:	681b      	ldr	r3, [r3, #0]
 800f474:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 800f478:	43db      	mvns	r3, r3
 800f47a:	401a      	ands	r2, r3
 800f47c:	68fb      	ldr	r3, [r7, #12]
 800f47e:	601a      	str	r2, [r3, #0]
  }

  /* Process Unlocked */
  __HAL_UNLOCK(&pFlash);
 800f480:	4b03      	ldr	r3, [pc, #12]	@ (800f490 <HAL_FLASHEx_Erase+0xd8>)
 800f482:	2200      	movs	r2, #0
 800f484:	701a      	strb	r2, [r3, #0]

  return status;
 800f486:	7dfb      	ldrb	r3, [r7, #23]
}
 800f488:	4618      	mov	r0, r3
 800f48a:	3718      	adds	r7, #24
 800f48c:	46bd      	mov	sp, r7
 800f48e:	bd80      	pop	{r7, pc}
 800f490:	200001ec 	.word	0x200001ec
 800f494:	40022028 	.word	0x40022028

0800f498 <HAL_FLASHEx_OBGetConfig>:
  *         Boot Address, else no information will be returned
  *
  * @retval None
  */
void HAL_FLASHEx_OBGetConfig(FLASH_OBProgramInitTypeDef *pOBInit)
{
 800f498:	b580      	push	{r7, lr}
 800f49a:	b082      	sub	sp, #8
 800f49c:	af00      	add	r7, sp, #0
 800f49e:	6078      	str	r0, [r7, #4]
  pOBInit->OptionType = (OPTIONBYTE_RDP | OPTIONBYTE_USER);
 800f4a0:	687b      	ldr	r3, [r7, #4]
 800f4a2:	2206      	movs	r2, #6
 800f4a4:	601a      	str	r2, [r3, #0]

  if ((pOBInit->WRPArea == OB_WRPAREA_BANK1_AREAA) || (pOBInit->WRPArea == OB_WRPAREA_BANK1_AREAB) ||
 800f4a6:	687b      	ldr	r3, [r7, #4]
 800f4a8:	685b      	ldr	r3, [r3, #4]
 800f4aa:	2b01      	cmp	r3, #1
 800f4ac:	d00b      	beq.n	800f4c6 <HAL_FLASHEx_OBGetConfig+0x2e>
 800f4ae:	687b      	ldr	r3, [r7, #4]
 800f4b0:	685b      	ldr	r3, [r3, #4]
 800f4b2:	2b02      	cmp	r3, #2
 800f4b4:	d007      	beq.n	800f4c6 <HAL_FLASHEx_OBGetConfig+0x2e>
      (pOBInit->WRPArea == OB_WRPAREA_BANK2_AREAA) || (pOBInit->WRPArea == OB_WRPAREA_BANK2_AREAB))
 800f4b6:	687b      	ldr	r3, [r7, #4]
 800f4b8:	685b      	ldr	r3, [r3, #4]
  if ((pOBInit->WRPArea == OB_WRPAREA_BANK1_AREAA) || (pOBInit->WRPArea == OB_WRPAREA_BANK1_AREAB) ||
 800f4ba:	2b04      	cmp	r3, #4
 800f4bc:	d003      	beq.n	800f4c6 <HAL_FLASHEx_OBGetConfig+0x2e>
      (pOBInit->WRPArea == OB_WRPAREA_BANK2_AREAA) || (pOBInit->WRPArea == OB_WRPAREA_BANK2_AREAB))
 800f4be:	687b      	ldr	r3, [r7, #4]
 800f4c0:	685b      	ldr	r3, [r3, #4]
 800f4c2:	2b08      	cmp	r3, #8
 800f4c4:	d111      	bne.n	800f4ea <HAL_FLASHEx_OBGetConfig+0x52>
  {
    pOBInit->OptionType |= OPTIONBYTE_WRP;
 800f4c6:	687b      	ldr	r3, [r7, #4]
 800f4c8:	681b      	ldr	r3, [r3, #0]
 800f4ca:	f043 0201 	orr.w	r2, r3, #1
 800f4ce:	687b      	ldr	r3, [r7, #4]
 800f4d0:	601a      	str	r2, [r3, #0]
    /* Get write protection on the selected area */
    FLASH_OB_GetWRP(pOBInit->WRPArea, &(pOBInit->WRPStartOffset), &(pOBInit->WRPEndOffset), &(pOBInit->WRPLock));
 800f4d2:	687b      	ldr	r3, [r7, #4]
 800f4d4:	6858      	ldr	r0, [r3, #4]
 800f4d6:	687b      	ldr	r3, [r7, #4]
 800f4d8:	f103 0108 	add.w	r1, r3, #8
 800f4dc:	687b      	ldr	r3, [r7, #4]
 800f4de:	f103 020c 	add.w	r2, r3, #12
 800f4e2:	687b      	ldr	r3, [r7, #4]
 800f4e4:	3310      	adds	r3, #16
 800f4e6:	f000 f87b 	bl	800f5e0 <FLASH_OB_GetWRP>
  }

  /* Get Read protection level */
  pOBInit->RDPLevel = FLASH_OB_GetRDP();
 800f4ea:	f000 f8eb 	bl	800f6c4 <FLASH_OB_GetRDP>
 800f4ee:	4602      	mov	r2, r0
 800f4f0:	687b      	ldr	r3, [r7, #4]
 800f4f2:	615a      	str	r2, [r3, #20]

  /* Get the user option bytes */
  pOBInit->USERConfig = FLASH_OB_GetUser();
 800f4f4:	f000 f902 	bl	800f6fc <FLASH_OB_GetUser>
 800f4f8:	4602      	mov	r2, r0
 800f4fa:	687b      	ldr	r3, [r7, #4]
 800f4fc:	61da      	str	r2, [r3, #28]
  /* Get the value of the selected boot address */
#if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
  if ((pOBInit->BootAddrConfig == OB_BOOTADDR_NS0) || (pOBInit->BootAddrConfig == OB_BOOTADDR_NS1) ||
      (pOBInit->BootAddrConfig == OB_BOOTADDR_SEC0))
#else
  if ((pOBInit->BootAddrConfig == OB_BOOTADDR_NS0) || (pOBInit->BootAddrConfig == OB_BOOTADDR_NS1))
 800f4fe:	687b      	ldr	r3, [r7, #4]
 800f500:	6a1b      	ldr	r3, [r3, #32]
 800f502:	2b01      	cmp	r3, #1
 800f504:	d003      	beq.n	800f50e <HAL_FLASHEx_OBGetConfig+0x76>
 800f506:	687b      	ldr	r3, [r7, #4]
 800f508:	6a1b      	ldr	r3, [r3, #32]
 800f50a:	2b02      	cmp	r3, #2
 800f50c:	d10d      	bne.n	800f52a <HAL_FLASHEx_OBGetConfig+0x92>
#endif /* __ARM_FEATURE_CMSE */
  {
    pOBInit->OptionType |= OPTIONBYTE_BOOTADDR;
 800f50e:	687b      	ldr	r3, [r7, #4]
 800f510:	681b      	ldr	r3, [r3, #0]
 800f512:	f043 0208 	orr.w	r2, r3, #8
 800f516:	687b      	ldr	r3, [r7, #4]
 800f518:	601a      	str	r2, [r3, #0]
    FLASH_OB_GetBootAddr(pOBInit->BootAddrConfig, &(pOBInit->BootAddr));
 800f51a:	687b      	ldr	r3, [r7, #4]
 800f51c:	6a1a      	ldr	r2, [r3, #32]
 800f51e:	687b      	ldr	r3, [r7, #4]
 800f520:	3324      	adds	r3, #36	@ 0x24
 800f522:	4619      	mov	r1, r3
 800f524:	4610      	mov	r0, r2
 800f526:	f000 f8fd 	bl	800f724 <FLASH_OB_GetBootAddr>
  }
}
 800f52a:	bf00      	nop
 800f52c:	3708      	adds	r7, #8
 800f52e:	46bd      	mov	sp, r7
 800f530:	bd80      	pop	{r7, pc}
	...

0800f534 <FLASH_MassErase>:
  *            @arg FLASH_BANK_2: Bank2 to be erased
  *            @arg FLASH_BANK_BOTH: Bank1 and Bank2 to be erased
  * @retval None
  */
static void FLASH_MassErase(uint32_t Banks)
{
 800f534:	b480      	push	{r7}
 800f536:	b085      	sub	sp, #20
 800f538:	af00      	add	r7, sp, #0
 800f53a:	6078      	str	r0, [r7, #4]

  /* Check the parameters */
  assert_param(IS_FLASH_BANK(Banks));

  /* Access to SECCR or NSCR registers depends on operation type */
  reg_cr = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH_NS->NSCR);
 800f53c:	4b0f      	ldr	r3, [pc, #60]	@ (800f57c <FLASH_MassErase+0x48>)
 800f53e:	60fb      	str	r3, [r7, #12]

  /* Set the Mass Erase Bit for the bank 1 and proceed to erase */
  if ((Banks & FLASH_BANK_1) != 0U)
 800f540:	687b      	ldr	r3, [r7, #4]
 800f542:	f003 0301 	and.w	r3, r3, #1
 800f546:	2b00      	cmp	r3, #0
 800f548:	d007      	beq.n	800f55a <FLASH_MassErase+0x26>
  {
    SET_BIT((*reg_cr), FLASH_NSCR_MER1 | FLASH_NSCR_STRT);
 800f54a:	68fb      	ldr	r3, [r7, #12]
 800f54c:	681b      	ldr	r3, [r3, #0]
 800f54e:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 800f552:	f043 0304 	orr.w	r3, r3, #4
 800f556:	68fa      	ldr	r2, [r7, #12]
 800f558:	6013      	str	r3, [r2, #0]
  }

  /* Set the Mass Erase Bit for the bank 2 and proceed to erase */
  if ((Banks & FLASH_BANK_2) != 0U)
 800f55a:	687b      	ldr	r3, [r7, #4]
 800f55c:	f003 0302 	and.w	r3, r3, #2
 800f560:	2b00      	cmp	r3, #0
 800f562:	d005      	beq.n	800f570 <FLASH_MassErase+0x3c>
  {
    SET_BIT((*reg_cr), FLASH_NSCR_MER2 | FLASH_NSCR_STRT);
 800f564:	68fb      	ldr	r3, [r7, #12]
 800f566:	681b      	ldr	r3, [r3, #0]
 800f568:	f443 32c0 	orr.w	r2, r3, #98304	@ 0x18000
 800f56c:	68fb      	ldr	r3, [r7, #12]
 800f56e:	601a      	str	r2, [r3, #0]
  }
}
 800f570:	bf00      	nop
 800f572:	3714      	adds	r7, #20
 800f574:	46bd      	mov	sp, r7
 800f576:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f57a:	4770      	bx	lr
 800f57c:	40022028 	.word	0x40022028

0800f580 <FLASH_PageErase>:
  *            @arg FLASH_BANK_1: Page in bank 1 to be erased
  *            @arg FLASH_BANK_2: Page in bank 2 to be erased
  * @retval None
  */
void FLASH_PageErase(uint32_t Page, uint32_t Banks)
{
 800f580:	b480      	push	{r7}
 800f582:	b085      	sub	sp, #20
 800f584:	af00      	add	r7, sp, #0
 800f586:	6078      	str	r0, [r7, #4]
 800f588:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_FLASH_PAGE(Page));
  assert_param(IS_FLASH_BANK_EXCLUSIVE(Banks));

  /* Access to SECCR or NSCR registers depends on operation type */
  reg_cr = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH_NS->NSCR);
 800f58a:	4b14      	ldr	r3, [pc, #80]	@ (800f5dc <FLASH_PageErase+0x5c>)
 800f58c:	60fb      	str	r3, [r7, #12]

  if ((Banks & FLASH_BANK_1) != 0U)
 800f58e:	683b      	ldr	r3, [r7, #0]
 800f590:	f003 0301 	and.w	r3, r3, #1
 800f594:	2b00      	cmp	r3, #0
 800f596:	d006      	beq.n	800f5a6 <FLASH_PageErase+0x26>
  {
    CLEAR_BIT((*reg_cr), FLASH_NSCR_BKER);
 800f598:	68fb      	ldr	r3, [r7, #12]
 800f59a:	681b      	ldr	r3, [r3, #0]
 800f59c:	f423 6200 	bic.w	r2, r3, #2048	@ 0x800
 800f5a0:	68fb      	ldr	r3, [r7, #12]
 800f5a2:	601a      	str	r2, [r3, #0]
 800f5a4:	e005      	b.n	800f5b2 <FLASH_PageErase+0x32>
  }
  else
  {
    SET_BIT((*reg_cr), FLASH_NSCR_BKER);
 800f5a6:	68fb      	ldr	r3, [r7, #12]
 800f5a8:	681b      	ldr	r3, [r3, #0]
 800f5aa:	f443 6200 	orr.w	r2, r3, #2048	@ 0x800
 800f5ae:	68fb      	ldr	r3, [r7, #12]
 800f5b0:	601a      	str	r2, [r3, #0]
  }

  /* Proceed to erase the page */
  MODIFY_REG((*reg_cr), (FLASH_NSCR_PNB | FLASH_NSCR_PER | FLASH_NSCR_STRT), \
 800f5b2:	68fb      	ldr	r3, [r7, #12]
 800f5b4:	681b      	ldr	r3, [r3, #0]
 800f5b6:	f423 3381 	bic.w	r3, r3, #66048	@ 0x10200
 800f5ba:	f423 73fd 	bic.w	r3, r3, #506	@ 0x1fa
 800f5be:	687a      	ldr	r2, [r7, #4]
 800f5c0:	00d2      	lsls	r2, r2, #3
 800f5c2:	4313      	orrs	r3, r2
 800f5c4:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 800f5c8:	f043 0302 	orr.w	r3, r3, #2
 800f5cc:	68fa      	ldr	r2, [r7, #12]
 800f5ce:	6013      	str	r3, [r2, #0]
             ((Page << FLASH_NSCR_PNB_Pos) | FLASH_NSCR_PER | FLASH_NSCR_STRT));
}
 800f5d0:	bf00      	nop
 800f5d2:	3714      	adds	r7, #20
 800f5d4:	46bd      	mov	sp, r7
 800f5d6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f5da:	4770      	bx	lr
 800f5dc:	40022028 	.word	0x40022028

0800f5e0 <FLASH_OB_GetWRP>:
  *
  * @retval None
  */
static void FLASH_OB_GetWRP(uint32_t WRPArea, uint32_t *WRPStartOffset, uint32_t *WRPEndOffset,
                            FunctionalState *WRPLock)
{
 800f5e0:	b480      	push	{r7}
 800f5e2:	b085      	sub	sp, #20
 800f5e4:	af00      	add	r7, sp, #0
 800f5e6:	60f8      	str	r0, [r7, #12]
 800f5e8:	60b9      	str	r1, [r7, #8]
 800f5ea:	607a      	str	r2, [r7, #4]
 800f5ec:	603b      	str	r3, [r7, #0]
  /* Get the configuration of the write protected area */
  if (WRPArea == OB_WRPAREA_BANK1_AREAA)
 800f5ee:	68fb      	ldr	r3, [r7, #12]
 800f5f0:	2b01      	cmp	r3, #1
 800f5f2:	d115      	bne.n	800f620 <FLASH_OB_GetWRP+0x40>
  {
    *WRPStartOffset = READ_BIT(FLASH->WRP1AR, FLASH_WRP1AR_WRP1A_PSTRT);
 800f5f4:	4b32      	ldr	r3, [pc, #200]	@ (800f6c0 <FLASH_OB_GetWRP+0xe0>)
 800f5f6:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800f5f8:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
 800f5fc:	68bb      	ldr	r3, [r7, #8]
 800f5fe:	601a      	str	r2, [r3, #0]
    *WRPEndOffset = (READ_BIT(FLASH->WRP1AR, FLASH_WRP1AR_WRP1A_PEND) >> FLASH_WRP1AR_WRP1A_PEND_Pos);
 800f600:	4b2f      	ldr	r3, [pc, #188]	@ (800f6c0 <FLASH_OB_GetWRP+0xe0>)
 800f602:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800f604:	0c1b      	lsrs	r3, r3, #16
 800f606:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
 800f60a:	687b      	ldr	r3, [r7, #4]
 800f60c:	601a      	str	r2, [r3, #0]
    *WRPLock = (READ_BIT(FLASH->WRP1AR, FLASH_WRP1AR_UNLOCK) != 0U) ? DISABLE : ENABLE;
 800f60e:	4b2c      	ldr	r3, [pc, #176]	@ (800f6c0 <FLASH_OB_GetWRP+0xe0>)
 800f610:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800f612:	43db      	mvns	r3, r3
 800f614:	0fdb      	lsrs	r3, r3, #31
 800f616:	b2db      	uxtb	r3, r3
 800f618:	461a      	mov	r2, r3
 800f61a:	683b      	ldr	r3, [r7, #0]
 800f61c:	701a      	strb	r2, [r3, #0]
  }
  else
  {
    /* Empty statement (to be compliant MISRA 15.7) */
  }
}
 800f61e:	e049      	b.n	800f6b4 <FLASH_OB_GetWRP+0xd4>
  else if (WRPArea == OB_WRPAREA_BANK1_AREAB)
 800f620:	68fb      	ldr	r3, [r7, #12]
 800f622:	2b02      	cmp	r3, #2
 800f624:	d115      	bne.n	800f652 <FLASH_OB_GetWRP+0x72>
    *WRPStartOffset = READ_BIT(FLASH->WRP1BR, FLASH_WRP1BR_WRP1B_PSTRT);
 800f626:	4b26      	ldr	r3, [pc, #152]	@ (800f6c0 <FLASH_OB_GetWRP+0xe0>)
 800f628:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 800f62a:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
 800f62e:	68bb      	ldr	r3, [r7, #8]
 800f630:	601a      	str	r2, [r3, #0]
    *WRPEndOffset = (READ_BIT(FLASH->WRP1BR, FLASH_WRP1BR_WRP1B_PEND) >> FLASH_WRP1BR_WRP1B_PEND_Pos);
 800f632:	4b23      	ldr	r3, [pc, #140]	@ (800f6c0 <FLASH_OB_GetWRP+0xe0>)
 800f634:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 800f636:	0c1b      	lsrs	r3, r3, #16
 800f638:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
 800f63c:	687b      	ldr	r3, [r7, #4]
 800f63e:	601a      	str	r2, [r3, #0]
    *WRPLock = (READ_BIT(FLASH->WRP1BR, FLASH_WRP1BR_UNLOCK) != 0U) ? DISABLE : ENABLE;
 800f640:	4b1f      	ldr	r3, [pc, #124]	@ (800f6c0 <FLASH_OB_GetWRP+0xe0>)
 800f642:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 800f644:	43db      	mvns	r3, r3
 800f646:	0fdb      	lsrs	r3, r3, #31
 800f648:	b2db      	uxtb	r3, r3
 800f64a:	461a      	mov	r2, r3
 800f64c:	683b      	ldr	r3, [r7, #0]
 800f64e:	701a      	strb	r2, [r3, #0]
}
 800f650:	e030      	b.n	800f6b4 <FLASH_OB_GetWRP+0xd4>
  else if (WRPArea == OB_WRPAREA_BANK2_AREAA)
 800f652:	68fb      	ldr	r3, [r7, #12]
 800f654:	2b04      	cmp	r3, #4
 800f656:	d115      	bne.n	800f684 <FLASH_OB_GetWRP+0xa4>
    *WRPStartOffset = READ_BIT(FLASH->WRP2AR, FLASH_WRP2AR_WRP2A_PSTRT);
 800f658:	4b19      	ldr	r3, [pc, #100]	@ (800f6c0 <FLASH_OB_GetWRP+0xe0>)
 800f65a:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 800f65c:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
 800f660:	68bb      	ldr	r3, [r7, #8]
 800f662:	601a      	str	r2, [r3, #0]
    *WRPEndOffset = (READ_BIT(FLASH->WRP2AR, FLASH_WRP2AR_WRP2A_PEND) >> FLASH_WRP2AR_WRP2A_PEND_Pos);
 800f664:	4b16      	ldr	r3, [pc, #88]	@ (800f6c0 <FLASH_OB_GetWRP+0xe0>)
 800f666:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 800f668:	0c1b      	lsrs	r3, r3, #16
 800f66a:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
 800f66e:	687b      	ldr	r3, [r7, #4]
 800f670:	601a      	str	r2, [r3, #0]
    *WRPLock = (READ_BIT(FLASH->WRP2AR, FLASH_WRP2AR_UNLOCK) != 0U) ? DISABLE : ENABLE;
 800f672:	4b13      	ldr	r3, [pc, #76]	@ (800f6c0 <FLASH_OB_GetWRP+0xe0>)
 800f674:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 800f676:	43db      	mvns	r3, r3
 800f678:	0fdb      	lsrs	r3, r3, #31
 800f67a:	b2db      	uxtb	r3, r3
 800f67c:	461a      	mov	r2, r3
 800f67e:	683b      	ldr	r3, [r7, #0]
 800f680:	701a      	strb	r2, [r3, #0]
}
 800f682:	e017      	b.n	800f6b4 <FLASH_OB_GetWRP+0xd4>
  else if (WRPArea == OB_WRPAREA_BANK2_AREAB)
 800f684:	68fb      	ldr	r3, [r7, #12]
 800f686:	2b08      	cmp	r3, #8
 800f688:	d114      	bne.n	800f6b4 <FLASH_OB_GetWRP+0xd4>
    *WRPStartOffset = READ_BIT(FLASH->WRP2BR, FLASH_WRP2BR_WRP2B_PSTRT);
 800f68a:	4b0d      	ldr	r3, [pc, #52]	@ (800f6c0 <FLASH_OB_GetWRP+0xe0>)
 800f68c:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 800f68e:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
 800f692:	68bb      	ldr	r3, [r7, #8]
 800f694:	601a      	str	r2, [r3, #0]
    *WRPEndOffset = (READ_BIT(FLASH->WRP2BR, FLASH_WRP2BR_WRP2B_PEND) >> FLASH_WRP2BR_WRP2B_PEND_Pos);
 800f696:	4b0a      	ldr	r3, [pc, #40]	@ (800f6c0 <FLASH_OB_GetWRP+0xe0>)
 800f698:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 800f69a:	0c1b      	lsrs	r3, r3, #16
 800f69c:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
 800f6a0:	687b      	ldr	r3, [r7, #4]
 800f6a2:	601a      	str	r2, [r3, #0]
    *WRPLock = (READ_BIT(FLASH->WRP2BR, FLASH_WRP2BR_UNLOCK) != 0U) ? DISABLE : ENABLE;
 800f6a4:	4b06      	ldr	r3, [pc, #24]	@ (800f6c0 <FLASH_OB_GetWRP+0xe0>)
 800f6a6:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 800f6a8:	43db      	mvns	r3, r3
 800f6aa:	0fdb      	lsrs	r3, r3, #31
 800f6ac:	b2db      	uxtb	r3, r3
 800f6ae:	461a      	mov	r2, r3
 800f6b0:	683b      	ldr	r3, [r7, #0]
 800f6b2:	701a      	strb	r2, [r3, #0]
}
 800f6b4:	bf00      	nop
 800f6b6:	3714      	adds	r7, #20
 800f6b8:	46bd      	mov	sp, r7
 800f6ba:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f6be:	4770      	bx	lr
 800f6c0:	40022000 	.word	0x40022000

0800f6c4 <FLASH_OB_GetRDP>:
  *            @arg OB_RDP_LEVEL_0_5: No debug access to secure area
  *            @arg OB_RDP_LEVEL_1: Read protection of the memory
  *            @arg OB_RDP_LEVEL_2: Full chip protection
  */
static uint32_t FLASH_OB_GetRDP(void)
{
 800f6c4:	b480      	push	{r7}
 800f6c6:	b083      	sub	sp, #12
 800f6c8:	af00      	add	r7, sp, #0
  uint32_t rdp_level = READ_BIT(FLASH->OPTR, FLASH_OPTR_RDP);
 800f6ca:	4b0b      	ldr	r3, [pc, #44]	@ (800f6f8 <FLASH_OB_GetRDP+0x34>)
 800f6cc:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800f6ce:	b2db      	uxtb	r3, r3
 800f6d0:	607b      	str	r3, [r7, #4]

  if ((rdp_level != OB_RDP_LEVEL_0) && (rdp_level != OB_RDP_LEVEL_0_5) && (rdp_level != OB_RDP_LEVEL_2))
 800f6d2:	687b      	ldr	r3, [r7, #4]
 800f6d4:	2baa      	cmp	r3, #170	@ 0xaa
 800f6d6:	d007      	beq.n	800f6e8 <FLASH_OB_GetRDP+0x24>
 800f6d8:	687b      	ldr	r3, [r7, #4]
 800f6da:	2b55      	cmp	r3, #85	@ 0x55
 800f6dc:	d004      	beq.n	800f6e8 <FLASH_OB_GetRDP+0x24>
 800f6de:	687b      	ldr	r3, [r7, #4]
 800f6e0:	2bcc      	cmp	r3, #204	@ 0xcc
 800f6e2:	d001      	beq.n	800f6e8 <FLASH_OB_GetRDP+0x24>
  {
    return (OB_RDP_LEVEL_1);
 800f6e4:	23bb      	movs	r3, #187	@ 0xbb
 800f6e6:	e000      	b.n	800f6ea <FLASH_OB_GetRDP+0x26>
  }
  else
  {
    return rdp_level;
 800f6e8:	687b      	ldr	r3, [r7, #4]
  }
}
 800f6ea:	4618      	mov	r0, r3
 800f6ec:	370c      	adds	r7, #12
 800f6ee:	46bd      	mov	sp, r7
 800f6f0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f6f4:	4770      	bx	lr
 800f6f6:	bf00      	nop
 800f6f8:	40022000 	.word	0x40022000

0800f6fc <FLASH_OB_GetUser>:
  *         @ref FLASH_OB_USER_nSWBOOT0, @ref FLASH_OB_USER_nBOOT0,
  *         @ref FLASH_OB_USER_PA15_PUPEN, @ref FLASH_OB_USER_IO_VDD_HSLV,
  *         @ref FLASH_OB_USER_IO_VDDIO2_HSLV and @ref OB_USER_TZEN
  */
static uint32_t FLASH_OB_GetUser(void)
{
 800f6fc:	b480      	push	{r7}
 800f6fe:	b083      	sub	sp, #12
 800f700:	af00      	add	r7, sp, #0
  uint32_t user_config = READ_REG(FLASH->OPTR);
 800f702:	4b07      	ldr	r3, [pc, #28]	@ (800f720 <FLASH_OB_GetUser+0x24>)
 800f704:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800f706:	607b      	str	r3, [r7, #4]
  CLEAR_BIT(user_config, FLASH_OPTR_RDP);
 800f708:	687b      	ldr	r3, [r7, #4]
 800f70a:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
 800f70e:	607b      	str	r3, [r7, #4]

  return user_config;
 800f710:	687b      	ldr	r3, [r7, #4]
}
 800f712:	4618      	mov	r0, r3
 800f714:	370c      	adds	r7, #12
 800f716:	46bd      	mov	sp, r7
 800f718:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f71c:	4770      	bx	lr
 800f71e:	bf00      	nop
 800f720:	40022000 	.word	0x40022000

0800f724 <FLASH_OB_GetBootAddr>:
  * @param[out]  BootAddr specifies the boot address value
  *
  * @retval None
  */
static void FLASH_OB_GetBootAddr(uint32_t BootAddrConfig, uint32_t *BootAddr)
{
 800f724:	b480      	push	{r7}
 800f726:	b083      	sub	sp, #12
 800f728:	af00      	add	r7, sp, #0
 800f72a:	6078      	str	r0, [r7, #4]
 800f72c:	6039      	str	r1, [r7, #0]
  if (BootAddrConfig == OB_BOOTADDR_NS0)
 800f72e:	687b      	ldr	r3, [r7, #4]
 800f730:	2b01      	cmp	r3, #1
 800f732:	d106      	bne.n	800f742 <FLASH_OB_GetBootAddr+0x1e>
  {
    *BootAddr = (FLASH->NSBOOTADD0R & FLASH_NSBOOTADD0R_NSBOOTADD0);
 800f734:	4b0a      	ldr	r3, [pc, #40]	@ (800f760 <FLASH_OB_GetBootAddr+0x3c>)
 800f736:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800f738:	f023 027f 	bic.w	r2, r3, #127	@ 0x7f
 800f73c:	683b      	ldr	r3, [r7, #0]
 800f73e:	601a      	str	r2, [r3, #0]
#endif /* __ARM_FEATURE_CMSE */
  else
  {
    /* Empty statement (to be compliant MISRA 15.7) */
  }
}
 800f740:	e008      	b.n	800f754 <FLASH_OB_GetBootAddr+0x30>
  else if (BootAddrConfig == OB_BOOTADDR_NS1)
 800f742:	687b      	ldr	r3, [r7, #4]
 800f744:	2b02      	cmp	r3, #2
 800f746:	d105      	bne.n	800f754 <FLASH_OB_GetBootAddr+0x30>
    *BootAddr = (FLASH->NSBOOTADD1R & FLASH_NSBOOTADD1R_NSBOOTADD1);
 800f748:	4b05      	ldr	r3, [pc, #20]	@ (800f760 <FLASH_OB_GetBootAddr+0x3c>)
 800f74a:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 800f74c:	f023 027f 	bic.w	r2, r3, #127	@ 0x7f
 800f750:	683b      	ldr	r3, [r7, #0]
 800f752:	601a      	str	r2, [r3, #0]
}
 800f754:	bf00      	nop
 800f756:	370c      	adds	r7, #12
 800f758:	46bd      	mov	sp, r7
 800f75a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f75e:	4770      	bx	lr
 800f760:	40022000 	.word	0x40022000

0800f764 <HAL_GPIO_Init>:
  * @param  pGPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, const GPIO_InitTypeDef *pGPIO_Init)
{
 800f764:	b480      	push	{r7}
 800f766:	b089      	sub	sp, #36	@ 0x24
 800f768:	af00      	add	r7, sp, #0
 800f76a:	6078      	str	r0, [r7, #4]
 800f76c:	6039      	str	r1, [r7, #0]
  uint32_t tmp;
  uint32_t iocurrent;
  uint32_t pin_position;
  uint32_t position = 0U;
 800f76e:	2300      	movs	r3, #0
 800f770:	617b      	str	r3, [r7, #20]
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(pGPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(pGPIO_Init->Mode));

  /* Save GPIO port address */
  p_gpio = GPIOx;
 800f772:	687b      	ldr	r3, [r7, #4]
 800f774:	613b      	str	r3, [r7, #16]

  /* Configure the port pins */
  while (((pGPIO_Init->Pin) >> position) != 0U)
 800f776:	e1ba      	b.n	800faee <HAL_GPIO_Init+0x38a>
  {
    /* Get current io position */
    iocurrent = (pGPIO_Init->Pin) & (1UL << position);
 800f778:	683b      	ldr	r3, [r7, #0]
 800f77a:	681a      	ldr	r2, [r3, #0]
 800f77c:	2101      	movs	r1, #1
 800f77e:	697b      	ldr	r3, [r7, #20]
 800f780:	fa01 f303 	lsl.w	r3, r1, r3
 800f784:	4013      	ands	r3, r2
 800f786:	60fb      	str	r3, [r7, #12]

    /* Save Pin Position */
    pin_position = position;
 800f788:	697b      	ldr	r3, [r7, #20]
 800f78a:	61bb      	str	r3, [r7, #24]

    if (iocurrent != 0U)
 800f78c:	68fb      	ldr	r3, [r7, #12]
 800f78e:	2b00      	cmp	r3, #0
 800f790:	f000 81aa 	beq.w	800fae8 <HAL_GPIO_Init+0x384>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Alternate function mode selection */
      if (GPIOx == LPGPIO1)
 800f794:	687b      	ldr	r3, [r7, #4]
 800f796:	4a55      	ldr	r2, [pc, #340]	@ (800f8ec <HAL_GPIO_Init+0x188>)
 800f798:	4293      	cmp	r3, r2
 800f79a:	d15d      	bne.n	800f858 <HAL_GPIO_Init+0xf4>
      {
        /* MODER configuration */
        tmp = GPIOx->MODER;
 800f79c:	687b      	ldr	r3, [r7, #4]
 800f79e:	681b      	ldr	r3, [r3, #0]
 800f7a0:	61fb      	str	r3, [r7, #28]
        tmp &= ~(LPGPIO_MODER_MOD0 << position);
 800f7a2:	2201      	movs	r2, #1
 800f7a4:	697b      	ldr	r3, [r7, #20]
 800f7a6:	fa02 f303 	lsl.w	r3, r2, r3
 800f7aa:	43db      	mvns	r3, r3
 800f7ac:	69fa      	ldr	r2, [r7, #28]
 800f7ae:	4013      	ands	r3, r2
 800f7b0:	61fb      	str	r3, [r7, #28]
        tmp |= ((pGPIO_Init->Mode & GPIO_MODE_OUTPUT_PP) << position);
 800f7b2:	683b      	ldr	r3, [r7, #0]
 800f7b4:	685b      	ldr	r3, [r3, #4]
 800f7b6:	f003 0201 	and.w	r2, r3, #1
 800f7ba:	697b      	ldr	r3, [r7, #20]
 800f7bc:	fa02 f303 	lsl.w	r3, r2, r3
 800f7c0:	69fa      	ldr	r2, [r7, #28]
 800f7c2:	4313      	orrs	r3, r2
 800f7c4:	61fb      	str	r3, [r7, #28]
        GPIOx->MODER = tmp;
 800f7c6:	687b      	ldr	r3, [r7, #4]
 800f7c8:	69fa      	ldr	r2, [r7, #28]
 800f7ca:	601a      	str	r2, [r3, #0]

        /* Save GPIO Port and pin index */
        p_gpio = LPGPIO_Map[position].GPIO_PORT;
 800f7cc:	4a48      	ldr	r2, [pc, #288]	@ (800f8f0 <HAL_GPIO_Init+0x18c>)
 800f7ce:	697b      	ldr	r3, [r7, #20]
 800f7d0:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 800f7d4:	613b      	str	r3, [r7, #16]
        pin_position = LPGPIO_Map[position].Pin_Pos;
 800f7d6:	4a46      	ldr	r2, [pc, #280]	@ (800f8f0 <HAL_GPIO_Init+0x18c>)
 800f7d8:	697b      	ldr	r3, [r7, #20]
 800f7da:	00db      	lsls	r3, r3, #3
 800f7dc:	4413      	add	r3, r2
 800f7de:	685b      	ldr	r3, [r3, #4]
 800f7e0:	61bb      	str	r3, [r7, #24]

        /* Configure Alternate function mapped with the current IO */
        tmp = p_gpio->AFR[(pin_position) >> 3U];
 800f7e2:	69bb      	ldr	r3, [r7, #24]
 800f7e4:	08da      	lsrs	r2, r3, #3
 800f7e6:	693b      	ldr	r3, [r7, #16]
 800f7e8:	3208      	adds	r2, #8
 800f7ea:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800f7ee:	61fb      	str	r3, [r7, #28]
        tmp &= ~(0x0FUL << (((pin_position) & 0x07U) * 4U));
 800f7f0:	69bb      	ldr	r3, [r7, #24]
 800f7f2:	f003 0307 	and.w	r3, r3, #7
 800f7f6:	009b      	lsls	r3, r3, #2
 800f7f8:	220f      	movs	r2, #15
 800f7fa:	fa02 f303 	lsl.w	r3, r2, r3
 800f7fe:	43db      	mvns	r3, r3
 800f800:	69fa      	ldr	r2, [r7, #28]
 800f802:	4013      	ands	r3, r2
 800f804:	61fb      	str	r3, [r7, #28]
        tmp |= ((GPIO_AF11_LPGPIO1 & 0x0FUL) << (((pin_position) & 0x07U) * 4U));
 800f806:	69bb      	ldr	r3, [r7, #24]
 800f808:	f003 0307 	and.w	r3, r3, #7
 800f80c:	009b      	lsls	r3, r3, #2
 800f80e:	220b      	movs	r2, #11
 800f810:	fa02 f303 	lsl.w	r3, r2, r3
 800f814:	69fa      	ldr	r2, [r7, #28]
 800f816:	4313      	orrs	r3, r2
 800f818:	61fb      	str	r3, [r7, #28]
        p_gpio->AFR[(pin_position) >> 3U] = tmp;
 800f81a:	69bb      	ldr	r3, [r7, #24]
 800f81c:	08da      	lsrs	r2, r3, #3
 800f81e:	693b      	ldr	r3, [r7, #16]
 800f820:	3208      	adds	r2, #8
 800f822:	69f9      	ldr	r1, [r7, #28]
 800f824:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

        /* Configure IO Direction mode (Alternate) */
        tmp = p_gpio->MODER;
 800f828:	693b      	ldr	r3, [r7, #16]
 800f82a:	681b      	ldr	r3, [r3, #0]
 800f82c:	61fb      	str	r3, [r7, #28]
        tmp &= ~(GPIO_MODER_MODE0 << (pin_position * GPIO_MODER_MODE1_Pos));
 800f82e:	69bb      	ldr	r3, [r7, #24]
 800f830:	005b      	lsls	r3, r3, #1
 800f832:	2203      	movs	r2, #3
 800f834:	fa02 f303 	lsl.w	r3, r2, r3
 800f838:	43db      	mvns	r3, r3
 800f83a:	69fa      	ldr	r2, [r7, #28]
 800f83c:	4013      	ands	r3, r2
 800f83e:	61fb      	str	r3, [r7, #28]
        tmp |= ((GPIO_MODE_AF_PP & 0x0FUL) << (pin_position * GPIO_MODER_MODE1_Pos));
 800f840:	69bb      	ldr	r3, [r7, #24]
 800f842:	005b      	lsls	r3, r3, #1
 800f844:	2202      	movs	r2, #2
 800f846:	fa02 f303 	lsl.w	r3, r2, r3
 800f84a:	69fa      	ldr	r2, [r7, #28]
 800f84c:	4313      	orrs	r3, r2
 800f84e:	61fb      	str	r3, [r7, #28]
        p_gpio->MODER = tmp;
 800f850:	693b      	ldr	r3, [r7, #16]
 800f852:	69fa      	ldr	r2, [r7, #28]
 800f854:	601a      	str	r2, [r3, #0]
 800f856:	e067      	b.n	800f928 <HAL_GPIO_Init+0x1c4>
      }
      else if ((pGPIO_Init->Mode == GPIO_MODE_AF_PP) || (pGPIO_Init->Mode == GPIO_MODE_AF_OD))
 800f858:	683b      	ldr	r3, [r7, #0]
 800f85a:	685b      	ldr	r3, [r3, #4]
 800f85c:	2b02      	cmp	r3, #2
 800f85e:	d003      	beq.n	800f868 <HAL_GPIO_Init+0x104>
 800f860:	683b      	ldr	r3, [r7, #0]
 800f862:	685b      	ldr	r3, [r3, #4]
 800f864:	2b12      	cmp	r3, #18
 800f866:	d145      	bne.n	800f8f4 <HAL_GPIO_Init+0x190>
        assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(pGPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        tmp = GPIOx->AFR[position >> 3U];
 800f868:	697b      	ldr	r3, [r7, #20]
 800f86a:	08da      	lsrs	r2, r3, #3
 800f86c:	687b      	ldr	r3, [r7, #4]
 800f86e:	3208      	adds	r2, #8
 800f870:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800f874:	61fb      	str	r3, [r7, #28]
        tmp &= ~(0x0FUL << ((position & 0x07U) * GPIO_AFRL_AFSEL1_Pos));
 800f876:	697b      	ldr	r3, [r7, #20]
 800f878:	f003 0307 	and.w	r3, r3, #7
 800f87c:	009b      	lsls	r3, r3, #2
 800f87e:	220f      	movs	r2, #15
 800f880:	fa02 f303 	lsl.w	r3, r2, r3
 800f884:	43db      	mvns	r3, r3
 800f886:	69fa      	ldr	r2, [r7, #28]
 800f888:	4013      	ands	r3, r2
 800f88a:	61fb      	str	r3, [r7, #28]
        tmp |= ((pGPIO_Init->Alternate & 0x0FUL) << ((position & 0x07U) * GPIO_AFRL_AFSEL1_Pos));
 800f88c:	683b      	ldr	r3, [r7, #0]
 800f88e:	691b      	ldr	r3, [r3, #16]
 800f890:	f003 020f 	and.w	r2, r3, #15
 800f894:	697b      	ldr	r3, [r7, #20]
 800f896:	f003 0307 	and.w	r3, r3, #7
 800f89a:	009b      	lsls	r3, r3, #2
 800f89c:	fa02 f303 	lsl.w	r3, r2, r3
 800f8a0:	69fa      	ldr	r2, [r7, #28]
 800f8a2:	4313      	orrs	r3, r2
 800f8a4:	61fb      	str	r3, [r7, #28]
        GPIOx->AFR[position >> 3U] = tmp;
 800f8a6:	697b      	ldr	r3, [r7, #20]
 800f8a8:	08da      	lsrs	r2, r3, #3
 800f8aa:	687b      	ldr	r3, [r7, #4]
 800f8ac:	3208      	adds	r2, #8
 800f8ae:	69f9      	ldr	r1, [r7, #28]
 800f8b0:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

        /* Configure IO Direction mode (Alternate) */
        tmp = p_gpio->MODER;
 800f8b4:	693b      	ldr	r3, [r7, #16]
 800f8b6:	681b      	ldr	r3, [r3, #0]
 800f8b8:	61fb      	str	r3, [r7, #28]
        tmp &= ~(GPIO_MODER_MODE0 << (pin_position * GPIO_MODER_MODE1_Pos));
 800f8ba:	69bb      	ldr	r3, [r7, #24]
 800f8bc:	005b      	lsls	r3, r3, #1
 800f8be:	2203      	movs	r2, #3
 800f8c0:	fa02 f303 	lsl.w	r3, r2, r3
 800f8c4:	43db      	mvns	r3, r3
 800f8c6:	69fa      	ldr	r2, [r7, #28]
 800f8c8:	4013      	ands	r3, r2
 800f8ca:	61fb      	str	r3, [r7, #28]
        tmp |= ((pGPIO_Init->Mode & GPIO_MODE) << (pin_position * GPIO_MODER_MODE1_Pos));
 800f8cc:	683b      	ldr	r3, [r7, #0]
 800f8ce:	685b      	ldr	r3, [r3, #4]
 800f8d0:	f003 0203 	and.w	r2, r3, #3
 800f8d4:	69bb      	ldr	r3, [r7, #24]
 800f8d6:	005b      	lsls	r3, r3, #1
 800f8d8:	fa02 f303 	lsl.w	r3, r2, r3
 800f8dc:	69fa      	ldr	r2, [r7, #28]
 800f8de:	4313      	orrs	r3, r2
 800f8e0:	61fb      	str	r3, [r7, #28]
        p_gpio->MODER = tmp;
 800f8e2:	693b      	ldr	r3, [r7, #16]
 800f8e4:	69fa      	ldr	r2, [r7, #28]
 800f8e6:	601a      	str	r2, [r3, #0]
 800f8e8:	e01e      	b.n	800f928 <HAL_GPIO_Init+0x1c4>
 800f8ea:	bf00      	nop
 800f8ec:	46020000 	.word	0x46020000
 800f8f0:	0802a520 	.word	0x0802a520
      {
        /* Check the parameters */
        assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));

        /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
        tmp = p_gpio->MODER;
 800f8f4:	693b      	ldr	r3, [r7, #16]
 800f8f6:	681b      	ldr	r3, [r3, #0]
 800f8f8:	61fb      	str	r3, [r7, #28]
        tmp &= ~(GPIO_MODER_MODE0 << (pin_position * GPIO_MODER_MODE1_Pos));
 800f8fa:	69bb      	ldr	r3, [r7, #24]
 800f8fc:	005b      	lsls	r3, r3, #1
 800f8fe:	2203      	movs	r2, #3
 800f900:	fa02 f303 	lsl.w	r3, r2, r3
 800f904:	43db      	mvns	r3, r3
 800f906:	69fa      	ldr	r2, [r7, #28]
 800f908:	4013      	ands	r3, r2
 800f90a:	61fb      	str	r3, [r7, #28]
        tmp |= ((pGPIO_Init->Mode & GPIO_MODE) << (pin_position * GPIO_MODER_MODE1_Pos));
 800f90c:	683b      	ldr	r3, [r7, #0]
 800f90e:	685b      	ldr	r3, [r3, #4]
 800f910:	f003 0203 	and.w	r2, r3, #3
 800f914:	69bb      	ldr	r3, [r7, #24]
 800f916:	005b      	lsls	r3, r3, #1
 800f918:	fa02 f303 	lsl.w	r3, r2, r3
 800f91c:	69fa      	ldr	r2, [r7, #28]
 800f91e:	4313      	orrs	r3, r2
 800f920:	61fb      	str	r3, [r7, #28]
        p_gpio->MODER = tmp;
 800f922:	693b      	ldr	r3, [r7, #16]
 800f924:	69fa      	ldr	r2, [r7, #28]
 800f926:	601a      	str	r2, [r3, #0]
      }

      /* In case of Output or Alternate function mode selection */
      if ((pGPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (pGPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 800f928:	683b      	ldr	r3, [r7, #0]
 800f92a:	685b      	ldr	r3, [r3, #4]
 800f92c:	2b01      	cmp	r3, #1
 800f92e:	d00b      	beq.n	800f948 <HAL_GPIO_Init+0x1e4>
 800f930:	683b      	ldr	r3, [r7, #0]
 800f932:	685b      	ldr	r3, [r3, #4]
 800f934:	2b02      	cmp	r3, #2
 800f936:	d007      	beq.n	800f948 <HAL_GPIO_Init+0x1e4>
          (pGPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (pGPIO_Init->Mode == GPIO_MODE_AF_OD))
 800f938:	683b      	ldr	r3, [r7, #0]
 800f93a:	685b      	ldr	r3, [r3, #4]
      if ((pGPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (pGPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 800f93c:	2b11      	cmp	r3, #17
 800f93e:	d003      	beq.n	800f948 <HAL_GPIO_Init+0x1e4>
          (pGPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (pGPIO_Init->Mode == GPIO_MODE_AF_OD))
 800f940:	683b      	ldr	r3, [r7, #0]
 800f942:	685b      	ldr	r3, [r3, #4]
 800f944:	2b12      	cmp	r3, #18
 800f946:	d130      	bne.n	800f9aa <HAL_GPIO_Init+0x246>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(pGPIO_Init->Speed));

        /* Configure the IO Speed */
        tmp = p_gpio->OSPEEDR;
 800f948:	693b      	ldr	r3, [r7, #16]
 800f94a:	689b      	ldr	r3, [r3, #8]
 800f94c:	61fb      	str	r3, [r7, #28]
        tmp &= ~(GPIO_OSPEEDR_OSPEED0 << (pin_position * GPIO_OSPEEDR_OSPEED1_Pos));
 800f94e:	69bb      	ldr	r3, [r7, #24]
 800f950:	005b      	lsls	r3, r3, #1
 800f952:	2203      	movs	r2, #3
 800f954:	fa02 f303 	lsl.w	r3, r2, r3
 800f958:	43db      	mvns	r3, r3
 800f95a:	69fa      	ldr	r2, [r7, #28]
 800f95c:	4013      	ands	r3, r2
 800f95e:	61fb      	str	r3, [r7, #28]
        tmp |= (pGPIO_Init->Speed << (pin_position * GPIO_OSPEEDR_OSPEED1_Pos));
 800f960:	683b      	ldr	r3, [r7, #0]
 800f962:	68da      	ldr	r2, [r3, #12]
 800f964:	69bb      	ldr	r3, [r7, #24]
 800f966:	005b      	lsls	r3, r3, #1
 800f968:	fa02 f303 	lsl.w	r3, r2, r3
 800f96c:	69fa      	ldr	r2, [r7, #28]
 800f96e:	4313      	orrs	r3, r2
 800f970:	61fb      	str	r3, [r7, #28]
        p_gpio->OSPEEDR = tmp;
 800f972:	693b      	ldr	r3, [r7, #16]
 800f974:	69fa      	ldr	r2, [r7, #28]
 800f976:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        tmp = p_gpio->OTYPER;
 800f978:	693b      	ldr	r3, [r7, #16]
 800f97a:	685b      	ldr	r3, [r3, #4]
 800f97c:	61fb      	str	r3, [r7, #28]
        tmp &= ~(GPIO_OTYPER_OT0 << pin_position);
 800f97e:	2201      	movs	r2, #1
 800f980:	69bb      	ldr	r3, [r7, #24]
 800f982:	fa02 f303 	lsl.w	r3, r2, r3
 800f986:	43db      	mvns	r3, r3
 800f988:	69fa      	ldr	r2, [r7, #28]
 800f98a:	4013      	ands	r3, r2
 800f98c:	61fb      	str	r3, [r7, #28]
        tmp |= (((pGPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << pin_position);
 800f98e:	683b      	ldr	r3, [r7, #0]
 800f990:	685b      	ldr	r3, [r3, #4]
 800f992:	091b      	lsrs	r3, r3, #4
 800f994:	f003 0201 	and.w	r2, r3, #1
 800f998:	69bb      	ldr	r3, [r7, #24]
 800f99a:	fa02 f303 	lsl.w	r3, r2, r3
 800f99e:	69fa      	ldr	r2, [r7, #28]
 800f9a0:	4313      	orrs	r3, r2
 800f9a2:	61fb      	str	r3, [r7, #28]
        p_gpio->OTYPER = tmp;
 800f9a4:	693b      	ldr	r3, [r7, #16]
 800f9a6:	69fa      	ldr	r2, [r7, #28]
 800f9a8:	605a      	str	r2, [r3, #4]
      }

      if (pGPIO_Init->Mode != GPIO_MODE_ANALOG)
 800f9aa:	683b      	ldr	r3, [r7, #0]
 800f9ac:	685b      	ldr	r3, [r3, #4]
 800f9ae:	2b03      	cmp	r3, #3
 800f9b0:	d017      	beq.n	800f9e2 <HAL_GPIO_Init+0x27e>
      {
        /* Check the Pull parameters */
        assert_param(IS_GPIO_PULL(pGPIO_Init->Pull));

        /* Activate the Pull-up or Pull down resistor for the current IO */
        tmp = p_gpio->PUPDR;
 800f9b2:	693b      	ldr	r3, [r7, #16]
 800f9b4:	68db      	ldr	r3, [r3, #12]
 800f9b6:	61fb      	str	r3, [r7, #28]
        tmp &= ~(GPIO_PUPDR_PUPD0 << (pin_position * GPIO_PUPDR_PUPD1_Pos));
 800f9b8:	69bb      	ldr	r3, [r7, #24]
 800f9ba:	005b      	lsls	r3, r3, #1
 800f9bc:	2203      	movs	r2, #3
 800f9be:	fa02 f303 	lsl.w	r3, r2, r3
 800f9c2:	43db      	mvns	r3, r3
 800f9c4:	69fa      	ldr	r2, [r7, #28]
 800f9c6:	4013      	ands	r3, r2
 800f9c8:	61fb      	str	r3, [r7, #28]
        tmp |= ((pGPIO_Init->Pull) << (pin_position * GPIO_PUPDR_PUPD1_Pos));
 800f9ca:	683b      	ldr	r3, [r7, #0]
 800f9cc:	689a      	ldr	r2, [r3, #8]
 800f9ce:	69bb      	ldr	r3, [r7, #24]
 800f9d0:	005b      	lsls	r3, r3, #1
 800f9d2:	fa02 f303 	lsl.w	r3, r2, r3
 800f9d6:	69fa      	ldr	r2, [r7, #28]
 800f9d8:	4313      	orrs	r3, r2
 800f9da:	61fb      	str	r3, [r7, #28]
        p_gpio->PUPDR = tmp;
 800f9dc:	693b      	ldr	r3, [r7, #16]
 800f9de:	69fa      	ldr	r2, [r7, #28]
 800f9e0:	60da      	str	r2, [r3, #12]
      }

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((pGPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 800f9e2:	683b      	ldr	r3, [r7, #0]
 800f9e4:	685b      	ldr	r3, [r3, #4]
 800f9e6:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 800f9ea:	2b00      	cmp	r3, #0
 800f9ec:	d07c      	beq.n	800fae8 <HAL_GPIO_Init+0x384>
      {
        tmp = EXTI->EXTICR[position >> 2U];
 800f9ee:	4a47      	ldr	r2, [pc, #284]	@ (800fb0c <HAL_GPIO_Init+0x3a8>)
 800f9f0:	697b      	ldr	r3, [r7, #20]
 800f9f2:	089b      	lsrs	r3, r3, #2
 800f9f4:	3318      	adds	r3, #24
 800f9f6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800f9fa:	61fb      	str	r3, [r7, #28]
        tmp &= ~((0x0FUL) << (EXTI_EXTICR1_EXTI1_Pos * (position & 0x03U)));
 800f9fc:	697b      	ldr	r3, [r7, #20]
 800f9fe:	f003 0303 	and.w	r3, r3, #3
 800fa02:	00db      	lsls	r3, r3, #3
 800fa04:	220f      	movs	r2, #15
 800fa06:	fa02 f303 	lsl.w	r3, r2, r3
 800fa0a:	43db      	mvns	r3, r3
 800fa0c:	69fa      	ldr	r2, [r7, #28]
 800fa0e:	4013      	ands	r3, r2
 800fa10:	61fb      	str	r3, [r7, #28]
        tmp |= (GPIO_GET_INDEX(GPIOx) << (EXTI_EXTICR1_EXTI1_Pos * (position & 0x03U)));
 800fa12:	687b      	ldr	r3, [r7, #4]
 800fa14:	0a9a      	lsrs	r2, r3, #10
 800fa16:	4b3e      	ldr	r3, [pc, #248]	@ (800fb10 <HAL_GPIO_Init+0x3ac>)
 800fa18:	4013      	ands	r3, r2
 800fa1a:	697a      	ldr	r2, [r7, #20]
 800fa1c:	f002 0203 	and.w	r2, r2, #3
 800fa20:	00d2      	lsls	r2, r2, #3
 800fa22:	4093      	lsls	r3, r2
 800fa24:	69fa      	ldr	r2, [r7, #28]
 800fa26:	4313      	orrs	r3, r2
 800fa28:	61fb      	str	r3, [r7, #28]
        EXTI->EXTICR[position >> 2U] = tmp;
 800fa2a:	4938      	ldr	r1, [pc, #224]	@ (800fb0c <HAL_GPIO_Init+0x3a8>)
 800fa2c:	697b      	ldr	r3, [r7, #20]
 800fa2e:	089b      	lsrs	r3, r3, #2
 800fa30:	3318      	adds	r3, #24
 800fa32:	69fa      	ldr	r2, [r7, #28]
 800fa34:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear Rising Falling edge configuration */
        tmp = EXTI->RTSR1;
 800fa38:	4b34      	ldr	r3, [pc, #208]	@ (800fb0c <HAL_GPIO_Init+0x3a8>)
 800fa3a:	681b      	ldr	r3, [r3, #0]
 800fa3c:	61fb      	str	r3, [r7, #28]
        tmp &= ~((uint32_t)iocurrent);
 800fa3e:	68fb      	ldr	r3, [r7, #12]
 800fa40:	43db      	mvns	r3, r3
 800fa42:	69fa      	ldr	r2, [r7, #28]
 800fa44:	4013      	ands	r3, r2
 800fa46:	61fb      	str	r3, [r7, #28]
        if ((pGPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 800fa48:	683b      	ldr	r3, [r7, #0]
 800fa4a:	685b      	ldr	r3, [r3, #4]
 800fa4c:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
 800fa50:	2b00      	cmp	r3, #0
 800fa52:	d003      	beq.n	800fa5c <HAL_GPIO_Init+0x2f8>
        {
          tmp |= iocurrent;
 800fa54:	69fa      	ldr	r2, [r7, #28]
 800fa56:	68fb      	ldr	r3, [r7, #12]
 800fa58:	4313      	orrs	r3, r2
 800fa5a:	61fb      	str	r3, [r7, #28]
        }
        EXTI->RTSR1 = tmp;
 800fa5c:	4a2b      	ldr	r2, [pc, #172]	@ (800fb0c <HAL_GPIO_Init+0x3a8>)
 800fa5e:	69fb      	ldr	r3, [r7, #28]
 800fa60:	6013      	str	r3, [r2, #0]

        tmp = EXTI->FTSR1;
 800fa62:	4b2a      	ldr	r3, [pc, #168]	@ (800fb0c <HAL_GPIO_Init+0x3a8>)
 800fa64:	685b      	ldr	r3, [r3, #4]
 800fa66:	61fb      	str	r3, [r7, #28]
        tmp &= ~((uint32_t)iocurrent);
 800fa68:	68fb      	ldr	r3, [r7, #12]
 800fa6a:	43db      	mvns	r3, r3
 800fa6c:	69fa      	ldr	r2, [r7, #28]
 800fa6e:	4013      	ands	r3, r2
 800fa70:	61fb      	str	r3, [r7, #28]
        if ((pGPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 800fa72:	683b      	ldr	r3, [r7, #0]
 800fa74:	685b      	ldr	r3, [r3, #4]
 800fa76:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
 800fa7a:	2b00      	cmp	r3, #0
 800fa7c:	d003      	beq.n	800fa86 <HAL_GPIO_Init+0x322>
        {
          tmp |= iocurrent;
 800fa7e:	69fa      	ldr	r2, [r7, #28]
 800fa80:	68fb      	ldr	r3, [r7, #12]
 800fa82:	4313      	orrs	r3, r2
 800fa84:	61fb      	str	r3, [r7, #28]
        }
        EXTI->FTSR1 = tmp;
 800fa86:	4a21      	ldr	r2, [pc, #132]	@ (800fb0c <HAL_GPIO_Init+0x3a8>)
 800fa88:	69fb      	ldr	r3, [r7, #28]
 800fa8a:	6053      	str	r3, [r2, #4]

        /* Clear EXTI line configuration */
        tmp = EXTI->EMR1;
 800fa8c:	4b1f      	ldr	r3, [pc, #124]	@ (800fb0c <HAL_GPIO_Init+0x3a8>)
 800fa8e:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 800fa92:	61fb      	str	r3, [r7, #28]
        tmp &= ~((uint32_t)iocurrent);
 800fa94:	68fb      	ldr	r3, [r7, #12]
 800fa96:	43db      	mvns	r3, r3
 800fa98:	69fa      	ldr	r2, [r7, #28]
 800fa9a:	4013      	ands	r3, r2
 800fa9c:	61fb      	str	r3, [r7, #28]
        if ((pGPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 800fa9e:	683b      	ldr	r3, [r7, #0]
 800faa0:	685b      	ldr	r3, [r3, #4]
 800faa2:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 800faa6:	2b00      	cmp	r3, #0
 800faa8:	d003      	beq.n	800fab2 <HAL_GPIO_Init+0x34e>
        {
          tmp |= iocurrent;
 800faaa:	69fa      	ldr	r2, [r7, #28]
 800faac:	68fb      	ldr	r3, [r7, #12]
 800faae:	4313      	orrs	r3, r2
 800fab0:	61fb      	str	r3, [r7, #28]
        }
        EXTI->EMR1 = tmp;
 800fab2:	4a16      	ldr	r2, [pc, #88]	@ (800fb0c <HAL_GPIO_Init+0x3a8>)
 800fab4:	69fb      	ldr	r3, [r7, #28]
 800fab6:	f8c2 3084 	str.w	r3, [r2, #132]	@ 0x84

        tmp = EXTI->IMR1;
 800faba:	4b14      	ldr	r3, [pc, #80]	@ (800fb0c <HAL_GPIO_Init+0x3a8>)
 800fabc:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 800fac0:	61fb      	str	r3, [r7, #28]
        tmp &= ~((uint32_t)iocurrent);
 800fac2:	68fb      	ldr	r3, [r7, #12]
 800fac4:	43db      	mvns	r3, r3
 800fac6:	69fa      	ldr	r2, [r7, #28]
 800fac8:	4013      	ands	r3, r2
 800faca:	61fb      	str	r3, [r7, #28]
        if ((pGPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 800facc:	683b      	ldr	r3, [r7, #0]
 800face:	685b      	ldr	r3, [r3, #4]
 800fad0:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 800fad4:	2b00      	cmp	r3, #0
 800fad6:	d003      	beq.n	800fae0 <HAL_GPIO_Init+0x37c>
        {
          tmp |= iocurrent;
 800fad8:	69fa      	ldr	r2, [r7, #28]
 800fada:	68fb      	ldr	r3, [r7, #12]
 800fadc:	4313      	orrs	r3, r2
 800fade:	61fb      	str	r3, [r7, #28]
        }
        EXTI->IMR1 = tmp;
 800fae0:	4a0a      	ldr	r2, [pc, #40]	@ (800fb0c <HAL_GPIO_Init+0x3a8>)
 800fae2:	69fb      	ldr	r3, [r7, #28]
 800fae4:	f8c2 3080 	str.w	r3, [r2, #128]	@ 0x80
      }
    }
    position++;
 800fae8:	697b      	ldr	r3, [r7, #20]
 800faea:	3301      	adds	r3, #1
 800faec:	617b      	str	r3, [r7, #20]
  while (((pGPIO_Init->Pin) >> position) != 0U)
 800faee:	683b      	ldr	r3, [r7, #0]
 800faf0:	681a      	ldr	r2, [r3, #0]
 800faf2:	697b      	ldr	r3, [r7, #20]
 800faf4:	fa22 f303 	lsr.w	r3, r2, r3
 800faf8:	2b00      	cmp	r3, #0
 800fafa:	f47f ae3d 	bne.w	800f778 <HAL_GPIO_Init+0x14>
  }
}
 800fafe:	bf00      	nop
 800fb00:	bf00      	nop
 800fb02:	3724      	adds	r7, #36	@ 0x24
 800fb04:	46bd      	mov	sp, r7
 800fb06:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fb0a:	4770      	bx	lr
 800fb0c:	46022000 	.word	0x46022000
 800fb10:	002f7f7f 	.word	0x002f7f7f

0800fb14 <HAL_GPIO_DeInit>:
  * @param  GPIO_Pin: specifies the port bit to be written.
  *         This parameter can be one of GPIO_PIN_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
{
 800fb14:	b480      	push	{r7}
 800fb16:	b089      	sub	sp, #36	@ 0x24
 800fb18:	af00      	add	r7, sp, #0
 800fb1a:	6078      	str	r0, [r7, #4]
 800fb1c:	6039      	str	r1, [r7, #0]
  uint32_t tmp;
  uint32_t iocurrent;
  uint32_t pin_position;
  uint32_t position = 0U;
 800fb1e:	2300      	movs	r3, #0
 800fb20:	61bb      	str	r3, [r7, #24]

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* Save GPIO port address */
  p_gpio = GPIOx;
 800fb22:	687b      	ldr	r3, [r7, #4]
 800fb24:	617b      	str	r3, [r7, #20]

  /* Configure the port pins */
  while ((GPIO_Pin >> position) != 0U)
 800fb26:	e0bc      	b.n	800fca2 <HAL_GPIO_DeInit+0x18e>
  {
    /* Get current io position */
    iocurrent = (GPIO_Pin) & (1UL << position);
 800fb28:	2201      	movs	r2, #1
 800fb2a:	69bb      	ldr	r3, [r7, #24]
 800fb2c:	fa02 f303 	lsl.w	r3, r2, r3
 800fb30:	683a      	ldr	r2, [r7, #0]
 800fb32:	4013      	ands	r3, r2
 800fb34:	613b      	str	r3, [r7, #16]

    /*Save Pin Position */
    pin_position = position;
 800fb36:	69bb      	ldr	r3, [r7, #24]
 800fb38:	61fb      	str	r3, [r7, #28]

    if (iocurrent != 0U)
 800fb3a:	693b      	ldr	r3, [r7, #16]
 800fb3c:	2b00      	cmp	r3, #0
 800fb3e:	f000 80ad 	beq.w	800fc9c <HAL_GPIO_DeInit+0x188>
    {
      /* In case of LPGPIO port selected */
      if (GPIOx == LPGPIO1)
 800fb42:	687b      	ldr	r3, [r7, #4]
 800fb44:	4a5e      	ldr	r2, [pc, #376]	@ (800fcc0 <HAL_GPIO_DeInit+0x1ac>)
 800fb46:	4293      	cmp	r3, r2
 800fb48:	d115      	bne.n	800fb76 <HAL_GPIO_DeInit+0x62>
      {
        /* Configure LP/IO in Input Mode */
        p_gpio  = LPGPIO_Map[pin_position].GPIO_PORT;
 800fb4a:	4a5e      	ldr	r2, [pc, #376]	@ (800fcc4 <HAL_GPIO_DeInit+0x1b0>)
 800fb4c:	69fb      	ldr	r3, [r7, #28]
 800fb4e:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 800fb52:	617b      	str	r3, [r7, #20]
        pin_position = LPGPIO_Map[position].Pin_Pos;
 800fb54:	4a5b      	ldr	r2, [pc, #364]	@ (800fcc4 <HAL_GPIO_DeInit+0x1b0>)
 800fb56:	69bb      	ldr	r3, [r7, #24]
 800fb58:	00db      	lsls	r3, r3, #3
 800fb5a:	4413      	add	r3, r2
 800fb5c:	685b      	ldr	r3, [r3, #4]
 800fb5e:	61fb      	str	r3, [r7, #28]
        LPGPIO1->MODER &= ~(1U << pin_position);
 800fb60:	4b57      	ldr	r3, [pc, #348]	@ (800fcc0 <HAL_GPIO_DeInit+0x1ac>)
 800fb62:	681a      	ldr	r2, [r3, #0]
 800fb64:	2101      	movs	r1, #1
 800fb66:	69fb      	ldr	r3, [r7, #28]
 800fb68:	fa01 f303 	lsl.w	r3, r1, r3
 800fb6c:	43db      	mvns	r3, r3
 800fb6e:	4954      	ldr	r1, [pc, #336]	@ (800fcc0 <HAL_GPIO_DeInit+0x1ac>)
 800fb70:	4013      	ands	r3, r2
 800fb72:	600b      	str	r3, [r1, #0]
 800fb74:	e053      	b.n	800fc1e <HAL_GPIO_DeInit+0x10a>
        /* Check the parameters */
        assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));

        /*------------------------- EXTI Mode Configuration --------------------*/
        /* Clear the External Interrupt or Event for the current IO */
        tmp = EXTI->EXTICR[position >> 2U];
 800fb76:	4a54      	ldr	r2, [pc, #336]	@ (800fcc8 <HAL_GPIO_DeInit+0x1b4>)
 800fb78:	69bb      	ldr	r3, [r7, #24]
 800fb7a:	089b      	lsrs	r3, r3, #2
 800fb7c:	3318      	adds	r3, #24
 800fb7e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800fb82:	60fb      	str	r3, [r7, #12]
        tmp &= ((0x0FUL) << (8U * (position & 0x03U)));
 800fb84:	69bb      	ldr	r3, [r7, #24]
 800fb86:	f003 0303 	and.w	r3, r3, #3
 800fb8a:	00db      	lsls	r3, r3, #3
 800fb8c:	220f      	movs	r2, #15
 800fb8e:	fa02 f303 	lsl.w	r3, r2, r3
 800fb92:	68fa      	ldr	r2, [r7, #12]
 800fb94:	4013      	ands	r3, r2
 800fb96:	60fb      	str	r3, [r7, #12]
        if (tmp == (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U))))
 800fb98:	687b      	ldr	r3, [r7, #4]
 800fb9a:	0a9a      	lsrs	r2, r3, #10
 800fb9c:	4b4b      	ldr	r3, [pc, #300]	@ (800fccc <HAL_GPIO_DeInit+0x1b8>)
 800fb9e:	4013      	ands	r3, r2
 800fba0:	69ba      	ldr	r2, [r7, #24]
 800fba2:	f002 0203 	and.w	r2, r2, #3
 800fba6:	00d2      	lsls	r2, r2, #3
 800fba8:	4093      	lsls	r3, r2
 800fbaa:	68fa      	ldr	r2, [r7, #12]
 800fbac:	429a      	cmp	r2, r3
 800fbae:	d136      	bne.n	800fc1e <HAL_GPIO_DeInit+0x10a>
        {
          /* Clear EXTI line configuration */
          EXTI->IMR1 &= ~(iocurrent);
 800fbb0:	4b45      	ldr	r3, [pc, #276]	@ (800fcc8 <HAL_GPIO_DeInit+0x1b4>)
 800fbb2:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
 800fbb6:	693b      	ldr	r3, [r7, #16]
 800fbb8:	43db      	mvns	r3, r3
 800fbba:	4943      	ldr	r1, [pc, #268]	@ (800fcc8 <HAL_GPIO_DeInit+0x1b4>)
 800fbbc:	4013      	ands	r3, r2
 800fbbe:	f8c1 3080 	str.w	r3, [r1, #128]	@ 0x80
          EXTI->EMR1 &= ~(iocurrent);
 800fbc2:	4b41      	ldr	r3, [pc, #260]	@ (800fcc8 <HAL_GPIO_DeInit+0x1b4>)
 800fbc4:	f8d3 2084 	ldr.w	r2, [r3, #132]	@ 0x84
 800fbc8:	693b      	ldr	r3, [r7, #16]
 800fbca:	43db      	mvns	r3, r3
 800fbcc:	493e      	ldr	r1, [pc, #248]	@ (800fcc8 <HAL_GPIO_DeInit+0x1b4>)
 800fbce:	4013      	ands	r3, r2
 800fbd0:	f8c1 3084 	str.w	r3, [r1, #132]	@ 0x84

          /* Clear Rising Falling edge configuration */
          EXTI->RTSR1 &= ~(iocurrent);
 800fbd4:	4b3c      	ldr	r3, [pc, #240]	@ (800fcc8 <HAL_GPIO_DeInit+0x1b4>)
 800fbd6:	681a      	ldr	r2, [r3, #0]
 800fbd8:	693b      	ldr	r3, [r7, #16]
 800fbda:	43db      	mvns	r3, r3
 800fbdc:	493a      	ldr	r1, [pc, #232]	@ (800fcc8 <HAL_GPIO_DeInit+0x1b4>)
 800fbde:	4013      	ands	r3, r2
 800fbe0:	600b      	str	r3, [r1, #0]
          EXTI->FTSR1 &= ~(iocurrent);
 800fbe2:	4b39      	ldr	r3, [pc, #228]	@ (800fcc8 <HAL_GPIO_DeInit+0x1b4>)
 800fbe4:	685a      	ldr	r2, [r3, #4]
 800fbe6:	693b      	ldr	r3, [r7, #16]
 800fbe8:	43db      	mvns	r3, r3
 800fbea:	4937      	ldr	r1, [pc, #220]	@ (800fcc8 <HAL_GPIO_DeInit+0x1b4>)
 800fbec:	4013      	ands	r3, r2
 800fbee:	604b      	str	r3, [r1, #4]

          tmp = (0x0FUL) << (8U * (position & 0x03U));
 800fbf0:	69bb      	ldr	r3, [r7, #24]
 800fbf2:	f003 0303 	and.w	r3, r3, #3
 800fbf6:	00db      	lsls	r3, r3, #3
 800fbf8:	220f      	movs	r2, #15
 800fbfa:	fa02 f303 	lsl.w	r3, r2, r3
 800fbfe:	60fb      	str	r3, [r7, #12]
          EXTI->EXTICR[position >> 2U] &= ~tmp;
 800fc00:	4a31      	ldr	r2, [pc, #196]	@ (800fcc8 <HAL_GPIO_DeInit+0x1b4>)
 800fc02:	69bb      	ldr	r3, [r7, #24]
 800fc04:	089b      	lsrs	r3, r3, #2
 800fc06:	3318      	adds	r3, #24
 800fc08:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
 800fc0c:	68fb      	ldr	r3, [r7, #12]
 800fc0e:	43da      	mvns	r2, r3
 800fc10:	482d      	ldr	r0, [pc, #180]	@ (800fcc8 <HAL_GPIO_DeInit+0x1b4>)
 800fc12:	69bb      	ldr	r3, [r7, #24]
 800fc14:	089b      	lsrs	r3, r3, #2
 800fc16:	400a      	ands	r2, r1
 800fc18:	3318      	adds	r3, #24
 800fc1a:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
        }
      }

      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Configure IO in Analog Mode */
      p_gpio->MODER |= (GPIO_MODER_MODE0 << (pin_position * GPIO_MODER_MODE1_Pos));
 800fc1e:	697b      	ldr	r3, [r7, #20]
 800fc20:	681a      	ldr	r2, [r3, #0]
 800fc22:	69fb      	ldr	r3, [r7, #28]
 800fc24:	005b      	lsls	r3, r3, #1
 800fc26:	2103      	movs	r1, #3
 800fc28:	fa01 f303 	lsl.w	r3, r1, r3
 800fc2c:	431a      	orrs	r2, r3
 800fc2e:	697b      	ldr	r3, [r7, #20]
 800fc30:	601a      	str	r2, [r3, #0]

      /* Configure the default Alternate Function in current IO */
      p_gpio->AFR[pin_position >> 3U] &= ~(0x0FUL << ((pin_position & 0x07U) * GPIO_AFRL_AFSEL1_Pos));
 800fc32:	69fb      	ldr	r3, [r7, #28]
 800fc34:	08da      	lsrs	r2, r3, #3
 800fc36:	697b      	ldr	r3, [r7, #20]
 800fc38:	3208      	adds	r2, #8
 800fc3a:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 800fc3e:	69fb      	ldr	r3, [r7, #28]
 800fc40:	f003 0307 	and.w	r3, r3, #7
 800fc44:	009b      	lsls	r3, r3, #2
 800fc46:	220f      	movs	r2, #15
 800fc48:	fa02 f303 	lsl.w	r3, r2, r3
 800fc4c:	43db      	mvns	r3, r3
 800fc4e:	69fa      	ldr	r2, [r7, #28]
 800fc50:	08d2      	lsrs	r2, r2, #3
 800fc52:	4019      	ands	r1, r3
 800fc54:	697b      	ldr	r3, [r7, #20]
 800fc56:	3208      	adds	r2, #8
 800fc58:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

      /* Configure the default value for IO Speed */
      p_gpio->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED0 << (pin_position * GPIO_OSPEEDR_OSPEED1_Pos));
 800fc5c:	697b      	ldr	r3, [r7, #20]
 800fc5e:	689a      	ldr	r2, [r3, #8]
 800fc60:	69fb      	ldr	r3, [r7, #28]
 800fc62:	005b      	lsls	r3, r3, #1
 800fc64:	2103      	movs	r1, #3
 800fc66:	fa01 f303 	lsl.w	r3, r1, r3
 800fc6a:	43db      	mvns	r3, r3
 800fc6c:	401a      	ands	r2, r3
 800fc6e:	697b      	ldr	r3, [r7, #20]
 800fc70:	609a      	str	r2, [r3, #8]

      /* Configure the default value IO Output Type */
      p_gpio->OTYPER  &= ~(GPIO_OTYPER_OT0 << pin_position);
 800fc72:	697b      	ldr	r3, [r7, #20]
 800fc74:	685a      	ldr	r2, [r3, #4]
 800fc76:	2101      	movs	r1, #1
 800fc78:	69fb      	ldr	r3, [r7, #28]
 800fc7a:	fa01 f303 	lsl.w	r3, r1, r3
 800fc7e:	43db      	mvns	r3, r3
 800fc80:	401a      	ands	r2, r3
 800fc82:	697b      	ldr	r3, [r7, #20]
 800fc84:	605a      	str	r2, [r3, #4]

      /* Deactivate the Pull-up and Pull-down resistor for the current IO */
      p_gpio->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (pin_position * GPIO_PUPDR_PUPD1_Pos));
 800fc86:	697b      	ldr	r3, [r7, #20]
 800fc88:	68da      	ldr	r2, [r3, #12]
 800fc8a:	69fb      	ldr	r3, [r7, #28]
 800fc8c:	005b      	lsls	r3, r3, #1
 800fc8e:	2103      	movs	r1, #3
 800fc90:	fa01 f303 	lsl.w	r3, r1, r3
 800fc94:	43db      	mvns	r3, r3
 800fc96:	401a      	ands	r2, r3
 800fc98:	697b      	ldr	r3, [r7, #20]
 800fc9a:	60da      	str	r2, [r3, #12]
    }

    position++;
 800fc9c:	69bb      	ldr	r3, [r7, #24]
 800fc9e:	3301      	adds	r3, #1
 800fca0:	61bb      	str	r3, [r7, #24]
  while ((GPIO_Pin >> position) != 0U)
 800fca2:	683a      	ldr	r2, [r7, #0]
 800fca4:	69bb      	ldr	r3, [r7, #24]
 800fca6:	fa22 f303 	lsr.w	r3, r2, r3
 800fcaa:	2b00      	cmp	r3, #0
 800fcac:	f47f af3c 	bne.w	800fb28 <HAL_GPIO_DeInit+0x14>
  }
}
 800fcb0:	bf00      	nop
 800fcb2:	bf00      	nop
 800fcb4:	3724      	adds	r7, #36	@ 0x24
 800fcb6:	46bd      	mov	sp, r7
 800fcb8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fcbc:	4770      	bx	lr
 800fcbe:	bf00      	nop
 800fcc0:	46020000 	.word	0x46020000
 800fcc4:	0802a520 	.word	0x0802a520
 800fcc8:	46022000 	.word	0x46022000
 800fccc:	002f7f7f 	.word	0x002f7f7f

0800fcd0 <HAL_GPIO_ReadPin>:
  * @param  GPIO_Pin: specifies the port bit to read.
  *         This parameter can be GPIO_PIN_x where x can be (0..15).
  * @retval The input port pin value.
  */
GPIO_PinState HAL_GPIO_ReadPin(const GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
 800fcd0:	b480      	push	{r7}
 800fcd2:	b085      	sub	sp, #20
 800fcd4:	af00      	add	r7, sp, #0
 800fcd6:	6078      	str	r0, [r7, #4]
 800fcd8:	460b      	mov	r3, r1
 800fcda:	807b      	strh	r3, [r7, #2]
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->IDR & GPIO_Pin) != 0U)
 800fcdc:	687b      	ldr	r3, [r7, #4]
 800fcde:	691a      	ldr	r2, [r3, #16]
 800fce0:	887b      	ldrh	r3, [r7, #2]
 800fce2:	4013      	ands	r3, r2
 800fce4:	2b00      	cmp	r3, #0
 800fce6:	d002      	beq.n	800fcee <HAL_GPIO_ReadPin+0x1e>
  {
    bitstatus = GPIO_PIN_SET;
 800fce8:	2301      	movs	r3, #1
 800fcea:	73fb      	strb	r3, [r7, #15]
 800fcec:	e001      	b.n	800fcf2 <HAL_GPIO_ReadPin+0x22>
  }
  else
  {
    bitstatus = GPIO_PIN_RESET;
 800fcee:	2300      	movs	r3, #0
 800fcf0:	73fb      	strb	r3, [r7, #15]
  }

  return bitstatus;
 800fcf2:	7bfb      	ldrb	r3, [r7, #15]
}
 800fcf4:	4618      	mov	r0, r3
 800fcf6:	3714      	adds	r7, #20
 800fcf8:	46bd      	mov	sp, r7
 800fcfa:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fcfe:	4770      	bx	lr

0800fd00 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 800fd00:	b480      	push	{r7}
 800fd02:	b083      	sub	sp, #12
 800fd04:	af00      	add	r7, sp, #0
 800fd06:	6078      	str	r0, [r7, #4]
 800fd08:	460b      	mov	r3, r1
 800fd0a:	807b      	strh	r3, [r7, #2]
 800fd0c:	4613      	mov	r3, r2
 800fd0e:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 800fd10:	787b      	ldrb	r3, [r7, #1]
 800fd12:	2b00      	cmp	r3, #0
 800fd14:	d003      	beq.n	800fd1e <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 800fd16:	887a      	ldrh	r2, [r7, #2]
 800fd18:	687b      	ldr	r3, [r7, #4]
 800fd1a:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BRR  = (uint32_t)GPIO_Pin;
  }
}
 800fd1c:	e002      	b.n	800fd24 <HAL_GPIO_WritePin+0x24>
    GPIOx->BRR  = (uint32_t)GPIO_Pin;
 800fd1e:	887a      	ldrh	r2, [r7, #2]
 800fd20:	687b      	ldr	r3, [r7, #4]
 800fd22:	629a      	str	r2, [r3, #40]	@ 0x28
}
 800fd24:	bf00      	nop
 800fd26:	370c      	adds	r7, #12
 800fd28:	46bd      	mov	sp, r7
 800fd2a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fd2e:	4770      	bx	lr

0800fd30 <HAL_GPIO_EXTI_IRQHandler>:
  * @brief  Handle EXTI interrupt request.
  * @param  GPIO_Pin: Specifies the port pin connected to corresponding EXTI line.
  * @retval None
  */
void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
{
 800fd30:	b580      	push	{r7, lr}
 800fd32:	b082      	sub	sp, #8
 800fd34:	af00      	add	r7, sp, #0
 800fd36:	4603      	mov	r3, r0
 800fd38:	80fb      	strh	r3, [r7, #6]
  /* EXTI line interrupt detected */
  if (__HAL_GPIO_EXTI_GET_RISING_IT(GPIO_Pin) != 0U)
 800fd3a:	4b0f      	ldr	r3, [pc, #60]	@ (800fd78 <HAL_GPIO_EXTI_IRQHandler+0x48>)
 800fd3c:	68da      	ldr	r2, [r3, #12]
 800fd3e:	88fb      	ldrh	r3, [r7, #6]
 800fd40:	4013      	ands	r3, r2
 800fd42:	2b00      	cmp	r3, #0
 800fd44:	d006      	beq.n	800fd54 <HAL_GPIO_EXTI_IRQHandler+0x24>
  {
    __HAL_GPIO_EXTI_CLEAR_RISING_IT(GPIO_Pin);
 800fd46:	4a0c      	ldr	r2, [pc, #48]	@ (800fd78 <HAL_GPIO_EXTI_IRQHandler+0x48>)
 800fd48:	88fb      	ldrh	r3, [r7, #6]
 800fd4a:	60d3      	str	r3, [r2, #12]
    HAL_GPIO_EXTI_Rising_Callback(GPIO_Pin);
 800fd4c:	88fb      	ldrh	r3, [r7, #6]
 800fd4e:	4618      	mov	r0, r3
 800fd50:	f000 f814 	bl	800fd7c <HAL_GPIO_EXTI_Rising_Callback>
  }

  if (__HAL_GPIO_EXTI_GET_FALLING_IT(GPIO_Pin) != 0U)
 800fd54:	4b08      	ldr	r3, [pc, #32]	@ (800fd78 <HAL_GPIO_EXTI_IRQHandler+0x48>)
 800fd56:	691a      	ldr	r2, [r3, #16]
 800fd58:	88fb      	ldrh	r3, [r7, #6]
 800fd5a:	4013      	ands	r3, r2
 800fd5c:	2b00      	cmp	r3, #0
 800fd5e:	d006      	beq.n	800fd6e <HAL_GPIO_EXTI_IRQHandler+0x3e>
  {
    __HAL_GPIO_EXTI_CLEAR_FALLING_IT(GPIO_Pin);
 800fd60:	4a05      	ldr	r2, [pc, #20]	@ (800fd78 <HAL_GPIO_EXTI_IRQHandler+0x48>)
 800fd62:	88fb      	ldrh	r3, [r7, #6]
 800fd64:	6113      	str	r3, [r2, #16]
    HAL_GPIO_EXTI_Falling_Callback(GPIO_Pin);
 800fd66:	88fb      	ldrh	r3, [r7, #6]
 800fd68:	4618      	mov	r0, r3
 800fd6a:	f000 f812 	bl	800fd92 <HAL_GPIO_EXTI_Falling_Callback>
  }
}
 800fd6e:	bf00      	nop
 800fd70:	3708      	adds	r7, #8
 800fd72:	46bd      	mov	sp, r7
 800fd74:	bd80      	pop	{r7, pc}
 800fd76:	bf00      	nop
 800fd78:	46022000 	.word	0x46022000

0800fd7c <HAL_GPIO_EXTI_Rising_Callback>:
  * @brief  EXTI line rising detection callback.
  * @param  GPIO_Pin: Specifies the port pin connected to corresponding EXTI line.
  * @retval None
  */
__weak void HAL_GPIO_EXTI_Rising_Callback(uint16_t GPIO_Pin)
{
 800fd7c:	b480      	push	{r7}
 800fd7e:	b083      	sub	sp, #12
 800fd80:	af00      	add	r7, sp, #0
 800fd82:	4603      	mov	r3, r0
 800fd84:	80fb      	strh	r3, [r7, #6]
  UNUSED(GPIO_Pin);

  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_GPIO_EXTI_Rising_Callback could be implemented in the user file
   */
}
 800fd86:	bf00      	nop
 800fd88:	370c      	adds	r7, #12
 800fd8a:	46bd      	mov	sp, r7
 800fd8c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fd90:	4770      	bx	lr

0800fd92 <HAL_GPIO_EXTI_Falling_Callback>:
  * @brief  EXTI line falling detection callback.
  * @param  GPIO_Pin: Specifies the port pin connected to corresponding EXTI line.
  * @retval None
  */
__weak void HAL_GPIO_EXTI_Falling_Callback(uint16_t GPIO_Pin)
{
 800fd92:	b480      	push	{r7}
 800fd94:	b083      	sub	sp, #12
 800fd96:	af00      	add	r7, sp, #0
 800fd98:	4603      	mov	r3, r0
 800fd9a:	80fb      	strh	r3, [r7, #6]
  UNUSED(GPIO_Pin);

  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_GPIO_EXTI_Falling_Callback could be implemented in the user file
   */
}
 800fd9c:	bf00      	nop
 800fd9e:	370c      	adds	r7, #12
 800fda0:	46bd      	mov	sp, r7
 800fda2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fda6:	4770      	bx	lr

0800fda8 <HAL_I2C_Init>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
{
 800fda8:	b580      	push	{r7, lr}
 800fdaa:	b082      	sub	sp, #8
 800fdac:	af00      	add	r7, sp, #0
 800fdae:	6078      	str	r0, [r7, #4]
  /* Check the I2C handle allocation */
  if (hi2c == NULL)
 800fdb0:	687b      	ldr	r3, [r7, #4]
 800fdb2:	2b00      	cmp	r3, #0
 800fdb4:	d101      	bne.n	800fdba <HAL_I2C_Init+0x12>
  {
    return HAL_ERROR;
 800fdb6:	2301      	movs	r3, #1
 800fdb8:	e08d      	b.n	800fed6 <HAL_I2C_Init+0x12e>
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
  assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));

  if (hi2c->State == HAL_I2C_STATE_RESET)
 800fdba:	687b      	ldr	r3, [r7, #4]
 800fdbc:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 800fdc0:	b2db      	uxtb	r3, r3
 800fdc2:	2b00      	cmp	r3, #0
 800fdc4:	d106      	bne.n	800fdd4 <HAL_I2C_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hi2c->Lock = HAL_UNLOCKED;
 800fdc6:	687b      	ldr	r3, [r7, #4]
 800fdc8:	2200      	movs	r2, #0
 800fdca:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    hi2c->MspInitCallback(hi2c);
#else
    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    HAL_I2C_MspInit(hi2c);
 800fdce:	6878      	ldr	r0, [r7, #4]
 800fdd0:	f000 f8b4 	bl	800ff3c <HAL_I2C_MspInit>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }

  hi2c->State = HAL_I2C_STATE_BUSY;
 800fdd4:	687b      	ldr	r3, [r7, #4]
 800fdd6:	2224      	movs	r2, #36	@ 0x24
 800fdd8:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

  /* Disable the selected I2C peripheral */
  __HAL_I2C_DISABLE(hi2c);
 800fddc:	687b      	ldr	r3, [r7, #4]
 800fdde:	681b      	ldr	r3, [r3, #0]
 800fde0:	681a      	ldr	r2, [r3, #0]
 800fde2:	687b      	ldr	r3, [r7, #4]
 800fde4:	681b      	ldr	r3, [r3, #0]
 800fde6:	f022 0201 	bic.w	r2, r2, #1
 800fdea:	601a      	str	r2, [r3, #0]

  /*---------------------------- I2Cx TIMINGR Configuration ------------------*/
  /* Configure I2Cx: Frequency range */
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
 800fdec:	687b      	ldr	r3, [r7, #4]
 800fdee:	685a      	ldr	r2, [r3, #4]
 800fdf0:	687b      	ldr	r3, [r7, #4]
 800fdf2:	681b      	ldr	r3, [r3, #0]
 800fdf4:	f022 6270 	bic.w	r2, r2, #251658240	@ 0xf000000
 800fdf8:	611a      	str	r2, [r3, #16]

  /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
  /* Disable Own Address1 before set the Own Address1 configuration */
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
 800fdfa:	687b      	ldr	r3, [r7, #4]
 800fdfc:	681b      	ldr	r3, [r3, #0]
 800fdfe:	689a      	ldr	r2, [r3, #8]
 800fe00:	687b      	ldr	r3, [r7, #4]
 800fe02:	681b      	ldr	r3, [r3, #0]
 800fe04:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
 800fe08:	609a      	str	r2, [r3, #8]

  /* Configure I2Cx: Own Address1 and ack own address1 mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 800fe0a:	687b      	ldr	r3, [r7, #4]
 800fe0c:	68db      	ldr	r3, [r3, #12]
 800fe0e:	2b01      	cmp	r3, #1
 800fe10:	d107      	bne.n	800fe22 <HAL_I2C_Init+0x7a>
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
 800fe12:	687b      	ldr	r3, [r7, #4]
 800fe14:	689a      	ldr	r2, [r3, #8]
 800fe16:	687b      	ldr	r3, [r7, #4]
 800fe18:	681b      	ldr	r3, [r3, #0]
 800fe1a:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
 800fe1e:	609a      	str	r2, [r3, #8]
 800fe20:	e006      	b.n	800fe30 <HAL_I2C_Init+0x88>
  }
  else /* I2C_ADDRESSINGMODE_10BIT */
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
 800fe22:	687b      	ldr	r3, [r7, #4]
 800fe24:	689a      	ldr	r2, [r3, #8]
 800fe26:	687b      	ldr	r3, [r7, #4]
 800fe28:	681b      	ldr	r3, [r3, #0]
 800fe2a:	f442 4204 	orr.w	r2, r2, #33792	@ 0x8400
 800fe2e:	609a      	str	r2, [r3, #8]
  }

  /*---------------------------- I2Cx CR2 Configuration ----------------------*/
  /* Configure I2Cx: Addressing Master mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 800fe30:	687b      	ldr	r3, [r7, #4]
 800fe32:	68db      	ldr	r3, [r3, #12]
 800fe34:	2b02      	cmp	r3, #2
 800fe36:	d108      	bne.n	800fe4a <HAL_I2C_Init+0xa2>
  {
    SET_BIT(hi2c->Instance->CR2, I2C_CR2_ADD10);
 800fe38:	687b      	ldr	r3, [r7, #4]
 800fe3a:	681b      	ldr	r3, [r3, #0]
 800fe3c:	685a      	ldr	r2, [r3, #4]
 800fe3e:	687b      	ldr	r3, [r7, #4]
 800fe40:	681b      	ldr	r3, [r3, #0]
 800fe42:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
 800fe46:	605a      	str	r2, [r3, #4]
 800fe48:	e007      	b.n	800fe5a <HAL_I2C_Init+0xb2>
  }
  else
  {
    /* Clear the I2C ADD10 bit */
    CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_ADD10);
 800fe4a:	687b      	ldr	r3, [r7, #4]
 800fe4c:	681b      	ldr	r3, [r3, #0]
 800fe4e:	685a      	ldr	r2, [r3, #4]
 800fe50:	687b      	ldr	r3, [r7, #4]
 800fe52:	681b      	ldr	r3, [r3, #0]
 800fe54:	f422 6200 	bic.w	r2, r2, #2048	@ 0x800
 800fe58:	605a      	str	r2, [r3, #4]
  }
  /* Enable the AUTOEND by default, and enable NACK (should be disable only during Slave process */
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 800fe5a:	687b      	ldr	r3, [r7, #4]
 800fe5c:	681b      	ldr	r3, [r3, #0]
 800fe5e:	685b      	ldr	r3, [r3, #4]
 800fe60:	687a      	ldr	r2, [r7, #4]
 800fe62:	6812      	ldr	r2, [r2, #0]
 800fe64:	f043 7300 	orr.w	r3, r3, #33554432	@ 0x2000000
 800fe68:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 800fe6c:	6053      	str	r3, [r2, #4]

  /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
  /* Disable Own Address2 before set the Own Address2 configuration */
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
 800fe6e:	687b      	ldr	r3, [r7, #4]
 800fe70:	681b      	ldr	r3, [r3, #0]
 800fe72:	68da      	ldr	r2, [r3, #12]
 800fe74:	687b      	ldr	r3, [r7, #4]
 800fe76:	681b      	ldr	r3, [r3, #0]
 800fe78:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
 800fe7c:	60da      	str	r2, [r3, #12]

  /* Configure I2Cx: Dual mode and Own Address2 */
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | \
 800fe7e:	687b      	ldr	r3, [r7, #4]
 800fe80:	691a      	ldr	r2, [r3, #16]
 800fe82:	687b      	ldr	r3, [r7, #4]
 800fe84:	695b      	ldr	r3, [r3, #20]
 800fe86:	ea42 0103 	orr.w	r1, r2, r3
                          (hi2c->Init.OwnAddress2Masks << 8));
 800fe8a:	687b      	ldr	r3, [r7, #4]
 800fe8c:	699b      	ldr	r3, [r3, #24]
 800fe8e:	021a      	lsls	r2, r3, #8
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | \
 800fe90:	687b      	ldr	r3, [r7, #4]
 800fe92:	681b      	ldr	r3, [r3, #0]
 800fe94:	430a      	orrs	r2, r1
 800fe96:	60da      	str	r2, [r3, #12]

  /*---------------------------- I2Cx CR1 Configuration ----------------------*/
  /* Configure I2Cx: Generalcall and NoStretch mode */
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 800fe98:	687b      	ldr	r3, [r7, #4]
 800fe9a:	69d9      	ldr	r1, [r3, #28]
 800fe9c:	687b      	ldr	r3, [r7, #4]
 800fe9e:	6a1a      	ldr	r2, [r3, #32]
 800fea0:	687b      	ldr	r3, [r7, #4]
 800fea2:	681b      	ldr	r3, [r3, #0]
 800fea4:	430a      	orrs	r2, r1
 800fea6:	601a      	str	r2, [r3, #0]

  /* Enable the selected I2C peripheral */
  __HAL_I2C_ENABLE(hi2c);
 800fea8:	687b      	ldr	r3, [r7, #4]
 800feaa:	681b      	ldr	r3, [r3, #0]
 800feac:	681a      	ldr	r2, [r3, #0]
 800feae:	687b      	ldr	r3, [r7, #4]
 800feb0:	681b      	ldr	r3, [r3, #0]
 800feb2:	f042 0201 	orr.w	r2, r2, #1
 800feb6:	601a      	str	r2, [r3, #0]

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 800feb8:	687b      	ldr	r3, [r7, #4]
 800feba:	2200      	movs	r2, #0
 800febc:	645a      	str	r2, [r3, #68]	@ 0x44
  hi2c->State = HAL_I2C_STATE_READY;
 800febe:	687b      	ldr	r3, [r7, #4]
 800fec0:	2220      	movs	r2, #32
 800fec2:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
 800fec6:	687b      	ldr	r3, [r7, #4]
 800fec8:	2200      	movs	r2, #0
 800feca:	631a      	str	r2, [r3, #48]	@ 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 800fecc:	687b      	ldr	r3, [r7, #4]
 800fece:	2200      	movs	r2, #0
 800fed0:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

  return HAL_OK;
 800fed4:	2300      	movs	r3, #0
}
 800fed6:	4618      	mov	r0, r3
 800fed8:	3708      	adds	r7, #8
 800feda:	46bd      	mov	sp, r7
 800fedc:	bd80      	pop	{r7, pc}

0800fede <HAL_I2C_DeInit>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_DeInit(I2C_HandleTypeDef *hi2c)
{
 800fede:	b580      	push	{r7, lr}
 800fee0:	b082      	sub	sp, #8
 800fee2:	af00      	add	r7, sp, #0
 800fee4:	6078      	str	r0, [r7, #4]
  /* Check the I2C handle allocation */
  if (hi2c == NULL)
 800fee6:	687b      	ldr	r3, [r7, #4]
 800fee8:	2b00      	cmp	r3, #0
 800feea:	d101      	bne.n	800fef0 <HAL_I2C_DeInit+0x12>
  {
    return HAL_ERROR;
 800feec:	2301      	movs	r3, #1
 800feee:	e021      	b.n	800ff34 <HAL_I2C_DeInit+0x56>
  }

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));

  hi2c->State = HAL_I2C_STATE_BUSY;
 800fef0:	687b      	ldr	r3, [r7, #4]
 800fef2:	2224      	movs	r2, #36	@ 0x24
 800fef4:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

  /* Disable the I2C Peripheral Clock */
  __HAL_I2C_DISABLE(hi2c);
 800fef8:	687b      	ldr	r3, [r7, #4]
 800fefa:	681b      	ldr	r3, [r3, #0]
 800fefc:	681a      	ldr	r2, [r3, #0]
 800fefe:	687b      	ldr	r3, [r7, #4]
 800ff00:	681b      	ldr	r3, [r3, #0]
 800ff02:	f022 0201 	bic.w	r2, r2, #1
 800ff06:	601a      	str	r2, [r3, #0]

  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
  hi2c->MspDeInitCallback(hi2c);
#else
  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
  HAL_I2C_MspDeInit(hi2c);
 800ff08:	6878      	ldr	r0, [r7, #4]
 800ff0a:	f000 f821 	bl	800ff50 <HAL_I2C_MspDeInit>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 800ff0e:	687b      	ldr	r3, [r7, #4]
 800ff10:	2200      	movs	r2, #0
 800ff12:	645a      	str	r2, [r3, #68]	@ 0x44
  hi2c->State = HAL_I2C_STATE_RESET;
 800ff14:	687b      	ldr	r3, [r7, #4]
 800ff16:	2200      	movs	r2, #0
 800ff18:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
 800ff1c:	687b      	ldr	r3, [r7, #4]
 800ff1e:	2200      	movs	r2, #0
 800ff20:	631a      	str	r2, [r3, #48]	@ 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 800ff22:	687b      	ldr	r3, [r7, #4]
 800ff24:	2200      	movs	r2, #0
 800ff26:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

  /* Release Lock */
  __HAL_UNLOCK(hi2c);
 800ff2a:	687b      	ldr	r3, [r7, #4]
 800ff2c:	2200      	movs	r2, #0
 800ff2e:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

  return HAL_OK;
 800ff32:	2300      	movs	r3, #0
}
 800ff34:	4618      	mov	r0, r3
 800ff36:	3708      	adds	r7, #8
 800ff38:	46bd      	mov	sp, r7
 800ff3a:	bd80      	pop	{r7, pc}

0800ff3c <HAL_I2C_MspInit>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MspInit(I2C_HandleTypeDef *hi2c)
{
 800ff3c:	b480      	push	{r7}
 800ff3e:	b083      	sub	sp, #12
 800ff40:	af00      	add	r7, sp, #0
 800ff42:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MspInit could be implemented in the user file
   */
}
 800ff44:	bf00      	nop
 800ff46:	370c      	adds	r7, #12
 800ff48:	46bd      	mov	sp, r7
 800ff4a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ff4e:	4770      	bx	lr

0800ff50 <HAL_I2C_MspDeInit>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MspDeInit(I2C_HandleTypeDef *hi2c)
{
 800ff50:	b480      	push	{r7}
 800ff52:	b083      	sub	sp, #12
 800ff54:	af00      	add	r7, sp, #0
 800ff56:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MspDeInit could be implemented in the user file
   */
}
 800ff58:	bf00      	nop
 800ff5a:	370c      	adds	r7, #12
 800ff5c:	46bd      	mov	sp, r7
 800ff5e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ff62:	4770      	bx	lr

0800ff64 <HAL_I2C_Mem_Write>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,
                                    uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 800ff64:	b580      	push	{r7, lr}
 800ff66:	b088      	sub	sp, #32
 800ff68:	af02      	add	r7, sp, #8
 800ff6a:	60f8      	str	r0, [r7, #12]
 800ff6c:	4608      	mov	r0, r1
 800ff6e:	4611      	mov	r1, r2
 800ff70:	461a      	mov	r2, r3
 800ff72:	4603      	mov	r3, r0
 800ff74:	817b      	strh	r3, [r7, #10]
 800ff76:	460b      	mov	r3, r1
 800ff78:	813b      	strh	r3, [r7, #8]
 800ff7a:	4613      	mov	r3, r2
 800ff7c:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
 800ff7e:	68fb      	ldr	r3, [r7, #12]
 800ff80:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 800ff84:	b2db      	uxtb	r3, r3
 800ff86:	2b20      	cmp	r3, #32
 800ff88:	f040 80f9 	bne.w	801017e <HAL_I2C_Mem_Write+0x21a>
  {
    if ((pData == NULL) || (Size == 0U))
 800ff8c:	6a3b      	ldr	r3, [r7, #32]
 800ff8e:	2b00      	cmp	r3, #0
 800ff90:	d002      	beq.n	800ff98 <HAL_I2C_Mem_Write+0x34>
 800ff92:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 800ff94:	2b00      	cmp	r3, #0
 800ff96:	d105      	bne.n	800ffa4 <HAL_I2C_Mem_Write+0x40>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
 800ff98:	68fb      	ldr	r3, [r7, #12]
 800ff9a:	f44f 7200 	mov.w	r2, #512	@ 0x200
 800ff9e:	645a      	str	r2, [r3, #68]	@ 0x44
      return  HAL_ERROR;
 800ffa0:	2301      	movs	r3, #1
 800ffa2:	e0ed      	b.n	8010180 <HAL_I2C_Mem_Write+0x21c>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
 800ffa4:	68fb      	ldr	r3, [r7, #12]
 800ffa6:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
 800ffaa:	2b01      	cmp	r3, #1
 800ffac:	d101      	bne.n	800ffb2 <HAL_I2C_Mem_Write+0x4e>
 800ffae:	2302      	movs	r3, #2
 800ffb0:	e0e6      	b.n	8010180 <HAL_I2C_Mem_Write+0x21c>
 800ffb2:	68fb      	ldr	r3, [r7, #12]
 800ffb4:	2201      	movs	r2, #1
 800ffb6:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
 800ffba:	f7fd fd51 	bl	800da60 <HAL_GetTick>
 800ffbe:	6178      	str	r0, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 800ffc0:	697b      	ldr	r3, [r7, #20]
 800ffc2:	9300      	str	r3, [sp, #0]
 800ffc4:	2319      	movs	r3, #25
 800ffc6:	2201      	movs	r2, #1
 800ffc8:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
 800ffcc:	68f8      	ldr	r0, [r7, #12]
 800ffce:	f001 f886 	bl	80110de <I2C_WaitOnFlagUntilTimeout>
 800ffd2:	4603      	mov	r3, r0
 800ffd4:	2b00      	cmp	r3, #0
 800ffd6:	d001      	beq.n	800ffdc <HAL_I2C_Mem_Write+0x78>
    {
      return HAL_ERROR;
 800ffd8:	2301      	movs	r3, #1
 800ffda:	e0d1      	b.n	8010180 <HAL_I2C_Mem_Write+0x21c>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
 800ffdc:	68fb      	ldr	r3, [r7, #12]
 800ffde:	2221      	movs	r2, #33	@ 0x21
 800ffe0:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
 800ffe4:	68fb      	ldr	r3, [r7, #12]
 800ffe6:	2240      	movs	r2, #64	@ 0x40
 800ffe8:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 800ffec:	68fb      	ldr	r3, [r7, #12]
 800ffee:	2200      	movs	r2, #0
 800fff0:	645a      	str	r2, [r3, #68]	@ 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
 800fff2:	68fb      	ldr	r3, [r7, #12]
 800fff4:	6a3a      	ldr	r2, [r7, #32]
 800fff6:	625a      	str	r2, [r3, #36]	@ 0x24
    hi2c->XferCount = Size;
 800fff8:	68fb      	ldr	r3, [r7, #12]
 800fffa:	8cba      	ldrh	r2, [r7, #36]	@ 0x24
 800fffc:	855a      	strh	r2, [r3, #42]	@ 0x2a
    hi2c->XferISR   = NULL;
 800fffe:	68fb      	ldr	r3, [r7, #12]
 8010000:	2200      	movs	r2, #0
 8010002:	635a      	str	r2, [r3, #52]	@ 0x34

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 8010004:	88f8      	ldrh	r0, [r7, #6]
 8010006:	893a      	ldrh	r2, [r7, #8]
 8010008:	8979      	ldrh	r1, [r7, #10]
 801000a:	697b      	ldr	r3, [r7, #20]
 801000c:	9301      	str	r3, [sp, #4]
 801000e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8010010:	9300      	str	r3, [sp, #0]
 8010012:	4603      	mov	r3, r0
 8010014:	68f8      	ldr	r0, [r7, #12]
 8010016:	f000 fbad 	bl	8010774 <I2C_RequestMemoryWrite>
 801001a:	4603      	mov	r3, r0
 801001c:	2b00      	cmp	r3, #0
 801001e:	d005      	beq.n	801002c <HAL_I2C_Mem_Write+0xc8>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
 8010020:	68fb      	ldr	r3, [r7, #12]
 8010022:	2200      	movs	r2, #0
 8010024:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
      return HAL_ERROR;
 8010028:	2301      	movs	r3, #1
 801002a:	e0a9      	b.n	8010180 <HAL_I2C_Mem_Write+0x21c>
    }

    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 801002c:	68fb      	ldr	r3, [r7, #12]
 801002e:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8010030:	b29b      	uxth	r3, r3
 8010032:	2bff      	cmp	r3, #255	@ 0xff
 8010034:	d90e      	bls.n	8010054 <HAL_I2C_Mem_Write+0xf0>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
 8010036:	68fb      	ldr	r3, [r7, #12]
 8010038:	22ff      	movs	r2, #255	@ 0xff
 801003a:	851a      	strh	r2, [r3, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 801003c:	68fb      	ldr	r3, [r7, #12]
 801003e:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 8010040:	b2da      	uxtb	r2, r3
 8010042:	8979      	ldrh	r1, [r7, #10]
 8010044:	2300      	movs	r3, #0
 8010046:	9300      	str	r3, [sp, #0]
 8010048:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
 801004c:	68f8      	ldr	r0, [r7, #12]
 801004e:	f001 fa09 	bl	8011464 <I2C_TransferConfig>
 8010052:	e00f      	b.n	8010074 <HAL_I2C_Mem_Write+0x110>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
 8010054:	68fb      	ldr	r3, [r7, #12]
 8010056:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8010058:	b29a      	uxth	r2, r3
 801005a:	68fb      	ldr	r3, [r7, #12]
 801005c:	851a      	strh	r2, [r3, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 801005e:	68fb      	ldr	r3, [r7, #12]
 8010060:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 8010062:	b2da      	uxtb	r2, r3
 8010064:	8979      	ldrh	r1, [r7, #10]
 8010066:	2300      	movs	r3, #0
 8010068:	9300      	str	r3, [sp, #0]
 801006a:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
 801006e:	68f8      	ldr	r0, [r7, #12]
 8010070:	f001 f9f8 	bl	8011464 <I2C_TransferConfig>
    }

    do
    {
      /* Wait until TXIS flag is set */
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8010074:	697a      	ldr	r2, [r7, #20]
 8010076:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 8010078:	68f8      	ldr	r0, [r7, #12]
 801007a:	f001 f889 	bl	8011190 <I2C_WaitOnTXISFlagUntilTimeout>
 801007e:	4603      	mov	r3, r0
 8010080:	2b00      	cmp	r3, #0
 8010082:	d001      	beq.n	8010088 <HAL_I2C_Mem_Write+0x124>
      {
        return HAL_ERROR;
 8010084:	2301      	movs	r3, #1
 8010086:	e07b      	b.n	8010180 <HAL_I2C_Mem_Write+0x21c>
      }

      /* Write data to TXDR */
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
 8010088:	68fb      	ldr	r3, [r7, #12]
 801008a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801008c:	781a      	ldrb	r2, [r3, #0]
 801008e:	68fb      	ldr	r3, [r7, #12]
 8010090:	681b      	ldr	r3, [r3, #0]
 8010092:	629a      	str	r2, [r3, #40]	@ 0x28

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
 8010094:	68fb      	ldr	r3, [r7, #12]
 8010096:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8010098:	1c5a      	adds	r2, r3, #1
 801009a:	68fb      	ldr	r3, [r7, #12]
 801009c:	625a      	str	r2, [r3, #36]	@ 0x24

      hi2c->XferCount--;
 801009e:	68fb      	ldr	r3, [r7, #12]
 80100a0:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 80100a2:	b29b      	uxth	r3, r3
 80100a4:	3b01      	subs	r3, #1
 80100a6:	b29a      	uxth	r2, r3
 80100a8:	68fb      	ldr	r3, [r7, #12]
 80100aa:	855a      	strh	r2, [r3, #42]	@ 0x2a
      hi2c->XferSize--;
 80100ac:	68fb      	ldr	r3, [r7, #12]
 80100ae:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 80100b0:	3b01      	subs	r3, #1
 80100b2:	b29a      	uxth	r2, r3
 80100b4:	68fb      	ldr	r3, [r7, #12]
 80100b6:	851a      	strh	r2, [r3, #40]	@ 0x28

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 80100b8:	68fb      	ldr	r3, [r7, #12]
 80100ba:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 80100bc:	b29b      	uxth	r3, r3
 80100be:	2b00      	cmp	r3, #0
 80100c0:	d034      	beq.n	801012c <HAL_I2C_Mem_Write+0x1c8>
 80100c2:	68fb      	ldr	r3, [r7, #12]
 80100c4:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 80100c6:	2b00      	cmp	r3, #0
 80100c8:	d130      	bne.n	801012c <HAL_I2C_Mem_Write+0x1c8>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
 80100ca:	697b      	ldr	r3, [r7, #20]
 80100cc:	9300      	str	r3, [sp, #0]
 80100ce:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80100d0:	2200      	movs	r2, #0
 80100d2:	2180      	movs	r1, #128	@ 0x80
 80100d4:	68f8      	ldr	r0, [r7, #12]
 80100d6:	f001 f802 	bl	80110de <I2C_WaitOnFlagUntilTimeout>
 80100da:	4603      	mov	r3, r0
 80100dc:	2b00      	cmp	r3, #0
 80100de:	d001      	beq.n	80100e4 <HAL_I2C_Mem_Write+0x180>
        {
          return HAL_ERROR;
 80100e0:	2301      	movs	r3, #1
 80100e2:	e04d      	b.n	8010180 <HAL_I2C_Mem_Write+0x21c>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
 80100e4:	68fb      	ldr	r3, [r7, #12]
 80100e6:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 80100e8:	b29b      	uxth	r3, r3
 80100ea:	2bff      	cmp	r3, #255	@ 0xff
 80100ec:	d90e      	bls.n	801010c <HAL_I2C_Mem_Write+0x1a8>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
 80100ee:	68fb      	ldr	r3, [r7, #12]
 80100f0:	22ff      	movs	r2, #255	@ 0xff
 80100f2:	851a      	strh	r2, [r3, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
 80100f4:	68fb      	ldr	r3, [r7, #12]
 80100f6:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 80100f8:	b2da      	uxtb	r2, r3
 80100fa:	8979      	ldrh	r1, [r7, #10]
 80100fc:	2300      	movs	r3, #0
 80100fe:	9300      	str	r3, [sp, #0]
 8010100:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
 8010104:	68f8      	ldr	r0, [r7, #12]
 8010106:	f001 f9ad 	bl	8011464 <I2C_TransferConfig>
 801010a:	e00f      	b.n	801012c <HAL_I2C_Mem_Write+0x1c8>
                             I2C_NO_STARTSTOP);
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
 801010c:	68fb      	ldr	r3, [r7, #12]
 801010e:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8010110:	b29a      	uxth	r2, r3
 8010112:	68fb      	ldr	r3, [r7, #12]
 8010114:	851a      	strh	r2, [r3, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
 8010116:	68fb      	ldr	r3, [r7, #12]
 8010118:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 801011a:	b2da      	uxtb	r2, r3
 801011c:	8979      	ldrh	r1, [r7, #10]
 801011e:	2300      	movs	r3, #0
 8010120:	9300      	str	r3, [sp, #0]
 8010122:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
 8010126:	68f8      	ldr	r0, [r7, #12]
 8010128:	f001 f99c 	bl	8011464 <I2C_TransferConfig>
                             I2C_NO_STARTSTOP);
        }
      }

    } while (hi2c->XferCount > 0U);
 801012c:	68fb      	ldr	r3, [r7, #12]
 801012e:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8010130:	b29b      	uxth	r3, r3
 8010132:	2b00      	cmp	r3, #0
 8010134:	d19e      	bne.n	8010074 <HAL_I2C_Mem_Write+0x110>

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is reset */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8010136:	697a      	ldr	r2, [r7, #20]
 8010138:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 801013a:	68f8      	ldr	r0, [r7, #12]
 801013c:	f001 f86f 	bl	801121e <I2C_WaitOnSTOPFlagUntilTimeout>
 8010140:	4603      	mov	r3, r0
 8010142:	2b00      	cmp	r3, #0
 8010144:	d001      	beq.n	801014a <HAL_I2C_Mem_Write+0x1e6>
    {
      return HAL_ERROR;
 8010146:	2301      	movs	r3, #1
 8010148:	e01a      	b.n	8010180 <HAL_I2C_Mem_Write+0x21c>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 801014a:	68fb      	ldr	r3, [r7, #12]
 801014c:	681b      	ldr	r3, [r3, #0]
 801014e:	2220      	movs	r2, #32
 8010150:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 8010152:	68fb      	ldr	r3, [r7, #12]
 8010154:	681b      	ldr	r3, [r3, #0]
 8010156:	6859      	ldr	r1, [r3, #4]
 8010158:	68fb      	ldr	r3, [r7, #12]
 801015a:	681a      	ldr	r2, [r3, #0]
 801015c:	4b0a      	ldr	r3, [pc, #40]	@ (8010188 <HAL_I2C_Mem_Write+0x224>)
 801015e:	400b      	ands	r3, r1
 8010160:	6053      	str	r3, [r2, #4]

    hi2c->State = HAL_I2C_STATE_READY;
 8010162:	68fb      	ldr	r3, [r7, #12]
 8010164:	2220      	movs	r2, #32
 8010166:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 801016a:	68fb      	ldr	r3, [r7, #12]
 801016c:	2200      	movs	r2, #0
 801016e:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8010172:	68fb      	ldr	r3, [r7, #12]
 8010174:	2200      	movs	r2, #0
 8010176:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    return HAL_OK;
 801017a:	2300      	movs	r3, #0
 801017c:	e000      	b.n	8010180 <HAL_I2C_Mem_Write+0x21c>
  }
  else
  {
    return HAL_BUSY;
 801017e:	2302      	movs	r3, #2
  }
}
 8010180:	4618      	mov	r0, r3
 8010182:	3718      	adds	r7, #24
 8010184:	46bd      	mov	sp, r7
 8010186:	bd80      	pop	{r7, pc}
 8010188:	fe00e800 	.word	0xfe00e800

0801018c <HAL_I2C_Mem_Read>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Read(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,
                                   uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 801018c:	b580      	push	{r7, lr}
 801018e:	b088      	sub	sp, #32
 8010190:	af02      	add	r7, sp, #8
 8010192:	60f8      	str	r0, [r7, #12]
 8010194:	4608      	mov	r0, r1
 8010196:	4611      	mov	r1, r2
 8010198:	461a      	mov	r2, r3
 801019a:	4603      	mov	r3, r0
 801019c:	817b      	strh	r3, [r7, #10]
 801019e:	460b      	mov	r3, r1
 80101a0:	813b      	strh	r3, [r7, #8]
 80101a2:	4613      	mov	r3, r2
 80101a4:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
 80101a6:	68fb      	ldr	r3, [r7, #12]
 80101a8:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 80101ac:	b2db      	uxtb	r3, r3
 80101ae:	2b20      	cmp	r3, #32
 80101b0:	f040 80fd 	bne.w	80103ae <HAL_I2C_Mem_Read+0x222>
  {
    if ((pData == NULL) || (Size == 0U))
 80101b4:	6a3b      	ldr	r3, [r7, #32]
 80101b6:	2b00      	cmp	r3, #0
 80101b8:	d002      	beq.n	80101c0 <HAL_I2C_Mem_Read+0x34>
 80101ba:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 80101bc:	2b00      	cmp	r3, #0
 80101be:	d105      	bne.n	80101cc <HAL_I2C_Mem_Read+0x40>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
 80101c0:	68fb      	ldr	r3, [r7, #12]
 80101c2:	f44f 7200 	mov.w	r2, #512	@ 0x200
 80101c6:	645a      	str	r2, [r3, #68]	@ 0x44
      return  HAL_ERROR;
 80101c8:	2301      	movs	r3, #1
 80101ca:	e0f1      	b.n	80103b0 <HAL_I2C_Mem_Read+0x224>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
 80101cc:	68fb      	ldr	r3, [r7, #12]
 80101ce:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
 80101d2:	2b01      	cmp	r3, #1
 80101d4:	d101      	bne.n	80101da <HAL_I2C_Mem_Read+0x4e>
 80101d6:	2302      	movs	r3, #2
 80101d8:	e0ea      	b.n	80103b0 <HAL_I2C_Mem_Read+0x224>
 80101da:	68fb      	ldr	r3, [r7, #12]
 80101dc:	2201      	movs	r2, #1
 80101de:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
 80101e2:	f7fd fc3d 	bl	800da60 <HAL_GetTick>
 80101e6:	6178      	str	r0, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 80101e8:	697b      	ldr	r3, [r7, #20]
 80101ea:	9300      	str	r3, [sp, #0]
 80101ec:	2319      	movs	r3, #25
 80101ee:	2201      	movs	r2, #1
 80101f0:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
 80101f4:	68f8      	ldr	r0, [r7, #12]
 80101f6:	f000 ff72 	bl	80110de <I2C_WaitOnFlagUntilTimeout>
 80101fa:	4603      	mov	r3, r0
 80101fc:	2b00      	cmp	r3, #0
 80101fe:	d001      	beq.n	8010204 <HAL_I2C_Mem_Read+0x78>
    {
      return HAL_ERROR;
 8010200:	2301      	movs	r3, #1
 8010202:	e0d5      	b.n	80103b0 <HAL_I2C_Mem_Read+0x224>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
 8010204:	68fb      	ldr	r3, [r7, #12]
 8010206:	2222      	movs	r2, #34	@ 0x22
 8010208:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
 801020c:	68fb      	ldr	r3, [r7, #12]
 801020e:	2240      	movs	r2, #64	@ 0x40
 8010210:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8010214:	68fb      	ldr	r3, [r7, #12]
 8010216:	2200      	movs	r2, #0
 8010218:	645a      	str	r2, [r3, #68]	@ 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
 801021a:	68fb      	ldr	r3, [r7, #12]
 801021c:	6a3a      	ldr	r2, [r7, #32]
 801021e:	625a      	str	r2, [r3, #36]	@ 0x24
    hi2c->XferCount = Size;
 8010220:	68fb      	ldr	r3, [r7, #12]
 8010222:	8cba      	ldrh	r2, [r7, #36]	@ 0x24
 8010224:	855a      	strh	r2, [r3, #42]	@ 0x2a
    hi2c->XferISR   = NULL;
 8010226:	68fb      	ldr	r3, [r7, #12]
 8010228:	2200      	movs	r2, #0
 801022a:	635a      	str	r2, [r3, #52]	@ 0x34

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 801022c:	88f8      	ldrh	r0, [r7, #6]
 801022e:	893a      	ldrh	r2, [r7, #8]
 8010230:	8979      	ldrh	r1, [r7, #10]
 8010232:	697b      	ldr	r3, [r7, #20]
 8010234:	9301      	str	r3, [sp, #4]
 8010236:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8010238:	9300      	str	r3, [sp, #0]
 801023a:	4603      	mov	r3, r0
 801023c:	68f8      	ldr	r0, [r7, #12]
 801023e:	f000 faed 	bl	801081c <I2C_RequestMemoryRead>
 8010242:	4603      	mov	r3, r0
 8010244:	2b00      	cmp	r3, #0
 8010246:	d005      	beq.n	8010254 <HAL_I2C_Mem_Read+0xc8>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
 8010248:	68fb      	ldr	r3, [r7, #12]
 801024a:	2200      	movs	r2, #0
 801024c:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
      return HAL_ERROR;
 8010250:	2301      	movs	r3, #1
 8010252:	e0ad      	b.n	80103b0 <HAL_I2C_Mem_Read+0x224>
    }

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8010254:	68fb      	ldr	r3, [r7, #12]
 8010256:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8010258:	b29b      	uxth	r3, r3
 801025a:	2bff      	cmp	r3, #255	@ 0xff
 801025c:	d90e      	bls.n	801027c <HAL_I2C_Mem_Read+0xf0>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
 801025e:	68fb      	ldr	r3, [r7, #12]
 8010260:	22ff      	movs	r2, #255	@ 0xff
 8010262:	851a      	strh	r2, [r3, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
 8010264:	68fb      	ldr	r3, [r7, #12]
 8010266:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 8010268:	b2da      	uxtb	r2, r3
 801026a:	8979      	ldrh	r1, [r7, #10]
 801026c:	4b52      	ldr	r3, [pc, #328]	@ (80103b8 <HAL_I2C_Mem_Read+0x22c>)
 801026e:	9300      	str	r3, [sp, #0]
 8010270:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
 8010274:	68f8      	ldr	r0, [r7, #12]
 8010276:	f001 f8f5 	bl	8011464 <I2C_TransferConfig>
 801027a:	e00f      	b.n	801029c <HAL_I2C_Mem_Read+0x110>
                         I2C_GENERATE_START_READ);
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
 801027c:	68fb      	ldr	r3, [r7, #12]
 801027e:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8010280:	b29a      	uxth	r2, r3
 8010282:	68fb      	ldr	r3, [r7, #12]
 8010284:	851a      	strh	r2, [r3, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
 8010286:	68fb      	ldr	r3, [r7, #12]
 8010288:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 801028a:	b2da      	uxtb	r2, r3
 801028c:	8979      	ldrh	r1, [r7, #10]
 801028e:	4b4a      	ldr	r3, [pc, #296]	@ (80103b8 <HAL_I2C_Mem_Read+0x22c>)
 8010290:	9300      	str	r3, [sp, #0]
 8010292:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
 8010296:	68f8      	ldr	r0, [r7, #12]
 8010298:	f001 f8e4 	bl	8011464 <I2C_TransferConfig>
    }

    do
    {
      /* Wait until RXNE flag is set */
      if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, Timeout, tickstart) != HAL_OK)
 801029c:	697b      	ldr	r3, [r7, #20]
 801029e:	9300      	str	r3, [sp, #0]
 80102a0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80102a2:	2200      	movs	r2, #0
 80102a4:	2104      	movs	r1, #4
 80102a6:	68f8      	ldr	r0, [r7, #12]
 80102a8:	f000 ff19 	bl	80110de <I2C_WaitOnFlagUntilTimeout>
 80102ac:	4603      	mov	r3, r0
 80102ae:	2b00      	cmp	r3, #0
 80102b0:	d001      	beq.n	80102b6 <HAL_I2C_Mem_Read+0x12a>
      {
        return HAL_ERROR;
 80102b2:	2301      	movs	r3, #1
 80102b4:	e07c      	b.n	80103b0 <HAL_I2C_Mem_Read+0x224>
      }

      /* Read data from RXDR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
 80102b6:	68fb      	ldr	r3, [r7, #12]
 80102b8:	681b      	ldr	r3, [r3, #0]
 80102ba:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 80102bc:	68fb      	ldr	r3, [r7, #12]
 80102be:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80102c0:	b2d2      	uxtb	r2, r2
 80102c2:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
 80102c4:	68fb      	ldr	r3, [r7, #12]
 80102c6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80102c8:	1c5a      	adds	r2, r3, #1
 80102ca:	68fb      	ldr	r3, [r7, #12]
 80102cc:	625a      	str	r2, [r3, #36]	@ 0x24

      hi2c->XferSize--;
 80102ce:	68fb      	ldr	r3, [r7, #12]
 80102d0:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 80102d2:	3b01      	subs	r3, #1
 80102d4:	b29a      	uxth	r2, r3
 80102d6:	68fb      	ldr	r3, [r7, #12]
 80102d8:	851a      	strh	r2, [r3, #40]	@ 0x28
      hi2c->XferCount--;
 80102da:	68fb      	ldr	r3, [r7, #12]
 80102dc:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 80102de:	b29b      	uxth	r3, r3
 80102e0:	3b01      	subs	r3, #1
 80102e2:	b29a      	uxth	r2, r3
 80102e4:	68fb      	ldr	r3, [r7, #12]
 80102e6:	855a      	strh	r2, [r3, #42]	@ 0x2a

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 80102e8:	68fb      	ldr	r3, [r7, #12]
 80102ea:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 80102ec:	b29b      	uxth	r3, r3
 80102ee:	2b00      	cmp	r3, #0
 80102f0:	d034      	beq.n	801035c <HAL_I2C_Mem_Read+0x1d0>
 80102f2:	68fb      	ldr	r3, [r7, #12]
 80102f4:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 80102f6:	2b00      	cmp	r3, #0
 80102f8:	d130      	bne.n	801035c <HAL_I2C_Mem_Read+0x1d0>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
 80102fa:	697b      	ldr	r3, [r7, #20]
 80102fc:	9300      	str	r3, [sp, #0]
 80102fe:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8010300:	2200      	movs	r2, #0
 8010302:	2180      	movs	r1, #128	@ 0x80
 8010304:	68f8      	ldr	r0, [r7, #12]
 8010306:	f000 feea 	bl	80110de <I2C_WaitOnFlagUntilTimeout>
 801030a:	4603      	mov	r3, r0
 801030c:	2b00      	cmp	r3, #0
 801030e:	d001      	beq.n	8010314 <HAL_I2C_Mem_Read+0x188>
        {
          return HAL_ERROR;
 8010310:	2301      	movs	r3, #1
 8010312:	e04d      	b.n	80103b0 <HAL_I2C_Mem_Read+0x224>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8010314:	68fb      	ldr	r3, [r7, #12]
 8010316:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8010318:	b29b      	uxth	r3, r3
 801031a:	2bff      	cmp	r3, #255	@ 0xff
 801031c:	d90e      	bls.n	801033c <HAL_I2C_Mem_Read+0x1b0>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
 801031e:	68fb      	ldr	r3, [r7, #12]
 8010320:	22ff      	movs	r2, #255	@ 0xff
 8010322:	851a      	strh	r2, [r3, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t) hi2c->XferSize, I2C_RELOAD_MODE,
 8010324:	68fb      	ldr	r3, [r7, #12]
 8010326:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 8010328:	b2da      	uxtb	r2, r3
 801032a:	8979      	ldrh	r1, [r7, #10]
 801032c:	2300      	movs	r3, #0
 801032e:	9300      	str	r3, [sp, #0]
 8010330:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
 8010334:	68f8      	ldr	r0, [r7, #12]
 8010336:	f001 f895 	bl	8011464 <I2C_TransferConfig>
 801033a:	e00f      	b.n	801035c <HAL_I2C_Mem_Read+0x1d0>
                             I2C_NO_STARTSTOP);
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
 801033c:	68fb      	ldr	r3, [r7, #12]
 801033e:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8010340:	b29a      	uxth	r2, r3
 8010342:	68fb      	ldr	r3, [r7, #12]
 8010344:	851a      	strh	r2, [r3, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
 8010346:	68fb      	ldr	r3, [r7, #12]
 8010348:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 801034a:	b2da      	uxtb	r2, r3
 801034c:	8979      	ldrh	r1, [r7, #10]
 801034e:	2300      	movs	r3, #0
 8010350:	9300      	str	r3, [sp, #0]
 8010352:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
 8010356:	68f8      	ldr	r0, [r7, #12]
 8010358:	f001 f884 	bl	8011464 <I2C_TransferConfig>
                             I2C_NO_STARTSTOP);
        }
      }
    } while (hi2c->XferCount > 0U);
 801035c:	68fb      	ldr	r3, [r7, #12]
 801035e:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8010360:	b29b      	uxth	r3, r3
 8010362:	2b00      	cmp	r3, #0
 8010364:	d19a      	bne.n	801029c <HAL_I2C_Mem_Read+0x110>

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is reset */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8010366:	697a      	ldr	r2, [r7, #20]
 8010368:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 801036a:	68f8      	ldr	r0, [r7, #12]
 801036c:	f000 ff57 	bl	801121e <I2C_WaitOnSTOPFlagUntilTimeout>
 8010370:	4603      	mov	r3, r0
 8010372:	2b00      	cmp	r3, #0
 8010374:	d001      	beq.n	801037a <HAL_I2C_Mem_Read+0x1ee>
    {
      return HAL_ERROR;
 8010376:	2301      	movs	r3, #1
 8010378:	e01a      	b.n	80103b0 <HAL_I2C_Mem_Read+0x224>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 801037a:	68fb      	ldr	r3, [r7, #12]
 801037c:	681b      	ldr	r3, [r3, #0]
 801037e:	2220      	movs	r2, #32
 8010380:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 8010382:	68fb      	ldr	r3, [r7, #12]
 8010384:	681b      	ldr	r3, [r3, #0]
 8010386:	6859      	ldr	r1, [r3, #4]
 8010388:	68fb      	ldr	r3, [r7, #12]
 801038a:	681a      	ldr	r2, [r3, #0]
 801038c:	4b0b      	ldr	r3, [pc, #44]	@ (80103bc <HAL_I2C_Mem_Read+0x230>)
 801038e:	400b      	ands	r3, r1
 8010390:	6053      	str	r3, [r2, #4]

    hi2c->State = HAL_I2C_STATE_READY;
 8010392:	68fb      	ldr	r3, [r7, #12]
 8010394:	2220      	movs	r2, #32
 8010396:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 801039a:	68fb      	ldr	r3, [r7, #12]
 801039c:	2200      	movs	r2, #0
 801039e:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 80103a2:	68fb      	ldr	r3, [r7, #12]
 80103a4:	2200      	movs	r2, #0
 80103a6:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    return HAL_OK;
 80103aa:	2300      	movs	r3, #0
 80103ac:	e000      	b.n	80103b0 <HAL_I2C_Mem_Read+0x224>
  }
  else
  {
    return HAL_BUSY;
 80103ae:	2302      	movs	r3, #2
  }
}
 80103b0:	4618      	mov	r0, r3
 80103b2:	3718      	adds	r7, #24
 80103b4:	46bd      	mov	sp, r7
 80103b6:	bd80      	pop	{r7, pc}
 80103b8:	80002400 	.word	0x80002400
 80103bc:	fe00e800 	.word	0xfe00e800

080103c0 <HAL_I2C_EV_IRQHandler>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
void HAL_I2C_EV_IRQHandler(I2C_HandleTypeDef *hi2c) /* Derogation MISRAC2012-Rule-8.13 */
{
 80103c0:	b580      	push	{r7, lr}
 80103c2:	b084      	sub	sp, #16
 80103c4:	af00      	add	r7, sp, #0
 80103c6:	6078      	str	r0, [r7, #4]
  /* Get current IT Flags and IT sources value */
  uint32_t itflags   = READ_REG(hi2c->Instance->ISR);
 80103c8:	687b      	ldr	r3, [r7, #4]
 80103ca:	681b      	ldr	r3, [r3, #0]
 80103cc:	699b      	ldr	r3, [r3, #24]
 80103ce:	60fb      	str	r3, [r7, #12]
  uint32_t itsources = READ_REG(hi2c->Instance->CR1);
 80103d0:	687b      	ldr	r3, [r7, #4]
 80103d2:	681b      	ldr	r3, [r3, #0]
 80103d4:	681b      	ldr	r3, [r3, #0]
 80103d6:	60bb      	str	r3, [r7, #8]

  /* I2C events treatment -------------------------------------*/
  if (hi2c->XferISR != NULL)
 80103d8:	687b      	ldr	r3, [r7, #4]
 80103da:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80103dc:	2b00      	cmp	r3, #0
 80103de:	d005      	beq.n	80103ec <HAL_I2C_EV_IRQHandler+0x2c>
  {
    hi2c->XferISR(hi2c, itflags, itsources);
 80103e0:	687b      	ldr	r3, [r7, #4]
 80103e2:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80103e4:	68ba      	ldr	r2, [r7, #8]
 80103e6:	68f9      	ldr	r1, [r7, #12]
 80103e8:	6878      	ldr	r0, [r7, #4]
 80103ea:	4798      	blx	r3
  }
}
 80103ec:	bf00      	nop
 80103ee:	3710      	adds	r7, #16
 80103f0:	46bd      	mov	sp, r7
 80103f2:	bd80      	pop	{r7, pc}

080103f4 <HAL_I2C_ER_IRQHandler>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
void HAL_I2C_ER_IRQHandler(I2C_HandleTypeDef *hi2c)
{
 80103f4:	b580      	push	{r7, lr}
 80103f6:	b086      	sub	sp, #24
 80103f8:	af00      	add	r7, sp, #0
 80103fa:	6078      	str	r0, [r7, #4]
  uint32_t itflags   = READ_REG(hi2c->Instance->ISR);
 80103fc:	687b      	ldr	r3, [r7, #4]
 80103fe:	681b      	ldr	r3, [r3, #0]
 8010400:	699b      	ldr	r3, [r3, #24]
 8010402:	617b      	str	r3, [r7, #20]
  uint32_t itsources = READ_REG(hi2c->Instance->CR1);
 8010404:	687b      	ldr	r3, [r7, #4]
 8010406:	681b      	ldr	r3, [r3, #0]
 8010408:	681b      	ldr	r3, [r3, #0]
 801040a:	613b      	str	r3, [r7, #16]
  uint32_t tmperror;

  /* I2C Bus error interrupt occurred ------------------------------------*/
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_BERR) != RESET) && \
 801040c:	697b      	ldr	r3, [r7, #20]
 801040e:	0a1b      	lsrs	r3, r3, #8
 8010410:	f003 0301 	and.w	r3, r3, #1
 8010414:	2b00      	cmp	r3, #0
 8010416:	d010      	beq.n	801043a <HAL_I2C_ER_IRQHandler+0x46>
      (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
 8010418:	693b      	ldr	r3, [r7, #16]
 801041a:	09db      	lsrs	r3, r3, #7
 801041c:	f003 0301 	and.w	r3, r3, #1
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_BERR) != RESET) && \
 8010420:	2b00      	cmp	r3, #0
 8010422:	d00a      	beq.n	801043a <HAL_I2C_ER_IRQHandler+0x46>
  {
    hi2c->ErrorCode |= HAL_I2C_ERROR_BERR;
 8010424:	687b      	ldr	r3, [r7, #4]
 8010426:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8010428:	f043 0201 	orr.w	r2, r3, #1
 801042c:	687b      	ldr	r3, [r7, #4]
 801042e:	645a      	str	r2, [r3, #68]	@ 0x44

    /* Clear BERR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
 8010430:	687b      	ldr	r3, [r7, #4]
 8010432:	681b      	ldr	r3, [r3, #0]
 8010434:	f44f 7280 	mov.w	r2, #256	@ 0x100
 8010438:	61da      	str	r2, [r3, #28]
  }

  /* I2C Over-Run/Under-Run interrupt occurred ----------------------------------------*/
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_OVR) != RESET) && \
 801043a:	697b      	ldr	r3, [r7, #20]
 801043c:	0a9b      	lsrs	r3, r3, #10
 801043e:	f003 0301 	and.w	r3, r3, #1
 8010442:	2b00      	cmp	r3, #0
 8010444:	d010      	beq.n	8010468 <HAL_I2C_ER_IRQHandler+0x74>
      (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
 8010446:	693b      	ldr	r3, [r7, #16]
 8010448:	09db      	lsrs	r3, r3, #7
 801044a:	f003 0301 	and.w	r3, r3, #1
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_OVR) != RESET) && \
 801044e:	2b00      	cmp	r3, #0
 8010450:	d00a      	beq.n	8010468 <HAL_I2C_ER_IRQHandler+0x74>
  {
    hi2c->ErrorCode |= HAL_I2C_ERROR_OVR;
 8010452:	687b      	ldr	r3, [r7, #4]
 8010454:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8010456:	f043 0208 	orr.w	r2, r3, #8
 801045a:	687b      	ldr	r3, [r7, #4]
 801045c:	645a      	str	r2, [r3, #68]	@ 0x44

    /* Clear OVR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
 801045e:	687b      	ldr	r3, [r7, #4]
 8010460:	681b      	ldr	r3, [r3, #0]
 8010462:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 8010466:	61da      	str	r2, [r3, #28]
  }

  /* I2C Arbitration Loss error interrupt occurred -------------------------------------*/
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_ARLO) != RESET) && \
 8010468:	697b      	ldr	r3, [r7, #20]
 801046a:	0a5b      	lsrs	r3, r3, #9
 801046c:	f003 0301 	and.w	r3, r3, #1
 8010470:	2b00      	cmp	r3, #0
 8010472:	d010      	beq.n	8010496 <HAL_I2C_ER_IRQHandler+0xa2>
      (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
 8010474:	693b      	ldr	r3, [r7, #16]
 8010476:	09db      	lsrs	r3, r3, #7
 8010478:	f003 0301 	and.w	r3, r3, #1
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_ARLO) != RESET) && \
 801047c:	2b00      	cmp	r3, #0
 801047e:	d00a      	beq.n	8010496 <HAL_I2C_ER_IRQHandler+0xa2>
  {
    hi2c->ErrorCode |= HAL_I2C_ERROR_ARLO;
 8010480:	687b      	ldr	r3, [r7, #4]
 8010482:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8010484:	f043 0202 	orr.w	r2, r3, #2
 8010488:	687b      	ldr	r3, [r7, #4]
 801048a:	645a      	str	r2, [r3, #68]	@ 0x44

    /* Clear ARLO flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
 801048c:	687b      	ldr	r3, [r7, #4]
 801048e:	681b      	ldr	r3, [r3, #0]
 8010490:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8010494:	61da      	str	r2, [r3, #28]
  }

  /* Store current volatile hi2c->ErrorCode, misra rule */
  tmperror = hi2c->ErrorCode;
 8010496:	687b      	ldr	r3, [r7, #4]
 8010498:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 801049a:	60fb      	str	r3, [r7, #12]

  /* Call the Error Callback in case of Error detected */
  if ((tmperror & (HAL_I2C_ERROR_BERR | HAL_I2C_ERROR_OVR | HAL_I2C_ERROR_ARLO)) !=  HAL_I2C_ERROR_NONE)
 801049c:	68fb      	ldr	r3, [r7, #12]
 801049e:	f003 030b 	and.w	r3, r3, #11
 80104a2:	2b00      	cmp	r3, #0
 80104a4:	d003      	beq.n	80104ae <HAL_I2C_ER_IRQHandler+0xba>
  {
    I2C_ITError(hi2c, tmperror);
 80104a6:	68f9      	ldr	r1, [r7, #12]
 80104a8:	6878      	ldr	r0, [r7, #4]
 80104aa:	f000 fcbf 	bl	8010e2c <I2C_ITError>
  }
}
 80104ae:	bf00      	nop
 80104b0:	3718      	adds	r7, #24
 80104b2:	46bd      	mov	sp, r7
 80104b4:	bd80      	pop	{r7, pc}

080104b6 <HAL_I2C_SlaveTxCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_SlaveTxCpltCallback(I2C_HandleTypeDef *hi2c)
{
 80104b6:	b480      	push	{r7}
 80104b8:	b083      	sub	sp, #12
 80104ba:	af00      	add	r7, sp, #0
 80104bc:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_SlaveTxCpltCallback could be implemented in the user file
   */
}
 80104be:	bf00      	nop
 80104c0:	370c      	adds	r7, #12
 80104c2:	46bd      	mov	sp, r7
 80104c4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80104c8:	4770      	bx	lr

080104ca <HAL_I2C_SlaveRxCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef *hi2c)
{
 80104ca:	b480      	push	{r7}
 80104cc:	b083      	sub	sp, #12
 80104ce:	af00      	add	r7, sp, #0
 80104d0:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_SlaveRxCpltCallback could be implemented in the user file
   */
}
 80104d2:	bf00      	nop
 80104d4:	370c      	adds	r7, #12
 80104d6:	46bd      	mov	sp, r7
 80104d8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80104dc:	4770      	bx	lr

080104de <HAL_I2C_AddrCallback>:
  * @param  TransferDirection Master request Transfer Direction (Write/Read), value of @ref I2C_XFERDIRECTION
  * @param  AddrMatchCode Address Match Code
  * @retval None
  */
__weak void HAL_I2C_AddrCallback(I2C_HandleTypeDef *hi2c, uint8_t TransferDirection, uint16_t AddrMatchCode)
{
 80104de:	b480      	push	{r7}
 80104e0:	b083      	sub	sp, #12
 80104e2:	af00      	add	r7, sp, #0
 80104e4:	6078      	str	r0, [r7, #4]
 80104e6:	460b      	mov	r3, r1
 80104e8:	70fb      	strb	r3, [r7, #3]
 80104ea:	4613      	mov	r3, r2
 80104ec:	803b      	strh	r3, [r7, #0]
  UNUSED(AddrMatchCode);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_AddrCallback() could be implemented in the user file
   */
}
 80104ee:	bf00      	nop
 80104f0:	370c      	adds	r7, #12
 80104f2:	46bd      	mov	sp, r7
 80104f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80104f8:	4770      	bx	lr

080104fa <HAL_I2C_ListenCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_ListenCpltCallback(I2C_HandleTypeDef *hi2c)
{
 80104fa:	b480      	push	{r7}
 80104fc:	b083      	sub	sp, #12
 80104fe:	af00      	add	r7, sp, #0
 8010500:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_ListenCpltCallback() could be implemented in the user file
   */
}
 8010502:	bf00      	nop
 8010504:	370c      	adds	r7, #12
 8010506:	46bd      	mov	sp, r7
 8010508:	f85d 7b04 	ldr.w	r7, [sp], #4
 801050c:	4770      	bx	lr

0801050e <HAL_I2C_ErrorCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c)
{
 801050e:	b480      	push	{r7}
 8010510:	b083      	sub	sp, #12
 8010512:	af00      	add	r7, sp, #0
 8010514:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_ErrorCallback could be implemented in the user file
   */
}
 8010516:	bf00      	nop
 8010518:	370c      	adds	r7, #12
 801051a:	46bd      	mov	sp, r7
 801051c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010520:	4770      	bx	lr

08010522 <HAL_I2C_AbortCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_AbortCpltCallback(I2C_HandleTypeDef *hi2c)
{
 8010522:	b480      	push	{r7}
 8010524:	b083      	sub	sp, #12
 8010526:	af00      	add	r7, sp, #0
 8010528:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_AbortCpltCallback could be implemented in the user file
   */
}
 801052a:	bf00      	nop
 801052c:	370c      	adds	r7, #12
 801052e:	46bd      	mov	sp, r7
 8010530:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010534:	4770      	bx	lr

08010536 <HAL_I2C_GetState>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL state
  */
HAL_I2C_StateTypeDef HAL_I2C_GetState(const I2C_HandleTypeDef *hi2c)
{
 8010536:	b480      	push	{r7}
 8010538:	b083      	sub	sp, #12
 801053a:	af00      	add	r7, sp, #0
 801053c:	6078      	str	r0, [r7, #4]
  /* Return I2C handle state */
  return hi2c->State;
 801053e:	687b      	ldr	r3, [r7, #4]
 8010540:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 8010544:	b2db      	uxtb	r3, r3
}
 8010546:	4618      	mov	r0, r3
 8010548:	370c      	adds	r7, #12
 801054a:	46bd      	mov	sp, r7
 801054c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010550:	4770      	bx	lr

08010552 <HAL_I2C_GetError>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *              the configuration information for the specified I2C.
  * @retval I2C Error Code
  */
uint32_t HAL_I2C_GetError(const I2C_HandleTypeDef *hi2c)
{
 8010552:	b480      	push	{r7}
 8010554:	b083      	sub	sp, #12
 8010556:	af00      	add	r7, sp, #0
 8010558:	6078      	str	r0, [r7, #4]
  return hi2c->ErrorCode;
 801055a:	687b      	ldr	r3, [r7, #4]
 801055c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
}
 801055e:	4618      	mov	r0, r3
 8010560:	370c      	adds	r7, #12
 8010562:	46bd      	mov	sp, r7
 8010564:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010568:	4770      	bx	lr

0801056a <I2C_Slave_ISR_IT>:
  * @param  ITSources Interrupt sources enabled.
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_Slave_ISR_IT(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags,
                                          uint32_t ITSources)
{
 801056a:	b580      	push	{r7, lr}
 801056c:	b086      	sub	sp, #24
 801056e:	af00      	add	r7, sp, #0
 8010570:	60f8      	str	r0, [r7, #12]
 8010572:	60b9      	str	r1, [r7, #8]
 8010574:	607a      	str	r2, [r7, #4]
  uint32_t tmpoptions = hi2c->XferOptions;
 8010576:	68fb      	ldr	r3, [r7, #12]
 8010578:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 801057a:	617b      	str	r3, [r7, #20]
  uint32_t tmpITFlags = ITFlags;
 801057c:	68bb      	ldr	r3, [r7, #8]
 801057e:	613b      	str	r3, [r7, #16]

  /* Process locked */
  __HAL_LOCK(hi2c);
 8010580:	68fb      	ldr	r3, [r7, #12]
 8010582:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
 8010586:	2b01      	cmp	r3, #1
 8010588:	d101      	bne.n	801058e <I2C_Slave_ISR_IT+0x24>
 801058a:	2302      	movs	r3, #2
 801058c:	e0ed      	b.n	801076a <I2C_Slave_ISR_IT+0x200>
 801058e:	68fb      	ldr	r3, [r7, #12]
 8010590:	2201      	movs	r2, #1
 8010592:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

  /* Check if STOPF is set */
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && \
 8010596:	693b      	ldr	r3, [r7, #16]
 8010598:	095b      	lsrs	r3, r3, #5
 801059a:	f003 0301 	and.w	r3, r3, #1
 801059e:	2b00      	cmp	r3, #0
 80105a0:	d00a      	beq.n	80105b8 <I2C_Slave_ISR_IT+0x4e>
      (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
 80105a2:	687b      	ldr	r3, [r7, #4]
 80105a4:	095b      	lsrs	r3, r3, #5
 80105a6:	f003 0301 	and.w	r3, r3, #1
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && \
 80105aa:	2b00      	cmp	r3, #0
 80105ac:	d004      	beq.n	80105b8 <I2C_Slave_ISR_IT+0x4e>
  {
    /* Call I2C Slave complete process */
    I2C_ITSlaveCplt(hi2c, tmpITFlags);
 80105ae:	6939      	ldr	r1, [r7, #16]
 80105b0:	68f8      	ldr	r0, [r7, #12]
 80105b2:	f000 fa69 	bl	8010a88 <I2C_ITSlaveCplt>
 80105b6:	e0d3      	b.n	8010760 <I2C_Slave_ISR_IT+0x1f6>
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && \
 80105b8:	693b      	ldr	r3, [r7, #16]
 80105ba:	091b      	lsrs	r3, r3, #4
 80105bc:	f003 0301 	and.w	r3, r3, #1
 80105c0:	2b00      	cmp	r3, #0
 80105c2:	d04d      	beq.n	8010660 <I2C_Slave_ISR_IT+0xf6>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
 80105c4:	687b      	ldr	r3, [r7, #4]
 80105c6:	091b      	lsrs	r3, r3, #4
 80105c8:	f003 0301 	and.w	r3, r3, #1
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && \
 80105cc:	2b00      	cmp	r3, #0
 80105ce:	d047      	beq.n	8010660 <I2C_Slave_ISR_IT+0xf6>
  {
    /* Check that I2C transfer finished */
    /* if yes, normal use case, a NACK is sent by the MASTER when Transfer is finished */
    /* Mean XferCount == 0*/
    /* So clear Flag NACKF only */
    if (hi2c->XferCount == 0U)
 80105d0:	68fb      	ldr	r3, [r7, #12]
 80105d2:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 80105d4:	b29b      	uxth	r3, r3
 80105d6:	2b00      	cmp	r3, #0
 80105d8:	d128      	bne.n	801062c <I2C_Slave_ISR_IT+0xc2>
    {
      if ((hi2c->State == HAL_I2C_STATE_LISTEN) && (tmpoptions == I2C_FIRST_AND_LAST_FRAME))
 80105da:	68fb      	ldr	r3, [r7, #12]
 80105dc:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 80105e0:	b2db      	uxtb	r3, r3
 80105e2:	2b28      	cmp	r3, #40	@ 0x28
 80105e4:	d108      	bne.n	80105f8 <I2C_Slave_ISR_IT+0x8e>
 80105e6:	697b      	ldr	r3, [r7, #20]
 80105e8:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 80105ec:	d104      	bne.n	80105f8 <I2C_Slave_ISR_IT+0x8e>
        /* Same action must be done for (tmpoptions == I2C_LAST_FRAME) which removed for
           Warning[Pa134]: left and right operands are identical */
      {
        /* Call I2C Listen complete process */
        I2C_ITListenCplt(hi2c, tmpITFlags);
 80105ee:	6939      	ldr	r1, [r7, #16]
 80105f0:	68f8      	ldr	r0, [r7, #12]
 80105f2:	f000 fbc5 	bl	8010d80 <I2C_ITListenCplt>
 80105f6:	e032      	b.n	801065e <I2C_Slave_ISR_IT+0xf4>
      }
      else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))
 80105f8:	68fb      	ldr	r3, [r7, #12]
 80105fa:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 80105fe:	b2db      	uxtb	r3, r3
 8010600:	2b29      	cmp	r3, #41	@ 0x29
 8010602:	d10e      	bne.n	8010622 <I2C_Slave_ISR_IT+0xb8>
 8010604:	697b      	ldr	r3, [r7, #20]
 8010606:	f513 3f80 	cmn.w	r3, #65536	@ 0x10000
 801060a:	d00a      	beq.n	8010622 <I2C_Slave_ISR_IT+0xb8>
      {
        /* Clear NACK Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 801060c:	68fb      	ldr	r3, [r7, #12]
 801060e:	681b      	ldr	r3, [r3, #0]
 8010610:	2210      	movs	r2, #16
 8010612:	61da      	str	r2, [r3, #28]

        /* Flush TX register */
        I2C_Flush_TXDR(hi2c);
 8010614:	68f8      	ldr	r0, [r7, #12]
 8010616:	f000 fd20 	bl	801105a <I2C_Flush_TXDR>

        /* Last Byte is Transmitted */
        /* Call I2C Slave Sequential complete process */
        I2C_ITSlaveSeqCplt(hi2c);
 801061a:	68f8      	ldr	r0, [r7, #12]
 801061c:	f000 f9d6 	bl	80109cc <I2C_ITSlaveSeqCplt>
 8010620:	e01d      	b.n	801065e <I2C_Slave_ISR_IT+0xf4>
      }
      else
      {
        /* Clear NACK Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8010622:	68fb      	ldr	r3, [r7, #12]
 8010624:	681b      	ldr	r3, [r3, #0]
 8010626:	2210      	movs	r2, #16
 8010628:	61da      	str	r2, [r3, #28]
    if (hi2c->XferCount == 0U)
 801062a:	e096      	b.n	801075a <I2C_Slave_ISR_IT+0x1f0>
    }
    else
    {
      /* if no, error use case, a Non-Acknowledge of last Data is generated by the MASTER*/
      /* Clear NACK Flag */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 801062c:	68fb      	ldr	r3, [r7, #12]
 801062e:	681b      	ldr	r3, [r3, #0]
 8010630:	2210      	movs	r2, #16
 8010632:	61da      	str	r2, [r3, #28]

      /* Set ErrorCode corresponding to a Non-Acknowledge */
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8010634:	68fb      	ldr	r3, [r7, #12]
 8010636:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8010638:	f043 0204 	orr.w	r2, r3, #4
 801063c:	68fb      	ldr	r3, [r7, #12]
 801063e:	645a      	str	r2, [r3, #68]	@ 0x44

      if ((tmpoptions == I2C_FIRST_FRAME) || (tmpoptions == I2C_NEXT_FRAME))
 8010640:	697b      	ldr	r3, [r7, #20]
 8010642:	2b00      	cmp	r3, #0
 8010644:	d004      	beq.n	8010650 <I2C_Slave_ISR_IT+0xe6>
 8010646:	697b      	ldr	r3, [r7, #20]
 8010648:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
 801064c:	f040 8085 	bne.w	801075a <I2C_Slave_ISR_IT+0x1f0>
      {
        /* Call the corresponding callback to inform upper layer of End of Transfer */
        I2C_ITError(hi2c, hi2c->ErrorCode);
 8010650:	68fb      	ldr	r3, [r7, #12]
 8010652:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8010654:	4619      	mov	r1, r3
 8010656:	68f8      	ldr	r0, [r7, #12]
 8010658:	f000 fbe8 	bl	8010e2c <I2C_ITError>
    if (hi2c->XferCount == 0U)
 801065c:	e07d      	b.n	801075a <I2C_Slave_ISR_IT+0x1f0>
 801065e:	e07c      	b.n	801075a <I2C_Slave_ISR_IT+0x1f0>
      }
    }
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && \
 8010660:	693b      	ldr	r3, [r7, #16]
 8010662:	089b      	lsrs	r3, r3, #2
 8010664:	f003 0301 	and.w	r3, r3, #1
 8010668:	2b00      	cmp	r3, #0
 801066a:	d030      	beq.n	80106ce <I2C_Slave_ISR_IT+0x164>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_RXI) != RESET))
 801066c:	687b      	ldr	r3, [r7, #4]
 801066e:	089b      	lsrs	r3, r3, #2
 8010670:	f003 0301 	and.w	r3, r3, #1
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && \
 8010674:	2b00      	cmp	r3, #0
 8010676:	d02a      	beq.n	80106ce <I2C_Slave_ISR_IT+0x164>
  {
    if (hi2c->XferCount > 0U)
 8010678:	68fb      	ldr	r3, [r7, #12]
 801067a:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 801067c:	b29b      	uxth	r3, r3
 801067e:	2b00      	cmp	r3, #0
 8010680:	d018      	beq.n	80106b4 <I2C_Slave_ISR_IT+0x14a>
    {
      /* Read data from RXDR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
 8010682:	68fb      	ldr	r3, [r7, #12]
 8010684:	681b      	ldr	r3, [r3, #0]
 8010686:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 8010688:	68fb      	ldr	r3, [r7, #12]
 801068a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801068c:	b2d2      	uxtb	r2, r2
 801068e:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
 8010690:	68fb      	ldr	r3, [r7, #12]
 8010692:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8010694:	1c5a      	adds	r2, r3, #1
 8010696:	68fb      	ldr	r3, [r7, #12]
 8010698:	625a      	str	r2, [r3, #36]	@ 0x24

      hi2c->XferSize--;
 801069a:	68fb      	ldr	r3, [r7, #12]
 801069c:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 801069e:	3b01      	subs	r3, #1
 80106a0:	b29a      	uxth	r2, r3
 80106a2:	68fb      	ldr	r3, [r7, #12]
 80106a4:	851a      	strh	r2, [r3, #40]	@ 0x28
      hi2c->XferCount--;
 80106a6:	68fb      	ldr	r3, [r7, #12]
 80106a8:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 80106aa:	b29b      	uxth	r3, r3
 80106ac:	3b01      	subs	r3, #1
 80106ae:	b29a      	uxth	r2, r3
 80106b0:	68fb      	ldr	r3, [r7, #12]
 80106b2:	855a      	strh	r2, [r3, #42]	@ 0x2a
    }

    if ((hi2c->XferCount == 0U) && \
 80106b4:	68fb      	ldr	r3, [r7, #12]
 80106b6:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 80106b8:	b29b      	uxth	r3, r3
 80106ba:	2b00      	cmp	r3, #0
 80106bc:	d14f      	bne.n	801075e <I2C_Slave_ISR_IT+0x1f4>
 80106be:	697b      	ldr	r3, [r7, #20]
 80106c0:	f513 3f80 	cmn.w	r3, #65536	@ 0x10000
 80106c4:	d04b      	beq.n	801075e <I2C_Slave_ISR_IT+0x1f4>
        (tmpoptions != I2C_NO_OPTION_FRAME))
    {
      /* Call I2C Slave Sequential complete process */
      I2C_ITSlaveSeqCplt(hi2c);
 80106c6:	68f8      	ldr	r0, [r7, #12]
 80106c8:	f000 f980 	bl	80109cc <I2C_ITSlaveSeqCplt>
    if ((hi2c->XferCount == 0U) && \
 80106cc:	e047      	b.n	801075e <I2C_Slave_ISR_IT+0x1f4>
    }
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_ADDR) != RESET) && \
 80106ce:	693b      	ldr	r3, [r7, #16]
 80106d0:	08db      	lsrs	r3, r3, #3
 80106d2:	f003 0301 	and.w	r3, r3, #1
 80106d6:	2b00      	cmp	r3, #0
 80106d8:	d00a      	beq.n	80106f0 <I2C_Slave_ISR_IT+0x186>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_ADDRI) != RESET))
 80106da:	687b      	ldr	r3, [r7, #4]
 80106dc:	08db      	lsrs	r3, r3, #3
 80106de:	f003 0301 	and.w	r3, r3, #1
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_ADDR) != RESET) && \
 80106e2:	2b00      	cmp	r3, #0
 80106e4:	d004      	beq.n	80106f0 <I2C_Slave_ISR_IT+0x186>
  {
    I2C_ITAddrCplt(hi2c, tmpITFlags);
 80106e6:	6939      	ldr	r1, [r7, #16]
 80106e8:	68f8      	ldr	r0, [r7, #12]
 80106ea:	f000 f8eb 	bl	80108c4 <I2C_ITAddrCplt>
 80106ee:	e037      	b.n	8010760 <I2C_Slave_ISR_IT+0x1f6>
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TXIS) != RESET) && \
 80106f0:	693b      	ldr	r3, [r7, #16]
 80106f2:	085b      	lsrs	r3, r3, #1
 80106f4:	f003 0301 	and.w	r3, r3, #1
 80106f8:	2b00      	cmp	r3, #0
 80106fa:	d031      	beq.n	8010760 <I2C_Slave_ISR_IT+0x1f6>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TXI) != RESET))
 80106fc:	687b      	ldr	r3, [r7, #4]
 80106fe:	085b      	lsrs	r3, r3, #1
 8010700:	f003 0301 	and.w	r3, r3, #1
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TXIS) != RESET) && \
 8010704:	2b00      	cmp	r3, #0
 8010706:	d02b      	beq.n	8010760 <I2C_Slave_ISR_IT+0x1f6>
  {
    /* Write data to TXDR only if XferCount not reach "0" */
    /* A TXIS flag can be set, during STOP treatment      */
    /* Check if all Data have already been sent */
    /* If it is the case, this last write in TXDR is not sent, correspond to a dummy TXIS event */
    if (hi2c->XferCount > 0U)
 8010708:	68fb      	ldr	r3, [r7, #12]
 801070a:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 801070c:	b29b      	uxth	r3, r3
 801070e:	2b00      	cmp	r3, #0
 8010710:	d018      	beq.n	8010744 <I2C_Slave_ISR_IT+0x1da>
    {
      /* Write data to TXDR */
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
 8010712:	68fb      	ldr	r3, [r7, #12]
 8010714:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8010716:	781a      	ldrb	r2, [r3, #0]
 8010718:	68fb      	ldr	r3, [r7, #12]
 801071a:	681b      	ldr	r3, [r3, #0]
 801071c:	629a      	str	r2, [r3, #40]	@ 0x28

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
 801071e:	68fb      	ldr	r3, [r7, #12]
 8010720:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8010722:	1c5a      	adds	r2, r3, #1
 8010724:	68fb      	ldr	r3, [r7, #12]
 8010726:	625a      	str	r2, [r3, #36]	@ 0x24

      hi2c->XferCount--;
 8010728:	68fb      	ldr	r3, [r7, #12]
 801072a:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 801072c:	b29b      	uxth	r3, r3
 801072e:	3b01      	subs	r3, #1
 8010730:	b29a      	uxth	r2, r3
 8010732:	68fb      	ldr	r3, [r7, #12]
 8010734:	855a      	strh	r2, [r3, #42]	@ 0x2a
      hi2c->XferSize--;
 8010736:	68fb      	ldr	r3, [r7, #12]
 8010738:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 801073a:	3b01      	subs	r3, #1
 801073c:	b29a      	uxth	r2, r3
 801073e:	68fb      	ldr	r3, [r7, #12]
 8010740:	851a      	strh	r2, [r3, #40]	@ 0x28
 8010742:	e00d      	b.n	8010760 <I2C_Slave_ISR_IT+0x1f6>
    }
    else
    {
      if ((tmpoptions == I2C_NEXT_FRAME) || (tmpoptions == I2C_FIRST_FRAME))
 8010744:	697b      	ldr	r3, [r7, #20]
 8010746:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
 801074a:	d002      	beq.n	8010752 <I2C_Slave_ISR_IT+0x1e8>
 801074c:	697b      	ldr	r3, [r7, #20]
 801074e:	2b00      	cmp	r3, #0
 8010750:	d106      	bne.n	8010760 <I2C_Slave_ISR_IT+0x1f6>
      {
        /* Last Byte is Transmitted */
        /* Call I2C Slave Sequential complete process */
        I2C_ITSlaveSeqCplt(hi2c);
 8010752:	68f8      	ldr	r0, [r7, #12]
 8010754:	f000 f93a 	bl	80109cc <I2C_ITSlaveSeqCplt>
 8010758:	e002      	b.n	8010760 <I2C_Slave_ISR_IT+0x1f6>
    if (hi2c->XferCount == 0U)
 801075a:	bf00      	nop
 801075c:	e000      	b.n	8010760 <I2C_Slave_ISR_IT+0x1f6>
    if ((hi2c->XferCount == 0U) && \
 801075e:	bf00      	nop
  {
    /* Nothing to do */
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
 8010760:	68fb      	ldr	r3, [r7, #12]
 8010762:	2200      	movs	r2, #0
 8010764:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

  return HAL_OK;
 8010768:	2300      	movs	r3, #0
}
 801076a:	4618      	mov	r0, r3
 801076c:	3718      	adds	r7, #24
 801076e:	46bd      	mov	sp, r7
 8010770:	bd80      	pop	{r7, pc}
	...

08010774 <I2C_RequestMemoryWrite>:
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress,
                                                uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout,
                                                uint32_t Tickstart)
{
 8010774:	b580      	push	{r7, lr}
 8010776:	b086      	sub	sp, #24
 8010778:	af02      	add	r7, sp, #8
 801077a:	60f8      	str	r0, [r7, #12]
 801077c:	4608      	mov	r0, r1
 801077e:	4611      	mov	r1, r2
 8010780:	461a      	mov	r2, r3
 8010782:	4603      	mov	r3, r0
 8010784:	817b      	strh	r3, [r7, #10]
 8010786:	460b      	mov	r3, r1
 8010788:	813b      	strh	r3, [r7, #8]
 801078a:	4613      	mov	r3, r2
 801078c:	80fb      	strh	r3, [r7, #6]
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
 801078e:	88fb      	ldrh	r3, [r7, #6]
 8010790:	b2da      	uxtb	r2, r3
 8010792:	8979      	ldrh	r1, [r7, #10]
 8010794:	4b20      	ldr	r3, [pc, #128]	@ (8010818 <I2C_RequestMemoryWrite+0xa4>)
 8010796:	9300      	str	r3, [sp, #0]
 8010798:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
 801079c:	68f8      	ldr	r0, [r7, #12]
 801079e:	f000 fe61 	bl	8011464 <I2C_TransferConfig>

  /* Wait until TXIS flag is set */
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 80107a2:	69fa      	ldr	r2, [r7, #28]
 80107a4:	69b9      	ldr	r1, [r7, #24]
 80107a6:	68f8      	ldr	r0, [r7, #12]
 80107a8:	f000 fcf2 	bl	8011190 <I2C_WaitOnTXISFlagUntilTimeout>
 80107ac:	4603      	mov	r3, r0
 80107ae:	2b00      	cmp	r3, #0
 80107b0:	d001      	beq.n	80107b6 <I2C_RequestMemoryWrite+0x42>
  {
    return HAL_ERROR;
 80107b2:	2301      	movs	r3, #1
 80107b4:	e02c      	b.n	8010810 <I2C_RequestMemoryWrite+0x9c>
  }

  /* If Memory address size is 8Bit */
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
 80107b6:	88fb      	ldrh	r3, [r7, #6]
 80107b8:	2b01      	cmp	r3, #1
 80107ba:	d105      	bne.n	80107c8 <I2C_RequestMemoryWrite+0x54>
  {
    /* Send Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 80107bc:	893b      	ldrh	r3, [r7, #8]
 80107be:	b2da      	uxtb	r2, r3
 80107c0:	68fb      	ldr	r3, [r7, #12]
 80107c2:	681b      	ldr	r3, [r3, #0]
 80107c4:	629a      	str	r2, [r3, #40]	@ 0x28
 80107c6:	e015      	b.n	80107f4 <I2C_RequestMemoryWrite+0x80>
  }
  /* If Memory address size is 16Bit */
  else
  {
    /* Send MSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
 80107c8:	893b      	ldrh	r3, [r7, #8]
 80107ca:	0a1b      	lsrs	r3, r3, #8
 80107cc:	b29b      	uxth	r3, r3
 80107ce:	b2da      	uxtb	r2, r3
 80107d0:	68fb      	ldr	r3, [r7, #12]
 80107d2:	681b      	ldr	r3, [r3, #0]
 80107d4:	629a      	str	r2, [r3, #40]	@ 0x28

    /* Wait until TXIS flag is set */
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 80107d6:	69fa      	ldr	r2, [r7, #28]
 80107d8:	69b9      	ldr	r1, [r7, #24]
 80107da:	68f8      	ldr	r0, [r7, #12]
 80107dc:	f000 fcd8 	bl	8011190 <I2C_WaitOnTXISFlagUntilTimeout>
 80107e0:	4603      	mov	r3, r0
 80107e2:	2b00      	cmp	r3, #0
 80107e4:	d001      	beq.n	80107ea <I2C_RequestMemoryWrite+0x76>
    {
      return HAL_ERROR;
 80107e6:	2301      	movs	r3, #1
 80107e8:	e012      	b.n	8010810 <I2C_RequestMemoryWrite+0x9c>
    }

    /* Send LSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 80107ea:	893b      	ldrh	r3, [r7, #8]
 80107ec:	b2da      	uxtb	r2, r3
 80107ee:	68fb      	ldr	r3, [r7, #12]
 80107f0:	681b      	ldr	r3, [r3, #0]
 80107f2:	629a      	str	r2, [r3, #40]	@ 0x28
  }

  /* Wait until TCR flag is set */
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, Tickstart) != HAL_OK)
 80107f4:	69fb      	ldr	r3, [r7, #28]
 80107f6:	9300      	str	r3, [sp, #0]
 80107f8:	69bb      	ldr	r3, [r7, #24]
 80107fa:	2200      	movs	r2, #0
 80107fc:	2180      	movs	r1, #128	@ 0x80
 80107fe:	68f8      	ldr	r0, [r7, #12]
 8010800:	f000 fc6d 	bl	80110de <I2C_WaitOnFlagUntilTimeout>
 8010804:	4603      	mov	r3, r0
 8010806:	2b00      	cmp	r3, #0
 8010808:	d001      	beq.n	801080e <I2C_RequestMemoryWrite+0x9a>
  {
    return HAL_ERROR;
 801080a:	2301      	movs	r3, #1
 801080c:	e000      	b.n	8010810 <I2C_RequestMemoryWrite+0x9c>
  }

  return HAL_OK;
 801080e:	2300      	movs	r3, #0
}
 8010810:	4618      	mov	r0, r3
 8010812:	3710      	adds	r7, #16
 8010814:	46bd      	mov	sp, r7
 8010816:	bd80      	pop	{r7, pc}
 8010818:	80002000 	.word	0x80002000

0801081c <I2C_RequestMemoryRead>:
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress,
                                               uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout,
                                               uint32_t Tickstart)
{
 801081c:	b580      	push	{r7, lr}
 801081e:	b086      	sub	sp, #24
 8010820:	af02      	add	r7, sp, #8
 8010822:	60f8      	str	r0, [r7, #12]
 8010824:	4608      	mov	r0, r1
 8010826:	4611      	mov	r1, r2
 8010828:	461a      	mov	r2, r3
 801082a:	4603      	mov	r3, r0
 801082c:	817b      	strh	r3, [r7, #10]
 801082e:	460b      	mov	r3, r1
 8010830:	813b      	strh	r3, [r7, #8]
 8010832:	4613      	mov	r3, r2
 8010834:	80fb      	strh	r3, [r7, #6]
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
 8010836:	88fb      	ldrh	r3, [r7, #6]
 8010838:	b2da      	uxtb	r2, r3
 801083a:	8979      	ldrh	r1, [r7, #10]
 801083c:	4b20      	ldr	r3, [pc, #128]	@ (80108c0 <I2C_RequestMemoryRead+0xa4>)
 801083e:	9300      	str	r3, [sp, #0]
 8010840:	2300      	movs	r3, #0
 8010842:	68f8      	ldr	r0, [r7, #12]
 8010844:	f000 fe0e 	bl	8011464 <I2C_TransferConfig>

  /* Wait until TXIS flag is set */
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8010848:	69fa      	ldr	r2, [r7, #28]
 801084a:	69b9      	ldr	r1, [r7, #24]
 801084c:	68f8      	ldr	r0, [r7, #12]
 801084e:	f000 fc9f 	bl	8011190 <I2C_WaitOnTXISFlagUntilTimeout>
 8010852:	4603      	mov	r3, r0
 8010854:	2b00      	cmp	r3, #0
 8010856:	d001      	beq.n	801085c <I2C_RequestMemoryRead+0x40>
  {
    return HAL_ERROR;
 8010858:	2301      	movs	r3, #1
 801085a:	e02c      	b.n	80108b6 <I2C_RequestMemoryRead+0x9a>
  }

  /* If Memory address size is 8Bit */
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
 801085c:	88fb      	ldrh	r3, [r7, #6]
 801085e:	2b01      	cmp	r3, #1
 8010860:	d105      	bne.n	801086e <I2C_RequestMemoryRead+0x52>
  {
    /* Send Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 8010862:	893b      	ldrh	r3, [r7, #8]
 8010864:	b2da      	uxtb	r2, r3
 8010866:	68fb      	ldr	r3, [r7, #12]
 8010868:	681b      	ldr	r3, [r3, #0]
 801086a:	629a      	str	r2, [r3, #40]	@ 0x28
 801086c:	e015      	b.n	801089a <I2C_RequestMemoryRead+0x7e>
  }
  /* If Memory address size is 16Bit */
  else
  {
    /* Send MSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
 801086e:	893b      	ldrh	r3, [r7, #8]
 8010870:	0a1b      	lsrs	r3, r3, #8
 8010872:	b29b      	uxth	r3, r3
 8010874:	b2da      	uxtb	r2, r3
 8010876:	68fb      	ldr	r3, [r7, #12]
 8010878:	681b      	ldr	r3, [r3, #0]
 801087a:	629a      	str	r2, [r3, #40]	@ 0x28

    /* Wait until TXIS flag is set */
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 801087c:	69fa      	ldr	r2, [r7, #28]
 801087e:	69b9      	ldr	r1, [r7, #24]
 8010880:	68f8      	ldr	r0, [r7, #12]
 8010882:	f000 fc85 	bl	8011190 <I2C_WaitOnTXISFlagUntilTimeout>
 8010886:	4603      	mov	r3, r0
 8010888:	2b00      	cmp	r3, #0
 801088a:	d001      	beq.n	8010890 <I2C_RequestMemoryRead+0x74>
    {
      return HAL_ERROR;
 801088c:	2301      	movs	r3, #1
 801088e:	e012      	b.n	80108b6 <I2C_RequestMemoryRead+0x9a>
    }

    /* Send LSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 8010890:	893b      	ldrh	r3, [r7, #8]
 8010892:	b2da      	uxtb	r2, r3
 8010894:	68fb      	ldr	r3, [r7, #12]
 8010896:	681b      	ldr	r3, [r3, #0]
 8010898:	629a      	str	r2, [r3, #40]	@ 0x28
  }

  /* Wait until TC flag is set */
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TC, RESET, Timeout, Tickstart) != HAL_OK)
 801089a:	69fb      	ldr	r3, [r7, #28]
 801089c:	9300      	str	r3, [sp, #0]
 801089e:	69bb      	ldr	r3, [r7, #24]
 80108a0:	2200      	movs	r2, #0
 80108a2:	2140      	movs	r1, #64	@ 0x40
 80108a4:	68f8      	ldr	r0, [r7, #12]
 80108a6:	f000 fc1a 	bl	80110de <I2C_WaitOnFlagUntilTimeout>
 80108aa:	4603      	mov	r3, r0
 80108ac:	2b00      	cmp	r3, #0
 80108ae:	d001      	beq.n	80108b4 <I2C_RequestMemoryRead+0x98>
  {
    return HAL_ERROR;
 80108b0:	2301      	movs	r3, #1
 80108b2:	e000      	b.n	80108b6 <I2C_RequestMemoryRead+0x9a>
  }

  return HAL_OK;
 80108b4:	2300      	movs	r3, #0
}
 80108b6:	4618      	mov	r0, r3
 80108b8:	3710      	adds	r7, #16
 80108ba:	46bd      	mov	sp, r7
 80108bc:	bd80      	pop	{r7, pc}
 80108be:	bf00      	nop
 80108c0:	80002000 	.word	0x80002000

080108c4 <I2C_ITAddrCplt>:
  * @param  hi2c I2C handle.
  * @param  ITFlags Interrupt flags to handle.
  * @retval None
  */
static void I2C_ITAddrCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
{
 80108c4:	b580      	push	{r7, lr}
 80108c6:	b084      	sub	sp, #16
 80108c8:	af00      	add	r7, sp, #0
 80108ca:	6078      	str	r0, [r7, #4]
 80108cc:	6039      	str	r1, [r7, #0]

  /* Prevent unused argument(s) compilation warning */
  UNUSED(ITFlags);

  /* In case of Listen state, need to inform upper layer of address match code event */
  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
 80108ce:	687b      	ldr	r3, [r7, #4]
 80108d0:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 80108d4:	b2db      	uxtb	r3, r3
 80108d6:	f003 0328 	and.w	r3, r3, #40	@ 0x28
 80108da:	2b28      	cmp	r3, #40	@ 0x28
 80108dc:	d16a      	bne.n	80109b4 <I2C_ITAddrCplt+0xf0>
  {
    transferdirection = I2C_GET_DIR(hi2c);
 80108de:	687b      	ldr	r3, [r7, #4]
 80108e0:	681b      	ldr	r3, [r3, #0]
 80108e2:	699b      	ldr	r3, [r3, #24]
 80108e4:	0c1b      	lsrs	r3, r3, #16
 80108e6:	b2db      	uxtb	r3, r3
 80108e8:	f003 0301 	and.w	r3, r3, #1
 80108ec:	73fb      	strb	r3, [r7, #15]
    slaveaddrcode     = I2C_GET_ADDR_MATCH(hi2c);
 80108ee:	687b      	ldr	r3, [r7, #4]
 80108f0:	681b      	ldr	r3, [r3, #0]
 80108f2:	699b      	ldr	r3, [r3, #24]
 80108f4:	0c1b      	lsrs	r3, r3, #16
 80108f6:	b29b      	uxth	r3, r3
 80108f8:	f003 03fe 	and.w	r3, r3, #254	@ 0xfe
 80108fc:	81bb      	strh	r3, [r7, #12]
    ownadd1code       = I2C_GET_OWN_ADDRESS1(hi2c);
 80108fe:	687b      	ldr	r3, [r7, #4]
 8010900:	681b      	ldr	r3, [r3, #0]
 8010902:	689b      	ldr	r3, [r3, #8]
 8010904:	b29b      	uxth	r3, r3
 8010906:	f3c3 0309 	ubfx	r3, r3, #0, #10
 801090a:	817b      	strh	r3, [r7, #10]
    ownadd2code       = I2C_GET_OWN_ADDRESS2(hi2c);
 801090c:	687b      	ldr	r3, [r7, #4]
 801090e:	681b      	ldr	r3, [r3, #0]
 8010910:	68db      	ldr	r3, [r3, #12]
 8010912:	b29b      	uxth	r3, r3
 8010914:	f003 03fe 	and.w	r3, r3, #254	@ 0xfe
 8010918:	813b      	strh	r3, [r7, #8]

    /* If 10bits addressing mode is selected */
    if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 801091a:	687b      	ldr	r3, [r7, #4]
 801091c:	68db      	ldr	r3, [r3, #12]
 801091e:	2b02      	cmp	r3, #2
 8010920:	d138      	bne.n	8010994 <I2C_ITAddrCplt+0xd0>
    {
      if ((slaveaddrcode & SLAVE_ADDR_MSK) == ((ownadd1code >> SLAVE_ADDR_SHIFT) & SLAVE_ADDR_MSK))
 8010922:	897b      	ldrh	r3, [r7, #10]
 8010924:	09db      	lsrs	r3, r3, #7
 8010926:	b29a      	uxth	r2, r3
 8010928:	89bb      	ldrh	r3, [r7, #12]
 801092a:	4053      	eors	r3, r2
 801092c:	b29b      	uxth	r3, r3
 801092e:	f003 0306 	and.w	r3, r3, #6
 8010932:	2b00      	cmp	r3, #0
 8010934:	d11c      	bne.n	8010970 <I2C_ITAddrCplt+0xac>
      {
        slaveaddrcode = ownadd1code;
 8010936:	897b      	ldrh	r3, [r7, #10]
 8010938:	81bb      	strh	r3, [r7, #12]
        hi2c->AddrEventCount++;
 801093a:	687b      	ldr	r3, [r7, #4]
 801093c:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 801093e:	1c5a      	adds	r2, r3, #1
 8010940:	687b      	ldr	r3, [r7, #4]
 8010942:	649a      	str	r2, [r3, #72]	@ 0x48
        if (hi2c->AddrEventCount == 2U)
 8010944:	687b      	ldr	r3, [r7, #4]
 8010946:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 8010948:	2b02      	cmp	r3, #2
 801094a:	d13b      	bne.n	80109c4 <I2C_ITAddrCplt+0x100>
        {
          /* Reset Address Event counter */
          hi2c->AddrEventCount = 0U;
 801094c:	687b      	ldr	r3, [r7, #4]
 801094e:	2200      	movs	r2, #0
 8010950:	649a      	str	r2, [r3, #72]	@ 0x48

          /* Clear ADDR flag */
          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
 8010952:	687b      	ldr	r3, [r7, #4]
 8010954:	681b      	ldr	r3, [r3, #0]
 8010956:	2208      	movs	r2, #8
 8010958:	61da      	str	r2, [r3, #28]

          /* Process Unlocked */
          __HAL_UNLOCK(hi2c);
 801095a:	687b      	ldr	r3, [r7, #4]
 801095c:	2200      	movs	r2, #0
 801095e:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

          /* Call Slave Addr callback */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
          hi2c->AddrCallback(hi2c, transferdirection, slaveaddrcode);
#else
          HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
 8010962:	89ba      	ldrh	r2, [r7, #12]
 8010964:	7bfb      	ldrb	r3, [r7, #15]
 8010966:	4619      	mov	r1, r3
 8010968:	6878      	ldr	r0, [r7, #4]
 801096a:	f7ff fdb8 	bl	80104de <HAL_I2C_AddrCallback>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
  }
}
 801096e:	e029      	b.n	80109c4 <I2C_ITAddrCplt+0x100>
        slaveaddrcode = ownadd2code;
 8010970:	893b      	ldrh	r3, [r7, #8]
 8010972:	81bb      	strh	r3, [r7, #12]
        I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
 8010974:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
 8010978:	6878      	ldr	r0, [r7, #4]
 801097a:	f000 fda5 	bl	80114c8 <I2C_Disable_IRQ>
        __HAL_UNLOCK(hi2c);
 801097e:	687b      	ldr	r3, [r7, #4]
 8010980:	2200      	movs	r2, #0
 8010982:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
        HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
 8010986:	89ba      	ldrh	r2, [r7, #12]
 8010988:	7bfb      	ldrb	r3, [r7, #15]
 801098a:	4619      	mov	r1, r3
 801098c:	6878      	ldr	r0, [r7, #4]
 801098e:	f7ff fda6 	bl	80104de <HAL_I2C_AddrCallback>
}
 8010992:	e017      	b.n	80109c4 <I2C_ITAddrCplt+0x100>
      I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
 8010994:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
 8010998:	6878      	ldr	r0, [r7, #4]
 801099a:	f000 fd95 	bl	80114c8 <I2C_Disable_IRQ>
      __HAL_UNLOCK(hi2c);
 801099e:	687b      	ldr	r3, [r7, #4]
 80109a0:	2200      	movs	r2, #0
 80109a2:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
      HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
 80109a6:	89ba      	ldrh	r2, [r7, #12]
 80109a8:	7bfb      	ldrb	r3, [r7, #15]
 80109aa:	4619      	mov	r1, r3
 80109ac:	6878      	ldr	r0, [r7, #4]
 80109ae:	f7ff fd96 	bl	80104de <HAL_I2C_AddrCallback>
}
 80109b2:	e007      	b.n	80109c4 <I2C_ITAddrCplt+0x100>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
 80109b4:	687b      	ldr	r3, [r7, #4]
 80109b6:	681b      	ldr	r3, [r3, #0]
 80109b8:	2208      	movs	r2, #8
 80109ba:	61da      	str	r2, [r3, #28]
    __HAL_UNLOCK(hi2c);
 80109bc:	687b      	ldr	r3, [r7, #4]
 80109be:	2200      	movs	r2, #0
 80109c0:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
}
 80109c4:	bf00      	nop
 80109c6:	3710      	adds	r7, #16
 80109c8:	46bd      	mov	sp, r7
 80109ca:	bd80      	pop	{r7, pc}

080109cc <I2C_ITSlaveSeqCplt>:
  * @brief  I2C Slave sequential complete process.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_ITSlaveSeqCplt(I2C_HandleTypeDef *hi2c)
{
 80109cc:	b580      	push	{r7, lr}
 80109ce:	b084      	sub	sp, #16
 80109d0:	af00      	add	r7, sp, #0
 80109d2:	6078      	str	r0, [r7, #4]
  uint32_t tmpcr1value = READ_REG(hi2c->Instance->CR1);
 80109d4:	687b      	ldr	r3, [r7, #4]
 80109d6:	681b      	ldr	r3, [r3, #0]
 80109d8:	681b      	ldr	r3, [r3, #0]
 80109da:	60fb      	str	r3, [r7, #12]

  /* Reset I2C handle mode */
  hi2c->Mode = HAL_I2C_MODE_NONE;
 80109dc:	687b      	ldr	r3, [r7, #4]
 80109de:	2200      	movs	r2, #0
 80109e0:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

#if defined(HAL_DMA_MODULE_ENABLED)
  /* If a DMA is ongoing, Update handle size context */
  if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_TXDMAEN) != RESET)
 80109e4:	68fb      	ldr	r3, [r7, #12]
 80109e6:	0b9b      	lsrs	r3, r3, #14
 80109e8:	f003 0301 	and.w	r3, r3, #1
 80109ec:	2b00      	cmp	r3, #0
 80109ee:	d008      	beq.n	8010a02 <I2C_ITSlaveSeqCplt+0x36>
  {
    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
 80109f0:	687b      	ldr	r3, [r7, #4]
 80109f2:	681b      	ldr	r3, [r3, #0]
 80109f4:	681a      	ldr	r2, [r3, #0]
 80109f6:	687b      	ldr	r3, [r7, #4]
 80109f8:	681b      	ldr	r3, [r3, #0]
 80109fa:	f422 4280 	bic.w	r2, r2, #16384	@ 0x4000
 80109fe:	601a      	str	r2, [r3, #0]
 8010a00:	e00d      	b.n	8010a1e <I2C_ITSlaveSeqCplt+0x52>
  }
  else if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_RXDMAEN) != RESET)
 8010a02:	68fb      	ldr	r3, [r7, #12]
 8010a04:	0bdb      	lsrs	r3, r3, #15
 8010a06:	f003 0301 	and.w	r3, r3, #1
 8010a0a:	2b00      	cmp	r3, #0
 8010a0c:	d007      	beq.n	8010a1e <I2C_ITSlaveSeqCplt+0x52>
  {
    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
 8010a0e:	687b      	ldr	r3, [r7, #4]
 8010a10:	681b      	ldr	r3, [r3, #0]
 8010a12:	681a      	ldr	r2, [r3, #0]
 8010a14:	687b      	ldr	r3, [r7, #4]
 8010a16:	681b      	ldr	r3, [r3, #0]
 8010a18:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
 8010a1c:	601a      	str	r2, [r3, #0]
  {
    /* Do nothing */
  }
#endif /* HAL_DMA_MODULE_ENABLED */

  if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
 8010a1e:	687b      	ldr	r3, [r7, #4]
 8010a20:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 8010a24:	b2db      	uxtb	r3, r3
 8010a26:	2b29      	cmp	r3, #41	@ 0x29
 8010a28:	d112      	bne.n	8010a50 <I2C_ITSlaveSeqCplt+0x84>
  {
    /* Remove HAL_I2C_STATE_SLAVE_BUSY_TX, keep only HAL_I2C_STATE_LISTEN */
    hi2c->State         = HAL_I2C_STATE_LISTEN;
 8010a2a:	687b      	ldr	r3, [r7, #4]
 8010a2c:	2228      	movs	r2, #40	@ 0x28
 8010a2e:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
 8010a32:	687b      	ldr	r3, [r7, #4]
 8010a34:	2221      	movs	r2, #33	@ 0x21
 8010a36:	631a      	str	r2, [r3, #48]	@ 0x30

    /* Disable Interrupts */
    I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
 8010a38:	2101      	movs	r1, #1
 8010a3a:	6878      	ldr	r0, [r7, #4]
 8010a3c:	f000 fd44 	bl	80114c8 <I2C_Disable_IRQ>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8010a40:	687b      	ldr	r3, [r7, #4]
 8010a42:	2200      	movs	r2, #0
 8010a44:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    /* Call the corresponding callback to inform upper layer of End of Transfer */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    hi2c->SlaveTxCpltCallback(hi2c);
#else
    HAL_I2C_SlaveTxCpltCallback(hi2c);
 8010a48:	6878      	ldr	r0, [r7, #4]
 8010a4a:	f7ff fd34 	bl	80104b6 <HAL_I2C_SlaveTxCpltCallback>
  }
  else
  {
    /* Nothing to do */
  }
}
 8010a4e:	e017      	b.n	8010a80 <I2C_ITSlaveSeqCplt+0xb4>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
 8010a50:	687b      	ldr	r3, [r7, #4]
 8010a52:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 8010a56:	b2db      	uxtb	r3, r3
 8010a58:	2b2a      	cmp	r3, #42	@ 0x2a
 8010a5a:	d111      	bne.n	8010a80 <I2C_ITSlaveSeqCplt+0xb4>
    hi2c->State         = HAL_I2C_STATE_LISTEN;
 8010a5c:	687b      	ldr	r3, [r7, #4]
 8010a5e:	2228      	movs	r2, #40	@ 0x28
 8010a60:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
 8010a64:	687b      	ldr	r3, [r7, #4]
 8010a66:	2222      	movs	r2, #34	@ 0x22
 8010a68:	631a      	str	r2, [r3, #48]	@ 0x30
    I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
 8010a6a:	2102      	movs	r1, #2
 8010a6c:	6878      	ldr	r0, [r7, #4]
 8010a6e:	f000 fd2b 	bl	80114c8 <I2C_Disable_IRQ>
    __HAL_UNLOCK(hi2c);
 8010a72:	687b      	ldr	r3, [r7, #4]
 8010a74:	2200      	movs	r2, #0
 8010a76:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
    HAL_I2C_SlaveRxCpltCallback(hi2c);
 8010a7a:	6878      	ldr	r0, [r7, #4]
 8010a7c:	f7ff fd25 	bl	80104ca <HAL_I2C_SlaveRxCpltCallback>
}
 8010a80:	bf00      	nop
 8010a82:	3710      	adds	r7, #16
 8010a84:	46bd      	mov	sp, r7
 8010a86:	bd80      	pop	{r7, pc}

08010a88 <I2C_ITSlaveCplt>:
  * @param  hi2c I2C handle.
  * @param  ITFlags Interrupt flags to handle.
  * @retval None
  */
static void I2C_ITSlaveCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
{
 8010a88:	b590      	push	{r4, r7, lr}
 8010a8a:	b087      	sub	sp, #28
 8010a8c:	af00      	add	r7, sp, #0
 8010a8e:	6078      	str	r0, [r7, #4]
 8010a90:	6039      	str	r1, [r7, #0]
  uint32_t tmpcr1value = READ_REG(hi2c->Instance->CR1);
 8010a92:	687b      	ldr	r3, [r7, #4]
 8010a94:	681b      	ldr	r3, [r3, #0]
 8010a96:	681b      	ldr	r3, [r3, #0]
 8010a98:	613b      	str	r3, [r7, #16]
  uint32_t tmpITFlags = ITFlags;
 8010a9a:	683b      	ldr	r3, [r7, #0]
 8010a9c:	617b      	str	r3, [r7, #20]
  uint32_t tmpoptions = hi2c->XferOptions;
 8010a9e:	687b      	ldr	r3, [r7, #4]
 8010aa0:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8010aa2:	60fb      	str	r3, [r7, #12]
  HAL_I2C_StateTypeDef tmpstate = hi2c->State;
 8010aa4:	687b      	ldr	r3, [r7, #4]
 8010aa6:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 8010aaa:	72fb      	strb	r3, [r7, #11]

  /* Clear STOP Flag */
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8010aac:	687b      	ldr	r3, [r7, #4]
 8010aae:	681b      	ldr	r3, [r3, #0]
 8010ab0:	2220      	movs	r2, #32
 8010ab2:	61da      	str	r2, [r3, #28]

  /* Disable Interrupts and Store Previous state */
  if ((tmpstate == HAL_I2C_STATE_BUSY_TX) || (tmpstate == HAL_I2C_STATE_BUSY_TX_LISTEN))
 8010ab4:	7afb      	ldrb	r3, [r7, #11]
 8010ab6:	2b21      	cmp	r3, #33	@ 0x21
 8010ab8:	d002      	beq.n	8010ac0 <I2C_ITSlaveCplt+0x38>
 8010aba:	7afb      	ldrb	r3, [r7, #11]
 8010abc:	2b29      	cmp	r3, #41	@ 0x29
 8010abe:	d108      	bne.n	8010ad2 <I2C_ITSlaveCplt+0x4a>
  {
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_TX_IT);
 8010ac0:	f248 0101 	movw	r1, #32769	@ 0x8001
 8010ac4:	6878      	ldr	r0, [r7, #4]
 8010ac6:	f000 fcff 	bl	80114c8 <I2C_Disable_IRQ>
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
 8010aca:	687b      	ldr	r3, [r7, #4]
 8010acc:	2221      	movs	r2, #33	@ 0x21
 8010ace:	631a      	str	r2, [r3, #48]	@ 0x30
 8010ad0:	e019      	b.n	8010b06 <I2C_ITSlaveCplt+0x7e>
  }
  else if ((tmpstate == HAL_I2C_STATE_BUSY_RX) || (tmpstate == HAL_I2C_STATE_BUSY_RX_LISTEN))
 8010ad2:	7afb      	ldrb	r3, [r7, #11]
 8010ad4:	2b22      	cmp	r3, #34	@ 0x22
 8010ad6:	d002      	beq.n	8010ade <I2C_ITSlaveCplt+0x56>
 8010ad8:	7afb      	ldrb	r3, [r7, #11]
 8010ada:	2b2a      	cmp	r3, #42	@ 0x2a
 8010adc:	d108      	bne.n	8010af0 <I2C_ITSlaveCplt+0x68>
  {
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT);
 8010ade:	f248 0102 	movw	r1, #32770	@ 0x8002
 8010ae2:	6878      	ldr	r0, [r7, #4]
 8010ae4:	f000 fcf0 	bl	80114c8 <I2C_Disable_IRQ>
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
 8010ae8:	687b      	ldr	r3, [r7, #4]
 8010aea:	2222      	movs	r2, #34	@ 0x22
 8010aec:	631a      	str	r2, [r3, #48]	@ 0x30
 8010aee:	e00a      	b.n	8010b06 <I2C_ITSlaveCplt+0x7e>
  }
  else if (tmpstate == HAL_I2C_STATE_LISTEN)
 8010af0:	7afb      	ldrb	r3, [r7, #11]
 8010af2:	2b28      	cmp	r3, #40	@ 0x28
 8010af4:	d107      	bne.n	8010b06 <I2C_ITSlaveCplt+0x7e>
  {
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_TX_IT | I2C_XFER_RX_IT);
 8010af6:	f248 0103 	movw	r1, #32771	@ 0x8003
 8010afa:	6878      	ldr	r0, [r7, #4]
 8010afc:	f000 fce4 	bl	80114c8 <I2C_Disable_IRQ>
    hi2c->PreviousState = I2C_STATE_NONE;
 8010b00:	687b      	ldr	r3, [r7, #4]
 8010b02:	2200      	movs	r2, #0
 8010b04:	631a      	str	r2, [r3, #48]	@ 0x30
  {
    /* Do nothing */
  }

  /* Disable Address Acknowledge */
  hi2c->Instance->CR2 |= I2C_CR2_NACK;
 8010b06:	687b      	ldr	r3, [r7, #4]
 8010b08:	681b      	ldr	r3, [r3, #0]
 8010b0a:	685a      	ldr	r2, [r3, #4]
 8010b0c:	687b      	ldr	r3, [r7, #4]
 8010b0e:	681b      	ldr	r3, [r3, #0]
 8010b10:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
 8010b14:	605a      	str	r2, [r3, #4]

  /* Clear Configuration Register 2 */
  I2C_RESET_CR2(hi2c);
 8010b16:	687b      	ldr	r3, [r7, #4]
 8010b18:	681b      	ldr	r3, [r3, #0]
 8010b1a:	6859      	ldr	r1, [r3, #4]
 8010b1c:	687b      	ldr	r3, [r7, #4]
 8010b1e:	681a      	ldr	r2, [r3, #0]
 8010b20:	4b95      	ldr	r3, [pc, #596]	@ (8010d78 <I2C_ITSlaveCplt+0x2f0>)
 8010b22:	400b      	ands	r3, r1
 8010b24:	6053      	str	r3, [r2, #4]

  /* Flush TX register */
  I2C_Flush_TXDR(hi2c);
 8010b26:	6878      	ldr	r0, [r7, #4]
 8010b28:	f000 fa97 	bl	801105a <I2C_Flush_TXDR>

#if defined(HAL_DMA_MODULE_ENABLED)
  /* If a DMA is ongoing, Update handle size context */
  if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_TXDMAEN) != RESET)
 8010b2c:	693b      	ldr	r3, [r7, #16]
 8010b2e:	0b9b      	lsrs	r3, r3, #14
 8010b30:	f003 0301 	and.w	r3, r3, #1
 8010b34:	2b00      	cmp	r3, #0
 8010b36:	d01c      	beq.n	8010b72 <I2C_ITSlaveCplt+0xea>
  {
    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
 8010b38:	687b      	ldr	r3, [r7, #4]
 8010b3a:	681b      	ldr	r3, [r3, #0]
 8010b3c:	681a      	ldr	r2, [r3, #0]
 8010b3e:	687b      	ldr	r3, [r7, #4]
 8010b40:	681b      	ldr	r3, [r3, #0]
 8010b42:	f422 4280 	bic.w	r2, r2, #16384	@ 0x4000
 8010b46:	601a      	str	r2, [r3, #0]

    if (hi2c->hdmatx != NULL)
 8010b48:	687b      	ldr	r3, [r7, #4]
 8010b4a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8010b4c:	2b00      	cmp	r3, #0
 8010b4e:	d032      	beq.n	8010bb6 <I2C_ITSlaveCplt+0x12e>
    {
      hi2c->XferCount = (uint16_t)I2C_GET_DMA_REMAIN_DATA(hi2c->hdmatx);
 8010b50:	687b      	ldr	r3, [r7, #4]
 8010b52:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8010b54:	681b      	ldr	r3, [r3, #0]
 8010b56:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 8010b58:	b29c      	uxth	r4, r3
 8010b5a:	687b      	ldr	r3, [r7, #4]
 8010b5c:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8010b5e:	4618      	mov	r0, r3
 8010b60:	f7fe fa12 	bl	800ef88 <HAL_DMAEx_GetFifoLevel>
 8010b64:	4603      	mov	r3, r0
 8010b66:	b29b      	uxth	r3, r3
 8010b68:	4423      	add	r3, r4
 8010b6a:	b29a      	uxth	r2, r3
 8010b6c:	687b      	ldr	r3, [r7, #4]
 8010b6e:	855a      	strh	r2, [r3, #42]	@ 0x2a
 8010b70:	e021      	b.n	8010bb6 <I2C_ITSlaveCplt+0x12e>
    }
  }
  else if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_RXDMAEN) != RESET)
 8010b72:	693b      	ldr	r3, [r7, #16]
 8010b74:	0bdb      	lsrs	r3, r3, #15
 8010b76:	f003 0301 	and.w	r3, r3, #1
 8010b7a:	2b00      	cmp	r3, #0
 8010b7c:	d01b      	beq.n	8010bb6 <I2C_ITSlaveCplt+0x12e>
  {
    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
 8010b7e:	687b      	ldr	r3, [r7, #4]
 8010b80:	681b      	ldr	r3, [r3, #0]
 8010b82:	681a      	ldr	r2, [r3, #0]
 8010b84:	687b      	ldr	r3, [r7, #4]
 8010b86:	681b      	ldr	r3, [r3, #0]
 8010b88:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
 8010b8c:	601a      	str	r2, [r3, #0]

    if (hi2c->hdmarx != NULL)
 8010b8e:	687b      	ldr	r3, [r7, #4]
 8010b90:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8010b92:	2b00      	cmp	r3, #0
 8010b94:	d00f      	beq.n	8010bb6 <I2C_ITSlaveCplt+0x12e>
    {
      hi2c->XferCount = (uint16_t)I2C_GET_DMA_REMAIN_DATA(hi2c->hdmarx);
 8010b96:	687b      	ldr	r3, [r7, #4]
 8010b98:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8010b9a:	681b      	ldr	r3, [r3, #0]
 8010b9c:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 8010b9e:	b29c      	uxth	r4, r3
 8010ba0:	687b      	ldr	r3, [r7, #4]
 8010ba2:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8010ba4:	4618      	mov	r0, r3
 8010ba6:	f7fe f9ef 	bl	800ef88 <HAL_DMAEx_GetFifoLevel>
 8010baa:	4603      	mov	r3, r0
 8010bac:	b29b      	uxth	r3, r3
 8010bae:	4423      	add	r3, r4
 8010bb0:	b29a      	uxth	r2, r3
 8010bb2:	687b      	ldr	r3, [r7, #4]
 8010bb4:	855a      	strh	r2, [r3, #42]	@ 0x2a
    /* Do nothing */
  }
#endif /* HAL_DMA_MODULE_ENABLED */

  /* Store Last receive data if any */
  if (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET)
 8010bb6:	697b      	ldr	r3, [r7, #20]
 8010bb8:	089b      	lsrs	r3, r3, #2
 8010bba:	f003 0301 	and.w	r3, r3, #1
 8010bbe:	2b00      	cmp	r3, #0
 8010bc0:	d020      	beq.n	8010c04 <I2C_ITSlaveCplt+0x17c>
  {
    /* Remove RXNE flag on temporary variable as read done */
    tmpITFlags &= ~I2C_FLAG_RXNE;
 8010bc2:	697b      	ldr	r3, [r7, #20]
 8010bc4:	f023 0304 	bic.w	r3, r3, #4
 8010bc8:	617b      	str	r3, [r7, #20]

    /* Read data from RXDR */
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
 8010bca:	687b      	ldr	r3, [r7, #4]
 8010bcc:	681b      	ldr	r3, [r3, #0]
 8010bce:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 8010bd0:	687b      	ldr	r3, [r7, #4]
 8010bd2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8010bd4:	b2d2      	uxtb	r2, r2
 8010bd6:	701a      	strb	r2, [r3, #0]

    /* Increment Buffer pointer */
    hi2c->pBuffPtr++;
 8010bd8:	687b      	ldr	r3, [r7, #4]
 8010bda:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8010bdc:	1c5a      	adds	r2, r3, #1
 8010bde:	687b      	ldr	r3, [r7, #4]
 8010be0:	625a      	str	r2, [r3, #36]	@ 0x24

    if ((hi2c->XferSize > 0U))
 8010be2:	687b      	ldr	r3, [r7, #4]
 8010be4:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 8010be6:	2b00      	cmp	r3, #0
 8010be8:	d00c      	beq.n	8010c04 <I2C_ITSlaveCplt+0x17c>
    {
      hi2c->XferSize--;
 8010bea:	687b      	ldr	r3, [r7, #4]
 8010bec:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 8010bee:	3b01      	subs	r3, #1
 8010bf0:	b29a      	uxth	r2, r3
 8010bf2:	687b      	ldr	r3, [r7, #4]
 8010bf4:	851a      	strh	r2, [r3, #40]	@ 0x28
      hi2c->XferCount--;
 8010bf6:	687b      	ldr	r3, [r7, #4]
 8010bf8:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8010bfa:	b29b      	uxth	r3, r3
 8010bfc:	3b01      	subs	r3, #1
 8010bfe:	b29a      	uxth	r2, r3
 8010c00:	687b      	ldr	r3, [r7, #4]
 8010c02:	855a      	strh	r2, [r3, #42]	@ 0x2a
    }
  }

  /* All data are not transferred, so set error code accordingly */
  if (hi2c->XferCount != 0U)
 8010c04:	687b      	ldr	r3, [r7, #4]
 8010c06:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8010c08:	b29b      	uxth	r3, r3
 8010c0a:	2b00      	cmp	r3, #0
 8010c0c:	d005      	beq.n	8010c1a <I2C_ITSlaveCplt+0x192>
  {
    /* Set ErrorCode corresponding to a Non-Acknowledge */
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8010c0e:	687b      	ldr	r3, [r7, #4]
 8010c10:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8010c12:	f043 0204 	orr.w	r2, r3, #4
 8010c16:	687b      	ldr	r3, [r7, #4]
 8010c18:	645a      	str	r2, [r3, #68]	@ 0x44
  }

  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && \
 8010c1a:	697b      	ldr	r3, [r7, #20]
 8010c1c:	091b      	lsrs	r3, r3, #4
 8010c1e:	f003 0301 	and.w	r3, r3, #1
 8010c22:	2b00      	cmp	r3, #0
 8010c24:	d04a      	beq.n	8010cbc <I2C_ITSlaveCplt+0x234>
      (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_IT_NACKI) != RESET))
 8010c26:	693b      	ldr	r3, [r7, #16]
 8010c28:	091b      	lsrs	r3, r3, #4
 8010c2a:	f003 0301 	and.w	r3, r3, #1
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && \
 8010c2e:	2b00      	cmp	r3, #0
 8010c30:	d044      	beq.n	8010cbc <I2C_ITSlaveCplt+0x234>
  {
    /* Check that I2C transfer finished */
    /* if yes, normal use case, a NACK is sent by the MASTER when Transfer is finished */
    /* Mean XferCount == 0*/
    /* So clear Flag NACKF only */
    if (hi2c->XferCount == 0U)
 8010c32:	687b      	ldr	r3, [r7, #4]
 8010c34:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8010c36:	b29b      	uxth	r3, r3
 8010c38:	2b00      	cmp	r3, #0
 8010c3a:	d128      	bne.n	8010c8e <I2C_ITSlaveCplt+0x206>
    {
      if ((hi2c->State == HAL_I2C_STATE_LISTEN) && (tmpoptions == I2C_FIRST_AND_LAST_FRAME))
 8010c3c:	687b      	ldr	r3, [r7, #4]
 8010c3e:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 8010c42:	b2db      	uxtb	r3, r3
 8010c44:	2b28      	cmp	r3, #40	@ 0x28
 8010c46:	d108      	bne.n	8010c5a <I2C_ITSlaveCplt+0x1d2>
 8010c48:	68fb      	ldr	r3, [r7, #12]
 8010c4a:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 8010c4e:	d104      	bne.n	8010c5a <I2C_ITSlaveCplt+0x1d2>
        /* Same action must be done for (tmpoptions == I2C_LAST_FRAME) which removed for
           Warning[Pa134]: left and right operands are identical */
      {
        /* Call I2C Listen complete process */
        I2C_ITListenCplt(hi2c, tmpITFlags);
 8010c50:	6979      	ldr	r1, [r7, #20]
 8010c52:	6878      	ldr	r0, [r7, #4]
 8010c54:	f000 f894 	bl	8010d80 <I2C_ITListenCplt>
 8010c58:	e030      	b.n	8010cbc <I2C_ITSlaveCplt+0x234>
      }
      else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))
 8010c5a:	687b      	ldr	r3, [r7, #4]
 8010c5c:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 8010c60:	b2db      	uxtb	r3, r3
 8010c62:	2b29      	cmp	r3, #41	@ 0x29
 8010c64:	d10e      	bne.n	8010c84 <I2C_ITSlaveCplt+0x1fc>
 8010c66:	68fb      	ldr	r3, [r7, #12]
 8010c68:	f513 3f80 	cmn.w	r3, #65536	@ 0x10000
 8010c6c:	d00a      	beq.n	8010c84 <I2C_ITSlaveCplt+0x1fc>
      {
        /* Clear NACK Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8010c6e:	687b      	ldr	r3, [r7, #4]
 8010c70:	681b      	ldr	r3, [r3, #0]
 8010c72:	2210      	movs	r2, #16
 8010c74:	61da      	str	r2, [r3, #28]

        /* Flush TX register */
        I2C_Flush_TXDR(hi2c);
 8010c76:	6878      	ldr	r0, [r7, #4]
 8010c78:	f000 f9ef 	bl	801105a <I2C_Flush_TXDR>

        /* Last Byte is Transmitted */
        /* Call I2C Slave Sequential complete process */
        I2C_ITSlaveSeqCplt(hi2c);
 8010c7c:	6878      	ldr	r0, [r7, #4]
 8010c7e:	f7ff fea5 	bl	80109cc <I2C_ITSlaveSeqCplt>
 8010c82:	e01b      	b.n	8010cbc <I2C_ITSlaveCplt+0x234>
      }
      else
      {
        /* Clear NACK Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8010c84:	687b      	ldr	r3, [r7, #4]
 8010c86:	681b      	ldr	r3, [r3, #0]
 8010c88:	2210      	movs	r2, #16
 8010c8a:	61da      	str	r2, [r3, #28]
 8010c8c:	e016      	b.n	8010cbc <I2C_ITSlaveCplt+0x234>
    }
    else
    {
      /* if no, error use case, a Non-Acknowledge of last Data is generated by the MASTER*/
      /* Clear NACK Flag */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8010c8e:	687b      	ldr	r3, [r7, #4]
 8010c90:	681b      	ldr	r3, [r3, #0]
 8010c92:	2210      	movs	r2, #16
 8010c94:	61da      	str	r2, [r3, #28]

      /* Set ErrorCode corresponding to a Non-Acknowledge */
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8010c96:	687b      	ldr	r3, [r7, #4]
 8010c98:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8010c9a:	f043 0204 	orr.w	r2, r3, #4
 8010c9e:	687b      	ldr	r3, [r7, #4]
 8010ca0:	645a      	str	r2, [r3, #68]	@ 0x44

      if ((tmpoptions == I2C_FIRST_FRAME) || (tmpoptions == I2C_NEXT_FRAME))
 8010ca2:	68fb      	ldr	r3, [r7, #12]
 8010ca4:	2b00      	cmp	r3, #0
 8010ca6:	d003      	beq.n	8010cb0 <I2C_ITSlaveCplt+0x228>
 8010ca8:	68fb      	ldr	r3, [r7, #12]
 8010caa:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
 8010cae:	d105      	bne.n	8010cbc <I2C_ITSlaveCplt+0x234>
      {
        /* Call the corresponding callback to inform upper layer of End of Transfer */
        I2C_ITError(hi2c, hi2c->ErrorCode);
 8010cb0:	687b      	ldr	r3, [r7, #4]
 8010cb2:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8010cb4:	4619      	mov	r1, r3
 8010cb6:	6878      	ldr	r0, [r7, #4]
 8010cb8:	f000 f8b8 	bl	8010e2c <I2C_ITError>
      }
    }
  }

  hi2c->Mode = HAL_I2C_MODE_NONE;
 8010cbc:	687b      	ldr	r3, [r7, #4]
 8010cbe:	2200      	movs	r2, #0
 8010cc0:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
  hi2c->XferISR = NULL;
 8010cc4:	687b      	ldr	r3, [r7, #4]
 8010cc6:	2200      	movs	r2, #0
 8010cc8:	635a      	str	r2, [r3, #52]	@ 0x34

  if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
 8010cca:	687b      	ldr	r3, [r7, #4]
 8010ccc:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8010cce:	2b00      	cmp	r3, #0
 8010cd0:	d010      	beq.n	8010cf4 <I2C_ITSlaveCplt+0x26c>
  {
    /* Call the corresponding callback to inform upper layer of End of Transfer */
    I2C_ITError(hi2c, hi2c->ErrorCode);
 8010cd2:	687b      	ldr	r3, [r7, #4]
 8010cd4:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8010cd6:	4619      	mov	r1, r3
 8010cd8:	6878      	ldr	r0, [r7, #4]
 8010cda:	f000 f8a7 	bl	8010e2c <I2C_ITError>

    /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
    if (hi2c->State == HAL_I2C_STATE_LISTEN)
 8010cde:	687b      	ldr	r3, [r7, #4]
 8010ce0:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 8010ce4:	b2db      	uxtb	r3, r3
 8010ce6:	2b28      	cmp	r3, #40	@ 0x28
 8010ce8:	d141      	bne.n	8010d6e <I2C_ITSlaveCplt+0x2e6>
    {
      /* Call I2C Listen complete process */
      I2C_ITListenCplt(hi2c, tmpITFlags);
 8010cea:	6979      	ldr	r1, [r7, #20]
 8010cec:	6878      	ldr	r0, [r7, #4]
 8010cee:	f000 f847 	bl	8010d80 <I2C_ITListenCplt>
    hi2c->SlaveTxCpltCallback(hi2c);
#else
    HAL_I2C_SlaveTxCpltCallback(hi2c);
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }
}
 8010cf2:	e03c      	b.n	8010d6e <I2C_ITSlaveCplt+0x2e6>
  else if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
 8010cf4:	687b      	ldr	r3, [r7, #4]
 8010cf6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8010cf8:	f513 3f80 	cmn.w	r3, #65536	@ 0x10000
 8010cfc:	d014      	beq.n	8010d28 <I2C_ITSlaveCplt+0x2a0>
    I2C_ITSlaveSeqCplt(hi2c);
 8010cfe:	6878      	ldr	r0, [r7, #4]
 8010d00:	f7ff fe64 	bl	80109cc <I2C_ITSlaveSeqCplt>
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 8010d04:	687b      	ldr	r3, [r7, #4]
 8010d06:	4a1d      	ldr	r2, [pc, #116]	@ (8010d7c <I2C_ITSlaveCplt+0x2f4>)
 8010d08:	62da      	str	r2, [r3, #44]	@ 0x2c
    hi2c->State = HAL_I2C_STATE_READY;
 8010d0a:	687b      	ldr	r3, [r7, #4]
 8010d0c:	2220      	movs	r2, #32
 8010d0e:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
 8010d12:	687b      	ldr	r3, [r7, #4]
 8010d14:	2200      	movs	r2, #0
 8010d16:	631a      	str	r2, [r3, #48]	@ 0x30
    __HAL_UNLOCK(hi2c);
 8010d18:	687b      	ldr	r3, [r7, #4]
 8010d1a:	2200      	movs	r2, #0
 8010d1c:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
    HAL_I2C_ListenCpltCallback(hi2c);
 8010d20:	6878      	ldr	r0, [r7, #4]
 8010d22:	f7ff fbea 	bl	80104fa <HAL_I2C_ListenCpltCallback>
}
 8010d26:	e022      	b.n	8010d6e <I2C_ITSlaveCplt+0x2e6>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
 8010d28:	687b      	ldr	r3, [r7, #4]
 8010d2a:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 8010d2e:	b2db      	uxtb	r3, r3
 8010d30:	2b22      	cmp	r3, #34	@ 0x22
 8010d32:	d10e      	bne.n	8010d52 <I2C_ITSlaveCplt+0x2ca>
    hi2c->State = HAL_I2C_STATE_READY;
 8010d34:	687b      	ldr	r3, [r7, #4]
 8010d36:	2220      	movs	r2, #32
 8010d38:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
 8010d3c:	687b      	ldr	r3, [r7, #4]
 8010d3e:	2200      	movs	r2, #0
 8010d40:	631a      	str	r2, [r3, #48]	@ 0x30
    __HAL_UNLOCK(hi2c);
 8010d42:	687b      	ldr	r3, [r7, #4]
 8010d44:	2200      	movs	r2, #0
 8010d46:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
    HAL_I2C_SlaveRxCpltCallback(hi2c);
 8010d4a:	6878      	ldr	r0, [r7, #4]
 8010d4c:	f7ff fbbd 	bl	80104ca <HAL_I2C_SlaveRxCpltCallback>
}
 8010d50:	e00d      	b.n	8010d6e <I2C_ITSlaveCplt+0x2e6>
    hi2c->State = HAL_I2C_STATE_READY;
 8010d52:	687b      	ldr	r3, [r7, #4]
 8010d54:	2220      	movs	r2, #32
 8010d56:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
 8010d5a:	687b      	ldr	r3, [r7, #4]
 8010d5c:	2200      	movs	r2, #0
 8010d5e:	631a      	str	r2, [r3, #48]	@ 0x30
    __HAL_UNLOCK(hi2c);
 8010d60:	687b      	ldr	r3, [r7, #4]
 8010d62:	2200      	movs	r2, #0
 8010d64:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
    HAL_I2C_SlaveTxCpltCallback(hi2c);
 8010d68:	6878      	ldr	r0, [r7, #4]
 8010d6a:	f7ff fba4 	bl	80104b6 <HAL_I2C_SlaveTxCpltCallback>
}
 8010d6e:	bf00      	nop
 8010d70:	371c      	adds	r7, #28
 8010d72:	46bd      	mov	sp, r7
 8010d74:	bd90      	pop	{r4, r7, pc}
 8010d76:	bf00      	nop
 8010d78:	fe00e800 	.word	0xfe00e800
 8010d7c:	ffff0000 	.word	0xffff0000

08010d80 <I2C_ITListenCplt>:
  * @param  hi2c I2C handle.
  * @param  ITFlags Interrupt flags to handle.
  * @retval None
  */
static void I2C_ITListenCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
{
 8010d80:	b580      	push	{r7, lr}
 8010d82:	b082      	sub	sp, #8
 8010d84:	af00      	add	r7, sp, #0
 8010d86:	6078      	str	r0, [r7, #4]
 8010d88:	6039      	str	r1, [r7, #0]
  /* Reset handle parameters */
  hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 8010d8a:	687b      	ldr	r3, [r7, #4]
 8010d8c:	4a26      	ldr	r2, [pc, #152]	@ (8010e28 <I2C_ITListenCplt+0xa8>)
 8010d8e:	62da      	str	r2, [r3, #44]	@ 0x2c
  hi2c->PreviousState = I2C_STATE_NONE;
 8010d90:	687b      	ldr	r3, [r7, #4]
 8010d92:	2200      	movs	r2, #0
 8010d94:	631a      	str	r2, [r3, #48]	@ 0x30
  hi2c->State = HAL_I2C_STATE_READY;
 8010d96:	687b      	ldr	r3, [r7, #4]
 8010d98:	2220      	movs	r2, #32
 8010d9a:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8010d9e:	687b      	ldr	r3, [r7, #4]
 8010da0:	2200      	movs	r2, #0
 8010da2:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
  hi2c->XferISR = NULL;
 8010da6:	687b      	ldr	r3, [r7, #4]
 8010da8:	2200      	movs	r2, #0
 8010daa:	635a      	str	r2, [r3, #52]	@ 0x34

  /* Store Last receive data if any */
  if (I2C_CHECK_FLAG(ITFlags, I2C_FLAG_RXNE) != RESET)
 8010dac:	683b      	ldr	r3, [r7, #0]
 8010dae:	089b      	lsrs	r3, r3, #2
 8010db0:	f003 0301 	and.w	r3, r3, #1
 8010db4:	2b00      	cmp	r3, #0
 8010db6:	d022      	beq.n	8010dfe <I2C_ITListenCplt+0x7e>
  {
    /* Read data from RXDR */
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
 8010db8:	687b      	ldr	r3, [r7, #4]
 8010dba:	681b      	ldr	r3, [r3, #0]
 8010dbc:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 8010dbe:	687b      	ldr	r3, [r7, #4]
 8010dc0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8010dc2:	b2d2      	uxtb	r2, r2
 8010dc4:	701a      	strb	r2, [r3, #0]

    /* Increment Buffer pointer */
    hi2c->pBuffPtr++;
 8010dc6:	687b      	ldr	r3, [r7, #4]
 8010dc8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8010dca:	1c5a      	adds	r2, r3, #1
 8010dcc:	687b      	ldr	r3, [r7, #4]
 8010dce:	625a      	str	r2, [r3, #36]	@ 0x24

    if ((hi2c->XferSize > 0U))
 8010dd0:	687b      	ldr	r3, [r7, #4]
 8010dd2:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 8010dd4:	2b00      	cmp	r3, #0
 8010dd6:	d012      	beq.n	8010dfe <I2C_ITListenCplt+0x7e>
    {
      hi2c->XferSize--;
 8010dd8:	687b      	ldr	r3, [r7, #4]
 8010dda:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 8010ddc:	3b01      	subs	r3, #1
 8010dde:	b29a      	uxth	r2, r3
 8010de0:	687b      	ldr	r3, [r7, #4]
 8010de2:	851a      	strh	r2, [r3, #40]	@ 0x28
      hi2c->XferCount--;
 8010de4:	687b      	ldr	r3, [r7, #4]
 8010de6:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8010de8:	b29b      	uxth	r3, r3
 8010dea:	3b01      	subs	r3, #1
 8010dec:	b29a      	uxth	r2, r3
 8010dee:	687b      	ldr	r3, [r7, #4]
 8010df0:	855a      	strh	r2, [r3, #42]	@ 0x2a

      /* Set ErrorCode corresponding to a Non-Acknowledge */
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8010df2:	687b      	ldr	r3, [r7, #4]
 8010df4:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8010df6:	f043 0204 	orr.w	r2, r3, #4
 8010dfa:	687b      	ldr	r3, [r7, #4]
 8010dfc:	645a      	str	r2, [r3, #68]	@ 0x44
    }
  }

  /* Disable all Interrupts*/
  I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT | I2C_XFER_TX_IT);
 8010dfe:	f248 0103 	movw	r1, #32771	@ 0x8003
 8010e02:	6878      	ldr	r0, [r7, #4]
 8010e04:	f000 fb60 	bl	80114c8 <I2C_Disable_IRQ>

  /* Clear NACK Flag */
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8010e08:	687b      	ldr	r3, [r7, #4]
 8010e0a:	681b      	ldr	r3, [r3, #0]
 8010e0c:	2210      	movs	r2, #16
 8010e0e:	61da      	str	r2, [r3, #28]

  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
 8010e10:	687b      	ldr	r3, [r7, #4]
 8010e12:	2200      	movs	r2, #0
 8010e14:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

  /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
  hi2c->ListenCpltCallback(hi2c);
#else
  HAL_I2C_ListenCpltCallback(hi2c);
 8010e18:	6878      	ldr	r0, [r7, #4]
 8010e1a:	f7ff fb6e 	bl	80104fa <HAL_I2C_ListenCpltCallback>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
}
 8010e1e:	bf00      	nop
 8010e20:	3708      	adds	r7, #8
 8010e22:	46bd      	mov	sp, r7
 8010e24:	bd80      	pop	{r7, pc}
 8010e26:	bf00      	nop
 8010e28:	ffff0000 	.word	0xffff0000

08010e2c <I2C_ITError>:
  * @param  hi2c I2C handle.
  * @param  ErrorCode Error code to handle.
  * @retval None
  */
static void I2C_ITError(I2C_HandleTypeDef *hi2c, uint32_t ErrorCode)
{
 8010e2c:	b580      	push	{r7, lr}
 8010e2e:	b084      	sub	sp, #16
 8010e30:	af00      	add	r7, sp, #0
 8010e32:	6078      	str	r0, [r7, #4]
 8010e34:	6039      	str	r1, [r7, #0]
  HAL_I2C_StateTypeDef tmpstate = hi2c->State;
 8010e36:	687b      	ldr	r3, [r7, #4]
 8010e38:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 8010e3c:	73fb      	strb	r3, [r7, #15]
#if defined(HAL_DMA_MODULE_ENABLED)
  uint32_t tmppreviousstate;
#endif /* HAL_DMA_MODULE_ENABLED */

  /* Reset handle parameters */
  hi2c->Mode          = HAL_I2C_MODE_NONE;
 8010e3e:	687b      	ldr	r3, [r7, #4]
 8010e40:	2200      	movs	r2, #0
 8010e42:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
 8010e46:	687b      	ldr	r3, [r7, #4]
 8010e48:	4a6d      	ldr	r2, [pc, #436]	@ (8011000 <I2C_ITError+0x1d4>)
 8010e4a:	62da      	str	r2, [r3, #44]	@ 0x2c
  hi2c->XferCount     = 0U;
 8010e4c:	687b      	ldr	r3, [r7, #4]
 8010e4e:	2200      	movs	r2, #0
 8010e50:	855a      	strh	r2, [r3, #42]	@ 0x2a

  /* Set new error code */
  hi2c->ErrorCode |= ErrorCode;
 8010e52:	687b      	ldr	r3, [r7, #4]
 8010e54:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 8010e56:	683b      	ldr	r3, [r7, #0]
 8010e58:	431a      	orrs	r2, r3
 8010e5a:	687b      	ldr	r3, [r7, #4]
 8010e5c:	645a      	str	r2, [r3, #68]	@ 0x44

  /* Disable Interrupts */
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
 8010e5e:	7bfb      	ldrb	r3, [r7, #15]
 8010e60:	2b28      	cmp	r3, #40	@ 0x28
 8010e62:	d005      	beq.n	8010e70 <I2C_ITError+0x44>
 8010e64:	7bfb      	ldrb	r3, [r7, #15]
 8010e66:	2b29      	cmp	r3, #41	@ 0x29
 8010e68:	d002      	beq.n	8010e70 <I2C_ITError+0x44>
      (tmpstate == HAL_I2C_STATE_BUSY_TX_LISTEN) ||
 8010e6a:	7bfb      	ldrb	r3, [r7, #15]
 8010e6c:	2b2a      	cmp	r3, #42	@ 0x2a
 8010e6e:	d10b      	bne.n	8010e88 <I2C_ITError+0x5c>
      (tmpstate == HAL_I2C_STATE_BUSY_RX_LISTEN))
  {
    /* Disable all interrupts, except interrupts related to LISTEN state */
    I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_TX_IT);
 8010e70:	2103      	movs	r1, #3
 8010e72:	6878      	ldr	r0, [r7, #4]
 8010e74:	f000 fb28 	bl	80114c8 <I2C_Disable_IRQ>

    /* keep HAL_I2C_STATE_LISTEN if set */
    hi2c->State         = HAL_I2C_STATE_LISTEN;
 8010e78:	687b      	ldr	r3, [r7, #4]
 8010e7a:	2228      	movs	r2, #40	@ 0x28
 8010e7c:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->XferISR       = I2C_Slave_ISR_IT;
 8010e80:	687b      	ldr	r3, [r7, #4]
 8010e82:	4a60      	ldr	r2, [pc, #384]	@ (8011004 <I2C_ITError+0x1d8>)
 8010e84:	635a      	str	r2, [r3, #52]	@ 0x34
 8010e86:	e030      	b.n	8010eea <I2C_ITError+0xbe>
  }
  else
  {
    /* Disable all interrupts */
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT | I2C_XFER_TX_IT);
 8010e88:	f248 0103 	movw	r1, #32771	@ 0x8003
 8010e8c:	6878      	ldr	r0, [r7, #4]
 8010e8e:	f000 fb1b 	bl	80114c8 <I2C_Disable_IRQ>

    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);
 8010e92:	6878      	ldr	r0, [r7, #4]
 8010e94:	f000 f8e1 	bl	801105a <I2C_Flush_TXDR>

    /* If state is an abort treatment on going, don't change state */
    /* This change will be do later */
    if (hi2c->State != HAL_I2C_STATE_ABORT)
 8010e98:	687b      	ldr	r3, [r7, #4]
 8010e9a:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 8010e9e:	b2db      	uxtb	r3, r3
 8010ea0:	2b60      	cmp	r3, #96	@ 0x60
 8010ea2:	d01f      	beq.n	8010ee4 <I2C_ITError+0xb8>
    {
      /* Set HAL_I2C_STATE_READY */
      hi2c->State         = HAL_I2C_STATE_READY;
 8010ea4:	687b      	ldr	r3, [r7, #4]
 8010ea6:	2220      	movs	r2, #32
 8010ea8:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

      /* Check if a STOPF is detected */
      if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
 8010eac:	687b      	ldr	r3, [r7, #4]
 8010eae:	681b      	ldr	r3, [r3, #0]
 8010eb0:	699b      	ldr	r3, [r3, #24]
 8010eb2:	f003 0320 	and.w	r3, r3, #32
 8010eb6:	2b20      	cmp	r3, #32
 8010eb8:	d114      	bne.n	8010ee4 <I2C_ITError+0xb8>
      {
        if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8010eba:	687b      	ldr	r3, [r7, #4]
 8010ebc:	681b      	ldr	r3, [r3, #0]
 8010ebe:	699b      	ldr	r3, [r3, #24]
 8010ec0:	f003 0310 	and.w	r3, r3, #16
 8010ec4:	2b10      	cmp	r3, #16
 8010ec6:	d109      	bne.n	8010edc <I2C_ITError+0xb0>
        {
          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8010ec8:	687b      	ldr	r3, [r7, #4]
 8010eca:	681b      	ldr	r3, [r3, #0]
 8010ecc:	2210      	movs	r2, #16
 8010ece:	61da      	str	r2, [r3, #28]
          hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8010ed0:	687b      	ldr	r3, [r7, #4]
 8010ed2:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8010ed4:	f043 0204 	orr.w	r2, r3, #4
 8010ed8:	687b      	ldr	r3, [r7, #4]
 8010eda:	645a      	str	r2, [r3, #68]	@ 0x44
        }

        /* Clear STOP Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8010edc:	687b      	ldr	r3, [r7, #4]
 8010ede:	681b      	ldr	r3, [r3, #0]
 8010ee0:	2220      	movs	r2, #32
 8010ee2:	61da      	str	r2, [r3, #28]
      }

    }
    hi2c->XferISR       = NULL;
 8010ee4:	687b      	ldr	r3, [r7, #4]
 8010ee6:	2200      	movs	r2, #0
 8010ee8:	635a      	str	r2, [r3, #52]	@ 0x34
  }

#if defined(HAL_DMA_MODULE_ENABLED)
  /* Abort DMA TX transfer if any */
  tmppreviousstate = hi2c->PreviousState;
 8010eea:	687b      	ldr	r3, [r7, #4]
 8010eec:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8010eee:	60bb      	str	r3, [r7, #8]

  if ((hi2c->hdmatx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_TX) || \
 8010ef0:	687b      	ldr	r3, [r7, #4]
 8010ef2:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8010ef4:	2b00      	cmp	r3, #0
 8010ef6:	d039      	beq.n	8010f6c <I2C_ITError+0x140>
 8010ef8:	68bb      	ldr	r3, [r7, #8]
 8010efa:	2b11      	cmp	r3, #17
 8010efc:	d002      	beq.n	8010f04 <I2C_ITError+0xd8>
 8010efe:	68bb      	ldr	r3, [r7, #8]
 8010f00:	2b21      	cmp	r3, #33	@ 0x21
 8010f02:	d133      	bne.n	8010f6c <I2C_ITError+0x140>
                                 (tmppreviousstate == I2C_STATE_SLAVE_BUSY_TX)))
  {
    if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
 8010f04:	687b      	ldr	r3, [r7, #4]
 8010f06:	681b      	ldr	r3, [r3, #0]
 8010f08:	681b      	ldr	r3, [r3, #0]
 8010f0a:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
 8010f0e:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 8010f12:	d107      	bne.n	8010f24 <I2C_ITError+0xf8>
    {
      hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
 8010f14:	687b      	ldr	r3, [r7, #4]
 8010f16:	681b      	ldr	r3, [r3, #0]
 8010f18:	681a      	ldr	r2, [r3, #0]
 8010f1a:	687b      	ldr	r3, [r7, #4]
 8010f1c:	681b      	ldr	r3, [r3, #0]
 8010f1e:	f422 4280 	bic.w	r2, r2, #16384	@ 0x4000
 8010f22:	601a      	str	r2, [r3, #0]
    }

    if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
 8010f24:	687b      	ldr	r3, [r7, #4]
 8010f26:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8010f28:	4618      	mov	r0, r3
 8010f2a:	f7fd fd63 	bl	800e9f4 <HAL_DMA_GetState>
 8010f2e:	4603      	mov	r3, r0
 8010f30:	2b01      	cmp	r3, #1
 8010f32:	d017      	beq.n	8010f64 <I2C_ITError+0x138>
    {
      /* Set the I2C DMA Abort callback :
       will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
      hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
 8010f34:	687b      	ldr	r3, [r7, #4]
 8010f36:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8010f38:	4a33      	ldr	r2, [pc, #204]	@ (8011008 <I2C_ITError+0x1dc>)
 8010f3a:	66da      	str	r2, [r3, #108]	@ 0x6c

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
 8010f3c:	687b      	ldr	r3, [r7, #4]
 8010f3e:	2200      	movs	r2, #0
 8010f40:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

      /* Abort DMA TX */
      if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
 8010f44:	687b      	ldr	r3, [r7, #4]
 8010f46:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8010f48:	4618      	mov	r0, r3
 8010f4a:	f7fd fbc9 	bl	800e6e0 <HAL_DMA_Abort_IT>
 8010f4e:	4603      	mov	r3, r0
 8010f50:	2b00      	cmp	r3, #0
 8010f52:	d04d      	beq.n	8010ff0 <I2C_ITError+0x1c4>
      {
        /* Call Directly XferAbortCallback function in case of error */
        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
 8010f54:	687b      	ldr	r3, [r7, #4]
 8010f56:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8010f58:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 8010f5a:	687a      	ldr	r2, [r7, #4]
 8010f5c:	6b92      	ldr	r2, [r2, #56]	@ 0x38
 8010f5e:	4610      	mov	r0, r2
 8010f60:	4798      	blx	r3
    if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
 8010f62:	e045      	b.n	8010ff0 <I2C_ITError+0x1c4>
      }
    }
    else
    {
      I2C_TreatErrorCallback(hi2c);
 8010f64:	6878      	ldr	r0, [r7, #4]
 8010f66:	f000 f851 	bl	801100c <I2C_TreatErrorCallback>
    if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
 8010f6a:	e041      	b.n	8010ff0 <I2C_ITError+0x1c4>
    }
  }
  /* Abort DMA RX transfer if any */
  else if ((hi2c->hdmarx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_RX) || \
 8010f6c:	687b      	ldr	r3, [r7, #4]
 8010f6e:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8010f70:	2b00      	cmp	r3, #0
 8010f72:	d039      	beq.n	8010fe8 <I2C_ITError+0x1bc>
 8010f74:	68bb      	ldr	r3, [r7, #8]
 8010f76:	2b12      	cmp	r3, #18
 8010f78:	d002      	beq.n	8010f80 <I2C_ITError+0x154>
 8010f7a:	68bb      	ldr	r3, [r7, #8]
 8010f7c:	2b22      	cmp	r3, #34	@ 0x22
 8010f7e:	d133      	bne.n	8010fe8 <I2C_ITError+0x1bc>
                                      (tmppreviousstate == I2C_STATE_SLAVE_BUSY_RX)))
  {
    if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
 8010f80:	687b      	ldr	r3, [r7, #4]
 8010f82:	681b      	ldr	r3, [r3, #0]
 8010f84:	681b      	ldr	r3, [r3, #0]
 8010f86:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 8010f8a:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 8010f8e:	d107      	bne.n	8010fa0 <I2C_ITError+0x174>
    {
      hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
 8010f90:	687b      	ldr	r3, [r7, #4]
 8010f92:	681b      	ldr	r3, [r3, #0]
 8010f94:	681a      	ldr	r2, [r3, #0]
 8010f96:	687b      	ldr	r3, [r7, #4]
 8010f98:	681b      	ldr	r3, [r3, #0]
 8010f9a:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
 8010f9e:	601a      	str	r2, [r3, #0]
    }

    if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
 8010fa0:	687b      	ldr	r3, [r7, #4]
 8010fa2:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8010fa4:	4618      	mov	r0, r3
 8010fa6:	f7fd fd25 	bl	800e9f4 <HAL_DMA_GetState>
 8010faa:	4603      	mov	r3, r0
 8010fac:	2b01      	cmp	r3, #1
 8010fae:	d017      	beq.n	8010fe0 <I2C_ITError+0x1b4>
    {
      /* Set the I2C DMA Abort callback :
        will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
      hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
 8010fb0:	687b      	ldr	r3, [r7, #4]
 8010fb2:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8010fb4:	4a14      	ldr	r2, [pc, #80]	@ (8011008 <I2C_ITError+0x1dc>)
 8010fb6:	66da      	str	r2, [r3, #108]	@ 0x6c

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
 8010fb8:	687b      	ldr	r3, [r7, #4]
 8010fba:	2200      	movs	r2, #0
 8010fbc:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

      /* Abort DMA RX */
      if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
 8010fc0:	687b      	ldr	r3, [r7, #4]
 8010fc2:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8010fc4:	4618      	mov	r0, r3
 8010fc6:	f7fd fb8b 	bl	800e6e0 <HAL_DMA_Abort_IT>
 8010fca:	4603      	mov	r3, r0
 8010fcc:	2b00      	cmp	r3, #0
 8010fce:	d011      	beq.n	8010ff4 <I2C_ITError+0x1c8>
      {
        /* Call Directly hi2c->hdmarx->XferAbortCallback function in case of error */
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
 8010fd0:	687b      	ldr	r3, [r7, #4]
 8010fd2:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8010fd4:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 8010fd6:	687a      	ldr	r2, [r7, #4]
 8010fd8:	6bd2      	ldr	r2, [r2, #60]	@ 0x3c
 8010fda:	4610      	mov	r0, r2
 8010fdc:	4798      	blx	r3
    if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
 8010fde:	e009      	b.n	8010ff4 <I2C_ITError+0x1c8>
      }
    }
    else
    {
      I2C_TreatErrorCallback(hi2c);
 8010fe0:	6878      	ldr	r0, [r7, #4]
 8010fe2:	f000 f813 	bl	801100c <I2C_TreatErrorCallback>
    if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
 8010fe6:	e005      	b.n	8010ff4 <I2C_ITError+0x1c8>
    }
  }
  else
#endif /* HAL_DMA_MODULE_ENABLED */
  {
    I2C_TreatErrorCallback(hi2c);
 8010fe8:	6878      	ldr	r0, [r7, #4]
 8010fea:	f000 f80f 	bl	801100c <I2C_TreatErrorCallback>
  }
}
 8010fee:	e002      	b.n	8010ff6 <I2C_ITError+0x1ca>
    if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
 8010ff0:	bf00      	nop
 8010ff2:	e000      	b.n	8010ff6 <I2C_ITError+0x1ca>
    if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
 8010ff4:	bf00      	nop
}
 8010ff6:	bf00      	nop
 8010ff8:	3710      	adds	r7, #16
 8010ffa:	46bd      	mov	sp, r7
 8010ffc:	bd80      	pop	{r7, pc}
 8010ffe:	bf00      	nop
 8011000:	ffff0000 	.word	0xffff0000
 8011004:	0801056b 	.word	0x0801056b
 8011008:	080110a3 	.word	0x080110a3

0801100c <I2C_TreatErrorCallback>:
  * @brief  I2C Error callback treatment.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_TreatErrorCallback(I2C_HandleTypeDef *hi2c)
{
 801100c:	b580      	push	{r7, lr}
 801100e:	b082      	sub	sp, #8
 8011010:	af00      	add	r7, sp, #0
 8011012:	6078      	str	r0, [r7, #4]
  if (hi2c->State == HAL_I2C_STATE_ABORT)
 8011014:	687b      	ldr	r3, [r7, #4]
 8011016:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 801101a:	b2db      	uxtb	r3, r3
 801101c:	2b60      	cmp	r3, #96	@ 0x60
 801101e:	d10e      	bne.n	801103e <I2C_TreatErrorCallback+0x32>
  {
    hi2c->State = HAL_I2C_STATE_READY;
 8011020:	687b      	ldr	r3, [r7, #4]
 8011022:	2220      	movs	r2, #32
 8011024:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
 8011028:	687b      	ldr	r3, [r7, #4]
 801102a:	2200      	movs	r2, #0
 801102c:	631a      	str	r2, [r3, #48]	@ 0x30

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 801102e:	687b      	ldr	r3, [r7, #4]
 8011030:	2200      	movs	r2, #0
 8011032:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    /* Call the corresponding callback to inform upper layer of End of Transfer */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    hi2c->AbortCpltCallback(hi2c);
#else
    HAL_I2C_AbortCpltCallback(hi2c);
 8011036:	6878      	ldr	r0, [r7, #4]
 8011038:	f7ff fa73 	bl	8010522 <HAL_I2C_AbortCpltCallback>
    hi2c->ErrorCallback(hi2c);
#else
    HAL_I2C_ErrorCallback(hi2c);
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }
}
 801103c:	e009      	b.n	8011052 <I2C_TreatErrorCallback+0x46>
    hi2c->PreviousState = I2C_STATE_NONE;
 801103e:	687b      	ldr	r3, [r7, #4]
 8011040:	2200      	movs	r2, #0
 8011042:	631a      	str	r2, [r3, #48]	@ 0x30
    __HAL_UNLOCK(hi2c);
 8011044:	687b      	ldr	r3, [r7, #4]
 8011046:	2200      	movs	r2, #0
 8011048:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
    HAL_I2C_ErrorCallback(hi2c);
 801104c:	6878      	ldr	r0, [r7, #4]
 801104e:	f7ff fa5e 	bl	801050e <HAL_I2C_ErrorCallback>
}
 8011052:	bf00      	nop
 8011054:	3708      	adds	r7, #8
 8011056:	46bd      	mov	sp, r7
 8011058:	bd80      	pop	{r7, pc}

0801105a <I2C_Flush_TXDR>:
  * @brief  I2C Tx data register flush process.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_Flush_TXDR(I2C_HandleTypeDef *hi2c)
{
 801105a:	b480      	push	{r7}
 801105c:	b083      	sub	sp, #12
 801105e:	af00      	add	r7, sp, #0
 8011060:	6078      	str	r0, [r7, #4]
  /* If a pending TXIS flag is set */
  /* Write a dummy data in TXDR to clear it */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 8011062:	687b      	ldr	r3, [r7, #4]
 8011064:	681b      	ldr	r3, [r3, #0]
 8011066:	699b      	ldr	r3, [r3, #24]
 8011068:	f003 0302 	and.w	r3, r3, #2
 801106c:	2b02      	cmp	r3, #2
 801106e:	d103      	bne.n	8011078 <I2C_Flush_TXDR+0x1e>
  {
    hi2c->Instance->TXDR = 0x00U;
 8011070:	687b      	ldr	r3, [r7, #4]
 8011072:	681b      	ldr	r3, [r3, #0]
 8011074:	2200      	movs	r2, #0
 8011076:	629a      	str	r2, [r3, #40]	@ 0x28
  }

  /* Flush TX register if not empty */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 8011078:	687b      	ldr	r3, [r7, #4]
 801107a:	681b      	ldr	r3, [r3, #0]
 801107c:	699b      	ldr	r3, [r3, #24]
 801107e:	f003 0301 	and.w	r3, r3, #1
 8011082:	2b01      	cmp	r3, #1
 8011084:	d007      	beq.n	8011096 <I2C_Flush_TXDR+0x3c>
  {
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
 8011086:	687b      	ldr	r3, [r7, #4]
 8011088:	681b      	ldr	r3, [r3, #0]
 801108a:	699a      	ldr	r2, [r3, #24]
 801108c:	687b      	ldr	r3, [r7, #4]
 801108e:	681b      	ldr	r3, [r3, #0]
 8011090:	f042 0201 	orr.w	r2, r2, #1
 8011094:	619a      	str	r2, [r3, #24]
  }
}
 8011096:	bf00      	nop
 8011098:	370c      	adds	r7, #12
 801109a:	46bd      	mov	sp, r7
 801109c:	f85d 7b04 	ldr.w	r7, [sp], #4
 80110a0:	4770      	bx	lr

080110a2 <I2C_DMAAbort>:
  *        (To be called at end of DMA Abort procedure).
  * @param hdma DMA handle.
  * @retval None
  */
static void I2C_DMAAbort(DMA_HandleTypeDef *hdma)
{
 80110a2:	b580      	push	{r7, lr}
 80110a4:	b084      	sub	sp, #16
 80110a6:	af00      	add	r7, sp, #0
 80110a8:	6078      	str	r0, [r7, #4]
  /* Derogation MISRAC2012-Rule-11.5 */
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent);
 80110aa:	687b      	ldr	r3, [r7, #4]
 80110ac:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 80110ae:	60fb      	str	r3, [r7, #12]

  /* Reset AbortCpltCallback */
  if (hi2c->hdmatx != NULL)
 80110b0:	68fb      	ldr	r3, [r7, #12]
 80110b2:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80110b4:	2b00      	cmp	r3, #0
 80110b6:	d003      	beq.n	80110c0 <I2C_DMAAbort+0x1e>
  {
    hi2c->hdmatx->XferAbortCallback = NULL;
 80110b8:	68fb      	ldr	r3, [r7, #12]
 80110ba:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80110bc:	2200      	movs	r2, #0
 80110be:	66da      	str	r2, [r3, #108]	@ 0x6c
  }
  if (hi2c->hdmarx != NULL)
 80110c0:	68fb      	ldr	r3, [r7, #12]
 80110c2:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80110c4:	2b00      	cmp	r3, #0
 80110c6:	d003      	beq.n	80110d0 <I2C_DMAAbort+0x2e>
  {
    hi2c->hdmarx->XferAbortCallback = NULL;
 80110c8:	68fb      	ldr	r3, [r7, #12]
 80110ca:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80110cc:	2200      	movs	r2, #0
 80110ce:	66da      	str	r2, [r3, #108]	@ 0x6c
  }

  I2C_TreatErrorCallback(hi2c);
 80110d0:	68f8      	ldr	r0, [r7, #12]
 80110d2:	f7ff ff9b 	bl	801100c <I2C_TreatErrorCallback>
}
 80110d6:	bf00      	nop
 80110d8:	3710      	adds	r7, #16
 80110da:	46bd      	mov	sp, r7
 80110dc:	bd80      	pop	{r7, pc}

080110de <I2C_WaitOnFlagUntilTimeout>:
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status,
                                                    uint32_t Timeout, uint32_t Tickstart)
{
 80110de:	b580      	push	{r7, lr}
 80110e0:	b084      	sub	sp, #16
 80110e2:	af00      	add	r7, sp, #0
 80110e4:	60f8      	str	r0, [r7, #12]
 80110e6:	60b9      	str	r1, [r7, #8]
 80110e8:	603b      	str	r3, [r7, #0]
 80110ea:	4613      	mov	r3, r2
 80110ec:	71fb      	strb	r3, [r7, #7]
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 80110ee:	e03b      	b.n	8011168 <I2C_WaitOnFlagUntilTimeout+0x8a>
  {
    /* Check if an error is detected */
    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)
 80110f0:	69ba      	ldr	r2, [r7, #24]
 80110f2:	6839      	ldr	r1, [r7, #0]
 80110f4:	68f8      	ldr	r0, [r7, #12]
 80110f6:	f000 f8d5 	bl	80112a4 <I2C_IsErrorOccurred>
 80110fa:	4603      	mov	r3, r0
 80110fc:	2b00      	cmp	r3, #0
 80110fe:	d001      	beq.n	8011104 <I2C_WaitOnFlagUntilTimeout+0x26>
    {
      return HAL_ERROR;
 8011100:	2301      	movs	r3, #1
 8011102:	e041      	b.n	8011188 <I2C_WaitOnFlagUntilTimeout+0xaa>
    }

    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 8011104:	683b      	ldr	r3, [r7, #0]
 8011106:	f1b3 3fff 	cmp.w	r3, #4294967295
 801110a:	d02d      	beq.n	8011168 <I2C_WaitOnFlagUntilTimeout+0x8a>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 801110c:	f7fc fca8 	bl	800da60 <HAL_GetTick>
 8011110:	4602      	mov	r2, r0
 8011112:	69bb      	ldr	r3, [r7, #24]
 8011114:	1ad3      	subs	r3, r2, r3
 8011116:	683a      	ldr	r2, [r7, #0]
 8011118:	429a      	cmp	r2, r3
 801111a:	d302      	bcc.n	8011122 <I2C_WaitOnFlagUntilTimeout+0x44>
 801111c:	683b      	ldr	r3, [r7, #0]
 801111e:	2b00      	cmp	r3, #0
 8011120:	d122      	bne.n	8011168 <I2C_WaitOnFlagUntilTimeout+0x8a>
      {
        if ((__HAL_I2C_GET_FLAG(hi2c, Flag) == Status))
 8011122:	68fb      	ldr	r3, [r7, #12]
 8011124:	681b      	ldr	r3, [r3, #0]
 8011126:	699a      	ldr	r2, [r3, #24]
 8011128:	68bb      	ldr	r3, [r7, #8]
 801112a:	4013      	ands	r3, r2
 801112c:	68ba      	ldr	r2, [r7, #8]
 801112e:	429a      	cmp	r2, r3
 8011130:	bf0c      	ite	eq
 8011132:	2301      	moveq	r3, #1
 8011134:	2300      	movne	r3, #0
 8011136:	b2db      	uxtb	r3, r3
 8011138:	461a      	mov	r2, r3
 801113a:	79fb      	ldrb	r3, [r7, #7]
 801113c:	429a      	cmp	r2, r3
 801113e:	d113      	bne.n	8011168 <I2C_WaitOnFlagUntilTimeout+0x8a>
        {
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8011140:	68fb      	ldr	r3, [r7, #12]
 8011142:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8011144:	f043 0220 	orr.w	r2, r3, #32
 8011148:	68fb      	ldr	r3, [r7, #12]
 801114a:	645a      	str	r2, [r3, #68]	@ 0x44
          hi2c->State = HAL_I2C_STATE_READY;
 801114c:	68fb      	ldr	r3, [r7, #12]
 801114e:	2220      	movs	r2, #32
 8011150:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
          hi2c->Mode = HAL_I2C_MODE_NONE;
 8011154:	68fb      	ldr	r3, [r7, #12]
 8011156:	2200      	movs	r2, #0
 8011158:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

          /* Process Unlocked */
          __HAL_UNLOCK(hi2c);
 801115c:	68fb      	ldr	r3, [r7, #12]
 801115e:	2200      	movs	r2, #0
 8011160:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
          return HAL_ERROR;
 8011164:	2301      	movs	r3, #1
 8011166:	e00f      	b.n	8011188 <I2C_WaitOnFlagUntilTimeout+0xaa>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 8011168:	68fb      	ldr	r3, [r7, #12]
 801116a:	681b      	ldr	r3, [r3, #0]
 801116c:	699a      	ldr	r2, [r3, #24]
 801116e:	68bb      	ldr	r3, [r7, #8]
 8011170:	4013      	ands	r3, r2
 8011172:	68ba      	ldr	r2, [r7, #8]
 8011174:	429a      	cmp	r2, r3
 8011176:	bf0c      	ite	eq
 8011178:	2301      	moveq	r3, #1
 801117a:	2300      	movne	r3, #0
 801117c:	b2db      	uxtb	r3, r3
 801117e:	461a      	mov	r2, r3
 8011180:	79fb      	ldrb	r3, [r7, #7]
 8011182:	429a      	cmp	r2, r3
 8011184:	d0b4      	beq.n	80110f0 <I2C_WaitOnFlagUntilTimeout+0x12>
        }
      }
    }
  }
  return HAL_OK;
 8011186:	2300      	movs	r3, #0
}
 8011188:	4618      	mov	r0, r3
 801118a:	3710      	adds	r7, #16
 801118c:	46bd      	mov	sp, r7
 801118e:	bd80      	pop	{r7, pc}

08011190 <I2C_WaitOnTXISFlagUntilTimeout>:
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnTXISFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout,
                                                        uint32_t Tickstart)
{
 8011190:	b580      	push	{r7, lr}
 8011192:	b084      	sub	sp, #16
 8011194:	af00      	add	r7, sp, #0
 8011196:	60f8      	str	r0, [r7, #12]
 8011198:	60b9      	str	r1, [r7, #8]
 801119a:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
 801119c:	e033      	b.n	8011206 <I2C_WaitOnTXISFlagUntilTimeout+0x76>
  {
    /* Check if an error is detected */
    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)
 801119e:	687a      	ldr	r2, [r7, #4]
 80111a0:	68b9      	ldr	r1, [r7, #8]
 80111a2:	68f8      	ldr	r0, [r7, #12]
 80111a4:	f000 f87e 	bl	80112a4 <I2C_IsErrorOccurred>
 80111a8:	4603      	mov	r3, r0
 80111aa:	2b00      	cmp	r3, #0
 80111ac:	d001      	beq.n	80111b2 <I2C_WaitOnTXISFlagUntilTimeout+0x22>
    {
      return HAL_ERROR;
 80111ae:	2301      	movs	r3, #1
 80111b0:	e031      	b.n	8011216 <I2C_WaitOnTXISFlagUntilTimeout+0x86>
    }

    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 80111b2:	68bb      	ldr	r3, [r7, #8]
 80111b4:	f1b3 3fff 	cmp.w	r3, #4294967295
 80111b8:	d025      	beq.n	8011206 <I2C_WaitOnTXISFlagUntilTimeout+0x76>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 80111ba:	f7fc fc51 	bl	800da60 <HAL_GetTick>
 80111be:	4602      	mov	r2, r0
 80111c0:	687b      	ldr	r3, [r7, #4]
 80111c2:	1ad3      	subs	r3, r2, r3
 80111c4:	68ba      	ldr	r2, [r7, #8]
 80111c6:	429a      	cmp	r2, r3
 80111c8:	d302      	bcc.n	80111d0 <I2C_WaitOnTXISFlagUntilTimeout+0x40>
 80111ca:	68bb      	ldr	r3, [r7, #8]
 80111cc:	2b00      	cmp	r3, #0
 80111ce:	d11a      	bne.n	8011206 <I2C_WaitOnTXISFlagUntilTimeout+0x76>
      {
        if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET))
 80111d0:	68fb      	ldr	r3, [r7, #12]
 80111d2:	681b      	ldr	r3, [r3, #0]
 80111d4:	699b      	ldr	r3, [r3, #24]
 80111d6:	f003 0302 	and.w	r3, r3, #2
 80111da:	2b02      	cmp	r3, #2
 80111dc:	d013      	beq.n	8011206 <I2C_WaitOnTXISFlagUntilTimeout+0x76>
        {
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 80111de:	68fb      	ldr	r3, [r7, #12]
 80111e0:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 80111e2:	f043 0220 	orr.w	r2, r3, #32
 80111e6:	68fb      	ldr	r3, [r7, #12]
 80111e8:	645a      	str	r2, [r3, #68]	@ 0x44
          hi2c->State = HAL_I2C_STATE_READY;
 80111ea:	68fb      	ldr	r3, [r7, #12]
 80111ec:	2220      	movs	r2, #32
 80111ee:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
          hi2c->Mode = HAL_I2C_MODE_NONE;
 80111f2:	68fb      	ldr	r3, [r7, #12]
 80111f4:	2200      	movs	r2, #0
 80111f6:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

          /* Process Unlocked */
          __HAL_UNLOCK(hi2c);
 80111fa:	68fb      	ldr	r3, [r7, #12]
 80111fc:	2200      	movs	r2, #0
 80111fe:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

          return HAL_ERROR;
 8011202:	2301      	movs	r3, #1
 8011204:	e007      	b.n	8011216 <I2C_WaitOnTXISFlagUntilTimeout+0x86>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
 8011206:	68fb      	ldr	r3, [r7, #12]
 8011208:	681b      	ldr	r3, [r3, #0]
 801120a:	699b      	ldr	r3, [r3, #24]
 801120c:	f003 0302 	and.w	r3, r3, #2
 8011210:	2b02      	cmp	r3, #2
 8011212:	d1c4      	bne.n	801119e <I2C_WaitOnTXISFlagUntilTimeout+0xe>
        }
      }
    }
  }
  return HAL_OK;
 8011214:	2300      	movs	r3, #0
}
 8011216:	4618      	mov	r0, r3
 8011218:	3710      	adds	r7, #16
 801121a:	46bd      	mov	sp, r7
 801121c:	bd80      	pop	{r7, pc}

0801121e <I2C_WaitOnSTOPFlagUntilTimeout>:
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout,
                                                        uint32_t Tickstart)
{
 801121e:	b580      	push	{r7, lr}
 8011220:	b084      	sub	sp, #16
 8011222:	af00      	add	r7, sp, #0
 8011224:	60f8      	str	r0, [r7, #12]
 8011226:	60b9      	str	r1, [r7, #8]
 8011228:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 801122a:	e02f      	b.n	801128c <I2C_WaitOnSTOPFlagUntilTimeout+0x6e>
  {
    /* Check if an error is detected */
    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)
 801122c:	687a      	ldr	r2, [r7, #4]
 801122e:	68b9      	ldr	r1, [r7, #8]
 8011230:	68f8      	ldr	r0, [r7, #12]
 8011232:	f000 f837 	bl	80112a4 <I2C_IsErrorOccurred>
 8011236:	4603      	mov	r3, r0
 8011238:	2b00      	cmp	r3, #0
 801123a:	d001      	beq.n	8011240 <I2C_WaitOnSTOPFlagUntilTimeout+0x22>
    {
      return HAL_ERROR;
 801123c:	2301      	movs	r3, #1
 801123e:	e02d      	b.n	801129c <I2C_WaitOnSTOPFlagUntilTimeout+0x7e>
    }

    /* Check for the Timeout */
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8011240:	f7fc fc0e 	bl	800da60 <HAL_GetTick>
 8011244:	4602      	mov	r2, r0
 8011246:	687b      	ldr	r3, [r7, #4]
 8011248:	1ad3      	subs	r3, r2, r3
 801124a:	68ba      	ldr	r2, [r7, #8]
 801124c:	429a      	cmp	r2, r3
 801124e:	d302      	bcc.n	8011256 <I2C_WaitOnSTOPFlagUntilTimeout+0x38>
 8011250:	68bb      	ldr	r3, [r7, #8]
 8011252:	2b00      	cmp	r3, #0
 8011254:	d11a      	bne.n	801128c <I2C_WaitOnSTOPFlagUntilTimeout+0x6e>
    {
      if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET))
 8011256:	68fb      	ldr	r3, [r7, #12]
 8011258:	681b      	ldr	r3, [r3, #0]
 801125a:	699b      	ldr	r3, [r3, #24]
 801125c:	f003 0320 	and.w	r3, r3, #32
 8011260:	2b20      	cmp	r3, #32
 8011262:	d013      	beq.n	801128c <I2C_WaitOnSTOPFlagUntilTimeout+0x6e>
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8011264:	68fb      	ldr	r3, [r7, #12]
 8011266:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8011268:	f043 0220 	orr.w	r2, r3, #32
 801126c:	68fb      	ldr	r3, [r7, #12]
 801126e:	645a      	str	r2, [r3, #68]	@ 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 8011270:	68fb      	ldr	r3, [r7, #12]
 8011272:	2220      	movs	r2, #32
 8011274:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8011278:	68fb      	ldr	r3, [r7, #12]
 801127a:	2200      	movs	r2, #0
 801127c:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
 8011280:	68fb      	ldr	r3, [r7, #12]
 8011282:	2200      	movs	r2, #0
 8011284:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

        return HAL_ERROR;
 8011288:	2301      	movs	r3, #1
 801128a:	e007      	b.n	801129c <I2C_WaitOnSTOPFlagUntilTimeout+0x7e>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 801128c:	68fb      	ldr	r3, [r7, #12]
 801128e:	681b      	ldr	r3, [r3, #0]
 8011290:	699b      	ldr	r3, [r3, #24]
 8011292:	f003 0320 	and.w	r3, r3, #32
 8011296:	2b20      	cmp	r3, #32
 8011298:	d1c8      	bne.n	801122c <I2C_WaitOnSTOPFlagUntilTimeout+0xe>
      }
    }
  }
  return HAL_OK;
 801129a:	2300      	movs	r3, #0
}
 801129c:	4618      	mov	r0, r3
 801129e:	3710      	adds	r7, #16
 80112a0:	46bd      	mov	sp, r7
 80112a2:	bd80      	pop	{r7, pc}

080112a4 <I2C_IsErrorOccurred>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_IsErrorOccurred(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
 80112a4:	b580      	push	{r7, lr}
 80112a6:	b08a      	sub	sp, #40	@ 0x28
 80112a8:	af00      	add	r7, sp, #0
 80112aa:	60f8      	str	r0, [r7, #12]
 80112ac:	60b9      	str	r1, [r7, #8]
 80112ae:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 80112b0:	2300      	movs	r3, #0
 80112b2:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  uint32_t itflag   = hi2c->Instance->ISR;
 80112b6:	68fb      	ldr	r3, [r7, #12]
 80112b8:	681b      	ldr	r3, [r3, #0]
 80112ba:	699b      	ldr	r3, [r3, #24]
 80112bc:	61bb      	str	r3, [r7, #24]
  uint32_t error_code = 0;
 80112be:	2300      	movs	r3, #0
 80112c0:	623b      	str	r3, [r7, #32]
  uint32_t tickstart = Tickstart;
 80112c2:	687b      	ldr	r3, [r7, #4]
 80112c4:	61fb      	str	r3, [r7, #28]
  uint32_t tmp1;
  HAL_I2C_ModeTypeDef tmp2;

  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_AF))
 80112c6:	69bb      	ldr	r3, [r7, #24]
 80112c8:	f003 0310 	and.w	r3, r3, #16
 80112cc:	2b00      	cmp	r3, #0
 80112ce:	d068      	beq.n	80113a2 <I2C_IsErrorOccurred+0xfe>
  {
    /* Clear NACKF Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 80112d0:	68fb      	ldr	r3, [r7, #12]
 80112d2:	681b      	ldr	r3, [r3, #0]
 80112d4:	2210      	movs	r2, #16
 80112d6:	61da      	str	r2, [r3, #28]

    /* Wait until STOP Flag is set or timeout occurred */
    /* AutoEnd should be initiate after AF */
    while ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (status == HAL_OK))
 80112d8:	e049      	b.n	801136e <I2C_IsErrorOccurred+0xca>
    {
      /* Check for the Timeout */
      if (Timeout != HAL_MAX_DELAY)
 80112da:	68bb      	ldr	r3, [r7, #8]
 80112dc:	f1b3 3fff 	cmp.w	r3, #4294967295
 80112e0:	d045      	beq.n	801136e <I2C_IsErrorOccurred+0xca>
      {
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
 80112e2:	f7fc fbbd 	bl	800da60 <HAL_GetTick>
 80112e6:	4602      	mov	r2, r0
 80112e8:	69fb      	ldr	r3, [r7, #28]
 80112ea:	1ad3      	subs	r3, r2, r3
 80112ec:	68ba      	ldr	r2, [r7, #8]
 80112ee:	429a      	cmp	r2, r3
 80112f0:	d302      	bcc.n	80112f8 <I2C_IsErrorOccurred+0x54>
 80112f2:	68bb      	ldr	r3, [r7, #8]
 80112f4:	2b00      	cmp	r3, #0
 80112f6:	d13a      	bne.n	801136e <I2C_IsErrorOccurred+0xca>
        {
          tmp1 = (uint32_t)(hi2c->Instance->CR2 & I2C_CR2_STOP);
 80112f8:	68fb      	ldr	r3, [r7, #12]
 80112fa:	681b      	ldr	r3, [r3, #0]
 80112fc:	685b      	ldr	r3, [r3, #4]
 80112fe:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
 8011302:	617b      	str	r3, [r7, #20]
          tmp2 = hi2c->Mode;
 8011304:	68fb      	ldr	r3, [r7, #12]
 8011306:	f893 3042 	ldrb.w	r3, [r3, #66]	@ 0x42
 801130a:	74fb      	strb	r3, [r7, #19]

          /* In case of I2C still busy, try to regenerate a STOP manually */
          if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET) && \
 801130c:	68fb      	ldr	r3, [r7, #12]
 801130e:	681b      	ldr	r3, [r3, #0]
 8011310:	699b      	ldr	r3, [r3, #24]
 8011312:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 8011316:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 801131a:	d121      	bne.n	8011360 <I2C_IsErrorOccurred+0xbc>
 801131c:	697b      	ldr	r3, [r7, #20]
 801131e:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 8011322:	d01d      	beq.n	8011360 <I2C_IsErrorOccurred+0xbc>
              (tmp1 != I2C_CR2_STOP) && \
 8011324:	7cfb      	ldrb	r3, [r7, #19]
 8011326:	2b20      	cmp	r3, #32
 8011328:	d01a      	beq.n	8011360 <I2C_IsErrorOccurred+0xbc>
              (tmp2 != HAL_I2C_MODE_SLAVE))
          {
            /* Generate Stop */
            hi2c->Instance->CR2 |= I2C_CR2_STOP;
 801132a:	68fb      	ldr	r3, [r7, #12]
 801132c:	681b      	ldr	r3, [r3, #0]
 801132e:	685a      	ldr	r2, [r3, #4]
 8011330:	68fb      	ldr	r3, [r7, #12]
 8011332:	681b      	ldr	r3, [r3, #0]
 8011334:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
 8011338:	605a      	str	r2, [r3, #4]

            /* Update Tick with new reference */
            tickstart = HAL_GetTick();
 801133a:	f7fc fb91 	bl	800da60 <HAL_GetTick>
 801133e:	61f8      	str	r0, [r7, #28]
          }

          while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8011340:	e00e      	b.n	8011360 <I2C_IsErrorOccurred+0xbc>
          {
            /* Check for the Timeout */
            if ((HAL_GetTick() - tickstart) > I2C_TIMEOUT_STOPF)
 8011342:	f7fc fb8d 	bl	800da60 <HAL_GetTick>
 8011346:	4602      	mov	r2, r0
 8011348:	69fb      	ldr	r3, [r7, #28]
 801134a:	1ad3      	subs	r3, r2, r3
 801134c:	2b19      	cmp	r3, #25
 801134e:	d907      	bls.n	8011360 <I2C_IsErrorOccurred+0xbc>
            {
              error_code |= HAL_I2C_ERROR_TIMEOUT;
 8011350:	6a3b      	ldr	r3, [r7, #32]
 8011352:	f043 0320 	orr.w	r3, r3, #32
 8011356:	623b      	str	r3, [r7, #32]

              status = HAL_ERROR;
 8011358:	2301      	movs	r3, #1
 801135a:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27

              break;
 801135e:	e006      	b.n	801136e <I2C_IsErrorOccurred+0xca>
          while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8011360:	68fb      	ldr	r3, [r7, #12]
 8011362:	681b      	ldr	r3, [r3, #0]
 8011364:	699b      	ldr	r3, [r3, #24]
 8011366:	f003 0320 	and.w	r3, r3, #32
 801136a:	2b20      	cmp	r3, #32
 801136c:	d1e9      	bne.n	8011342 <I2C_IsErrorOccurred+0x9e>
    while ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (status == HAL_OK))
 801136e:	68fb      	ldr	r3, [r7, #12]
 8011370:	681b      	ldr	r3, [r3, #0]
 8011372:	699b      	ldr	r3, [r3, #24]
 8011374:	f003 0320 	and.w	r3, r3, #32
 8011378:	2b20      	cmp	r3, #32
 801137a:	d003      	beq.n	8011384 <I2C_IsErrorOccurred+0xe0>
 801137c:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 8011380:	2b00      	cmp	r3, #0
 8011382:	d0aa      	beq.n	80112da <I2C_IsErrorOccurred+0x36>
        }
      }
    }

    /* In case STOP Flag is detected, clear it */
    if (status == HAL_OK)
 8011384:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 8011388:	2b00      	cmp	r3, #0
 801138a:	d103      	bne.n	8011394 <I2C_IsErrorOccurred+0xf0>
    {
      /* Clear STOP Flag */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 801138c:	68fb      	ldr	r3, [r7, #12]
 801138e:	681b      	ldr	r3, [r3, #0]
 8011390:	2220      	movs	r2, #32
 8011392:	61da      	str	r2, [r3, #28]
    }

    error_code |= HAL_I2C_ERROR_AF;
 8011394:	6a3b      	ldr	r3, [r7, #32]
 8011396:	f043 0304 	orr.w	r3, r3, #4
 801139a:	623b      	str	r3, [r7, #32]

    status = HAL_ERROR;
 801139c:	2301      	movs	r3, #1
 801139e:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  }

  /* Refresh Content of Status register */
  itflag = hi2c->Instance->ISR;
 80113a2:	68fb      	ldr	r3, [r7, #12]
 80113a4:	681b      	ldr	r3, [r3, #0]
 80113a6:	699b      	ldr	r3, [r3, #24]
 80113a8:	61bb      	str	r3, [r7, #24]

  /* Then verify if an additional errors occurs */
  /* Check if a Bus error occurred */
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_BERR))
 80113aa:	69bb      	ldr	r3, [r7, #24]
 80113ac:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 80113b0:	2b00      	cmp	r3, #0
 80113b2:	d00b      	beq.n	80113cc <I2C_IsErrorOccurred+0x128>
  {
    error_code |= HAL_I2C_ERROR_BERR;
 80113b4:	6a3b      	ldr	r3, [r7, #32]
 80113b6:	f043 0301 	orr.w	r3, r3, #1
 80113ba:	623b      	str	r3, [r7, #32]

    /* Clear BERR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
 80113bc:	68fb      	ldr	r3, [r7, #12]
 80113be:	681b      	ldr	r3, [r3, #0]
 80113c0:	f44f 7280 	mov.w	r2, #256	@ 0x100
 80113c4:	61da      	str	r2, [r3, #28]

    status = HAL_ERROR;
 80113c6:	2301      	movs	r3, #1
 80113c8:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  }

  /* Check if an Over-Run/Under-Run error occurred */
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_OVR))
 80113cc:	69bb      	ldr	r3, [r7, #24]
 80113ce:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 80113d2:	2b00      	cmp	r3, #0
 80113d4:	d00b      	beq.n	80113ee <I2C_IsErrorOccurred+0x14a>
  {
    error_code |= HAL_I2C_ERROR_OVR;
 80113d6:	6a3b      	ldr	r3, [r7, #32]
 80113d8:	f043 0308 	orr.w	r3, r3, #8
 80113dc:	623b      	str	r3, [r7, #32]

    /* Clear OVR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
 80113de:	68fb      	ldr	r3, [r7, #12]
 80113e0:	681b      	ldr	r3, [r3, #0]
 80113e2:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 80113e6:	61da      	str	r2, [r3, #28]

    status = HAL_ERROR;
 80113e8:	2301      	movs	r3, #1
 80113ea:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  }

  /* Check if an Arbitration Loss error occurred */
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_ARLO))
 80113ee:	69bb      	ldr	r3, [r7, #24]
 80113f0:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 80113f4:	2b00      	cmp	r3, #0
 80113f6:	d00b      	beq.n	8011410 <I2C_IsErrorOccurred+0x16c>
  {
    error_code |= HAL_I2C_ERROR_ARLO;
 80113f8:	6a3b      	ldr	r3, [r7, #32]
 80113fa:	f043 0302 	orr.w	r3, r3, #2
 80113fe:	623b      	str	r3, [r7, #32]

    /* Clear ARLO flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
 8011400:	68fb      	ldr	r3, [r7, #12]
 8011402:	681b      	ldr	r3, [r3, #0]
 8011404:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8011408:	61da      	str	r2, [r3, #28]

    status = HAL_ERROR;
 801140a:	2301      	movs	r3, #1
 801140c:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  }

  if (status != HAL_OK)
 8011410:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 8011414:	2b00      	cmp	r3, #0
 8011416:	d01c      	beq.n	8011452 <I2C_IsErrorOccurred+0x1ae>
  {
    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);
 8011418:	68f8      	ldr	r0, [r7, #12]
 801141a:	f7ff fe1e 	bl	801105a <I2C_Flush_TXDR>

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 801141e:	68fb      	ldr	r3, [r7, #12]
 8011420:	681b      	ldr	r3, [r3, #0]
 8011422:	6859      	ldr	r1, [r3, #4]
 8011424:	68fb      	ldr	r3, [r7, #12]
 8011426:	681a      	ldr	r2, [r3, #0]
 8011428:	4b0d      	ldr	r3, [pc, #52]	@ (8011460 <I2C_IsErrorOccurred+0x1bc>)
 801142a:	400b      	ands	r3, r1
 801142c:	6053      	str	r3, [r2, #4]

    hi2c->ErrorCode |= error_code;
 801142e:	68fb      	ldr	r3, [r7, #12]
 8011430:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 8011432:	6a3b      	ldr	r3, [r7, #32]
 8011434:	431a      	orrs	r2, r3
 8011436:	68fb      	ldr	r3, [r7, #12]
 8011438:	645a      	str	r2, [r3, #68]	@ 0x44
    hi2c->State = HAL_I2C_STATE_READY;
 801143a:	68fb      	ldr	r3, [r7, #12]
 801143c:	2220      	movs	r2, #32
 801143e:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
 8011442:	68fb      	ldr	r3, [r7, #12]
 8011444:	2200      	movs	r2, #0
 8011446:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 801144a:	68fb      	ldr	r3, [r7, #12]
 801144c:	2200      	movs	r2, #0
 801144e:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
  }

  return status;
 8011452:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
}
 8011456:	4618      	mov	r0, r3
 8011458:	3728      	adds	r7, #40	@ 0x28
 801145a:	46bd      	mov	sp, r7
 801145c:	bd80      	pop	{r7, pc}
 801145e:	bf00      	nop
 8011460:	fe00e800 	.word	0xfe00e800

08011464 <I2C_TransferConfig>:
  *     @arg @ref I2C_GENERATE_START_WRITE Generate Restart for write request.
  * @retval None
  */
static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t Size, uint32_t Mode,
                               uint32_t Request)
{
 8011464:	b480      	push	{r7}
 8011466:	b087      	sub	sp, #28
 8011468:	af00      	add	r7, sp, #0
 801146a:	60f8      	str	r0, [r7, #12]
 801146c:	607b      	str	r3, [r7, #4]
 801146e:	460b      	mov	r3, r1
 8011470:	817b      	strh	r3, [r7, #10]
 8011472:	4613      	mov	r3, r2
 8011474:	727b      	strb	r3, [r7, #9]
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));

  /* Declaration of tmp to prevent undefined behavior of volatile usage */
  uint32_t tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
 8011476:	897b      	ldrh	r3, [r7, #10]
 8011478:	f3c3 0209 	ubfx	r2, r3, #0, #10
                             (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \
 801147c:	7a7b      	ldrb	r3, [r7, #9]
 801147e:	041b      	lsls	r3, r3, #16
 8011480:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
  uint32_t tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
 8011484:	431a      	orrs	r2, r3
                             (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \
 8011486:	687b      	ldr	r3, [r7, #4]
 8011488:	431a      	orrs	r2, r3
  uint32_t tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
 801148a:	6a3b      	ldr	r3, [r7, #32]
 801148c:	4313      	orrs	r3, r2
 801148e:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 8011492:	617b      	str	r3, [r7, #20]
                             (uint32_t)Mode | (uint32_t)Request) & (~0x80000000U));

  /* update CR2 register */
  MODIFY_REG(hi2c->Instance->CR2, \
 8011494:	68fb      	ldr	r3, [r7, #12]
 8011496:	681b      	ldr	r3, [r3, #0]
 8011498:	685a      	ldr	r2, [r3, #4]
 801149a:	6a3b      	ldr	r3, [r7, #32]
 801149c:	0d5b      	lsrs	r3, r3, #21
 801149e:	f403 6180 	and.w	r1, r3, #1024	@ 0x400
 80114a2:	4b08      	ldr	r3, [pc, #32]	@ (80114c4 <I2C_TransferConfig+0x60>)
 80114a4:	430b      	orrs	r3, r1
 80114a6:	43db      	mvns	r3, r3
 80114a8:	ea02 0103 	and.w	r1, r2, r3
 80114ac:	68fb      	ldr	r3, [r7, #12]
 80114ae:	681b      	ldr	r3, [r3, #0]
 80114b0:	697a      	ldr	r2, [r7, #20]
 80114b2:	430a      	orrs	r2, r1
 80114b4:	605a      	str	r2, [r3, #4]
             ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | \
               (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | \
               I2C_CR2_START | I2C_CR2_STOP)), tmp);
}
 80114b6:	bf00      	nop
 80114b8:	371c      	adds	r7, #28
 80114ba:	46bd      	mov	sp, r7
 80114bc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80114c0:	4770      	bx	lr
 80114c2:	bf00      	nop
 80114c4:	03ff63ff 	.word	0x03ff63ff

080114c8 <I2C_Disable_IRQ>:
  *                the configuration information for the specified I2C.
  * @param  InterruptRequest Value of @ref I2C_Interrupt_configuration_definition.
  * @retval None
  */
static void I2C_Disable_IRQ(I2C_HandleTypeDef *hi2c, uint16_t InterruptRequest)
{
 80114c8:	b480      	push	{r7}
 80114ca:	b085      	sub	sp, #20
 80114cc:	af00      	add	r7, sp, #0
 80114ce:	6078      	str	r0, [r7, #4]
 80114d0:	460b      	mov	r3, r1
 80114d2:	807b      	strh	r3, [r7, #2]
  uint32_t tmpisr = 0U;
 80114d4:	2300      	movs	r3, #0
 80114d6:	60fb      	str	r3, [r7, #12]

  if ((InterruptRequest & I2C_XFER_TX_IT) == I2C_XFER_TX_IT)
 80114d8:	887b      	ldrh	r3, [r7, #2]
 80114da:	f003 0301 	and.w	r3, r3, #1
 80114de:	2b00      	cmp	r3, #0
 80114e0:	d00f      	beq.n	8011502 <I2C_Disable_IRQ+0x3a>
  {
    /* Disable TC and TXI interrupts */
    tmpisr |= I2C_IT_TCI | I2C_IT_TXI;
 80114e2:	68fb      	ldr	r3, [r7, #12]
 80114e4:	f043 0342 	orr.w	r3, r3, #66	@ 0x42
 80114e8:	60fb      	str	r3, [r7, #12]

    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 80114ea:	687b      	ldr	r3, [r7, #4]
 80114ec:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 80114f0:	b2db      	uxtb	r3, r3
 80114f2:	f003 0328 	and.w	r3, r3, #40	@ 0x28
 80114f6:	2b28      	cmp	r3, #40	@ 0x28
 80114f8:	d003      	beq.n	8011502 <I2C_Disable_IRQ+0x3a>
    {
      /* Disable NACK and STOP interrupts */
      tmpisr |= I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
 80114fa:	68fb      	ldr	r3, [r7, #12]
 80114fc:	f043 03b0 	orr.w	r3, r3, #176	@ 0xb0
 8011500:	60fb      	str	r3, [r7, #12]
    }
  }

  if ((InterruptRequest & I2C_XFER_RX_IT) == I2C_XFER_RX_IT)
 8011502:	887b      	ldrh	r3, [r7, #2]
 8011504:	f003 0302 	and.w	r3, r3, #2
 8011508:	2b00      	cmp	r3, #0
 801150a:	d00f      	beq.n	801152c <I2C_Disable_IRQ+0x64>
  {
    /* Disable TC and RXI interrupts */
    tmpisr |= I2C_IT_TCI | I2C_IT_RXI;
 801150c:	68fb      	ldr	r3, [r7, #12]
 801150e:	f043 0344 	orr.w	r3, r3, #68	@ 0x44
 8011512:	60fb      	str	r3, [r7, #12]

    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8011514:	687b      	ldr	r3, [r7, #4]
 8011516:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 801151a:	b2db      	uxtb	r3, r3
 801151c:	f003 0328 	and.w	r3, r3, #40	@ 0x28
 8011520:	2b28      	cmp	r3, #40	@ 0x28
 8011522:	d003      	beq.n	801152c <I2C_Disable_IRQ+0x64>
    {
      /* Disable NACK and STOP interrupts */
      tmpisr |= I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
 8011524:	68fb      	ldr	r3, [r7, #12]
 8011526:	f043 03b0 	orr.w	r3, r3, #176	@ 0xb0
 801152a:	60fb      	str	r3, [r7, #12]
    }
  }

  if ((InterruptRequest & I2C_XFER_LISTEN_IT) == I2C_XFER_LISTEN_IT)
 801152c:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 8011530:	2b00      	cmp	r3, #0
 8011532:	da03      	bge.n	801153c <I2C_Disable_IRQ+0x74>
  {
    /* Disable ADDR, NACK and STOP interrupts */
    tmpisr |= I2C_IT_ADDRI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
 8011534:	68fb      	ldr	r3, [r7, #12]
 8011536:	f043 03b8 	orr.w	r3, r3, #184	@ 0xb8
 801153a:	60fb      	str	r3, [r7, #12]
  }

  if (InterruptRequest == I2C_XFER_ERROR_IT)
 801153c:	887b      	ldrh	r3, [r7, #2]
 801153e:	2b10      	cmp	r3, #16
 8011540:	d103      	bne.n	801154a <I2C_Disable_IRQ+0x82>
  {
    /* Enable ERR and NACK interrupts */
    tmpisr |= I2C_IT_ERRI | I2C_IT_NACKI;
 8011542:	68fb      	ldr	r3, [r7, #12]
 8011544:	f043 0390 	orr.w	r3, r3, #144	@ 0x90
 8011548:	60fb      	str	r3, [r7, #12]
  }

  if (InterruptRequest == I2C_XFER_CPLT_IT)
 801154a:	887b      	ldrh	r3, [r7, #2]
 801154c:	2b20      	cmp	r3, #32
 801154e:	d103      	bne.n	8011558 <I2C_Disable_IRQ+0x90>
  {
    /* Enable STOP interrupts */
    tmpisr |= I2C_IT_STOPI;
 8011550:	68fb      	ldr	r3, [r7, #12]
 8011552:	f043 0320 	orr.w	r3, r3, #32
 8011556:	60fb      	str	r3, [r7, #12]
  }

  if (InterruptRequest == I2C_XFER_RELOAD_IT)
 8011558:	887b      	ldrh	r3, [r7, #2]
 801155a:	2b40      	cmp	r3, #64	@ 0x40
 801155c:	d103      	bne.n	8011566 <I2C_Disable_IRQ+0x9e>
  {
    /* Enable TC interrupts */
    tmpisr |= I2C_IT_TCI;
 801155e:	68fb      	ldr	r3, [r7, #12]
 8011560:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8011564:	60fb      	str	r3, [r7, #12]
  }

  /* Disable interrupts only at the end */
  /* to avoid a breaking situation like at "t" time */
  /* all disable interrupts request are not done */
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8011566:	687b      	ldr	r3, [r7, #4]
 8011568:	681b      	ldr	r3, [r3, #0]
 801156a:	6819      	ldr	r1, [r3, #0]
 801156c:	68fb      	ldr	r3, [r7, #12]
 801156e:	43da      	mvns	r2, r3
 8011570:	687b      	ldr	r3, [r7, #4]
 8011572:	681b      	ldr	r3, [r3, #0]
 8011574:	400a      	ands	r2, r1
 8011576:	601a      	str	r2, [r3, #0]
}
 8011578:	bf00      	nop
 801157a:	3714      	adds	r7, #20
 801157c:	46bd      	mov	sp, r7
 801157e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011582:	4770      	bx	lr

08011584 <HAL_I2CEx_ConfigAnalogFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  AnalogFilter New state of the Analog filter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigAnalogFilter(I2C_HandleTypeDef *hi2c, uint32_t AnalogFilter)
{
 8011584:	b480      	push	{r7}
 8011586:	b083      	sub	sp, #12
 8011588:	af00      	add	r7, sp, #0
 801158a:	6078      	str	r0, [r7, #4]
 801158c:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
 801158e:	687b      	ldr	r3, [r7, #4]
 8011590:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 8011594:	b2db      	uxtb	r3, r3
 8011596:	2b20      	cmp	r3, #32
 8011598:	d138      	bne.n	801160c <HAL_I2CEx_ConfigAnalogFilter+0x88>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 801159a:	687b      	ldr	r3, [r7, #4]
 801159c:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
 80115a0:	2b01      	cmp	r3, #1
 80115a2:	d101      	bne.n	80115a8 <HAL_I2CEx_ConfigAnalogFilter+0x24>
 80115a4:	2302      	movs	r3, #2
 80115a6:	e032      	b.n	801160e <HAL_I2CEx_ConfigAnalogFilter+0x8a>
 80115a8:	687b      	ldr	r3, [r7, #4]
 80115aa:	2201      	movs	r2, #1
 80115ac:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    hi2c->State = HAL_I2C_STATE_BUSY;
 80115b0:	687b      	ldr	r3, [r7, #4]
 80115b2:	2224      	movs	r2, #36	@ 0x24
 80115b4:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
 80115b8:	687b      	ldr	r3, [r7, #4]
 80115ba:	681b      	ldr	r3, [r3, #0]
 80115bc:	681a      	ldr	r2, [r3, #0]
 80115be:	687b      	ldr	r3, [r7, #4]
 80115c0:	681b      	ldr	r3, [r3, #0]
 80115c2:	f022 0201 	bic.w	r2, r2, #1
 80115c6:	601a      	str	r2, [r3, #0]

    /* Reset I2Cx ANOFF bit */
    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);
 80115c8:	687b      	ldr	r3, [r7, #4]
 80115ca:	681b      	ldr	r3, [r3, #0]
 80115cc:	681a      	ldr	r2, [r3, #0]
 80115ce:	687b      	ldr	r3, [r7, #4]
 80115d0:	681b      	ldr	r3, [r3, #0]
 80115d2:	f422 5280 	bic.w	r2, r2, #4096	@ 0x1000
 80115d6:	601a      	str	r2, [r3, #0]

    /* Set analog filter bit*/
    hi2c->Instance->CR1 |= AnalogFilter;
 80115d8:	687b      	ldr	r3, [r7, #4]
 80115da:	681b      	ldr	r3, [r3, #0]
 80115dc:	6819      	ldr	r1, [r3, #0]
 80115de:	687b      	ldr	r3, [r7, #4]
 80115e0:	681b      	ldr	r3, [r3, #0]
 80115e2:	683a      	ldr	r2, [r7, #0]
 80115e4:	430a      	orrs	r2, r1
 80115e6:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
 80115e8:	687b      	ldr	r3, [r7, #4]
 80115ea:	681b      	ldr	r3, [r3, #0]
 80115ec:	681a      	ldr	r2, [r3, #0]
 80115ee:	687b      	ldr	r3, [r7, #4]
 80115f0:	681b      	ldr	r3, [r3, #0]
 80115f2:	f042 0201 	orr.w	r2, r2, #1
 80115f6:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
 80115f8:	687b      	ldr	r3, [r7, #4]
 80115fa:	2220      	movs	r2, #32
 80115fc:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8011600:	687b      	ldr	r3, [r7, #4]
 8011602:	2200      	movs	r2, #0
 8011604:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    return HAL_OK;
 8011608:	2300      	movs	r3, #0
 801160a:	e000      	b.n	801160e <HAL_I2CEx_ConfigAnalogFilter+0x8a>
  }
  else
  {
    return HAL_BUSY;
 801160c:	2302      	movs	r3, #2
  }
}
 801160e:	4618      	mov	r0, r3
 8011610:	370c      	adds	r7, #12
 8011612:	46bd      	mov	sp, r7
 8011614:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011618:	4770      	bx	lr

0801161a <HAL_I2CEx_ConfigDigitalFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  DigitalFilter Coefficient of digital noise filter between Min_Data=0x00 and Max_Data=0x0F.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigDigitalFilter(I2C_HandleTypeDef *hi2c, uint32_t DigitalFilter)
{
 801161a:	b480      	push	{r7}
 801161c:	b085      	sub	sp, #20
 801161e:	af00      	add	r7, sp, #0
 8011620:	6078      	str	r0, [r7, #4]
 8011622:	6039      	str	r1, [r7, #0]

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
 8011624:	687b      	ldr	r3, [r7, #4]
 8011626:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 801162a:	b2db      	uxtb	r3, r3
 801162c:	2b20      	cmp	r3, #32
 801162e:	d139      	bne.n	80116a4 <HAL_I2CEx_ConfigDigitalFilter+0x8a>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 8011630:	687b      	ldr	r3, [r7, #4]
 8011632:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
 8011636:	2b01      	cmp	r3, #1
 8011638:	d101      	bne.n	801163e <HAL_I2CEx_ConfigDigitalFilter+0x24>
 801163a:	2302      	movs	r3, #2
 801163c:	e033      	b.n	80116a6 <HAL_I2CEx_ConfigDigitalFilter+0x8c>
 801163e:	687b      	ldr	r3, [r7, #4]
 8011640:	2201      	movs	r2, #1
 8011642:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    hi2c->State = HAL_I2C_STATE_BUSY;
 8011646:	687b      	ldr	r3, [r7, #4]
 8011648:	2224      	movs	r2, #36	@ 0x24
 801164a:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
 801164e:	687b      	ldr	r3, [r7, #4]
 8011650:	681b      	ldr	r3, [r3, #0]
 8011652:	681a      	ldr	r2, [r3, #0]
 8011654:	687b      	ldr	r3, [r7, #4]
 8011656:	681b      	ldr	r3, [r3, #0]
 8011658:	f022 0201 	bic.w	r2, r2, #1
 801165c:	601a      	str	r2, [r3, #0]

    /* Get the old register value */
    tmpreg = hi2c->Instance->CR1;
 801165e:	687b      	ldr	r3, [r7, #4]
 8011660:	681b      	ldr	r3, [r3, #0]
 8011662:	681b      	ldr	r3, [r3, #0]
 8011664:	60fb      	str	r3, [r7, #12]

    /* Reset I2Cx DNF bits [11:8] */
    tmpreg &= ~(I2C_CR1_DNF);
 8011666:	68fb      	ldr	r3, [r7, #12]
 8011668:	f423 6370 	bic.w	r3, r3, #3840	@ 0xf00
 801166c:	60fb      	str	r3, [r7, #12]

    /* Set I2Cx DNF coefficient */
    tmpreg |= DigitalFilter << 8U;
 801166e:	683b      	ldr	r3, [r7, #0]
 8011670:	021b      	lsls	r3, r3, #8
 8011672:	68fa      	ldr	r2, [r7, #12]
 8011674:	4313      	orrs	r3, r2
 8011676:	60fb      	str	r3, [r7, #12]

    /* Store the new register value */
    hi2c->Instance->CR1 = tmpreg;
 8011678:	687b      	ldr	r3, [r7, #4]
 801167a:	681b      	ldr	r3, [r3, #0]
 801167c:	68fa      	ldr	r2, [r7, #12]
 801167e:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
 8011680:	687b      	ldr	r3, [r7, #4]
 8011682:	681b      	ldr	r3, [r3, #0]
 8011684:	681a      	ldr	r2, [r3, #0]
 8011686:	687b      	ldr	r3, [r7, #4]
 8011688:	681b      	ldr	r3, [r3, #0]
 801168a:	f042 0201 	orr.w	r2, r2, #1
 801168e:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
 8011690:	687b      	ldr	r3, [r7, #4]
 8011692:	2220      	movs	r2, #32
 8011694:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8011698:	687b      	ldr	r3, [r7, #4]
 801169a:	2200      	movs	r2, #0
 801169c:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    return HAL_OK;
 80116a0:	2300      	movs	r3, #0
 80116a2:	e000      	b.n	80116a6 <HAL_I2CEx_ConfigDigitalFilter+0x8c>
  }
  else
  {
    return HAL_BUSY;
 80116a4:	2302      	movs	r3, #2
  }
}
 80116a6:	4618      	mov	r0, r3
 80116a8:	3714      	adds	r7, #20
 80116aa:	46bd      	mov	sp, r7
 80116ac:	f85d 7b04 	ldr.w	r7, [sp], #4
 80116b0:	4770      	bx	lr
	...

080116b4 <HAL_ICACHE_ConfigAssociativityMode>:
  *            @arg ICACHE_1WAY   1-way cache (direct mapped cache)
  *            @arg ICACHE_2WAYS  2-ways set associative cache (default)
  * @retval HAL status (HAL_OK/HAL_ERROR)
  */
HAL_StatusTypeDef HAL_ICACHE_ConfigAssociativityMode(uint32_t AssociativityMode)
{
 80116b4:	b480      	push	{r7}
 80116b6:	b085      	sub	sp, #20
 80116b8:	af00      	add	r7, sp, #0
 80116ba:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 80116bc:	2300      	movs	r3, #0
 80116be:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_ICACHE_ASSOCIATIVITY_MODE(AssociativityMode));

  /* Check cache is not enabled */
  if (READ_BIT(ICACHE->CR, ICACHE_CR_EN) != 0U)
 80116c0:	4b0b      	ldr	r3, [pc, #44]	@ (80116f0 <HAL_ICACHE_ConfigAssociativityMode+0x3c>)
 80116c2:	681b      	ldr	r3, [r3, #0]
 80116c4:	f003 0301 	and.w	r3, r3, #1
 80116c8:	2b00      	cmp	r3, #0
 80116ca:	d002      	beq.n	80116d2 <HAL_ICACHE_ConfigAssociativityMode+0x1e>
  {
    status = HAL_ERROR;
 80116cc:	2301      	movs	r3, #1
 80116ce:	73fb      	strb	r3, [r7, #15]
 80116d0:	e007      	b.n	80116e2 <HAL_ICACHE_ConfigAssociativityMode+0x2e>
  }
  else
  {
    MODIFY_REG(ICACHE->CR, ICACHE_CR_WAYSEL, AssociativityMode);
 80116d2:	4b07      	ldr	r3, [pc, #28]	@ (80116f0 <HAL_ICACHE_ConfigAssociativityMode+0x3c>)
 80116d4:	681b      	ldr	r3, [r3, #0]
 80116d6:	f023 0204 	bic.w	r2, r3, #4
 80116da:	4905      	ldr	r1, [pc, #20]	@ (80116f0 <HAL_ICACHE_ConfigAssociativityMode+0x3c>)
 80116dc:	687b      	ldr	r3, [r7, #4]
 80116de:	4313      	orrs	r3, r2
 80116e0:	600b      	str	r3, [r1, #0]
  }

  return status;
 80116e2:	7bfb      	ldrb	r3, [r7, #15]
}
 80116e4:	4618      	mov	r0, r3
 80116e6:	3714      	adds	r7, #20
 80116e8:	46bd      	mov	sp, r7
 80116ea:	f85d 7b04 	ldr.w	r7, [sp], #4
 80116ee:	4770      	bx	lr
 80116f0:	40030400 	.word	0x40030400

080116f4 <HAL_ICACHE_Enable>:
  *         cache operation. The Instruction Cache is bypassed until the
  *         cache operation completes.
  * @retval HAL status (HAL_OK)
  */
HAL_StatusTypeDef HAL_ICACHE_Enable(void)
{
 80116f4:	b480      	push	{r7}
 80116f6:	af00      	add	r7, sp, #0
  SET_BIT(ICACHE->CR, ICACHE_CR_EN);
 80116f8:	4b05      	ldr	r3, [pc, #20]	@ (8011710 <HAL_ICACHE_Enable+0x1c>)
 80116fa:	681b      	ldr	r3, [r3, #0]
 80116fc:	4a04      	ldr	r2, [pc, #16]	@ (8011710 <HAL_ICACHE_Enable+0x1c>)
 80116fe:	f043 0301 	orr.w	r3, r3, #1
 8011702:	6013      	str	r3, [r2, #0]

  return HAL_OK;
 8011704:	2300      	movs	r3, #0
}
 8011706:	4618      	mov	r0, r3
 8011708:	46bd      	mov	sp, r7
 801170a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801170e:	4770      	bx	lr
 8011710:	40030400 	.word	0x40030400

08011714 <HAL_ICACHE_Disable>:
  * @note   This function waits for the cache being disabled but
  *         not for the end of the automatic cache invalidation procedure.
  * @retval HAL status (HAL_OK/HAL_TIMEOUT)
  */
HAL_StatusTypeDef HAL_ICACHE_Disable(void)
{
 8011714:	b580      	push	{r7, lr}
 8011716:	b082      	sub	sp, #8
 8011718:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef status = HAL_OK;
 801171a:	2300      	movs	r3, #0
 801171c:	71fb      	strb	r3, [r7, #7]
  uint32_t tickstart;

  /* Make sure BSYENDF is reset before to disable the instruction cache */
  /* as it automatically starts a cache invalidation procedure */
  WRITE_REG(ICACHE->FCR, ICACHE_FCR_CBSYENDF);
 801171e:	4b14      	ldr	r3, [pc, #80]	@ (8011770 <HAL_ICACHE_Disable+0x5c>)
 8011720:	2202      	movs	r2, #2
 8011722:	60da      	str	r2, [r3, #12]

  CLEAR_BIT(ICACHE->CR, ICACHE_CR_EN);
 8011724:	4b12      	ldr	r3, [pc, #72]	@ (8011770 <HAL_ICACHE_Disable+0x5c>)
 8011726:	681b      	ldr	r3, [r3, #0]
 8011728:	4a11      	ldr	r2, [pc, #68]	@ (8011770 <HAL_ICACHE_Disable+0x5c>)
 801172a:	f023 0301 	bic.w	r3, r3, #1
 801172e:	6013      	str	r3, [r2, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
 8011730:	f7fc f996 	bl	800da60 <HAL_GetTick>
 8011734:	6038      	str	r0, [r7, #0]

  /* Wait for instruction cache being disabled */
  while (READ_BIT(ICACHE->CR, ICACHE_CR_EN) != 0U)
 8011736:	e00f      	b.n	8011758 <HAL_ICACHE_Disable+0x44>
  {
    if ((HAL_GetTick() - tickstart) > ICACHE_DISABLE_TIMEOUT_VALUE)
 8011738:	f7fc f992 	bl	800da60 <HAL_GetTick>
 801173c:	4602      	mov	r2, r0
 801173e:	683b      	ldr	r3, [r7, #0]
 8011740:	1ad3      	subs	r3, r2, r3
 8011742:	2b01      	cmp	r3, #1
 8011744:	d908      	bls.n	8011758 <HAL_ICACHE_Disable+0x44>
    {
      /* New check to avoid false timeout detection in case of preemption */
      if (READ_BIT(ICACHE->CR, ICACHE_CR_EN) != 0U)
 8011746:	4b0a      	ldr	r3, [pc, #40]	@ (8011770 <HAL_ICACHE_Disable+0x5c>)
 8011748:	681b      	ldr	r3, [r3, #0]
 801174a:	f003 0301 	and.w	r3, r3, #1
 801174e:	2b00      	cmp	r3, #0
 8011750:	d002      	beq.n	8011758 <HAL_ICACHE_Disable+0x44>
      {
        status = HAL_TIMEOUT;
 8011752:	2303      	movs	r3, #3
 8011754:	71fb      	strb	r3, [r7, #7]
        break;
 8011756:	e005      	b.n	8011764 <HAL_ICACHE_Disable+0x50>
  while (READ_BIT(ICACHE->CR, ICACHE_CR_EN) != 0U)
 8011758:	4b05      	ldr	r3, [pc, #20]	@ (8011770 <HAL_ICACHE_Disable+0x5c>)
 801175a:	681b      	ldr	r3, [r3, #0]
 801175c:	f003 0301 	and.w	r3, r3, #1
 8011760:	2b00      	cmp	r3, #0
 8011762:	d1e9      	bne.n	8011738 <HAL_ICACHE_Disable+0x24>
      }
    }
  }

  return status;
 8011764:	79fb      	ldrb	r3, [r7, #7]
}
 8011766:	4618      	mov	r0, r3
 8011768:	3708      	adds	r7, #8
 801176a:	46bd      	mov	sp, r7
 801176c:	bd80      	pop	{r7, pc}
 801176e:	bf00      	nop
 8011770:	40030400 	.word	0x40030400

08011774 <HAL_PWREx_ControlVoltageScaling>:
  * @note  Before moving to voltage scaling 4, it is mandatory to ensure that
  *        the system frequency is below 24 MHz.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_PWREx_ControlVoltageScaling(uint32_t VoltageScaling)
{
 8011774:	b480      	push	{r7}
 8011776:	b085      	sub	sp, #20
 8011778:	af00      	add	r7, sp, #0
 801177a:	6078      	str	r0, [r7, #4]

  /* Check the parameter */
  assert_param(IS_PWR_VOLTAGE_SCALING_RANGE(VoltageScaling));

  /* Get the current voltage scale applied */
  vos_old = READ_BIT(PWR->SVMSR, PWR_SVMSR_ACTVOS);
 801177c:	4b39      	ldr	r3, [pc, #228]	@ (8011864 <HAL_PWREx_ControlVoltageScaling+0xf0>)
 801177e:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8011780:	f403 3340 	and.w	r3, r3, #196608	@ 0x30000
 8011784:	60bb      	str	r3, [r7, #8]

  /* No change, nothing to do */
  if (vos_old == VoltageScaling)
 8011786:	68ba      	ldr	r2, [r7, #8]
 8011788:	687b      	ldr	r3, [r7, #4]
 801178a:	429a      	cmp	r2, r3
 801178c:	d10b      	bne.n	80117a6 <HAL_PWREx_ControlVoltageScaling+0x32>
  {
    /* Enable USB BOOST after wake up from Stop mode */
    if (VoltageScaling > PWR_REGULATOR_VOLTAGE_SCALE3)
 801178e:	687b      	ldr	r3, [r7, #4]
 8011790:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 8011794:	d905      	bls.n	80117a2 <HAL_PWREx_ControlVoltageScaling+0x2e>
    {
      /* Enable USB BOOST */
      SET_BIT(PWR->VOSR, PWR_VOSR_BOOSTEN);
 8011796:	4b33      	ldr	r3, [pc, #204]	@ (8011864 <HAL_PWREx_ControlVoltageScaling+0xf0>)
 8011798:	68db      	ldr	r3, [r3, #12]
 801179a:	4a32      	ldr	r2, [pc, #200]	@ (8011864 <HAL_PWREx_ControlVoltageScaling+0xf0>)
 801179c:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
 80117a0:	60d3      	str	r3, [r2, #12]
    }

    return HAL_OK;
 80117a2:	2300      	movs	r3, #0
 80117a4:	e057      	b.n	8011856 <HAL_PWREx_ControlVoltageScaling+0xe2>
  /* Check voltage scaling level */
  /*
   *  The Embedded power distribution (EPOD) must be enabled before switching to
   *  voltage scale 1 / 2 from voltage scale lower.
   */
  if (VoltageScaling > PWR_REGULATOR_VOLTAGE_SCALE3)
 80117a6:	687b      	ldr	r3, [r7, #4]
 80117a8:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 80117ac:	d90a      	bls.n	80117c4 <HAL_PWREx_ControlVoltageScaling+0x50>
  {
    MODIFY_REG(PWR->VOSR, (PWR_VOSR_VOS | PWR_VOSR_BOOSTEN), (VoltageScaling | PWR_VOSR_BOOSTEN));
 80117ae:	4b2d      	ldr	r3, [pc, #180]	@ (8011864 <HAL_PWREx_ControlVoltageScaling+0xf0>)
 80117b0:	68db      	ldr	r3, [r3, #12]
 80117b2:	f423 22e0 	bic.w	r2, r3, #458752	@ 0x70000
 80117b6:	687b      	ldr	r3, [r7, #4]
 80117b8:	4313      	orrs	r3, r2
 80117ba:	4a2a      	ldr	r2, [pc, #168]	@ (8011864 <HAL_PWREx_ControlVoltageScaling+0xf0>)
 80117bc:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
 80117c0:	60d3      	str	r3, [r2, #12]
 80117c2:	e007      	b.n	80117d4 <HAL_PWREx_ControlVoltageScaling+0x60>
  }
  else
  {
    MODIFY_REG(PWR->VOSR, (PWR_VOSR_VOS | PWR_VOSR_BOOSTEN), VoltageScaling);
 80117c4:	4b27      	ldr	r3, [pc, #156]	@ (8011864 <HAL_PWREx_ControlVoltageScaling+0xf0>)
 80117c6:	68db      	ldr	r3, [r3, #12]
 80117c8:	f423 22e0 	bic.w	r2, r3, #458752	@ 0x70000
 80117cc:	4925      	ldr	r1, [pc, #148]	@ (8011864 <HAL_PWREx_ControlVoltageScaling+0xf0>)
 80117ce:	687b      	ldr	r3, [r7, #4]
 80117d0:	4313      	orrs	r3, r2
 80117d2:	60cb      	str	r3, [r1, #12]
  }

  /* Wait until VOSRDY is raised */
  timeout = ((PWR_FLAG_SETTING_DELAY * (SystemCoreClock / 1000U)) / 1000U) + 1U;
 80117d4:	4b24      	ldr	r3, [pc, #144]	@ (8011868 <HAL_PWREx_ControlVoltageScaling+0xf4>)
 80117d6:	681b      	ldr	r3, [r3, #0]
 80117d8:	4a24      	ldr	r2, [pc, #144]	@ (801186c <HAL_PWREx_ControlVoltageScaling+0xf8>)
 80117da:	fba2 2303 	umull	r2, r3, r2, r3
 80117de:	099b      	lsrs	r3, r3, #6
 80117e0:	2232      	movs	r2, #50	@ 0x32
 80117e2:	fb02 f303 	mul.w	r3, r2, r3
 80117e6:	4a21      	ldr	r2, [pc, #132]	@ (801186c <HAL_PWREx_ControlVoltageScaling+0xf8>)
 80117e8:	fba2 2303 	umull	r2, r3, r2, r3
 80117ec:	099b      	lsrs	r3, r3, #6
 80117ee:	3301      	adds	r3, #1
 80117f0:	60fb      	str	r3, [r7, #12]
  while (HAL_IS_BIT_CLR(PWR->VOSR, PWR_VOSR_VOSRDY) && (timeout != 0U))
 80117f2:	e002      	b.n	80117fa <HAL_PWREx_ControlVoltageScaling+0x86>
  {
    timeout--;
 80117f4:	68fb      	ldr	r3, [r7, #12]
 80117f6:	3b01      	subs	r3, #1
 80117f8:	60fb      	str	r3, [r7, #12]
  while (HAL_IS_BIT_CLR(PWR->VOSR, PWR_VOSR_VOSRDY) && (timeout != 0U))
 80117fa:	4b1a      	ldr	r3, [pc, #104]	@ (8011864 <HAL_PWREx_ControlVoltageScaling+0xf0>)
 80117fc:	68db      	ldr	r3, [r3, #12]
 80117fe:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 8011802:	2b00      	cmp	r3, #0
 8011804:	d102      	bne.n	801180c <HAL_PWREx_ControlVoltageScaling+0x98>
 8011806:	68fb      	ldr	r3, [r7, #12]
 8011808:	2b00      	cmp	r3, #0
 801180a:	d1f3      	bne.n	80117f4 <HAL_PWREx_ControlVoltageScaling+0x80>
  }

  /* Check time out */
  if (timeout != 0U)
 801180c:	68fb      	ldr	r3, [r7, #12]
 801180e:	2b00      	cmp	r3, #0
 8011810:	d01b      	beq.n	801184a <HAL_PWREx_ControlVoltageScaling+0xd6>
  {
    /* Wait until ACTVOSRDY is raised */
    timeout = ((PWR_FLAG_SETTING_DELAY * (SystemCoreClock / 1000U)) / 1000U) + 1U;
 8011812:	4b15      	ldr	r3, [pc, #84]	@ (8011868 <HAL_PWREx_ControlVoltageScaling+0xf4>)
 8011814:	681b      	ldr	r3, [r3, #0]
 8011816:	4a15      	ldr	r2, [pc, #84]	@ (801186c <HAL_PWREx_ControlVoltageScaling+0xf8>)
 8011818:	fba2 2303 	umull	r2, r3, r2, r3
 801181c:	099b      	lsrs	r3, r3, #6
 801181e:	2232      	movs	r2, #50	@ 0x32
 8011820:	fb02 f303 	mul.w	r3, r2, r3
 8011824:	4a11      	ldr	r2, [pc, #68]	@ (801186c <HAL_PWREx_ControlVoltageScaling+0xf8>)
 8011826:	fba2 2303 	umull	r2, r3, r2, r3
 801182a:	099b      	lsrs	r3, r3, #6
 801182c:	3301      	adds	r3, #1
 801182e:	60fb      	str	r3, [r7, #12]
    while ((HAL_IS_BIT_CLR(PWR->SVMSR, PWR_SVMSR_ACTVOSRDY)) && (timeout != 0U))
 8011830:	e002      	b.n	8011838 <HAL_PWREx_ControlVoltageScaling+0xc4>
    {
      timeout--;
 8011832:	68fb      	ldr	r3, [r7, #12]
 8011834:	3b01      	subs	r3, #1
 8011836:	60fb      	str	r3, [r7, #12]
    while ((HAL_IS_BIT_CLR(PWR->SVMSR, PWR_SVMSR_ACTVOSRDY)) && (timeout != 0U))
 8011838:	4b0a      	ldr	r3, [pc, #40]	@ (8011864 <HAL_PWREx_ControlVoltageScaling+0xf0>)
 801183a:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 801183c:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 8011840:	2b00      	cmp	r3, #0
 8011842:	d102      	bne.n	801184a <HAL_PWREx_ControlVoltageScaling+0xd6>
 8011844:	68fb      	ldr	r3, [r7, #12]
 8011846:	2b00      	cmp	r3, #0
 8011848:	d1f3      	bne.n	8011832 <HAL_PWREx_ControlVoltageScaling+0xbe>
    }
  }

  /* Check time out */
  if (timeout == 0U)
 801184a:	68fb      	ldr	r3, [r7, #12]
 801184c:	2b00      	cmp	r3, #0
 801184e:	d101      	bne.n	8011854 <HAL_PWREx_ControlVoltageScaling+0xe0>
  {
    return HAL_TIMEOUT;
 8011850:	2303      	movs	r3, #3
 8011852:	e000      	b.n	8011856 <HAL_PWREx_ControlVoltageScaling+0xe2>
  }

  return HAL_OK;
 8011854:	2300      	movs	r3, #0
}
 8011856:	4618      	mov	r0, r3
 8011858:	3714      	adds	r7, #20
 801185a:	46bd      	mov	sp, r7
 801185c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011860:	4770      	bx	lr
 8011862:	bf00      	nop
 8011864:	46020800 	.word	0x46020800
 8011868:	200001e0 	.word	0x200001e0
 801186c:	10624dd3 	.word	0x10624dd3

08011870 <HAL_PWREx_GetVoltageRange>:
/**
  * @brief  Return Voltage Scaling Range.
  * @retval Applied voltage scaling value.
  */
uint32_t HAL_PWREx_GetVoltageRange(void)
{
 8011870:	b480      	push	{r7}
 8011872:	af00      	add	r7, sp, #0
  return (PWR->SVMSR & PWR_SVMSR_ACTVOS);
 8011874:	4b04      	ldr	r3, [pc, #16]	@ (8011888 <HAL_PWREx_GetVoltageRange+0x18>)
 8011876:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8011878:	f403 3340 	and.w	r3, r3, #196608	@ 0x30000
}
 801187c:	4618      	mov	r0, r3
 801187e:	46bd      	mov	sp, r7
 8011880:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011884:	4770      	bx	lr
 8011886:	bf00      	nop
 8011888:	46020800 	.word	0x46020800

0801188c <HAL_PWREx_ConfigSupply>:
  *                        @arg PWR_LDO_SUPPLY  : The LDO regulator supplies the Vcore Power Domains.
  *                        @arg PWR_SMPS_SUPPLY : The SMPS regulator supplies the Vcore Power Domains.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_PWREx_ConfigSupply(uint32_t SupplySource)
{
 801188c:	b480      	push	{r7}
 801188e:	b085      	sub	sp, #20
 8011890:	af00      	add	r7, sp, #0
 8011892:	6078      	str	r0, [r7, #4]

  /* Check the parameter */
  assert_param(IS_PWR_SUPPLY(SupplySource));

  /* Set maximum time out */
  timeout = ((PWR_FLAG_SETTING_DELAY * (SystemCoreClock / 1000U)) / 1000U) + 1U;
 8011894:	4b22      	ldr	r3, [pc, #136]	@ (8011920 <HAL_PWREx_ConfigSupply+0x94>)
 8011896:	681b      	ldr	r3, [r3, #0]
 8011898:	4a22      	ldr	r2, [pc, #136]	@ (8011924 <HAL_PWREx_ConfigSupply+0x98>)
 801189a:	fba2 2303 	umull	r2, r3, r2, r3
 801189e:	099b      	lsrs	r3, r3, #6
 80118a0:	2232      	movs	r2, #50	@ 0x32
 80118a2:	fb02 f303 	mul.w	r3, r2, r3
 80118a6:	4a1f      	ldr	r2, [pc, #124]	@ (8011924 <HAL_PWREx_ConfigSupply+0x98>)
 80118a8:	fba2 2303 	umull	r2, r3, r2, r3
 80118ac:	099b      	lsrs	r3, r3, #6
 80118ae:	3301      	adds	r3, #1
 80118b0:	60fb      	str	r3, [r7, #12]

  /* Configure the LDO as system regulator supply */
  if (SupplySource == PWR_LDO_SUPPLY)
 80118b2:	687b      	ldr	r3, [r7, #4]
 80118b4:	2b00      	cmp	r3, #0
 80118b6:	d113      	bne.n	80118e0 <HAL_PWREx_ConfigSupply+0x54>
  {
    /* Set the power supply configuration */
    CLEAR_BIT(PWR->CR3, PWR_CR3_REGSEL);
 80118b8:	4b1b      	ldr	r3, [pc, #108]	@ (8011928 <HAL_PWREx_ConfigSupply+0x9c>)
 80118ba:	689b      	ldr	r3, [r3, #8]
 80118bc:	4a1a      	ldr	r2, [pc, #104]	@ (8011928 <HAL_PWREx_ConfigSupply+0x9c>)
 80118be:	f023 0302 	bic.w	r3, r3, #2
 80118c2:	6093      	str	r3, [r2, #8]

    /* Wait until system switch on new regulator */
    while (HAL_IS_BIT_SET(PWR->SVMSR, PWR_SVMSR_REGS) && (timeout != 0U))
 80118c4:	e002      	b.n	80118cc <HAL_PWREx_ConfigSupply+0x40>
    {
      timeout--;
 80118c6:	68fb      	ldr	r3, [r7, #12]
 80118c8:	3b01      	subs	r3, #1
 80118ca:	60fb      	str	r3, [r7, #12]
    while (HAL_IS_BIT_SET(PWR->SVMSR, PWR_SVMSR_REGS) && (timeout != 0U))
 80118cc:	4b16      	ldr	r3, [pc, #88]	@ (8011928 <HAL_PWREx_ConfigSupply+0x9c>)
 80118ce:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80118d0:	f003 0302 	and.w	r3, r3, #2
 80118d4:	2b02      	cmp	r3, #2
 80118d6:	d116      	bne.n	8011906 <HAL_PWREx_ConfigSupply+0x7a>
 80118d8:	68fb      	ldr	r3, [r7, #12]
 80118da:	2b00      	cmp	r3, #0
 80118dc:	d1f3      	bne.n	80118c6 <HAL_PWREx_ConfigSupply+0x3a>
 80118de:	e012      	b.n	8011906 <HAL_PWREx_ConfigSupply+0x7a>
  }
  /* Configure the SMPS as system regulator supply */
  else
  {
    /* Set the power supply configuration */
    SET_BIT(PWR->CR3, PWR_CR3_REGSEL);
 80118e0:	4b11      	ldr	r3, [pc, #68]	@ (8011928 <HAL_PWREx_ConfigSupply+0x9c>)
 80118e2:	689b      	ldr	r3, [r3, #8]
 80118e4:	4a10      	ldr	r2, [pc, #64]	@ (8011928 <HAL_PWREx_ConfigSupply+0x9c>)
 80118e6:	f043 0302 	orr.w	r3, r3, #2
 80118ea:	6093      	str	r3, [r2, #8]

    /* Wait until system switch on new regulator */
    while (HAL_IS_BIT_CLR(PWR->SVMSR, PWR_SVMSR_REGS) && (timeout != 0U))
 80118ec:	e002      	b.n	80118f4 <HAL_PWREx_ConfigSupply+0x68>
    {
      timeout--;
 80118ee:	68fb      	ldr	r3, [r7, #12]
 80118f0:	3b01      	subs	r3, #1
 80118f2:	60fb      	str	r3, [r7, #12]
    while (HAL_IS_BIT_CLR(PWR->SVMSR, PWR_SVMSR_REGS) && (timeout != 0U))
 80118f4:	4b0c      	ldr	r3, [pc, #48]	@ (8011928 <HAL_PWREx_ConfigSupply+0x9c>)
 80118f6:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80118f8:	f003 0302 	and.w	r3, r3, #2
 80118fc:	2b00      	cmp	r3, #0
 80118fe:	d102      	bne.n	8011906 <HAL_PWREx_ConfigSupply+0x7a>
 8011900:	68fb      	ldr	r3, [r7, #12]
 8011902:	2b00      	cmp	r3, #0
 8011904:	d1f3      	bne.n	80118ee <HAL_PWREx_ConfigSupply+0x62>
    }
  }

  /* Check time out */
  if (timeout == 0U)
 8011906:	68fb      	ldr	r3, [r7, #12]
 8011908:	2b00      	cmp	r3, #0
 801190a:	d101      	bne.n	8011910 <HAL_PWREx_ConfigSupply+0x84>
  {
    return HAL_TIMEOUT;
 801190c:	2303      	movs	r3, #3
 801190e:	e000      	b.n	8011912 <HAL_PWREx_ConfigSupply+0x86>
  }

  return HAL_OK;
 8011910:	2300      	movs	r3, #0
}
 8011912:	4618      	mov	r0, r3
 8011914:	3714      	adds	r7, #20
 8011916:	46bd      	mov	sp, r7
 8011918:	f85d 7b04 	ldr.w	r7, [sp], #4
 801191c:	4770      	bx	lr
 801191e:	bf00      	nop
 8011920:	200001e0 	.word	0x200001e0
 8011924:	10624dd3 	.word	0x10624dd3
 8011928:	46020800 	.word	0x46020800

0801192c <HAL_PWREx_EnableVddIO2>:
  * @note   Remove VDDIO2 electrical and logical isolation, once VDDIO2 supply
  *         is present for consumption saving.
  * @retval None.
  */
void HAL_PWREx_EnableVddIO2(void)
{
 801192c:	b480      	push	{r7}
 801192e:	af00      	add	r7, sp, #0
  SET_BIT(PWR->SVMCR, PWR_SVMCR_IO2SV);
 8011930:	4b05      	ldr	r3, [pc, #20]	@ (8011948 <HAL_PWREx_EnableVddIO2+0x1c>)
 8011932:	691b      	ldr	r3, [r3, #16]
 8011934:	4a04      	ldr	r2, [pc, #16]	@ (8011948 <HAL_PWREx_EnableVddIO2+0x1c>)
 8011936:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
 801193a:	6113      	str	r3, [r2, #16]
}
 801193c:	bf00      	nop
 801193e:	46bd      	mov	sp, r7
 8011940:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011944:	4770      	bx	lr
 8011946:	bf00      	nop
 8011948:	46020800 	.word	0x46020800

0801194c <HAL_PWREx_DisableUCPDDeadBattery>:
  *         pull-down or to handover control to the UCPD (the UCPD must be
  *         initialized before doing the disable).
  * @retval None.
  */
void HAL_PWREx_DisableUCPDDeadBattery(void)
{
 801194c:	b480      	push	{r7}
 801194e:	af00      	add	r7, sp, #0
  SET_BIT(PWR->UCPDR, PWR_UCPDR_UCPD_DBDIS);
 8011950:	4b05      	ldr	r3, [pc, #20]	@ (8011968 <HAL_PWREx_DisableUCPDDeadBattery+0x1c>)
 8011952:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8011954:	4a04      	ldr	r2, [pc, #16]	@ (8011968 <HAL_PWREx_DisableUCPDDeadBattery+0x1c>)
 8011956:	f043 0301 	orr.w	r3, r3, #1
 801195a:	62d3      	str	r3, [r2, #44]	@ 0x2c
}
 801195c:	bf00      	nop
 801195e:	46bd      	mov	sp, r7
 8011960:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011964:	4770      	bx	lr
 8011966:	bf00      	nop
 8011968:	46020800 	.word	0x46020800

0801196c <HAL_RCC_OscConfig>:
  *         supported by this function. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(const RCC_OscInitTypeDef  *pRCC_OscInitStruct)
{
 801196c:	b580      	push	{r7, lr}
 801196e:	b08e      	sub	sp, #56	@ 0x38
 8011970:	af00      	add	r7, sp, #0
 8011972:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  HAL_StatusTypeDef status;
  uint32_t sysclk_source;
  uint32_t pll_config;
  FlagStatus pwrboosten = RESET;
 8011974:	2300      	movs	r3, #0
 8011976:	f887 3037 	strb.w	r3, [r7, #55]	@ 0x37
  uint32_t temp1_pllckcfg;
  uint32_t temp2_pllckcfg;

  /* Check Null pointer */
  if (pRCC_OscInitStruct == NULL)
 801197a:	687b      	ldr	r3, [r7, #4]
 801197c:	2b00      	cmp	r3, #0
 801197e:	d102      	bne.n	8011986 <HAL_RCC_OscConfig+0x1a>
  {
    return HAL_ERROR;
 8011980:	2301      	movs	r3, #1
 8011982:	f000 bec8 	b.w	8012716 <HAL_RCC_OscConfig+0xdaa>
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(pRCC_OscInitStruct->OscillatorType));

  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 8011986:	4b99      	ldr	r3, [pc, #612]	@ (8011bec <HAL_RCC_OscConfig+0x280>)
 8011988:	69db      	ldr	r3, [r3, #28]
 801198a:	f003 030c 	and.w	r3, r3, #12
 801198e:	633b      	str	r3, [r7, #48]	@ 0x30
  pll_config = __HAL_RCC_GET_PLL_OSCSOURCE();
 8011990:	4b96      	ldr	r3, [pc, #600]	@ (8011bec <HAL_RCC_OscConfig+0x280>)
 8011992:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8011994:	f003 0303 	and.w	r3, r3, #3
 8011998:	62fb      	str	r3, [r7, #44]	@ 0x2c

  /*----------------------------- MSI Configuration --------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 801199a:	687b      	ldr	r3, [r7, #4]
 801199c:	681b      	ldr	r3, [r3, #0]
 801199e:	f003 0310 	and.w	r3, r3, #16
 80119a2:	2b00      	cmp	r3, #0
 80119a4:	f000 816c 	beq.w	8011c80 <HAL_RCC_OscConfig+0x314>
    assert_param(IS_RCC_MSICALIBRATION_VALUE(pRCC_OscInitStruct->MSICalibrationValue));
    assert_param(IS_RCC_MSI_CLOCK_RANGE(pRCC_OscInitStruct->MSIClockRange));

    /*Check if MSI is used as system clock or as PLL source when PLL is selected as system clock*/

    if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI) ||
 80119a8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80119aa:	2b00      	cmp	r3, #0
 80119ac:	d007      	beq.n	80119be <HAL_RCC_OscConfig+0x52>
 80119ae:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80119b0:	2b0c      	cmp	r3, #12
 80119b2:	f040 80de 	bne.w	8011b72 <HAL_RCC_OscConfig+0x206>
        ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_MSI)))
 80119b6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80119b8:	2b01      	cmp	r3, #1
 80119ba:	f040 80da 	bne.w	8011b72 <HAL_RCC_OscConfig+0x206>
    {
      if (pRCC_OscInitStruct->MSIState == RCC_MSI_OFF)
 80119be:	687b      	ldr	r3, [r7, #4]
 80119c0:	69db      	ldr	r3, [r3, #28]
 80119c2:	2b00      	cmp	r3, #0
 80119c4:	d102      	bne.n	80119cc <HAL_RCC_OscConfig+0x60>
      {
        return HAL_ERROR;
 80119c6:	2301      	movs	r3, #1
 80119c8:	f000 bea5 	b.w	8012716 <HAL_RCC_OscConfig+0xdaa>
      else
      {
        /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
           must be correctly programmed according to the frequency of the CPU clock
           (HCLK) and the supply voltage of the device */
        if (pRCC_OscInitStruct->MSIClockRange > __HAL_RCC_GET_MSI_RANGE())
 80119cc:	687b      	ldr	r3, [r7, #4]
 80119ce:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 80119d0:	4b86      	ldr	r3, [pc, #536]	@ (8011bec <HAL_RCC_OscConfig+0x280>)
 80119d2:	689b      	ldr	r3, [r3, #8]
 80119d4:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 80119d8:	2b00      	cmp	r3, #0
 80119da:	d004      	beq.n	80119e6 <HAL_RCC_OscConfig+0x7a>
 80119dc:	4b83      	ldr	r3, [pc, #524]	@ (8011bec <HAL_RCC_OscConfig+0x280>)
 80119de:	689b      	ldr	r3, [r3, #8]
 80119e0:	f003 4370 	and.w	r3, r3, #4026531840	@ 0xf0000000
 80119e4:	e005      	b.n	80119f2 <HAL_RCC_OscConfig+0x86>
 80119e6:	4b81      	ldr	r3, [pc, #516]	@ (8011bec <HAL_RCC_OscConfig+0x280>)
 80119e8:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 80119ec:	041b      	lsls	r3, r3, #16
 80119ee:	f003 4370 	and.w	r3, r3, #4026531840	@ 0xf0000000
 80119f2:	4293      	cmp	r3, r2
 80119f4:	d255      	bcs.n	8011aa2 <HAL_RCC_OscConfig+0x136>
        {
          /* Decrease number of wait states update if necessary */
          /* Only possible when MSI is the System clock source  */
          if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI)
 80119f6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80119f8:	2b00      	cmp	r3, #0
 80119fa:	d10a      	bne.n	8011a12 <HAL_RCC_OscConfig+0xa6>
          {
            if (RCC_SetFlashLatencyFromMSIRange(pRCC_OscInitStruct->MSIClockRange) != HAL_OK)
 80119fc:	687b      	ldr	r3, [r7, #4]
 80119fe:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8011a00:	4618      	mov	r0, r3
 8011a02:	f001 f9d9 	bl	8012db8 <RCC_SetFlashLatencyFromMSIRange>
 8011a06:	4603      	mov	r3, r0
 8011a08:	2b00      	cmp	r3, #0
 8011a0a:	d002      	beq.n	8011a12 <HAL_RCC_OscConfig+0xa6>
            {
              return HAL_ERROR;
 8011a0c:	2301      	movs	r3, #1
 8011a0e:	f000 be82 	b.w	8012716 <HAL_RCC_OscConfig+0xdaa>
            }
          }

          /* Selects the Multiple Speed oscillator (MSI) clock range */
          __HAL_RCC_MSI_RANGE_CONFIG(pRCC_OscInitStruct->MSIClockRange);
 8011a12:	4b76      	ldr	r3, [pc, #472]	@ (8011bec <HAL_RCC_OscConfig+0x280>)
 8011a14:	689b      	ldr	r3, [r3, #8]
 8011a16:	4a75      	ldr	r2, [pc, #468]	@ (8011bec <HAL_RCC_OscConfig+0x280>)
 8011a18:	f443 0300 	orr.w	r3, r3, #8388608	@ 0x800000
 8011a1c:	6093      	str	r3, [r2, #8]
 8011a1e:	4b73      	ldr	r3, [pc, #460]	@ (8011bec <HAL_RCC_OscConfig+0x280>)
 8011a20:	689b      	ldr	r3, [r3, #8]
 8011a22:	f023 4270 	bic.w	r2, r3, #4026531840	@ 0xf0000000
 8011a26:	687b      	ldr	r3, [r7, #4]
 8011a28:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8011a2a:	4970      	ldr	r1, [pc, #448]	@ (8011bec <HAL_RCC_OscConfig+0x280>)
 8011a2c:	4313      	orrs	r3, r2
 8011a2e:	608b      	str	r3, [r1, #8]
          /* Adjusts the Multiple Speed oscillator (MSI) calibration value */
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST((pRCC_OscInitStruct->MSICalibrationValue), \
 8011a30:	687b      	ldr	r3, [r7, #4]
 8011a32:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8011a34:	f1b3 4f40 	cmp.w	r3, #3221225472	@ 0xc0000000
 8011a38:	d309      	bcc.n	8011a4e <HAL_RCC_OscConfig+0xe2>
 8011a3a:	4b6c      	ldr	r3, [pc, #432]	@ (8011bec <HAL_RCC_OscConfig+0x280>)
 8011a3c:	68db      	ldr	r3, [r3, #12]
 8011a3e:	f023 021f 	bic.w	r2, r3, #31
 8011a42:	687b      	ldr	r3, [r7, #4]
 8011a44:	6a1b      	ldr	r3, [r3, #32]
 8011a46:	4969      	ldr	r1, [pc, #420]	@ (8011bec <HAL_RCC_OscConfig+0x280>)
 8011a48:	4313      	orrs	r3, r2
 8011a4a:	60cb      	str	r3, [r1, #12]
 8011a4c:	e07e      	b.n	8011b4c <HAL_RCC_OscConfig+0x1e0>
 8011a4e:	687b      	ldr	r3, [r7, #4]
 8011a50:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8011a52:	2b00      	cmp	r3, #0
 8011a54:	da0a      	bge.n	8011a6c <HAL_RCC_OscConfig+0x100>
 8011a56:	4b65      	ldr	r3, [pc, #404]	@ (8011bec <HAL_RCC_OscConfig+0x280>)
 8011a58:	68db      	ldr	r3, [r3, #12]
 8011a5a:	f423 7278 	bic.w	r2, r3, #992	@ 0x3e0
 8011a5e:	687b      	ldr	r3, [r7, #4]
 8011a60:	6a1b      	ldr	r3, [r3, #32]
 8011a62:	015b      	lsls	r3, r3, #5
 8011a64:	4961      	ldr	r1, [pc, #388]	@ (8011bec <HAL_RCC_OscConfig+0x280>)
 8011a66:	4313      	orrs	r3, r2
 8011a68:	60cb      	str	r3, [r1, #12]
 8011a6a:	e06f      	b.n	8011b4c <HAL_RCC_OscConfig+0x1e0>
 8011a6c:	687b      	ldr	r3, [r7, #4]
 8011a6e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8011a70:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 8011a74:	d30a      	bcc.n	8011a8c <HAL_RCC_OscConfig+0x120>
 8011a76:	4b5d      	ldr	r3, [pc, #372]	@ (8011bec <HAL_RCC_OscConfig+0x280>)
 8011a78:	68db      	ldr	r3, [r3, #12]
 8011a7a:	f423 42f8 	bic.w	r2, r3, #31744	@ 0x7c00
 8011a7e:	687b      	ldr	r3, [r7, #4]
 8011a80:	6a1b      	ldr	r3, [r3, #32]
 8011a82:	029b      	lsls	r3, r3, #10
 8011a84:	4959      	ldr	r1, [pc, #356]	@ (8011bec <HAL_RCC_OscConfig+0x280>)
 8011a86:	4313      	orrs	r3, r2
 8011a88:	60cb      	str	r3, [r1, #12]
 8011a8a:	e05f      	b.n	8011b4c <HAL_RCC_OscConfig+0x1e0>
 8011a8c:	4b57      	ldr	r3, [pc, #348]	@ (8011bec <HAL_RCC_OscConfig+0x280>)
 8011a8e:	68db      	ldr	r3, [r3, #12]
 8011a90:	f423 2278 	bic.w	r2, r3, #1015808	@ 0xf8000
 8011a94:	687b      	ldr	r3, [r7, #4]
 8011a96:	6a1b      	ldr	r3, [r3, #32]
 8011a98:	03db      	lsls	r3, r3, #15
 8011a9a:	4954      	ldr	r1, [pc, #336]	@ (8011bec <HAL_RCC_OscConfig+0x280>)
 8011a9c:	4313      	orrs	r3, r2
 8011a9e:	60cb      	str	r3, [r1, #12]
 8011aa0:	e054      	b.n	8011b4c <HAL_RCC_OscConfig+0x1e0>
        }
        else
        {
          /* Else, keep current flash latency while decreasing applies */
          /* Selects the Multiple Speed oscillator (MSI) clock range */
          __HAL_RCC_MSI_RANGE_CONFIG(pRCC_OscInitStruct->MSIClockRange);
 8011aa2:	4b52      	ldr	r3, [pc, #328]	@ (8011bec <HAL_RCC_OscConfig+0x280>)
 8011aa4:	689b      	ldr	r3, [r3, #8]
 8011aa6:	4a51      	ldr	r2, [pc, #324]	@ (8011bec <HAL_RCC_OscConfig+0x280>)
 8011aa8:	f443 0300 	orr.w	r3, r3, #8388608	@ 0x800000
 8011aac:	6093      	str	r3, [r2, #8]
 8011aae:	4b4f      	ldr	r3, [pc, #316]	@ (8011bec <HAL_RCC_OscConfig+0x280>)
 8011ab0:	689b      	ldr	r3, [r3, #8]
 8011ab2:	f023 4270 	bic.w	r2, r3, #4026531840	@ 0xf0000000
 8011ab6:	687b      	ldr	r3, [r7, #4]
 8011ab8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8011aba:	494c      	ldr	r1, [pc, #304]	@ (8011bec <HAL_RCC_OscConfig+0x280>)
 8011abc:	4313      	orrs	r3, r2
 8011abe:	608b      	str	r3, [r1, #8]
          /* Adjusts the Multiple Speed oscillator (MSI) calibration value */
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST((pRCC_OscInitStruct->MSICalibrationValue), \
 8011ac0:	687b      	ldr	r3, [r7, #4]
 8011ac2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8011ac4:	f1b3 4f40 	cmp.w	r3, #3221225472	@ 0xc0000000
 8011ac8:	d309      	bcc.n	8011ade <HAL_RCC_OscConfig+0x172>
 8011aca:	4b48      	ldr	r3, [pc, #288]	@ (8011bec <HAL_RCC_OscConfig+0x280>)
 8011acc:	68db      	ldr	r3, [r3, #12]
 8011ace:	f023 021f 	bic.w	r2, r3, #31
 8011ad2:	687b      	ldr	r3, [r7, #4]
 8011ad4:	6a1b      	ldr	r3, [r3, #32]
 8011ad6:	4945      	ldr	r1, [pc, #276]	@ (8011bec <HAL_RCC_OscConfig+0x280>)
 8011ad8:	4313      	orrs	r3, r2
 8011ada:	60cb      	str	r3, [r1, #12]
 8011adc:	e028      	b.n	8011b30 <HAL_RCC_OscConfig+0x1c4>
 8011ade:	687b      	ldr	r3, [r7, #4]
 8011ae0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8011ae2:	2b00      	cmp	r3, #0
 8011ae4:	da0a      	bge.n	8011afc <HAL_RCC_OscConfig+0x190>
 8011ae6:	4b41      	ldr	r3, [pc, #260]	@ (8011bec <HAL_RCC_OscConfig+0x280>)
 8011ae8:	68db      	ldr	r3, [r3, #12]
 8011aea:	f423 7278 	bic.w	r2, r3, #992	@ 0x3e0
 8011aee:	687b      	ldr	r3, [r7, #4]
 8011af0:	6a1b      	ldr	r3, [r3, #32]
 8011af2:	015b      	lsls	r3, r3, #5
 8011af4:	493d      	ldr	r1, [pc, #244]	@ (8011bec <HAL_RCC_OscConfig+0x280>)
 8011af6:	4313      	orrs	r3, r2
 8011af8:	60cb      	str	r3, [r1, #12]
 8011afa:	e019      	b.n	8011b30 <HAL_RCC_OscConfig+0x1c4>
 8011afc:	687b      	ldr	r3, [r7, #4]
 8011afe:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8011b00:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 8011b04:	d30a      	bcc.n	8011b1c <HAL_RCC_OscConfig+0x1b0>
 8011b06:	4b39      	ldr	r3, [pc, #228]	@ (8011bec <HAL_RCC_OscConfig+0x280>)
 8011b08:	68db      	ldr	r3, [r3, #12]
 8011b0a:	f423 42f8 	bic.w	r2, r3, #31744	@ 0x7c00
 8011b0e:	687b      	ldr	r3, [r7, #4]
 8011b10:	6a1b      	ldr	r3, [r3, #32]
 8011b12:	029b      	lsls	r3, r3, #10
 8011b14:	4935      	ldr	r1, [pc, #212]	@ (8011bec <HAL_RCC_OscConfig+0x280>)
 8011b16:	4313      	orrs	r3, r2
 8011b18:	60cb      	str	r3, [r1, #12]
 8011b1a:	e009      	b.n	8011b30 <HAL_RCC_OscConfig+0x1c4>
 8011b1c:	4b33      	ldr	r3, [pc, #204]	@ (8011bec <HAL_RCC_OscConfig+0x280>)
 8011b1e:	68db      	ldr	r3, [r3, #12]
 8011b20:	f423 2278 	bic.w	r2, r3, #1015808	@ 0xf8000
 8011b24:	687b      	ldr	r3, [r7, #4]
 8011b26:	6a1b      	ldr	r3, [r3, #32]
 8011b28:	03db      	lsls	r3, r3, #15
 8011b2a:	4930      	ldr	r1, [pc, #192]	@ (8011bec <HAL_RCC_OscConfig+0x280>)
 8011b2c:	4313      	orrs	r3, r2
 8011b2e:	60cb      	str	r3, [r1, #12]
                                                (pRCC_OscInitStruct->MSIClockRange));

          if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI)
 8011b30:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011b32:	2b00      	cmp	r3, #0
 8011b34:	d10a      	bne.n	8011b4c <HAL_RCC_OscConfig+0x1e0>
          {
            if (RCC_SetFlashLatencyFromMSIRange(pRCC_OscInitStruct->MSIClockRange) != HAL_OK)
 8011b36:	687b      	ldr	r3, [r7, #4]
 8011b38:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8011b3a:	4618      	mov	r0, r3
 8011b3c:	f001 f93c 	bl	8012db8 <RCC_SetFlashLatencyFromMSIRange>
 8011b40:	4603      	mov	r3, r0
 8011b42:	2b00      	cmp	r3, #0
 8011b44:	d002      	beq.n	8011b4c <HAL_RCC_OscConfig+0x1e0>
            {
              return HAL_ERROR;
 8011b46:	2301      	movs	r3, #1
 8011b48:	f000 bde5 	b.w	8012716 <HAL_RCC_OscConfig+0xdaa>
            }
          }
        }

        /* Update the SystemCoreClock global variable */
        (void) HAL_RCC_GetHCLKFreq();
 8011b4c:	f001 f8de 	bl	8012d0c <HAL_RCC_GetHCLKFreq>
        /* Configure the source of time base considering new system clocks settings*/
        status = HAL_InitTick(uwTickPrio);
 8011b50:	4b27      	ldr	r3, [pc, #156]	@ (8011bf0 <HAL_RCC_OscConfig+0x284>)
 8011b52:	681b      	ldr	r3, [r3, #0]
 8011b54:	4618      	mov	r0, r3
 8011b56:	f7fb fef9 	bl	800d94c <HAL_InitTick>
 8011b5a:	4603      	mov	r3, r0
 8011b5c:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
        if (status != HAL_OK)
 8011b60:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 8011b64:	2b00      	cmp	r3, #0
 8011b66:	f000 808a 	beq.w	8011c7e <HAL_RCC_OscConfig+0x312>
        {
          return status;
 8011b6a:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 8011b6e:	f000 bdd2 	b.w	8012716 <HAL_RCC_OscConfig+0xdaa>
      }
    }
    else
    {
      /* Check the MSI State */
      if (pRCC_OscInitStruct->MSIState != RCC_MSI_OFF)
 8011b72:	687b      	ldr	r3, [r7, #4]
 8011b74:	69db      	ldr	r3, [r3, #28]
 8011b76:	2b00      	cmp	r3, #0
 8011b78:	d066      	beq.n	8011c48 <HAL_RCC_OscConfig+0x2dc>
      {
        /* Enable the Internal High Speed oscillator (MSI) */
        __HAL_RCC_MSI_ENABLE();
 8011b7a:	4b1c      	ldr	r3, [pc, #112]	@ (8011bec <HAL_RCC_OscConfig+0x280>)
 8011b7c:	681b      	ldr	r3, [r3, #0]
 8011b7e:	4a1b      	ldr	r2, [pc, #108]	@ (8011bec <HAL_RCC_OscConfig+0x280>)
 8011b80:	f043 0301 	orr.w	r3, r3, #1
 8011b84:	6013      	str	r3, [r2, #0]

        tickstart = HAL_GetTick();
 8011b86:	f7fb ff6b 	bl	800da60 <HAL_GetTick>
 8011b8a:	62b8      	str	r0, [r7, #40]	@ 0x28

        /* Wait till MSI is ready */
        while (READ_BIT(RCC->CR, RCC_CR_MSISRDY) == 0U)
 8011b8c:	e009      	b.n	8011ba2 <HAL_RCC_OscConfig+0x236>
        {
          if ((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 8011b8e:	f7fb ff67 	bl	800da60 <HAL_GetTick>
 8011b92:	4602      	mov	r2, r0
 8011b94:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011b96:	1ad3      	subs	r3, r2, r3
 8011b98:	2b02      	cmp	r3, #2
 8011b9a:	d902      	bls.n	8011ba2 <HAL_RCC_OscConfig+0x236>
          {
            return HAL_TIMEOUT;
 8011b9c:	2303      	movs	r3, #3
 8011b9e:	f000 bdba 	b.w	8012716 <HAL_RCC_OscConfig+0xdaa>
        while (READ_BIT(RCC->CR, RCC_CR_MSISRDY) == 0U)
 8011ba2:	4b12      	ldr	r3, [pc, #72]	@ (8011bec <HAL_RCC_OscConfig+0x280>)
 8011ba4:	681b      	ldr	r3, [r3, #0]
 8011ba6:	f003 0304 	and.w	r3, r3, #4
 8011baa:	2b00      	cmp	r3, #0
 8011bac:	d0ef      	beq.n	8011b8e <HAL_RCC_OscConfig+0x222>
          }
        }
        /* Selects the Multiple Speed oscillator (MSI) clock range */
        __HAL_RCC_MSI_RANGE_CONFIG(pRCC_OscInitStruct->MSIClockRange);
 8011bae:	4b0f      	ldr	r3, [pc, #60]	@ (8011bec <HAL_RCC_OscConfig+0x280>)
 8011bb0:	689b      	ldr	r3, [r3, #8]
 8011bb2:	4a0e      	ldr	r2, [pc, #56]	@ (8011bec <HAL_RCC_OscConfig+0x280>)
 8011bb4:	f443 0300 	orr.w	r3, r3, #8388608	@ 0x800000
 8011bb8:	6093      	str	r3, [r2, #8]
 8011bba:	4b0c      	ldr	r3, [pc, #48]	@ (8011bec <HAL_RCC_OscConfig+0x280>)
 8011bbc:	689b      	ldr	r3, [r3, #8]
 8011bbe:	f023 4270 	bic.w	r2, r3, #4026531840	@ 0xf0000000
 8011bc2:	687b      	ldr	r3, [r7, #4]
 8011bc4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8011bc6:	4909      	ldr	r1, [pc, #36]	@ (8011bec <HAL_RCC_OscConfig+0x280>)
 8011bc8:	4313      	orrs	r3, r2
 8011bca:	608b      	str	r3, [r1, #8]
        /* Adjusts the Multiple Speed oscillator (MSI) calibration value */
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST((pRCC_OscInitStruct->MSICalibrationValue), \
 8011bcc:	687b      	ldr	r3, [r7, #4]
 8011bce:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8011bd0:	f1b3 4f40 	cmp.w	r3, #3221225472	@ 0xc0000000
 8011bd4:	d30e      	bcc.n	8011bf4 <HAL_RCC_OscConfig+0x288>
 8011bd6:	4b05      	ldr	r3, [pc, #20]	@ (8011bec <HAL_RCC_OscConfig+0x280>)
 8011bd8:	68db      	ldr	r3, [r3, #12]
 8011bda:	f023 021f 	bic.w	r2, r3, #31
 8011bde:	687b      	ldr	r3, [r7, #4]
 8011be0:	6a1b      	ldr	r3, [r3, #32]
 8011be2:	4902      	ldr	r1, [pc, #8]	@ (8011bec <HAL_RCC_OscConfig+0x280>)
 8011be4:	4313      	orrs	r3, r2
 8011be6:	60cb      	str	r3, [r1, #12]
 8011be8:	e04a      	b.n	8011c80 <HAL_RCC_OscConfig+0x314>
 8011bea:	bf00      	nop
 8011bec:	46020c00 	.word	0x46020c00
 8011bf0:	200001e4 	.word	0x200001e4
 8011bf4:	687b      	ldr	r3, [r7, #4]
 8011bf6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8011bf8:	2b00      	cmp	r3, #0
 8011bfa:	da0a      	bge.n	8011c12 <HAL_RCC_OscConfig+0x2a6>
 8011bfc:	4b98      	ldr	r3, [pc, #608]	@ (8011e60 <HAL_RCC_OscConfig+0x4f4>)
 8011bfe:	68db      	ldr	r3, [r3, #12]
 8011c00:	f423 7278 	bic.w	r2, r3, #992	@ 0x3e0
 8011c04:	687b      	ldr	r3, [r7, #4]
 8011c06:	6a1b      	ldr	r3, [r3, #32]
 8011c08:	015b      	lsls	r3, r3, #5
 8011c0a:	4995      	ldr	r1, [pc, #596]	@ (8011e60 <HAL_RCC_OscConfig+0x4f4>)
 8011c0c:	4313      	orrs	r3, r2
 8011c0e:	60cb      	str	r3, [r1, #12]
 8011c10:	e036      	b.n	8011c80 <HAL_RCC_OscConfig+0x314>
 8011c12:	687b      	ldr	r3, [r7, #4]
 8011c14:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8011c16:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 8011c1a:	d30a      	bcc.n	8011c32 <HAL_RCC_OscConfig+0x2c6>
 8011c1c:	4b90      	ldr	r3, [pc, #576]	@ (8011e60 <HAL_RCC_OscConfig+0x4f4>)
 8011c1e:	68db      	ldr	r3, [r3, #12]
 8011c20:	f423 42f8 	bic.w	r2, r3, #31744	@ 0x7c00
 8011c24:	687b      	ldr	r3, [r7, #4]
 8011c26:	6a1b      	ldr	r3, [r3, #32]
 8011c28:	029b      	lsls	r3, r3, #10
 8011c2a:	498d      	ldr	r1, [pc, #564]	@ (8011e60 <HAL_RCC_OscConfig+0x4f4>)
 8011c2c:	4313      	orrs	r3, r2
 8011c2e:	60cb      	str	r3, [r1, #12]
 8011c30:	e026      	b.n	8011c80 <HAL_RCC_OscConfig+0x314>
 8011c32:	4b8b      	ldr	r3, [pc, #556]	@ (8011e60 <HAL_RCC_OscConfig+0x4f4>)
 8011c34:	68db      	ldr	r3, [r3, #12]
 8011c36:	f423 2278 	bic.w	r2, r3, #1015808	@ 0xf8000
 8011c3a:	687b      	ldr	r3, [r7, #4]
 8011c3c:	6a1b      	ldr	r3, [r3, #32]
 8011c3e:	03db      	lsls	r3, r3, #15
 8011c40:	4987      	ldr	r1, [pc, #540]	@ (8011e60 <HAL_RCC_OscConfig+0x4f4>)
 8011c42:	4313      	orrs	r3, r2
 8011c44:	60cb      	str	r3, [r1, #12]
 8011c46:	e01b      	b.n	8011c80 <HAL_RCC_OscConfig+0x314>

      }
      else
      {
        /* Disable the Internal High Speed oscillator (MSI) */
        __HAL_RCC_MSI_DISABLE();
 8011c48:	4b85      	ldr	r3, [pc, #532]	@ (8011e60 <HAL_RCC_OscConfig+0x4f4>)
 8011c4a:	681b      	ldr	r3, [r3, #0]
 8011c4c:	4a84      	ldr	r2, [pc, #528]	@ (8011e60 <HAL_RCC_OscConfig+0x4f4>)
 8011c4e:	f023 0301 	bic.w	r3, r3, #1
 8011c52:	6013      	str	r3, [r2, #0]

        tickstart = HAL_GetTick();
 8011c54:	f7fb ff04 	bl	800da60 <HAL_GetTick>
 8011c58:	62b8      	str	r0, [r7, #40]	@ 0x28

        /* Wait till MSI is ready */
        while (READ_BIT(RCC->CR, RCC_CR_MSISRDY) != 0U)
 8011c5a:	e009      	b.n	8011c70 <HAL_RCC_OscConfig+0x304>
        {
          if ((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 8011c5c:	f7fb ff00 	bl	800da60 <HAL_GetTick>
 8011c60:	4602      	mov	r2, r0
 8011c62:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011c64:	1ad3      	subs	r3, r2, r3
 8011c66:	2b02      	cmp	r3, #2
 8011c68:	d902      	bls.n	8011c70 <HAL_RCC_OscConfig+0x304>
          {
            return HAL_TIMEOUT;
 8011c6a:	2303      	movs	r3, #3
 8011c6c:	f000 bd53 	b.w	8012716 <HAL_RCC_OscConfig+0xdaa>
        while (READ_BIT(RCC->CR, RCC_CR_MSISRDY) != 0U)
 8011c70:	4b7b      	ldr	r3, [pc, #492]	@ (8011e60 <HAL_RCC_OscConfig+0x4f4>)
 8011c72:	681b      	ldr	r3, [r3, #0]
 8011c74:	f003 0304 	and.w	r3, r3, #4
 8011c78:	2b00      	cmp	r3, #0
 8011c7a:	d1ef      	bne.n	8011c5c <HAL_RCC_OscConfig+0x2f0>
 8011c7c:	e000      	b.n	8011c80 <HAL_RCC_OscConfig+0x314>
      if (pRCC_OscInitStruct->MSIState == RCC_MSI_OFF)
 8011c7e:	bf00      	nop
        }
      }
    }
  }
  /*------------------------------- HSE Configuration ------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8011c80:	687b      	ldr	r3, [r7, #4]
 8011c82:	681b      	ldr	r3, [r3, #0]
 8011c84:	f003 0301 	and.w	r3, r3, #1
 8011c88:	2b00      	cmp	r3, #0
 8011c8a:	f000 808b 	beq.w	8011da4 <HAL_RCC_OscConfig+0x438>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(pRCC_OscInitStruct->HSEState));

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSE) ||
 8011c8e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011c90:	2b08      	cmp	r3, #8
 8011c92:	d005      	beq.n	8011ca0 <HAL_RCC_OscConfig+0x334>
 8011c94:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011c96:	2b0c      	cmp	r3, #12
 8011c98:	d109      	bne.n	8011cae <HAL_RCC_OscConfig+0x342>
        ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_HSE)))
 8011c9a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011c9c:	2b03      	cmp	r3, #3
 8011c9e:	d106      	bne.n	8011cae <HAL_RCC_OscConfig+0x342>
    {
      if (pRCC_OscInitStruct->HSEState == RCC_HSE_OFF)
 8011ca0:	687b      	ldr	r3, [r7, #4]
 8011ca2:	685b      	ldr	r3, [r3, #4]
 8011ca4:	2b00      	cmp	r3, #0
 8011ca6:	d17d      	bne.n	8011da4 <HAL_RCC_OscConfig+0x438>
      {
        return HAL_ERROR;
 8011ca8:	2301      	movs	r3, #1
 8011caa:	f000 bd34 	b.w	8012716 <HAL_RCC_OscConfig+0xdaa>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(pRCC_OscInitStruct->HSEState);
 8011cae:	687b      	ldr	r3, [r7, #4]
 8011cb0:	685b      	ldr	r3, [r3, #4]
 8011cb2:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 8011cb6:	d106      	bne.n	8011cc6 <HAL_RCC_OscConfig+0x35a>
 8011cb8:	4b69      	ldr	r3, [pc, #420]	@ (8011e60 <HAL_RCC_OscConfig+0x4f4>)
 8011cba:	681b      	ldr	r3, [r3, #0]
 8011cbc:	4a68      	ldr	r2, [pc, #416]	@ (8011e60 <HAL_RCC_OscConfig+0x4f4>)
 8011cbe:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 8011cc2:	6013      	str	r3, [r2, #0]
 8011cc4:	e041      	b.n	8011d4a <HAL_RCC_OscConfig+0x3de>
 8011cc6:	687b      	ldr	r3, [r7, #4]
 8011cc8:	685b      	ldr	r3, [r3, #4]
 8011cca:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
 8011cce:	d112      	bne.n	8011cf6 <HAL_RCC_OscConfig+0x38a>
 8011cd0:	4b63      	ldr	r3, [pc, #396]	@ (8011e60 <HAL_RCC_OscConfig+0x4f4>)
 8011cd2:	681b      	ldr	r3, [r3, #0]
 8011cd4:	4a62      	ldr	r2, [pc, #392]	@ (8011e60 <HAL_RCC_OscConfig+0x4f4>)
 8011cd6:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
 8011cda:	6013      	str	r3, [r2, #0]
 8011cdc:	4b60      	ldr	r3, [pc, #384]	@ (8011e60 <HAL_RCC_OscConfig+0x4f4>)
 8011cde:	681b      	ldr	r3, [r3, #0]
 8011ce0:	4a5f      	ldr	r2, [pc, #380]	@ (8011e60 <HAL_RCC_OscConfig+0x4f4>)
 8011ce2:	f423 1380 	bic.w	r3, r3, #1048576	@ 0x100000
 8011ce6:	6013      	str	r3, [r2, #0]
 8011ce8:	4b5d      	ldr	r3, [pc, #372]	@ (8011e60 <HAL_RCC_OscConfig+0x4f4>)
 8011cea:	681b      	ldr	r3, [r3, #0]
 8011cec:	4a5c      	ldr	r2, [pc, #368]	@ (8011e60 <HAL_RCC_OscConfig+0x4f4>)
 8011cee:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 8011cf2:	6013      	str	r3, [r2, #0]
 8011cf4:	e029      	b.n	8011d4a <HAL_RCC_OscConfig+0x3de>
 8011cf6:	687b      	ldr	r3, [r7, #4]
 8011cf8:	685b      	ldr	r3, [r3, #4]
 8011cfa:	f5b3 1fa8 	cmp.w	r3, #1376256	@ 0x150000
 8011cfe:	d112      	bne.n	8011d26 <HAL_RCC_OscConfig+0x3ba>
 8011d00:	4b57      	ldr	r3, [pc, #348]	@ (8011e60 <HAL_RCC_OscConfig+0x4f4>)
 8011d02:	681b      	ldr	r3, [r3, #0]
 8011d04:	4a56      	ldr	r2, [pc, #344]	@ (8011e60 <HAL_RCC_OscConfig+0x4f4>)
 8011d06:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
 8011d0a:	6013      	str	r3, [r2, #0]
 8011d0c:	4b54      	ldr	r3, [pc, #336]	@ (8011e60 <HAL_RCC_OscConfig+0x4f4>)
 8011d0e:	681b      	ldr	r3, [r3, #0]
 8011d10:	4a53      	ldr	r2, [pc, #332]	@ (8011e60 <HAL_RCC_OscConfig+0x4f4>)
 8011d12:	f443 1380 	orr.w	r3, r3, #1048576	@ 0x100000
 8011d16:	6013      	str	r3, [r2, #0]
 8011d18:	4b51      	ldr	r3, [pc, #324]	@ (8011e60 <HAL_RCC_OscConfig+0x4f4>)
 8011d1a:	681b      	ldr	r3, [r3, #0]
 8011d1c:	4a50      	ldr	r2, [pc, #320]	@ (8011e60 <HAL_RCC_OscConfig+0x4f4>)
 8011d1e:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 8011d22:	6013      	str	r3, [r2, #0]
 8011d24:	e011      	b.n	8011d4a <HAL_RCC_OscConfig+0x3de>
 8011d26:	4b4e      	ldr	r3, [pc, #312]	@ (8011e60 <HAL_RCC_OscConfig+0x4f4>)
 8011d28:	681b      	ldr	r3, [r3, #0]
 8011d2a:	4a4d      	ldr	r2, [pc, #308]	@ (8011e60 <HAL_RCC_OscConfig+0x4f4>)
 8011d2c:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 8011d30:	6013      	str	r3, [r2, #0]
 8011d32:	4b4b      	ldr	r3, [pc, #300]	@ (8011e60 <HAL_RCC_OscConfig+0x4f4>)
 8011d34:	681b      	ldr	r3, [r3, #0]
 8011d36:	4a4a      	ldr	r2, [pc, #296]	@ (8011e60 <HAL_RCC_OscConfig+0x4f4>)
 8011d38:	f423 2380 	bic.w	r3, r3, #262144	@ 0x40000
 8011d3c:	6013      	str	r3, [r2, #0]
 8011d3e:	4b48      	ldr	r3, [pc, #288]	@ (8011e60 <HAL_RCC_OscConfig+0x4f4>)
 8011d40:	681b      	ldr	r3, [r3, #0]
 8011d42:	4a47      	ldr	r2, [pc, #284]	@ (8011e60 <HAL_RCC_OscConfig+0x4f4>)
 8011d44:	f423 1380 	bic.w	r3, r3, #1048576	@ 0x100000
 8011d48:	6013      	str	r3, [r2, #0]

      /* Check the HSE State */
      if (pRCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 8011d4a:	687b      	ldr	r3, [r7, #4]
 8011d4c:	685b      	ldr	r3, [r3, #4]
 8011d4e:	2b00      	cmp	r3, #0
 8011d50:	d014      	beq.n	8011d7c <HAL_RCC_OscConfig+0x410>
      {
        tickstart = HAL_GetTick();
 8011d52:	f7fb fe85 	bl	800da60 <HAL_GetTick>
 8011d56:	62b8      	str	r0, [r7, #40]	@ 0x28

        /* Wait till HSE is ready */
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8011d58:	e009      	b.n	8011d6e <HAL_RCC_OscConfig+0x402>
        {
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8011d5a:	f7fb fe81 	bl	800da60 <HAL_GetTick>
 8011d5e:	4602      	mov	r2, r0
 8011d60:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011d62:	1ad3      	subs	r3, r2, r3
 8011d64:	2b64      	cmp	r3, #100	@ 0x64
 8011d66:	d902      	bls.n	8011d6e <HAL_RCC_OscConfig+0x402>
          {
            return HAL_TIMEOUT;
 8011d68:	2303      	movs	r3, #3
 8011d6a:	f000 bcd4 	b.w	8012716 <HAL_RCC_OscConfig+0xdaa>
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8011d6e:	4b3c      	ldr	r3, [pc, #240]	@ (8011e60 <HAL_RCC_OscConfig+0x4f4>)
 8011d70:	681b      	ldr	r3, [r3, #0]
 8011d72:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8011d76:	2b00      	cmp	r3, #0
 8011d78:	d0ef      	beq.n	8011d5a <HAL_RCC_OscConfig+0x3ee>
 8011d7a:	e013      	b.n	8011da4 <HAL_RCC_OscConfig+0x438>
          }
        }
      }
      else
      {
        tickstart = HAL_GetTick();
 8011d7c:	f7fb fe70 	bl	800da60 <HAL_GetTick>
 8011d80:	62b8      	str	r0, [r7, #40]	@ 0x28

        /* Wait till HSE is disabled */
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
 8011d82:	e009      	b.n	8011d98 <HAL_RCC_OscConfig+0x42c>
        {
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8011d84:	f7fb fe6c 	bl	800da60 <HAL_GetTick>
 8011d88:	4602      	mov	r2, r0
 8011d8a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011d8c:	1ad3      	subs	r3, r2, r3
 8011d8e:	2b64      	cmp	r3, #100	@ 0x64
 8011d90:	d902      	bls.n	8011d98 <HAL_RCC_OscConfig+0x42c>
          {
            return HAL_TIMEOUT;
 8011d92:	2303      	movs	r3, #3
 8011d94:	f000 bcbf 	b.w	8012716 <HAL_RCC_OscConfig+0xdaa>
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
 8011d98:	4b31      	ldr	r3, [pc, #196]	@ (8011e60 <HAL_RCC_OscConfig+0x4f4>)
 8011d9a:	681b      	ldr	r3, [r3, #0]
 8011d9c:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8011da0:	2b00      	cmp	r3, #0
 8011da2:	d1ef      	bne.n	8011d84 <HAL_RCC_OscConfig+0x418>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8011da4:	687b      	ldr	r3, [r7, #4]
 8011da6:	681b      	ldr	r3, [r3, #0]
 8011da8:	f003 0302 	and.w	r3, r3, #2
 8011dac:	2b00      	cmp	r3, #0
 8011dae:	d05f      	beq.n	8011e70 <HAL_RCC_OscConfig+0x504>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(pRCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_HSI_CALIBRATION_VALUE(pRCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSI) ||
 8011db0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011db2:	2b04      	cmp	r3, #4
 8011db4:	d005      	beq.n	8011dc2 <HAL_RCC_OscConfig+0x456>
 8011db6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011db8:	2b0c      	cmp	r3, #12
 8011dba:	d114      	bne.n	8011de6 <HAL_RCC_OscConfig+0x47a>
        ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_HSI)))
 8011dbc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011dbe:	2b02      	cmp	r3, #2
 8011dc0:	d111      	bne.n	8011de6 <HAL_RCC_OscConfig+0x47a>
    {
      /* When HSI is used as system clock it will not be disabled */
      if (pRCC_OscInitStruct->HSIState == RCC_HSI_OFF)
 8011dc2:	687b      	ldr	r3, [r7, #4]
 8011dc4:	68db      	ldr	r3, [r3, #12]
 8011dc6:	2b00      	cmp	r3, #0
 8011dc8:	d102      	bne.n	8011dd0 <HAL_RCC_OscConfig+0x464>
      {
        return HAL_ERROR;
 8011dca:	2301      	movs	r3, #1
 8011dcc:	f000 bca3 	b.w	8012716 <HAL_RCC_OscConfig+0xdaa>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value */
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(pRCC_OscInitStruct->HSICalibrationValue);
 8011dd0:	4b23      	ldr	r3, [pc, #140]	@ (8011e60 <HAL_RCC_OscConfig+0x4f4>)
 8011dd2:	691b      	ldr	r3, [r3, #16]
 8011dd4:	f423 12f8 	bic.w	r2, r3, #2031616	@ 0x1f0000
 8011dd8:	687b      	ldr	r3, [r7, #4]
 8011dda:	691b      	ldr	r3, [r3, #16]
 8011ddc:	041b      	lsls	r3, r3, #16
 8011dde:	4920      	ldr	r1, [pc, #128]	@ (8011e60 <HAL_RCC_OscConfig+0x4f4>)
 8011de0:	4313      	orrs	r3, r2
 8011de2:	610b      	str	r3, [r1, #16]
      if (pRCC_OscInitStruct->HSIState == RCC_HSI_OFF)
 8011de4:	e044      	b.n	8011e70 <HAL_RCC_OscConfig+0x504>
      }
    }
    else
    {
      /* Check the HSI State */
      if (pRCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 8011de6:	687b      	ldr	r3, [r7, #4]
 8011de8:	68db      	ldr	r3, [r3, #12]
 8011dea:	2b00      	cmp	r3, #0
 8011dec:	d024      	beq.n	8011e38 <HAL_RCC_OscConfig+0x4cc>
      {
        /* Enable the Internal High Speed oscillator (HSI) */
        __HAL_RCC_HSI_ENABLE();
 8011dee:	4b1c      	ldr	r3, [pc, #112]	@ (8011e60 <HAL_RCC_OscConfig+0x4f4>)
 8011df0:	681b      	ldr	r3, [r3, #0]
 8011df2:	4a1b      	ldr	r2, [pc, #108]	@ (8011e60 <HAL_RCC_OscConfig+0x4f4>)
 8011df4:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8011df8:	6013      	str	r3, [r2, #0]

        tickstart = HAL_GetTick();
 8011dfa:	f7fb fe31 	bl	800da60 <HAL_GetTick>
 8011dfe:	62b8      	str	r0, [r7, #40]	@ 0x28

        /* Wait till HSI is ready */
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 8011e00:	e009      	b.n	8011e16 <HAL_RCC_OscConfig+0x4aa>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8011e02:	f7fb fe2d 	bl	800da60 <HAL_GetTick>
 8011e06:	4602      	mov	r2, r0
 8011e08:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011e0a:	1ad3      	subs	r3, r2, r3
 8011e0c:	2b02      	cmp	r3, #2
 8011e0e:	d902      	bls.n	8011e16 <HAL_RCC_OscConfig+0x4aa>
          {
            return HAL_TIMEOUT;
 8011e10:	2303      	movs	r3, #3
 8011e12:	f000 bc80 	b.w	8012716 <HAL_RCC_OscConfig+0xdaa>
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 8011e16:	4b12      	ldr	r3, [pc, #72]	@ (8011e60 <HAL_RCC_OscConfig+0x4f4>)
 8011e18:	681b      	ldr	r3, [r3, #0]
 8011e1a:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8011e1e:	2b00      	cmp	r3, #0
 8011e20:	d0ef      	beq.n	8011e02 <HAL_RCC_OscConfig+0x496>
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value */
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(pRCC_OscInitStruct->HSICalibrationValue);
 8011e22:	4b0f      	ldr	r3, [pc, #60]	@ (8011e60 <HAL_RCC_OscConfig+0x4f4>)
 8011e24:	691b      	ldr	r3, [r3, #16]
 8011e26:	f423 12f8 	bic.w	r2, r3, #2031616	@ 0x1f0000
 8011e2a:	687b      	ldr	r3, [r7, #4]
 8011e2c:	691b      	ldr	r3, [r3, #16]
 8011e2e:	041b      	lsls	r3, r3, #16
 8011e30:	490b      	ldr	r1, [pc, #44]	@ (8011e60 <HAL_RCC_OscConfig+0x4f4>)
 8011e32:	4313      	orrs	r3, r2
 8011e34:	610b      	str	r3, [r1, #16]
 8011e36:	e01b      	b.n	8011e70 <HAL_RCC_OscConfig+0x504>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI) */
        __HAL_RCC_HSI_DISABLE();
 8011e38:	4b09      	ldr	r3, [pc, #36]	@ (8011e60 <HAL_RCC_OscConfig+0x4f4>)
 8011e3a:	681b      	ldr	r3, [r3, #0]
 8011e3c:	4a08      	ldr	r2, [pc, #32]	@ (8011e60 <HAL_RCC_OscConfig+0x4f4>)
 8011e3e:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
 8011e42:	6013      	str	r3, [r2, #0]

        tickstart = HAL_GetTick();
 8011e44:	f7fb fe0c 	bl	800da60 <HAL_GetTick>
 8011e48:	62b8      	str	r0, [r7, #40]	@ 0x28

        /* Wait till HSI is disabled */
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
 8011e4a:	e00b      	b.n	8011e64 <HAL_RCC_OscConfig+0x4f8>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8011e4c:	f7fb fe08 	bl	800da60 <HAL_GetTick>
 8011e50:	4602      	mov	r2, r0
 8011e52:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011e54:	1ad3      	subs	r3, r2, r3
 8011e56:	2b02      	cmp	r3, #2
 8011e58:	d904      	bls.n	8011e64 <HAL_RCC_OscConfig+0x4f8>
          {
            return HAL_TIMEOUT;
 8011e5a:	2303      	movs	r3, #3
 8011e5c:	f000 bc5b 	b.w	8012716 <HAL_RCC_OscConfig+0xdaa>
 8011e60:	46020c00 	.word	0x46020c00
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
 8011e64:	4baf      	ldr	r3, [pc, #700]	@ (8012124 <HAL_RCC_OscConfig+0x7b8>)
 8011e66:	681b      	ldr	r3, [r3, #0]
 8011e68:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8011e6c:	2b00      	cmp	r3, #0
 8011e6e:	d1ed      	bne.n	8011e4c <HAL_RCC_OscConfig+0x4e0>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8011e70:	687b      	ldr	r3, [r7, #4]
 8011e72:	681b      	ldr	r3, [r3, #0]
 8011e74:	f003 0308 	and.w	r3, r3, #8
 8011e78:	2b00      	cmp	r3, #0
 8011e7a:	f000 80c8 	beq.w	801200e <HAL_RCC_OscConfig+0x6a2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(pRCC_OscInitStruct->LSIState));

    FlagStatus  pwrclkchanged = RESET;
 8011e7e:	2300      	movs	r3, #0
 8011e80:	f887 3036 	strb.w	r3, [r7, #54]	@ 0x36

    /* Update LSI configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if (__HAL_RCC_PWR_IS_CLK_DISABLED())
 8011e84:	4ba7      	ldr	r3, [pc, #668]	@ (8012124 <HAL_RCC_OscConfig+0x7b8>)
 8011e86:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 8011e8a:	f003 0304 	and.w	r3, r3, #4
 8011e8e:	2b00      	cmp	r3, #0
 8011e90:	d111      	bne.n	8011eb6 <HAL_RCC_OscConfig+0x54a>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 8011e92:	4ba4      	ldr	r3, [pc, #656]	@ (8012124 <HAL_RCC_OscConfig+0x7b8>)
 8011e94:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 8011e98:	4aa2      	ldr	r2, [pc, #648]	@ (8012124 <HAL_RCC_OscConfig+0x7b8>)
 8011e9a:	f043 0304 	orr.w	r3, r3, #4
 8011e9e:	f8c2 3094 	str.w	r3, [r2, #148]	@ 0x94
 8011ea2:	4ba0      	ldr	r3, [pc, #640]	@ (8012124 <HAL_RCC_OscConfig+0x7b8>)
 8011ea4:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 8011ea8:	f003 0304 	and.w	r3, r3, #4
 8011eac:	617b      	str	r3, [r7, #20]
 8011eae:	697b      	ldr	r3, [r7, #20]
      pwrclkchanged = SET;
 8011eb0:	2301      	movs	r3, #1
 8011eb2:	f887 3036 	strb.w	r3, [r7, #54]	@ 0x36
    }

    if (HAL_IS_BIT_CLR(PWR->DBPR, PWR_DBPR_DBP))
 8011eb6:	4b9c      	ldr	r3, [pc, #624]	@ (8012128 <HAL_RCC_OscConfig+0x7bc>)
 8011eb8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8011eba:	f003 0301 	and.w	r3, r3, #1
 8011ebe:	2b00      	cmp	r3, #0
 8011ec0:	d119      	bne.n	8011ef6 <HAL_RCC_OscConfig+0x58a>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->DBPR, PWR_DBPR_DBP);
 8011ec2:	4b99      	ldr	r3, [pc, #612]	@ (8012128 <HAL_RCC_OscConfig+0x7bc>)
 8011ec4:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8011ec6:	4a98      	ldr	r2, [pc, #608]	@ (8012128 <HAL_RCC_OscConfig+0x7bc>)
 8011ec8:	f043 0301 	orr.w	r3, r3, #1
 8011ecc:	6293      	str	r3, [r2, #40]	@ 0x28

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 8011ece:	f7fb fdc7 	bl	800da60 <HAL_GetTick>
 8011ed2:	62b8      	str	r0, [r7, #40]	@ 0x28

      while (HAL_IS_BIT_CLR(PWR->DBPR, PWR_DBPR_DBP))
 8011ed4:	e009      	b.n	8011eea <HAL_RCC_OscConfig+0x57e>
      {
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8011ed6:	f7fb fdc3 	bl	800da60 <HAL_GetTick>
 8011eda:	4602      	mov	r2, r0
 8011edc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011ede:	1ad3      	subs	r3, r2, r3
 8011ee0:	2b02      	cmp	r3, #2
 8011ee2:	d902      	bls.n	8011eea <HAL_RCC_OscConfig+0x57e>
        {
          return HAL_TIMEOUT;
 8011ee4:	2303      	movs	r3, #3
 8011ee6:	f000 bc16 	b.w	8012716 <HAL_RCC_OscConfig+0xdaa>
      while (HAL_IS_BIT_CLR(PWR->DBPR, PWR_DBPR_DBP))
 8011eea:	4b8f      	ldr	r3, [pc, #572]	@ (8012128 <HAL_RCC_OscConfig+0x7bc>)
 8011eec:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8011eee:	f003 0301 	and.w	r3, r3, #1
 8011ef2:	2b00      	cmp	r3, #0
 8011ef4:	d0ef      	beq.n	8011ed6 <HAL_RCC_OscConfig+0x56a>
        }
      }
    }
    /* Check the LSI State */
    if (pRCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 8011ef6:	687b      	ldr	r3, [r7, #4]
 8011ef8:	695b      	ldr	r3, [r3, #20]
 8011efa:	2b00      	cmp	r3, #0
 8011efc:	d05f      	beq.n	8011fbe <HAL_RCC_OscConfig+0x652>
    {
      uint32_t bdcr_temp = RCC->BDCR;
 8011efe:	4b89      	ldr	r3, [pc, #548]	@ (8012124 <HAL_RCC_OscConfig+0x7b8>)
 8011f00:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8011f04:	623b      	str	r3, [r7, #32]

      /* Check LSI division factor */
      assert_param(IS_RCC_LSIDIV(pRCC_OscInitStruct->LSIDiv));

      if (pRCC_OscInitStruct->LSIDiv != (bdcr_temp & RCC_BDCR_LSIPREDIV))
 8011f06:	687b      	ldr	r3, [r7, #4]
 8011f08:	699a      	ldr	r2, [r3, #24]
 8011f0a:	6a3b      	ldr	r3, [r7, #32]
 8011f0c:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 8011f10:	429a      	cmp	r2, r3
 8011f12:	d037      	beq.n	8011f84 <HAL_RCC_OscConfig+0x618>
      {
        if (((bdcr_temp & RCC_BDCR_LSIRDY) == RCC_BDCR_LSIRDY) && \
 8011f14:	6a3b      	ldr	r3, [r7, #32]
 8011f16:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8011f1a:	2b00      	cmp	r3, #0
 8011f1c:	d006      	beq.n	8011f2c <HAL_RCC_OscConfig+0x5c0>
            ((bdcr_temp & RCC_BDCR_LSION) != RCC_BDCR_LSION))
 8011f1e:	6a3b      	ldr	r3, [r7, #32]
 8011f20:	f003 6380 	and.w	r3, r3, #67108864	@ 0x4000000
        if (((bdcr_temp & RCC_BDCR_LSIRDY) == RCC_BDCR_LSIRDY) && \
 8011f24:	2b00      	cmp	r3, #0
 8011f26:	d101      	bne.n	8011f2c <HAL_RCC_OscConfig+0x5c0>
        {
          /* If LSIRDY is set while LSION is not enabled, LSIPREDIV can't be updated */
          /* The LSIPREDIV cannot be changed if the LSI is used by the IWDG or by the RTC */
          return HAL_ERROR;
 8011f28:	2301      	movs	r3, #1
 8011f2a:	e3f4      	b.n	8012716 <HAL_RCC_OscConfig+0xdaa>
        }

        /* Turn off LSI before changing RCC_BDCR_LSIPREDIV */
        if ((bdcr_temp & RCC_BDCR_LSION) == RCC_BDCR_LSION)
 8011f2c:	6a3b      	ldr	r3, [r7, #32]
 8011f2e:	f003 6380 	and.w	r3, r3, #67108864	@ 0x4000000
 8011f32:	2b00      	cmp	r3, #0
 8011f34:	d01b      	beq.n	8011f6e <HAL_RCC_OscConfig+0x602>
        {
          __HAL_RCC_LSI_DISABLE();
 8011f36:	4b7b      	ldr	r3, [pc, #492]	@ (8012124 <HAL_RCC_OscConfig+0x7b8>)
 8011f38:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8011f3c:	4a79      	ldr	r2, [pc, #484]	@ (8012124 <HAL_RCC_OscConfig+0x7b8>)
 8011f3e:	f023 53a0 	bic.w	r3, r3, #335544320	@ 0x14000000
 8011f42:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0

          tickstart = HAL_GetTick();
 8011f46:	f7fb fd8b 	bl	800da60 <HAL_GetTick>
 8011f4a:	62b8      	str	r0, [r7, #40]	@ 0x28

          /* Wait till LSI is disabled */
          while (READ_BIT(RCC->BDCR, RCC_BDCR_LSIRDY) != 0U)
 8011f4c:	e008      	b.n	8011f60 <HAL_RCC_OscConfig+0x5f4>
          {
            if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8011f4e:	f7fb fd87 	bl	800da60 <HAL_GetTick>
 8011f52:	4602      	mov	r2, r0
 8011f54:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011f56:	1ad3      	subs	r3, r2, r3
 8011f58:	2b05      	cmp	r3, #5
 8011f5a:	d901      	bls.n	8011f60 <HAL_RCC_OscConfig+0x5f4>
            {
              return HAL_TIMEOUT;
 8011f5c:	2303      	movs	r3, #3
 8011f5e:	e3da      	b.n	8012716 <HAL_RCC_OscConfig+0xdaa>
          while (READ_BIT(RCC->BDCR, RCC_BDCR_LSIRDY) != 0U)
 8011f60:	4b70      	ldr	r3, [pc, #448]	@ (8012124 <HAL_RCC_OscConfig+0x7b8>)
 8011f62:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8011f66:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8011f6a:	2b00      	cmp	r3, #0
 8011f6c:	d1ef      	bne.n	8011f4e <HAL_RCC_OscConfig+0x5e2>
            }
          }
        }

        /* Set LSI division factor */
        MODIFY_REG(RCC->BDCR, RCC_BDCR_LSIPREDIV, pRCC_OscInitStruct->LSIDiv);
 8011f6e:	4b6d      	ldr	r3, [pc, #436]	@ (8012124 <HAL_RCC_OscConfig+0x7b8>)
 8011f70:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8011f74:	f023 5280 	bic.w	r2, r3, #268435456	@ 0x10000000
 8011f78:	687b      	ldr	r3, [r7, #4]
 8011f7a:	699b      	ldr	r3, [r3, #24]
 8011f7c:	4969      	ldr	r1, [pc, #420]	@ (8012124 <HAL_RCC_OscConfig+0x7b8>)
 8011f7e:	4313      	orrs	r3, r2
 8011f80:	f8c1 30f0 	str.w	r3, [r1, #240]	@ 0xf0
      }

      /* Enable the Internal Low Speed oscillator (LSI) */
      __HAL_RCC_LSI_ENABLE();
 8011f84:	4b67      	ldr	r3, [pc, #412]	@ (8012124 <HAL_RCC_OscConfig+0x7b8>)
 8011f86:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8011f8a:	4a66      	ldr	r2, [pc, #408]	@ (8012124 <HAL_RCC_OscConfig+0x7b8>)
 8011f8c:	f043 6380 	orr.w	r3, r3, #67108864	@ 0x4000000
 8011f90:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0

      tickstart = HAL_GetTick();
 8011f94:	f7fb fd64 	bl	800da60 <HAL_GetTick>
 8011f98:	62b8      	str	r0, [r7, #40]	@ 0x28

      /* Wait till LSI is ready */
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSIRDY) == 0U)
 8011f9a:	e008      	b.n	8011fae <HAL_RCC_OscConfig+0x642>
      {
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8011f9c:	f7fb fd60 	bl	800da60 <HAL_GetTick>
 8011fa0:	4602      	mov	r2, r0
 8011fa2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011fa4:	1ad3      	subs	r3, r2, r3
 8011fa6:	2b05      	cmp	r3, #5
 8011fa8:	d901      	bls.n	8011fae <HAL_RCC_OscConfig+0x642>
        {
          return HAL_TIMEOUT;
 8011faa:	2303      	movs	r3, #3
 8011fac:	e3b3      	b.n	8012716 <HAL_RCC_OscConfig+0xdaa>
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSIRDY) == 0U)
 8011fae:	4b5d      	ldr	r3, [pc, #372]	@ (8012124 <HAL_RCC_OscConfig+0x7b8>)
 8011fb0:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8011fb4:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8011fb8:	2b00      	cmp	r3, #0
 8011fba:	d0ef      	beq.n	8011f9c <HAL_RCC_OscConfig+0x630>
 8011fbc:	e01b      	b.n	8011ff6 <HAL_RCC_OscConfig+0x68a>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI) */
      __HAL_RCC_LSI_DISABLE();
 8011fbe:	4b59      	ldr	r3, [pc, #356]	@ (8012124 <HAL_RCC_OscConfig+0x7b8>)
 8011fc0:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8011fc4:	4a57      	ldr	r2, [pc, #348]	@ (8012124 <HAL_RCC_OscConfig+0x7b8>)
 8011fc6:	f023 53a0 	bic.w	r3, r3, #335544320	@ 0x14000000
 8011fca:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0

      tickstart = HAL_GetTick();
 8011fce:	f7fb fd47 	bl	800da60 <HAL_GetTick>
 8011fd2:	62b8      	str	r0, [r7, #40]	@ 0x28

      /* Wait till LSI is disabled */
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSIRDY) != 0U)
 8011fd4:	e008      	b.n	8011fe8 <HAL_RCC_OscConfig+0x67c>
      {
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8011fd6:	f7fb fd43 	bl	800da60 <HAL_GetTick>
 8011fda:	4602      	mov	r2, r0
 8011fdc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011fde:	1ad3      	subs	r3, r2, r3
 8011fe0:	2b05      	cmp	r3, #5
 8011fe2:	d901      	bls.n	8011fe8 <HAL_RCC_OscConfig+0x67c>
        {
          return HAL_TIMEOUT;
 8011fe4:	2303      	movs	r3, #3
 8011fe6:	e396      	b.n	8012716 <HAL_RCC_OscConfig+0xdaa>
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSIRDY) != 0U)
 8011fe8:	4b4e      	ldr	r3, [pc, #312]	@ (8012124 <HAL_RCC_OscConfig+0x7b8>)
 8011fea:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8011fee:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8011ff2:	2b00      	cmp	r3, #0
 8011ff4:	d1ef      	bne.n	8011fd6 <HAL_RCC_OscConfig+0x66a>
        }
      }
    }
    /* Restore clock configuration if changed */
    if (pwrclkchanged == SET)
 8011ff6:	f897 3036 	ldrb.w	r3, [r7, #54]	@ 0x36
 8011ffa:	2b01      	cmp	r3, #1
 8011ffc:	d107      	bne.n	801200e <HAL_RCC_OscConfig+0x6a2>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 8011ffe:	4b49      	ldr	r3, [pc, #292]	@ (8012124 <HAL_RCC_OscConfig+0x7b8>)
 8012000:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 8012004:	4a47      	ldr	r2, [pc, #284]	@ (8012124 <HAL_RCC_OscConfig+0x7b8>)
 8012006:	f023 0304 	bic.w	r3, r3, #4
 801200a:	f8c2 3094 	str.w	r3, [r2, #148]	@ 0x94
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 801200e:	687b      	ldr	r3, [r7, #4]
 8012010:	681b      	ldr	r3, [r3, #0]
 8012012:	f003 0304 	and.w	r3, r3, #4
 8012016:	2b00      	cmp	r3, #0
 8012018:	f000 8111 	beq.w	801223e <HAL_RCC_OscConfig+0x8d2>
  {
    FlagStatus pwrclkchanged = RESET;
 801201c:	2300      	movs	r3, #0
 801201e:	f887 3035 	strb.w	r3, [r7, #53]	@ 0x35
    /* Check the parameters */
    assert_param(IS_RCC_LSE(pRCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if (__HAL_RCC_PWR_IS_CLK_DISABLED())
 8012022:	4b40      	ldr	r3, [pc, #256]	@ (8012124 <HAL_RCC_OscConfig+0x7b8>)
 8012024:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 8012028:	f003 0304 	and.w	r3, r3, #4
 801202c:	2b00      	cmp	r3, #0
 801202e:	d111      	bne.n	8012054 <HAL_RCC_OscConfig+0x6e8>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 8012030:	4b3c      	ldr	r3, [pc, #240]	@ (8012124 <HAL_RCC_OscConfig+0x7b8>)
 8012032:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 8012036:	4a3b      	ldr	r2, [pc, #236]	@ (8012124 <HAL_RCC_OscConfig+0x7b8>)
 8012038:	f043 0304 	orr.w	r3, r3, #4
 801203c:	f8c2 3094 	str.w	r3, [r2, #148]	@ 0x94
 8012040:	4b38      	ldr	r3, [pc, #224]	@ (8012124 <HAL_RCC_OscConfig+0x7b8>)
 8012042:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 8012046:	f003 0304 	and.w	r3, r3, #4
 801204a:	613b      	str	r3, [r7, #16]
 801204c:	693b      	ldr	r3, [r7, #16]
      pwrclkchanged = SET;
 801204e:	2301      	movs	r3, #1
 8012050:	f887 3035 	strb.w	r3, [r7, #53]	@ 0x35
    }

    if (HAL_IS_BIT_CLR(PWR->DBPR, PWR_DBPR_DBP))
 8012054:	4b34      	ldr	r3, [pc, #208]	@ (8012128 <HAL_RCC_OscConfig+0x7bc>)
 8012056:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8012058:	f003 0301 	and.w	r3, r3, #1
 801205c:	2b00      	cmp	r3, #0
 801205e:	d118      	bne.n	8012092 <HAL_RCC_OscConfig+0x726>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->DBPR, PWR_DBPR_DBP);
 8012060:	4b31      	ldr	r3, [pc, #196]	@ (8012128 <HAL_RCC_OscConfig+0x7bc>)
 8012062:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8012064:	4a30      	ldr	r2, [pc, #192]	@ (8012128 <HAL_RCC_OscConfig+0x7bc>)
 8012066:	f043 0301 	orr.w	r3, r3, #1
 801206a:	6293      	str	r3, [r2, #40]	@ 0x28

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 801206c:	f7fb fcf8 	bl	800da60 <HAL_GetTick>
 8012070:	62b8      	str	r0, [r7, #40]	@ 0x28

      while (HAL_IS_BIT_CLR(PWR->DBPR, PWR_DBPR_DBP))
 8012072:	e008      	b.n	8012086 <HAL_RCC_OscConfig+0x71a>
      {
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8012074:	f7fb fcf4 	bl	800da60 <HAL_GetTick>
 8012078:	4602      	mov	r2, r0
 801207a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801207c:	1ad3      	subs	r3, r2, r3
 801207e:	2b02      	cmp	r3, #2
 8012080:	d901      	bls.n	8012086 <HAL_RCC_OscConfig+0x71a>
        {
          return HAL_TIMEOUT;
 8012082:	2303      	movs	r3, #3
 8012084:	e347      	b.n	8012716 <HAL_RCC_OscConfig+0xdaa>
      while (HAL_IS_BIT_CLR(PWR->DBPR, PWR_DBPR_DBP))
 8012086:	4b28      	ldr	r3, [pc, #160]	@ (8012128 <HAL_RCC_OscConfig+0x7bc>)
 8012088:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 801208a:	f003 0301 	and.w	r3, r3, #1
 801208e:	2b00      	cmp	r3, #0
 8012090:	d0f0      	beq.n	8012074 <HAL_RCC_OscConfig+0x708>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    if ((pRCC_OscInitStruct->LSEState & RCC_BDCR_LSEON) != 0U)
 8012092:	687b      	ldr	r3, [r7, #4]
 8012094:	689b      	ldr	r3, [r3, #8]
 8012096:	f003 0301 	and.w	r3, r3, #1
 801209a:	2b00      	cmp	r3, #0
 801209c:	d01f      	beq.n	80120de <HAL_RCC_OscConfig+0x772>
    {
      if ((pRCC_OscInitStruct->LSEState & RCC_BDCR_LSEBYP) != 0U)
 801209e:	687b      	ldr	r3, [r7, #4]
 80120a0:	689b      	ldr	r3, [r3, #8]
 80120a2:	f003 0304 	and.w	r3, r3, #4
 80120a6:	2b00      	cmp	r3, #0
 80120a8:	d010      	beq.n	80120cc <HAL_RCC_OscConfig+0x760>
      {
        /* LSE oscillator bypass enable */
        SET_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);
 80120aa:	4b1e      	ldr	r3, [pc, #120]	@ (8012124 <HAL_RCC_OscConfig+0x7b8>)
 80120ac:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 80120b0:	4a1c      	ldr	r2, [pc, #112]	@ (8012124 <HAL_RCC_OscConfig+0x7b8>)
 80120b2:	f043 0304 	orr.w	r3, r3, #4
 80120b6:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0
        SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 80120ba:	4b1a      	ldr	r3, [pc, #104]	@ (8012124 <HAL_RCC_OscConfig+0x7b8>)
 80120bc:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 80120c0:	4a18      	ldr	r2, [pc, #96]	@ (8012124 <HAL_RCC_OscConfig+0x7b8>)
 80120c2:	f043 0301 	orr.w	r3, r3, #1
 80120c6:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0
 80120ca:	e018      	b.n	80120fe <HAL_RCC_OscConfig+0x792>
      }
      else
      {
        /* LSE oscillator enable */
        SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 80120cc:	4b15      	ldr	r3, [pc, #84]	@ (8012124 <HAL_RCC_OscConfig+0x7b8>)
 80120ce:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 80120d2:	4a14      	ldr	r2, [pc, #80]	@ (8012124 <HAL_RCC_OscConfig+0x7b8>)
 80120d4:	f043 0301 	orr.w	r3, r3, #1
 80120d8:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0
 80120dc:	e00f      	b.n	80120fe <HAL_RCC_OscConfig+0x792>
      }
    }
    else
    {
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 80120de:	4b11      	ldr	r3, [pc, #68]	@ (8012124 <HAL_RCC_OscConfig+0x7b8>)
 80120e0:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 80120e4:	4a0f      	ldr	r2, [pc, #60]	@ (8012124 <HAL_RCC_OscConfig+0x7b8>)
 80120e6:	f023 0301 	bic.w	r3, r3, #1
 80120ea:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);
 80120ee:	4b0d      	ldr	r3, [pc, #52]	@ (8012124 <HAL_RCC_OscConfig+0x7b8>)
 80120f0:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 80120f4:	4a0b      	ldr	r2, [pc, #44]	@ (8012124 <HAL_RCC_OscConfig+0x7b8>)
 80120f6:	f023 0304 	bic.w	r3, r3, #4
 80120fa:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0
    }

    /* Check the LSE State */
    if (pRCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 80120fe:	687b      	ldr	r3, [r7, #4]
 8012100:	689b      	ldr	r3, [r3, #8]
 8012102:	2b00      	cmp	r3, #0
 8012104:	d057      	beq.n	80121b6 <HAL_RCC_OscConfig+0x84a>
    {
      tickstart = HAL_GetTick();
 8012106:	f7fb fcab 	bl	800da60 <HAL_GetTick>
 801210a:	62b8      	str	r0, [r7, #40]	@ 0x28

      /* Wait till LSE is ready */
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 801210c:	e00e      	b.n	801212c <HAL_RCC_OscConfig+0x7c0>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 801210e:	f7fb fca7 	bl	800da60 <HAL_GetTick>
 8012112:	4602      	mov	r2, r0
 8012114:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8012116:	1ad3      	subs	r3, r2, r3
 8012118:	f241 3288 	movw	r2, #5000	@ 0x1388
 801211c:	4293      	cmp	r3, r2
 801211e:	d905      	bls.n	801212c <HAL_RCC_OscConfig+0x7c0>
        {
          return HAL_TIMEOUT;
 8012120:	2303      	movs	r3, #3
 8012122:	e2f8      	b.n	8012716 <HAL_RCC_OscConfig+0xdaa>
 8012124:	46020c00 	.word	0x46020c00
 8012128:	46020800 	.word	0x46020800
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 801212c:	4b9c      	ldr	r3, [pc, #624]	@ (80123a0 <HAL_RCC_OscConfig+0xa34>)
 801212e:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8012132:	f003 0302 	and.w	r3, r3, #2
 8012136:	2b00      	cmp	r3, #0
 8012138:	d0e9      	beq.n	801210e <HAL_RCC_OscConfig+0x7a2>
        }
      }

      /* Enable LSESYS additionally if requested */
      if ((pRCC_OscInitStruct->LSEState & RCC_BDCR_LSESYSEN) != 0U)
 801213a:	687b      	ldr	r3, [r7, #4]
 801213c:	689b      	ldr	r3, [r3, #8]
 801213e:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8012142:	2b00      	cmp	r3, #0
 8012144:	d01b      	beq.n	801217e <HAL_RCC_OscConfig+0x812>
      {
        SET_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 8012146:	4b96      	ldr	r3, [pc, #600]	@ (80123a0 <HAL_RCC_OscConfig+0xa34>)
 8012148:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 801214c:	4a94      	ldr	r2, [pc, #592]	@ (80123a0 <HAL_RCC_OscConfig+0xa34>)
 801214e:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8012152:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0

        /* Wait till LSESYS is ready */
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) == 0U)
 8012156:	e00a      	b.n	801216e <HAL_RCC_OscConfig+0x802>
        {
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8012158:	f7fb fc82 	bl	800da60 <HAL_GetTick>
 801215c:	4602      	mov	r2, r0
 801215e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8012160:	1ad3      	subs	r3, r2, r3
 8012162:	f241 3288 	movw	r2, #5000	@ 0x1388
 8012166:	4293      	cmp	r3, r2
 8012168:	d901      	bls.n	801216e <HAL_RCC_OscConfig+0x802>
          {
            return HAL_TIMEOUT;
 801216a:	2303      	movs	r3, #3
 801216c:	e2d3      	b.n	8012716 <HAL_RCC_OscConfig+0xdaa>
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) == 0U)
 801216e:	4b8c      	ldr	r3, [pc, #560]	@ (80123a0 <HAL_RCC_OscConfig+0xa34>)
 8012170:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8012174:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 8012178:	2b00      	cmp	r3, #0
 801217a:	d0ed      	beq.n	8012158 <HAL_RCC_OscConfig+0x7ec>
 801217c:	e053      	b.n	8012226 <HAL_RCC_OscConfig+0x8ba>
        }
      }
      else
      {
        /* Make sure LSESYSEN/LSESYSRDY are reset */
        CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 801217e:	4b88      	ldr	r3, [pc, #544]	@ (80123a0 <HAL_RCC_OscConfig+0xa34>)
 8012180:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8012184:	4a86      	ldr	r2, [pc, #536]	@ (80123a0 <HAL_RCC_OscConfig+0xa34>)
 8012186:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 801218a:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0

        /* Wait till LSESYSRDY is cleared */
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) != 0U)
 801218e:	e00a      	b.n	80121a6 <HAL_RCC_OscConfig+0x83a>
        {
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8012190:	f7fb fc66 	bl	800da60 <HAL_GetTick>
 8012194:	4602      	mov	r2, r0
 8012196:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8012198:	1ad3      	subs	r3, r2, r3
 801219a:	f241 3288 	movw	r2, #5000	@ 0x1388
 801219e:	4293      	cmp	r3, r2
 80121a0:	d901      	bls.n	80121a6 <HAL_RCC_OscConfig+0x83a>
          {
            return HAL_TIMEOUT;
 80121a2:	2303      	movs	r3, #3
 80121a4:	e2b7      	b.n	8012716 <HAL_RCC_OscConfig+0xdaa>
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) != 0U)
 80121a6:	4b7e      	ldr	r3, [pc, #504]	@ (80123a0 <HAL_RCC_OscConfig+0xa34>)
 80121a8:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 80121ac:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 80121b0:	2b00      	cmp	r3, #0
 80121b2:	d1ed      	bne.n	8012190 <HAL_RCC_OscConfig+0x824>
 80121b4:	e037      	b.n	8012226 <HAL_RCC_OscConfig+0x8ba>
        }
      }
    }
    else
    {
      tickstart = HAL_GetTick();
 80121b6:	f7fb fc53 	bl	800da60 <HAL_GetTick>
 80121ba:	62b8      	str	r0, [r7, #40]	@ 0x28

      /* Wait till LSE is disabled */
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
 80121bc:	e00a      	b.n	80121d4 <HAL_RCC_OscConfig+0x868>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80121be:	f7fb fc4f 	bl	800da60 <HAL_GetTick>
 80121c2:	4602      	mov	r2, r0
 80121c4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80121c6:	1ad3      	subs	r3, r2, r3
 80121c8:	f241 3288 	movw	r2, #5000	@ 0x1388
 80121cc:	4293      	cmp	r3, r2
 80121ce:	d901      	bls.n	80121d4 <HAL_RCC_OscConfig+0x868>
        {
          return HAL_TIMEOUT;
 80121d0:	2303      	movs	r3, #3
 80121d2:	e2a0      	b.n	8012716 <HAL_RCC_OscConfig+0xdaa>
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
 80121d4:	4b72      	ldr	r3, [pc, #456]	@ (80123a0 <HAL_RCC_OscConfig+0xa34>)
 80121d6:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 80121da:	f003 0302 	and.w	r3, r3, #2
 80121de:	2b00      	cmp	r3, #0
 80121e0:	d1ed      	bne.n	80121be <HAL_RCC_OscConfig+0x852>
        }
      }

      if (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN) != 0U)
 80121e2:	4b6f      	ldr	r3, [pc, #444]	@ (80123a0 <HAL_RCC_OscConfig+0xa34>)
 80121e4:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 80121e8:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 80121ec:	2b00      	cmp	r3, #0
 80121ee:	d01a      	beq.n	8012226 <HAL_RCC_OscConfig+0x8ba>
      {
        /* Reset LSESYSEN once LSE is disabled */
        CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 80121f0:	4b6b      	ldr	r3, [pc, #428]	@ (80123a0 <HAL_RCC_OscConfig+0xa34>)
 80121f2:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 80121f6:	4a6a      	ldr	r2, [pc, #424]	@ (80123a0 <HAL_RCC_OscConfig+0xa34>)
 80121f8:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 80121fc:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0

        /* Wait till LSESYSRDY is cleared */
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) != 0U)
 8012200:	e00a      	b.n	8012218 <HAL_RCC_OscConfig+0x8ac>
        {
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8012202:	f7fb fc2d 	bl	800da60 <HAL_GetTick>
 8012206:	4602      	mov	r2, r0
 8012208:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801220a:	1ad3      	subs	r3, r2, r3
 801220c:	f241 3288 	movw	r2, #5000	@ 0x1388
 8012210:	4293      	cmp	r3, r2
 8012212:	d901      	bls.n	8012218 <HAL_RCC_OscConfig+0x8ac>
          {
            return HAL_TIMEOUT;
 8012214:	2303      	movs	r3, #3
 8012216:	e27e      	b.n	8012716 <HAL_RCC_OscConfig+0xdaa>
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) != 0U)
 8012218:	4b61      	ldr	r3, [pc, #388]	@ (80123a0 <HAL_RCC_OscConfig+0xa34>)
 801221a:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 801221e:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 8012222:	2b00      	cmp	r3, #0
 8012224:	d1ed      	bne.n	8012202 <HAL_RCC_OscConfig+0x896>
        }
      }
    }

    /* Restore clock configuration if changed */
    if (pwrclkchanged == SET)
 8012226:	f897 3035 	ldrb.w	r3, [r7, #53]	@ 0x35
 801222a:	2b01      	cmp	r3, #1
 801222c:	d107      	bne.n	801223e <HAL_RCC_OscConfig+0x8d2>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 801222e:	4b5c      	ldr	r3, [pc, #368]	@ (80123a0 <HAL_RCC_OscConfig+0xa34>)
 8012230:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 8012234:	4a5a      	ldr	r2, [pc, #360]	@ (80123a0 <HAL_RCC_OscConfig+0xa34>)
 8012236:	f023 0304 	bic.w	r3, r3, #4
 801223a:	f8c2 3094 	str.w	r3, [r2, #148]	@ 0x94
    }
  }
  /*------------------------------ HSI48 Configuration -----------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
 801223e:	687b      	ldr	r3, [r7, #4]
 8012240:	681b      	ldr	r3, [r3, #0]
 8012242:	f003 0320 	and.w	r3, r3, #32
 8012246:	2b00      	cmp	r3, #0
 8012248:	d036      	beq.n	80122b8 <HAL_RCC_OscConfig+0x94c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI48(pRCC_OscInitStruct->HSI48State));

    /* Check the HSI48 State */
    if (pRCC_OscInitStruct->HSI48State != RCC_HSI48_OFF)
 801224a:	687b      	ldr	r3, [r7, #4]
 801224c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 801224e:	2b00      	cmp	r3, #0
 8012250:	d019      	beq.n	8012286 <HAL_RCC_OscConfig+0x91a>
    {
      /* Enable the Internal High Speed oscillator (HSI48) */
      __HAL_RCC_HSI48_ENABLE();
 8012252:	4b53      	ldr	r3, [pc, #332]	@ (80123a0 <HAL_RCC_OscConfig+0xa34>)
 8012254:	681b      	ldr	r3, [r3, #0]
 8012256:	4a52      	ldr	r2, [pc, #328]	@ (80123a0 <HAL_RCC_OscConfig+0xa34>)
 8012258:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
 801225c:	6013      	str	r3, [r2, #0]

      tickstart = HAL_GetTick();
 801225e:	f7fb fbff 	bl	800da60 <HAL_GetTick>
 8012262:	62b8      	str	r0, [r7, #40]	@ 0x28

      /* Wait till HSI48 is ready */
      while (READ_BIT(RCC->CR, RCC_CR_HSI48RDY) == 0U)
 8012264:	e008      	b.n	8012278 <HAL_RCC_OscConfig+0x90c>
      {
        if ((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 8012266:	f7fb fbfb 	bl	800da60 <HAL_GetTick>
 801226a:	4602      	mov	r2, r0
 801226c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801226e:	1ad3      	subs	r3, r2, r3
 8012270:	2b02      	cmp	r3, #2
 8012272:	d901      	bls.n	8012278 <HAL_RCC_OscConfig+0x90c>
        {
          return HAL_TIMEOUT;
 8012274:	2303      	movs	r3, #3
 8012276:	e24e      	b.n	8012716 <HAL_RCC_OscConfig+0xdaa>
      while (READ_BIT(RCC->CR, RCC_CR_HSI48RDY) == 0U)
 8012278:	4b49      	ldr	r3, [pc, #292]	@ (80123a0 <HAL_RCC_OscConfig+0xa34>)
 801227a:	681b      	ldr	r3, [r3, #0]
 801227c:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 8012280:	2b00      	cmp	r3, #0
 8012282:	d0f0      	beq.n	8012266 <HAL_RCC_OscConfig+0x8fa>
 8012284:	e018      	b.n	80122b8 <HAL_RCC_OscConfig+0x94c>
      }
    }
    else
    {
      /* Disable the Internal High Speed oscillator (HSI48) */
      __HAL_RCC_HSI48_DISABLE();
 8012286:	4b46      	ldr	r3, [pc, #280]	@ (80123a0 <HAL_RCC_OscConfig+0xa34>)
 8012288:	681b      	ldr	r3, [r3, #0]
 801228a:	4a45      	ldr	r2, [pc, #276]	@ (80123a0 <HAL_RCC_OscConfig+0xa34>)
 801228c:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
 8012290:	6013      	str	r3, [r2, #0]

      tickstart = HAL_GetTick();
 8012292:	f7fb fbe5 	bl	800da60 <HAL_GetTick>
 8012296:	62b8      	str	r0, [r7, #40]	@ 0x28

      /* Wait till HSI48 is disabled */
      while (READ_BIT(RCC->CR, RCC_CR_HSI48RDY) != 0U)
 8012298:	e008      	b.n	80122ac <HAL_RCC_OscConfig+0x940>
      {
        if ((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 801229a:	f7fb fbe1 	bl	800da60 <HAL_GetTick>
 801229e:	4602      	mov	r2, r0
 80122a0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80122a2:	1ad3      	subs	r3, r2, r3
 80122a4:	2b02      	cmp	r3, #2
 80122a6:	d901      	bls.n	80122ac <HAL_RCC_OscConfig+0x940>
        {
          return HAL_TIMEOUT;
 80122a8:	2303      	movs	r3, #3
 80122aa:	e234      	b.n	8012716 <HAL_RCC_OscConfig+0xdaa>
      while (READ_BIT(RCC->CR, RCC_CR_HSI48RDY) != 0U)
 80122ac:	4b3c      	ldr	r3, [pc, #240]	@ (80123a0 <HAL_RCC_OscConfig+0xa34>)
 80122ae:	681b      	ldr	r3, [r3, #0]
 80122b0:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 80122b4:	2b00      	cmp	r3, #0
 80122b6:	d1f0      	bne.n	801229a <HAL_RCC_OscConfig+0x92e>
      }
    }
  }

  /*------------------------------ SHSI Configuration -----------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_SHSI) == RCC_OSCILLATORTYPE_SHSI)
 80122b8:	687b      	ldr	r3, [r7, #4]
 80122ba:	681b      	ldr	r3, [r3, #0]
 80122bc:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 80122c0:	2b00      	cmp	r3, #0
 80122c2:	d036      	beq.n	8012332 <HAL_RCC_OscConfig+0x9c6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SHSI(pRCC_OscInitStruct->SHSIState));

    /* Check the SHSI State */
    if (pRCC_OscInitStruct->SHSIState != RCC_SHSI_OFF)
 80122c4:	687b      	ldr	r3, [r7, #4]
 80122c6:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80122c8:	2b00      	cmp	r3, #0
 80122ca:	d019      	beq.n	8012300 <HAL_RCC_OscConfig+0x994>
    {
      /* Enable the Secure Internal High Speed oscillator (SHSI) */
      __HAL_RCC_SHSI_ENABLE();
 80122cc:	4b34      	ldr	r3, [pc, #208]	@ (80123a0 <HAL_RCC_OscConfig+0xa34>)
 80122ce:	681b      	ldr	r3, [r3, #0]
 80122d0:	4a33      	ldr	r2, [pc, #204]	@ (80123a0 <HAL_RCC_OscConfig+0xa34>)
 80122d2:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 80122d6:	6013      	str	r3, [r2, #0]

      tickstart = HAL_GetTick();
 80122d8:	f7fb fbc2 	bl	800da60 <HAL_GetTick>
 80122dc:	62b8      	str	r0, [r7, #40]	@ 0x28

      /* Wait till SHSI is ready */
      while (READ_BIT(RCC->CR, RCC_CR_SHSIRDY) == 0U)
 80122de:	e008      	b.n	80122f2 <HAL_RCC_OscConfig+0x986>
      {
        if ((HAL_GetTick() - tickstart) > SHSI_TIMEOUT_VALUE)
 80122e0:	f7fb fbbe 	bl	800da60 <HAL_GetTick>
 80122e4:	4602      	mov	r2, r0
 80122e6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80122e8:	1ad3      	subs	r3, r2, r3
 80122ea:	2b02      	cmp	r3, #2
 80122ec:	d901      	bls.n	80122f2 <HAL_RCC_OscConfig+0x986>
        {
          return HAL_TIMEOUT;
 80122ee:	2303      	movs	r3, #3
 80122f0:	e211      	b.n	8012716 <HAL_RCC_OscConfig+0xdaa>
      while (READ_BIT(RCC->CR, RCC_CR_SHSIRDY) == 0U)
 80122f2:	4b2b      	ldr	r3, [pc, #172]	@ (80123a0 <HAL_RCC_OscConfig+0xa34>)
 80122f4:	681b      	ldr	r3, [r3, #0]
 80122f6:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 80122fa:	2b00      	cmp	r3, #0
 80122fc:	d0f0      	beq.n	80122e0 <HAL_RCC_OscConfig+0x974>
 80122fe:	e018      	b.n	8012332 <HAL_RCC_OscConfig+0x9c6>
      }
    }
    else
    {
      /* Disable the Secure Internal High Speed oscillator (SHSI) */
      __HAL_RCC_SHSI_DISABLE();
 8012300:	4b27      	ldr	r3, [pc, #156]	@ (80123a0 <HAL_RCC_OscConfig+0xa34>)
 8012302:	681b      	ldr	r3, [r3, #0]
 8012304:	4a26      	ldr	r2, [pc, #152]	@ (80123a0 <HAL_RCC_OscConfig+0xa34>)
 8012306:	f423 4380 	bic.w	r3, r3, #16384	@ 0x4000
 801230a:	6013      	str	r3, [r2, #0]

      tickstart = HAL_GetTick();
 801230c:	f7fb fba8 	bl	800da60 <HAL_GetTick>
 8012310:	62b8      	str	r0, [r7, #40]	@ 0x28

      /* Wait till SHSI is disabled */
      while (READ_BIT(RCC->CR, RCC_CR_SHSIRDY) != 0U)
 8012312:	e008      	b.n	8012326 <HAL_RCC_OscConfig+0x9ba>
      {
        if ((HAL_GetTick() - tickstart) > SHSI_TIMEOUT_VALUE)
 8012314:	f7fb fba4 	bl	800da60 <HAL_GetTick>
 8012318:	4602      	mov	r2, r0
 801231a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801231c:	1ad3      	subs	r3, r2, r3
 801231e:	2b02      	cmp	r3, #2
 8012320:	d901      	bls.n	8012326 <HAL_RCC_OscConfig+0x9ba>
        {
          return HAL_TIMEOUT;
 8012322:	2303      	movs	r3, #3
 8012324:	e1f7      	b.n	8012716 <HAL_RCC_OscConfig+0xdaa>
      while (READ_BIT(RCC->CR, RCC_CR_SHSIRDY) != 0U)
 8012326:	4b1e      	ldr	r3, [pc, #120]	@ (80123a0 <HAL_RCC_OscConfig+0xa34>)
 8012328:	681b      	ldr	r3, [r3, #0]
 801232a:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 801232e:	2b00      	cmp	r3, #0
 8012330:	d1f0      	bne.n	8012314 <HAL_RCC_OscConfig+0x9a8>
        }
      }
    }
  }
  /*------------------------------ MSIK Configuration -----------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSIK) == RCC_OSCILLATORTYPE_MSIK)
 8012332:	687b      	ldr	r3, [r7, #4]
 8012334:	681b      	ldr	r3, [r3, #0]
 8012336:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 801233a:	2b00      	cmp	r3, #0
 801233c:	d07f      	beq.n	801243e <HAL_RCC_OscConfig+0xad2>
    assert_param(IS_RCC_MSIK(pRCC_OscInitStruct->MSIKState));
    assert_param(IS_RCC_MSIK_CLOCK_RANGE(pRCC_OscInitStruct->MSIKClockRange));
    assert_param(IS_RCC_MSICALIBRATION_VALUE(pRCC_OscInitStruct->MSICalibrationValue));

    /* Check the MSIK State */
    if (pRCC_OscInitStruct->MSIKState != RCC_MSIK_OFF)
 801233e:	687b      	ldr	r3, [r7, #4]
 8012340:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8012342:	2b00      	cmp	r3, #0
 8012344:	d062      	beq.n	801240c <HAL_RCC_OscConfig+0xaa0>
    {

      /* Selects the Multiple Speed of kernel high speed oscillator (MSIK) clock range .*/
      __HAL_RCC_MSIK_RANGE_CONFIG(pRCC_OscInitStruct->MSIKClockRange);
 8012346:	4b16      	ldr	r3, [pc, #88]	@ (80123a0 <HAL_RCC_OscConfig+0xa34>)
 8012348:	689b      	ldr	r3, [r3, #8]
 801234a:	4a15      	ldr	r2, [pc, #84]	@ (80123a0 <HAL_RCC_OscConfig+0xa34>)
 801234c:	f443 0300 	orr.w	r3, r3, #8388608	@ 0x800000
 8012350:	6093      	str	r3, [r2, #8]
 8012352:	4b13      	ldr	r3, [pc, #76]	@ (80123a0 <HAL_RCC_OscConfig+0xa34>)
 8012354:	689b      	ldr	r3, [r3, #8]
 8012356:	f023 6270 	bic.w	r2, r3, #251658240	@ 0xf000000
 801235a:	687b      	ldr	r3, [r7, #4]
 801235c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 801235e:	4910      	ldr	r1, [pc, #64]	@ (80123a0 <HAL_RCC_OscConfig+0xa34>)
 8012360:	4313      	orrs	r3, r2
 8012362:	608b      	str	r3, [r1, #8]
      /* Adjusts the Multiple Speed of kernel high speed oscillator (MSIK) calibration value.*/
      __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST((pRCC_OscInitStruct->MSICalibrationValue), \
 8012364:	687b      	ldr	r3, [r7, #4]
 8012366:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8012368:	f1b3 4f40 	cmp.w	r3, #3221225472	@ 0xc0000000
 801236c:	d309      	bcc.n	8012382 <HAL_RCC_OscConfig+0xa16>
 801236e:	4b0c      	ldr	r3, [pc, #48]	@ (80123a0 <HAL_RCC_OscConfig+0xa34>)
 8012370:	68db      	ldr	r3, [r3, #12]
 8012372:	f023 021f 	bic.w	r2, r3, #31
 8012376:	687b      	ldr	r3, [r7, #4]
 8012378:	6a1b      	ldr	r3, [r3, #32]
 801237a:	4909      	ldr	r1, [pc, #36]	@ (80123a0 <HAL_RCC_OscConfig+0xa34>)
 801237c:	4313      	orrs	r3, r2
 801237e:	60cb      	str	r3, [r1, #12]
 8012380:	e02a      	b.n	80123d8 <HAL_RCC_OscConfig+0xa6c>
 8012382:	687b      	ldr	r3, [r7, #4]
 8012384:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8012386:	2b00      	cmp	r3, #0
 8012388:	da0c      	bge.n	80123a4 <HAL_RCC_OscConfig+0xa38>
 801238a:	4b05      	ldr	r3, [pc, #20]	@ (80123a0 <HAL_RCC_OscConfig+0xa34>)
 801238c:	68db      	ldr	r3, [r3, #12]
 801238e:	f423 7278 	bic.w	r2, r3, #992	@ 0x3e0
 8012392:	687b      	ldr	r3, [r7, #4]
 8012394:	6a1b      	ldr	r3, [r3, #32]
 8012396:	015b      	lsls	r3, r3, #5
 8012398:	4901      	ldr	r1, [pc, #4]	@ (80123a0 <HAL_RCC_OscConfig+0xa34>)
 801239a:	4313      	orrs	r3, r2
 801239c:	60cb      	str	r3, [r1, #12]
 801239e:	e01b      	b.n	80123d8 <HAL_RCC_OscConfig+0xa6c>
 80123a0:	46020c00 	.word	0x46020c00
 80123a4:	687b      	ldr	r3, [r7, #4]
 80123a6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80123a8:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 80123ac:	d30a      	bcc.n	80123c4 <HAL_RCC_OscConfig+0xa58>
 80123ae:	4ba1      	ldr	r3, [pc, #644]	@ (8012634 <HAL_RCC_OscConfig+0xcc8>)
 80123b0:	68db      	ldr	r3, [r3, #12]
 80123b2:	f423 42f8 	bic.w	r2, r3, #31744	@ 0x7c00
 80123b6:	687b      	ldr	r3, [r7, #4]
 80123b8:	6a1b      	ldr	r3, [r3, #32]
 80123ba:	029b      	lsls	r3, r3, #10
 80123bc:	499d      	ldr	r1, [pc, #628]	@ (8012634 <HAL_RCC_OscConfig+0xcc8>)
 80123be:	4313      	orrs	r3, r2
 80123c0:	60cb      	str	r3, [r1, #12]
 80123c2:	e009      	b.n	80123d8 <HAL_RCC_OscConfig+0xa6c>
 80123c4:	4b9b      	ldr	r3, [pc, #620]	@ (8012634 <HAL_RCC_OscConfig+0xcc8>)
 80123c6:	68db      	ldr	r3, [r3, #12]
 80123c8:	f423 2278 	bic.w	r2, r3, #1015808	@ 0xf8000
 80123cc:	687b      	ldr	r3, [r7, #4]
 80123ce:	6a1b      	ldr	r3, [r3, #32]
 80123d0:	03db      	lsls	r3, r3, #15
 80123d2:	4998      	ldr	r1, [pc, #608]	@ (8012634 <HAL_RCC_OscConfig+0xcc8>)
 80123d4:	4313      	orrs	r3, r2
 80123d6:	60cb      	str	r3, [r1, #12]
                                            (pRCC_OscInitStruct->MSIClockRange));

      /* Enable the Internal kernel High Speed oscillator (MSIK) */
      __HAL_RCC_MSIK_ENABLE();
 80123d8:	4b96      	ldr	r3, [pc, #600]	@ (8012634 <HAL_RCC_OscConfig+0xcc8>)
 80123da:	681b      	ldr	r3, [r3, #0]
 80123dc:	4a95      	ldr	r2, [pc, #596]	@ (8012634 <HAL_RCC_OscConfig+0xcc8>)
 80123de:	f043 0310 	orr.w	r3, r3, #16
 80123e2:	6013      	str	r3, [r2, #0]

      tickstart = HAL_GetTick();
 80123e4:	f7fb fb3c 	bl	800da60 <HAL_GetTick>
 80123e8:	62b8      	str	r0, [r7, #40]	@ 0x28

      /* Wait till MSIK is ready */
      while (READ_BIT(RCC->CR, RCC_CR_MSIKRDY) == 0U)
 80123ea:	e008      	b.n	80123fe <HAL_RCC_OscConfig+0xa92>
      {
        if ((HAL_GetTick() - tickstart) > MSIK_TIMEOUT_VALUE)
 80123ec:	f7fb fb38 	bl	800da60 <HAL_GetTick>
 80123f0:	4602      	mov	r2, r0
 80123f2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80123f4:	1ad3      	subs	r3, r2, r3
 80123f6:	2b02      	cmp	r3, #2
 80123f8:	d901      	bls.n	80123fe <HAL_RCC_OscConfig+0xa92>
        {
          return HAL_TIMEOUT;
 80123fa:	2303      	movs	r3, #3
 80123fc:	e18b      	b.n	8012716 <HAL_RCC_OscConfig+0xdaa>
      while (READ_BIT(RCC->CR, RCC_CR_MSIKRDY) == 0U)
 80123fe:	4b8d      	ldr	r3, [pc, #564]	@ (8012634 <HAL_RCC_OscConfig+0xcc8>)
 8012400:	681b      	ldr	r3, [r3, #0]
 8012402:	f003 0320 	and.w	r3, r3, #32
 8012406:	2b00      	cmp	r3, #0
 8012408:	d0f0      	beq.n	80123ec <HAL_RCC_OscConfig+0xa80>
 801240a:	e018      	b.n	801243e <HAL_RCC_OscConfig+0xad2>
      }
    }
    else
    {
      /* Disable the Internal High Speed Kernel oscillator (MSIK) */
      __HAL_RCC_MSIK_DISABLE();
 801240c:	4b89      	ldr	r3, [pc, #548]	@ (8012634 <HAL_RCC_OscConfig+0xcc8>)
 801240e:	681b      	ldr	r3, [r3, #0]
 8012410:	4a88      	ldr	r2, [pc, #544]	@ (8012634 <HAL_RCC_OscConfig+0xcc8>)
 8012412:	f023 0310 	bic.w	r3, r3, #16
 8012416:	6013      	str	r3, [r2, #0]

      tickstart = HAL_GetTick();
 8012418:	f7fb fb22 	bl	800da60 <HAL_GetTick>
 801241c:	62b8      	str	r0, [r7, #40]	@ 0x28

      /* Wait till MSIK is disabled */
      while (READ_BIT(RCC->CR, RCC_CR_MSIKRDY) != 0U)
 801241e:	e008      	b.n	8012432 <HAL_RCC_OscConfig+0xac6>
      {
        if ((HAL_GetTick() - tickstart) > MSIK_TIMEOUT_VALUE)
 8012420:	f7fb fb1e 	bl	800da60 <HAL_GetTick>
 8012424:	4602      	mov	r2, r0
 8012426:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8012428:	1ad3      	subs	r3, r2, r3
 801242a:	2b02      	cmp	r3, #2
 801242c:	d901      	bls.n	8012432 <HAL_RCC_OscConfig+0xac6>
        {
          return HAL_TIMEOUT;
 801242e:	2303      	movs	r3, #3
 8012430:	e171      	b.n	8012716 <HAL_RCC_OscConfig+0xdaa>
      while (READ_BIT(RCC->CR, RCC_CR_MSIKRDY) != 0U)
 8012432:	4b80      	ldr	r3, [pc, #512]	@ (8012634 <HAL_RCC_OscConfig+0xcc8>)
 8012434:	681b      	ldr	r3, [r3, #0]
 8012436:	f003 0320 	and.w	r3, r3, #32
 801243a:	2b00      	cmp	r3, #0
 801243c:	d1f0      	bne.n	8012420 <HAL_RCC_OscConfig+0xab4>
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(pRCC_OscInitStruct->PLL.PLLState));

  if ((pRCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 801243e:	687b      	ldr	r3, [r7, #4]
 8012440:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8012442:	2b00      	cmp	r3, #0
 8012444:	f000 8166 	beq.w	8012714 <HAL_RCC_OscConfig+0xda8>
  {
    FlagStatus  pwrclkchanged = RESET;
 8012448:	2300      	movs	r3, #0
 801244a:	f887 3034 	strb.w	r3, [r7, #52]	@ 0x34

    /* Check if the PLL is used as system clock or not */
    if (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 801244e:	4b79      	ldr	r3, [pc, #484]	@ (8012634 <HAL_RCC_OscConfig+0xcc8>)
 8012450:	69db      	ldr	r3, [r3, #28]
 8012452:	f003 030c 	and.w	r3, r3, #12
 8012456:	2b0c      	cmp	r3, #12
 8012458:	f000 80f2 	beq.w	8012640 <HAL_RCC_OscConfig+0xcd4>
    {
      if ((pRCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 801245c:	687b      	ldr	r3, [r7, #4]
 801245e:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8012460:	2b02      	cmp	r3, #2
 8012462:	f040 80c5 	bne.w	80125f0 <HAL_RCC_OscConfig+0xc84>
        assert_param(IS_RCC_PLLP_VALUE(pRCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(pRCC_OscInitStruct->PLL.PLLQ));
        assert_param(IS_RCC_PLLR_VALUE(pRCC_OscInitStruct->PLL.PLLR));

        /* Disable the main PLL */
        __HAL_RCC_PLL_DISABLE();
 8012466:	4b73      	ldr	r3, [pc, #460]	@ (8012634 <HAL_RCC_OscConfig+0xcc8>)
 8012468:	681b      	ldr	r3, [r3, #0]
 801246a:	4a72      	ldr	r2, [pc, #456]	@ (8012634 <HAL_RCC_OscConfig+0xcc8>)
 801246c:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
 8012470:	6013      	str	r3, [r2, #0]

        tickstart = HAL_GetTick();
 8012472:	f7fb faf5 	bl	800da60 <HAL_GetTick>
 8012476:	62b8      	str	r0, [r7, #40]	@ 0x28

        /* Wait till PLL is disabled */
        while (READ_BIT(RCC->CR, RCC_CR_PLL1RDY) != 0U)
 8012478:	e008      	b.n	801248c <HAL_RCC_OscConfig+0xb20>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 801247a:	f7fb faf1 	bl	800da60 <HAL_GetTick>
 801247e:	4602      	mov	r2, r0
 8012480:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8012482:	1ad3      	subs	r3, r2, r3
 8012484:	2b02      	cmp	r3, #2
 8012486:	d901      	bls.n	801248c <HAL_RCC_OscConfig+0xb20>
          {
            return HAL_TIMEOUT;
 8012488:	2303      	movs	r3, #3
 801248a:	e144      	b.n	8012716 <HAL_RCC_OscConfig+0xdaa>
        while (READ_BIT(RCC->CR, RCC_CR_PLL1RDY) != 0U)
 801248c:	4b69      	ldr	r3, [pc, #420]	@ (8012634 <HAL_RCC_OscConfig+0xcc8>)
 801248e:	681b      	ldr	r3, [r3, #0]
 8012490:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 8012494:	2b00      	cmp	r3, #0
 8012496:	d1f0      	bne.n	801247a <HAL_RCC_OscConfig+0xb0e>
          }
        }

        /* Requires to enable write access to Backup Domain of necessary */
        if (__HAL_RCC_PWR_IS_CLK_DISABLED())
 8012498:	4b66      	ldr	r3, [pc, #408]	@ (8012634 <HAL_RCC_OscConfig+0xcc8>)
 801249a:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 801249e:	f003 0304 	and.w	r3, r3, #4
 80124a2:	2b00      	cmp	r3, #0
 80124a4:	d111      	bne.n	80124ca <HAL_RCC_OscConfig+0xb5e>
        {
          __HAL_RCC_PWR_CLK_ENABLE();
 80124a6:	4b63      	ldr	r3, [pc, #396]	@ (8012634 <HAL_RCC_OscConfig+0xcc8>)
 80124a8:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 80124ac:	4a61      	ldr	r2, [pc, #388]	@ (8012634 <HAL_RCC_OscConfig+0xcc8>)
 80124ae:	f043 0304 	orr.w	r3, r3, #4
 80124b2:	f8c2 3094 	str.w	r3, [r2, #148]	@ 0x94
 80124b6:	4b5f      	ldr	r3, [pc, #380]	@ (8012634 <HAL_RCC_OscConfig+0xcc8>)
 80124b8:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 80124bc:	f003 0304 	and.w	r3, r3, #4
 80124c0:	60fb      	str	r3, [r7, #12]
 80124c2:	68fb      	ldr	r3, [r7, #12]
          pwrclkchanged = SET;
 80124c4:	2301      	movs	r3, #1
 80124c6:	f887 3034 	strb.w	r3, [r7, #52]	@ 0x34
        }

        /*Disable EPOD to configure PLL1MBOOST*/
        if (READ_BIT(PWR->VOSR, PWR_VOSR_BOOSTEN) == PWR_VOSR_BOOSTEN)
 80124ca:	4b5b      	ldr	r3, [pc, #364]	@ (8012638 <HAL_RCC_OscConfig+0xccc>)
 80124cc:	68db      	ldr	r3, [r3, #12]
 80124ce:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
 80124d2:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 80124d6:	d102      	bne.n	80124de <HAL_RCC_OscConfig+0xb72>
        {
          pwrboosten = SET;
 80124d8:	2301      	movs	r3, #1
 80124da:	f887 3037 	strb.w	r3, [r7, #55]	@ 0x37
        }
        CLEAR_BIT(PWR->VOSR, PWR_VOSR_BOOSTEN);
 80124de:	4b56      	ldr	r3, [pc, #344]	@ (8012638 <HAL_RCC_OscConfig+0xccc>)
 80124e0:	68db      	ldr	r3, [r3, #12]
 80124e2:	4a55      	ldr	r2, [pc, #340]	@ (8012638 <HAL_RCC_OscConfig+0xccc>)
 80124e4:	f423 2380 	bic.w	r3, r3, #262144	@ 0x40000
 80124e8:	60d3      	str	r3, [r2, #12]

        /* Configure the main PLL clock source, multiplication and division factors */
        __HAL_RCC_PLL_CONFIG(pRCC_OscInitStruct->PLL.PLLSource,
 80124ea:	4b52      	ldr	r3, [pc, #328]	@ (8012634 <HAL_RCC_OscConfig+0xcc8>)
 80124ec:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80124ee:	f423 437f 	bic.w	r3, r3, #65280	@ 0xff00
 80124f2:	f023 0303 	bic.w	r3, r3, #3
 80124f6:	687a      	ldr	r2, [r7, #4]
 80124f8:	6bd1      	ldr	r1, [r2, #60]	@ 0x3c
 80124fa:	687a      	ldr	r2, [r7, #4]
 80124fc:	6c12      	ldr	r2, [r2, #64]	@ 0x40
 80124fe:	3a01      	subs	r2, #1
 8012500:	0212      	lsls	r2, r2, #8
 8012502:	4311      	orrs	r1, r2
 8012504:	687a      	ldr	r2, [r7, #4]
 8012506:	6c52      	ldr	r2, [r2, #68]	@ 0x44
 8012508:	430a      	orrs	r2, r1
 801250a:	494a      	ldr	r1, [pc, #296]	@ (8012634 <HAL_RCC_OscConfig+0xcc8>)
 801250c:	4313      	orrs	r3, r2
 801250e:	628b      	str	r3, [r1, #40]	@ 0x28
 8012510:	4b48      	ldr	r3, [pc, #288]	@ (8012634 <HAL_RCC_OscConfig+0xcc8>)
 8012512:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8012514:	4b49      	ldr	r3, [pc, #292]	@ (801263c <HAL_RCC_OscConfig+0xcd0>)
 8012516:	4013      	ands	r3, r2
 8012518:	687a      	ldr	r2, [r7, #4]
 801251a:	6c92      	ldr	r2, [r2, #72]	@ 0x48
 801251c:	3a01      	subs	r2, #1
 801251e:	f3c2 0108 	ubfx	r1, r2, #0, #9
 8012522:	687a      	ldr	r2, [r7, #4]
 8012524:	6cd2      	ldr	r2, [r2, #76]	@ 0x4c
 8012526:	3a01      	subs	r2, #1
 8012528:	0252      	lsls	r2, r2, #9
 801252a:	b292      	uxth	r2, r2
 801252c:	4311      	orrs	r1, r2
 801252e:	687a      	ldr	r2, [r7, #4]
 8012530:	6d12      	ldr	r2, [r2, #80]	@ 0x50
 8012532:	3a01      	subs	r2, #1
 8012534:	0412      	lsls	r2, r2, #16
 8012536:	f402 02fe 	and.w	r2, r2, #8323072	@ 0x7f0000
 801253a:	4311      	orrs	r1, r2
 801253c:	687a      	ldr	r2, [r7, #4]
 801253e:	6d52      	ldr	r2, [r2, #84]	@ 0x54
 8012540:	3a01      	subs	r2, #1
 8012542:	0612      	lsls	r2, r2, #24
 8012544:	f002 42fe 	and.w	r2, r2, #2130706432	@ 0x7f000000
 8012548:	430a      	orrs	r2, r1
 801254a:	493a      	ldr	r1, [pc, #232]	@ (8012634 <HAL_RCC_OscConfig+0xcc8>)
 801254c:	4313      	orrs	r3, r2
 801254e:	634b      	str	r3, [r1, #52]	@ 0x34
                             pRCC_OscInitStruct->PLL.PLLR);

        assert_param(IS_RCC_PLL_FRACN_VALUE(pRCC_OscInitStruct->PLL.PLLFRACN));

        /* Disable PLL1FRACN  */
        __HAL_RCC_PLL_FRACN_DISABLE();
 8012550:	4b38      	ldr	r3, [pc, #224]	@ (8012634 <HAL_RCC_OscConfig+0xcc8>)
 8012552:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8012554:	4a37      	ldr	r2, [pc, #220]	@ (8012634 <HAL_RCC_OscConfig+0xcc8>)
 8012556:	f023 0310 	bic.w	r3, r3, #16
 801255a:	6293      	str	r3, [r2, #40]	@ 0x28

        /* Configure PLL  PLL1FRACN */
        __HAL_RCC_PLL_FRACN_CONFIG(pRCC_OscInitStruct->PLL.PLLFRACN);
 801255c:	687b      	ldr	r3, [r7, #4]
 801255e:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8012560:	4a34      	ldr	r2, [pc, #208]	@ (8012634 <HAL_RCC_OscConfig+0xcc8>)
 8012562:	00db      	lsls	r3, r3, #3
 8012564:	6393      	str	r3, [r2, #56]	@ 0x38

        /* Enable PLL1FRACN  */
        __HAL_RCC_PLL_FRACN_ENABLE();
 8012566:	4b33      	ldr	r3, [pc, #204]	@ (8012634 <HAL_RCC_OscConfig+0xcc8>)
 8012568:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 801256a:	4a32      	ldr	r2, [pc, #200]	@ (8012634 <HAL_RCC_OscConfig+0xcc8>)
 801256c:	f043 0310 	orr.w	r3, r3, #16
 8012570:	6293      	str	r3, [r2, #40]	@ 0x28

        assert_param(IS_RCC_PLLRGE_VALUE(pRCC_OscInitStruct->PLL.PLLRGE));

        /* Select PLL1 input reference frequency range: VCI */
        __HAL_RCC_PLL_VCIRANGE(pRCC_OscInitStruct->PLL.PLLRGE);
 8012572:	4b30      	ldr	r3, [pc, #192]	@ (8012634 <HAL_RCC_OscConfig+0xcc8>)
 8012574:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8012576:	f023 020c 	bic.w	r2, r3, #12
 801257a:	687b      	ldr	r3, [r7, #4]
 801257c:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 801257e:	492d      	ldr	r1, [pc, #180]	@ (8012634 <HAL_RCC_OscConfig+0xcc8>)
 8012580:	4313      	orrs	r3, r2
 8012582:	628b      	str	r3, [r1, #40]	@ 0x28

        if (pwrboosten == SET)
 8012584:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
 8012588:	2b01      	cmp	r3, #1
 801258a:	d105      	bne.n	8012598 <HAL_RCC_OscConfig+0xc2c>
        {
          /* Enable the EPOD to reach max frequency */
          SET_BIT(PWR->VOSR, PWR_VOSR_BOOSTEN);
 801258c:	4b2a      	ldr	r3, [pc, #168]	@ (8012638 <HAL_RCC_OscConfig+0xccc>)
 801258e:	68db      	ldr	r3, [r3, #12]
 8012590:	4a29      	ldr	r2, [pc, #164]	@ (8012638 <HAL_RCC_OscConfig+0xccc>)
 8012592:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
 8012596:	60d3      	str	r3, [r2, #12]
        }

        /* Restore clock configuration if changed */
        if (pwrclkchanged == SET)
 8012598:	f897 3034 	ldrb.w	r3, [r7, #52]	@ 0x34
 801259c:	2b01      	cmp	r3, #1
 801259e:	d107      	bne.n	80125b0 <HAL_RCC_OscConfig+0xc44>
        {
          __HAL_RCC_PWR_CLK_DISABLE();
 80125a0:	4b24      	ldr	r3, [pc, #144]	@ (8012634 <HAL_RCC_OscConfig+0xcc8>)
 80125a2:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 80125a6:	4a23      	ldr	r2, [pc, #140]	@ (8012634 <HAL_RCC_OscConfig+0xcc8>)
 80125a8:	f023 0304 	bic.w	r3, r3, #4
 80125ac:	f8c2 3094 	str.w	r3, [r2, #148]	@ 0x94
        }

        /* Enable the main PLL */
        __HAL_RCC_PLL_ENABLE();
 80125b0:	4b20      	ldr	r3, [pc, #128]	@ (8012634 <HAL_RCC_OscConfig+0xcc8>)
 80125b2:	681b      	ldr	r3, [r3, #0]
 80125b4:	4a1f      	ldr	r2, [pc, #124]	@ (8012634 <HAL_RCC_OscConfig+0xcc8>)
 80125b6:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
 80125ba:	6013      	str	r3, [r2, #0]

        tickstart = HAL_GetTick();
 80125bc:	f7fb fa50 	bl	800da60 <HAL_GetTick>
 80125c0:	62b8      	str	r0, [r7, #40]	@ 0x28

        /* Wait till PLL is ready */
        while (READ_BIT(RCC->CR, RCC_CR_PLL1RDY) == 0U)
 80125c2:	e008      	b.n	80125d6 <HAL_RCC_OscConfig+0xc6a>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 80125c4:	f7fb fa4c 	bl	800da60 <HAL_GetTick>
 80125c8:	4602      	mov	r2, r0
 80125ca:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80125cc:	1ad3      	subs	r3, r2, r3
 80125ce:	2b02      	cmp	r3, #2
 80125d0:	d901      	bls.n	80125d6 <HAL_RCC_OscConfig+0xc6a>
          {
            return HAL_TIMEOUT;
 80125d2:	2303      	movs	r3, #3
 80125d4:	e09f      	b.n	8012716 <HAL_RCC_OscConfig+0xdaa>
        while (READ_BIT(RCC->CR, RCC_CR_PLL1RDY) == 0U)
 80125d6:	4b17      	ldr	r3, [pc, #92]	@ (8012634 <HAL_RCC_OscConfig+0xcc8>)
 80125d8:	681b      	ldr	r3, [r3, #0]
 80125da:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 80125de:	2b00      	cmp	r3, #0
 80125e0:	d0f0      	beq.n	80125c4 <HAL_RCC_OscConfig+0xc58>
          }
        }

        /* Enable PLL System Clock output */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVR);
 80125e2:	4b14      	ldr	r3, [pc, #80]	@ (8012634 <HAL_RCC_OscConfig+0xcc8>)
 80125e4:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80125e6:	4a13      	ldr	r2, [pc, #76]	@ (8012634 <HAL_RCC_OscConfig+0xcc8>)
 80125e8:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
 80125ec:	6293      	str	r3, [r2, #40]	@ 0x28
 80125ee:	e091      	b.n	8012714 <HAL_RCC_OscConfig+0xda8>

      }
      else
      {
        /* Disable the main PLL */
        __HAL_RCC_PLL_DISABLE();
 80125f0:	4b10      	ldr	r3, [pc, #64]	@ (8012634 <HAL_RCC_OscConfig+0xcc8>)
 80125f2:	681b      	ldr	r3, [r3, #0]
 80125f4:	4a0f      	ldr	r2, [pc, #60]	@ (8012634 <HAL_RCC_OscConfig+0xcc8>)
 80125f6:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
 80125fa:	6013      	str	r3, [r2, #0]

        tickstart = HAL_GetTick();
 80125fc:	f7fb fa30 	bl	800da60 <HAL_GetTick>
 8012600:	62b8      	str	r0, [r7, #40]	@ 0x28

        /* Wait till PLL is disabled */
        while (READ_BIT(RCC->CR, RCC_CR_PLL1RDY) != 0U)
 8012602:	e008      	b.n	8012616 <HAL_RCC_OscConfig+0xcaa>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8012604:	f7fb fa2c 	bl	800da60 <HAL_GetTick>
 8012608:	4602      	mov	r2, r0
 801260a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801260c:	1ad3      	subs	r3, r2, r3
 801260e:	2b02      	cmp	r3, #2
 8012610:	d901      	bls.n	8012616 <HAL_RCC_OscConfig+0xcaa>
          {
            return HAL_TIMEOUT;
 8012612:	2303      	movs	r3, #3
 8012614:	e07f      	b.n	8012716 <HAL_RCC_OscConfig+0xdaa>
        while (READ_BIT(RCC->CR, RCC_CR_PLL1RDY) != 0U)
 8012616:	4b07      	ldr	r3, [pc, #28]	@ (8012634 <HAL_RCC_OscConfig+0xcc8>)
 8012618:	681b      	ldr	r3, [r3, #0]
 801261a:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 801261e:	2b00      	cmp	r3, #0
 8012620:	d1f0      	bne.n	8012604 <HAL_RCC_OscConfig+0xc98>
          }
        }

        /* Unselect main PLL clock source and disable main PLL outputs to save power */
        RCC->PLL1CFGR &= ~(RCC_PLL1CFGR_PLL1SRC | RCC_PLL1CFGR_PLL1PEN | RCC_PLL1CFGR_PLL1QEN | RCC_PLL1CFGR_PLL1REN);
 8012622:	4b04      	ldr	r3, [pc, #16]	@ (8012634 <HAL_RCC_OscConfig+0xcc8>)
 8012624:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8012626:	4a03      	ldr	r2, [pc, #12]	@ (8012634 <HAL_RCC_OscConfig+0xcc8>)
 8012628:	f423 23e0 	bic.w	r3, r3, #458752	@ 0x70000
 801262c:	f023 0303 	bic.w	r3, r3, #3
 8012630:	6293      	str	r3, [r2, #40]	@ 0x28
 8012632:	e06f      	b.n	8012714 <HAL_RCC_OscConfig+0xda8>
 8012634:	46020c00 	.word	0x46020c00
 8012638:	46020800 	.word	0x46020800
 801263c:	80800000 	.word	0x80800000
      }
    }
    else
    {
      /* Do not return HAL_ERROR if request repeats the current configuration */
      temp1_pllckcfg = RCC->PLL1CFGR;
 8012640:	4b37      	ldr	r3, [pc, #220]	@ (8012720 <HAL_RCC_OscConfig+0xdb4>)
 8012642:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8012644:	61fb      	str	r3, [r7, #28]
      temp2_pllckcfg = RCC->PLL1DIVR;
 8012646:	4b36      	ldr	r3, [pc, #216]	@ (8012720 <HAL_RCC_OscConfig+0xdb4>)
 8012648:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 801264a:	61bb      	str	r3, [r7, #24]
      if (((pRCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 801264c:	687b      	ldr	r3, [r7, #4]
 801264e:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8012650:	2b01      	cmp	r3, #1
 8012652:	d039      	beq.n	80126c8 <HAL_RCC_OscConfig+0xd5c>
          (READ_BIT(temp1_pllckcfg, RCC_PLL1CFGR_PLL1SRC) != pRCC_OscInitStruct->PLL.PLLSource) ||
 8012654:	69fb      	ldr	r3, [r7, #28]
 8012656:	f003 0203 	and.w	r2, r3, #3
 801265a:	687b      	ldr	r3, [r7, #4]
 801265c:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
      if (((pRCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 801265e:	429a      	cmp	r2, r3
 8012660:	d132      	bne.n	80126c8 <HAL_RCC_OscConfig+0xd5c>
          ((READ_BIT(temp1_pllckcfg, RCC_PLL1CFGR_PLL1M) >> \
 8012662:	69fb      	ldr	r3, [r7, #28]
 8012664:	0a1b      	lsrs	r3, r3, #8
 8012666:	f003 020f 	and.w	r2, r3, #15
            RCC_PLL1CFGR_PLL1M_Pos) != (pRCC_OscInitStruct->PLL.PLLM - 1U)) ||
 801266a:	687b      	ldr	r3, [r7, #4]
 801266c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 801266e:	3b01      	subs	r3, #1
          (READ_BIT(temp1_pllckcfg, RCC_PLL1CFGR_PLL1SRC) != pRCC_OscInitStruct->PLL.PLLSource) ||
 8012670:	429a      	cmp	r2, r3
 8012672:	d129      	bne.n	80126c8 <HAL_RCC_OscConfig+0xd5c>
          (READ_BIT(temp1_pllckcfg, RCC_PLL1CFGR_PLL1MBOOST) != pRCC_OscInitStruct->PLL.PLLMBOOST) ||
 8012674:	69fb      	ldr	r3, [r7, #28]
 8012676:	f403 4270 	and.w	r2, r3, #61440	@ 0xf000
 801267a:	687b      	ldr	r3, [r7, #4]
 801267c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
            RCC_PLL1CFGR_PLL1M_Pos) != (pRCC_OscInitStruct->PLL.PLLM - 1U)) ||
 801267e:	429a      	cmp	r2, r3
 8012680:	d122      	bne.n	80126c8 <HAL_RCC_OscConfig+0xd5c>
          (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_PLL1N) != (pRCC_OscInitStruct->PLL.PLLN - 1U)) ||
 8012682:	69bb      	ldr	r3, [r7, #24]
 8012684:	f3c3 0208 	ubfx	r2, r3, #0, #9
 8012688:	687b      	ldr	r3, [r7, #4]
 801268a:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 801268c:	3b01      	subs	r3, #1
          (READ_BIT(temp1_pllckcfg, RCC_PLL1CFGR_PLL1MBOOST) != pRCC_OscInitStruct->PLL.PLLMBOOST) ||
 801268e:	429a      	cmp	r2, r3
 8012690:	d11a      	bne.n	80126c8 <HAL_RCC_OscConfig+0xd5c>
          ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_PLL1P) >> \
 8012692:	69bb      	ldr	r3, [r7, #24]
 8012694:	0a5b      	lsrs	r3, r3, #9
 8012696:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
            RCC_PLL1DIVR_PLL1P_Pos) != (pRCC_OscInitStruct->PLL.PLLP - 1U)) ||
 801269a:	687b      	ldr	r3, [r7, #4]
 801269c:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 801269e:	3b01      	subs	r3, #1
          (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_PLL1N) != (pRCC_OscInitStruct->PLL.PLLN - 1U)) ||
 80126a0:	429a      	cmp	r2, r3
 80126a2:	d111      	bne.n	80126c8 <HAL_RCC_OscConfig+0xd5c>
          ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_PLL1Q) >> \
 80126a4:	69bb      	ldr	r3, [r7, #24]
 80126a6:	0c1b      	lsrs	r3, r3, #16
 80126a8:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
            RCC_PLL1DIVR_PLL1Q_Pos) != (pRCC_OscInitStruct->PLL.PLLQ - 1U)) ||
 80126ac:	687b      	ldr	r3, [r7, #4]
 80126ae:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 80126b0:	3b01      	subs	r3, #1
            RCC_PLL1DIVR_PLL1P_Pos) != (pRCC_OscInitStruct->PLL.PLLP - 1U)) ||
 80126b2:	429a      	cmp	r2, r3
 80126b4:	d108      	bne.n	80126c8 <HAL_RCC_OscConfig+0xd5c>
          ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_PLL1R) >> \
 80126b6:	69bb      	ldr	r3, [r7, #24]
 80126b8:	0e1b      	lsrs	r3, r3, #24
 80126ba:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
            RCC_PLL1DIVR_PLL1R_Pos) != (pRCC_OscInitStruct->PLL.PLLR - 1U)))
 80126be:	687b      	ldr	r3, [r7, #4]
 80126c0:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 80126c2:	3b01      	subs	r3, #1
            RCC_PLL1DIVR_PLL1Q_Pos) != (pRCC_OscInitStruct->PLL.PLLQ - 1U)) ||
 80126c4:	429a      	cmp	r2, r3
 80126c6:	d001      	beq.n	80126cc <HAL_RCC_OscConfig+0xd60>
      {
        return HAL_ERROR;
 80126c8:	2301      	movs	r3, #1
 80126ca:	e024      	b.n	8012716 <HAL_RCC_OscConfig+0xdaa>
      }

      /* FRACN1 on-the-fly value update */
      if ((READ_BIT(RCC->PLL1FRACR, RCC_PLL1FRACR_PLL1FRACN) >> \
 80126cc:	4b14      	ldr	r3, [pc, #80]	@ (8012720 <HAL_RCC_OscConfig+0xdb4>)
 80126ce:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80126d0:	08db      	lsrs	r3, r3, #3
 80126d2:	f3c3 020c 	ubfx	r2, r3, #0, #13
           RCC_PLL1FRACR_PLL1FRACN_Pos) != (pRCC_OscInitStruct->PLL.PLLFRACN))
 80126d6:	687b      	ldr	r3, [r7, #4]
 80126d8:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
      if ((READ_BIT(RCC->PLL1FRACR, RCC_PLL1FRACR_PLL1FRACN) >> \
 80126da:	429a      	cmp	r2, r3
 80126dc:	d01a      	beq.n	8012714 <HAL_RCC_OscConfig+0xda8>
      {
        assert_param(IS_RCC_PLL_FRACN_VALUE(pRCC_OscInitStruct->PLL.PLLFRACN));

        /* Disable PLL1FRACN. */
        __HAL_RCC_PLL_FRACN_DISABLE();
 80126de:	4b10      	ldr	r3, [pc, #64]	@ (8012720 <HAL_RCC_OscConfig+0xdb4>)
 80126e0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80126e2:	4a0f      	ldr	r2, [pc, #60]	@ (8012720 <HAL_RCC_OscConfig+0xdb4>)
 80126e4:	f023 0310 	bic.w	r3, r3, #16
 80126e8:	6293      	str	r3, [r2, #40]	@ 0x28

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80126ea:	f7fb f9b9 	bl	800da60 <HAL_GetTick>
 80126ee:	62b8      	str	r0, [r7, #40]	@ 0x28

        /* Wait at least 2 CK_REF (PLL1 input source divided by M) period to make sure next latched value
           will be taken into account. */
        while ((HAL_GetTick() - tickstart) < PLL_FRAC_WAIT_VALUE)
 80126f0:	bf00      	nop
 80126f2:	f7fb f9b5 	bl	800da60 <HAL_GetTick>
 80126f6:	4602      	mov	r2, r0
 80126f8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80126fa:	4293      	cmp	r3, r2
 80126fc:	d0f9      	beq.n	80126f2 <HAL_RCC_OscConfig+0xd86>
        {
        }

        /* Configure PLL PLL1FRACN */
        __HAL_RCC_PLL_FRACN_CONFIG(pRCC_OscInitStruct->PLL.PLLFRACN);
 80126fe:	687b      	ldr	r3, [r7, #4]
 8012700:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8012702:	4a07      	ldr	r2, [pc, #28]	@ (8012720 <HAL_RCC_OscConfig+0xdb4>)
 8012704:	00db      	lsls	r3, r3, #3
 8012706:	6393      	str	r3, [r2, #56]	@ 0x38

        /* Enable PLL1FRACN to latch the new value. */
        __HAL_RCC_PLL_FRACN_ENABLE();
 8012708:	4b05      	ldr	r3, [pc, #20]	@ (8012720 <HAL_RCC_OscConfig+0xdb4>)
 801270a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 801270c:	4a04      	ldr	r2, [pc, #16]	@ (8012720 <HAL_RCC_OscConfig+0xdb4>)
 801270e:	f043 0310 	orr.w	r3, r3, #16
 8012712:	6293      	str	r3, [r2, #40]	@ 0x28
      }
    }
  }
  return HAL_OK;
 8012714:	2300      	movs	r3, #0
}
 8012716:	4618      	mov	r0, r3
 8012718:	3738      	adds	r7, #56	@ 0x38
 801271a:	46bd      	mov	sp, r7
 801271c:	bd80      	pop	{r7, pc}
 801271e:	bf00      	nop
 8012720:	46020c00 	.word	0x46020c00

08012724 <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(const RCC_ClkInitTypeDef   *const pRCC_ClkInitStruct, uint32_t FLatency)
{
 8012724:	b580      	push	{r7, lr}
 8012726:	b086      	sub	sp, #24
 8012728:	af00      	add	r7, sp, #0
 801272a:	6078      	str	r0, [r7, #4]
 801272c:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status;
  uint32_t tickstart;

  /* Check Null pointer */
  if (pRCC_ClkInitStruct == NULL)
 801272e:	687b      	ldr	r3, [r7, #4]
 8012730:	2b00      	cmp	r3, #0
 8012732:	d101      	bne.n	8012738 <HAL_RCC_ClockConfig+0x14>
  {
    return HAL_ERROR;
 8012734:	2301      	movs	r3, #1
 8012736:	e1d9      	b.n	8012aec <HAL_RCC_ClockConfig+0x3c8>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
   must be correctly programmed according to the frequency of the CPU clock
   (HCLK) and the supply voltage of the device */

  /* Increasing the number of wait states because of higher CPU frequency */
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 8012738:	4b9b      	ldr	r3, [pc, #620]	@ (80129a8 <HAL_RCC_ClockConfig+0x284>)
 801273a:	681b      	ldr	r3, [r3, #0]
 801273c:	f003 030f 	and.w	r3, r3, #15
 8012740:	683a      	ldr	r2, [r7, #0]
 8012742:	429a      	cmp	r2, r3
 8012744:	d910      	bls.n	8012768 <HAL_RCC_ClockConfig+0x44>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8012746:	4b98      	ldr	r3, [pc, #608]	@ (80129a8 <HAL_RCC_ClockConfig+0x284>)
 8012748:	681b      	ldr	r3, [r3, #0]
 801274a:	f023 020f 	bic.w	r2, r3, #15
 801274e:	4996      	ldr	r1, [pc, #600]	@ (80129a8 <HAL_RCC_ClockConfig+0x284>)
 8012750:	683b      	ldr	r3, [r7, #0]
 8012752:	4313      	orrs	r3, r2
 8012754:	600b      	str	r3, [r1, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 8012756:	4b94      	ldr	r3, [pc, #592]	@ (80129a8 <HAL_RCC_ClockConfig+0x284>)
 8012758:	681b      	ldr	r3, [r3, #0]
 801275a:	f003 030f 	and.w	r3, r3, #15
 801275e:	683a      	ldr	r2, [r7, #0]
 8012760:	429a      	cmp	r2, r3
 8012762:	d001      	beq.n	8012768 <HAL_RCC_ClockConfig+0x44>
    {
      return HAL_ERROR;
 8012764:	2301      	movs	r3, #1
 8012766:	e1c1      	b.n	8012aec <HAL_RCC_ClockConfig+0x3c8>
    }
  }

  /* Increasing the BUS frequency divider */
  /*-------------------------- PCLK3 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK3) == RCC_CLOCKTYPE_PCLK3)
 8012768:	687b      	ldr	r3, [r7, #4]
 801276a:	681b      	ldr	r3, [r3, #0]
 801276c:	f003 0310 	and.w	r3, r3, #16
 8012770:	2b00      	cmp	r3, #0
 8012772:	d010      	beq.n	8012796 <HAL_RCC_ClockConfig+0x72>
  {
    if ((pRCC_ClkInitStruct->APB3CLKDivider) > (RCC->CFGR3 & RCC_CFGR3_PPRE3))
 8012774:	687b      	ldr	r3, [r7, #4]
 8012776:	695a      	ldr	r2, [r3, #20]
 8012778:	4b8c      	ldr	r3, [pc, #560]	@ (80129ac <HAL_RCC_ClockConfig+0x288>)
 801277a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801277c:	f003 0370 	and.w	r3, r3, #112	@ 0x70
 8012780:	429a      	cmp	r2, r3
 8012782:	d908      	bls.n	8012796 <HAL_RCC_ClockConfig+0x72>
    {
      assert_param(IS_RCC_PCLK(pRCC_ClkInitStruct->APB3CLKDivider));
      MODIFY_REG(RCC->CFGR3, RCC_CFGR3_PPRE3, pRCC_ClkInitStruct->APB3CLKDivider);
 8012784:	4b89      	ldr	r3, [pc, #548]	@ (80129ac <HAL_RCC_ClockConfig+0x288>)
 8012786:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8012788:	f023 0270 	bic.w	r2, r3, #112	@ 0x70
 801278c:	687b      	ldr	r3, [r7, #4]
 801278e:	695b      	ldr	r3, [r3, #20]
 8012790:	4986      	ldr	r1, [pc, #536]	@ (80129ac <HAL_RCC_ClockConfig+0x288>)
 8012792:	4313      	orrs	r3, r2
 8012794:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }
  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8012796:	687b      	ldr	r3, [r7, #4]
 8012798:	681b      	ldr	r3, [r3, #0]
 801279a:	f003 0308 	and.w	r3, r3, #8
 801279e:	2b00      	cmp	r3, #0
 80127a0:	d012      	beq.n	80127c8 <HAL_RCC_ClockConfig+0xa4>
  {
    if ((pRCC_ClkInitStruct->APB2CLKDivider) > ((RCC->CFGR2 & RCC_CFGR2_PPRE2) >> 4))
 80127a2:	687b      	ldr	r3, [r7, #4]
 80127a4:	691a      	ldr	r2, [r3, #16]
 80127a6:	4b81      	ldr	r3, [pc, #516]	@ (80129ac <HAL_RCC_ClockConfig+0x288>)
 80127a8:	6a1b      	ldr	r3, [r3, #32]
 80127aa:	091b      	lsrs	r3, r3, #4
 80127ac:	f003 0370 	and.w	r3, r3, #112	@ 0x70
 80127b0:	429a      	cmp	r2, r3
 80127b2:	d909      	bls.n	80127c8 <HAL_RCC_ClockConfig+0xa4>
    {
      assert_param(IS_RCC_PCLK(pRCC_ClkInitStruct->APB2CLKDivider));
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE2, ((pRCC_ClkInitStruct->APB2CLKDivider) << 4));
 80127b4:	4b7d      	ldr	r3, [pc, #500]	@ (80129ac <HAL_RCC_ClockConfig+0x288>)
 80127b6:	6a1b      	ldr	r3, [r3, #32]
 80127b8:	f423 62e0 	bic.w	r2, r3, #1792	@ 0x700
 80127bc:	687b      	ldr	r3, [r7, #4]
 80127be:	691b      	ldr	r3, [r3, #16]
 80127c0:	011b      	lsls	r3, r3, #4
 80127c2:	497a      	ldr	r1, [pc, #488]	@ (80129ac <HAL_RCC_ClockConfig+0x288>)
 80127c4:	4313      	orrs	r3, r2
 80127c6:	620b      	str	r3, [r1, #32]
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 80127c8:	687b      	ldr	r3, [r7, #4]
 80127ca:	681b      	ldr	r3, [r3, #0]
 80127cc:	f003 0304 	and.w	r3, r3, #4
 80127d0:	2b00      	cmp	r3, #0
 80127d2:	d010      	beq.n	80127f6 <HAL_RCC_ClockConfig+0xd2>
  {
    if ((pRCC_ClkInitStruct->APB1CLKDivider) > (RCC->CFGR2 & RCC_CFGR2_PPRE1))
 80127d4:	687b      	ldr	r3, [r7, #4]
 80127d6:	68da      	ldr	r2, [r3, #12]
 80127d8:	4b74      	ldr	r3, [pc, #464]	@ (80129ac <HAL_RCC_ClockConfig+0x288>)
 80127da:	6a1b      	ldr	r3, [r3, #32]
 80127dc:	f003 0370 	and.w	r3, r3, #112	@ 0x70
 80127e0:	429a      	cmp	r2, r3
 80127e2:	d908      	bls.n	80127f6 <HAL_RCC_ClockConfig+0xd2>
    {
      assert_param(IS_RCC_PCLK(pRCC_ClkInitStruct->APB1CLKDivider));
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE1, pRCC_ClkInitStruct->APB1CLKDivider);
 80127e4:	4b71      	ldr	r3, [pc, #452]	@ (80129ac <HAL_RCC_ClockConfig+0x288>)
 80127e6:	6a1b      	ldr	r3, [r3, #32]
 80127e8:	f023 0270 	bic.w	r2, r3, #112	@ 0x70
 80127ec:	687b      	ldr	r3, [r7, #4]
 80127ee:	68db      	ldr	r3, [r3, #12]
 80127f0:	496e      	ldr	r1, [pc, #440]	@ (80129ac <HAL_RCC_ClockConfig+0x288>)
 80127f2:	4313      	orrs	r3, r2
 80127f4:	620b      	str	r3, [r1, #32]
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 80127f6:	687b      	ldr	r3, [r7, #4]
 80127f8:	681b      	ldr	r3, [r3, #0]
 80127fa:	f003 0302 	and.w	r3, r3, #2
 80127fe:	2b00      	cmp	r3, #0
 8012800:	d010      	beq.n	8012824 <HAL_RCC_ClockConfig+0x100>
  {
    if ((pRCC_ClkInitStruct->AHBCLKDivider) > (RCC->CFGR2 & RCC_CFGR2_HPRE))
 8012802:	687b      	ldr	r3, [r7, #4]
 8012804:	689a      	ldr	r2, [r3, #8]
 8012806:	4b69      	ldr	r3, [pc, #420]	@ (80129ac <HAL_RCC_ClockConfig+0x288>)
 8012808:	6a1b      	ldr	r3, [r3, #32]
 801280a:	f003 030f 	and.w	r3, r3, #15
 801280e:	429a      	cmp	r2, r3
 8012810:	d908      	bls.n	8012824 <HAL_RCC_ClockConfig+0x100>
    {
      assert_param(IS_RCC_HCLK(pRCC_ClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_HPRE, pRCC_ClkInitStruct->AHBCLKDivider);
 8012812:	4b66      	ldr	r3, [pc, #408]	@ (80129ac <HAL_RCC_ClockConfig+0x288>)
 8012814:	6a1b      	ldr	r3, [r3, #32]
 8012816:	f023 020f 	bic.w	r2, r3, #15
 801281a:	687b      	ldr	r3, [r7, #4]
 801281c:	689b      	ldr	r3, [r3, #8]
 801281e:	4963      	ldr	r1, [pc, #396]	@ (80129ac <HAL_RCC_ClockConfig+0x288>)
 8012820:	4313      	orrs	r3, r2
 8012822:	620b      	str	r3, [r1, #32]
    }
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8012824:	687b      	ldr	r3, [r7, #4]
 8012826:	681b      	ldr	r3, [r3, #0]
 8012828:	f003 0301 	and.w	r3, r3, #1
 801282c:	2b00      	cmp	r3, #0
 801282e:	f000 80d2 	beq.w	80129d6 <HAL_RCC_ClockConfig+0x2b2>
  {
    assert_param(IS_RCC_SYSCLKSOURCE(pRCC_ClkInitStruct->SYSCLKSource));
    FlagStatus  pwrclkchanged = RESET;
 8012832:	2300      	movs	r3, #0
 8012834:	75fb      	strb	r3, [r7, #23]

    /* PLL is selected as System Clock Source */
    if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8012836:	687b      	ldr	r3, [r7, #4]
 8012838:	685b      	ldr	r3, [r3, #4]
 801283a:	2b03      	cmp	r3, #3
 801283c:	d143      	bne.n	80128c6 <HAL_RCC_ClockConfig+0x1a2>
    {
      if (__HAL_RCC_PWR_IS_CLK_DISABLED())
 801283e:	4b5b      	ldr	r3, [pc, #364]	@ (80129ac <HAL_RCC_ClockConfig+0x288>)
 8012840:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 8012844:	f003 0304 	and.w	r3, r3, #4
 8012848:	2b00      	cmp	r3, #0
 801284a:	d110      	bne.n	801286e <HAL_RCC_ClockConfig+0x14a>
      {
        __HAL_RCC_PWR_CLK_ENABLE();
 801284c:	4b57      	ldr	r3, [pc, #348]	@ (80129ac <HAL_RCC_ClockConfig+0x288>)
 801284e:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 8012852:	4a56      	ldr	r2, [pc, #344]	@ (80129ac <HAL_RCC_ClockConfig+0x288>)
 8012854:	f043 0304 	orr.w	r3, r3, #4
 8012858:	f8c2 3094 	str.w	r3, [r2, #148]	@ 0x94
 801285c:	4b53      	ldr	r3, [pc, #332]	@ (80129ac <HAL_RCC_ClockConfig+0x288>)
 801285e:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 8012862:	f003 0304 	and.w	r3, r3, #4
 8012866:	60bb      	str	r3, [r7, #8]
 8012868:	68bb      	ldr	r3, [r7, #8]
        pwrclkchanged = SET;
 801286a:	2301      	movs	r3, #1
 801286c:	75fb      	strb	r3, [r7, #23]
      }
      tickstart = HAL_GetTick();
 801286e:	f7fb f8f7 	bl	800da60 <HAL_GetTick>
 8012872:	6138      	str	r0, [r7, #16]
      /* Check if EPOD is enabled */
      if (READ_BIT(PWR->VOSR, PWR_VOSR_BOOSTEN) != 0U)
 8012874:	4b4e      	ldr	r3, [pc, #312]	@ (80129b0 <HAL_RCC_ClockConfig+0x28c>)
 8012876:	68db      	ldr	r3, [r3, #12]
 8012878:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
 801287c:	2b00      	cmp	r3, #0
 801287e:	d00f      	beq.n	80128a0 <HAL_RCC_ClockConfig+0x17c>
      {
        /* Wait till BOOST is ready */
        while (READ_BIT(PWR->VOSR, PWR_VOSR_BOOSTRDY) == 0U)
 8012880:	e008      	b.n	8012894 <HAL_RCC_ClockConfig+0x170>
        {
          if ((HAL_GetTick() - tickstart) > EPOD_TIMEOUT_VALUE)
 8012882:	f7fb f8ed 	bl	800da60 <HAL_GetTick>
 8012886:	4602      	mov	r2, r0
 8012888:	693b      	ldr	r3, [r7, #16]
 801288a:	1ad3      	subs	r3, r2, r3
 801288c:	2b02      	cmp	r3, #2
 801288e:	d901      	bls.n	8012894 <HAL_RCC_ClockConfig+0x170>
          {
            return HAL_TIMEOUT;
 8012890:	2303      	movs	r3, #3
 8012892:	e12b      	b.n	8012aec <HAL_RCC_ClockConfig+0x3c8>
        while (READ_BIT(PWR->VOSR, PWR_VOSR_BOOSTRDY) == 0U)
 8012894:	4b46      	ldr	r3, [pc, #280]	@ (80129b0 <HAL_RCC_ClockConfig+0x28c>)
 8012896:	68db      	ldr	r3, [r3, #12]
 8012898:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
 801289c:	2b00      	cmp	r3, #0
 801289e:	d0f0      	beq.n	8012882 <HAL_RCC_ClockConfig+0x15e>
          }
        }
      }

      /* Restore clock configuration if changed */
      if (pwrclkchanged == SET)
 80128a0:	7dfb      	ldrb	r3, [r7, #23]
 80128a2:	2b01      	cmp	r3, #1
 80128a4:	d107      	bne.n	80128b6 <HAL_RCC_ClockConfig+0x192>
      {
        __HAL_RCC_PWR_CLK_DISABLE();
 80128a6:	4b41      	ldr	r3, [pc, #260]	@ (80129ac <HAL_RCC_ClockConfig+0x288>)
 80128a8:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 80128ac:	4a3f      	ldr	r2, [pc, #252]	@ (80129ac <HAL_RCC_ClockConfig+0x288>)
 80128ae:	f023 0304 	bic.w	r3, r3, #4
 80128b2:	f8c2 3094 	str.w	r3, [r2, #148]	@ 0x94
      }

      /* Check the PLL ready flag */
      if (READ_BIT(RCC->CR, RCC_CR_PLL1RDY) == 0U)
 80128b6:	4b3d      	ldr	r3, [pc, #244]	@ (80129ac <HAL_RCC_ClockConfig+0x288>)
 80128b8:	681b      	ldr	r3, [r3, #0]
 80128ba:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 80128be:	2b00      	cmp	r3, #0
 80128c0:	d121      	bne.n	8012906 <HAL_RCC_ClockConfig+0x1e2>
      {
        return HAL_ERROR;
 80128c2:	2301      	movs	r3, #1
 80128c4:	e112      	b.n	8012aec <HAL_RCC_ClockConfig+0x3c8>
      }
    }
    else
    {
      /* HSE is selected as System Clock Source */
      if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80128c6:	687b      	ldr	r3, [r7, #4]
 80128c8:	685b      	ldr	r3, [r3, #4]
 80128ca:	2b02      	cmp	r3, #2
 80128cc:	d107      	bne.n	80128de <HAL_RCC_ClockConfig+0x1ba>
      {
        /* Check the HSE ready flag */
        if (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 80128ce:	4b37      	ldr	r3, [pc, #220]	@ (80129ac <HAL_RCC_ClockConfig+0x288>)
 80128d0:	681b      	ldr	r3, [r3, #0]
 80128d2:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 80128d6:	2b00      	cmp	r3, #0
 80128d8:	d115      	bne.n	8012906 <HAL_RCC_ClockConfig+0x1e2>
        {
          return HAL_ERROR;
 80128da:	2301      	movs	r3, #1
 80128dc:	e106      	b.n	8012aec <HAL_RCC_ClockConfig+0x3c8>
        }
      }
      /* MSI is selected as System Clock Source */
      else if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
 80128de:	687b      	ldr	r3, [r7, #4]
 80128e0:	685b      	ldr	r3, [r3, #4]
 80128e2:	2b00      	cmp	r3, #0
 80128e4:	d107      	bne.n	80128f6 <HAL_RCC_ClockConfig+0x1d2>
      {
        /* Check the MSI ready flag */
        if (READ_BIT(RCC->CR, RCC_CR_MSISRDY) == 0U)
 80128e6:	4b31      	ldr	r3, [pc, #196]	@ (80129ac <HAL_RCC_ClockConfig+0x288>)
 80128e8:	681b      	ldr	r3, [r3, #0]
 80128ea:	f003 0304 	and.w	r3, r3, #4
 80128ee:	2b00      	cmp	r3, #0
 80128f0:	d109      	bne.n	8012906 <HAL_RCC_ClockConfig+0x1e2>
        {
          return HAL_ERROR;
 80128f2:	2301      	movs	r3, #1
 80128f4:	e0fa      	b.n	8012aec <HAL_RCC_ClockConfig+0x3c8>
      }
      /* HSI is selected as System Clock Source */
      else
      {
        /* Check the HSI ready flag */
        if (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 80128f6:	4b2d      	ldr	r3, [pc, #180]	@ (80129ac <HAL_RCC_ClockConfig+0x288>)
 80128f8:	681b      	ldr	r3, [r3, #0]
 80128fa:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 80128fe:	2b00      	cmp	r3, #0
 8012900:	d101      	bne.n	8012906 <HAL_RCC_ClockConfig+0x1e2>
        {
          return HAL_ERROR;
 8012902:	2301      	movs	r3, #1
 8012904:	e0f2      	b.n	8012aec <HAL_RCC_ClockConfig+0x3c8>
        }
      }
    }

    MODIFY_REG(RCC->CFGR1, RCC_CFGR1_SW, pRCC_ClkInitStruct->SYSCLKSource);
 8012906:	4b29      	ldr	r3, [pc, #164]	@ (80129ac <HAL_RCC_ClockConfig+0x288>)
 8012908:	69db      	ldr	r3, [r3, #28]
 801290a:	f023 0203 	bic.w	r2, r3, #3
 801290e:	687b      	ldr	r3, [r7, #4]
 8012910:	685b      	ldr	r3, [r3, #4]
 8012912:	4926      	ldr	r1, [pc, #152]	@ (80129ac <HAL_RCC_ClockConfig+0x288>)
 8012914:	4313      	orrs	r3, r2
 8012916:	61cb      	str	r3, [r1, #28]

    tickstart = HAL_GetTick();
 8012918:	f7fb f8a2 	bl	800da60 <HAL_GetTick>
 801291c:	6138      	str	r0, [r7, #16]

    if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 801291e:	687b      	ldr	r3, [r7, #4]
 8012920:	685b      	ldr	r3, [r3, #4]
 8012922:	2b03      	cmp	r3, #3
 8012924:	d112      	bne.n	801294c <HAL_RCC_ClockConfig+0x228>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8012926:	e00a      	b.n	801293e <HAL_RCC_ClockConfig+0x21a>
      {
        if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8012928:	f7fb f89a 	bl	800da60 <HAL_GetTick>
 801292c:	4602      	mov	r2, r0
 801292e:	693b      	ldr	r3, [r7, #16]
 8012930:	1ad3      	subs	r3, r2, r3
 8012932:	f241 3288 	movw	r2, #5000	@ 0x1388
 8012936:	4293      	cmp	r3, r2
 8012938:	d901      	bls.n	801293e <HAL_RCC_ClockConfig+0x21a>
        {
          return HAL_TIMEOUT;
 801293a:	2303      	movs	r3, #3
 801293c:	e0d6      	b.n	8012aec <HAL_RCC_ClockConfig+0x3c8>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 801293e:	4b1b      	ldr	r3, [pc, #108]	@ (80129ac <HAL_RCC_ClockConfig+0x288>)
 8012940:	69db      	ldr	r3, [r3, #28]
 8012942:	f003 030c 	and.w	r3, r3, #12
 8012946:	2b0c      	cmp	r3, #12
 8012948:	d1ee      	bne.n	8012928 <HAL_RCC_ClockConfig+0x204>
 801294a:	e044      	b.n	80129d6 <HAL_RCC_ClockConfig+0x2b2>
        }
      }
    }
    else
    {
      if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 801294c:	687b      	ldr	r3, [r7, #4]
 801294e:	685b      	ldr	r3, [r3, #4]
 8012950:	2b02      	cmp	r3, #2
 8012952:	d112      	bne.n	801297a <HAL_RCC_ClockConfig+0x256>
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 8012954:	e00a      	b.n	801296c <HAL_RCC_ClockConfig+0x248>
        {
          if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8012956:	f7fb f883 	bl	800da60 <HAL_GetTick>
 801295a:	4602      	mov	r2, r0
 801295c:	693b      	ldr	r3, [r7, #16]
 801295e:	1ad3      	subs	r3, r2, r3
 8012960:	f241 3288 	movw	r2, #5000	@ 0x1388
 8012964:	4293      	cmp	r3, r2
 8012966:	d901      	bls.n	801296c <HAL_RCC_ClockConfig+0x248>
          {
            return HAL_TIMEOUT;
 8012968:	2303      	movs	r3, #3
 801296a:	e0bf      	b.n	8012aec <HAL_RCC_ClockConfig+0x3c8>
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 801296c:	4b0f      	ldr	r3, [pc, #60]	@ (80129ac <HAL_RCC_ClockConfig+0x288>)
 801296e:	69db      	ldr	r3, [r3, #28]
 8012970:	f003 030c 	and.w	r3, r3, #12
 8012974:	2b08      	cmp	r3, #8
 8012976:	d1ee      	bne.n	8012956 <HAL_RCC_ClockConfig+0x232>
 8012978:	e02d      	b.n	80129d6 <HAL_RCC_ClockConfig+0x2b2>
          }
        }
      }
      else if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
 801297a:	687b      	ldr	r3, [r7, #4]
 801297c:	685b      	ldr	r3, [r3, #4]
 801297e:	2b00      	cmp	r3, #0
 8012980:	d123      	bne.n	80129ca <HAL_RCC_ClockConfig+0x2a6>
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_MSI)
 8012982:	e00a      	b.n	801299a <HAL_RCC_ClockConfig+0x276>
        {
          if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8012984:	f7fb f86c 	bl	800da60 <HAL_GetTick>
 8012988:	4602      	mov	r2, r0
 801298a:	693b      	ldr	r3, [r7, #16]
 801298c:	1ad3      	subs	r3, r2, r3
 801298e:	f241 3288 	movw	r2, #5000	@ 0x1388
 8012992:	4293      	cmp	r3, r2
 8012994:	d901      	bls.n	801299a <HAL_RCC_ClockConfig+0x276>
          {
            return HAL_TIMEOUT;
 8012996:	2303      	movs	r3, #3
 8012998:	e0a8      	b.n	8012aec <HAL_RCC_ClockConfig+0x3c8>
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_MSI)
 801299a:	4b04      	ldr	r3, [pc, #16]	@ (80129ac <HAL_RCC_ClockConfig+0x288>)
 801299c:	69db      	ldr	r3, [r3, #28]
 801299e:	f003 030c 	and.w	r3, r3, #12
 80129a2:	2b00      	cmp	r3, #0
 80129a4:	d1ee      	bne.n	8012984 <HAL_RCC_ClockConfig+0x260>
 80129a6:	e016      	b.n	80129d6 <HAL_RCC_ClockConfig+0x2b2>
 80129a8:	40022000 	.word	0x40022000
 80129ac:	46020c00 	.word	0x46020c00
 80129b0:	46020800 	.word	0x46020800
      }
      else
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
        {
          if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 80129b4:	f7fb f854 	bl	800da60 <HAL_GetTick>
 80129b8:	4602      	mov	r2, r0
 80129ba:	693b      	ldr	r3, [r7, #16]
 80129bc:	1ad3      	subs	r3, r2, r3
 80129be:	f241 3288 	movw	r2, #5000	@ 0x1388
 80129c2:	4293      	cmp	r3, r2
 80129c4:	d901      	bls.n	80129ca <HAL_RCC_ClockConfig+0x2a6>
          {
            return HAL_TIMEOUT;
 80129c6:	2303      	movs	r3, #3
 80129c8:	e090      	b.n	8012aec <HAL_RCC_ClockConfig+0x3c8>
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 80129ca:	4b4a      	ldr	r3, [pc, #296]	@ (8012af4 <HAL_RCC_ClockConfig+0x3d0>)
 80129cc:	69db      	ldr	r3, [r3, #28]
 80129ce:	f003 030c 	and.w	r3, r3, #12
 80129d2:	2b04      	cmp	r3, #4
 80129d4:	d1ee      	bne.n	80129b4 <HAL_RCC_ClockConfig+0x290>
    }
  }

  /* Decreasing the BUS frequency divider */
  /*-------------------------- HCLK Configuration --------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 80129d6:	687b      	ldr	r3, [r7, #4]
 80129d8:	681b      	ldr	r3, [r3, #0]
 80129da:	f003 0302 	and.w	r3, r3, #2
 80129de:	2b00      	cmp	r3, #0
 80129e0:	d010      	beq.n	8012a04 <HAL_RCC_ClockConfig+0x2e0>
  {
    if ((pRCC_ClkInitStruct->AHBCLKDivider) < (RCC->CFGR2 & RCC_CFGR2_HPRE))
 80129e2:	687b      	ldr	r3, [r7, #4]
 80129e4:	689a      	ldr	r2, [r3, #8]
 80129e6:	4b43      	ldr	r3, [pc, #268]	@ (8012af4 <HAL_RCC_ClockConfig+0x3d0>)
 80129e8:	6a1b      	ldr	r3, [r3, #32]
 80129ea:	f003 030f 	and.w	r3, r3, #15
 80129ee:	429a      	cmp	r2, r3
 80129f0:	d208      	bcs.n	8012a04 <HAL_RCC_ClockConfig+0x2e0>
    {
      assert_param(IS_RCC_HCLK(pRCC_ClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_HPRE, pRCC_ClkInitStruct->AHBCLKDivider);
 80129f2:	4b40      	ldr	r3, [pc, #256]	@ (8012af4 <HAL_RCC_ClockConfig+0x3d0>)
 80129f4:	6a1b      	ldr	r3, [r3, #32]
 80129f6:	f023 020f 	bic.w	r2, r3, #15
 80129fa:	687b      	ldr	r3, [r7, #4]
 80129fc:	689b      	ldr	r3, [r3, #8]
 80129fe:	493d      	ldr	r1, [pc, #244]	@ (8012af4 <HAL_RCC_ClockConfig+0x3d0>)
 8012a00:	4313      	orrs	r3, r2
 8012a02:	620b      	str	r3, [r1, #32]
    }
  }

  /* Decreasing the number of wait states because of lower CPU frequency */
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 8012a04:	4b3c      	ldr	r3, [pc, #240]	@ (8012af8 <HAL_RCC_ClockConfig+0x3d4>)
 8012a06:	681b      	ldr	r3, [r3, #0]
 8012a08:	f003 030f 	and.w	r3, r3, #15
 8012a0c:	683a      	ldr	r2, [r7, #0]
 8012a0e:	429a      	cmp	r2, r3
 8012a10:	d210      	bcs.n	8012a34 <HAL_RCC_ClockConfig+0x310>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8012a12:	4b39      	ldr	r3, [pc, #228]	@ (8012af8 <HAL_RCC_ClockConfig+0x3d4>)
 8012a14:	681b      	ldr	r3, [r3, #0]
 8012a16:	f023 020f 	bic.w	r2, r3, #15
 8012a1a:	4937      	ldr	r1, [pc, #220]	@ (8012af8 <HAL_RCC_ClockConfig+0x3d4>)
 8012a1c:	683b      	ldr	r3, [r7, #0]
 8012a1e:	4313      	orrs	r3, r2
 8012a20:	600b      	str	r3, [r1, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 8012a22:	4b35      	ldr	r3, [pc, #212]	@ (8012af8 <HAL_RCC_ClockConfig+0x3d4>)
 8012a24:	681b      	ldr	r3, [r3, #0]
 8012a26:	f003 030f 	and.w	r3, r3, #15
 8012a2a:	683a      	ldr	r2, [r7, #0]
 8012a2c:	429a      	cmp	r2, r3
 8012a2e:	d001      	beq.n	8012a34 <HAL_RCC_ClockConfig+0x310>
    {
      return HAL_ERROR;
 8012a30:	2301      	movs	r3, #1
 8012a32:	e05b      	b.n	8012aec <HAL_RCC_ClockConfig+0x3c8>
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8012a34:	687b      	ldr	r3, [r7, #4]
 8012a36:	681b      	ldr	r3, [r3, #0]
 8012a38:	f003 0304 	and.w	r3, r3, #4
 8012a3c:	2b00      	cmp	r3, #0
 8012a3e:	d010      	beq.n	8012a62 <HAL_RCC_ClockConfig+0x33e>
  {
    if ((pRCC_ClkInitStruct->APB1CLKDivider) < (RCC->CFGR2 & RCC_CFGR2_PPRE1))
 8012a40:	687b      	ldr	r3, [r7, #4]
 8012a42:	68da      	ldr	r2, [r3, #12]
 8012a44:	4b2b      	ldr	r3, [pc, #172]	@ (8012af4 <HAL_RCC_ClockConfig+0x3d0>)
 8012a46:	6a1b      	ldr	r3, [r3, #32]
 8012a48:	f003 0370 	and.w	r3, r3, #112	@ 0x70
 8012a4c:	429a      	cmp	r2, r3
 8012a4e:	d208      	bcs.n	8012a62 <HAL_RCC_ClockConfig+0x33e>
    {
      assert_param(IS_RCC_PCLK(pRCC_ClkInitStruct->APB1CLKDivider));
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE1, pRCC_ClkInitStruct->APB1CLKDivider);
 8012a50:	4b28      	ldr	r3, [pc, #160]	@ (8012af4 <HAL_RCC_ClockConfig+0x3d0>)
 8012a52:	6a1b      	ldr	r3, [r3, #32]
 8012a54:	f023 0270 	bic.w	r2, r3, #112	@ 0x70
 8012a58:	687b      	ldr	r3, [r7, #4]
 8012a5a:	68db      	ldr	r3, [r3, #12]
 8012a5c:	4925      	ldr	r1, [pc, #148]	@ (8012af4 <HAL_RCC_ClockConfig+0x3d0>)
 8012a5e:	4313      	orrs	r3, r2
 8012a60:	620b      	str	r3, [r1, #32]
    }
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8012a62:	687b      	ldr	r3, [r7, #4]
 8012a64:	681b      	ldr	r3, [r3, #0]
 8012a66:	f003 0308 	and.w	r3, r3, #8
 8012a6a:	2b00      	cmp	r3, #0
 8012a6c:	d012      	beq.n	8012a94 <HAL_RCC_ClockConfig+0x370>
  {
    if ((pRCC_ClkInitStruct->APB2CLKDivider) < ((RCC->CFGR2 & RCC_CFGR2_PPRE2) >> 4))
 8012a6e:	687b      	ldr	r3, [r7, #4]
 8012a70:	691a      	ldr	r2, [r3, #16]
 8012a72:	4b20      	ldr	r3, [pc, #128]	@ (8012af4 <HAL_RCC_ClockConfig+0x3d0>)
 8012a74:	6a1b      	ldr	r3, [r3, #32]
 8012a76:	091b      	lsrs	r3, r3, #4
 8012a78:	f003 0370 	and.w	r3, r3, #112	@ 0x70
 8012a7c:	429a      	cmp	r2, r3
 8012a7e:	d209      	bcs.n	8012a94 <HAL_RCC_ClockConfig+0x370>
    {
      assert_param(IS_RCC_PCLK(pRCC_ClkInitStruct->APB2CLKDivider));
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE2, ((pRCC_ClkInitStruct->APB2CLKDivider) << 4));
 8012a80:	4b1c      	ldr	r3, [pc, #112]	@ (8012af4 <HAL_RCC_ClockConfig+0x3d0>)
 8012a82:	6a1b      	ldr	r3, [r3, #32]
 8012a84:	f423 62e0 	bic.w	r2, r3, #1792	@ 0x700
 8012a88:	687b      	ldr	r3, [r7, #4]
 8012a8a:	691b      	ldr	r3, [r3, #16]
 8012a8c:	011b      	lsls	r3, r3, #4
 8012a8e:	4919      	ldr	r1, [pc, #100]	@ (8012af4 <HAL_RCC_ClockConfig+0x3d0>)
 8012a90:	4313      	orrs	r3, r2
 8012a92:	620b      	str	r3, [r1, #32]
    }
  }

  /*-------------------------- PCLK3 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK3) == RCC_CLOCKTYPE_PCLK3)
 8012a94:	687b      	ldr	r3, [r7, #4]
 8012a96:	681b      	ldr	r3, [r3, #0]
 8012a98:	f003 0310 	and.w	r3, r3, #16
 8012a9c:	2b00      	cmp	r3, #0
 8012a9e:	d010      	beq.n	8012ac2 <HAL_RCC_ClockConfig+0x39e>
  {
    if ((pRCC_ClkInitStruct->APB3CLKDivider) < (RCC->CFGR3 & RCC_CFGR3_PPRE3))
 8012aa0:	687b      	ldr	r3, [r7, #4]
 8012aa2:	695a      	ldr	r2, [r3, #20]
 8012aa4:	4b13      	ldr	r3, [pc, #76]	@ (8012af4 <HAL_RCC_ClockConfig+0x3d0>)
 8012aa6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8012aa8:	f003 0370 	and.w	r3, r3, #112	@ 0x70
 8012aac:	429a      	cmp	r2, r3
 8012aae:	d208      	bcs.n	8012ac2 <HAL_RCC_ClockConfig+0x39e>
    {
      assert_param(IS_RCC_PCLK(pRCC_ClkInitStruct->APB3CLKDivider));
      MODIFY_REG(RCC->CFGR3, RCC_CFGR3_PPRE3, (pRCC_ClkInitStruct->APB3CLKDivider));
 8012ab0:	4b10      	ldr	r3, [pc, #64]	@ (8012af4 <HAL_RCC_ClockConfig+0x3d0>)
 8012ab2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8012ab4:	f023 0270 	bic.w	r2, r3, #112	@ 0x70
 8012ab8:	687b      	ldr	r3, [r7, #4]
 8012aba:	695b      	ldr	r3, [r3, #20]
 8012abc:	490d      	ldr	r1, [pc, #52]	@ (8012af4 <HAL_RCC_ClockConfig+0x3d0>)
 8012abe:	4313      	orrs	r3, r2
 8012ac0:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR2 & RCC_CFGR2_HPRE) >> RCC_CFGR2_HPRE_Pos];
 8012ac2:	f000 f821 	bl	8012b08 <HAL_RCC_GetSysClockFreq>
 8012ac6:	4602      	mov	r2, r0
 8012ac8:	4b0a      	ldr	r3, [pc, #40]	@ (8012af4 <HAL_RCC_ClockConfig+0x3d0>)
 8012aca:	6a1b      	ldr	r3, [r3, #32]
 8012acc:	f003 030f 	and.w	r3, r3, #15
 8012ad0:	490a      	ldr	r1, [pc, #40]	@ (8012afc <HAL_RCC_ClockConfig+0x3d8>)
 8012ad2:	5ccb      	ldrb	r3, [r1, r3]
 8012ad4:	fa22 f303 	lsr.w	r3, r2, r3
 8012ad8:	4a09      	ldr	r2, [pc, #36]	@ (8012b00 <HAL_RCC_ClockConfig+0x3dc>)
 8012ada:	6013      	str	r3, [r2, #0]

  /* Configure the source of time base considering new system clocks settings*/
  status = HAL_InitTick(uwTickPrio);
 8012adc:	4b09      	ldr	r3, [pc, #36]	@ (8012b04 <HAL_RCC_ClockConfig+0x3e0>)
 8012ade:	681b      	ldr	r3, [r3, #0]
 8012ae0:	4618      	mov	r0, r3
 8012ae2:	f7fa ff33 	bl	800d94c <HAL_InitTick>
 8012ae6:	4603      	mov	r3, r0
 8012ae8:	73fb      	strb	r3, [r7, #15]

  return status;
 8012aea:	7bfb      	ldrb	r3, [r7, #15]
}
 8012aec:	4618      	mov	r0, r3
 8012aee:	3718      	adds	r7, #24
 8012af0:	46bd      	mov	sp, r7
 8012af2:	bd80      	pop	{r7, pc}
 8012af4:	46020c00 	.word	0x46020c00
 8012af8:	40022000 	.word	0x40022000
 8012afc:	0802a4c8 	.word	0x0802a4c8
 8012b00:	200001e0 	.word	0x200001e0
 8012b04:	200001e4 	.word	0x200001e4

08012b08 <HAL_RCC_GetSysClockFreq>:
  * @note   Each time SYSCLK changes, this function must be called to update the
  *         right SYSCLK value. Otherwise, any configuration based on this function will be incorrect.
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 8012b08:	b480      	push	{r7}
 8012b0a:	b08b      	sub	sp, #44	@ 0x2c
 8012b0c:	af00      	add	r7, sp, #0
  uint32_t msirange = 0U;
 8012b0e:	2300      	movs	r3, #0
 8012b10:	627b      	str	r3, [r7, #36]	@ 0x24
  uint32_t pllsource;
  uint32_t pllr;
  uint32_t pllm;
  uint32_t pllfracen;
  uint32_t sysclockfreq = 0U;
 8012b12:	2300      	movs	r3, #0
 8012b14:	623b      	str	r3, [r7, #32]
  uint32_t sysclk_source;
  uint32_t pll_oscsource;
  float_t fracn1;
  float_t pllvco;

  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 8012b16:	4b78      	ldr	r3, [pc, #480]	@ (8012cf8 <HAL_RCC_GetSysClockFreq+0x1f0>)
 8012b18:	69db      	ldr	r3, [r3, #28]
 8012b1a:	f003 030c 	and.w	r3, r3, #12
 8012b1e:	61bb      	str	r3, [r7, #24]
  pll_oscsource = __HAL_RCC_GET_PLL_OSCSOURCE();
 8012b20:	4b75      	ldr	r3, [pc, #468]	@ (8012cf8 <HAL_RCC_GetSysClockFreq+0x1f0>)
 8012b22:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8012b24:	f003 0303 	and.w	r3, r3, #3
 8012b28:	617b      	str	r3, [r7, #20]

  if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI) ||
 8012b2a:	69bb      	ldr	r3, [r7, #24]
 8012b2c:	2b00      	cmp	r3, #0
 8012b2e:	d005      	beq.n	8012b3c <HAL_RCC_GetSysClockFreq+0x34>
 8012b30:	69bb      	ldr	r3, [r7, #24]
 8012b32:	2b0c      	cmp	r3, #12
 8012b34:	d121      	bne.n	8012b7a <HAL_RCC_GetSysClockFreq+0x72>
      ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_oscsource == RCC_PLLSOURCE_MSI)))
 8012b36:	697b      	ldr	r3, [r7, #20]
 8012b38:	2b01      	cmp	r3, #1
 8012b3a:	d11e      	bne.n	8012b7a <HAL_RCC_GetSysClockFreq+0x72>
  {
    /* MSI or PLL with MSI source used as system clock source */

    /* Get SYSCLK source */
    if (READ_BIT(RCC->ICSCR1, RCC_ICSCR1_MSIRGSEL) == 0U)
 8012b3c:	4b6e      	ldr	r3, [pc, #440]	@ (8012cf8 <HAL_RCC_GetSysClockFreq+0x1f0>)
 8012b3e:	689b      	ldr	r3, [r3, #8]
 8012b40:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 8012b44:	2b00      	cmp	r3, #0
 8012b46:	d107      	bne.n	8012b58 <HAL_RCC_GetSysClockFreq+0x50>
    {
      /* MSISRANGE from RCC_CSR applies */
      msirange = (RCC->CSR & RCC_CSR_MSISSRANGE) >> RCC_CSR_MSISSRANGE_Pos;
 8012b48:	4b6b      	ldr	r3, [pc, #428]	@ (8012cf8 <HAL_RCC_GetSysClockFreq+0x1f0>)
 8012b4a:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 8012b4e:	0b1b      	lsrs	r3, r3, #12
 8012b50:	f003 030f 	and.w	r3, r3, #15
 8012b54:	627b      	str	r3, [r7, #36]	@ 0x24
 8012b56:	e005      	b.n	8012b64 <HAL_RCC_GetSysClockFreq+0x5c>
    }
    else
    {
      /* MSIRANGE from RCC_CR applies */
      msirange = (RCC->ICSCR1 & RCC_ICSCR1_MSISRANGE) >> RCC_ICSCR1_MSISRANGE_Pos;
 8012b58:	4b67      	ldr	r3, [pc, #412]	@ (8012cf8 <HAL_RCC_GetSysClockFreq+0x1f0>)
 8012b5a:	689b      	ldr	r3, [r3, #8]
 8012b5c:	0f1b      	lsrs	r3, r3, #28
 8012b5e:	f003 030f 	and.w	r3, r3, #15
 8012b62:	627b      	str	r3, [r7, #36]	@ 0x24
    }
    /*MSI frequency range in HZ*/
    msirange = MSIRangeTable[msirange];
 8012b64:	4a65      	ldr	r2, [pc, #404]	@ (8012cfc <HAL_RCC_GetSysClockFreq+0x1f4>)
 8012b66:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012b68:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8012b6c:	627b      	str	r3, [r7, #36]	@ 0x24

    if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI)
 8012b6e:	69bb      	ldr	r3, [r7, #24]
 8012b70:	2b00      	cmp	r3, #0
 8012b72:	d110      	bne.n	8012b96 <HAL_RCC_GetSysClockFreq+0x8e>
    {
      /* MSI used as system clock source */
      sysclockfreq = msirange;
 8012b74:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012b76:	623b      	str	r3, [r7, #32]
    if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI)
 8012b78:	e00d      	b.n	8012b96 <HAL_RCC_GetSysClockFreq+0x8e>
    }
  }
  else if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI)
 8012b7a:	4b5f      	ldr	r3, [pc, #380]	@ (8012cf8 <HAL_RCC_GetSysClockFreq+0x1f0>)
 8012b7c:	69db      	ldr	r3, [r3, #28]
 8012b7e:	f003 030c 	and.w	r3, r3, #12
 8012b82:	2b04      	cmp	r3, #4
 8012b84:	d102      	bne.n	8012b8c <HAL_RCC_GetSysClockFreq+0x84>
  {
    /* HSI used as system clock source */
    sysclockfreq = HSI_VALUE;
 8012b86:	4b5e      	ldr	r3, [pc, #376]	@ (8012d00 <HAL_RCC_GetSysClockFreq+0x1f8>)
 8012b88:	623b      	str	r3, [r7, #32]
 8012b8a:	e004      	b.n	8012b96 <HAL_RCC_GetSysClockFreq+0x8e>
  }
  else if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSE)
 8012b8c:	69bb      	ldr	r3, [r7, #24]
 8012b8e:	2b08      	cmp	r3, #8
 8012b90:	d101      	bne.n	8012b96 <HAL_RCC_GetSysClockFreq+0x8e>
  {
    /* HSE used as system clock source */
    sysclockfreq = HSE_VALUE;
 8012b92:	4b5b      	ldr	r3, [pc, #364]	@ (8012d00 <HAL_RCC_GetSysClockFreq+0x1f8>)
 8012b94:	623b      	str	r3, [r7, #32]
  else
  {
    /* Nothing to do */
  }

  if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8012b96:	69bb      	ldr	r3, [r7, #24]
 8012b98:	2b0c      	cmp	r3, #12
 8012b9a:	f040 80a5 	bne.w	8012ce8 <HAL_RCC_GetSysClockFreq+0x1e0>
  {
    /* PLL used as system clock  source
       PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE/ PLLM) * PLLN
       SYSCLK = PLL_VCO / PLLR
    */
    pllsource = (RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1SRC);
 8012b9e:	4b56      	ldr	r3, [pc, #344]	@ (8012cf8 <HAL_RCC_GetSysClockFreq+0x1f0>)
 8012ba0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8012ba2:	f003 0303 	and.w	r3, r3, #3
 8012ba6:	613b      	str	r3, [r7, #16]
    pllm = ((RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1M) >> RCC_PLL1CFGR_PLL1M_Pos) + 1U;
 8012ba8:	4b53      	ldr	r3, [pc, #332]	@ (8012cf8 <HAL_RCC_GetSysClockFreq+0x1f0>)
 8012baa:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8012bac:	0a1b      	lsrs	r3, r3, #8
 8012bae:	f003 030f 	and.w	r3, r3, #15
 8012bb2:	3301      	adds	r3, #1
 8012bb4:	60fb      	str	r3, [r7, #12]
    pllfracen = ((RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1FRACEN) >> RCC_PLL1CFGR_PLL1FRACEN_Pos);
 8012bb6:	4b50      	ldr	r3, [pc, #320]	@ (8012cf8 <HAL_RCC_GetSysClockFreq+0x1f0>)
 8012bb8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8012bba:	091b      	lsrs	r3, r3, #4
 8012bbc:	f003 0301 	and.w	r3, r3, #1
 8012bc0:	60bb      	str	r3, [r7, #8]
    fracn1 = (float_t)(uint32_t)(pllfracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_PLL1FRACN) >> \
 8012bc2:	4b4d      	ldr	r3, [pc, #308]	@ (8012cf8 <HAL_RCC_GetSysClockFreq+0x1f0>)
 8012bc4:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8012bc6:	08db      	lsrs	r3, r3, #3
 8012bc8:	f3c3 030c 	ubfx	r3, r3, #0, #13
 8012bcc:	68ba      	ldr	r2, [r7, #8]
 8012bce:	fb02 f303 	mul.w	r3, r2, r3
 8012bd2:	ee07 3a90 	vmov	s15, r3
 8012bd6:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8012bda:	edc7 7a01 	vstr	s15, [r7, #4]
                                              RCC_PLL1FRACR_PLL1FRACN_Pos));

    switch (pllsource)
 8012bde:	693b      	ldr	r3, [r7, #16]
 8012be0:	2b02      	cmp	r3, #2
 8012be2:	d003      	beq.n	8012bec <HAL_RCC_GetSysClockFreq+0xe4>
 8012be4:	693b      	ldr	r3, [r7, #16]
 8012be6:	2b03      	cmp	r3, #3
 8012be8:	d022      	beq.n	8012c30 <HAL_RCC_GetSysClockFreq+0x128>
 8012bea:	e043      	b.n	8012c74 <HAL_RCC_GetSysClockFreq+0x16c>
    {
      case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
        pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 8012bec:	68fb      	ldr	r3, [r7, #12]
 8012bee:	ee07 3a90 	vmov	s15, r3
 8012bf2:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8012bf6:	eddf 6a43 	vldr	s13, [pc, #268]	@ 8012d04 <HAL_RCC_GetSysClockFreq+0x1fc>
 8012bfa:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8012bfe:	4b3e      	ldr	r3, [pc, #248]	@ (8012cf8 <HAL_RCC_GetSysClockFreq+0x1f0>)
 8012c00:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8012c02:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8012c06:	ee07 3a90 	vmov	s15, r3
 8012c0a:	eef8 6a67 	vcvt.f32.u32	s13, s15
                                                         (fracn1 / (float_t)0x2000) + (float_t)1U);
 8012c0e:	ed97 6a01 	vldr	s12, [r7, #4]
 8012c12:	eddf 5a3d 	vldr	s11, [pc, #244]	@ 8012d08 <HAL_RCC_GetSysClockFreq+0x200>
 8012c16:	eec6 7a25 	vdiv.f32	s15, s12, s11
        pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 8012c1a:	ee76 7aa7 	vadd.f32	s15, s13, s15
                                                         (fracn1 / (float_t)0x2000) + (float_t)1U);
 8012c1e:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8012c22:	ee77 7aa6 	vadd.f32	s15, s15, s13
        pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 8012c26:	ee67 7a27 	vmul.f32	s15, s14, s15
 8012c2a:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 8012c2e:	e046      	b.n	8012cbe <HAL_RCC_GetSysClockFreq+0x1b6>

      case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
        pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 8012c30:	68fb      	ldr	r3, [r7, #12]
 8012c32:	ee07 3a90 	vmov	s15, r3
 8012c36:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8012c3a:	eddf 6a32 	vldr	s13, [pc, #200]	@ 8012d04 <HAL_RCC_GetSysClockFreq+0x1fc>
 8012c3e:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8012c42:	4b2d      	ldr	r3, [pc, #180]	@ (8012cf8 <HAL_RCC_GetSysClockFreq+0x1f0>)
 8012c44:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8012c46:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8012c4a:	ee07 3a90 	vmov	s15, r3
 8012c4e:	eef8 6a67 	vcvt.f32.u32	s13, s15
                                                         (fracn1 / (float_t)0x2000) + (float_t)1U);
 8012c52:	ed97 6a01 	vldr	s12, [r7, #4]
 8012c56:	eddf 5a2c 	vldr	s11, [pc, #176]	@ 8012d08 <HAL_RCC_GetSysClockFreq+0x200>
 8012c5a:	eec6 7a25 	vdiv.f32	s15, s12, s11
        pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 8012c5e:	ee76 7aa7 	vadd.f32	s15, s13, s15
                                                         (fracn1 / (float_t)0x2000) + (float_t)1U);
 8012c62:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8012c66:	ee77 7aa6 	vadd.f32	s15, s15, s13
        pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 8012c6a:	ee67 7a27 	vmul.f32	s15, s14, s15
 8012c6e:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 8012c72:	e024      	b.n	8012cbe <HAL_RCC_GetSysClockFreq+0x1b6>

      case RCC_PLLSOURCE_MSI:  /* MSI used as PLL clock source */
      default:
        pllvco = ((float_t) msirange / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 8012c74:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012c76:	ee07 3a90 	vmov	s15, r3
 8012c7a:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8012c7e:	68fb      	ldr	r3, [r7, #12]
 8012c80:	ee07 3a90 	vmov	s15, r3
 8012c84:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8012c88:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8012c8c:	4b1a      	ldr	r3, [pc, #104]	@ (8012cf8 <HAL_RCC_GetSysClockFreq+0x1f0>)
 8012c8e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8012c90:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8012c94:	ee07 3a90 	vmov	s15, r3
 8012c98:	eef8 6a67 	vcvt.f32.u32	s13, s15
                                                         (fracn1 / (float_t)0x2000) + (float_t)1U);
 8012c9c:	ed97 6a01 	vldr	s12, [r7, #4]
 8012ca0:	eddf 5a19 	vldr	s11, [pc, #100]	@ 8012d08 <HAL_RCC_GetSysClockFreq+0x200>
 8012ca4:	eec6 7a25 	vdiv.f32	s15, s12, s11
        pllvco = ((float_t) msirange / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 8012ca8:	ee76 7aa7 	vadd.f32	s15, s13, s15
                                                         (fracn1 / (float_t)0x2000) + (float_t)1U);
 8012cac:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8012cb0:	ee77 7aa6 	vadd.f32	s15, s15, s13
        pllvco = ((float_t) msirange / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 8012cb4:	ee67 7a27 	vmul.f32	s15, s14, s15
 8012cb8:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 8012cbc:	bf00      	nop
    }

    pllr = (((RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1R) >> RCC_PLL1DIVR_PLL1R_Pos) + 1U);
 8012cbe:	4b0e      	ldr	r3, [pc, #56]	@ (8012cf8 <HAL_RCC_GetSysClockFreq+0x1f0>)
 8012cc0:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8012cc2:	0e1b      	lsrs	r3, r3, #24
 8012cc4:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8012cc8:	3301      	adds	r3, #1
 8012cca:	603b      	str	r3, [r7, #0]
    sysclockfreq = (uint32_t)(float_t)((float_t)pllvco / (float_t)pllr);
 8012ccc:	683b      	ldr	r3, [r7, #0]
 8012cce:	ee07 3a90 	vmov	s15, r3
 8012cd2:	eeb8 7a67 	vcvt.f32.u32	s14, s15
 8012cd6:	edd7 6a07 	vldr	s13, [r7, #28]
 8012cda:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8012cde:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8012ce2:	ee17 3a90 	vmov	r3, s15
 8012ce6:	623b      	str	r3, [r7, #32]
  }

  return sysclockfreq;
 8012ce8:	6a3b      	ldr	r3, [r7, #32]
}
 8012cea:	4618      	mov	r0, r3
 8012cec:	372c      	adds	r7, #44	@ 0x2c
 8012cee:	46bd      	mov	sp, r7
 8012cf0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012cf4:	4770      	bx	lr
 8012cf6:	bf00      	nop
 8012cf8:	46020c00 	.word	0x46020c00
 8012cfc:	0802a4e0 	.word	0x0802a4e0
 8012d00:	00f42400 	.word	0x00f42400
 8012d04:	4b742400 	.word	0x4b742400
 8012d08:	46000000 	.word	0x46000000

08012d0c <HAL_RCC_GetHCLKFreq>:
  *
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency.
  * @retval HCLK frequency in Hz
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 8012d0c:	b580      	push	{r7, lr}
 8012d0e:	af00      	add	r7, sp, #0
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR2 & RCC_CFGR2_HPRE) >> RCC_CFGR2_HPRE_Pos];
 8012d10:	f7ff fefa 	bl	8012b08 <HAL_RCC_GetSysClockFreq>
 8012d14:	4602      	mov	r2, r0
 8012d16:	4b07      	ldr	r3, [pc, #28]	@ (8012d34 <HAL_RCC_GetHCLKFreq+0x28>)
 8012d18:	6a1b      	ldr	r3, [r3, #32]
 8012d1a:	f003 030f 	and.w	r3, r3, #15
 8012d1e:	4906      	ldr	r1, [pc, #24]	@ (8012d38 <HAL_RCC_GetHCLKFreq+0x2c>)
 8012d20:	5ccb      	ldrb	r3, [r1, r3]
 8012d22:	fa22 f303 	lsr.w	r3, r2, r3
 8012d26:	4a05      	ldr	r2, [pc, #20]	@ (8012d3c <HAL_RCC_GetHCLKFreq+0x30>)
 8012d28:	6013      	str	r3, [r2, #0]
  return SystemCoreClock;
 8012d2a:	4b04      	ldr	r3, [pc, #16]	@ (8012d3c <HAL_RCC_GetHCLKFreq+0x30>)
 8012d2c:	681b      	ldr	r3, [r3, #0]
}
 8012d2e:	4618      	mov	r0, r3
 8012d30:	bd80      	pop	{r7, pc}
 8012d32:	bf00      	nop
 8012d34:	46020c00 	.word	0x46020c00
 8012d38:	0802a4c8 	.word	0x0802a4c8
 8012d3c:	200001e0 	.word	0x200001e0

08012d40 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 8012d40:	b580      	push	{r7, lr}
 8012d42:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR2 & RCC_CFGR2_PPRE1) >> RCC_CFGR2_PPRE1_Pos]);
 8012d44:	f7ff ffe2 	bl	8012d0c <HAL_RCC_GetHCLKFreq>
 8012d48:	4602      	mov	r2, r0
 8012d4a:	4b05      	ldr	r3, [pc, #20]	@ (8012d60 <HAL_RCC_GetPCLK1Freq+0x20>)
 8012d4c:	6a1b      	ldr	r3, [r3, #32]
 8012d4e:	091b      	lsrs	r3, r3, #4
 8012d50:	f003 0307 	and.w	r3, r3, #7
 8012d54:	4903      	ldr	r1, [pc, #12]	@ (8012d64 <HAL_RCC_GetPCLK1Freq+0x24>)
 8012d56:	5ccb      	ldrb	r3, [r1, r3]
 8012d58:	fa22 f303 	lsr.w	r3, r2, r3
}
 8012d5c:	4618      	mov	r0, r3
 8012d5e:	bd80      	pop	{r7, pc}
 8012d60:	46020c00 	.word	0x46020c00
 8012d64:	0802a4d8 	.word	0x0802a4d8

08012d68 <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK2 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
 8012d68:	b580      	push	{r7, lr}
 8012d6a:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR2 & RCC_CFGR2_PPRE2) >> RCC_CFGR2_PPRE2_Pos]);
 8012d6c:	f7ff ffce 	bl	8012d0c <HAL_RCC_GetHCLKFreq>
 8012d70:	4602      	mov	r2, r0
 8012d72:	4b05      	ldr	r3, [pc, #20]	@ (8012d88 <HAL_RCC_GetPCLK2Freq+0x20>)
 8012d74:	6a1b      	ldr	r3, [r3, #32]
 8012d76:	0a1b      	lsrs	r3, r3, #8
 8012d78:	f003 0307 	and.w	r3, r3, #7
 8012d7c:	4903      	ldr	r1, [pc, #12]	@ (8012d8c <HAL_RCC_GetPCLK2Freq+0x24>)
 8012d7e:	5ccb      	ldrb	r3, [r1, r3]
 8012d80:	fa22 f303 	lsr.w	r3, r2, r3
}
 8012d84:	4618      	mov	r0, r3
 8012d86:	bd80      	pop	{r7, pc}
 8012d88:	46020c00 	.word	0x46020c00
 8012d8c:	0802a4d8 	.word	0x0802a4d8

08012d90 <HAL_RCC_GetPCLK3Freq>:
  * @note   Each time PCLK3 changes, this function must be called to update the
  *         right PCLK3 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK3 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK3Freq(void)
{
 8012d90:	b580      	push	{r7, lr}
 8012d92:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR3 & RCC_CFGR3_PPRE3) >> RCC_CFGR3_PPRE3_Pos]);
 8012d94:	f7ff ffba 	bl	8012d0c <HAL_RCC_GetHCLKFreq>
 8012d98:	4602      	mov	r2, r0
 8012d9a:	4b05      	ldr	r3, [pc, #20]	@ (8012db0 <HAL_RCC_GetPCLK3Freq+0x20>)
 8012d9c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8012d9e:	091b      	lsrs	r3, r3, #4
 8012da0:	f003 0307 	and.w	r3, r3, #7
 8012da4:	4903      	ldr	r1, [pc, #12]	@ (8012db4 <HAL_RCC_GetPCLK3Freq+0x24>)
 8012da6:	5ccb      	ldrb	r3, [r1, r3]
 8012da8:	fa22 f303 	lsr.w	r3, r2, r3
}
 8012dac:	4618      	mov	r0, r3
 8012dae:	bd80      	pop	{r7, pc}
 8012db0:	46020c00 	.word	0x46020c00
 8012db4:	0802a4d8 	.word	0x0802a4d8

08012db8 <RCC_SetFlashLatencyFromMSIRange>:
            voltage range.
  * @param  msirange  MSI range value from RCC_MSIRANGE_0 to RCC_MSIRANGE_15
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t msirange)
{
 8012db8:	b580      	push	{r7, lr}
 8012dba:	b086      	sub	sp, #24
 8012dbc:	af00      	add	r7, sp, #0
 8012dbe:	6078      	str	r0, [r7, #4]
  uint32_t vos;
  uint32_t latency;  /* default value 0WS */

  if (__HAL_RCC_PWR_IS_CLK_ENABLED())
 8012dc0:	4b3e      	ldr	r3, [pc, #248]	@ (8012ebc <RCC_SetFlashLatencyFromMSIRange+0x104>)
 8012dc2:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 8012dc6:	f003 0304 	and.w	r3, r3, #4
 8012dca:	2b00      	cmp	r3, #0
 8012dcc:	d003      	beq.n	8012dd6 <RCC_SetFlashLatencyFromMSIRange+0x1e>
  {
    vos = HAL_PWREx_GetVoltageRange();
 8012dce:	f7fe fd4f 	bl	8011870 <HAL_PWREx_GetVoltageRange>
 8012dd2:	6178      	str	r0, [r7, #20]
 8012dd4:	e019      	b.n	8012e0a <RCC_SetFlashLatencyFromMSIRange+0x52>
  }
  else
  {
    __HAL_RCC_PWR_CLK_ENABLE();
 8012dd6:	4b39      	ldr	r3, [pc, #228]	@ (8012ebc <RCC_SetFlashLatencyFromMSIRange+0x104>)
 8012dd8:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 8012ddc:	4a37      	ldr	r2, [pc, #220]	@ (8012ebc <RCC_SetFlashLatencyFromMSIRange+0x104>)
 8012dde:	f043 0304 	orr.w	r3, r3, #4
 8012de2:	f8c2 3094 	str.w	r3, [r2, #148]	@ 0x94
 8012de6:	4b35      	ldr	r3, [pc, #212]	@ (8012ebc <RCC_SetFlashLatencyFromMSIRange+0x104>)
 8012de8:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 8012dec:	f003 0304 	and.w	r3, r3, #4
 8012df0:	60fb      	str	r3, [r7, #12]
 8012df2:	68fb      	ldr	r3, [r7, #12]
    vos = HAL_PWREx_GetVoltageRange();
 8012df4:	f7fe fd3c 	bl	8011870 <HAL_PWREx_GetVoltageRange>
 8012df8:	6178      	str	r0, [r7, #20]
    __HAL_RCC_PWR_CLK_DISABLE();
 8012dfa:	4b30      	ldr	r3, [pc, #192]	@ (8012ebc <RCC_SetFlashLatencyFromMSIRange+0x104>)
 8012dfc:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 8012e00:	4a2e      	ldr	r2, [pc, #184]	@ (8012ebc <RCC_SetFlashLatencyFromMSIRange+0x104>)
 8012e02:	f023 0304 	bic.w	r3, r3, #4
 8012e06:	f8c2 3094 	str.w	r3, [r2, #148]	@ 0x94
  }

  if ((vos == PWR_REGULATOR_VOLTAGE_SCALE1) || (vos == PWR_REGULATOR_VOLTAGE_SCALE2))
 8012e0a:	697b      	ldr	r3, [r7, #20]
 8012e0c:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
 8012e10:	d003      	beq.n	8012e1a <RCC_SetFlashLatencyFromMSIRange+0x62>
 8012e12:	697b      	ldr	r3, [r7, #20]
 8012e14:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 8012e18:	d109      	bne.n	8012e2e <RCC_SetFlashLatencyFromMSIRange+0x76>
  {

    if (msirange < RCC_MSIRANGE_1)
 8012e1a:	687b      	ldr	r3, [r7, #4]
 8012e1c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 8012e20:	d202      	bcs.n	8012e28 <RCC_SetFlashLatencyFromMSIRange+0x70>
    {
      /* MSI = 48Mhz */
      latency = FLASH_LATENCY_1; /* 1WS */
 8012e22:	2301      	movs	r3, #1
 8012e24:	613b      	str	r3, [r7, #16]
    if (msirange < RCC_MSIRANGE_1)
 8012e26:	e033      	b.n	8012e90 <RCC_SetFlashLatencyFromMSIRange+0xd8>
    }
    else
    {
      /*  MSI < 48Mhz */
      latency = FLASH_LATENCY_0; /* 0WS */
 8012e28:	2300      	movs	r3, #0
 8012e2a:	613b      	str	r3, [r7, #16]
    if (msirange < RCC_MSIRANGE_1)
 8012e2c:	e030      	b.n	8012e90 <RCC_SetFlashLatencyFromMSIRange+0xd8>
    }
  }
  else
  {
    if (msirange < RCC_MSIRANGE_1)
 8012e2e:	687b      	ldr	r3, [r7, #4]
 8012e30:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 8012e34:	d208      	bcs.n	8012e48 <RCC_SetFlashLatencyFromMSIRange+0x90>
    {
      /* MSI = 48Mhz */
      if (vos == PWR_REGULATOR_VOLTAGE_SCALE3)
 8012e36:	697b      	ldr	r3, [r7, #20]
 8012e38:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 8012e3c:	d102      	bne.n	8012e44 <RCC_SetFlashLatencyFromMSIRange+0x8c>
      {
        latency = FLASH_LATENCY_3; /* 3WS */
 8012e3e:	2303      	movs	r3, #3
 8012e40:	613b      	str	r3, [r7, #16]
 8012e42:	e025      	b.n	8012e90 <RCC_SetFlashLatencyFromMSIRange+0xd8>
      }
      else
      {
        return HAL_ERROR;
 8012e44:	2301      	movs	r3, #1
 8012e46:	e035      	b.n	8012eb4 <RCC_SetFlashLatencyFromMSIRange+0xfc>
      }
    }
    else
    {
      if (msirange > RCC_MSIRANGE_2)
 8012e48:	687b      	ldr	r3, [r7, #4]
 8012e4a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8012e4e:	d90f      	bls.n	8012e70 <RCC_SetFlashLatencyFromMSIRange+0xb8>
      {
        if (vos == PWR_REGULATOR_VOLTAGE_SCALE4)
 8012e50:	697b      	ldr	r3, [r7, #20]
 8012e52:	2b00      	cmp	r3, #0
 8012e54:	d109      	bne.n	8012e6a <RCC_SetFlashLatencyFromMSIRange+0xb2>
        {
          if (msirange > RCC_MSIRANGE_3)
 8012e56:	687b      	ldr	r3, [r7, #4]
 8012e58:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
 8012e5c:	d902      	bls.n	8012e64 <RCC_SetFlashLatencyFromMSIRange+0xac>
          {
            latency = FLASH_LATENCY_0; /* 1WS */
 8012e5e:	2300      	movs	r3, #0
 8012e60:	613b      	str	r3, [r7, #16]
 8012e62:	e015      	b.n	8012e90 <RCC_SetFlashLatencyFromMSIRange+0xd8>
          }
          else
          {
            latency = FLASH_LATENCY_1; /* 0WS */
 8012e64:	2301      	movs	r3, #1
 8012e66:	613b      	str	r3, [r7, #16]
 8012e68:	e012      	b.n	8012e90 <RCC_SetFlashLatencyFromMSIRange+0xd8>
          }
        }
        else
        {
          latency = FLASH_LATENCY_0; /* 0WS */
 8012e6a:	2300      	movs	r3, #0
 8012e6c:	613b      	str	r3, [r7, #16]
 8012e6e:	e00f      	b.n	8012e90 <RCC_SetFlashLatencyFromMSIRange+0xd8>
        }
      }
      else
      {
        if (msirange == RCC_MSIRANGE_1)
 8012e70:	687b      	ldr	r3, [r7, #4]
 8012e72:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 8012e76:	d109      	bne.n	8012e8c <RCC_SetFlashLatencyFromMSIRange+0xd4>
        {
          if (vos == PWR_REGULATOR_VOLTAGE_SCALE3)
 8012e78:	697b      	ldr	r3, [r7, #20]
 8012e7a:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 8012e7e:	d102      	bne.n	8012e86 <RCC_SetFlashLatencyFromMSIRange+0xce>
          {
            latency = FLASH_LATENCY_1; /* 1WS */
 8012e80:	2301      	movs	r3, #1
 8012e82:	613b      	str	r3, [r7, #16]
 8012e84:	e004      	b.n	8012e90 <RCC_SetFlashLatencyFromMSIRange+0xd8>
          }
          else
          {
            latency = FLASH_LATENCY_2; /* 2WS */
 8012e86:	2302      	movs	r3, #2
 8012e88:	613b      	str	r3, [r7, #16]
 8012e8a:	e001      	b.n	8012e90 <RCC_SetFlashLatencyFromMSIRange+0xd8>
          }
        }
        else
        {
          latency = FLASH_LATENCY_1; /* 1WS */
 8012e8c:	2301      	movs	r3, #1
 8012e8e:	613b      	str	r3, [r7, #16]
        }
      }
    }
  }

  __HAL_FLASH_SET_LATENCY(latency);
 8012e90:	4b0b      	ldr	r3, [pc, #44]	@ (8012ec0 <RCC_SetFlashLatencyFromMSIRange+0x108>)
 8012e92:	681b      	ldr	r3, [r3, #0]
 8012e94:	f023 020f 	bic.w	r2, r3, #15
 8012e98:	4909      	ldr	r1, [pc, #36]	@ (8012ec0 <RCC_SetFlashLatencyFromMSIRange+0x108>)
 8012e9a:	693b      	ldr	r3, [r7, #16]
 8012e9c:	4313      	orrs	r3, r2
 8012e9e:	600b      	str	r3, [r1, #0]

  /* Check that the new number of wait states is taken into account to access the Flash
  memory by reading the FLASH_ACR register */
  if ((FLASH->ACR & FLASH_ACR_LATENCY) != latency)
 8012ea0:	4b07      	ldr	r3, [pc, #28]	@ (8012ec0 <RCC_SetFlashLatencyFromMSIRange+0x108>)
 8012ea2:	681b      	ldr	r3, [r3, #0]
 8012ea4:	f003 030f 	and.w	r3, r3, #15
 8012ea8:	693a      	ldr	r2, [r7, #16]
 8012eaa:	429a      	cmp	r2, r3
 8012eac:	d001      	beq.n	8012eb2 <RCC_SetFlashLatencyFromMSIRange+0xfa>
  {
    return HAL_ERROR;
 8012eae:	2301      	movs	r3, #1
 8012eb0:	e000      	b.n	8012eb4 <RCC_SetFlashLatencyFromMSIRange+0xfc>
  }

  return HAL_OK;
 8012eb2:	2300      	movs	r3, #0
}
 8012eb4:	4618      	mov	r0, r3
 8012eb6:	3718      	adds	r7, #24
 8012eb8:	46bd      	mov	sp, r7
 8012eba:	bd80      	pop	{r7, pc}
 8012ebc:	46020c00 	.word	0x46020c00
 8012ec0:	40022000 	.word	0x40022000

08012ec4 <HAL_RCCEx_PeriphCLKConfig>:
  * @retval HAL status
  *
  *         (*) value not defined in all devices.
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(const RCC_PeriphCLKInitTypeDef  *pPeriphClkInit)
{
 8012ec4:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8012ec8:	b0ba      	sub	sp, #232	@ 0xe8
 8012eca:	af00      	add	r7, sp, #0
 8012ecc:	f8c7 00d4 	str.w	r0, [r7, #212]	@ 0xd4
  uint32_t tmpregister;
  uint32_t tickstart;
  HAL_StatusTypeDef ret = HAL_OK;      /* Intermediate status */
 8012ed0:	2300      	movs	r3, #0
 8012ed2:	f887 30e3 	strb.w	r3, [r7, #227]	@ 0xe3
  HAL_StatusTypeDef status = HAL_OK;   /* Final status */
 8012ed6:	2300      	movs	r3, #0
 8012ed8:	f887 30e2 	strb.w	r3, [r7, #226]	@ 0xe2

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(pPeriphClkInit->PeriphClockSelection));

  /*-------------------------- USART1 clock source configuration -------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 8012edc:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8012ee0:	e9d3 2300 	ldrd	r2, r3, [r3]
 8012ee4:	f002 0401 	and.w	r4, r2, #1
 8012ee8:	2500      	movs	r5, #0
 8012eea:	ea54 0305 	orrs.w	r3, r4, r5
 8012eee:	d00b      	beq.n	8012f08 <HAL_RCCEx_PeriphCLKConfig+0x44>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(pPeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(pPeriphClkInit->Usart1ClockSelection);
 8012ef0:	4bcb      	ldr	r3, [pc, #812]	@ (8013220 <HAL_RCCEx_PeriphCLKConfig+0x35c>)
 8012ef2:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8012ef6:	f023 0103 	bic.w	r1, r3, #3
 8012efa:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8012efe:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8012f00:	4ac7      	ldr	r2, [pc, #796]	@ (8013220 <HAL_RCCEx_PeriphCLKConfig+0x35c>)
 8012f02:	430b      	orrs	r3, r1
 8012f04:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  }

#if defined(USART2)
  /*-------------------------- USART2 clock source configuration -------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 8012f08:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8012f0c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8012f10:	f002 0802 	and.w	r8, r2, #2
 8012f14:	f04f 0900 	mov.w	r9, #0
 8012f18:	ea58 0309 	orrs.w	r3, r8, r9
 8012f1c:	d00b      	beq.n	8012f36 <HAL_RCCEx_PeriphCLKConfig+0x72>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(pPeriphClkInit->Usart2ClockSelection));

    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(pPeriphClkInit->Usart2ClockSelection);
 8012f1e:	4bc0      	ldr	r3, [pc, #768]	@ (8013220 <HAL_RCCEx_PeriphCLKConfig+0x35c>)
 8012f20:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8012f24:	f023 010c 	bic.w	r1, r3, #12
 8012f28:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8012f2c:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8012f2e:	4abc      	ldr	r2, [pc, #752]	@ (8013220 <HAL_RCCEx_PeriphCLKConfig+0x35c>)
 8012f30:	430b      	orrs	r3, r1
 8012f32:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  }
#endif /* USART2 */

  /*-------------------------- USART3 clock source configuration -------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
 8012f36:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8012f3a:	e9d3 2300 	ldrd	r2, r3, [r3]
 8012f3e:	f002 0a04 	and.w	sl, r2, #4
 8012f42:	f04f 0b00 	mov.w	fp, #0
 8012f46:	ea5a 030b 	orrs.w	r3, sl, fp
 8012f4a:	d00b      	beq.n	8012f64 <HAL_RCCEx_PeriphCLKConfig+0xa0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART3CLKSOURCE(pPeriphClkInit->Usart3ClockSelection));

    /* Configure the USART3 clock source */
    __HAL_RCC_USART3_CONFIG(pPeriphClkInit->Usart3ClockSelection);
 8012f4c:	4bb4      	ldr	r3, [pc, #720]	@ (8013220 <HAL_RCCEx_PeriphCLKConfig+0x35c>)
 8012f4e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8012f52:	f023 0130 	bic.w	r1, r3, #48	@ 0x30
 8012f56:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8012f5a:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8012f5c:	4ab0      	ldr	r2, [pc, #704]	@ (8013220 <HAL_RCCEx_PeriphCLKConfig+0x35c>)
 8012f5e:	430b      	orrs	r3, r1
 8012f60:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  }

  /*-------------------------- UART4 clock source configuration --------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
 8012f64:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8012f68:	e9d3 2300 	ldrd	r2, r3, [r3]
 8012f6c:	f002 0308 	and.w	r3, r2, #8
 8012f70:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 8012f74:	2300      	movs	r3, #0
 8012f76:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
 8012f7a:	e9d7 1232 	ldrd	r1, r2, [r7, #200]	@ 0xc8
 8012f7e:	460b      	mov	r3, r1
 8012f80:	4313      	orrs	r3, r2
 8012f82:	d00b      	beq.n	8012f9c <HAL_RCCEx_PeriphCLKConfig+0xd8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART4CLKSOURCE(pPeriphClkInit->Uart4ClockSelection));

    /* Configure the UART4 clock source */
    __HAL_RCC_UART4_CONFIG(pPeriphClkInit->Uart4ClockSelection);
 8012f84:	4ba6      	ldr	r3, [pc, #664]	@ (8013220 <HAL_RCCEx_PeriphCLKConfig+0x35c>)
 8012f86:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8012f8a:	f023 01c0 	bic.w	r1, r3, #192	@ 0xc0
 8012f8e:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8012f92:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8012f94:	4aa2      	ldr	r2, [pc, #648]	@ (8013220 <HAL_RCCEx_PeriphCLKConfig+0x35c>)
 8012f96:	430b      	orrs	r3, r1
 8012f98:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  }

  /*-------------------------- UART5 clock source configuration --------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
 8012f9c:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8012fa0:	e9d3 2300 	ldrd	r2, r3, [r3]
 8012fa4:	f002 0310 	and.w	r3, r2, #16
 8012fa8:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
 8012fac:	2300      	movs	r3, #0
 8012fae:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
 8012fb2:	e9d7 1230 	ldrd	r1, r2, [r7, #192]	@ 0xc0
 8012fb6:	460b      	mov	r3, r1
 8012fb8:	4313      	orrs	r3, r2
 8012fba:	d00b      	beq.n	8012fd4 <HAL_RCCEx_PeriphCLKConfig+0x110>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART5CLKSOURCE(pPeriphClkInit->Uart5ClockSelection));

    /* Configure the UART5 clock source */
    __HAL_RCC_UART5_CONFIG(pPeriphClkInit->Uart5ClockSelection);
 8012fbc:	4b98      	ldr	r3, [pc, #608]	@ (8013220 <HAL_RCCEx_PeriphCLKConfig+0x35c>)
 8012fbe:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8012fc2:	f423 7140 	bic.w	r1, r3, #768	@ 0x300
 8012fc6:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8012fca:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8012fcc:	4a94      	ldr	r2, [pc, #592]	@ (8013220 <HAL_RCCEx_PeriphCLKConfig+0x35c>)
 8012fce:	430b      	orrs	r3, r1
 8012fd0:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
    __HAL_RCC_USART6_CONFIG(pPeriphClkInit->Usart6ClockSelection);
  }
#endif /* USART6 */

  /*-------------------------- LPUART1 clock source configuration ------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 8012fd4:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8012fd8:	e9d3 2300 	ldrd	r2, r3, [r3]
 8012fdc:	f002 0320 	and.w	r3, r2, #32
 8012fe0:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
 8012fe4:	2300      	movs	r3, #0
 8012fe6:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
 8012fea:	e9d7 122e 	ldrd	r1, r2, [r7, #184]	@ 0xb8
 8012fee:	460b      	mov	r3, r1
 8012ff0:	4313      	orrs	r3, r2
 8012ff2:	d00b      	beq.n	801300c <HAL_RCCEx_PeriphCLKConfig+0x148>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPUART1CLKSOURCE(pPeriphClkInit->Lpuart1ClockSelection));

    /* Configure the LPUART1 clock source */
    __HAL_RCC_LPUART1_CONFIG(pPeriphClkInit->Lpuart1ClockSelection);
 8012ff4:	4b8a      	ldr	r3, [pc, #552]	@ (8013220 <HAL_RCCEx_PeriphCLKConfig+0x35c>)
 8012ff6:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 8012ffa:	f023 0107 	bic.w	r1, r3, #7
 8012ffe:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8013002:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8013004:	4a86      	ldr	r2, [pc, #536]	@ (8013220 <HAL_RCCEx_PeriphCLKConfig+0x35c>)
 8013006:	430b      	orrs	r3, r1
 8013008:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
  }

  /*-------------------------- I2C1 clock source configuration ---------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 801300c:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8013010:	e9d3 2300 	ldrd	r2, r3, [r3]
 8013014:	f002 0340 	and.w	r3, r2, #64	@ 0x40
 8013018:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0
 801301c:	2300      	movs	r3, #0
 801301e:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
 8013022:	e9d7 122c 	ldrd	r1, r2, [r7, #176]	@ 0xb0
 8013026:	460b      	mov	r3, r1
 8013028:	4313      	orrs	r3, r2
 801302a:	d00b      	beq.n	8013044 <HAL_RCCEx_PeriphCLKConfig+0x180>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(pPeriphClkInit->I2c1ClockSelection));

    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(pPeriphClkInit->I2c1ClockSelection);
 801302c:	4b7c      	ldr	r3, [pc, #496]	@ (8013220 <HAL_RCCEx_PeriphCLKConfig+0x35c>)
 801302e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8013032:	f423 6140 	bic.w	r1, r3, #3072	@ 0xc00
 8013036:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 801303a:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 801303c:	4a78      	ldr	r2, [pc, #480]	@ (8013220 <HAL_RCCEx_PeriphCLKConfig+0x35c>)
 801303e:	430b      	orrs	r3, r1
 8013040:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  }

  /*-------------------------- I2C2 clock source configuration ---------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 8013044:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8013048:	e9d3 2300 	ldrd	r2, r3, [r3]
 801304c:	f002 0380 	and.w	r3, r2, #128	@ 0x80
 8013050:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
 8013054:	2300      	movs	r3, #0
 8013056:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
 801305a:	e9d7 122a 	ldrd	r1, r2, [r7, #168]	@ 0xa8
 801305e:	460b      	mov	r3, r1
 8013060:	4313      	orrs	r3, r2
 8013062:	d00b      	beq.n	801307c <HAL_RCCEx_PeriphCLKConfig+0x1b8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(pPeriphClkInit->I2c2ClockSelection));

    /* Configure the I2C2 clock source */
    __HAL_RCC_I2C2_CONFIG(pPeriphClkInit->I2c2ClockSelection);
 8013064:	4b6e      	ldr	r3, [pc, #440]	@ (8013220 <HAL_RCCEx_PeriphCLKConfig+0x35c>)
 8013066:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 801306a:	f423 5140 	bic.w	r1, r3, #12288	@ 0x3000
 801306e:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8013072:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 8013074:	4a6a      	ldr	r2, [pc, #424]	@ (8013220 <HAL_RCCEx_PeriphCLKConfig+0x35c>)
 8013076:	430b      	orrs	r3, r1
 8013078:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  }

  /*-------------------------- I2C3 clock source configuration ---------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 801307c:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8013080:	e9d3 2300 	ldrd	r2, r3, [r3]
 8013084:	f402 7380 	and.w	r3, r2, #256	@ 0x100
 8013088:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
 801308c:	2300      	movs	r3, #0
 801308e:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
 8013092:	e9d7 1228 	ldrd	r1, r2, [r7, #160]	@ 0xa0
 8013096:	460b      	mov	r3, r1
 8013098:	4313      	orrs	r3, r2
 801309a:	d00b      	beq.n	80130b4 <HAL_RCCEx_PeriphCLKConfig+0x1f0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(pPeriphClkInit->I2c3ClockSelection));

    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(pPeriphClkInit->I2c3ClockSelection);
 801309c:	4b60      	ldr	r3, [pc, #384]	@ (8013220 <HAL_RCCEx_PeriphCLKConfig+0x35c>)
 801309e:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 80130a2:	f023 01c0 	bic.w	r1, r3, #192	@ 0xc0
 80130a6:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 80130aa:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 80130ac:	4a5c      	ldr	r2, [pc, #368]	@ (8013220 <HAL_RCCEx_PeriphCLKConfig+0x35c>)
 80130ae:	430b      	orrs	r3, r1
 80130b0:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
  }

  /*-------------------------- I2C4 clock source configuration ---------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
 80130b4:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 80130b8:	e9d3 2300 	ldrd	r2, r3, [r3]
 80130bc:	f402 0380 	and.w	r3, r2, #4194304	@ 0x400000
 80130c0:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98
 80130c4:	2300      	movs	r3, #0
 80130c6:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
 80130ca:	e9d7 1226 	ldrd	r1, r2, [r7, #152]	@ 0x98
 80130ce:	460b      	mov	r3, r1
 80130d0:	4313      	orrs	r3, r2
 80130d2:	d00b      	beq.n	80130ec <HAL_RCCEx_PeriphCLKConfig+0x228>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C4CLKSOURCE(pPeriphClkInit->I2c4ClockSelection));

    /* Configure the I2C4 clock source */
    __HAL_RCC_I2C4_CONFIG(pPeriphClkInit->I2c4ClockSelection);
 80130d4:	4b52      	ldr	r3, [pc, #328]	@ (8013220 <HAL_RCCEx_PeriphCLKConfig+0x35c>)
 80130d6:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 80130da:	f423 4140 	bic.w	r1, r3, #49152	@ 0xc000
 80130de:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 80130e2:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 80130e4:	4a4e      	ldr	r2, [pc, #312]	@ (8013220 <HAL_RCCEx_PeriphCLKConfig+0x35c>)
 80130e6:	430b      	orrs	r3, r1
 80130e8:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
    __HAL_RCC_I2C6_CONFIG(pPeriphClkInit->I2c6ClockSelection);
  }
#endif /* I2C6 */

  /*-------------------------- LPTIM1 clock source configuration -------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == (RCC_PERIPHCLK_LPTIM1))
 80130ec:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 80130f0:	e9d3 2300 	ldrd	r2, r3, [r3]
 80130f4:	f402 7300 	and.w	r3, r2, #512	@ 0x200
 80130f8:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
 80130fc:	2300      	movs	r3, #0
 80130fe:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
 8013102:	e9d7 1224 	ldrd	r1, r2, [r7, #144]	@ 0x90
 8013106:	460b      	mov	r3, r1
 8013108:	4313      	orrs	r3, r2
 801310a:	d00b      	beq.n	8013124 <HAL_RCCEx_PeriphCLKConfig+0x260>
  {
    assert_param(IS_RCC_LPTIM1CLK(pPeriphClkInit->Lptim1ClockSelection));
    __HAL_RCC_LPTIM1_CONFIG(pPeriphClkInit->Lptim1ClockSelection);
 801310c:	4b44      	ldr	r3, [pc, #272]	@ (8013220 <HAL_RCCEx_PeriphCLKConfig+0x35c>)
 801310e:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 8013112:	f423 6140 	bic.w	r1, r3, #3072	@ 0xc00
 8013116:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 801311a:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 801311c:	4a40      	ldr	r2, [pc, #256]	@ (8013220 <HAL_RCCEx_PeriphCLKConfig+0x35c>)
 801311e:	430b      	orrs	r3, r1
 8013120:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
  }

  /*-------------------------- LPTIM2 clock source configuration -------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == (RCC_PERIPHCLK_LPTIM2))
 8013124:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8013128:	e9d3 2300 	ldrd	r2, r3, [r3]
 801312c:	f402 6380 	and.w	r3, r2, #1024	@ 0x400
 8013130:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
 8013134:	2300      	movs	r3, #0
 8013136:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
 801313a:	e9d7 1222 	ldrd	r1, r2, [r7, #136]	@ 0x88
 801313e:	460b      	mov	r3, r1
 8013140:	4313      	orrs	r3, r2
 8013142:	d00b      	beq.n	801315c <HAL_RCCEx_PeriphCLKConfig+0x298>
  {
    assert_param(IS_RCC_LPTIM2CLK(pPeriphClkInit->Lptim2ClockSelection));
    __HAL_RCC_LPTIM2_CONFIG(pPeriphClkInit->Lptim2ClockSelection);
 8013144:	4b36      	ldr	r3, [pc, #216]	@ (8013220 <HAL_RCCEx_PeriphCLKConfig+0x35c>)
 8013146:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 801314a:	f423 2140 	bic.w	r1, r3, #786432	@ 0xc0000
 801314e:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8013152:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
 8013154:	4a32      	ldr	r2, [pc, #200]	@ (8013220 <HAL_RCCEx_PeriphCLKConfig+0x35c>)
 8013156:	430b      	orrs	r3, r1
 8013158:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  }

  /*-------------------------- LPTIM34 clock source configuration -------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM34) == (RCC_PERIPHCLK_LPTIM34))
 801315c:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8013160:	e9d3 2300 	ldrd	r2, r3, [r3]
 8013164:	f402 6300 	and.w	r3, r2, #2048	@ 0x800
 8013168:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
 801316c:	2300      	movs	r3, #0
 801316e:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
 8013172:	e9d7 1220 	ldrd	r1, r2, [r7, #128]	@ 0x80
 8013176:	460b      	mov	r3, r1
 8013178:	4313      	orrs	r3, r2
 801317a:	d00c      	beq.n	8013196 <HAL_RCCEx_PeriphCLKConfig+0x2d2>
  {
    assert_param(IS_RCC_LPTIM34CLK(pPeriphClkInit->Lptim34ClockSelection));
    __HAL_RCC_LPTIM34_CONFIG(pPeriphClkInit->Lptim34ClockSelection);
 801317c:	4b28      	ldr	r3, [pc, #160]	@ (8013220 <HAL_RCCEx_PeriphCLKConfig+0x35c>)
 801317e:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 8013182:	f423 7140 	bic.w	r1, r3, #768	@ 0x300
 8013186:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 801318a:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 801318e:	4a24      	ldr	r2, [pc, #144]	@ (8013220 <HAL_RCCEx_PeriphCLKConfig+0x35c>)
 8013190:	430b      	orrs	r3, r1
 8013192:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
  }

  /*-------------------------- SAI1 clock source configuration ---------------------*/
  if ((((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1))
 8013196:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 801319a:	e9d3 2300 	ldrd	r2, r3, [r3]
 801319e:	f402 5300 	and.w	r3, r2, #8192	@ 0x2000
 80131a2:	67bb      	str	r3, [r7, #120]	@ 0x78
 80131a4:	2300      	movs	r3, #0
 80131a6:	67fb      	str	r3, [r7, #124]	@ 0x7c
 80131a8:	e9d7 121e 	ldrd	r1, r2, [r7, #120]	@ 0x78
 80131ac:	460b      	mov	r3, r1
 80131ae:	4313      	orrs	r3, r2
 80131b0:	d04f      	beq.n	8013252 <HAL_RCCEx_PeriphCLKConfig+0x38e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLK(pPeriphClkInit->Sai1ClockSelection));

    switch (pPeriphClkInit->Sai1ClockSelection)
 80131b2:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 80131b6:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 80131ba:	2b80      	cmp	r3, #128	@ 0x80
 80131bc:	d02d      	beq.n	801321a <HAL_RCCEx_PeriphCLKConfig+0x356>
 80131be:	2b80      	cmp	r3, #128	@ 0x80
 80131c0:	d827      	bhi.n	8013212 <HAL_RCCEx_PeriphCLKConfig+0x34e>
 80131c2:	2b60      	cmp	r3, #96	@ 0x60
 80131c4:	d02e      	beq.n	8013224 <HAL_RCCEx_PeriphCLKConfig+0x360>
 80131c6:	2b60      	cmp	r3, #96	@ 0x60
 80131c8:	d823      	bhi.n	8013212 <HAL_RCCEx_PeriphCLKConfig+0x34e>
 80131ca:	2b40      	cmp	r3, #64	@ 0x40
 80131cc:	d006      	beq.n	80131dc <HAL_RCCEx_PeriphCLKConfig+0x318>
 80131ce:	2b40      	cmp	r3, #64	@ 0x40
 80131d0:	d81f      	bhi.n	8013212 <HAL_RCCEx_PeriphCLKConfig+0x34e>
 80131d2:	2b00      	cmp	r3, #0
 80131d4:	d009      	beq.n	80131ea <HAL_RCCEx_PeriphCLKConfig+0x326>
 80131d6:	2b20      	cmp	r3, #32
 80131d8:	d011      	beq.n	80131fe <HAL_RCCEx_PeriphCLKConfig+0x33a>
 80131da:	e01a      	b.n	8013212 <HAL_RCCEx_PeriphCLKConfig+0x34e>
    {
      case RCC_SAI1CLKSOURCE_PLL1:      /* PLL is used as clock source for SAI1*/
        /* Enable SAI Clock output generated from System PLL  */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVP);
 80131dc:	4b10      	ldr	r3, [pc, #64]	@ (8013220 <HAL_RCCEx_PeriphCLKConfig+0x35c>)
 80131de:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80131e0:	4a0f      	ldr	r2, [pc, #60]	@ (8013220 <HAL_RCCEx_PeriphCLKConfig+0x35c>)
 80131e2:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 80131e6:	6293      	str	r3, [r2, #40]	@ 0x28
        /* SAI1 clock source config set later after clock selection check */
        break;
 80131e8:	e01d      	b.n	8013226 <HAL_RCCEx_PeriphCLKConfig+0x362>

      case RCC_SAI1CLKSOURCE_PLL2:  /* PLL2 is used as clock source for SAI1*/
        /* PLL2 P input clock, parameters M, N & P configuration and clock output (PLL2ClockOut) */
        ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
 80131ea:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 80131ee:	3308      	adds	r3, #8
 80131f0:	4618      	mov	r0, r3
 80131f2:	f002 fa17 	bl	8015624 <RCCEx_PLL2_Config>
 80131f6:	4603      	mov	r3, r0
 80131f8:	f887 30e3 	strb.w	r3, [r7, #227]	@ 0xe3
        /* SAI1 clock source config set later after clock selection check */
        break;
 80131fc:	e013      	b.n	8013226 <HAL_RCCEx_PeriphCLKConfig+0x362>

      case RCC_SAI1CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI1*/
        /* PLL3 P input clock, parameters M, N & P configuration clock output (PLL3ClockOut) */
        ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
 80131fe:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8013202:	332c      	adds	r3, #44	@ 0x2c
 8013204:	4618      	mov	r0, r3
 8013206:	f002 faa5 	bl	8015754 <RCCEx_PLL3_Config>
 801320a:	4603      	mov	r3, r0
 801320c:	f887 30e3 	strb.w	r3, [r7, #227]	@ 0xe3
        /* SAI1 clock source config set later after clock selection check */
        break;
 8013210:	e009      	b.n	8013226 <HAL_RCCEx_PeriphCLKConfig+0x362>
      case RCC_SAI1CLKSOURCE_HSI:      /* HSI is used as source of SAI1 clock*/
        /* SAI1 clock source config set later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 8013212:	2301      	movs	r3, #1
 8013214:	f887 30e3 	strb.w	r3, [r7, #227]	@ 0xe3
        break;
 8013218:	e005      	b.n	8013226 <HAL_RCCEx_PeriphCLKConfig+0x362>
        break;
 801321a:	bf00      	nop
 801321c:	e003      	b.n	8013226 <HAL_RCCEx_PeriphCLKConfig+0x362>
 801321e:	bf00      	nop
 8013220:	46020c00 	.word	0x46020c00
        break;
 8013224:	bf00      	nop
    }

    if (ret == HAL_OK)
 8013226:	f897 30e3 	ldrb.w	r3, [r7, #227]	@ 0xe3
 801322a:	2b00      	cmp	r3, #0
 801322c:	d10d      	bne.n	801324a <HAL_RCCEx_PeriphCLKConfig+0x386>
    {
      /* Set the source of SAI1 clock*/
      __HAL_RCC_SAI1_CONFIG(pPeriphClkInit->Sai1ClockSelection);
 801322e:	4bb6      	ldr	r3, [pc, #728]	@ (8013508 <HAL_RCCEx_PeriphCLKConfig+0x644>)
 8013230:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
 8013234:	f023 01e0 	bic.w	r1, r3, #224	@ 0xe0
 8013238:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 801323c:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 8013240:	4ab1      	ldr	r2, [pc, #708]	@ (8013508 <HAL_RCCEx_PeriphCLKConfig+0x644>)
 8013242:	430b      	orrs	r3, r1
 8013244:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
 8013248:	e003      	b.n	8013252 <HAL_RCCEx_PeriphCLKConfig+0x38e>
    }
    else
    {
      /* set overall return value */
      status = ret;
 801324a:	f897 30e3 	ldrb.w	r3, [r7, #227]	@ 0xe3
 801324e:	f887 30e2 	strb.w	r3, [r7, #226]	@ 0xe2
    }
  }

#if defined(SAI2)
  /*-------------------------- SAI2 clock source configuration ---------------------*/
  if ((((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2))
 8013252:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8013256:	e9d3 2300 	ldrd	r2, r3, [r3]
 801325a:	f402 4380 	and.w	r3, r2, #16384	@ 0x4000
 801325e:	673b      	str	r3, [r7, #112]	@ 0x70
 8013260:	2300      	movs	r3, #0
 8013262:	677b      	str	r3, [r7, #116]	@ 0x74
 8013264:	e9d7 121c 	ldrd	r1, r2, [r7, #112]	@ 0x70
 8013268:	460b      	mov	r3, r1
 801326a:	4313      	orrs	r3, r2
 801326c:	d053      	beq.n	8013316 <HAL_RCCEx_PeriphCLKConfig+0x452>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI2CLK(pPeriphClkInit->Sai2ClockSelection));

    switch (pPeriphClkInit->Sai2ClockSelection)
 801326e:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8013272:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 8013276:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 801327a:	d033      	beq.n	80132e4 <HAL_RCCEx_PeriphCLKConfig+0x420>
 801327c:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 8013280:	d82c      	bhi.n	80132dc <HAL_RCCEx_PeriphCLKConfig+0x418>
 8013282:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
 8013286:	d02f      	beq.n	80132e8 <HAL_RCCEx_PeriphCLKConfig+0x424>
 8013288:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
 801328c:	d826      	bhi.n	80132dc <HAL_RCCEx_PeriphCLKConfig+0x418>
 801328e:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8013292:	d008      	beq.n	80132a6 <HAL_RCCEx_PeriphCLKConfig+0x3e2>
 8013294:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8013298:	d820      	bhi.n	80132dc <HAL_RCCEx_PeriphCLKConfig+0x418>
 801329a:	2b00      	cmp	r3, #0
 801329c:	d00a      	beq.n	80132b4 <HAL_RCCEx_PeriphCLKConfig+0x3f0>
 801329e:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 80132a2:	d011      	beq.n	80132c8 <HAL_RCCEx_PeriphCLKConfig+0x404>
 80132a4:	e01a      	b.n	80132dc <HAL_RCCEx_PeriphCLKConfig+0x418>
    {
      case RCC_SAI2CLKSOURCE_PLL1:      /* PLL is used as clock source for SAI2*/
        /* Enable SAI Clock output generated from System PLL  */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVP);
 80132a6:	4b98      	ldr	r3, [pc, #608]	@ (8013508 <HAL_RCCEx_PeriphCLKConfig+0x644>)
 80132a8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80132aa:	4a97      	ldr	r2, [pc, #604]	@ (8013508 <HAL_RCCEx_PeriphCLKConfig+0x644>)
 80132ac:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 80132b0:	6293      	str	r3, [r2, #40]	@ 0x28
        /* SAI2 clock source config set later after clock selection check */
        break;
 80132b2:	e01a      	b.n	80132ea <HAL_RCCEx_PeriphCLKConfig+0x426>

      case RCC_SAI2CLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI2*/
        /* PLL2 P input clock, parameters M, N & P configuration and clock output (PLL2ClockOut) */
        ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
 80132b4:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 80132b8:	3308      	adds	r3, #8
 80132ba:	4618      	mov	r0, r3
 80132bc:	f002 f9b2 	bl	8015624 <RCCEx_PLL2_Config>
 80132c0:	4603      	mov	r3, r0
 80132c2:	f887 30e3 	strb.w	r3, [r7, #227]	@ 0xe3
        /* SAI2 clock source config set later after clock selection check */
        break;
 80132c6:	e010      	b.n	80132ea <HAL_RCCEx_PeriphCLKConfig+0x426>

      case RCC_SAI2CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI2*/
        /* PLL3 P input clock, parameters M, N & P configuration and clock output (PLL3ClockOut) */
        ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
 80132c8:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 80132cc:	332c      	adds	r3, #44	@ 0x2c
 80132ce:	4618      	mov	r0, r3
 80132d0:	f002 fa40 	bl	8015754 <RCCEx_PLL3_Config>
 80132d4:	4603      	mov	r3, r0
 80132d6:	f887 30e3 	strb.w	r3, [r7, #227]	@ 0xe3
        /* SAI2 clock source config set later after clock selection check */
        break;
 80132da:	e006      	b.n	80132ea <HAL_RCCEx_PeriphCLKConfig+0x426>
      case RCC_SAI2CLKSOURCE_HSI:      /* HSI is used as source of SAI2 clock*/
        /* SAI2 clock source config set later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 80132dc:	2301      	movs	r3, #1
 80132de:	f887 30e3 	strb.w	r3, [r7, #227]	@ 0xe3
        break;
 80132e2:	e002      	b.n	80132ea <HAL_RCCEx_PeriphCLKConfig+0x426>
        break;
 80132e4:	bf00      	nop
 80132e6:	e000      	b.n	80132ea <HAL_RCCEx_PeriphCLKConfig+0x426>
        break;
 80132e8:	bf00      	nop
    }

    if (ret == HAL_OK)
 80132ea:	f897 30e3 	ldrb.w	r3, [r7, #227]	@ 0xe3
 80132ee:	2b00      	cmp	r3, #0
 80132f0:	d10d      	bne.n	801330e <HAL_RCCEx_PeriphCLKConfig+0x44a>
    {
      /* Set the source of SAI2 clock*/
      __HAL_RCC_SAI2_CONFIG(pPeriphClkInit->Sai2ClockSelection);
 80132f2:	4b85      	ldr	r3, [pc, #532]	@ (8013508 <HAL_RCCEx_PeriphCLKConfig+0x644>)
 80132f4:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
 80132f8:	f423 61e0 	bic.w	r1, r3, #1792	@ 0x700
 80132fc:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8013300:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 8013304:	4a80      	ldr	r2, [pc, #512]	@ (8013508 <HAL_RCCEx_PeriphCLKConfig+0x644>)
 8013306:	430b      	orrs	r3, r1
 8013308:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
 801330c:	e003      	b.n	8013316 <HAL_RCCEx_PeriphCLKConfig+0x452>
    }
    else
    {
      /* set overall return value */
      status = ret;
 801330e:	f897 30e3 	ldrb.w	r3, [r7, #227]	@ 0xe3
 8013312:	f887 30e2 	strb.w	r3, [r7, #226]	@ 0xe2
    }
  }
#endif /* SAI2 */

  /*-------------------------- ADCDAC clock source configuration ----------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADCDAC) == RCC_PERIPHCLK_ADCDAC)
 8013316:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 801331a:	e9d3 2300 	ldrd	r2, r3, [r3]
 801331e:	f402 4300 	and.w	r3, r2, #32768	@ 0x8000
 8013322:	66bb      	str	r3, [r7, #104]	@ 0x68
 8013324:	2300      	movs	r3, #0
 8013326:	66fb      	str	r3, [r7, #108]	@ 0x6c
 8013328:	e9d7 121a 	ldrd	r1, r2, [r7, #104]	@ 0x68
 801332c:	460b      	mov	r3, r1
 801332e:	4313      	orrs	r3, r2
 8013330:	d046      	beq.n	80133c0 <HAL_RCCEx_PeriphCLKConfig+0x4fc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADCDACCLKSOURCE(pPeriphClkInit->AdcDacClockSelection));

    switch (pPeriphClkInit->AdcDacClockSelection)
 8013332:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8013336:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
 801333a:	f5b3 4fa0 	cmp.w	r3, #20480	@ 0x5000
 801333e:	d028      	beq.n	8013392 <HAL_RCCEx_PeriphCLKConfig+0x4ce>
 8013340:	f5b3 4fa0 	cmp.w	r3, #20480	@ 0x5000
 8013344:	d821      	bhi.n	801338a <HAL_RCCEx_PeriphCLKConfig+0x4c6>
 8013346:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 801334a:	d022      	beq.n	8013392 <HAL_RCCEx_PeriphCLKConfig+0x4ce>
 801334c:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 8013350:	d81b      	bhi.n	801338a <HAL_RCCEx_PeriphCLKConfig+0x4c6>
 8013352:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
 8013356:	d01c      	beq.n	8013392 <HAL_RCCEx_PeriphCLKConfig+0x4ce>
 8013358:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
 801335c:	d815      	bhi.n	801338a <HAL_RCCEx_PeriphCLKConfig+0x4c6>
 801335e:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 8013362:	d008      	beq.n	8013376 <HAL_RCCEx_PeriphCLKConfig+0x4b2>
 8013364:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 8013368:	d80f      	bhi.n	801338a <HAL_RCCEx_PeriphCLKConfig+0x4c6>
 801336a:	2b00      	cmp	r3, #0
 801336c:	d011      	beq.n	8013392 <HAL_RCCEx_PeriphCLKConfig+0x4ce>
 801336e:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 8013372:	d00e      	beq.n	8013392 <HAL_RCCEx_PeriphCLKConfig+0x4ce>
 8013374:	e009      	b.n	801338a <HAL_RCCEx_PeriphCLKConfig+0x4c6>
    {
      case RCC_ADCDACCLKSOURCE_PLL2:
        /* PLL2 input clock, parameters M, N,P, & R configuration and clock output (PLL2ClockOut) */
        ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
 8013376:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 801337a:	3308      	adds	r3, #8
 801337c:	4618      	mov	r0, r3
 801337e:	f002 f951 	bl	8015624 <RCCEx_PLL2_Config>
 8013382:	4603      	mov	r3, r0
 8013384:	f887 30e3 	strb.w	r3, [r7, #227]	@ 0xe3
        break;
 8013388:	e004      	b.n	8013394 <HAL_RCCEx_PeriphCLKConfig+0x4d0>
      case RCC_ADCDACCLKSOURCE_HSE:
      case RCC_ADCDACCLKSOURCE_HSI:
      case RCC_ADCDACCLKSOURCE_MSIK:
        break;
      default:
        ret = HAL_ERROR;
 801338a:	2301      	movs	r3, #1
 801338c:	f887 30e3 	strb.w	r3, [r7, #227]	@ 0xe3
        break;
 8013390:	e000      	b.n	8013394 <HAL_RCCEx_PeriphCLKConfig+0x4d0>
        break;
 8013392:	bf00      	nop
    }

    if (ret == HAL_OK)
 8013394:	f897 30e3 	ldrb.w	r3, [r7, #227]	@ 0xe3
 8013398:	2b00      	cmp	r3, #0
 801339a:	d10d      	bne.n	80133b8 <HAL_RCCEx_PeriphCLKConfig+0x4f4>
    {
      /* Configure the ADC1 interface clock source */
      __HAL_RCC_ADCDAC_CONFIG(pPeriphClkInit->AdcDacClockSelection);
 801339c:	4b5a      	ldr	r3, [pc, #360]	@ (8013508 <HAL_RCCEx_PeriphCLKConfig+0x644>)
 801339e:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 80133a2:	f423 41e0 	bic.w	r1, r3, #28672	@ 0x7000
 80133a6:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 80133aa:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
 80133ae:	4a56      	ldr	r2, [pc, #344]	@ (8013508 <HAL_RCCEx_PeriphCLKConfig+0x644>)
 80133b0:	430b      	orrs	r3, r1
 80133b2:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
 80133b6:	e003      	b.n	80133c0 <HAL_RCCEx_PeriphCLKConfig+0x4fc>
    }
    else
    {
      /* set overall return value */
      status = ret;
 80133b8:	f897 30e3 	ldrb.w	r3, [r7, #227]	@ 0xe3
 80133bc:	f887 30e2 	strb.w	r3, [r7, #226]	@ 0xe2
    }
  }

  /*-------------------------- MDF1 clock source configuration -------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_MDF1) == RCC_PERIPHCLK_MDF1)
 80133c0:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 80133c4:	e9d3 2300 	ldrd	r2, r3, [r3]
 80133c8:	f402 3380 	and.w	r3, r2, #65536	@ 0x10000
 80133cc:	663b      	str	r3, [r7, #96]	@ 0x60
 80133ce:	2300      	movs	r3, #0
 80133d0:	667b      	str	r3, [r7, #100]	@ 0x64
 80133d2:	e9d7 1218 	ldrd	r1, r2, [r7, #96]	@ 0x60
 80133d6:	460b      	mov	r3, r1
 80133d8:	4313      	orrs	r3, r2
 80133da:	d03f      	beq.n	801345c <HAL_RCCEx_PeriphCLKConfig+0x598>
  {
    /* Check the parameters */
    assert_param(IS_RCC_MDF1CLKSOURCE(pPeriphClkInit->Mdf1ClockSelection));

    switch (pPeriphClkInit->Mdf1ClockSelection)
 80133dc:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 80133e0:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 80133e4:	2b04      	cmp	r3, #4
 80133e6:	d81e      	bhi.n	8013426 <HAL_RCCEx_PeriphCLKConfig+0x562>
 80133e8:	a201      	add	r2, pc, #4	@ (adr r2, 80133f0 <HAL_RCCEx_PeriphCLKConfig+0x52c>)
 80133ea:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80133ee:	bf00      	nop
 80133f0:	0801342f 	.word	0x0801342f
 80133f4:	08013405 	.word	0x08013405
 80133f8:	08013413 	.word	0x08013413
 80133fc:	0801342f 	.word	0x0801342f
 8013400:	0801342f 	.word	0x0801342f
    {
      case RCC_MDF1CLKSOURCE_PLL1:
        /* Enable PLL1 Clock output generated from System PLL  */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVP);
 8013404:	4b40      	ldr	r3, [pc, #256]	@ (8013508 <HAL_RCCEx_PeriphCLKConfig+0x644>)
 8013406:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8013408:	4a3f      	ldr	r2, [pc, #252]	@ (8013508 <HAL_RCCEx_PeriphCLKConfig+0x644>)
 801340a:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 801340e:	6293      	str	r3, [r2, #40]	@ 0x28
        break;
 8013410:	e00e      	b.n	8013430 <HAL_RCCEx_PeriphCLKConfig+0x56c>
      case RCC_MDF1CLKSOURCE_PLL3:
        /* PLL3 Q input clock, parameters M, N & Q configuration and clock output (PLL3ClockOut) */
        ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
 8013412:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8013416:	332c      	adds	r3, #44	@ 0x2c
 8013418:	4618      	mov	r0, r3
 801341a:	f002 f99b 	bl	8015754 <RCCEx_PLL3_Config>
 801341e:	4603      	mov	r3, r0
 8013420:	f887 30e3 	strb.w	r3, [r7, #227]	@ 0xe3
        break;
 8013424:	e004      	b.n	8013430 <HAL_RCCEx_PeriphCLKConfig+0x56c>
      case RCC_MDF1CLKSOURCE_PIN:
        break;
      case RCC_MDF1CLKSOURCE_MSIK:
        break;
      default:
        ret = HAL_ERROR;
 8013426:	2301      	movs	r3, #1
 8013428:	f887 30e3 	strb.w	r3, [r7, #227]	@ 0xe3
        break;
 801342c:	e000      	b.n	8013430 <HAL_RCCEx_PeriphCLKConfig+0x56c>
        break;
 801342e:	bf00      	nop
    }
    if (ret == HAL_OK)
 8013430:	f897 30e3 	ldrb.w	r3, [r7, #227]	@ 0xe3
 8013434:	2b00      	cmp	r3, #0
 8013436:	d10d      	bne.n	8013454 <HAL_RCCEx_PeriphCLKConfig+0x590>
    {
      /* Configure the MDF1 interface clock source */
      __HAL_RCC_MDF1_CONFIG(pPeriphClkInit->Mdf1ClockSelection);
 8013438:	4b33      	ldr	r3, [pc, #204]	@ (8013508 <HAL_RCCEx_PeriphCLKConfig+0x644>)
 801343a:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
 801343e:	f023 0107 	bic.w	r1, r3, #7
 8013442:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8013446:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 801344a:	4a2f      	ldr	r2, [pc, #188]	@ (8013508 <HAL_RCCEx_PeriphCLKConfig+0x644>)
 801344c:	430b      	orrs	r3, r1
 801344e:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
 8013452:	e003      	b.n	801345c <HAL_RCCEx_PeriphCLKConfig+0x598>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8013454:	f897 30e3 	ldrb.w	r3, [r7, #227]	@ 0xe3
 8013458:	f887 30e2 	strb.w	r3, [r7, #226]	@ 0xe2
    }
  }

  /*-------------------------- ADF1 clock source configuration -------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADF1) == RCC_PERIPHCLK_ADF1)
 801345c:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8013460:	e9d3 2300 	ldrd	r2, r3, [r3]
 8013464:	f402 3300 	and.w	r3, r2, #131072	@ 0x20000
 8013468:	65bb      	str	r3, [r7, #88]	@ 0x58
 801346a:	2300      	movs	r3, #0
 801346c:	65fb      	str	r3, [r7, #92]	@ 0x5c
 801346e:	e9d7 1216 	ldrd	r1, r2, [r7, #88]	@ 0x58
 8013472:	460b      	mov	r3, r1
 8013474:	4313      	orrs	r3, r2
 8013476:	d04d      	beq.n	8013514 <HAL_RCCEx_PeriphCLKConfig+0x650>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADF1CLKSOURCE(pPeriphClkInit->Adf1ClockSelection));
    switch (pPeriphClkInit->Adf1ClockSelection)
 8013478:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 801347c:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8013480:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 8013484:	d028      	beq.n	80134d8 <HAL_RCCEx_PeriphCLKConfig+0x614>
 8013486:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 801348a:	d821      	bhi.n	80134d0 <HAL_RCCEx_PeriphCLKConfig+0x60c>
 801348c:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
 8013490:	d024      	beq.n	80134dc <HAL_RCCEx_PeriphCLKConfig+0x618>
 8013492:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
 8013496:	d81b      	bhi.n	80134d0 <HAL_RCCEx_PeriphCLKConfig+0x60c>
 8013498:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 801349c:	d00e      	beq.n	80134bc <HAL_RCCEx_PeriphCLKConfig+0x5f8>
 801349e:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 80134a2:	d815      	bhi.n	80134d0 <HAL_RCCEx_PeriphCLKConfig+0x60c>
 80134a4:	2b00      	cmp	r3, #0
 80134a6:	d01b      	beq.n	80134e0 <HAL_RCCEx_PeriphCLKConfig+0x61c>
 80134a8:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 80134ac:	d110      	bne.n	80134d0 <HAL_RCCEx_PeriphCLKConfig+0x60c>
    {
      case RCC_ADF1CLKSOURCE_PLL1:
        /* Enable PLL1 Clock output generated from System PLL  */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVP);
 80134ae:	4b16      	ldr	r3, [pc, #88]	@ (8013508 <HAL_RCCEx_PeriphCLKConfig+0x644>)
 80134b0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80134b2:	4a15      	ldr	r2, [pc, #84]	@ (8013508 <HAL_RCCEx_PeriphCLKConfig+0x644>)
 80134b4:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 80134b8:	6293      	str	r3, [r2, #40]	@ 0x28
        break;
 80134ba:	e012      	b.n	80134e2 <HAL_RCCEx_PeriphCLKConfig+0x61e>
      case RCC_ADF1CLKSOURCE_PLL3:
        /* PLL3 Q input clock, parameters M, N & Q configuration and clock output (PLL3ClockOut) */
        ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
 80134bc:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 80134c0:	332c      	adds	r3, #44	@ 0x2c
 80134c2:	4618      	mov	r0, r3
 80134c4:	f002 f946 	bl	8015754 <RCCEx_PLL3_Config>
 80134c8:	4603      	mov	r3, r0
 80134ca:	f887 30e3 	strb.w	r3, [r7, #227]	@ 0xe3
        break;
 80134ce:	e008      	b.n	80134e2 <HAL_RCCEx_PeriphCLKConfig+0x61e>
      case RCC_ADF1CLKSOURCE_PIN:
        break;
      case RCC_ADF1CLKSOURCE_MSIK:
        break;
      default:
        ret = HAL_ERROR;
 80134d0:	2301      	movs	r3, #1
 80134d2:	f887 30e3 	strb.w	r3, [r7, #227]	@ 0xe3
        break;
 80134d6:	e004      	b.n	80134e2 <HAL_RCCEx_PeriphCLKConfig+0x61e>
        break;
 80134d8:	bf00      	nop
 80134da:	e002      	b.n	80134e2 <HAL_RCCEx_PeriphCLKConfig+0x61e>
        break;
 80134dc:	bf00      	nop
 80134de:	e000      	b.n	80134e2 <HAL_RCCEx_PeriphCLKConfig+0x61e>
        break;
 80134e0:	bf00      	nop
    }
    if (ret == HAL_OK)
 80134e2:	f897 30e3 	ldrb.w	r3, [r7, #227]	@ 0xe3
 80134e6:	2b00      	cmp	r3, #0
 80134e8:	d110      	bne.n	801350c <HAL_RCCEx_PeriphCLKConfig+0x648>
    {
      /* Configure the ADF1 interface clock source */
      __HAL_RCC_ADF1_CONFIG(pPeriphClkInit->Adf1ClockSelection);
 80134ea:	4b07      	ldr	r3, [pc, #28]	@ (8013508 <HAL_RCCEx_PeriphCLKConfig+0x644>)
 80134ec:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 80134f0:	f423 21e0 	bic.w	r1, r3, #458752	@ 0x70000
 80134f4:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 80134f8:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 80134fc:	4a02      	ldr	r2, [pc, #8]	@ (8013508 <HAL_RCCEx_PeriphCLKConfig+0x644>)
 80134fe:	430b      	orrs	r3, r1
 8013500:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
 8013504:	e006      	b.n	8013514 <HAL_RCCEx_PeriphCLKConfig+0x650>
 8013506:	bf00      	nop
 8013508:	46020c00 	.word	0x46020c00
    }
    else
    {
      /* set overall return value */
      status = ret;
 801350c:	f897 30e3 	ldrb.w	r3, [r7, #227]	@ 0xe3
 8013510:	f887 30e2 	strb.w	r3, [r7, #226]	@ 0xe2
    }
  }

  /*-------------------------- RTC clock source configuration ----------------------*/
  if ((pPeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 8013514:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8013518:	e9d3 2300 	ldrd	r2, r3, [r3]
 801351c:	f402 2380 	and.w	r3, r2, #262144	@ 0x40000
 8013520:	653b      	str	r3, [r7, #80]	@ 0x50
 8013522:	2300      	movs	r3, #0
 8013524:	657b      	str	r3, [r7, #84]	@ 0x54
 8013526:	e9d7 1214 	ldrd	r1, r2, [r7, #80]	@ 0x50
 801352a:	460b      	mov	r3, r1
 801352c:	4313      	orrs	r3, r2
 801352e:	f000 80b5 	beq.w	801369c <HAL_RCCEx_PeriphCLKConfig+0x7d8>
  {
    FlagStatus       pwrclkchanged = RESET;
 8013532:	2300      	movs	r3, #0
 8013534:	f887 30e1 	strb.w	r3, [r7, #225]	@ 0xe1
    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(pPeriphClkInit->RTCClockSelection));
    /* Enable Power Clock */
    if (__HAL_RCC_PWR_IS_CLK_DISABLED())
 8013538:	4b9d      	ldr	r3, [pc, #628]	@ (80137b0 <HAL_RCCEx_PeriphCLKConfig+0x8ec>)
 801353a:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 801353e:	f003 0304 	and.w	r3, r3, #4
 8013542:	2b00      	cmp	r3, #0
 8013544:	d113      	bne.n	801356e <HAL_RCCEx_PeriphCLKConfig+0x6aa>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 8013546:	4b9a      	ldr	r3, [pc, #616]	@ (80137b0 <HAL_RCCEx_PeriphCLKConfig+0x8ec>)
 8013548:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 801354c:	4a98      	ldr	r2, [pc, #608]	@ (80137b0 <HAL_RCCEx_PeriphCLKConfig+0x8ec>)
 801354e:	f043 0304 	orr.w	r3, r3, #4
 8013552:	f8c2 3094 	str.w	r3, [r2, #148]	@ 0x94
 8013556:	4b96      	ldr	r3, [pc, #600]	@ (80137b0 <HAL_RCCEx_PeriphCLKConfig+0x8ec>)
 8013558:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 801355c:	f003 0304 	and.w	r3, r3, #4
 8013560:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
 8013564:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
      pwrclkchanged = SET;
 8013568:	2301      	movs	r3, #1
 801356a:	f887 30e1 	strb.w	r3, [r7, #225]	@ 0xe1
    }
    /* Enable write access to Backup domain */
    SET_BIT(PWR->DBPR, PWR_DBPR_DBP);
 801356e:	4b91      	ldr	r3, [pc, #580]	@ (80137b4 <HAL_RCCEx_PeriphCLKConfig+0x8f0>)
 8013570:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8013572:	4a90      	ldr	r2, [pc, #576]	@ (80137b4 <HAL_RCCEx_PeriphCLKConfig+0x8f0>)
 8013574:	f043 0301 	orr.w	r3, r3, #1
 8013578:	6293      	str	r3, [r2, #40]	@ 0x28

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
 801357a:	f7fa fa71 	bl	800da60 <HAL_GetTick>
 801357e:	f8c7 00dc 	str.w	r0, [r7, #220]	@ 0xdc

    while (HAL_IS_BIT_CLR(PWR->DBPR, PWR_DBPR_DBP))
 8013582:	e00b      	b.n	801359c <HAL_RCCEx_PeriphCLKConfig+0x6d8>
    {
      if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8013584:	f7fa fa6c 	bl	800da60 <HAL_GetTick>
 8013588:	4602      	mov	r2, r0
 801358a:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 801358e:	1ad3      	subs	r3, r2, r3
 8013590:	2b02      	cmp	r3, #2
 8013592:	d903      	bls.n	801359c <HAL_RCCEx_PeriphCLKConfig+0x6d8>
      {
        ret = HAL_TIMEOUT;
 8013594:	2303      	movs	r3, #3
 8013596:	f887 30e3 	strb.w	r3, [r7, #227]	@ 0xe3
        break;
 801359a:	e005      	b.n	80135a8 <HAL_RCCEx_PeriphCLKConfig+0x6e4>
    while (HAL_IS_BIT_CLR(PWR->DBPR, PWR_DBPR_DBP))
 801359c:	4b85      	ldr	r3, [pc, #532]	@ (80137b4 <HAL_RCCEx_PeriphCLKConfig+0x8f0>)
 801359e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80135a0:	f003 0301 	and.w	r3, r3, #1
 80135a4:	2b00      	cmp	r3, #0
 80135a6:	d0ed      	beq.n	8013584 <HAL_RCCEx_PeriphCLKConfig+0x6c0>
      }
    }

    if (ret == HAL_OK)
 80135a8:	f897 30e3 	ldrb.w	r3, [r7, #227]	@ 0xe3
 80135ac:	2b00      	cmp	r3, #0
 80135ae:	d165      	bne.n	801367c <HAL_RCCEx_PeriphCLKConfig+0x7b8>
    {
      /* Reset the Backup domain only if the RTC Clock source selection is modified from default */
      tmpregister = READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL);
 80135b0:	4b7f      	ldr	r3, [pc, #508]	@ (80137b0 <HAL_RCCEx_PeriphCLKConfig+0x8ec>)
 80135b2:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 80135b6:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 80135ba:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4

      if ((tmpregister != RCC_RTCCLKSOURCE_NO_CLK) && (tmpregister != pPeriphClkInit->RTCClockSelection))
 80135be:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 80135c2:	2b00      	cmp	r3, #0
 80135c4:	d023      	beq.n	801360e <HAL_RCCEx_PeriphCLKConfig+0x74a>
 80135c6:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 80135ca:	f8d3 20c0 	ldr.w	r2, [r3, #192]	@ 0xc0
 80135ce:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 80135d2:	4293      	cmp	r3, r2
 80135d4:	d01b      	beq.n	801360e <HAL_RCCEx_PeriphCLKConfig+0x74a>
      {
        /* Store the content of BDCR register before the reset of Backup Domain */
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 80135d6:	4b76      	ldr	r3, [pc, #472]	@ (80137b0 <HAL_RCCEx_PeriphCLKConfig+0x8ec>)
 80135d8:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 80135dc:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
 80135e0:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
        /* RTC Clock selection can be changed only if the Backup Domain is reset */
        __HAL_RCC_BACKUPRESET_FORCE();
 80135e4:	4b72      	ldr	r3, [pc, #456]	@ (80137b0 <HAL_RCCEx_PeriphCLKConfig+0x8ec>)
 80135e6:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 80135ea:	4a71      	ldr	r2, [pc, #452]	@ (80137b0 <HAL_RCCEx_PeriphCLKConfig+0x8ec>)
 80135ec:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 80135f0:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0
        __HAL_RCC_BACKUPRESET_RELEASE();
 80135f4:	4b6e      	ldr	r3, [pc, #440]	@ (80137b0 <HAL_RCCEx_PeriphCLKConfig+0x8ec>)
 80135f6:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 80135fa:	4a6d      	ldr	r2, [pc, #436]	@ (80137b0 <HAL_RCCEx_PeriphCLKConfig+0x8ec>)
 80135fc:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 8013600:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0
        /* Restore the Content of BDCR register */
        RCC->BDCR = tmpregister;
 8013604:	4a6a      	ldr	r2, [pc, #424]	@ (80137b0 <HAL_RCCEx_PeriphCLKConfig+0x8ec>)
 8013606:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 801360a:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0
      }

      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSEON))
 801360e:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 8013612:	f003 0301 	and.w	r3, r3, #1
 8013616:	2b00      	cmp	r3, #0
 8013618:	d019      	beq.n	801364e <HAL_RCCEx_PeriphCLKConfig+0x78a>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 801361a:	f7fa fa21 	bl	800da60 <HAL_GetTick>
 801361e:	f8c7 00dc 	str.w	r0, [r7, #220]	@ 0xdc

        /* Wait till LSE is ready */
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8013622:	e00d      	b.n	8013640 <HAL_RCCEx_PeriphCLKConfig+0x77c>
        {
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8013624:	f7fa fa1c 	bl	800da60 <HAL_GetTick>
 8013628:	4602      	mov	r2, r0
 801362a:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 801362e:	1ad2      	subs	r2, r2, r3
 8013630:	f241 3388 	movw	r3, #5000	@ 0x1388
 8013634:	429a      	cmp	r2, r3
 8013636:	d903      	bls.n	8013640 <HAL_RCCEx_PeriphCLKConfig+0x77c>
          {
            ret = HAL_TIMEOUT;
 8013638:	2303      	movs	r3, #3
 801363a:	f887 30e3 	strb.w	r3, [r7, #227]	@ 0xe3
            break;
 801363e:	e006      	b.n	801364e <HAL_RCCEx_PeriphCLKConfig+0x78a>
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8013640:	4b5b      	ldr	r3, [pc, #364]	@ (80137b0 <HAL_RCCEx_PeriphCLKConfig+0x8ec>)
 8013642:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8013646:	f003 0302 	and.w	r3, r3, #2
 801364a:	2b00      	cmp	r3, #0
 801364c:	d0ea      	beq.n	8013624 <HAL_RCCEx_PeriphCLKConfig+0x760>
          }
        }
      }

      if (ret == HAL_OK)
 801364e:	f897 30e3 	ldrb.w	r3, [r7, #227]	@ 0xe3
 8013652:	2b00      	cmp	r3, #0
 8013654:	d10d      	bne.n	8013672 <HAL_RCCEx_PeriphCLKConfig+0x7ae>
      {
        /* Apply new RTC clock source selection */
        __HAL_RCC_RTC_CONFIG(pPeriphClkInit->RTCClockSelection);
 8013656:	4b56      	ldr	r3, [pc, #344]	@ (80137b0 <HAL_RCCEx_PeriphCLKConfig+0x8ec>)
 8013658:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 801365c:	f423 7140 	bic.w	r1, r3, #768	@ 0x300
 8013660:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8013664:	f8d3 30c0 	ldr.w	r3, [r3, #192]	@ 0xc0
 8013668:	4a51      	ldr	r2, [pc, #324]	@ (80137b0 <HAL_RCCEx_PeriphCLKConfig+0x8ec>)
 801366a:	430b      	orrs	r3, r1
 801366c:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0
 8013670:	e008      	b.n	8013684 <HAL_RCCEx_PeriphCLKConfig+0x7c0>
      }
      else
      {
        /* set overall return value */
        status = ret;
 8013672:	f897 30e3 	ldrb.w	r3, [r7, #227]	@ 0xe3
 8013676:	f887 30e2 	strb.w	r3, [r7, #226]	@ 0xe2
 801367a:	e003      	b.n	8013684 <HAL_RCCEx_PeriphCLKConfig+0x7c0>
      }
    }
    else
    {
      /* set overall return value */
      status = ret;
 801367c:	f897 30e3 	ldrb.w	r3, [r7, #227]	@ 0xe3
 8013680:	f887 30e2 	strb.w	r3, [r7, #226]	@ 0xe2
    }

    /* Restore clock configuration if changed */
    if (pwrclkchanged == SET)
 8013684:	f897 30e1 	ldrb.w	r3, [r7, #225]	@ 0xe1
 8013688:	2b01      	cmp	r3, #1
 801368a:	d107      	bne.n	801369c <HAL_RCCEx_PeriphCLKConfig+0x7d8>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 801368c:	4b48      	ldr	r3, [pc, #288]	@ (80137b0 <HAL_RCCEx_PeriphCLKConfig+0x8ec>)
 801368e:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 8013692:	4a47      	ldr	r2, [pc, #284]	@ (80137b0 <HAL_RCCEx_PeriphCLKConfig+0x8ec>)
 8013694:	f023 0304 	bic.w	r3, r3, #4
 8013698:	f8c2 3094 	str.w	r3, [r2, #148]	@ 0x94
    }
  }

  /*-------------------------------------- ICLK Configuration -----------------------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ICLK) == RCC_PERIPHCLK_ICLK)
 801369c:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 80136a0:	e9d3 2300 	ldrd	r2, r3, [r3]
 80136a4:	f402 1380 	and.w	r3, r2, #1048576	@ 0x100000
 80136a8:	64bb      	str	r3, [r7, #72]	@ 0x48
 80136aa:	2300      	movs	r3, #0
 80136ac:	64fb      	str	r3, [r7, #76]	@ 0x4c
 80136ae:	e9d7 1212 	ldrd	r1, r2, [r7, #72]	@ 0x48
 80136b2:	460b      	mov	r3, r1
 80136b4:	4313      	orrs	r3, r2
 80136b6:	d042      	beq.n	801373e <HAL_RCCEx_PeriphCLKConfig+0x87a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ICLKCLKSOURCE(pPeriphClkInit->IclkClockSelection));

    switch (pPeriphClkInit->IclkClockSelection)
 80136b8:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 80136bc:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
 80136c0:	f1b3 6f40 	cmp.w	r3, #201326592	@ 0xc000000
 80136c4:	d022      	beq.n	801370c <HAL_RCCEx_PeriphCLKConfig+0x848>
 80136c6:	f1b3 6f40 	cmp.w	r3, #201326592	@ 0xc000000
 80136ca:	d81b      	bhi.n	8013704 <HAL_RCCEx_PeriphCLKConfig+0x840>
 80136cc:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 80136d0:	d011      	beq.n	80136f6 <HAL_RCCEx_PeriphCLKConfig+0x832>
 80136d2:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 80136d6:	d815      	bhi.n	8013704 <HAL_RCCEx_PeriphCLKConfig+0x840>
 80136d8:	2b00      	cmp	r3, #0
 80136da:	d019      	beq.n	8013710 <HAL_RCCEx_PeriphCLKConfig+0x84c>
 80136dc:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
 80136e0:	d110      	bne.n	8013704 <HAL_RCCEx_PeriphCLKConfig+0x840>
    {
      case RCC_ICLK_CLKSOURCE_PLL2:
        /* PLL2 input clock, parameters M, N,P,Q & R configuration and clock output (PLL2ClockOut) */
        ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
 80136e2:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 80136e6:	3308      	adds	r3, #8
 80136e8:	4618      	mov	r0, r3
 80136ea:	f001 ff9b 	bl	8015624 <RCCEx_PLL2_Config>
 80136ee:	4603      	mov	r3, r0
 80136f0:	f887 30e3 	strb.w	r3, [r7, #227]	@ 0xe3
        break;
 80136f4:	e00d      	b.n	8013712 <HAL_RCCEx_PeriphCLKConfig+0x84e>
      case RCC_ICLK_CLKSOURCE_PLL1:
        /* Enable ICLK Clock output generated from System PLL  */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 80136f6:	4b2e      	ldr	r3, [pc, #184]	@ (80137b0 <HAL_RCCEx_PeriphCLKConfig+0x8ec>)
 80136f8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80136fa:	4a2d      	ldr	r2, [pc, #180]	@ (80137b0 <HAL_RCCEx_PeriphCLKConfig+0x8ec>)
 80136fc:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8013700:	6293      	str	r3, [r2, #40]	@ 0x28
        break;
 8013702:	e006      	b.n	8013712 <HAL_RCCEx_PeriphCLKConfig+0x84e>
      case RCC_ICLK_CLKSOURCE_HSI48:
        break;
      case RCC_ICLK_CLKSOURCE_MSIK:
        break;
      default:
        ret = HAL_ERROR;
 8013704:	2301      	movs	r3, #1
 8013706:	f887 30e3 	strb.w	r3, [r7, #227]	@ 0xe3
        break;
 801370a:	e002      	b.n	8013712 <HAL_RCCEx_PeriphCLKConfig+0x84e>
        break;
 801370c:	bf00      	nop
 801370e:	e000      	b.n	8013712 <HAL_RCCEx_PeriphCLKConfig+0x84e>
        break;
 8013710:	bf00      	nop
    }
    if (ret == HAL_OK)
 8013712:	f897 30e3 	ldrb.w	r3, [r7, #227]	@ 0xe3
 8013716:	2b00      	cmp	r3, #0
 8013718:	d10d      	bne.n	8013736 <HAL_RCCEx_PeriphCLKConfig+0x872>
    {
      /* Configure the CLK48 source */
      __HAL_RCC_CLK48_CONFIG(pPeriphClkInit->IclkClockSelection);
 801371a:	4b25      	ldr	r3, [pc, #148]	@ (80137b0 <HAL_RCCEx_PeriphCLKConfig+0x8ec>)
 801371c:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8013720:	f023 6140 	bic.w	r1, r3, #201326592	@ 0xc000000
 8013724:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8013728:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
 801372c:	4a20      	ldr	r2, [pc, #128]	@ (80137b0 <HAL_RCCEx_PeriphCLKConfig+0x8ec>)
 801372e:	430b      	orrs	r3, r1
 8013730:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
 8013734:	e003      	b.n	801373e <HAL_RCCEx_PeriphCLKConfig+0x87a>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8013736:	f897 30e3 	ldrb.w	r3, [r7, #227]	@ 0xe3
 801373a:	f887 30e2 	strb.w	r3, [r7, #226]	@ 0xe2
    }
  }

  /*------------------------------ RNG Configuration -------------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == RCC_PERIPHCLK_RNG)
 801373e:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8013742:	e9d3 2300 	ldrd	r2, r3, [r3]
 8013746:	f402 2300 	and.w	r3, r2, #524288	@ 0x80000
 801374a:	643b      	str	r3, [r7, #64]	@ 0x40
 801374c:	2300      	movs	r3, #0
 801374e:	647b      	str	r3, [r7, #68]	@ 0x44
 8013750:	e9d7 1210 	ldrd	r1, r2, [r7, #64]	@ 0x40
 8013754:	460b      	mov	r3, r1
 8013756:	4313      	orrs	r3, r2
 8013758:	d032      	beq.n	80137c0 <HAL_RCCEx_PeriphCLKConfig+0x8fc>
  {

    /* Check the parameters */
    assert_param(IS_RCC_RNGCLKSOURCE(pPeriphClkInit->RngClockSelection));

    switch (pPeriphClkInit->RngClockSelection)
 801375a:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 801375e:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
 8013762:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 8013766:	d00b      	beq.n	8013780 <HAL_RCCEx_PeriphCLKConfig+0x8bc>
 8013768:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 801376c:	d804      	bhi.n	8013778 <HAL_RCCEx_PeriphCLKConfig+0x8b4>
 801376e:	2b00      	cmp	r3, #0
 8013770:	d008      	beq.n	8013784 <HAL_RCCEx_PeriphCLKConfig+0x8c0>
 8013772:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 8013776:	d007      	beq.n	8013788 <HAL_RCCEx_PeriphCLKConfig+0x8c4>
      case RCC_RNGCLKSOURCE_HSI48:
        /* HSI48 oscillator is used as source of RNG clock */
        /* RNG clock source configuration done later after clock selection check */
        break;
      default:
        ret = HAL_ERROR;
 8013778:	2301      	movs	r3, #1
 801377a:	f887 30e3 	strb.w	r3, [r7, #227]	@ 0xe3
        break;
 801377e:	e004      	b.n	801378a <HAL_RCCEx_PeriphCLKConfig+0x8c6>
        break;
 8013780:	bf00      	nop
 8013782:	e002      	b.n	801378a <HAL_RCCEx_PeriphCLKConfig+0x8c6>
        break;
 8013784:	bf00      	nop
 8013786:	e000      	b.n	801378a <HAL_RCCEx_PeriphCLKConfig+0x8c6>
        break;
 8013788:	bf00      	nop
    }
    if (ret == HAL_OK)
 801378a:	f897 30e3 	ldrb.w	r3, [r7, #227]	@ 0xe3
 801378e:	2b00      	cmp	r3, #0
 8013790:	d112      	bne.n	80137b8 <HAL_RCCEx_PeriphCLKConfig+0x8f4>
    {
      /* Set the source of RNG clock*/
      __HAL_RCC_RNG_CONFIG(pPeriphClkInit->RngClockSelection);
 8013792:	4b07      	ldr	r3, [pc, #28]	@ (80137b0 <HAL_RCCEx_PeriphCLKConfig+0x8ec>)
 8013794:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
 8013798:	f423 5140 	bic.w	r1, r3, #12288	@ 0x3000
 801379c:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 80137a0:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
 80137a4:	4a02      	ldr	r2, [pc, #8]	@ (80137b0 <HAL_RCCEx_PeriphCLKConfig+0x8ec>)
 80137a6:	430b      	orrs	r3, r1
 80137a8:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
 80137ac:	e008      	b.n	80137c0 <HAL_RCCEx_PeriphCLKConfig+0x8fc>
 80137ae:	bf00      	nop
 80137b0:	46020c00 	.word	0x46020c00
 80137b4:	46020800 	.word	0x46020800
    }
    else
    {
      /* set overall return value */
      status = ret;
 80137b8:	f897 30e3 	ldrb.w	r3, [r7, #227]	@ 0xe3
 80137bc:	f887 30e2 	strb.w	r3, [r7, #226]	@ 0xe2
    }
  }

#if defined(SAES)
  /*-------------------------- SAES clock source configuration ----------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAES) == RCC_PERIPHCLK_SAES)
 80137c0:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 80137c4:	e9d3 2300 	ldrd	r2, r3, [r3]
 80137c8:	f402 5380 	and.w	r3, r2, #4096	@ 0x1000
 80137cc:	63bb      	str	r3, [r7, #56]	@ 0x38
 80137ce:	2300      	movs	r3, #0
 80137d0:	63fb      	str	r3, [r7, #60]	@ 0x3c
 80137d2:	e9d7 120e 	ldrd	r1, r2, [r7, #56]	@ 0x38
 80137d6:	460b      	mov	r3, r1
 80137d8:	4313      	orrs	r3, r2
 80137da:	d00c      	beq.n	80137f6 <HAL_RCCEx_PeriphCLKConfig+0x932>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAESCLKSOURCE(pPeriphClkInit->SaesClockSelection));

    /* Configure the SAES clock source */
    __HAL_RCC_SAES_CONFIG(pPeriphClkInit->SaesClockSelection);
 80137dc:	4b98      	ldr	r3, [pc, #608]	@ (8013a40 <HAL_RCCEx_PeriphCLKConfig+0xb7c>)
 80137de:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
 80137e2:	f423 6100 	bic.w	r1, r3, #2048	@ 0x800
 80137e6:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 80137ea:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
 80137ee:	4a94      	ldr	r2, [pc, #592]	@ (8013a40 <HAL_RCCEx_PeriphCLKConfig+0xb7c>)
 80137f0:	430b      	orrs	r3, r1
 80137f2:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  }
#endif /* SAES */

  /*-------------------------- SDMMC1/2 clock source configuration -------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC) == (RCC_PERIPHCLK_SDMMC))
 80137f6:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 80137fa:	e9d3 2300 	ldrd	r2, r3, [r3]
 80137fe:	f402 1300 	and.w	r3, r2, #2097152	@ 0x200000
 8013802:	633b      	str	r3, [r7, #48]	@ 0x30
 8013804:	2300      	movs	r3, #0
 8013806:	637b      	str	r3, [r7, #52]	@ 0x34
 8013808:	e9d7 120c 	ldrd	r1, r2, [r7, #48]	@ 0x30
 801380c:	460b      	mov	r3, r1
 801380e:	4313      	orrs	r3, r2
 8013810:	d019      	beq.n	8013846 <HAL_RCCEx_PeriphCLKConfig+0x982>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMCCLKSOURCE(pPeriphClkInit->SdmmcClockSelection));

    if (pPeriphClkInit->SdmmcClockSelection == RCC_SDMMCCLKSOURCE_PLL1)
 8013812:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8013816:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
 801381a:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 801381e:	d105      	bne.n	801382c <HAL_RCCEx_PeriphCLKConfig+0x968>
    {
      /* Enable PLL1 P CLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVP);
 8013820:	4b87      	ldr	r3, [pc, #540]	@ (8013a40 <HAL_RCCEx_PeriphCLKConfig+0xb7c>)
 8013822:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8013824:	4a86      	ldr	r2, [pc, #536]	@ (8013a40 <HAL_RCCEx_PeriphCLKConfig+0xb7c>)
 8013826:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 801382a:	6293      	str	r3, [r2, #40]	@ 0x28
    }

    /* Configure the SDMMC1/2 clock source */
    __HAL_RCC_SDMMC_CONFIG(pPeriphClkInit->SdmmcClockSelection);
 801382c:	4b84      	ldr	r3, [pc, #528]	@ (8013a40 <HAL_RCCEx_PeriphCLKConfig+0xb7c>)
 801382e:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
 8013832:	f423 4180 	bic.w	r1, r3, #16384	@ 0x4000
 8013836:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 801383a:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
 801383e:	4a80      	ldr	r2, [pc, #512]	@ (8013a40 <HAL_RCCEx_PeriphCLKConfig+0xb7c>)
 8013840:	430b      	orrs	r3, r1
 8013842:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  }

  /*-------------------------- SPI1 clock source configuration ----------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI1) == RCC_PERIPHCLK_SPI1)
 8013846:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 801384a:	e9d3 2300 	ldrd	r2, r3, [r3]
 801384e:	f402 0300 	and.w	r3, r2, #8388608	@ 0x800000
 8013852:	62bb      	str	r3, [r7, #40]	@ 0x28
 8013854:	2300      	movs	r3, #0
 8013856:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8013858:	e9d7 120a 	ldrd	r1, r2, [r7, #40]	@ 0x28
 801385c:	460b      	mov	r3, r1
 801385e:	4313      	orrs	r3, r2
 8013860:	d00c      	beq.n	801387c <HAL_RCCEx_PeriphCLKConfig+0x9b8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI1CLKSOURCE(pPeriphClkInit->Spi1ClockSelection));

    /* Configure the SPI1 clock source */
    __HAL_RCC_SPI1_CONFIG(pPeriphClkInit->Spi1ClockSelection);
 8013862:	4b77      	ldr	r3, [pc, #476]	@ (8013a40 <HAL_RCCEx_PeriphCLKConfig+0xb7c>)
 8013864:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8013868:	f423 1240 	bic.w	r2, r3, #3145728	@ 0x300000
 801386c:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8013870:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
 8013874:	4972      	ldr	r1, [pc, #456]	@ (8013a40 <HAL_RCCEx_PeriphCLKConfig+0xb7c>)
 8013876:	4313      	orrs	r3, r2
 8013878:	f8c1 30e0 	str.w	r3, [r1, #224]	@ 0xe0
  }

  /*-------------------------- SPI2 clock source configuration ----------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI2) == RCC_PERIPHCLK_SPI2)
 801387c:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8013880:	e9d3 2300 	ldrd	r2, r3, [r3]
 8013884:	f002 7380 	and.w	r3, r2, #16777216	@ 0x1000000
 8013888:	623b      	str	r3, [r7, #32]
 801388a:	2300      	movs	r3, #0
 801388c:	627b      	str	r3, [r7, #36]	@ 0x24
 801388e:	e9d7 1208 	ldrd	r1, r2, [r7, #32]
 8013892:	460b      	mov	r3, r1
 8013894:	4313      	orrs	r3, r2
 8013896:	d00c      	beq.n	80138b2 <HAL_RCCEx_PeriphCLKConfig+0x9ee>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI2CLKSOURCE(pPeriphClkInit->Spi2ClockSelection));

    /* Configure the SPI2 clock source */
    __HAL_RCC_SPI2_CONFIG(pPeriphClkInit->Spi2ClockSelection);
 8013898:	4b69      	ldr	r3, [pc, #420]	@ (8013a40 <HAL_RCCEx_PeriphCLKConfig+0xb7c>)
 801389a:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 801389e:	f423 3240 	bic.w	r2, r3, #196608	@ 0x30000
 80138a2:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 80138a6:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
 80138aa:	4965      	ldr	r1, [pc, #404]	@ (8013a40 <HAL_RCCEx_PeriphCLKConfig+0xb7c>)
 80138ac:	4313      	orrs	r3, r2
 80138ae:	f8c1 30e0 	str.w	r3, [r1, #224]	@ 0xe0
  }

  /*-------------------------- SPI3 clock source configuration ----------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI3) == RCC_PERIPHCLK_SPI3)
 80138b2:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 80138b6:	e9d3 2300 	ldrd	r2, r3, [r3]
 80138ba:	f002 7300 	and.w	r3, r2, #33554432	@ 0x2000000
 80138be:	61bb      	str	r3, [r7, #24]
 80138c0:	2300      	movs	r3, #0
 80138c2:	61fb      	str	r3, [r7, #28]
 80138c4:	e9d7 1206 	ldrd	r1, r2, [r7, #24]
 80138c8:	460b      	mov	r3, r1
 80138ca:	4313      	orrs	r3, r2
 80138cc:	d00c      	beq.n	80138e8 <HAL_RCCEx_PeriphCLKConfig+0xa24>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI3CLKSOURCE(pPeriphClkInit->Spi3ClockSelection));

    /* Configure the SPI3 clock source */
    __HAL_RCC_SPI3_CONFIG(pPeriphClkInit->Spi3ClockSelection);
 80138ce:	4b5c      	ldr	r3, [pc, #368]	@ (8013a40 <HAL_RCCEx_PeriphCLKConfig+0xb7c>)
 80138d0:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 80138d4:	f023 0218 	bic.w	r2, r3, #24
 80138d8:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 80138dc:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
 80138e0:	4957      	ldr	r1, [pc, #348]	@ (8013a40 <HAL_RCCEx_PeriphCLKConfig+0xb7c>)
 80138e2:	4313      	orrs	r3, r2
 80138e4:	f8c1 30e8 	str.w	r3, [r1, #232]	@ 0xe8
  }

  /*-------------------------- OctoSPIx clock source configuration ----------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_OSPI) == RCC_PERIPHCLK_OSPI)
 80138e8:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 80138ec:	e9d3 2300 	ldrd	r2, r3, [r3]
 80138f0:	f002 6380 	and.w	r3, r2, #67108864	@ 0x4000000
 80138f4:	613b      	str	r3, [r7, #16]
 80138f6:	2300      	movs	r3, #0
 80138f8:	617b      	str	r3, [r7, #20]
 80138fa:	e9d7 1204 	ldrd	r1, r2, [r7, #16]
 80138fe:	460b      	mov	r3, r1
 8013900:	4313      	orrs	r3, r2
 8013902:	d032      	beq.n	801396a <HAL_RCCEx_PeriphCLKConfig+0xaa6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_OSPICLKSOURCE(pPeriphClkInit->OspiClockSelection));

    if (pPeriphClkInit->OspiClockSelection == RCC_OSPICLKSOURCE_PLL1)
 8013904:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8013908:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
 801390c:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 8013910:	d105      	bne.n	801391e <HAL_RCCEx_PeriphCLKConfig+0xa5a>
    {
      /* Enable PLL1 Q CLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8013912:	4b4b      	ldr	r3, [pc, #300]	@ (8013a40 <HAL_RCCEx_PeriphCLKConfig+0xb7c>)
 8013914:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8013916:	4a4a      	ldr	r2, [pc, #296]	@ (8013a40 <HAL_RCCEx_PeriphCLKConfig+0xb7c>)
 8013918:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 801391c:	6293      	str	r3, [r2, #40]	@ 0x28
    }
    if (pPeriphClkInit->OspiClockSelection == RCC_OSPICLKSOURCE_PLL2)
 801391e:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8013922:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
 8013926:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
 801392a:	d108      	bne.n	801393e <HAL_RCCEx_PeriphCLKConfig+0xa7a>
    {
      /* PLL2 input clock, parameters M, N & Q configuration and clock output (PLL2ClockOut) */
      ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
 801392c:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8013930:	3308      	adds	r3, #8
 8013932:	4618      	mov	r0, r3
 8013934:	f001 fe76 	bl	8015624 <RCCEx_PLL2_Config>
 8013938:	4603      	mov	r3, r0
 801393a:	f887 30e3 	strb.w	r3, [r7, #227]	@ 0xe3
    }
    if (ret == HAL_OK)
 801393e:	f897 30e3 	ldrb.w	r3, [r7, #227]	@ 0xe3
 8013942:	2b00      	cmp	r3, #0
 8013944:	d10d      	bne.n	8013962 <HAL_RCCEx_PeriphCLKConfig+0xa9e>
    {
      /* Configure the OctoSPI clock source */
      __HAL_RCC_OSPI_CONFIG(pPeriphClkInit->OspiClockSelection);
 8013946:	4b3e      	ldr	r3, [pc, #248]	@ (8013a40 <HAL_RCCEx_PeriphCLKConfig+0xb7c>)
 8013948:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
 801394c:	f423 1240 	bic.w	r2, r3, #3145728	@ 0x300000
 8013950:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8013954:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
 8013958:	4939      	ldr	r1, [pc, #228]	@ (8013a40 <HAL_RCCEx_PeriphCLKConfig+0xb7c>)
 801395a:	4313      	orrs	r3, r2
 801395c:	f8c1 30e4 	str.w	r3, [r1, #228]	@ 0xe4
 8013960:	e003      	b.n	801396a <HAL_RCCEx_PeriphCLKConfig+0xaa6>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8013962:	f897 30e3 	ldrb.w	r3, [r7, #227]	@ 0xe3
 8013966:	f887 30e2 	strb.w	r3, [r7, #226]	@ 0xe2
    }
  }
#endif /* defined(HSPI1) */

  /*-------------------------- FDCAN1 kernel clock source configuration -------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FDCAN1) == (RCC_PERIPHCLK_FDCAN1))
 801396a:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 801396e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8013972:	f002 6300 	and.w	r3, r2, #134217728	@ 0x8000000
 8013976:	60bb      	str	r3, [r7, #8]
 8013978:	2300      	movs	r3, #0
 801397a:	60fb      	str	r3, [r7, #12]
 801397c:	e9d7 1202 	ldrd	r1, r2, [r7, #8]
 8013980:	460b      	mov	r3, r1
 8013982:	4313      	orrs	r3, r2
 8013984:	d03a      	beq.n	80139fc <HAL_RCCEx_PeriphCLKConfig+0xb38>
  {
    assert_param(IS_RCC_FDCAN1CLK(pPeriphClkInit->Fdcan1ClockSelection));

    switch (pPeriphClkInit->Fdcan1ClockSelection)
 8013986:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 801398a:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 801398e:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 8013992:	d00e      	beq.n	80139b2 <HAL_RCCEx_PeriphCLKConfig+0xaee>
 8013994:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 8013998:	d815      	bhi.n	80139c6 <HAL_RCCEx_PeriphCLKConfig+0xb02>
 801399a:	2b00      	cmp	r3, #0
 801399c:	d017      	beq.n	80139ce <HAL_RCCEx_PeriphCLKConfig+0xb0a>
 801399e:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
 80139a2:	d110      	bne.n	80139c6 <HAL_RCCEx_PeriphCLKConfig+0xb02>
      case RCC_FDCAN1CLKSOURCE_HSE:      /* HSE is used as source of FDCAN1 kernel clock*/
        /* FDCAN1 kernel clock source config set later after clock selection check */
        break;
      case RCC_FDCAN1CLKSOURCE_PLL1:      /* PLL1 is used as clock source for FDCAN1 kernel clock*/
        /* Enable 48M2 Clock output generated from System PLL  */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 80139a4:	4b26      	ldr	r3, [pc, #152]	@ (8013a40 <HAL_RCCEx_PeriphCLKConfig+0xb7c>)
 80139a6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80139a8:	4a25      	ldr	r2, [pc, #148]	@ (8013a40 <HAL_RCCEx_PeriphCLKConfig+0xb7c>)
 80139aa:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 80139ae:	6293      	str	r3, [r2, #40]	@ 0x28
        /* FDCAN1 kernel clock source config set later after clock selection check */
        break;
 80139b0:	e00e      	b.n	80139d0 <HAL_RCCEx_PeriphCLKConfig+0xb0c>
      case RCC_FDCAN1CLKSOURCE_PLL2:  /* PLL2 is used as clock source for FDCAN1 kernel clock*/
        /* PLL2 input clock, parameters M, N & P configuration and clock output (PLL2ClockOut) */
        ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
 80139b2:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 80139b6:	3308      	adds	r3, #8
 80139b8:	4618      	mov	r0, r3
 80139ba:	f001 fe33 	bl	8015624 <RCCEx_PLL2_Config>
 80139be:	4603      	mov	r3, r0
 80139c0:	f887 30e3 	strb.w	r3, [r7, #227]	@ 0xe3
        /* FDCAN1 kernel clock source config set later after clock selection check */
        break;
 80139c4:	e004      	b.n	80139d0 <HAL_RCCEx_PeriphCLKConfig+0xb0c>
      default:
        ret = HAL_ERROR;
 80139c6:	2301      	movs	r3, #1
 80139c8:	f887 30e3 	strb.w	r3, [r7, #227]	@ 0xe3
        break;
 80139cc:	e000      	b.n	80139d0 <HAL_RCCEx_PeriphCLKConfig+0xb0c>
        break;
 80139ce:	bf00      	nop
    }
    if (ret == HAL_OK)
 80139d0:	f897 30e3 	ldrb.w	r3, [r7, #227]	@ 0xe3
 80139d4:	2b00      	cmp	r3, #0
 80139d6:	d10d      	bne.n	80139f4 <HAL_RCCEx_PeriphCLKConfig+0xb30>
    {
      /* Set the source of FDCAN1 kernel clock*/
      __HAL_RCC_FDCAN1_CONFIG(pPeriphClkInit->Fdcan1ClockSelection);
 80139d8:	4b19      	ldr	r3, [pc, #100]	@ (8013a40 <HAL_RCCEx_PeriphCLKConfig+0xb7c>)
 80139da:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 80139de:	f023 7240 	bic.w	r2, r3, #50331648	@ 0x3000000
 80139e2:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 80139e6:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 80139ea:	4915      	ldr	r1, [pc, #84]	@ (8013a40 <HAL_RCCEx_PeriphCLKConfig+0xb7c>)
 80139ec:	4313      	orrs	r3, r2
 80139ee:	f8c1 30e0 	str.w	r3, [r1, #224]	@ 0xe0
 80139f2:	e003      	b.n	80139fc <HAL_RCCEx_PeriphCLKConfig+0xb38>
    }
    else
    {
      /* set overall return value */
      status = ret;
 80139f4:	f897 30e3 	ldrb.w	r3, [r7, #227]	@ 0xe3
 80139f8:	f887 30e2 	strb.w	r3, [r7, #226]	@ 0xe2
    }
  }

  /*-------------------------- DAC1 clock source configuration ----------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DAC1) == RCC_PERIPHCLK_DAC1)
 80139fc:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8013a00:	e9d3 2300 	ldrd	r2, r3, [r3]
 8013a04:	f002 5380 	and.w	r3, r2, #268435456	@ 0x10000000
 8013a08:	603b      	str	r3, [r7, #0]
 8013a0a:	2300      	movs	r3, #0
 8013a0c:	607b      	str	r3, [r7, #4]
 8013a0e:	e9d7 1200 	ldrd	r1, r2, [r7]
 8013a12:	460b      	mov	r3, r1
 8013a14:	4313      	orrs	r3, r2
 8013a16:	d00c      	beq.n	8013a32 <HAL_RCCEx_PeriphCLKConfig+0xb6e>

    /* Check the parameters */
    assert_param(IS_RCC_DAC1CLKSOURCE(pPeriphClkInit->Dac1ClockSelection));

    /* Configure the DAC1 clock source */
    __HAL_RCC_DAC1_CONFIG(pPeriphClkInit->Dac1ClockSelection);
 8013a18:	4b09      	ldr	r3, [pc, #36]	@ (8013a40 <HAL_RCCEx_PeriphCLKConfig+0xb7c>)
 8013a1a:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 8013a1e:	f423 4200 	bic.w	r2, r3, #32768	@ 0x8000
 8013a22:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8013a26:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
 8013a2a:	4905      	ldr	r1, [pc, #20]	@ (8013a40 <HAL_RCCEx_PeriphCLKConfig+0xb7c>)
 8013a2c:	4313      	orrs	r3, r2
 8013a2e:	f8c1 30e8 	str.w	r3, [r1, #232]	@ 0xe8
    }
  }

#endif /* defined(USB_OTG_HS) */

  return status;
 8013a32:	f897 30e2 	ldrb.w	r3, [r7, #226]	@ 0xe2
}
 8013a36:	4618      	mov	r0, r3
 8013a38:	37e8      	adds	r7, #232	@ 0xe8
 8013a3a:	46bd      	mov	sp, r7
 8013a3c:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 8013a40:	46020c00 	.word	0x46020c00

08013a44 <HAL_RCCEx_GetPLL1ClockFreq>:
  *         right PLL1CLK value. Otherwise, any configuration based on this function will be incorrect.
  * @param  PLL1_Clocks structure.
  * @retval None
  */
void HAL_RCCEx_GetPLL1ClockFreq(PLL1_ClocksTypeDef *PLL1_Clocks)
{
 8013a44:	b480      	push	{r7}
 8013a46:	b089      	sub	sp, #36	@ 0x24
 8013a48:	af00      	add	r7, sp, #0
 8013a4a:	6078      	str	r0, [r7, #4]
  uint32_t pll1n;
  uint32_t pll1fracen;
  float_t fracn1;
  float_t pll1vco;

  pll1n = (RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N);
 8013a4c:	4ba6      	ldr	r3, [pc, #664]	@ (8013ce8 <HAL_RCCEx_GetPLL1ClockFreq+0x2a4>)
 8013a4e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8013a50:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8013a54:	61bb      	str	r3, [r7, #24]
  pll1source = (RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1SRC);
 8013a56:	4ba4      	ldr	r3, [pc, #656]	@ (8013ce8 <HAL_RCCEx_GetPLL1ClockFreq+0x2a4>)
 8013a58:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8013a5a:	f003 0303 	and.w	r3, r3, #3
 8013a5e:	617b      	str	r3, [r7, #20]
  pll1m = ((RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1M) >> RCC_PLL1CFGR_PLL1M_Pos) + 1U;
 8013a60:	4ba1      	ldr	r3, [pc, #644]	@ (8013ce8 <HAL_RCCEx_GetPLL1ClockFreq+0x2a4>)
 8013a62:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8013a64:	0a1b      	lsrs	r3, r3, #8
 8013a66:	f003 030f 	and.w	r3, r3, #15
 8013a6a:	3301      	adds	r3, #1
 8013a6c:	613b      	str	r3, [r7, #16]
  pll1fracen = ((RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1FRACEN) >> RCC_PLL1CFGR_PLL1FRACEN_Pos);
 8013a6e:	4b9e      	ldr	r3, [pc, #632]	@ (8013ce8 <HAL_RCCEx_GetPLL1ClockFreq+0x2a4>)
 8013a70:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8013a72:	091b      	lsrs	r3, r3, #4
 8013a74:	f003 0301 	and.w	r3, r3, #1
 8013a78:	60fb      	str	r3, [r7, #12]
  fracn1 = (float_t)(uint32_t)(pll1fracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_PLL1FRACN) >> \
 8013a7a:	4b9b      	ldr	r3, [pc, #620]	@ (8013ce8 <HAL_RCCEx_GetPLL1ClockFreq+0x2a4>)
 8013a7c:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8013a7e:	08db      	lsrs	r3, r3, #3
 8013a80:	f3c3 030c 	ubfx	r3, r3, #0, #13
 8013a84:	68fa      	ldr	r2, [r7, #12]
 8013a86:	fb02 f303 	mul.w	r3, r2, r3
 8013a8a:	ee07 3a90 	vmov	s15, r3
 8013a8e:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8013a92:	edc7 7a02 	vstr	s15, [r7, #8]
                                             RCC_PLL1FRACR_PLL1FRACN_Pos));

  switch (pll1source)
 8013a96:	697b      	ldr	r3, [r7, #20]
 8013a98:	2b03      	cmp	r3, #3
 8013a9a:	d062      	beq.n	8013b62 <HAL_RCCEx_GetPLL1ClockFreq+0x11e>
 8013a9c:	697b      	ldr	r3, [r7, #20]
 8013a9e:	2b03      	cmp	r3, #3
 8013aa0:	f200 8081 	bhi.w	8013ba6 <HAL_RCCEx_GetPLL1ClockFreq+0x162>
 8013aa4:	697b      	ldr	r3, [r7, #20]
 8013aa6:	2b01      	cmp	r3, #1
 8013aa8:	d024      	beq.n	8013af4 <HAL_RCCEx_GetPLL1ClockFreq+0xb0>
 8013aaa:	697b      	ldr	r3, [r7, #20]
 8013aac:	2b02      	cmp	r3, #2
 8013aae:	d17a      	bne.n	8013ba6 <HAL_RCCEx_GetPLL1ClockFreq+0x162>
  {

    case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
      pll1vco = ((float_t)HSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 8013ab0:	693b      	ldr	r3, [r7, #16]
 8013ab2:	ee07 3a90 	vmov	s15, r3
 8013ab6:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8013aba:	eddf 6a8c 	vldr	s13, [pc, #560]	@ 8013cec <HAL_RCCEx_GetPLL1ClockFreq+0x2a8>
 8013abe:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8013ac2:	4b89      	ldr	r3, [pc, #548]	@ (8013ce8 <HAL_RCCEx_GetPLL1ClockFreq+0x2a4>)
 8013ac4:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8013ac6:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8013aca:	ee07 3a90 	vmov	s15, r3
 8013ace:	eef8 6a67 	vcvt.f32.u32	s13, s15
                                                         (fracn1 / (float_t)0x2000) + (float_t)1);
 8013ad2:	ed97 6a02 	vldr	s12, [r7, #8]
 8013ad6:	eddf 5a86 	vldr	s11, [pc, #536]	@ 8013cf0 <HAL_RCCEx_GetPLL1ClockFreq+0x2ac>
 8013ada:	eec6 7a25 	vdiv.f32	s15, s12, s11
      pll1vco = ((float_t)HSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 8013ade:	ee76 7aa7 	vadd.f32	s15, s13, s15
                                                         (fracn1 / (float_t)0x2000) + (float_t)1);
 8013ae2:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8013ae6:	ee77 7aa6 	vadd.f32	s15, s15, s13
      pll1vco = ((float_t)HSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 8013aea:	ee67 7a27 	vmul.f32	s15, s14, s15
 8013aee:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
 8013af2:	e08f      	b.n	8013c14 <HAL_RCCEx_GetPLL1ClockFreq+0x1d0>
    case RCC_PLLSOURCE_MSI:  /* MSI used as PLL clock source */
      pll1vco = ((float_t)MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> RCC_ICSCR1_MSISRANGE_Pos)] / (float_t)pll1m) * \
 8013af4:	4b7c      	ldr	r3, [pc, #496]	@ (8013ce8 <HAL_RCCEx_GetPLL1ClockFreq+0x2a4>)
 8013af6:	689b      	ldr	r3, [r3, #8]
 8013af8:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 8013afc:	2b00      	cmp	r3, #0
 8013afe:	d005      	beq.n	8013b0c <HAL_RCCEx_GetPLL1ClockFreq+0xc8>
 8013b00:	4b79      	ldr	r3, [pc, #484]	@ (8013ce8 <HAL_RCCEx_GetPLL1ClockFreq+0x2a4>)
 8013b02:	689b      	ldr	r3, [r3, #8]
 8013b04:	0f1b      	lsrs	r3, r3, #28
 8013b06:	f003 030f 	and.w	r3, r3, #15
 8013b0a:	e006      	b.n	8013b1a <HAL_RCCEx_GetPLL1ClockFreq+0xd6>
 8013b0c:	4b76      	ldr	r3, [pc, #472]	@ (8013ce8 <HAL_RCCEx_GetPLL1ClockFreq+0x2a4>)
 8013b0e:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 8013b12:	041b      	lsls	r3, r3, #16
 8013b14:	0f1b      	lsrs	r3, r3, #28
 8013b16:	f003 030f 	and.w	r3, r3, #15
 8013b1a:	4a76      	ldr	r2, [pc, #472]	@ (8013cf4 <HAL_RCCEx_GetPLL1ClockFreq+0x2b0>)
 8013b1c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8013b20:	ee07 3a90 	vmov	s15, r3
 8013b24:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8013b28:	693b      	ldr	r3, [r7, #16]
 8013b2a:	ee07 3a90 	vmov	s15, r3
 8013b2e:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8013b32:	ee86 7aa7 	vdiv.f32	s14, s13, s15
                ((float_t)pll1n + (fracn1 / (float_t)0x2000) + (float_t)1);
 8013b36:	69bb      	ldr	r3, [r7, #24]
 8013b38:	ee07 3a90 	vmov	s15, r3
 8013b3c:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8013b40:	ed97 6a02 	vldr	s12, [r7, #8]
 8013b44:	eddf 5a6a 	vldr	s11, [pc, #424]	@ 8013cf0 <HAL_RCCEx_GetPLL1ClockFreq+0x2ac>
 8013b48:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8013b4c:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8013b50:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8013b54:	ee77 7aa6 	vadd.f32	s15, s15, s13
      pll1vco = ((float_t)MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> RCC_ICSCR1_MSISRANGE_Pos)] / (float_t)pll1m) * \
 8013b58:	ee67 7a27 	vmul.f32	s15, s14, s15
 8013b5c:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
 8013b60:	e058      	b.n	8013c14 <HAL_RCCEx_GetPLL1ClockFreq+0x1d0>
    case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
      pll1vco = ((float_t)HSE_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 8013b62:	693b      	ldr	r3, [r7, #16]
 8013b64:	ee07 3a90 	vmov	s15, r3
 8013b68:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8013b6c:	eddf 6a5f 	vldr	s13, [pc, #380]	@ 8013cec <HAL_RCCEx_GetPLL1ClockFreq+0x2a8>
 8013b70:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8013b74:	4b5c      	ldr	r3, [pc, #368]	@ (8013ce8 <HAL_RCCEx_GetPLL1ClockFreq+0x2a4>)
 8013b76:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8013b78:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8013b7c:	ee07 3a90 	vmov	s15, r3
 8013b80:	eef8 6a67 	vcvt.f32.u32	s13, s15
                                                         (fracn1 / (float_t)0x2000) + (float_t)1);
 8013b84:	ed97 6a02 	vldr	s12, [r7, #8]
 8013b88:	eddf 5a59 	vldr	s11, [pc, #356]	@ 8013cf0 <HAL_RCCEx_GetPLL1ClockFreq+0x2ac>
 8013b8c:	eec6 7a25 	vdiv.f32	s15, s12, s11
      pll1vco = ((float_t)HSE_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 8013b90:	ee76 7aa7 	vadd.f32	s15, s13, s15
                                                         (fracn1 / (float_t)0x2000) + (float_t)1);
 8013b94:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8013b98:	ee77 7aa6 	vadd.f32	s15, s15, s13
      pll1vco = ((float_t)HSE_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 8013b9c:	ee67 7a27 	vmul.f32	s15, s14, s15
 8013ba0:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
 8013ba4:	e036      	b.n	8013c14 <HAL_RCCEx_GetPLL1ClockFreq+0x1d0>
    default:
      pll1vco = ((float_t)MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> RCC_ICSCR1_MSISRANGE_Pos)] / (float_t)pll1m) * \
 8013ba6:	4b50      	ldr	r3, [pc, #320]	@ (8013ce8 <HAL_RCCEx_GetPLL1ClockFreq+0x2a4>)
 8013ba8:	689b      	ldr	r3, [r3, #8]
 8013baa:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 8013bae:	2b00      	cmp	r3, #0
 8013bb0:	d005      	beq.n	8013bbe <HAL_RCCEx_GetPLL1ClockFreq+0x17a>
 8013bb2:	4b4d      	ldr	r3, [pc, #308]	@ (8013ce8 <HAL_RCCEx_GetPLL1ClockFreq+0x2a4>)
 8013bb4:	689b      	ldr	r3, [r3, #8]
 8013bb6:	0f1b      	lsrs	r3, r3, #28
 8013bb8:	f003 030f 	and.w	r3, r3, #15
 8013bbc:	e006      	b.n	8013bcc <HAL_RCCEx_GetPLL1ClockFreq+0x188>
 8013bbe:	4b4a      	ldr	r3, [pc, #296]	@ (8013ce8 <HAL_RCCEx_GetPLL1ClockFreq+0x2a4>)
 8013bc0:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 8013bc4:	041b      	lsls	r3, r3, #16
 8013bc6:	0f1b      	lsrs	r3, r3, #28
 8013bc8:	f003 030f 	and.w	r3, r3, #15
 8013bcc:	4a49      	ldr	r2, [pc, #292]	@ (8013cf4 <HAL_RCCEx_GetPLL1ClockFreq+0x2b0>)
 8013bce:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8013bd2:	ee07 3a90 	vmov	s15, r3
 8013bd6:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8013bda:	693b      	ldr	r3, [r7, #16]
 8013bdc:	ee07 3a90 	vmov	s15, r3
 8013be0:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8013be4:	ee86 7aa7 	vdiv.f32	s14, s13, s15
                ((float_t)pll1n + (fracn1 / (float_t)0x2000) + (float_t)1);
 8013be8:	69bb      	ldr	r3, [r7, #24]
 8013bea:	ee07 3a90 	vmov	s15, r3
 8013bee:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8013bf2:	ed97 6a02 	vldr	s12, [r7, #8]
 8013bf6:	eddf 5a3e 	vldr	s11, [pc, #248]	@ 8013cf0 <HAL_RCCEx_GetPLL1ClockFreq+0x2ac>
 8013bfa:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8013bfe:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8013c02:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8013c06:	ee77 7aa6 	vadd.f32	s15, s15, s13
      pll1vco = ((float_t)MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> RCC_ICSCR1_MSISRANGE_Pos)] / (float_t)pll1m) * \
 8013c0a:	ee67 7a27 	vmul.f32	s15, s14, s15
 8013c0e:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
 8013c12:	bf00      	nop
  }

  if (__HAL_RCC_GET_PLLCLKOUT_CONFIG(RCC_PLL1_DIVP) != 0U)
 8013c14:	4b34      	ldr	r3, [pc, #208]	@ (8013ce8 <HAL_RCCEx_GetPLL1ClockFreq+0x2a4>)
 8013c16:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8013c18:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 8013c1c:	2b00      	cmp	r3, #0
 8013c1e:	d017      	beq.n	8013c50 <HAL_RCCEx_GetPLL1ClockFreq+0x20c>
  {
    PLL1_Clocks->PLL1_P_Frequency = (uint32_t)(float_t)(pll1vco / ((float_t)(uint32_t)((RCC->PLL1DIVR & \
 8013c20:	4b31      	ldr	r3, [pc, #196]	@ (8013ce8 <HAL_RCCEx_GetPLL1ClockFreq+0x2a4>)
 8013c22:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8013c24:	0a5b      	lsrs	r3, r3, #9
 8013c26:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8013c2a:	ee07 3a90 	vmov	s15, r3
 8013c2e:	eef8 7a67 	vcvt.f32.u32	s15, s15
                                                                   RCC_PLL1DIVR_PLL1P) >> RCC_PLL1DIVR_PLL1P_Pos) + \
 8013c32:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 8013c36:	ee37 7a87 	vadd.f32	s14, s15, s14
    PLL1_Clocks->PLL1_P_Frequency = (uint32_t)(float_t)(pll1vco / ((float_t)(uint32_t)((RCC->PLL1DIVR & \
 8013c3a:	edd7 6a07 	vldr	s13, [r7, #28]
 8013c3e:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8013c42:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8013c46:	ee17 2a90 	vmov	r2, s15
 8013c4a:	687b      	ldr	r3, [r7, #4]
 8013c4c:	601a      	str	r2, [r3, #0]
 8013c4e:	e002      	b.n	8013c56 <HAL_RCCEx_GetPLL1ClockFreq+0x212>
                                                                   (float_t)1));
  }
  else
  {
    PLL1_Clocks->PLL1_P_Frequency = 0U;
 8013c50:	687b      	ldr	r3, [r7, #4]
 8013c52:	2200      	movs	r2, #0
 8013c54:	601a      	str	r2, [r3, #0]
  }

  if (__HAL_RCC_GET_PLLCLKOUT_CONFIG(RCC_PLL1_DIVQ) != 0U)
 8013c56:	4b24      	ldr	r3, [pc, #144]	@ (8013ce8 <HAL_RCCEx_GetPLL1ClockFreq+0x2a4>)
 8013c58:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8013c5a:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8013c5e:	2b00      	cmp	r3, #0
 8013c60:	d017      	beq.n	8013c92 <HAL_RCCEx_GetPLL1ClockFreq+0x24e>
  {
    PLL1_Clocks->PLL1_Q_Frequency = (uint32_t)(float_t)(pll1vco / ((float_t)(uint32_t)((RCC->PLL1DIVR & \
 8013c62:	4b21      	ldr	r3, [pc, #132]	@ (8013ce8 <HAL_RCCEx_GetPLL1ClockFreq+0x2a4>)
 8013c64:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8013c66:	0c1b      	lsrs	r3, r3, #16
 8013c68:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8013c6c:	ee07 3a90 	vmov	s15, r3
 8013c70:	eef8 7a67 	vcvt.f32.u32	s15, s15
                                                                   RCC_PLL1DIVR_PLL1Q) >> RCC_PLL1DIVR_PLL1Q_Pos) + \
 8013c74:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 8013c78:	ee37 7a87 	vadd.f32	s14, s15, s14
    PLL1_Clocks->PLL1_Q_Frequency = (uint32_t)(float_t)(pll1vco / ((float_t)(uint32_t)((RCC->PLL1DIVR & \
 8013c7c:	edd7 6a07 	vldr	s13, [r7, #28]
 8013c80:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8013c84:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8013c88:	ee17 2a90 	vmov	r2, s15
 8013c8c:	687b      	ldr	r3, [r7, #4]
 8013c8e:	605a      	str	r2, [r3, #4]
 8013c90:	e002      	b.n	8013c98 <HAL_RCCEx_GetPLL1ClockFreq+0x254>
                                                                   (float_t)1));
  }
  else
  {
    PLL1_Clocks->PLL1_Q_Frequency = 0U;
 8013c92:	687b      	ldr	r3, [r7, #4]
 8013c94:	2200      	movs	r2, #0
 8013c96:	605a      	str	r2, [r3, #4]
  }

  if (__HAL_RCC_GET_PLLCLKOUT_CONFIG(RCC_PLL1_DIVR) != 0U)
 8013c98:	4b13      	ldr	r3, [pc, #76]	@ (8013ce8 <HAL_RCCEx_GetPLL1ClockFreq+0x2a4>)
 8013c9a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8013c9c:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
 8013ca0:	2b00      	cmp	r3, #0
 8013ca2:	d017      	beq.n	8013cd4 <HAL_RCCEx_GetPLL1ClockFreq+0x290>
  {
    PLL1_Clocks->PLL1_R_Frequency = (uint32_t)(float_t)(pll1vco / ((float_t)(uint32_t)((RCC->PLL1DIVR & \
 8013ca4:	4b10      	ldr	r3, [pc, #64]	@ (8013ce8 <HAL_RCCEx_GetPLL1ClockFreq+0x2a4>)
 8013ca6:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8013ca8:	0e1b      	lsrs	r3, r3, #24
 8013caa:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8013cae:	ee07 3a90 	vmov	s15, r3
 8013cb2:	eef8 7a67 	vcvt.f32.u32	s15, s15
                                                                   RCC_PLL1DIVR_PLL1R) >> RCC_PLL1DIVR_PLL1R_Pos) + \
 8013cb6:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 8013cba:	ee37 7a87 	vadd.f32	s14, s15, s14
    PLL1_Clocks->PLL1_R_Frequency = (uint32_t)(float_t)(pll1vco / ((float_t)(uint32_t)((RCC->PLL1DIVR & \
 8013cbe:	edd7 6a07 	vldr	s13, [r7, #28]
 8013cc2:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8013cc6:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8013cca:	ee17 2a90 	vmov	r2, s15
 8013cce:	687b      	ldr	r3, [r7, #4]
 8013cd0:	609a      	str	r2, [r3, #8]
  else
  {
    PLL1_Clocks->PLL1_R_Frequency = 0U;
  }

}
 8013cd2:	e002      	b.n	8013cda <HAL_RCCEx_GetPLL1ClockFreq+0x296>
    PLL1_Clocks->PLL1_R_Frequency = 0U;
 8013cd4:	687b      	ldr	r3, [r7, #4]
 8013cd6:	2200      	movs	r2, #0
 8013cd8:	609a      	str	r2, [r3, #8]
}
 8013cda:	bf00      	nop
 8013cdc:	3724      	adds	r7, #36	@ 0x24
 8013cde:	46bd      	mov	sp, r7
 8013ce0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013ce4:	4770      	bx	lr
 8013ce6:	bf00      	nop
 8013ce8:	46020c00 	.word	0x46020c00
 8013cec:	4b742400 	.word	0x4b742400
 8013cf0:	46000000 	.word	0x46000000
 8013cf4:	0802a4e0 	.word	0x0802a4e0

08013cf8 <HAL_RCCEx_GetPLL2ClockFreq>:
  *         right PLL2CLK value. Otherwise, any configuration based on this function will be incorrect.
  * @param  PLL2_Clocks structure.
  * @retval None
  */
void HAL_RCCEx_GetPLL2ClockFreq(PLL2_ClocksTypeDef *PLL2_Clocks)
{
 8013cf8:	b480      	push	{r7}
 8013cfa:	b089      	sub	sp, #36	@ 0x24
 8013cfc:	af00      	add	r7, sp, #0
 8013cfe:	6078      	str	r0, [r7, #4]
  float_t fracn2;
  float_t pll2vco;

  /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLL2M) * PLL2N
     PLL2xCLK = PLL2_VCO / PLL2x */
  pll2n = (RCC->PLL2DIVR & RCC_PLL2DIVR_PLL2N);
 8013d00:	4ba6      	ldr	r3, [pc, #664]	@ (8013f9c <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>)
 8013d02:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8013d04:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8013d08:	61bb      	str	r3, [r7, #24]
  pll2source = (RCC->PLL2CFGR & RCC_PLL2CFGR_PLL2SRC);
 8013d0a:	4ba4      	ldr	r3, [pc, #656]	@ (8013f9c <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>)
 8013d0c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8013d0e:	f003 0303 	and.w	r3, r3, #3
 8013d12:	617b      	str	r3, [r7, #20]
  pll2m = ((RCC->PLL2CFGR & RCC_PLL2CFGR_PLL2M) >> RCC_PLL2CFGR_PLL2M_Pos) + 1U;
 8013d14:	4ba1      	ldr	r3, [pc, #644]	@ (8013f9c <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>)
 8013d16:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8013d18:	0a1b      	lsrs	r3, r3, #8
 8013d1a:	f003 030f 	and.w	r3, r3, #15
 8013d1e:	3301      	adds	r3, #1
 8013d20:	613b      	str	r3, [r7, #16]
  pll2fracen = ((RCC->PLL2CFGR & RCC_PLL2CFGR_PLL2FRACEN) >> RCC_PLL2CFGR_PLL2FRACEN_Pos);
 8013d22:	4b9e      	ldr	r3, [pc, #632]	@ (8013f9c <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>)
 8013d24:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8013d26:	091b      	lsrs	r3, r3, #4
 8013d28:	f003 0301 	and.w	r3, r3, #1
 8013d2c:	60fb      	str	r3, [r7, #12]
  fracn2 = (float_t)(uint32_t)(pll2fracen * ((RCC->PLL2FRACR & RCC_PLL2FRACR_PLL2FRACN) >> \
 8013d2e:	4b9b      	ldr	r3, [pc, #620]	@ (8013f9c <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>)
 8013d30:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8013d32:	08db      	lsrs	r3, r3, #3
 8013d34:	f3c3 030c 	ubfx	r3, r3, #0, #13
 8013d38:	68fa      	ldr	r2, [r7, #12]
 8013d3a:	fb02 f303 	mul.w	r3, r2, r3
 8013d3e:	ee07 3a90 	vmov	s15, r3
 8013d42:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8013d46:	edc7 7a02 	vstr	s15, [r7, #8]
                                             RCC_PLL2FRACR_PLL2FRACN_Pos));

  switch (pll2source)
 8013d4a:	697b      	ldr	r3, [r7, #20]
 8013d4c:	2b03      	cmp	r3, #3
 8013d4e:	d062      	beq.n	8013e16 <HAL_RCCEx_GetPLL2ClockFreq+0x11e>
 8013d50:	697b      	ldr	r3, [r7, #20]
 8013d52:	2b03      	cmp	r3, #3
 8013d54:	f200 8081 	bhi.w	8013e5a <HAL_RCCEx_GetPLL2ClockFreq+0x162>
 8013d58:	697b      	ldr	r3, [r7, #20]
 8013d5a:	2b01      	cmp	r3, #1
 8013d5c:	d024      	beq.n	8013da8 <HAL_RCCEx_GetPLL2ClockFreq+0xb0>
 8013d5e:	697b      	ldr	r3, [r7, #20]
 8013d60:	2b02      	cmp	r3, #2
 8013d62:	d17a      	bne.n	8013e5a <HAL_RCCEx_GetPLL2ClockFreq+0x162>
  {
    case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
      pll2vco = ((float_t)HSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_PLL2N) + \
 8013d64:	693b      	ldr	r3, [r7, #16]
 8013d66:	ee07 3a90 	vmov	s15, r3
 8013d6a:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8013d6e:	eddf 6a8c 	vldr	s13, [pc, #560]	@ 8013fa0 <HAL_RCCEx_GetPLL2ClockFreq+0x2a8>
 8013d72:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8013d76:	4b89      	ldr	r3, [pc, #548]	@ (8013f9c <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>)
 8013d78:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8013d7a:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8013d7e:	ee07 3a90 	vmov	s15, r3
 8013d82:	eef8 6a67 	vcvt.f32.u32	s13, s15
                                                         (fracn2 / (float_t)0x2000) + (float_t)1);
 8013d86:	ed97 6a02 	vldr	s12, [r7, #8]
 8013d8a:	eddf 5a86 	vldr	s11, [pc, #536]	@ 8013fa4 <HAL_RCCEx_GetPLL2ClockFreq+0x2ac>
 8013d8e:	eec6 7a25 	vdiv.f32	s15, s12, s11
      pll2vco = ((float_t)HSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_PLL2N) + \
 8013d92:	ee76 7aa7 	vadd.f32	s15, s13, s15
                                                         (fracn2 / (float_t)0x2000) + (float_t)1);
 8013d96:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8013d9a:	ee77 7aa6 	vadd.f32	s15, s15, s13
      pll2vco = ((float_t)HSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_PLL2N) + \
 8013d9e:	ee67 7a27 	vmul.f32	s15, s14, s15
 8013da2:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
 8013da6:	e08f      	b.n	8013ec8 <HAL_RCCEx_GetPLL2ClockFreq+0x1d0>

    case RCC_PLLSOURCE_MSI:  /* MSI used as PLL clock source */
      pll2vco = ((float_t)MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> RCC_ICSCR1_MSISRANGE_Pos)] / (float_t)pll2m) * \
 8013da8:	4b7c      	ldr	r3, [pc, #496]	@ (8013f9c <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>)
 8013daa:	689b      	ldr	r3, [r3, #8]
 8013dac:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 8013db0:	2b00      	cmp	r3, #0
 8013db2:	d005      	beq.n	8013dc0 <HAL_RCCEx_GetPLL2ClockFreq+0xc8>
 8013db4:	4b79      	ldr	r3, [pc, #484]	@ (8013f9c <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>)
 8013db6:	689b      	ldr	r3, [r3, #8]
 8013db8:	0f1b      	lsrs	r3, r3, #28
 8013dba:	f003 030f 	and.w	r3, r3, #15
 8013dbe:	e006      	b.n	8013dce <HAL_RCCEx_GetPLL2ClockFreq+0xd6>
 8013dc0:	4b76      	ldr	r3, [pc, #472]	@ (8013f9c <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>)
 8013dc2:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 8013dc6:	041b      	lsls	r3, r3, #16
 8013dc8:	0f1b      	lsrs	r3, r3, #28
 8013dca:	f003 030f 	and.w	r3, r3, #15
 8013dce:	4a76      	ldr	r2, [pc, #472]	@ (8013fa8 <HAL_RCCEx_GetPLL2ClockFreq+0x2b0>)
 8013dd0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8013dd4:	ee07 3a90 	vmov	s15, r3
 8013dd8:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8013ddc:	693b      	ldr	r3, [r7, #16]
 8013dde:	ee07 3a90 	vmov	s15, r3
 8013de2:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8013de6:	ee86 7aa7 	vdiv.f32	s14, s13, s15
                ((float_t)pll2n + (fracn2 / (float_t)0x2000) + (float_t)1);
 8013dea:	69bb      	ldr	r3, [r7, #24]
 8013dec:	ee07 3a90 	vmov	s15, r3
 8013df0:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8013df4:	ed97 6a02 	vldr	s12, [r7, #8]
 8013df8:	eddf 5a6a 	vldr	s11, [pc, #424]	@ 8013fa4 <HAL_RCCEx_GetPLL2ClockFreq+0x2ac>
 8013dfc:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8013e00:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8013e04:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8013e08:	ee77 7aa6 	vadd.f32	s15, s15, s13
      pll2vco = ((float_t)MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> RCC_ICSCR1_MSISRANGE_Pos)] / (float_t)pll2m) * \
 8013e0c:	ee67 7a27 	vmul.f32	s15, s14, s15
 8013e10:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
 8013e14:	e058      	b.n	8013ec8 <HAL_RCCEx_GetPLL2ClockFreq+0x1d0>

    case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
      pll2vco = ((float_t)HSE_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_PLL2N) + \
 8013e16:	693b      	ldr	r3, [r7, #16]
 8013e18:	ee07 3a90 	vmov	s15, r3
 8013e1c:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8013e20:	eddf 6a5f 	vldr	s13, [pc, #380]	@ 8013fa0 <HAL_RCCEx_GetPLL2ClockFreq+0x2a8>
 8013e24:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8013e28:	4b5c      	ldr	r3, [pc, #368]	@ (8013f9c <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>)
 8013e2a:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8013e2c:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8013e30:	ee07 3a90 	vmov	s15, r3
 8013e34:	eef8 6a67 	vcvt.f32.u32	s13, s15
                                                         (fracn2 / (float_t)0x2000) + (float_t)1);
 8013e38:	ed97 6a02 	vldr	s12, [r7, #8]
 8013e3c:	eddf 5a59 	vldr	s11, [pc, #356]	@ 8013fa4 <HAL_RCCEx_GetPLL2ClockFreq+0x2ac>
 8013e40:	eec6 7a25 	vdiv.f32	s15, s12, s11
      pll2vco = ((float_t)HSE_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_PLL2N) + \
 8013e44:	ee76 7aa7 	vadd.f32	s15, s13, s15
                                                         (fracn2 / (float_t)0x2000) + (float_t)1);
 8013e48:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8013e4c:	ee77 7aa6 	vadd.f32	s15, s15, s13
      pll2vco = ((float_t)HSE_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_PLL2N) + \
 8013e50:	ee67 7a27 	vmul.f32	s15, s14, s15
 8013e54:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
 8013e58:	e036      	b.n	8013ec8 <HAL_RCCEx_GetPLL2ClockFreq+0x1d0>

    default:
      pll2vco = ((float_t)MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> RCC_ICSCR1_MSISRANGE_Pos)] / (float_t) pll2m) \
 8013e5a:	4b50      	ldr	r3, [pc, #320]	@ (8013f9c <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>)
 8013e5c:	689b      	ldr	r3, [r3, #8]
 8013e5e:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 8013e62:	2b00      	cmp	r3, #0
 8013e64:	d005      	beq.n	8013e72 <HAL_RCCEx_GetPLL2ClockFreq+0x17a>
 8013e66:	4b4d      	ldr	r3, [pc, #308]	@ (8013f9c <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>)
 8013e68:	689b      	ldr	r3, [r3, #8]
 8013e6a:	0f1b      	lsrs	r3, r3, #28
 8013e6c:	f003 030f 	and.w	r3, r3, #15
 8013e70:	e006      	b.n	8013e80 <HAL_RCCEx_GetPLL2ClockFreq+0x188>
 8013e72:	4b4a      	ldr	r3, [pc, #296]	@ (8013f9c <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>)
 8013e74:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 8013e78:	041b      	lsls	r3, r3, #16
 8013e7a:	0f1b      	lsrs	r3, r3, #28
 8013e7c:	f003 030f 	and.w	r3, r3, #15
 8013e80:	4a49      	ldr	r2, [pc, #292]	@ (8013fa8 <HAL_RCCEx_GetPLL2ClockFreq+0x2b0>)
 8013e82:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8013e86:	ee07 3a90 	vmov	s15, r3
 8013e8a:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8013e8e:	693b      	ldr	r3, [r7, #16]
 8013e90:	ee07 3a90 	vmov	s15, r3
 8013e94:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8013e98:	ee86 7aa7 	vdiv.f32	s14, s13, s15
                * ((float_t)pll2n + (fracn2 / (float_t)0x2000) + (float_t)1);
 8013e9c:	69bb      	ldr	r3, [r7, #24]
 8013e9e:	ee07 3a90 	vmov	s15, r3
 8013ea2:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8013ea6:	ed97 6a02 	vldr	s12, [r7, #8]
 8013eaa:	eddf 5a3e 	vldr	s11, [pc, #248]	@ 8013fa4 <HAL_RCCEx_GetPLL2ClockFreq+0x2ac>
 8013eae:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8013eb2:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8013eb6:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8013eba:	ee77 7aa6 	vadd.f32	s15, s15, s13
      pll2vco = ((float_t)MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> RCC_ICSCR1_MSISRANGE_Pos)] / (float_t) pll2m) \
 8013ebe:	ee67 7a27 	vmul.f32	s15, s14, s15
 8013ec2:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
 8013ec6:	bf00      	nop
  }
  if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL2_DIVP) != 0U)
 8013ec8:	4b34      	ldr	r3, [pc, #208]	@ (8013f9c <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>)
 8013eca:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8013ecc:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 8013ed0:	2b00      	cmp	r3, #0
 8013ed2:	d017      	beq.n	8013f04 <HAL_RCCEx_GetPLL2ClockFreq+0x20c>
  {
    PLL2_Clocks->PLL2_P_Frequency = (uint32_t)(float_t)(pll2vco / ((float_t)(uint32_t)((RCC->PLL2DIVR & \
 8013ed4:	4b31      	ldr	r3, [pc, #196]	@ (8013f9c <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>)
 8013ed6:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8013ed8:	0a5b      	lsrs	r3, r3, #9
 8013eda:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8013ede:	ee07 3a90 	vmov	s15, r3
 8013ee2:	eef8 7a67 	vcvt.f32.u32	s15, s15
                                                                   RCC_PLL2DIVR_PLL2P) >> RCC_PLL2DIVR_PLL2P_Pos) + \
 8013ee6:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 8013eea:	ee37 7a87 	vadd.f32	s14, s15, s14
    PLL2_Clocks->PLL2_P_Frequency = (uint32_t)(float_t)(pll2vco / ((float_t)(uint32_t)((RCC->PLL2DIVR & \
 8013eee:	edd7 6a07 	vldr	s13, [r7, #28]
 8013ef2:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8013ef6:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8013efa:	ee17 2a90 	vmov	r2, s15
 8013efe:	687b      	ldr	r3, [r7, #4]
 8013f00:	601a      	str	r2, [r3, #0]
 8013f02:	e002      	b.n	8013f0a <HAL_RCCEx_GetPLL2ClockFreq+0x212>
                                                                   (float_t)1));
  }
  else
  {
    PLL2_Clocks->PLL2_P_Frequency = 0U;
 8013f04:	687b      	ldr	r3, [r7, #4]
 8013f06:	2200      	movs	r2, #0
 8013f08:	601a      	str	r2, [r3, #0]
  }
  if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL2_DIVQ) != 0U)
 8013f0a:	4b24      	ldr	r3, [pc, #144]	@ (8013f9c <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>)
 8013f0c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8013f0e:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8013f12:	2b00      	cmp	r3, #0
 8013f14:	d017      	beq.n	8013f46 <HAL_RCCEx_GetPLL2ClockFreq+0x24e>
  {
    PLL2_Clocks->PLL2_Q_Frequency = (uint32_t)(float_t)(pll2vco / ((float_t)(uint32_t)((RCC->PLL2DIVR & \
 8013f16:	4b21      	ldr	r3, [pc, #132]	@ (8013f9c <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>)
 8013f18:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8013f1a:	0c1b      	lsrs	r3, r3, #16
 8013f1c:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8013f20:	ee07 3a90 	vmov	s15, r3
 8013f24:	eef8 7a67 	vcvt.f32.u32	s15, s15
                                                                   RCC_PLL2DIVR_PLL2Q) >> RCC_PLL2DIVR_PLL2Q_Pos) + \
 8013f28:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 8013f2c:	ee37 7a87 	vadd.f32	s14, s15, s14
    PLL2_Clocks->PLL2_Q_Frequency = (uint32_t)(float_t)(pll2vco / ((float_t)(uint32_t)((RCC->PLL2DIVR & \
 8013f30:	edd7 6a07 	vldr	s13, [r7, #28]
 8013f34:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8013f38:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8013f3c:	ee17 2a90 	vmov	r2, s15
 8013f40:	687b      	ldr	r3, [r7, #4]
 8013f42:	605a      	str	r2, [r3, #4]
 8013f44:	e002      	b.n	8013f4c <HAL_RCCEx_GetPLL2ClockFreq+0x254>
                                                                   (float_t)1));
  }
  else
  {
    PLL2_Clocks->PLL2_Q_Frequency = 0U;
 8013f46:	687b      	ldr	r3, [r7, #4]
 8013f48:	2200      	movs	r2, #0
 8013f4a:	605a      	str	r2, [r3, #4]
  }
  if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL2_DIVR) != 0U)
 8013f4c:	4b13      	ldr	r3, [pc, #76]	@ (8013f9c <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>)
 8013f4e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8013f50:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
 8013f54:	2b00      	cmp	r3, #0
 8013f56:	d017      	beq.n	8013f88 <HAL_RCCEx_GetPLL2ClockFreq+0x290>
  {
    PLL2_Clocks->PLL2_R_Frequency = (uint32_t)(float_t)(pll2vco / ((float_t)(uint32_t)((RCC->PLL2DIVR & \
 8013f58:	4b10      	ldr	r3, [pc, #64]	@ (8013f9c <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>)
 8013f5a:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8013f5c:	0e1b      	lsrs	r3, r3, #24
 8013f5e:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8013f62:	ee07 3a90 	vmov	s15, r3
 8013f66:	eef8 7a67 	vcvt.f32.u32	s15, s15
                                                                   RCC_PLL2DIVR_PLL2R) >> RCC_PLL2DIVR_PLL2R_Pos) + \
 8013f6a:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 8013f6e:	ee37 7a87 	vadd.f32	s14, s15, s14
    PLL2_Clocks->PLL2_R_Frequency = (uint32_t)(float_t)(pll2vco / ((float_t)(uint32_t)((RCC->PLL2DIVR & \
 8013f72:	edd7 6a07 	vldr	s13, [r7, #28]
 8013f76:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8013f7a:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8013f7e:	ee17 2a90 	vmov	r2, s15
 8013f82:	687b      	ldr	r3, [r7, #4]
 8013f84:	609a      	str	r2, [r3, #8]
  }
  else
  {
    PLL2_Clocks->PLL2_R_Frequency = 0U;
  }
}
 8013f86:	e002      	b.n	8013f8e <HAL_RCCEx_GetPLL2ClockFreq+0x296>
    PLL2_Clocks->PLL2_R_Frequency = 0U;
 8013f88:	687b      	ldr	r3, [r7, #4]
 8013f8a:	2200      	movs	r2, #0
 8013f8c:	609a      	str	r2, [r3, #8]
}
 8013f8e:	bf00      	nop
 8013f90:	3724      	adds	r7, #36	@ 0x24
 8013f92:	46bd      	mov	sp, r7
 8013f94:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013f98:	4770      	bx	lr
 8013f9a:	bf00      	nop
 8013f9c:	46020c00 	.word	0x46020c00
 8013fa0:	4b742400 	.word	0x4b742400
 8013fa4:	46000000 	.word	0x46000000
 8013fa8:	0802a4e0 	.word	0x0802a4e0

08013fac <HAL_RCCEx_GetPLL3ClockFreq>:
  *         right PLL3CLK value. Otherwise, any configuration based on this function will be incorrect.
  * @param  PLL3_Clocks structure.
  * @retval None
  */
void HAL_RCCEx_GetPLL3ClockFreq(PLL3_ClocksTypeDef *PLL3_Clocks)
{
 8013fac:	b480      	push	{r7}
 8013fae:	b089      	sub	sp, #36	@ 0x24
 8013fb0:	af00      	add	r7, sp, #0
 8013fb2:	6078      	str	r0, [r7, #4]

  /* PLL3_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLL3M) * PLL3N
  PLL3xCLK = PLL3_VCO / PLLxR
  */

  pll3n = (RCC->PLL3DIVR & RCC_PLL3DIVR_PLL3N);
 8013fb4:	4ba6      	ldr	r3, [pc, #664]	@ (8014250 <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>)
 8013fb6:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8013fb8:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8013fbc:	61bb      	str	r3, [r7, #24]
  pll3source = (RCC->PLL3CFGR & RCC_PLL3CFGR_PLL3SRC);
 8013fbe:	4ba4      	ldr	r3, [pc, #656]	@ (8014250 <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>)
 8013fc0:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8013fc2:	f003 0303 	and.w	r3, r3, #3
 8013fc6:	617b      	str	r3, [r7, #20]
  pll3m = ((RCC->PLL3CFGR & RCC_PLL3CFGR_PLL3M) >> RCC_PLL3CFGR_PLL3M_Pos) + 1U;
 8013fc8:	4ba1      	ldr	r3, [pc, #644]	@ (8014250 <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>)
 8013fca:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8013fcc:	0a1b      	lsrs	r3, r3, #8
 8013fce:	f003 030f 	and.w	r3, r3, #15
 8013fd2:	3301      	adds	r3, #1
 8013fd4:	613b      	str	r3, [r7, #16]
  pll3fracen = ((RCC->PLL3CFGR & RCC_PLL3CFGR_PLL3FRACEN) >> RCC_PLL3CFGR_PLL3FRACEN_Pos);
 8013fd6:	4b9e      	ldr	r3, [pc, #632]	@ (8014250 <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>)
 8013fd8:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8013fda:	091b      	lsrs	r3, r3, #4
 8013fdc:	f003 0301 	and.w	r3, r3, #1
 8013fe0:	60fb      	str	r3, [r7, #12]
  fracn3 = (float_t)(uint32_t)(pll3fracen * ((RCC->PLL3FRACR & RCC_PLL3FRACR_PLL3FRACN) >> \
 8013fe2:	4b9b      	ldr	r3, [pc, #620]	@ (8014250 <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>)
 8013fe4:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 8013fe6:	08db      	lsrs	r3, r3, #3
 8013fe8:	f3c3 030c 	ubfx	r3, r3, #0, #13
 8013fec:	68fa      	ldr	r2, [r7, #12]
 8013fee:	fb02 f303 	mul.w	r3, r2, r3
 8013ff2:	ee07 3a90 	vmov	s15, r3
 8013ff6:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8013ffa:	edc7 7a02 	vstr	s15, [r7, #8]
                                             RCC_PLL3FRACR_PLL3FRACN_Pos));

  switch (pll3source)
 8013ffe:	697b      	ldr	r3, [r7, #20]
 8014000:	2b03      	cmp	r3, #3
 8014002:	d062      	beq.n	80140ca <HAL_RCCEx_GetPLL3ClockFreq+0x11e>
 8014004:	697b      	ldr	r3, [r7, #20]
 8014006:	2b03      	cmp	r3, #3
 8014008:	f200 8081 	bhi.w	801410e <HAL_RCCEx_GetPLL3ClockFreq+0x162>
 801400c:	697b      	ldr	r3, [r7, #20]
 801400e:	2b01      	cmp	r3, #1
 8014010:	d024      	beq.n	801405c <HAL_RCCEx_GetPLL3ClockFreq+0xb0>
 8014012:	697b      	ldr	r3, [r7, #20]
 8014014:	2b02      	cmp	r3, #2
 8014016:	d17a      	bne.n	801410e <HAL_RCCEx_GetPLL3ClockFreq+0x162>
  {
    case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
      pll3vco = ((float_t)HSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_PLL3N) + \
 8014018:	693b      	ldr	r3, [r7, #16]
 801401a:	ee07 3a90 	vmov	s15, r3
 801401e:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8014022:	eddf 6a8c 	vldr	s13, [pc, #560]	@ 8014254 <HAL_RCCEx_GetPLL3ClockFreq+0x2a8>
 8014026:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 801402a:	4b89      	ldr	r3, [pc, #548]	@ (8014250 <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>)
 801402c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 801402e:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8014032:	ee07 3a90 	vmov	s15, r3
 8014036:	eef8 6a67 	vcvt.f32.u32	s13, s15
                                                         (fracn3 / (float_t)0x2000) + (float_t)1);
 801403a:	ed97 6a02 	vldr	s12, [r7, #8]
 801403e:	eddf 5a86 	vldr	s11, [pc, #536]	@ 8014258 <HAL_RCCEx_GetPLL3ClockFreq+0x2ac>
 8014042:	eec6 7a25 	vdiv.f32	s15, s12, s11
      pll3vco = ((float_t)HSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_PLL3N) + \
 8014046:	ee76 7aa7 	vadd.f32	s15, s13, s15
                                                         (fracn3 / (float_t)0x2000) + (float_t)1);
 801404a:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 801404e:	ee77 7aa6 	vadd.f32	s15, s15, s13
      pll3vco = ((float_t)HSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_PLL3N) + \
 8014052:	ee67 7a27 	vmul.f32	s15, s14, s15
 8014056:	edc7 7a07 	vstr	s15, [r7, #28]

      break;
 801405a:	e08f      	b.n	801417c <HAL_RCCEx_GetPLL3ClockFreq+0x1d0>
    case RCC_PLLSOURCE_MSI:  /* MSI used as PLL clock source */
      pll3vco = ((float_t)MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> RCC_ICSCR1_MSISRANGE_Pos)] / (float_t)pll3m) * \
 801405c:	4b7c      	ldr	r3, [pc, #496]	@ (8014250 <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>)
 801405e:	689b      	ldr	r3, [r3, #8]
 8014060:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 8014064:	2b00      	cmp	r3, #0
 8014066:	d005      	beq.n	8014074 <HAL_RCCEx_GetPLL3ClockFreq+0xc8>
 8014068:	4b79      	ldr	r3, [pc, #484]	@ (8014250 <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>)
 801406a:	689b      	ldr	r3, [r3, #8]
 801406c:	0f1b      	lsrs	r3, r3, #28
 801406e:	f003 030f 	and.w	r3, r3, #15
 8014072:	e006      	b.n	8014082 <HAL_RCCEx_GetPLL3ClockFreq+0xd6>
 8014074:	4b76      	ldr	r3, [pc, #472]	@ (8014250 <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>)
 8014076:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 801407a:	041b      	lsls	r3, r3, #16
 801407c:	0f1b      	lsrs	r3, r3, #28
 801407e:	f003 030f 	and.w	r3, r3, #15
 8014082:	4a76      	ldr	r2, [pc, #472]	@ (801425c <HAL_RCCEx_GetPLL3ClockFreq+0x2b0>)
 8014084:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8014088:	ee07 3a90 	vmov	s15, r3
 801408c:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8014090:	693b      	ldr	r3, [r7, #16]
 8014092:	ee07 3a90 	vmov	s15, r3
 8014096:	eef8 7a67 	vcvt.f32.u32	s15, s15
 801409a:	ee86 7aa7 	vdiv.f32	s14, s13, s15
                ((float_t)pll3n + (fracn3 / (float_t)0x2000) + (float_t)1);
 801409e:	69bb      	ldr	r3, [r7, #24]
 80140a0:	ee07 3a90 	vmov	s15, r3
 80140a4:	eef8 6a67 	vcvt.f32.u32	s13, s15
 80140a8:	ed97 6a02 	vldr	s12, [r7, #8]
 80140ac:	eddf 5a6a 	vldr	s11, [pc, #424]	@ 8014258 <HAL_RCCEx_GetPLL3ClockFreq+0x2ac>
 80140b0:	eec6 7a25 	vdiv.f32	s15, s12, s11
 80140b4:	ee76 7aa7 	vadd.f32	s15, s13, s15
 80140b8:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 80140bc:	ee77 7aa6 	vadd.f32	s15, s15, s13
      pll3vco = ((float_t)MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> RCC_ICSCR1_MSISRANGE_Pos)] / (float_t)pll3m) * \
 80140c0:	ee67 7a27 	vmul.f32	s15, s14, s15
 80140c4:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
 80140c8:	e058      	b.n	801417c <HAL_RCCEx_GetPLL3ClockFreq+0x1d0>

    case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
      pll3vco = ((float_t)HSE_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_PLL3N) + \
 80140ca:	693b      	ldr	r3, [r7, #16]
 80140cc:	ee07 3a90 	vmov	s15, r3
 80140d0:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80140d4:	eddf 6a5f 	vldr	s13, [pc, #380]	@ 8014254 <HAL_RCCEx_GetPLL3ClockFreq+0x2a8>
 80140d8:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 80140dc:	4b5c      	ldr	r3, [pc, #368]	@ (8014250 <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>)
 80140de:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 80140e0:	f3c3 0308 	ubfx	r3, r3, #0, #9
 80140e4:	ee07 3a90 	vmov	s15, r3
 80140e8:	eef8 6a67 	vcvt.f32.u32	s13, s15
                                                         (fracn3 / (float_t)0x2000) + (float_t)1);
 80140ec:	ed97 6a02 	vldr	s12, [r7, #8]
 80140f0:	eddf 5a59 	vldr	s11, [pc, #356]	@ 8014258 <HAL_RCCEx_GetPLL3ClockFreq+0x2ac>
 80140f4:	eec6 7a25 	vdiv.f32	s15, s12, s11
      pll3vco = ((float_t)HSE_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_PLL3N) + \
 80140f8:	ee76 7aa7 	vadd.f32	s15, s13, s15
                                                         (fracn3 / (float_t)0x2000) + (float_t)1);
 80140fc:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8014100:	ee77 7aa6 	vadd.f32	s15, s15, s13
      pll3vco = ((float_t)HSE_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_PLL3N) + \
 8014104:	ee67 7a27 	vmul.f32	s15, s14, s15
 8014108:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
 801410c:	e036      	b.n	801417c <HAL_RCCEx_GetPLL3ClockFreq+0x1d0>

    default:
      pll3vco = ((float_t)MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> RCC_ICSCR1_MSISRANGE_Pos)] / (float_t)pll3m) * \
 801410e:	4b50      	ldr	r3, [pc, #320]	@ (8014250 <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>)
 8014110:	689b      	ldr	r3, [r3, #8]
 8014112:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 8014116:	2b00      	cmp	r3, #0
 8014118:	d005      	beq.n	8014126 <HAL_RCCEx_GetPLL3ClockFreq+0x17a>
 801411a:	4b4d      	ldr	r3, [pc, #308]	@ (8014250 <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>)
 801411c:	689b      	ldr	r3, [r3, #8]
 801411e:	0f1b      	lsrs	r3, r3, #28
 8014120:	f003 030f 	and.w	r3, r3, #15
 8014124:	e006      	b.n	8014134 <HAL_RCCEx_GetPLL3ClockFreq+0x188>
 8014126:	4b4a      	ldr	r3, [pc, #296]	@ (8014250 <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>)
 8014128:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 801412c:	041b      	lsls	r3, r3, #16
 801412e:	0f1b      	lsrs	r3, r3, #28
 8014130:	f003 030f 	and.w	r3, r3, #15
 8014134:	4a49      	ldr	r2, [pc, #292]	@ (801425c <HAL_RCCEx_GetPLL3ClockFreq+0x2b0>)
 8014136:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801413a:	ee07 3a90 	vmov	s15, r3
 801413e:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8014142:	693b      	ldr	r3, [r7, #16]
 8014144:	ee07 3a90 	vmov	s15, r3
 8014148:	eef8 7a67 	vcvt.f32.u32	s15, s15
 801414c:	ee86 7aa7 	vdiv.f32	s14, s13, s15
                ((float_t)pll3n + (fracn3 / (float_t)0x2000) + (float_t)1);
 8014150:	69bb      	ldr	r3, [r7, #24]
 8014152:	ee07 3a90 	vmov	s15, r3
 8014156:	eef8 6a67 	vcvt.f32.u32	s13, s15
 801415a:	ed97 6a02 	vldr	s12, [r7, #8]
 801415e:	eddf 5a3e 	vldr	s11, [pc, #248]	@ 8014258 <HAL_RCCEx_GetPLL3ClockFreq+0x2ac>
 8014162:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8014166:	ee76 7aa7 	vadd.f32	s15, s13, s15
 801416a:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 801416e:	ee77 7aa6 	vadd.f32	s15, s15, s13
      pll3vco = ((float_t)MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> RCC_ICSCR1_MSISRANGE_Pos)] / (float_t)pll3m) * \
 8014172:	ee67 7a27 	vmul.f32	s15, s14, s15
 8014176:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
 801417a:	bf00      	nop
  }

  if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL3_DIVP) != 0U)
 801417c:	4b34      	ldr	r3, [pc, #208]	@ (8014250 <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>)
 801417e:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8014180:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 8014184:	2b00      	cmp	r3, #0
 8014186:	d017      	beq.n	80141b8 <HAL_RCCEx_GetPLL3ClockFreq+0x20c>
  {
    PLL3_Clocks->PLL3_P_Frequency = (uint32_t)(float_t)(pll3vco / ((float_t)(uint32_t)((RCC->PLL3DIVR & \
 8014188:	4b31      	ldr	r3, [pc, #196]	@ (8014250 <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>)
 801418a:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 801418c:	0a5b      	lsrs	r3, r3, #9
 801418e:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8014192:	ee07 3a90 	vmov	s15, r3
 8014196:	eef8 7a67 	vcvt.f32.u32	s15, s15
                                                                   RCC_PLL3DIVR_PLL3P) >> RCC_PLL3DIVR_PLL3P_Pos) + \
 801419a:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 801419e:	ee37 7a87 	vadd.f32	s14, s15, s14
    PLL3_Clocks->PLL3_P_Frequency = (uint32_t)(float_t)(pll3vco / ((float_t)(uint32_t)((RCC->PLL3DIVR & \
 80141a2:	edd7 6a07 	vldr	s13, [r7, #28]
 80141a6:	eec6 7a87 	vdiv.f32	s15, s13, s14
 80141aa:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 80141ae:	ee17 2a90 	vmov	r2, s15
 80141b2:	687b      	ldr	r3, [r7, #4]
 80141b4:	601a      	str	r2, [r3, #0]
 80141b6:	e002      	b.n	80141be <HAL_RCCEx_GetPLL3ClockFreq+0x212>
                                                                   (float_t)1));
  }
  else
  {
    PLL3_Clocks->PLL3_P_Frequency = 0U;
 80141b8:	687b      	ldr	r3, [r7, #4]
 80141ba:	2200      	movs	r2, #0
 80141bc:	601a      	str	r2, [r3, #0]
  }

  if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL3_DIVQ) != 0U)
 80141be:	4b24      	ldr	r3, [pc, #144]	@ (8014250 <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>)
 80141c0:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80141c2:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 80141c6:	2b00      	cmp	r3, #0
 80141c8:	d017      	beq.n	80141fa <HAL_RCCEx_GetPLL3ClockFreq+0x24e>
  {
    PLL3_Clocks->PLL3_Q_Frequency = (uint32_t)(float_t)(pll3vco / ((float_t)(uint32_t)((RCC->PLL3DIVR & \
 80141ca:	4b21      	ldr	r3, [pc, #132]	@ (8014250 <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>)
 80141cc:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 80141ce:	0c1b      	lsrs	r3, r3, #16
 80141d0:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 80141d4:	ee07 3a90 	vmov	s15, r3
 80141d8:	eef8 7a67 	vcvt.f32.u32	s15, s15
                                                                   RCC_PLL3DIVR_PLL3Q) >> RCC_PLL3DIVR_PLL3Q_Pos) + \
 80141dc:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 80141e0:	ee37 7a87 	vadd.f32	s14, s15, s14
    PLL3_Clocks->PLL3_Q_Frequency = (uint32_t)(float_t)(pll3vco / ((float_t)(uint32_t)((RCC->PLL3DIVR & \
 80141e4:	edd7 6a07 	vldr	s13, [r7, #28]
 80141e8:	eec6 7a87 	vdiv.f32	s15, s13, s14
 80141ec:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 80141f0:	ee17 2a90 	vmov	r2, s15
 80141f4:	687b      	ldr	r3, [r7, #4]
 80141f6:	605a      	str	r2, [r3, #4]
 80141f8:	e002      	b.n	8014200 <HAL_RCCEx_GetPLL3ClockFreq+0x254>
                                                                   (float_t)1));
  }
  else
  {
    PLL3_Clocks->PLL3_Q_Frequency = 0U;
 80141fa:	687b      	ldr	r3, [r7, #4]
 80141fc:	2200      	movs	r2, #0
 80141fe:	605a      	str	r2, [r3, #4]
  }

  if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL3_DIVR) != 0U)
 8014200:	4b13      	ldr	r3, [pc, #76]	@ (8014250 <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>)
 8014202:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8014204:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
 8014208:	2b00      	cmp	r3, #0
 801420a:	d017      	beq.n	801423c <HAL_RCCEx_GetPLL3ClockFreq+0x290>
  {
    PLL3_Clocks->PLL3_R_Frequency = (uint32_t)(float_t)(pll3vco / ((float_t)(uint32_t)((RCC->PLL3DIVR & \
 801420c:	4b10      	ldr	r3, [pc, #64]	@ (8014250 <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>)
 801420e:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8014210:	0e1b      	lsrs	r3, r3, #24
 8014212:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8014216:	ee07 3a90 	vmov	s15, r3
 801421a:	eef8 7a67 	vcvt.f32.u32	s15, s15
                                                                   RCC_PLL3DIVR_PLL3R) >> RCC_PLL3DIVR_PLL3R_Pos) + \
 801421e:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 8014222:	ee37 7a87 	vadd.f32	s14, s15, s14
    PLL3_Clocks->PLL3_R_Frequency = (uint32_t)(float_t)(pll3vco / ((float_t)(uint32_t)((RCC->PLL3DIVR & \
 8014226:	edd7 6a07 	vldr	s13, [r7, #28]
 801422a:	eec6 7a87 	vdiv.f32	s15, s13, s14
 801422e:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8014232:	ee17 2a90 	vmov	r2, s15
 8014236:	687b      	ldr	r3, [r7, #4]
 8014238:	609a      	str	r2, [r3, #8]
  else
  {
    PLL3_Clocks->PLL3_R_Frequency = 0U;
  }

}
 801423a:	e002      	b.n	8014242 <HAL_RCCEx_GetPLL3ClockFreq+0x296>
    PLL3_Clocks->PLL3_R_Frequency = 0U;
 801423c:	687b      	ldr	r3, [r7, #4]
 801423e:	2200      	movs	r2, #0
 8014240:	609a      	str	r2, [r3, #8]
}
 8014242:	bf00      	nop
 8014244:	3724      	adds	r7, #36	@ 0x24
 8014246:	46bd      	mov	sp, r7
 8014248:	f85d 7b04 	ldr.w	r7, [sp], #4
 801424c:	4770      	bx	lr
 801424e:	bf00      	nop
 8014250:	46020c00 	.word	0x46020c00
 8014254:	4b742400 	.word	0x4b742400
 8014258:	46000000 	.word	0x46000000
 801425c:	0802a4e0 	.word	0x0802a4e0

08014260 <HAL_RCCEx_GetPeriphCLKFreq>:
  * @retval Frequency in Hz
  *
  *        (*) value not defined in all devices.
  */
uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint64_t PeriphClk)
{
 8014260:	b580      	push	{r7, lr}
 8014262:	b08e      	sub	sp, #56	@ 0x38
 8014264:	af00      	add	r7, sp, #0
 8014266:	e9c7 0100 	strd	r0, r1, [r7]
  uint32_t srcclk;

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClk));

  if (PeriphClk == RCC_PERIPHCLK_RTC)
 801426a:	e9d7 2300 	ldrd	r2, r3, [r7]
 801426e:	f5a2 2180 	sub.w	r1, r2, #262144	@ 0x40000
 8014272:	430b      	orrs	r3, r1
 8014274:	d145      	bne.n	8014302 <HAL_RCCEx_GetPeriphCLKFreq+0xa2>
  {
    /* Get the current RTC source */
    srcclk = __HAL_RCC_GET_RTC_SOURCE();
 8014276:	4ba7      	ldr	r3, [pc, #668]	@ (8014514 <HAL_RCCEx_GetPeriphCLKFreq+0x2b4>)
 8014278:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 801427c:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 8014280:	633b      	str	r3, [r7, #48]	@ 0x30

    /* Check if LSE is ready and if RTC clock selection is LSE */
    if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_RTCCLKSOURCE_LSE))
 8014282:	4ba4      	ldr	r3, [pc, #656]	@ (8014514 <HAL_RCCEx_GetPeriphCLKFreq+0x2b4>)
 8014284:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8014288:	f003 0302 	and.w	r3, r3, #2
 801428c:	2b02      	cmp	r3, #2
 801428e:	d108      	bne.n	80142a2 <HAL_RCCEx_GetPeriphCLKFreq+0x42>
 8014290:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014292:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8014296:	d104      	bne.n	80142a2 <HAL_RCCEx_GetPeriphCLKFreq+0x42>
    {
      frequency = LSE_VALUE;
 8014298:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 801429c:	637b      	str	r3, [r7, #52]	@ 0x34
 801429e:	f001 b9b3 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
    /* Check if LSI is ready and if RTC clock selection is LSI */
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIRDY)) && (srcclk == RCC_RTCCLKSOURCE_LSI))
 80142a2:	4b9c      	ldr	r3, [pc, #624]	@ (8014514 <HAL_RCCEx_GetPeriphCLKFreq+0x2b4>)
 80142a4:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 80142a8:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 80142ac:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 80142b0:	d114      	bne.n	80142dc <HAL_RCCEx_GetPeriphCLKFreq+0x7c>
 80142b2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80142b4:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 80142b8:	d110      	bne.n	80142dc <HAL_RCCEx_GetPeriphCLKFreq+0x7c>
    {
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIPREDIV))
 80142ba:	4b96      	ldr	r3, [pc, #600]	@ (8014514 <HAL_RCCEx_GetPeriphCLKFreq+0x2b4>)
 80142bc:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 80142c0:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 80142c4:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 80142c8:	d103      	bne.n	80142d2 <HAL_RCCEx_GetPeriphCLKFreq+0x72>
      {
        frequency = LSI_VALUE / 128U;
 80142ca:	23fa      	movs	r3, #250	@ 0xfa
 80142cc:	637b      	str	r3, [r7, #52]	@ 0x34
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIPREDIV))
 80142ce:	f001 b99b 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
      }
      else
      {
        frequency = LSI_VALUE;
 80142d2:	f44f 43fa 	mov.w	r3, #32000	@ 0x7d00
 80142d6:	637b      	str	r3, [r7, #52]	@ 0x34
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIPREDIV))
 80142d8:	f001 b996 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
      }
    }
    /* Check if HSE is ready  and if RTC clock selection is HSI_DIV32*/
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (srcclk == RCC_RTCCLKSOURCE_HSE_DIV32))
 80142dc:	4b8d      	ldr	r3, [pc, #564]	@ (8014514 <HAL_RCCEx_GetPeriphCLKFreq+0x2b4>)
 80142de:	681b      	ldr	r3, [r3, #0]
 80142e0:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 80142e4:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 80142e8:	d107      	bne.n	80142fa <HAL_RCCEx_GetPeriphCLKFreq+0x9a>
 80142ea:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80142ec:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
 80142f0:	d103      	bne.n	80142fa <HAL_RCCEx_GetPeriphCLKFreq+0x9a>
    {
      frequency = HSE_VALUE / 32U;
 80142f2:	4b89      	ldr	r3, [pc, #548]	@ (8014518 <HAL_RCCEx_GetPeriphCLKFreq+0x2b8>)
 80142f4:	637b      	str	r3, [r7, #52]	@ 0x34
 80142f6:	f001 b987 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
    /* Clock not enabled for RTC*/
    else
    {
      frequency = 0U;
 80142fa:	2300      	movs	r3, #0
 80142fc:	637b      	str	r3, [r7, #52]	@ 0x34
 80142fe:	f001 b983 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_SAI1)
 8014302:	e9d7 2300 	ldrd	r2, r3, [r7]
 8014306:	f5a2 5100 	sub.w	r1, r2, #8192	@ 0x2000
 801430a:	430b      	orrs	r3, r1
 801430c:	d151      	bne.n	80143b2 <HAL_RCCEx_GetPeriphCLKFreq+0x152>
  {
    srcclk = __HAL_RCC_GET_SAI1_SOURCE();
 801430e:	4b81      	ldr	r3, [pc, #516]	@ (8014514 <HAL_RCCEx_GetPeriphCLKFreq+0x2b4>)
 8014310:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
 8014314:	f003 03e0 	and.w	r3, r3, #224	@ 0xe0
 8014318:	633b      	str	r3, [r7, #48]	@ 0x30

    switch (srcclk)
 801431a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801431c:	2b80      	cmp	r3, #128	@ 0x80
 801431e:	d035      	beq.n	801438c <HAL_RCCEx_GetPeriphCLKFreq+0x12c>
 8014320:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014322:	2b80      	cmp	r3, #128	@ 0x80
 8014324:	d841      	bhi.n	80143aa <HAL_RCCEx_GetPeriphCLKFreq+0x14a>
 8014326:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014328:	2b60      	cmp	r3, #96	@ 0x60
 801432a:	d02a      	beq.n	8014382 <HAL_RCCEx_GetPeriphCLKFreq+0x122>
 801432c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801432e:	2b60      	cmp	r3, #96	@ 0x60
 8014330:	d83b      	bhi.n	80143aa <HAL_RCCEx_GetPeriphCLKFreq+0x14a>
 8014332:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014334:	2b40      	cmp	r3, #64	@ 0x40
 8014336:	d009      	beq.n	801434c <HAL_RCCEx_GetPeriphCLKFreq+0xec>
 8014338:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801433a:	2b40      	cmp	r3, #64	@ 0x40
 801433c:	d835      	bhi.n	80143aa <HAL_RCCEx_GetPeriphCLKFreq+0x14a>
 801433e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014340:	2b00      	cmp	r3, #0
 8014342:	d00c      	beq.n	801435e <HAL_RCCEx_GetPeriphCLKFreq+0xfe>
 8014344:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014346:	2b20      	cmp	r3, #32
 8014348:	d012      	beq.n	8014370 <HAL_RCCEx_GetPeriphCLKFreq+0x110>
 801434a:	e02e      	b.n	80143aa <HAL_RCCEx_GetPeriphCLKFreq+0x14a>
    {
      case RCC_SAI1CLKSOURCE_PLL1: /* PLL1P is the clock source for SAI1 */

        HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 801434c:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 8014350:	4618      	mov	r0, r3
 8014352:	f7ff fb77 	bl	8013a44 <HAL_RCCEx_GetPLL1ClockFreq>
        frequency = pll1_clocks.PLL1_P_Frequency;
 8014356:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8014358:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 801435a:	f001 b955 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>

      case RCC_SAI1CLKSOURCE_PLL2: /* PLL2P is the clock source for SAI1 */

        HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 801435e:	f107 0318 	add.w	r3, r7, #24
 8014362:	4618      	mov	r0, r3
 8014364:	f7ff fcc8 	bl	8013cf8 <HAL_RCCEx_GetPLL2ClockFreq>
        frequency = pll2_clocks.PLL2_P_Frequency;
 8014368:	69bb      	ldr	r3, [r7, #24]
 801436a:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 801436c:	f001 b94c 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>

      case RCC_SAI1CLKSOURCE_PLL3: /* PLLI3P is the clock source for SAI1 */

        HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 8014370:	f107 030c 	add.w	r3, r7, #12
 8014374:	4618      	mov	r0, r3
 8014376:	f7ff fe19 	bl	8013fac <HAL_RCCEx_GetPLL3ClockFreq>
        frequency = pll3_clocks.PLL3_P_Frequency;
 801437a:	68fb      	ldr	r3, [r7, #12]
 801437c:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 801437e:	f001 b943 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>

      case RCC_SAI1CLKSOURCE_PIN:

        frequency = EXTERNAL_SAI1_CLOCK_VALUE;
 8014382:	f64b 3380 	movw	r3, #48000	@ 0xbb80
 8014386:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8014388:	f001 b93e 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>

      case RCC_SAI1CLKSOURCE_HSI: /* HSI is the clock source for SAI1 */

        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
 801438c:	4b61      	ldr	r3, [pc, #388]	@ (8014514 <HAL_RCCEx_GetPeriphCLKFreq+0x2b4>)
 801438e:	681b      	ldr	r3, [r3, #0]
 8014390:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8014394:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 8014398:	d103      	bne.n	80143a2 <HAL_RCCEx_GetPeriphCLKFreq+0x142>
        {
          frequency = HSI_VALUE;
 801439a:	4b60      	ldr	r3, [pc, #384]	@ (801451c <HAL_RCCEx_GetPeriphCLKFreq+0x2bc>)
 801439c:	637b      	str	r3, [r7, #52]	@ 0x34
        }
        else
        {
          frequency = 0U;
        }
        break;
 801439e:	f001 b933 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
          frequency = 0U;
 80143a2:	2300      	movs	r3, #0
 80143a4:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 80143a6:	f001 b92f 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>

      default :
      {
        frequency = 0U;
 80143aa:	2300      	movs	r3, #0
 80143ac:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 80143ae:	f001 b92b 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
      }
    }
  }
#if defined(SAI2)
  else if (PeriphClk == RCC_PERIPHCLK_SAI2)
 80143b2:	e9d7 2300 	ldrd	r2, r3, [r7]
 80143b6:	f5a2 4180 	sub.w	r1, r2, #16384	@ 0x4000
 80143ba:	430b      	orrs	r3, r1
 80143bc:	d158      	bne.n	8014470 <HAL_RCCEx_GetPeriphCLKFreq+0x210>
  {
    srcclk = __HAL_RCC_GET_SAI2_SOURCE();
 80143be:	4b55      	ldr	r3, [pc, #340]	@ (8014514 <HAL_RCCEx_GetPeriphCLKFreq+0x2b4>)
 80143c0:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
 80143c4:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
 80143c8:	633b      	str	r3, [r7, #48]	@ 0x30

    switch (srcclk)
 80143ca:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80143cc:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 80143d0:	d03b      	beq.n	801444a <HAL_RCCEx_GetPeriphCLKFreq+0x1ea>
 80143d2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80143d4:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 80143d8:	d846      	bhi.n	8014468 <HAL_RCCEx_GetPeriphCLKFreq+0x208>
 80143da:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80143dc:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
 80143e0:	d02e      	beq.n	8014440 <HAL_RCCEx_GetPeriphCLKFreq+0x1e0>
 80143e2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80143e4:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
 80143e8:	d83e      	bhi.n	8014468 <HAL_RCCEx_GetPeriphCLKFreq+0x208>
 80143ea:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80143ec:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 80143f0:	d00b      	beq.n	801440a <HAL_RCCEx_GetPeriphCLKFreq+0x1aa>
 80143f2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80143f4:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 80143f8:	d836      	bhi.n	8014468 <HAL_RCCEx_GetPeriphCLKFreq+0x208>
 80143fa:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80143fc:	2b00      	cmp	r3, #0
 80143fe:	d00d      	beq.n	801441c <HAL_RCCEx_GetPeriphCLKFreq+0x1bc>
 8014400:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014402:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8014406:	d012      	beq.n	801442e <HAL_RCCEx_GetPeriphCLKFreq+0x1ce>
 8014408:	e02e      	b.n	8014468 <HAL_RCCEx_GetPeriphCLKFreq+0x208>
    {
      case RCC_SAI2CLKSOURCE_PLL1: /* PLL1P is the clock source for SAI1 */

        HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 801440a:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 801440e:	4618      	mov	r0, r3
 8014410:	f7ff fb18 	bl	8013a44 <HAL_RCCEx_GetPLL1ClockFreq>
        frequency = pll1_clocks.PLL1_P_Frequency;
 8014414:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8014416:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8014418:	f001 b8f6 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>

      case RCC_SAI2CLKSOURCE_PLL2: /* PLL2P is the clock source for SAI1 */

        HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 801441c:	f107 0318 	add.w	r3, r7, #24
 8014420:	4618      	mov	r0, r3
 8014422:	f7ff fc69 	bl	8013cf8 <HAL_RCCEx_GetPLL2ClockFreq>
        frequency = pll2_clocks.PLL2_P_Frequency;
 8014426:	69bb      	ldr	r3, [r7, #24]
 8014428:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 801442a:	f001 b8ed 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>

      case RCC_SAI2CLKSOURCE_PLL3: /* PLLI3P is the clock source for SAI1 */

        HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 801442e:	f107 030c 	add.w	r3, r7, #12
 8014432:	4618      	mov	r0, r3
 8014434:	f7ff fdba 	bl	8013fac <HAL_RCCEx_GetPLL3ClockFreq>
        frequency = pll3_clocks.PLL3_P_Frequency;
 8014438:	68fb      	ldr	r3, [r7, #12]
 801443a:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 801443c:	f001 b8e4 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>

      case RCC_SAI2CLKSOURCE_PIN:

        frequency = EXTERNAL_SAI1_CLOCK_VALUE;
 8014440:	f64b 3380 	movw	r3, #48000	@ 0xbb80
 8014444:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8014446:	f001 b8df 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>

      case RCC_SAI2CLKSOURCE_HSI: /* HSI is the clock source for SAI1 */

        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
 801444a:	4b32      	ldr	r3, [pc, #200]	@ (8014514 <HAL_RCCEx_GetPeriphCLKFreq+0x2b4>)
 801444c:	681b      	ldr	r3, [r3, #0]
 801444e:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8014452:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 8014456:	d103      	bne.n	8014460 <HAL_RCCEx_GetPeriphCLKFreq+0x200>
        {
          frequency = HSI_VALUE;
 8014458:	4b30      	ldr	r3, [pc, #192]	@ (801451c <HAL_RCCEx_GetPeriphCLKFreq+0x2bc>)
 801445a:	637b      	str	r3, [r7, #52]	@ 0x34
        }
        else
        {
          frequency = 0U;
        }
        break;
 801445c:	f001 b8d4 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
          frequency = 0U;
 8014460:	2300      	movs	r3, #0
 8014462:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8014464:	f001 b8d0 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>

      default :

        frequency = 0U;
 8014468:	2300      	movs	r3, #0
 801446a:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 801446c:	f001 b8cc 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
  }
#endif /* SAI2 */
#if defined(SAES)
  else if (PeriphClk == RCC_PERIPHCLK_SAES)
 8014470:	e9d7 2300 	ldrd	r2, r3, [r7]
 8014474:	f5a2 5180 	sub.w	r1, r2, #4096	@ 0x1000
 8014478:	430b      	orrs	r3, r1
 801447a:	d126      	bne.n	80144ca <HAL_RCCEx_GetPeriphCLKFreq+0x26a>
  {
    /* Get the current SAES source */
    srcclk = __HAL_RCC_GET_SAES_SOURCE();
 801447c:	4b25      	ldr	r3, [pc, #148]	@ (8014514 <HAL_RCCEx_GetPeriphCLKFreq+0x2b4>)
 801447e:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
 8014482:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 8014486:	633b      	str	r3, [r7, #48]	@ 0x30

    if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY) && (srcclk == RCC_SAESCLKSOURCE_SHSI))
 8014488:	4b22      	ldr	r3, [pc, #136]	@ (8014514 <HAL_RCCEx_GetPeriphCLKFreq+0x2b4>)
 801448a:	681b      	ldr	r3, [r3, #0]
 801448c:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8014490:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 8014494:	d106      	bne.n	80144a4 <HAL_RCCEx_GetPeriphCLKFreq+0x244>
 8014496:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014498:	2b00      	cmp	r3, #0
 801449a:	d103      	bne.n	80144a4 <HAL_RCCEx_GetPeriphCLKFreq+0x244>
    {
      frequency = HSI_VALUE;
 801449c:	4b1f      	ldr	r3, [pc, #124]	@ (801451c <HAL_RCCEx_GetPeriphCLKFreq+0x2bc>)
 801449e:	637b      	str	r3, [r7, #52]	@ 0x34
 80144a0:	f001 b8b2 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
    else if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY) && (srcclk == RCC_SAESCLKSOURCE_SHSI_DIV2))
 80144a4:	4b1b      	ldr	r3, [pc, #108]	@ (8014514 <HAL_RCCEx_GetPeriphCLKFreq+0x2b4>)
 80144a6:	681b      	ldr	r3, [r3, #0]
 80144a8:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 80144ac:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 80144b0:	d107      	bne.n	80144c2 <HAL_RCCEx_GetPeriphCLKFreq+0x262>
 80144b2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80144b4:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 80144b8:	d103      	bne.n	80144c2 <HAL_RCCEx_GetPeriphCLKFreq+0x262>
    {
      frequency = HSI_VALUE >> 1U;
 80144ba:	4b19      	ldr	r3, [pc, #100]	@ (8014520 <HAL_RCCEx_GetPeriphCLKFreq+0x2c0>)
 80144bc:	637b      	str	r3, [r7, #52]	@ 0x34
 80144be:	f001 b8a3 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
    /* Clock not enabled for SAES */
    else
    {
      frequency = 0U;
 80144c2:	2300      	movs	r3, #0
 80144c4:	637b      	str	r3, [r7, #52]	@ 0x34
 80144c6:	f001 b89f 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
  }
#endif /* SAES */
  else if (PeriphClk == RCC_PERIPHCLK_ICLK)
 80144ca:	e9d7 2300 	ldrd	r2, r3, [r7]
 80144ce:	f5a2 1180 	sub.w	r1, r2, #1048576	@ 0x100000
 80144d2:	430b      	orrs	r3, r1
 80144d4:	d16e      	bne.n	80145b4 <HAL_RCCEx_GetPeriphCLKFreq+0x354>
  {
    srcclk = __HAL_RCC_GET_ICLK_SOURCE();
 80144d6:	4b0f      	ldr	r3, [pc, #60]	@ (8014514 <HAL_RCCEx_GetPeriphCLKFreq+0x2b4>)
 80144d8:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 80144dc:	f003 6340 	and.w	r3, r3, #201326592	@ 0xc000000
 80144e0:	633b      	str	r3, [r7, #48]	@ 0x30

    switch (srcclk)
 80144e2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80144e4:	f1b3 6f40 	cmp.w	r3, #201326592	@ 0xc000000
 80144e8:	d03d      	beq.n	8014566 <HAL_RCCEx_GetPeriphCLKFreq+0x306>
 80144ea:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80144ec:	f1b3 6f40 	cmp.w	r3, #201326592	@ 0xc000000
 80144f0:	d85c      	bhi.n	80145ac <HAL_RCCEx_GetPeriphCLKFreq+0x34c>
 80144f2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80144f4:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 80144f8:	d014      	beq.n	8014524 <HAL_RCCEx_GetPeriphCLKFreq+0x2c4>
 80144fa:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80144fc:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 8014500:	d854      	bhi.n	80145ac <HAL_RCCEx_GetPeriphCLKFreq+0x34c>
 8014502:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014504:	2b00      	cmp	r3, #0
 8014506:	d01f      	beq.n	8014548 <HAL_RCCEx_GetPeriphCLKFreq+0x2e8>
 8014508:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801450a:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
 801450e:	d012      	beq.n	8014536 <HAL_RCCEx_GetPeriphCLKFreq+0x2d6>
 8014510:	e04c      	b.n	80145ac <HAL_RCCEx_GetPeriphCLKFreq+0x34c>
 8014512:	bf00      	nop
 8014514:	46020c00 	.word	0x46020c00
 8014518:	0007a120 	.word	0x0007a120
 801451c:	00f42400 	.word	0x00f42400
 8014520:	007a1200 	.word	0x007a1200
    {
      case RCC_ICLK_CLKSOURCE_PLL1: /* PLL1Q  */

        HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 8014524:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 8014528:	4618      	mov	r0, r3
 801452a:	f7ff fa8b 	bl	8013a44 <HAL_RCCEx_GetPLL1ClockFreq>
        frequency = pll1_clocks.PLL1_Q_Frequency;
 801452e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8014530:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8014532:	f001 b869 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>

      case RCC_ICLK_CLKSOURCE_PLL2: /* PLL2Q */

        HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 8014536:	f107 0318 	add.w	r3, r7, #24
 801453a:	4618      	mov	r0, r3
 801453c:	f7ff fbdc 	bl	8013cf8 <HAL_RCCEx_GetPLL2ClockFreq>
        frequency = pll2_clocks.PLL2_Q_Frequency;
 8014540:	69fb      	ldr	r3, [r7, #28]
 8014542:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8014544:	f001 b860 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>

      case RCC_ICLK_CLKSOURCE_HSI48: /* HSI48 */

        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSI48RDY))
 8014548:	4ba7      	ldr	r3, [pc, #668]	@ (80147e8 <HAL_RCCEx_GetPeriphCLKFreq+0x588>)
 801454a:	681b      	ldr	r3, [r3, #0]
 801454c:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 8014550:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 8014554:	d103      	bne.n	801455e <HAL_RCCEx_GetPeriphCLKFreq+0x2fe>
        {
          frequency = HSI48_VALUE;
 8014556:	4ba5      	ldr	r3, [pc, #660]	@ (80147ec <HAL_RCCEx_GetPeriphCLKFreq+0x58c>)
 8014558:	637b      	str	r3, [r7, #52]	@ 0x34
        }
        else
        {
          frequency = 0U;
        }
        break;
 801455a:	f001 b855 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
          frequency = 0U;
 801455e:	2300      	movs	r3, #0
 8014560:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8014562:	f001 b851 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>

      case RCC_ICLK_CLKSOURCE_MSIK: /* MSIK frequency range in HZ */

        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 8014566:	4ba0      	ldr	r3, [pc, #640]	@ (80147e8 <HAL_RCCEx_GetPeriphCLKFreq+0x588>)
 8014568:	681b      	ldr	r3, [r3, #0]
 801456a:	f003 0320 	and.w	r3, r3, #32
 801456e:	2b20      	cmp	r3, #32
 8014570:	d118      	bne.n	80145a4 <HAL_RCCEx_GetPeriphCLKFreq+0x344>
        {
          frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 8014572:	4b9d      	ldr	r3, [pc, #628]	@ (80147e8 <HAL_RCCEx_GetPeriphCLKFreq+0x588>)
 8014574:	689b      	ldr	r3, [r3, #8]
 8014576:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 801457a:	2b00      	cmp	r3, #0
 801457c:	d005      	beq.n	801458a <HAL_RCCEx_GetPeriphCLKFreq+0x32a>
 801457e:	4b9a      	ldr	r3, [pc, #616]	@ (80147e8 <HAL_RCCEx_GetPeriphCLKFreq+0x588>)
 8014580:	689b      	ldr	r3, [r3, #8]
 8014582:	0e1b      	lsrs	r3, r3, #24
 8014584:	f003 030f 	and.w	r3, r3, #15
 8014588:	e006      	b.n	8014598 <HAL_RCCEx_GetPeriphCLKFreq+0x338>
 801458a:	4b97      	ldr	r3, [pc, #604]	@ (80147e8 <HAL_RCCEx_GetPeriphCLKFreq+0x588>)
 801458c:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 8014590:	041b      	lsls	r3, r3, #16
 8014592:	0e1b      	lsrs	r3, r3, #24
 8014594:	f003 030f 	and.w	r3, r3, #15
 8014598:	4a95      	ldr	r2, [pc, #596]	@ (80147f0 <HAL_RCCEx_GetPeriphCLKFreq+0x590>)
 801459a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801459e:	637b      	str	r3, [r7, #52]	@ 0x34
        }
        else
        {
          frequency = 0U;
        }
        break;
 80145a0:	f001 b832 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
          frequency = 0U;
 80145a4:	2300      	movs	r3, #0
 80145a6:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 80145a8:	f001 b82e 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>

      default :

        frequency = 0U;
 80145ac:	2300      	movs	r3, #0
 80145ae:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 80145b0:	f001 b82a 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_SDMMC)
 80145b4:	e9d7 2300 	ldrd	r2, r3, [r7]
 80145b8:	f5a2 1100 	sub.w	r1, r2, #2097152	@ 0x200000
 80145bc:	430b      	orrs	r3, r1
 80145be:	d17f      	bne.n	80146c0 <HAL_RCCEx_GetPeriphCLKFreq+0x460>
  {
    srcclk = __HAL_RCC_GET_SDMMC_SOURCE();
 80145c0:	4b89      	ldr	r3, [pc, #548]	@ (80147e8 <HAL_RCCEx_GetPeriphCLKFreq+0x588>)
 80145c2:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
 80145c6:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
 80145ca:	633b      	str	r3, [r7, #48]	@ 0x30
    if (srcclk == RCC_SDMMCCLKSOURCE_CLK48)
 80145cc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80145ce:	2b00      	cmp	r3, #0
 80145d0:	d165      	bne.n	801469e <HAL_RCCEx_GetPeriphCLKFreq+0x43e>
    {
      srcclk = __HAL_RCC_GET_ICLK_SOURCE();
 80145d2:	4b85      	ldr	r3, [pc, #532]	@ (80147e8 <HAL_RCCEx_GetPeriphCLKFreq+0x588>)
 80145d4:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 80145d8:	f003 6340 	and.w	r3, r3, #201326592	@ 0xc000000
 80145dc:	633b      	str	r3, [r7, #48]	@ 0x30

      switch (srcclk)
 80145de:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80145e0:	f1b3 6f40 	cmp.w	r3, #201326592	@ 0xc000000
 80145e4:	d034      	beq.n	8014650 <HAL_RCCEx_GetPeriphCLKFreq+0x3f0>
 80145e6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80145e8:	f1b3 6f40 	cmp.w	r3, #201326592	@ 0xc000000
 80145ec:	d853      	bhi.n	8014696 <HAL_RCCEx_GetPeriphCLKFreq+0x436>
 80145ee:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80145f0:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 80145f4:	d00b      	beq.n	801460e <HAL_RCCEx_GetPeriphCLKFreq+0x3ae>
 80145f6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80145f8:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 80145fc:	d84b      	bhi.n	8014696 <HAL_RCCEx_GetPeriphCLKFreq+0x436>
 80145fe:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014600:	2b00      	cmp	r3, #0
 8014602:	d016      	beq.n	8014632 <HAL_RCCEx_GetPeriphCLKFreq+0x3d2>
 8014604:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014606:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
 801460a:	d009      	beq.n	8014620 <HAL_RCCEx_GetPeriphCLKFreq+0x3c0>
 801460c:	e043      	b.n	8014696 <HAL_RCCEx_GetPeriphCLKFreq+0x436>
      {
        case RCC_ICLK_CLKSOURCE_PLL1: /* PLL1Q  */
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 801460e:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 8014612:	4618      	mov	r0, r3
 8014614:	f7ff fa16 	bl	8013a44 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
 8014618:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801461a:	637b      	str	r3, [r7, #52]	@ 0x34
          break;
 801461c:	f000 bff4 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
        }
        case RCC_ICLK_CLKSOURCE_PLL2: /* PLL2Q */
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 8014620:	f107 0318 	add.w	r3, r7, #24
 8014624:	4618      	mov	r0, r3
 8014626:	f7ff fb67 	bl	8013cf8 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_Q_Frequency;
 801462a:	69fb      	ldr	r3, [r7, #28]
 801462c:	637b      	str	r3, [r7, #52]	@ 0x34
          break;
 801462e:	f000 bfeb 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
        }
        case RCC_ICLK_CLKSOURCE_HSI48: /* HSI48 */
        {
          if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSI48RDY))
 8014632:	4b6d      	ldr	r3, [pc, #436]	@ (80147e8 <HAL_RCCEx_GetPeriphCLKFreq+0x588>)
 8014634:	681b      	ldr	r3, [r3, #0]
 8014636:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 801463a:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 801463e:	d103      	bne.n	8014648 <HAL_RCCEx_GetPeriphCLKFreq+0x3e8>
          {
            frequency = HSI48_VALUE;
 8014640:	4b6a      	ldr	r3, [pc, #424]	@ (80147ec <HAL_RCCEx_GetPeriphCLKFreq+0x58c>)
 8014642:	637b      	str	r3, [r7, #52]	@ 0x34
          }
          else
          {
            frequency = 0U;
          }
          break;
 8014644:	f000 bfe0 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
            frequency = 0U;
 8014648:	2300      	movs	r3, #0
 801464a:	637b      	str	r3, [r7, #52]	@ 0x34
          break;
 801464c:	f000 bfdc 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
        }
        case RCC_ICLK_CLKSOURCE_MSIK: /* MSIK frequency range in HZ */
        {
          if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 8014650:	4b65      	ldr	r3, [pc, #404]	@ (80147e8 <HAL_RCCEx_GetPeriphCLKFreq+0x588>)
 8014652:	681b      	ldr	r3, [r3, #0]
 8014654:	f003 0320 	and.w	r3, r3, #32
 8014658:	2b20      	cmp	r3, #32
 801465a:	d118      	bne.n	801468e <HAL_RCCEx_GetPeriphCLKFreq+0x42e>
          {
            frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 801465c:	4b62      	ldr	r3, [pc, #392]	@ (80147e8 <HAL_RCCEx_GetPeriphCLKFreq+0x588>)
 801465e:	689b      	ldr	r3, [r3, #8]
 8014660:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 8014664:	2b00      	cmp	r3, #0
 8014666:	d005      	beq.n	8014674 <HAL_RCCEx_GetPeriphCLKFreq+0x414>
 8014668:	4b5f      	ldr	r3, [pc, #380]	@ (80147e8 <HAL_RCCEx_GetPeriphCLKFreq+0x588>)
 801466a:	689b      	ldr	r3, [r3, #8]
 801466c:	0e1b      	lsrs	r3, r3, #24
 801466e:	f003 030f 	and.w	r3, r3, #15
 8014672:	e006      	b.n	8014682 <HAL_RCCEx_GetPeriphCLKFreq+0x422>
 8014674:	4b5c      	ldr	r3, [pc, #368]	@ (80147e8 <HAL_RCCEx_GetPeriphCLKFreq+0x588>)
 8014676:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 801467a:	041b      	lsls	r3, r3, #16
 801467c:	0e1b      	lsrs	r3, r3, #24
 801467e:	f003 030f 	and.w	r3, r3, #15
 8014682:	4a5b      	ldr	r2, [pc, #364]	@ (80147f0 <HAL_RCCEx_GetPeriphCLKFreq+0x590>)
 8014684:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8014688:	637b      	str	r3, [r7, #52]	@ 0x34
          }
          else
          {
            frequency = 0U;
          }
          break;
 801468a:	f000 bfbd 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
            frequency = 0U;
 801468e:	2300      	movs	r3, #0
 8014690:	637b      	str	r3, [r7, #52]	@ 0x34
          break;
 8014692:	f000 bfb9 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
        }
        default :
        {
          frequency = 0U;
 8014696:	2300      	movs	r3, #0
 8014698:	637b      	str	r3, [r7, #52]	@ 0x34
          break;
 801469a:	f000 bfb5 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
        }
      }
    }
    else if (srcclk == RCC_SDMMCCLKSOURCE_PLL1)
 801469e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80146a0:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 80146a4:	d108      	bne.n	80146b8 <HAL_RCCEx_GetPeriphCLKFreq+0x458>
    {
      HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 80146a6:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 80146aa:	4618      	mov	r0, r3
 80146ac:	f7ff f9ca 	bl	8013a44 <HAL_RCCEx_GetPLL1ClockFreq>
      frequency = pll1_clocks.PLL1_P_Frequency;
 80146b0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80146b2:	637b      	str	r3, [r7, #52]	@ 0x34
 80146b4:	f000 bfa8 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
    else
    {
      frequency = 0U;
 80146b8:	2300      	movs	r3, #0
 80146ba:	637b      	str	r3, [r7, #52]	@ 0x34
 80146bc:	f000 bfa4 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_USART1)
 80146c0:	e9d7 2300 	ldrd	r2, r3, [r7]
 80146c4:	1e51      	subs	r1, r2, #1
 80146c6:	430b      	orrs	r3, r1
 80146c8:	d136      	bne.n	8014738 <HAL_RCCEx_GetPeriphCLKFreq+0x4d8>
  {
    /* Get the current USART1 source */
    srcclk = __HAL_RCC_GET_USART1_SOURCE();
 80146ca:	4b47      	ldr	r3, [pc, #284]	@ (80147e8 <HAL_RCCEx_GetPeriphCLKFreq+0x588>)
 80146cc:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 80146d0:	f003 0303 	and.w	r3, r3, #3
 80146d4:	633b      	str	r3, [r7, #48]	@ 0x30

    if (srcclk == RCC_USART1CLKSOURCE_PCLK2)
 80146d6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80146d8:	2b00      	cmp	r3, #0
 80146da:	d104      	bne.n	80146e6 <HAL_RCCEx_GetPeriphCLKFreq+0x486>
    {
      frequency = HAL_RCC_GetPCLK2Freq();
 80146dc:	f7fe fb44 	bl	8012d68 <HAL_RCC_GetPCLK2Freq>
 80146e0:	6378      	str	r0, [r7, #52]	@ 0x34
 80146e2:	f000 bf91 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
    else if (srcclk == RCC_USART1CLKSOURCE_SYSCLK)
 80146e6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80146e8:	2b01      	cmp	r3, #1
 80146ea:	d104      	bne.n	80146f6 <HAL_RCCEx_GetPeriphCLKFreq+0x496>
    {
      frequency = HAL_RCC_GetSysClockFreq();
 80146ec:	f7fe fa0c 	bl	8012b08 <HAL_RCC_GetSysClockFreq>
 80146f0:	6378      	str	r0, [r7, #52]	@ 0x34
 80146f2:	f000 bf89 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_USART1CLKSOURCE_HSI))
 80146f6:	4b3c      	ldr	r3, [pc, #240]	@ (80147e8 <HAL_RCCEx_GetPeriphCLKFreq+0x588>)
 80146f8:	681b      	ldr	r3, [r3, #0]
 80146fa:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 80146fe:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 8014702:	d106      	bne.n	8014712 <HAL_RCCEx_GetPeriphCLKFreq+0x4b2>
 8014704:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014706:	2b02      	cmp	r3, #2
 8014708:	d103      	bne.n	8014712 <HAL_RCCEx_GetPeriphCLKFreq+0x4b2>
    {
      frequency = HSI_VALUE;
 801470a:	4b3a      	ldr	r3, [pc, #232]	@ (80147f4 <HAL_RCCEx_GetPeriphCLKFreq+0x594>)
 801470c:	637b      	str	r3, [r7, #52]	@ 0x34
 801470e:	f000 bf7b 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_USART1CLKSOURCE_LSE))
 8014712:	4b35      	ldr	r3, [pc, #212]	@ (80147e8 <HAL_RCCEx_GetPeriphCLKFreq+0x588>)
 8014714:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8014718:	f003 0302 	and.w	r3, r3, #2
 801471c:	2b02      	cmp	r3, #2
 801471e:	d107      	bne.n	8014730 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
 8014720:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014722:	2b03      	cmp	r3, #3
 8014724:	d104      	bne.n	8014730 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
    {
      frequency = LSE_VALUE;
 8014726:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 801472a:	637b      	str	r3, [r7, #52]	@ 0x34
 801472c:	f000 bf6c 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
    /* Clock not enabled for USART1 */
    else
    {
      frequency = 0U;
 8014730:	2300      	movs	r3, #0
 8014732:	637b      	str	r3, [r7, #52]	@ 0x34
 8014734:	f000 bf68 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
  }
#if defined(USART2)
  else if (PeriphClk == RCC_PERIPHCLK_USART2)
 8014738:	e9d7 2300 	ldrd	r2, r3, [r7]
 801473c:	1e91      	subs	r1, r2, #2
 801473e:	430b      	orrs	r3, r1
 8014740:	d136      	bne.n	80147b0 <HAL_RCCEx_GetPeriphCLKFreq+0x550>
  {
    /* Get the current USART2 source */
    srcclk = __HAL_RCC_GET_USART2_SOURCE();
 8014742:	4b29      	ldr	r3, [pc, #164]	@ (80147e8 <HAL_RCCEx_GetPeriphCLKFreq+0x588>)
 8014744:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8014748:	f003 030c 	and.w	r3, r3, #12
 801474c:	633b      	str	r3, [r7, #48]	@ 0x30

    if (srcclk == RCC_USART2CLKSOURCE_PCLK1)
 801474e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014750:	2b00      	cmp	r3, #0
 8014752:	d104      	bne.n	801475e <HAL_RCCEx_GetPeriphCLKFreq+0x4fe>
    {
      frequency = HAL_RCC_GetPCLK1Freq();
 8014754:	f7fe faf4 	bl	8012d40 <HAL_RCC_GetPCLK1Freq>
 8014758:	6378      	str	r0, [r7, #52]	@ 0x34
 801475a:	f000 bf55 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
    else if (srcclk == RCC_USART2CLKSOURCE_SYSCLK)
 801475e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014760:	2b04      	cmp	r3, #4
 8014762:	d104      	bne.n	801476e <HAL_RCCEx_GetPeriphCLKFreq+0x50e>
    {
      frequency = HAL_RCC_GetSysClockFreq();
 8014764:	f7fe f9d0 	bl	8012b08 <HAL_RCC_GetSysClockFreq>
 8014768:	6378      	str	r0, [r7, #52]	@ 0x34
 801476a:	f000 bf4d 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_USART2CLKSOURCE_HSI))
 801476e:	4b1e      	ldr	r3, [pc, #120]	@ (80147e8 <HAL_RCCEx_GetPeriphCLKFreq+0x588>)
 8014770:	681b      	ldr	r3, [r3, #0]
 8014772:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8014776:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 801477a:	d106      	bne.n	801478a <HAL_RCCEx_GetPeriphCLKFreq+0x52a>
 801477c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801477e:	2b08      	cmp	r3, #8
 8014780:	d103      	bne.n	801478a <HAL_RCCEx_GetPeriphCLKFreq+0x52a>
    {
      frequency = HSI_VALUE;
 8014782:	4b1c      	ldr	r3, [pc, #112]	@ (80147f4 <HAL_RCCEx_GetPeriphCLKFreq+0x594>)
 8014784:	637b      	str	r3, [r7, #52]	@ 0x34
 8014786:	f000 bf3f 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_USART2CLKSOURCE_LSE))
 801478a:	4b17      	ldr	r3, [pc, #92]	@ (80147e8 <HAL_RCCEx_GetPeriphCLKFreq+0x588>)
 801478c:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8014790:	f003 0302 	and.w	r3, r3, #2
 8014794:	2b02      	cmp	r3, #2
 8014796:	d107      	bne.n	80147a8 <HAL_RCCEx_GetPeriphCLKFreq+0x548>
 8014798:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801479a:	2b0c      	cmp	r3, #12
 801479c:	d104      	bne.n	80147a8 <HAL_RCCEx_GetPeriphCLKFreq+0x548>
    {
      frequency = LSE_VALUE;
 801479e:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 80147a2:	637b      	str	r3, [r7, #52]	@ 0x34
 80147a4:	f000 bf30 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
    /* Clock not enabled for USART2 */
    else
    {
      frequency = 0U;
 80147a8:	2300      	movs	r3, #0
 80147aa:	637b      	str	r3, [r7, #52]	@ 0x34
 80147ac:	f000 bf2c 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
  }
#endif /* USART2 */
  else if (PeriphClk == RCC_PERIPHCLK_USART3)
 80147b0:	e9d7 2300 	ldrd	r2, r3, [r7]
 80147b4:	1f11      	subs	r1, r2, #4
 80147b6:	430b      	orrs	r3, r1
 80147b8:	d13f      	bne.n	801483a <HAL_RCCEx_GetPeriphCLKFreq+0x5da>
  {
    /* Get the current USART3 source */
    srcclk = __HAL_RCC_GET_USART3_SOURCE();
 80147ba:	4b0b      	ldr	r3, [pc, #44]	@ (80147e8 <HAL_RCCEx_GetPeriphCLKFreq+0x588>)
 80147bc:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 80147c0:	f003 0330 	and.w	r3, r3, #48	@ 0x30
 80147c4:	633b      	str	r3, [r7, #48]	@ 0x30

    if (srcclk == RCC_USART3CLKSOURCE_PCLK1)
 80147c6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80147c8:	2b00      	cmp	r3, #0
 80147ca:	d104      	bne.n	80147d6 <HAL_RCCEx_GetPeriphCLKFreq+0x576>
    {
      frequency = HAL_RCC_GetPCLK1Freq();
 80147cc:	f7fe fab8 	bl	8012d40 <HAL_RCC_GetPCLK1Freq>
 80147d0:	6378      	str	r0, [r7, #52]	@ 0x34
 80147d2:	f000 bf19 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
    else if (srcclk == RCC_USART3CLKSOURCE_SYSCLK)
 80147d6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80147d8:	2b10      	cmp	r3, #16
 80147da:	d10d      	bne.n	80147f8 <HAL_RCCEx_GetPeriphCLKFreq+0x598>
    {
      frequency = HAL_RCC_GetSysClockFreq();
 80147dc:	f7fe f994 	bl	8012b08 <HAL_RCC_GetSysClockFreq>
 80147e0:	6378      	str	r0, [r7, #52]	@ 0x34
 80147e2:	f000 bf11 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
 80147e6:	bf00      	nop
 80147e8:	46020c00 	.word	0x46020c00
 80147ec:	02dc6c00 	.word	0x02dc6c00
 80147f0:	0802a4e0 	.word	0x0802a4e0
 80147f4:	00f42400 	.word	0x00f42400
    }
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_USART3CLKSOURCE_HSI))
 80147f8:	4ba6      	ldr	r3, [pc, #664]	@ (8014a94 <HAL_RCCEx_GetPeriphCLKFreq+0x834>)
 80147fa:	681b      	ldr	r3, [r3, #0]
 80147fc:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8014800:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 8014804:	d106      	bne.n	8014814 <HAL_RCCEx_GetPeriphCLKFreq+0x5b4>
 8014806:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014808:	2b20      	cmp	r3, #32
 801480a:	d103      	bne.n	8014814 <HAL_RCCEx_GetPeriphCLKFreq+0x5b4>
    {
      frequency = HSI_VALUE;
 801480c:	4ba2      	ldr	r3, [pc, #648]	@ (8014a98 <HAL_RCCEx_GetPeriphCLKFreq+0x838>)
 801480e:	637b      	str	r3, [r7, #52]	@ 0x34
 8014810:	f000 befa 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_USART3CLKSOURCE_LSE))
 8014814:	4b9f      	ldr	r3, [pc, #636]	@ (8014a94 <HAL_RCCEx_GetPeriphCLKFreq+0x834>)
 8014816:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 801481a:	f003 0302 	and.w	r3, r3, #2
 801481e:	2b02      	cmp	r3, #2
 8014820:	d107      	bne.n	8014832 <HAL_RCCEx_GetPeriphCLKFreq+0x5d2>
 8014822:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014824:	2b30      	cmp	r3, #48	@ 0x30
 8014826:	d104      	bne.n	8014832 <HAL_RCCEx_GetPeriphCLKFreq+0x5d2>
    {
      frequency = LSE_VALUE;
 8014828:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 801482c:	637b      	str	r3, [r7, #52]	@ 0x34
 801482e:	f000 beeb 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
    /* Clock not enabled for USART3 */
    else
    {
      frequency = 0U;
 8014832:	2300      	movs	r3, #0
 8014834:	637b      	str	r3, [r7, #52]	@ 0x34
 8014836:	f000 bee7 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_UART4)
 801483a:	e9d7 2300 	ldrd	r2, r3, [r7]
 801483e:	f1a2 0108 	sub.w	r1, r2, #8
 8014842:	430b      	orrs	r3, r1
 8014844:	d136      	bne.n	80148b4 <HAL_RCCEx_GetPeriphCLKFreq+0x654>
  {
    /* Get the current UART4 source */
    srcclk = __HAL_RCC_GET_UART4_SOURCE();
 8014846:	4b93      	ldr	r3, [pc, #588]	@ (8014a94 <HAL_RCCEx_GetPeriphCLKFreq+0x834>)
 8014848:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 801484c:	f003 03c0 	and.w	r3, r3, #192	@ 0xc0
 8014850:	633b      	str	r3, [r7, #48]	@ 0x30

    if (srcclk == RCC_UART4CLKSOURCE_PCLK1)
 8014852:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014854:	2b00      	cmp	r3, #0
 8014856:	d104      	bne.n	8014862 <HAL_RCCEx_GetPeriphCLKFreq+0x602>
    {
      frequency = HAL_RCC_GetPCLK1Freq();
 8014858:	f7fe fa72 	bl	8012d40 <HAL_RCC_GetPCLK1Freq>
 801485c:	6378      	str	r0, [r7, #52]	@ 0x34
 801485e:	f000 bed3 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
    else if (srcclk == RCC_UART4CLKSOURCE_SYSCLK)
 8014862:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014864:	2b40      	cmp	r3, #64	@ 0x40
 8014866:	d104      	bne.n	8014872 <HAL_RCCEx_GetPeriphCLKFreq+0x612>
    {
      frequency = HAL_RCC_GetSysClockFreq();
 8014868:	f7fe f94e 	bl	8012b08 <HAL_RCC_GetSysClockFreq>
 801486c:	6378      	str	r0, [r7, #52]	@ 0x34
 801486e:	f000 becb 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_UART4CLKSOURCE_HSI))
 8014872:	4b88      	ldr	r3, [pc, #544]	@ (8014a94 <HAL_RCCEx_GetPeriphCLKFreq+0x834>)
 8014874:	681b      	ldr	r3, [r3, #0]
 8014876:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 801487a:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 801487e:	d106      	bne.n	801488e <HAL_RCCEx_GetPeriphCLKFreq+0x62e>
 8014880:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014882:	2b80      	cmp	r3, #128	@ 0x80
 8014884:	d103      	bne.n	801488e <HAL_RCCEx_GetPeriphCLKFreq+0x62e>
    {
      frequency = HSI_VALUE;
 8014886:	4b84      	ldr	r3, [pc, #528]	@ (8014a98 <HAL_RCCEx_GetPeriphCLKFreq+0x838>)
 8014888:	637b      	str	r3, [r7, #52]	@ 0x34
 801488a:	f000 bebd 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_UART4CLKSOURCE_LSE))
 801488e:	4b81      	ldr	r3, [pc, #516]	@ (8014a94 <HAL_RCCEx_GetPeriphCLKFreq+0x834>)
 8014890:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8014894:	f003 0302 	and.w	r3, r3, #2
 8014898:	2b02      	cmp	r3, #2
 801489a:	d107      	bne.n	80148ac <HAL_RCCEx_GetPeriphCLKFreq+0x64c>
 801489c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801489e:	2bc0      	cmp	r3, #192	@ 0xc0
 80148a0:	d104      	bne.n	80148ac <HAL_RCCEx_GetPeriphCLKFreq+0x64c>
    {
      frequency = LSE_VALUE;
 80148a2:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 80148a6:	637b      	str	r3, [r7, #52]	@ 0x34
 80148a8:	f000 beae 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
    /* Clock not enabled for UART4 */
    else
    {
      frequency = 0U;
 80148ac:	2300      	movs	r3, #0
 80148ae:	637b      	str	r3, [r7, #52]	@ 0x34
 80148b0:	f000 beaa 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_UART5)
 80148b4:	e9d7 2300 	ldrd	r2, r3, [r7]
 80148b8:	f1a2 0110 	sub.w	r1, r2, #16
 80148bc:	430b      	orrs	r3, r1
 80148be:	d139      	bne.n	8014934 <HAL_RCCEx_GetPeriphCLKFreq+0x6d4>
  {
    /* Get the current UART5 source */
    srcclk = __HAL_RCC_GET_UART5_SOURCE();
 80148c0:	4b74      	ldr	r3, [pc, #464]	@ (8014a94 <HAL_RCCEx_GetPeriphCLKFreq+0x834>)
 80148c2:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 80148c6:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 80148ca:	633b      	str	r3, [r7, #48]	@ 0x30

    if (srcclk == RCC_UART5CLKSOURCE_PCLK1)
 80148cc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80148ce:	2b00      	cmp	r3, #0
 80148d0:	d104      	bne.n	80148dc <HAL_RCCEx_GetPeriphCLKFreq+0x67c>
    {
      frequency = HAL_RCC_GetPCLK1Freq();
 80148d2:	f7fe fa35 	bl	8012d40 <HAL_RCC_GetPCLK1Freq>
 80148d6:	6378      	str	r0, [r7, #52]	@ 0x34
 80148d8:	f000 be96 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
    else if (srcclk == RCC_UART5CLKSOURCE_SYSCLK)
 80148dc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80148de:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 80148e2:	d104      	bne.n	80148ee <HAL_RCCEx_GetPeriphCLKFreq+0x68e>
    {
      frequency = HAL_RCC_GetSysClockFreq();
 80148e4:	f7fe f910 	bl	8012b08 <HAL_RCC_GetSysClockFreq>
 80148e8:	6378      	str	r0, [r7, #52]	@ 0x34
 80148ea:	f000 be8d 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_UART5CLKSOURCE_HSI))
 80148ee:	4b69      	ldr	r3, [pc, #420]	@ (8014a94 <HAL_RCCEx_GetPeriphCLKFreq+0x834>)
 80148f0:	681b      	ldr	r3, [r3, #0]
 80148f2:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 80148f6:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 80148fa:	d107      	bne.n	801490c <HAL_RCCEx_GetPeriphCLKFreq+0x6ac>
 80148fc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80148fe:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8014902:	d103      	bne.n	801490c <HAL_RCCEx_GetPeriphCLKFreq+0x6ac>
    {
      frequency = HSI_VALUE;
 8014904:	4b64      	ldr	r3, [pc, #400]	@ (8014a98 <HAL_RCCEx_GetPeriphCLKFreq+0x838>)
 8014906:	637b      	str	r3, [r7, #52]	@ 0x34
 8014908:	f000 be7e 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_UART5CLKSOURCE_LSE))
 801490c:	4b61      	ldr	r3, [pc, #388]	@ (8014a94 <HAL_RCCEx_GetPeriphCLKFreq+0x834>)
 801490e:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8014912:	f003 0302 	and.w	r3, r3, #2
 8014916:	2b02      	cmp	r3, #2
 8014918:	d108      	bne.n	801492c <HAL_RCCEx_GetPeriphCLKFreq+0x6cc>
 801491a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801491c:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
 8014920:	d104      	bne.n	801492c <HAL_RCCEx_GetPeriphCLKFreq+0x6cc>
    {
      frequency = LSE_VALUE;
 8014922:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 8014926:	637b      	str	r3, [r7, #52]	@ 0x34
 8014928:	f000 be6e 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
    /* Clock not enabled for UART5 */
    else
    {
      frequency = 0U;
 801492c:	2300      	movs	r3, #0
 801492e:	637b      	str	r3, [r7, #52]	@ 0x34
 8014930:	f000 be6a 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    {
      frequency = 0U;
    }
  }
#endif /* USART6 */
  else if (PeriphClk == RCC_PERIPHCLK_LPUART1)
 8014934:	e9d7 2300 	ldrd	r2, r3, [r7]
 8014938:	f1a2 0120 	sub.w	r1, r2, #32
 801493c:	430b      	orrs	r3, r1
 801493e:	d158      	bne.n	80149f2 <HAL_RCCEx_GetPeriphCLKFreq+0x792>
  {
    /* Get the current LPUART1 source */
    srcclk = __HAL_RCC_GET_LPUART1_SOURCE();
 8014940:	4b54      	ldr	r3, [pc, #336]	@ (8014a94 <HAL_RCCEx_GetPeriphCLKFreq+0x834>)
 8014942:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 8014946:	f003 0307 	and.w	r3, r3, #7
 801494a:	633b      	str	r3, [r7, #48]	@ 0x30

    if (srcclk == RCC_LPUART1CLKSOURCE_PCLK3)
 801494c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801494e:	2b00      	cmp	r3, #0
 8014950:	d104      	bne.n	801495c <HAL_RCCEx_GetPeriphCLKFreq+0x6fc>
    {
      frequency = HAL_RCC_GetPCLK3Freq();
 8014952:	f7fe fa1d 	bl	8012d90 <HAL_RCC_GetPCLK3Freq>
 8014956:	6378      	str	r0, [r7, #52]	@ 0x34
 8014958:	f000 be56 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
    else if (srcclk == RCC_LPUART1CLKSOURCE_SYSCLK)
 801495c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801495e:	2b01      	cmp	r3, #1
 8014960:	d104      	bne.n	801496c <HAL_RCCEx_GetPeriphCLKFreq+0x70c>
    {
      frequency = HAL_RCC_GetSysClockFreq();
 8014962:	f7fe f8d1 	bl	8012b08 <HAL_RCC_GetSysClockFreq>
 8014966:	6378      	str	r0, [r7, #52]	@ 0x34
 8014968:	f000 be4e 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_LPUART1CLKSOURCE_HSI))
 801496c:	4b49      	ldr	r3, [pc, #292]	@ (8014a94 <HAL_RCCEx_GetPeriphCLKFreq+0x834>)
 801496e:	681b      	ldr	r3, [r3, #0]
 8014970:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8014974:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 8014978:	d106      	bne.n	8014988 <HAL_RCCEx_GetPeriphCLKFreq+0x728>
 801497a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801497c:	2b02      	cmp	r3, #2
 801497e:	d103      	bne.n	8014988 <HAL_RCCEx_GetPeriphCLKFreq+0x728>
    {
      frequency = HSI_VALUE;
 8014980:	4b45      	ldr	r3, [pc, #276]	@ (8014a98 <HAL_RCCEx_GetPeriphCLKFreq+0x838>)
 8014982:	637b      	str	r3, [r7, #52]	@ 0x34
 8014984:	f000 be40 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_LPUART1CLKSOURCE_LSE))
 8014988:	4b42      	ldr	r3, [pc, #264]	@ (8014a94 <HAL_RCCEx_GetPeriphCLKFreq+0x834>)
 801498a:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 801498e:	f003 0302 	and.w	r3, r3, #2
 8014992:	2b02      	cmp	r3, #2
 8014994:	d107      	bne.n	80149a6 <HAL_RCCEx_GetPeriphCLKFreq+0x746>
 8014996:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014998:	2b03      	cmp	r3, #3
 801499a:	d104      	bne.n	80149a6 <HAL_RCCEx_GetPeriphCLKFreq+0x746>
    {
      frequency = LSE_VALUE;
 801499c:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 80149a0:	637b      	str	r3, [r7, #52]	@ 0x34
 80149a2:	f000 be31 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY)) && (srcclk == RCC_LPUART1CLKSOURCE_MSIK))
 80149a6:	4b3b      	ldr	r3, [pc, #236]	@ (8014a94 <HAL_RCCEx_GetPeriphCLKFreq+0x834>)
 80149a8:	681b      	ldr	r3, [r3, #0]
 80149aa:	f003 0320 	and.w	r3, r3, #32
 80149ae:	2b20      	cmp	r3, #32
 80149b0:	d11b      	bne.n	80149ea <HAL_RCCEx_GetPeriphCLKFreq+0x78a>
 80149b2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80149b4:	2b04      	cmp	r3, #4
 80149b6:	d118      	bne.n	80149ea <HAL_RCCEx_GetPeriphCLKFreq+0x78a>
    {
      frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 80149b8:	4b36      	ldr	r3, [pc, #216]	@ (8014a94 <HAL_RCCEx_GetPeriphCLKFreq+0x834>)
 80149ba:	689b      	ldr	r3, [r3, #8]
 80149bc:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 80149c0:	2b00      	cmp	r3, #0
 80149c2:	d005      	beq.n	80149d0 <HAL_RCCEx_GetPeriphCLKFreq+0x770>
 80149c4:	4b33      	ldr	r3, [pc, #204]	@ (8014a94 <HAL_RCCEx_GetPeriphCLKFreq+0x834>)
 80149c6:	689b      	ldr	r3, [r3, #8]
 80149c8:	0e1b      	lsrs	r3, r3, #24
 80149ca:	f003 030f 	and.w	r3, r3, #15
 80149ce:	e006      	b.n	80149de <HAL_RCCEx_GetPeriphCLKFreq+0x77e>
 80149d0:	4b30      	ldr	r3, [pc, #192]	@ (8014a94 <HAL_RCCEx_GetPeriphCLKFreq+0x834>)
 80149d2:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 80149d6:	041b      	lsls	r3, r3, #16
 80149d8:	0e1b      	lsrs	r3, r3, #24
 80149da:	f003 030f 	and.w	r3, r3, #15
 80149de:	4a2f      	ldr	r2, [pc, #188]	@ (8014a9c <HAL_RCCEx_GetPeriphCLKFreq+0x83c>)
 80149e0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80149e4:	637b      	str	r3, [r7, #52]	@ 0x34
 80149e6:	f000 be0f 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
    /* Clock not enabled for LPUART1 */
    else
    {
      frequency = 0U;
 80149ea:	2300      	movs	r3, #0
 80149ec:	637b      	str	r3, [r7, #52]	@ 0x34
 80149ee:	f000 be0b 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_ADCDAC)
 80149f2:	e9d7 2300 	ldrd	r2, r3, [r7]
 80149f6:	f5a2 4100 	sub.w	r1, r2, #32768	@ 0x8000
 80149fa:	430b      	orrs	r3, r1
 80149fc:	d172      	bne.n	8014ae4 <HAL_RCCEx_GetPeriphCLKFreq+0x884>
  {
    srcclk = __HAL_RCC_GET_ADCDAC_SOURCE();
 80149fe:	4b25      	ldr	r3, [pc, #148]	@ (8014a94 <HAL_RCCEx_GetPeriphCLKFreq+0x834>)
 8014a00:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 8014a04:	f403 43e0 	and.w	r3, r3, #28672	@ 0x7000
 8014a08:	633b      	str	r3, [r7, #48]	@ 0x30

    if (srcclk == RCC_ADCDACCLKSOURCE_SYSCLK)
 8014a0a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014a0c:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 8014a10:	d104      	bne.n	8014a1c <HAL_RCCEx_GetPeriphCLKFreq+0x7bc>
    {
      frequency = HAL_RCC_GetSysClockFreq();
 8014a12:	f7fe f879 	bl	8012b08 <HAL_RCC_GetSysClockFreq>
 8014a16:	6378      	str	r0, [r7, #52]	@ 0x34
 8014a18:	f000 bdf6 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
    else if (srcclk == RCC_ADCDACCLKSOURCE_PLL2)
 8014a1c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014a1e:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 8014a22:	d108      	bne.n	8014a36 <HAL_RCCEx_GetPeriphCLKFreq+0x7d6>
    {
      HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 8014a24:	f107 0318 	add.w	r3, r7, #24
 8014a28:	4618      	mov	r0, r3
 8014a2a:	f7ff f965 	bl	8013cf8 <HAL_RCCEx_GetPLL2ClockFreq>
      frequency = pll2_clocks.PLL2_R_Frequency;
 8014a2e:	6a3b      	ldr	r3, [r7, #32]
 8014a30:	637b      	str	r3, [r7, #52]	@ 0x34
 8014a32:	f000 bde9 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
    else if (srcclk == RCC_ADCDACCLKSOURCE_HCLK)
 8014a36:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014a38:	2b00      	cmp	r3, #0
 8014a3a:	d104      	bne.n	8014a46 <HAL_RCCEx_GetPeriphCLKFreq+0x7e6>
    {
      frequency = HAL_RCC_GetHCLKFreq();
 8014a3c:	f7fe f966 	bl	8012d0c <HAL_RCC_GetHCLKFreq>
 8014a40:	6378      	str	r0, [r7, #52]	@ 0x34
 8014a42:	f000 bde1 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
    else if (srcclk == RCC_ADCDACCLKSOURCE_MSIK)
 8014a46:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014a48:	f5b3 4fa0 	cmp.w	r3, #20480	@ 0x5000
 8014a4c:	d128      	bne.n	8014aa0 <HAL_RCCEx_GetPeriphCLKFreq+0x840>
    {
      if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 8014a4e:	4b11      	ldr	r3, [pc, #68]	@ (8014a94 <HAL_RCCEx_GetPeriphCLKFreq+0x834>)
 8014a50:	681b      	ldr	r3, [r3, #0]
 8014a52:	f003 0320 	and.w	r3, r3, #32
 8014a56:	2b20      	cmp	r3, #32
 8014a58:	d118      	bne.n	8014a8c <HAL_RCCEx_GetPeriphCLKFreq+0x82c>
      {
        frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 8014a5a:	4b0e      	ldr	r3, [pc, #56]	@ (8014a94 <HAL_RCCEx_GetPeriphCLKFreq+0x834>)
 8014a5c:	689b      	ldr	r3, [r3, #8]
 8014a5e:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 8014a62:	2b00      	cmp	r3, #0
 8014a64:	d005      	beq.n	8014a72 <HAL_RCCEx_GetPeriphCLKFreq+0x812>
 8014a66:	4b0b      	ldr	r3, [pc, #44]	@ (8014a94 <HAL_RCCEx_GetPeriphCLKFreq+0x834>)
 8014a68:	689b      	ldr	r3, [r3, #8]
 8014a6a:	0e1b      	lsrs	r3, r3, #24
 8014a6c:	f003 030f 	and.w	r3, r3, #15
 8014a70:	e006      	b.n	8014a80 <HAL_RCCEx_GetPeriphCLKFreq+0x820>
 8014a72:	4b08      	ldr	r3, [pc, #32]	@ (8014a94 <HAL_RCCEx_GetPeriphCLKFreq+0x834>)
 8014a74:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 8014a78:	041b      	lsls	r3, r3, #16
 8014a7a:	0e1b      	lsrs	r3, r3, #24
 8014a7c:	f003 030f 	and.w	r3, r3, #15
 8014a80:	4a06      	ldr	r2, [pc, #24]	@ (8014a9c <HAL_RCCEx_GetPeriphCLKFreq+0x83c>)
 8014a82:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8014a86:	637b      	str	r3, [r7, #52]	@ 0x34
 8014a88:	f000 bdbe 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
      }
      else
      {
        frequency = 0U;
 8014a8c:	2300      	movs	r3, #0
 8014a8e:	637b      	str	r3, [r7, #52]	@ 0x34
 8014a90:	f000 bdba 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
 8014a94:	46020c00 	.word	0x46020c00
 8014a98:	00f42400 	.word	0x00f42400
 8014a9c:	0802a4e0 	.word	0x0802a4e0
      }
    }
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (srcclk == RCC_ADCDACCLKSOURCE_HSE))
 8014aa0:	4baf      	ldr	r3, [pc, #700]	@ (8014d60 <HAL_RCCEx_GetPeriphCLKFreq+0xb00>)
 8014aa2:	681b      	ldr	r3, [r3, #0]
 8014aa4:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8014aa8:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 8014aac:	d107      	bne.n	8014abe <HAL_RCCEx_GetPeriphCLKFreq+0x85e>
 8014aae:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014ab0:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
 8014ab4:	d103      	bne.n	8014abe <HAL_RCCEx_GetPeriphCLKFreq+0x85e>
    {
      frequency = HSE_VALUE;
 8014ab6:	4bab      	ldr	r3, [pc, #684]	@ (8014d64 <HAL_RCCEx_GetPeriphCLKFreq+0xb04>)
 8014ab8:	637b      	str	r3, [r7, #52]	@ 0x34
 8014aba:	f000 bda5 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_ADCDACCLKSOURCE_HSI))
 8014abe:	4ba8      	ldr	r3, [pc, #672]	@ (8014d60 <HAL_RCCEx_GetPeriphCLKFreq+0xb00>)
 8014ac0:	681b      	ldr	r3, [r3, #0]
 8014ac2:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8014ac6:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 8014aca:	d107      	bne.n	8014adc <HAL_RCCEx_GetPeriphCLKFreq+0x87c>
 8014acc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014ace:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 8014ad2:	d103      	bne.n	8014adc <HAL_RCCEx_GetPeriphCLKFreq+0x87c>
    {
      frequency = HSI_VALUE;
 8014ad4:	4ba3      	ldr	r3, [pc, #652]	@ (8014d64 <HAL_RCCEx_GetPeriphCLKFreq+0xb04>)
 8014ad6:	637b      	str	r3, [r7, #52]	@ 0x34
 8014ad8:	f000 bd96 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
    /* Clock not enabled for ADC */
    else
    {
      frequency = 0U;
 8014adc:	2300      	movs	r3, #0
 8014ade:	637b      	str	r3, [r7, #52]	@ 0x34
 8014ae0:	f000 bd92 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_MDF1)
 8014ae4:	e9d7 2300 	ldrd	r2, r3, [r7]
 8014ae8:	f5a2 3180 	sub.w	r1, r2, #65536	@ 0x10000
 8014aec:	430b      	orrs	r3, r1
 8014aee:	d158      	bne.n	8014ba2 <HAL_RCCEx_GetPeriphCLKFreq+0x942>
  {
    /* Get the current MDF1 source */
    srcclk = __HAL_RCC_GET_MDF1_SOURCE();
 8014af0:	4b9b      	ldr	r3, [pc, #620]	@ (8014d60 <HAL_RCCEx_GetPeriphCLKFreq+0xb00>)
 8014af2:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
 8014af6:	f003 0307 	and.w	r3, r3, #7
 8014afa:	633b      	str	r3, [r7, #48]	@ 0x30

    switch (srcclk)
 8014afc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014afe:	2b04      	cmp	r3, #4
 8014b00:	d84b      	bhi.n	8014b9a <HAL_RCCEx_GetPeriphCLKFreq+0x93a>
 8014b02:	a201      	add	r2, pc, #4	@ (adr r2, 8014b08 <HAL_RCCEx_GetPeriphCLKFreq+0x8a8>)
 8014b04:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8014b08:	08014b41 	.word	0x08014b41
 8014b0c:	08014b1d 	.word	0x08014b1d
 8014b10:	08014b2f 	.word	0x08014b2f
 8014b14:	08014b4b 	.word	0x08014b4b
 8014b18:	08014b55 	.word	0x08014b55
    {
      case RCC_MDF1CLKSOURCE_PLL1:

        HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 8014b1c:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 8014b20:	4618      	mov	r0, r3
 8014b22:	f7fe ff8f 	bl	8013a44 <HAL_RCCEx_GetPLL1ClockFreq>
        frequency = pll1_clocks.PLL1_P_Frequency;
 8014b26:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8014b28:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8014b2a:	f000 bd6d 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>

      case RCC_MDF1CLKSOURCE_PLL3:

        HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 8014b2e:	f107 030c 	add.w	r3, r7, #12
 8014b32:	4618      	mov	r0, r3
 8014b34:	f7ff fa3a 	bl	8013fac <HAL_RCCEx_GetPLL3ClockFreq>
        frequency = pll3_clocks.PLL3_Q_Frequency;
 8014b38:	693b      	ldr	r3, [r7, #16]
 8014b3a:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8014b3c:	f000 bd64 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>

      case RCC_MDF1CLKSOURCE_HCLK:

        frequency = HAL_RCC_GetHCLKFreq();
 8014b40:	f7fe f8e4 	bl	8012d0c <HAL_RCC_GetHCLKFreq>
 8014b44:	6378      	str	r0, [r7, #52]	@ 0x34
        break;
 8014b46:	f000 bd5f 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>

      case RCC_MDF1CLKSOURCE_PIN:

        frequency = EXTERNAL_SAI1_CLOCK_VALUE;
 8014b4a:	f64b 3380 	movw	r3, #48000	@ 0xbb80
 8014b4e:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8014b50:	f000 bd5a 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>

      case RCC_MDF1CLKSOURCE_MSIK:

        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 8014b54:	4b82      	ldr	r3, [pc, #520]	@ (8014d60 <HAL_RCCEx_GetPeriphCLKFreq+0xb00>)
 8014b56:	681b      	ldr	r3, [r3, #0]
 8014b58:	f003 0320 	and.w	r3, r3, #32
 8014b5c:	2b20      	cmp	r3, #32
 8014b5e:	d118      	bne.n	8014b92 <HAL_RCCEx_GetPeriphCLKFreq+0x932>
        {
          frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 8014b60:	4b7f      	ldr	r3, [pc, #508]	@ (8014d60 <HAL_RCCEx_GetPeriphCLKFreq+0xb00>)
 8014b62:	689b      	ldr	r3, [r3, #8]
 8014b64:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 8014b68:	2b00      	cmp	r3, #0
 8014b6a:	d005      	beq.n	8014b78 <HAL_RCCEx_GetPeriphCLKFreq+0x918>
 8014b6c:	4b7c      	ldr	r3, [pc, #496]	@ (8014d60 <HAL_RCCEx_GetPeriphCLKFreq+0xb00>)
 8014b6e:	689b      	ldr	r3, [r3, #8]
 8014b70:	0e1b      	lsrs	r3, r3, #24
 8014b72:	f003 030f 	and.w	r3, r3, #15
 8014b76:	e006      	b.n	8014b86 <HAL_RCCEx_GetPeriphCLKFreq+0x926>
 8014b78:	4b79      	ldr	r3, [pc, #484]	@ (8014d60 <HAL_RCCEx_GetPeriphCLKFreq+0xb00>)
 8014b7a:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 8014b7e:	041b      	lsls	r3, r3, #16
 8014b80:	0e1b      	lsrs	r3, r3, #24
 8014b82:	f003 030f 	and.w	r3, r3, #15
 8014b86:	4a78      	ldr	r2, [pc, #480]	@ (8014d68 <HAL_RCCEx_GetPeriphCLKFreq+0xb08>)
 8014b88:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8014b8c:	637b      	str	r3, [r7, #52]	@ 0x34
        }
        else
        {
          frequency = 0U;
        }
        break;
 8014b8e:	f000 bd3b 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
          frequency = 0U;
 8014b92:	2300      	movs	r3, #0
 8014b94:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8014b96:	f000 bd37 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>

      default:

        frequency = 0U;
 8014b9a:	2300      	movs	r3, #0
 8014b9c:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8014b9e:	f000 bd33 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_ADF1)
 8014ba2:	e9d7 2300 	ldrd	r2, r3, [r7]
 8014ba6:	f5a2 3100 	sub.w	r1, r2, #131072	@ 0x20000
 8014baa:	430b      	orrs	r3, r1
 8014bac:	d167      	bne.n	8014c7e <HAL_RCCEx_GetPeriphCLKFreq+0xa1e>
  {
    /* Get the current ADF1 source */
    srcclk = __HAL_RCC_GET_ADF1_SOURCE();
 8014bae:	4b6c      	ldr	r3, [pc, #432]	@ (8014d60 <HAL_RCCEx_GetPeriphCLKFreq+0xb00>)
 8014bb0:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 8014bb4:	f403 23e0 	and.w	r3, r3, #458752	@ 0x70000
 8014bb8:	633b      	str	r3, [r7, #48]	@ 0x30

    switch (srcclk)
 8014bba:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014bbc:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 8014bc0:	d036      	beq.n	8014c30 <HAL_RCCEx_GetPeriphCLKFreq+0x9d0>
 8014bc2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014bc4:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 8014bc8:	d855      	bhi.n	8014c76 <HAL_RCCEx_GetPeriphCLKFreq+0xa16>
 8014bca:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014bcc:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
 8014bd0:	d029      	beq.n	8014c26 <HAL_RCCEx_GetPeriphCLKFreq+0x9c6>
 8014bd2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014bd4:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
 8014bd8:	d84d      	bhi.n	8014c76 <HAL_RCCEx_GetPeriphCLKFreq+0xa16>
 8014bda:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014bdc:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 8014be0:	d013      	beq.n	8014c0a <HAL_RCCEx_GetPeriphCLKFreq+0x9aa>
 8014be2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014be4:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 8014be8:	d845      	bhi.n	8014c76 <HAL_RCCEx_GetPeriphCLKFreq+0xa16>
 8014bea:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014bec:	2b00      	cmp	r3, #0
 8014bee:	d015      	beq.n	8014c1c <HAL_RCCEx_GetPeriphCLKFreq+0x9bc>
 8014bf0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014bf2:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 8014bf6:	d13e      	bne.n	8014c76 <HAL_RCCEx_GetPeriphCLKFreq+0xa16>
    {
      case RCC_ADF1CLKSOURCE_PLL1:

        HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 8014bf8:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 8014bfc:	4618      	mov	r0, r3
 8014bfe:	f7fe ff21 	bl	8013a44 <HAL_RCCEx_GetPLL1ClockFreq>
        frequency = pll1_clocks.PLL1_P_Frequency;
 8014c02:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8014c04:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8014c06:	f000 bcff 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>

      case RCC_ADF1CLKSOURCE_PLL3:

        HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 8014c0a:	f107 030c 	add.w	r3, r7, #12
 8014c0e:	4618      	mov	r0, r3
 8014c10:	f7ff f9cc 	bl	8013fac <HAL_RCCEx_GetPLL3ClockFreq>
        frequency = pll3_clocks.PLL3_Q_Frequency;
 8014c14:	693b      	ldr	r3, [r7, #16]
 8014c16:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8014c18:	f000 bcf6 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>

      case RCC_ADF1CLKSOURCE_HCLK:

        frequency = HAL_RCC_GetHCLKFreq();
 8014c1c:	f7fe f876 	bl	8012d0c <HAL_RCC_GetHCLKFreq>
 8014c20:	6378      	str	r0, [r7, #52]	@ 0x34
        break;
 8014c22:	f000 bcf1 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>

      case RCC_ADF1CLKSOURCE_PIN:

        frequency = EXTERNAL_SAI1_CLOCK_VALUE;
 8014c26:	f64b 3380 	movw	r3, #48000	@ 0xbb80
 8014c2a:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8014c2c:	f000 bcec 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>

      case RCC_ADF1CLKSOURCE_MSIK:

        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 8014c30:	4b4b      	ldr	r3, [pc, #300]	@ (8014d60 <HAL_RCCEx_GetPeriphCLKFreq+0xb00>)
 8014c32:	681b      	ldr	r3, [r3, #0]
 8014c34:	f003 0320 	and.w	r3, r3, #32
 8014c38:	2b20      	cmp	r3, #32
 8014c3a:	d118      	bne.n	8014c6e <HAL_RCCEx_GetPeriphCLKFreq+0xa0e>
        {
          frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 8014c3c:	4b48      	ldr	r3, [pc, #288]	@ (8014d60 <HAL_RCCEx_GetPeriphCLKFreq+0xb00>)
 8014c3e:	689b      	ldr	r3, [r3, #8]
 8014c40:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 8014c44:	2b00      	cmp	r3, #0
 8014c46:	d005      	beq.n	8014c54 <HAL_RCCEx_GetPeriphCLKFreq+0x9f4>
 8014c48:	4b45      	ldr	r3, [pc, #276]	@ (8014d60 <HAL_RCCEx_GetPeriphCLKFreq+0xb00>)
 8014c4a:	689b      	ldr	r3, [r3, #8]
 8014c4c:	0e1b      	lsrs	r3, r3, #24
 8014c4e:	f003 030f 	and.w	r3, r3, #15
 8014c52:	e006      	b.n	8014c62 <HAL_RCCEx_GetPeriphCLKFreq+0xa02>
 8014c54:	4b42      	ldr	r3, [pc, #264]	@ (8014d60 <HAL_RCCEx_GetPeriphCLKFreq+0xb00>)
 8014c56:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 8014c5a:	041b      	lsls	r3, r3, #16
 8014c5c:	0e1b      	lsrs	r3, r3, #24
 8014c5e:	f003 030f 	and.w	r3, r3, #15
 8014c62:	4a41      	ldr	r2, [pc, #260]	@ (8014d68 <HAL_RCCEx_GetPeriphCLKFreq+0xb08>)
 8014c64:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8014c68:	637b      	str	r3, [r7, #52]	@ 0x34
        }
        else
        {
          frequency = 0U;
        }
        break;
 8014c6a:	f000 bccd 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
          frequency = 0U;
 8014c6e:	2300      	movs	r3, #0
 8014c70:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8014c72:	f000 bcc9 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>

      default:

        frequency = 0U;
 8014c76:	2300      	movs	r3, #0
 8014c78:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8014c7a:	f000 bcc5 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_I2C1)
 8014c7e:	e9d7 2300 	ldrd	r2, r3, [r7]
 8014c82:	f1a2 0140 	sub.w	r1, r2, #64	@ 0x40
 8014c86:	430b      	orrs	r3, r1
 8014c88:	d14c      	bne.n	8014d24 <HAL_RCCEx_GetPeriphCLKFreq+0xac4>
  {
    /* Get the current I2C1 source */
    srcclk = __HAL_RCC_GET_I2C1_SOURCE();
 8014c8a:	4b35      	ldr	r3, [pc, #212]	@ (8014d60 <HAL_RCCEx_GetPeriphCLKFreq+0xb00>)
 8014c8c:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8014c90:	f403 6340 	and.w	r3, r3, #3072	@ 0xc00
 8014c94:	633b      	str	r3, [r7, #48]	@ 0x30

    if (srcclk == RCC_I2C1CLKSOURCE_PCLK1)
 8014c96:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014c98:	2b00      	cmp	r3, #0
 8014c9a:	d104      	bne.n	8014ca6 <HAL_RCCEx_GetPeriphCLKFreq+0xa46>
    {
      frequency = HAL_RCC_GetPCLK1Freq();
 8014c9c:	f7fe f850 	bl	8012d40 <HAL_RCC_GetPCLK1Freq>
 8014ca0:	6378      	str	r0, [r7, #52]	@ 0x34
 8014ca2:	f000 bcb1 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
    else if (srcclk == RCC_I2C1CLKSOURCE_SYSCLK)
 8014ca6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014ca8:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 8014cac:	d104      	bne.n	8014cb8 <HAL_RCCEx_GetPeriphCLKFreq+0xa58>
    {
      frequency = HAL_RCC_GetSysClockFreq();
 8014cae:	f7fd ff2b 	bl	8012b08 <HAL_RCC_GetSysClockFreq>
 8014cb2:	6378      	str	r0, [r7, #52]	@ 0x34
 8014cb4:	f000 bca8 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_I2C1CLKSOURCE_HSI))
 8014cb8:	4b29      	ldr	r3, [pc, #164]	@ (8014d60 <HAL_RCCEx_GetPeriphCLKFreq+0xb00>)
 8014cba:	681b      	ldr	r3, [r3, #0]
 8014cbc:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8014cc0:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 8014cc4:	d107      	bne.n	8014cd6 <HAL_RCCEx_GetPeriphCLKFreq+0xa76>
 8014cc6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014cc8:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 8014ccc:	d103      	bne.n	8014cd6 <HAL_RCCEx_GetPeriphCLKFreq+0xa76>
    {
      frequency = HSI_VALUE;
 8014cce:	4b25      	ldr	r3, [pc, #148]	@ (8014d64 <HAL_RCCEx_GetPeriphCLKFreq+0xb04>)
 8014cd0:	637b      	str	r3, [r7, #52]	@ 0x34
 8014cd2:	f000 bc99 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY)) && (srcclk == RCC_I2C1CLKSOURCE_MSIK))
 8014cd6:	4b22      	ldr	r3, [pc, #136]	@ (8014d60 <HAL_RCCEx_GetPeriphCLKFreq+0xb00>)
 8014cd8:	681b      	ldr	r3, [r3, #0]
 8014cda:	f003 0320 	and.w	r3, r3, #32
 8014cde:	2b20      	cmp	r3, #32
 8014ce0:	d11c      	bne.n	8014d1c <HAL_RCCEx_GetPeriphCLKFreq+0xabc>
 8014ce2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014ce4:	f5b3 6f40 	cmp.w	r3, #3072	@ 0xc00
 8014ce8:	d118      	bne.n	8014d1c <HAL_RCCEx_GetPeriphCLKFreq+0xabc>
    {
      frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 8014cea:	4b1d      	ldr	r3, [pc, #116]	@ (8014d60 <HAL_RCCEx_GetPeriphCLKFreq+0xb00>)
 8014cec:	689b      	ldr	r3, [r3, #8]
 8014cee:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 8014cf2:	2b00      	cmp	r3, #0
 8014cf4:	d005      	beq.n	8014d02 <HAL_RCCEx_GetPeriphCLKFreq+0xaa2>
 8014cf6:	4b1a      	ldr	r3, [pc, #104]	@ (8014d60 <HAL_RCCEx_GetPeriphCLKFreq+0xb00>)
 8014cf8:	689b      	ldr	r3, [r3, #8]
 8014cfa:	0e1b      	lsrs	r3, r3, #24
 8014cfc:	f003 030f 	and.w	r3, r3, #15
 8014d00:	e006      	b.n	8014d10 <HAL_RCCEx_GetPeriphCLKFreq+0xab0>
 8014d02:	4b17      	ldr	r3, [pc, #92]	@ (8014d60 <HAL_RCCEx_GetPeriphCLKFreq+0xb00>)
 8014d04:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 8014d08:	041b      	lsls	r3, r3, #16
 8014d0a:	0e1b      	lsrs	r3, r3, #24
 8014d0c:	f003 030f 	and.w	r3, r3, #15
 8014d10:	4a15      	ldr	r2, [pc, #84]	@ (8014d68 <HAL_RCCEx_GetPeriphCLKFreq+0xb08>)
 8014d12:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8014d16:	637b      	str	r3, [r7, #52]	@ 0x34
 8014d18:	f000 bc76 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
    /* Clock not enabled for I2C1 */
    else
    {
      frequency = 0U;
 8014d1c:	2300      	movs	r3, #0
 8014d1e:	637b      	str	r3, [r7, #52]	@ 0x34
 8014d20:	f000 bc72 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_I2C2)
 8014d24:	e9d7 2300 	ldrd	r2, r3, [r7]
 8014d28:	f1a2 0180 	sub.w	r1, r2, #128	@ 0x80
 8014d2c:	430b      	orrs	r3, r1
 8014d2e:	d153      	bne.n	8014dd8 <HAL_RCCEx_GetPeriphCLKFreq+0xb78>
  {
    /* Get the current I2C2 source */
    srcclk = __HAL_RCC_GET_I2C2_SOURCE();
 8014d30:	4b0b      	ldr	r3, [pc, #44]	@ (8014d60 <HAL_RCCEx_GetPeriphCLKFreq+0xb00>)
 8014d32:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8014d36:	f403 5340 	and.w	r3, r3, #12288	@ 0x3000
 8014d3a:	633b      	str	r3, [r7, #48]	@ 0x30

    if (srcclk == RCC_I2C2CLKSOURCE_PCLK1)
 8014d3c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014d3e:	2b00      	cmp	r3, #0
 8014d40:	d104      	bne.n	8014d4c <HAL_RCCEx_GetPeriphCLKFreq+0xaec>
    {
      frequency = HAL_RCC_GetPCLK1Freq();
 8014d42:	f7fd fffd 	bl	8012d40 <HAL_RCC_GetPCLK1Freq>
 8014d46:	6378      	str	r0, [r7, #52]	@ 0x34
 8014d48:	f000 bc5e 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
    else if (srcclk == RCC_I2C2CLKSOURCE_SYSCLK)
 8014d4c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014d4e:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 8014d52:	d10b      	bne.n	8014d6c <HAL_RCCEx_GetPeriphCLKFreq+0xb0c>
    {
      frequency = HAL_RCC_GetSysClockFreq();
 8014d54:	f7fd fed8 	bl	8012b08 <HAL_RCC_GetSysClockFreq>
 8014d58:	6378      	str	r0, [r7, #52]	@ 0x34
 8014d5a:	f000 bc55 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
 8014d5e:	bf00      	nop
 8014d60:	46020c00 	.word	0x46020c00
 8014d64:	00f42400 	.word	0x00f42400
 8014d68:	0802a4e0 	.word	0x0802a4e0
    }
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_I2C2CLKSOURCE_HSI))
 8014d6c:	4ba1      	ldr	r3, [pc, #644]	@ (8014ff4 <HAL_RCCEx_GetPeriphCLKFreq+0xd94>)
 8014d6e:	681b      	ldr	r3, [r3, #0]
 8014d70:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8014d74:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 8014d78:	d107      	bne.n	8014d8a <HAL_RCCEx_GetPeriphCLKFreq+0xb2a>
 8014d7a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014d7c:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 8014d80:	d103      	bne.n	8014d8a <HAL_RCCEx_GetPeriphCLKFreq+0xb2a>
    {
      frequency = HSI_VALUE;
 8014d82:	4b9d      	ldr	r3, [pc, #628]	@ (8014ff8 <HAL_RCCEx_GetPeriphCLKFreq+0xd98>)
 8014d84:	637b      	str	r3, [r7, #52]	@ 0x34
 8014d86:	f000 bc3f 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY)) && (srcclk == RCC_I2C2CLKSOURCE_MSIK))
 8014d8a:	4b9a      	ldr	r3, [pc, #616]	@ (8014ff4 <HAL_RCCEx_GetPeriphCLKFreq+0xd94>)
 8014d8c:	681b      	ldr	r3, [r3, #0]
 8014d8e:	f003 0320 	and.w	r3, r3, #32
 8014d92:	2b20      	cmp	r3, #32
 8014d94:	d11c      	bne.n	8014dd0 <HAL_RCCEx_GetPeriphCLKFreq+0xb70>
 8014d96:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014d98:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
 8014d9c:	d118      	bne.n	8014dd0 <HAL_RCCEx_GetPeriphCLKFreq+0xb70>
    {
      frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 8014d9e:	4b95      	ldr	r3, [pc, #596]	@ (8014ff4 <HAL_RCCEx_GetPeriphCLKFreq+0xd94>)
 8014da0:	689b      	ldr	r3, [r3, #8]
 8014da2:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 8014da6:	2b00      	cmp	r3, #0
 8014da8:	d005      	beq.n	8014db6 <HAL_RCCEx_GetPeriphCLKFreq+0xb56>
 8014daa:	4b92      	ldr	r3, [pc, #584]	@ (8014ff4 <HAL_RCCEx_GetPeriphCLKFreq+0xd94>)
 8014dac:	689b      	ldr	r3, [r3, #8]
 8014dae:	0e1b      	lsrs	r3, r3, #24
 8014db0:	f003 030f 	and.w	r3, r3, #15
 8014db4:	e006      	b.n	8014dc4 <HAL_RCCEx_GetPeriphCLKFreq+0xb64>
 8014db6:	4b8f      	ldr	r3, [pc, #572]	@ (8014ff4 <HAL_RCCEx_GetPeriphCLKFreq+0xd94>)
 8014db8:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 8014dbc:	041b      	lsls	r3, r3, #16
 8014dbe:	0e1b      	lsrs	r3, r3, #24
 8014dc0:	f003 030f 	and.w	r3, r3, #15
 8014dc4:	4a8d      	ldr	r2, [pc, #564]	@ (8014ffc <HAL_RCCEx_GetPeriphCLKFreq+0xd9c>)
 8014dc6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8014dca:	637b      	str	r3, [r7, #52]	@ 0x34
 8014dcc:	f000 bc1c 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
    /* Clock not enabled for I2C2 */
    else
    {
      frequency = 0U;
 8014dd0:	2300      	movs	r3, #0
 8014dd2:	637b      	str	r3, [r7, #52]	@ 0x34
 8014dd4:	f000 bc18 	b.w	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_I2C3)
 8014dd8:	e9d7 2300 	ldrd	r2, r3, [r7]
 8014ddc:	f5a2 7180 	sub.w	r1, r2, #256	@ 0x100
 8014de0:	430b      	orrs	r3, r1
 8014de2:	d151      	bne.n	8014e88 <HAL_RCCEx_GetPeriphCLKFreq+0xc28>
  {
    /* Get the current I2C3 source */
    srcclk = __HAL_RCC_GET_I2C3_SOURCE();
 8014de4:	4b83      	ldr	r3, [pc, #524]	@ (8014ff4 <HAL_RCCEx_GetPeriphCLKFreq+0xd94>)
 8014de6:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 8014dea:	f003 03c0 	and.w	r3, r3, #192	@ 0xc0
 8014dee:	633b      	str	r3, [r7, #48]	@ 0x30

    switch (srcclk)
 8014df0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014df2:	2bc0      	cmp	r3, #192	@ 0xc0
 8014df4:	d024      	beq.n	8014e40 <HAL_RCCEx_GetPeriphCLKFreq+0xbe0>
 8014df6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014df8:	2bc0      	cmp	r3, #192	@ 0xc0
 8014dfa:	d842      	bhi.n	8014e82 <HAL_RCCEx_GetPeriphCLKFreq+0xc22>
 8014dfc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014dfe:	2b80      	cmp	r3, #128	@ 0x80
 8014e00:	d00d      	beq.n	8014e1e <HAL_RCCEx_GetPeriphCLKFreq+0xbbe>
 8014e02:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014e04:	2b80      	cmp	r3, #128	@ 0x80
 8014e06:	d83c      	bhi.n	8014e82 <HAL_RCCEx_GetPeriphCLKFreq+0xc22>
 8014e08:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014e0a:	2b00      	cmp	r3, #0
 8014e0c:	d003      	beq.n	8014e16 <HAL_RCCEx_GetPeriphCLKFreq+0xbb6>
 8014e0e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014e10:	2b40      	cmp	r3, #64	@ 0x40
 8014e12:	d011      	beq.n	8014e38 <HAL_RCCEx_GetPeriphCLKFreq+0xbd8>
 8014e14:	e035      	b.n	8014e82 <HAL_RCCEx_GetPeriphCLKFreq+0xc22>
    {
      case RCC_I2C3CLKSOURCE_PCLK3:
      {
        frequency = HAL_RCC_GetPCLK3Freq();
 8014e16:	f7fd ffbb 	bl	8012d90 <HAL_RCC_GetPCLK3Freq>
 8014e1a:	6378      	str	r0, [r7, #52]	@ 0x34
        break;
 8014e1c:	e3f4      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
      }
      case RCC_I2C3CLKSOURCE_HSI:
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
 8014e1e:	4b75      	ldr	r3, [pc, #468]	@ (8014ff4 <HAL_RCCEx_GetPeriphCLKFreq+0xd94>)
 8014e20:	681b      	ldr	r3, [r3, #0]
 8014e22:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8014e26:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 8014e2a:	d102      	bne.n	8014e32 <HAL_RCCEx_GetPeriphCLKFreq+0xbd2>
        {
          frequency = HSI_VALUE;
 8014e2c:	4b72      	ldr	r3, [pc, #456]	@ (8014ff8 <HAL_RCCEx_GetPeriphCLKFreq+0xd98>)
 8014e2e:	637b      	str	r3, [r7, #52]	@ 0x34
        }
        else
        {
          frequency = 0U;
        }
        break;
 8014e30:	e3ea      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
          frequency = 0U;
 8014e32:	2300      	movs	r3, #0
 8014e34:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8014e36:	e3e7      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
      }
      case RCC_I2C3CLKSOURCE_SYSCLK:
      {
        frequency = HAL_RCC_GetSysClockFreq();
 8014e38:	f7fd fe66 	bl	8012b08 <HAL_RCC_GetSysClockFreq>
 8014e3c:	6378      	str	r0, [r7, #52]	@ 0x34
        break;
 8014e3e:	e3e3      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
      }
      case RCC_I2C3CLKSOURCE_MSIK:
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 8014e40:	4b6c      	ldr	r3, [pc, #432]	@ (8014ff4 <HAL_RCCEx_GetPeriphCLKFreq+0xd94>)
 8014e42:	681b      	ldr	r3, [r3, #0]
 8014e44:	f003 0320 	and.w	r3, r3, #32
 8014e48:	2b20      	cmp	r3, #32
 8014e4a:	d117      	bne.n	8014e7c <HAL_RCCEx_GetPeriphCLKFreq+0xc1c>
        {
          frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 8014e4c:	4b69      	ldr	r3, [pc, #420]	@ (8014ff4 <HAL_RCCEx_GetPeriphCLKFreq+0xd94>)
 8014e4e:	689b      	ldr	r3, [r3, #8]
 8014e50:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 8014e54:	2b00      	cmp	r3, #0
 8014e56:	d005      	beq.n	8014e64 <HAL_RCCEx_GetPeriphCLKFreq+0xc04>
 8014e58:	4b66      	ldr	r3, [pc, #408]	@ (8014ff4 <HAL_RCCEx_GetPeriphCLKFreq+0xd94>)
 8014e5a:	689b      	ldr	r3, [r3, #8]
 8014e5c:	0e1b      	lsrs	r3, r3, #24
 8014e5e:	f003 030f 	and.w	r3, r3, #15
 8014e62:	e006      	b.n	8014e72 <HAL_RCCEx_GetPeriphCLKFreq+0xc12>
 8014e64:	4b63      	ldr	r3, [pc, #396]	@ (8014ff4 <HAL_RCCEx_GetPeriphCLKFreq+0xd94>)
 8014e66:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 8014e6a:	041b      	lsls	r3, r3, #16
 8014e6c:	0e1b      	lsrs	r3, r3, #24
 8014e6e:	f003 030f 	and.w	r3, r3, #15
 8014e72:	4a62      	ldr	r2, [pc, #392]	@ (8014ffc <HAL_RCCEx_GetPeriphCLKFreq+0xd9c>)
 8014e74:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8014e78:	637b      	str	r3, [r7, #52]	@ 0x34
        }
        else
        {
          frequency = 0U;
        }
        break;
 8014e7a:	e3c5      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
          frequency = 0U;
 8014e7c:	2300      	movs	r3, #0
 8014e7e:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8014e80:	e3c2      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
      }
      default:
      {
        frequency = 0U;
 8014e82:	2300      	movs	r3, #0
 8014e84:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8014e86:	e3bf      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
      }
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_I2C4)
 8014e88:	e9d7 2300 	ldrd	r2, r3, [r7]
 8014e8c:	f5a2 0180 	sub.w	r1, r2, #4194304	@ 0x400000
 8014e90:	430b      	orrs	r3, r1
 8014e92:	d147      	bne.n	8014f24 <HAL_RCCEx_GetPeriphCLKFreq+0xcc4>
  {
    /* Get the current I2C4 source */
    srcclk = __HAL_RCC_GET_I2C4_SOURCE();
 8014e94:	4b57      	ldr	r3, [pc, #348]	@ (8014ff4 <HAL_RCCEx_GetPeriphCLKFreq+0xd94>)
 8014e96:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8014e9a:	f403 4340 	and.w	r3, r3, #49152	@ 0xc000
 8014e9e:	633b      	str	r3, [r7, #48]	@ 0x30

    if (srcclk == RCC_I2C4CLKSOURCE_PCLK1)
 8014ea0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014ea2:	2b00      	cmp	r3, #0
 8014ea4:	d103      	bne.n	8014eae <HAL_RCCEx_GetPeriphCLKFreq+0xc4e>
    {
      frequency = HAL_RCC_GetPCLK1Freq();
 8014ea6:	f7fd ff4b 	bl	8012d40 <HAL_RCC_GetPCLK1Freq>
 8014eaa:	6378      	str	r0, [r7, #52]	@ 0x34
 8014eac:	e3ac      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
    else if (srcclk == RCC_I2C4CLKSOURCE_SYSCLK)
 8014eae:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014eb0:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 8014eb4:	d103      	bne.n	8014ebe <HAL_RCCEx_GetPeriphCLKFreq+0xc5e>
    {
      frequency = HAL_RCC_GetSysClockFreq();
 8014eb6:	f7fd fe27 	bl	8012b08 <HAL_RCC_GetSysClockFreq>
 8014eba:	6378      	str	r0, [r7, #52]	@ 0x34
 8014ebc:	e3a4      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_I2C4CLKSOURCE_HSI))
 8014ebe:	4b4d      	ldr	r3, [pc, #308]	@ (8014ff4 <HAL_RCCEx_GetPeriphCLKFreq+0xd94>)
 8014ec0:	681b      	ldr	r3, [r3, #0]
 8014ec2:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8014ec6:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 8014eca:	d106      	bne.n	8014eda <HAL_RCCEx_GetPeriphCLKFreq+0xc7a>
 8014ecc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014ece:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 8014ed2:	d102      	bne.n	8014eda <HAL_RCCEx_GetPeriphCLKFreq+0xc7a>
    {
      frequency = HSI_VALUE;
 8014ed4:	4b48      	ldr	r3, [pc, #288]	@ (8014ff8 <HAL_RCCEx_GetPeriphCLKFreq+0xd98>)
 8014ed6:	637b      	str	r3, [r7, #52]	@ 0x34
 8014ed8:	e396      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY)) && (srcclk == RCC_I2C4CLKSOURCE_MSIK))
 8014eda:	4b46      	ldr	r3, [pc, #280]	@ (8014ff4 <HAL_RCCEx_GetPeriphCLKFreq+0xd94>)
 8014edc:	681b      	ldr	r3, [r3, #0]
 8014ede:	f003 0320 	and.w	r3, r3, #32
 8014ee2:	2b20      	cmp	r3, #32
 8014ee4:	d11b      	bne.n	8014f1e <HAL_RCCEx_GetPeriphCLKFreq+0xcbe>
 8014ee6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014ee8:	f5b3 4f40 	cmp.w	r3, #49152	@ 0xc000
 8014eec:	d117      	bne.n	8014f1e <HAL_RCCEx_GetPeriphCLKFreq+0xcbe>
    {
      frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 8014eee:	4b41      	ldr	r3, [pc, #260]	@ (8014ff4 <HAL_RCCEx_GetPeriphCLKFreq+0xd94>)
 8014ef0:	689b      	ldr	r3, [r3, #8]
 8014ef2:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 8014ef6:	2b00      	cmp	r3, #0
 8014ef8:	d005      	beq.n	8014f06 <HAL_RCCEx_GetPeriphCLKFreq+0xca6>
 8014efa:	4b3e      	ldr	r3, [pc, #248]	@ (8014ff4 <HAL_RCCEx_GetPeriphCLKFreq+0xd94>)
 8014efc:	689b      	ldr	r3, [r3, #8]
 8014efe:	0e1b      	lsrs	r3, r3, #24
 8014f00:	f003 030f 	and.w	r3, r3, #15
 8014f04:	e006      	b.n	8014f14 <HAL_RCCEx_GetPeriphCLKFreq+0xcb4>
 8014f06:	4b3b      	ldr	r3, [pc, #236]	@ (8014ff4 <HAL_RCCEx_GetPeriphCLKFreq+0xd94>)
 8014f08:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 8014f0c:	041b      	lsls	r3, r3, #16
 8014f0e:	0e1b      	lsrs	r3, r3, #24
 8014f10:	f003 030f 	and.w	r3, r3, #15
 8014f14:	4a39      	ldr	r2, [pc, #228]	@ (8014ffc <HAL_RCCEx_GetPeriphCLKFreq+0xd9c>)
 8014f16:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8014f1a:	637b      	str	r3, [r7, #52]	@ 0x34
 8014f1c:	e374      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
    /* Clock not enabled for I2C4 */
    else
    {
      frequency = 0U;
 8014f1e:	2300      	movs	r3, #0
 8014f20:	637b      	str	r3, [r7, #52]	@ 0x34
 8014f22:	e371      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    {
      frequency = 0U;
    }
  }
#endif /* I2C6 */
  else if (PeriphClk == RCC_PERIPHCLK_LPTIM34)
 8014f24:	e9d7 2300 	ldrd	r2, r3, [r7]
 8014f28:	f5a2 6100 	sub.w	r1, r2, #2048	@ 0x800
 8014f2c:	430b      	orrs	r3, r1
 8014f2e:	d16a      	bne.n	8015006 <HAL_RCCEx_GetPeriphCLKFreq+0xda6>
  {
    /* Get the current LPTIM34 source */
    srcclk = __HAL_RCC_GET_LPTIM34_SOURCE();
 8014f30:	4b30      	ldr	r3, [pc, #192]	@ (8014ff4 <HAL_RCCEx_GetPeriphCLKFreq+0xd94>)
 8014f32:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 8014f36:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 8014f3a:	633b      	str	r3, [r7, #48]	@ 0x30

    if (srcclk == RCC_LPTIM34CLKSOURCE_MSIK)
 8014f3c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014f3e:	2b00      	cmp	r3, #0
 8014f40:	d120      	bne.n	8014f84 <HAL_RCCEx_GetPeriphCLKFreq+0xd24>
    {
      if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 8014f42:	4b2c      	ldr	r3, [pc, #176]	@ (8014ff4 <HAL_RCCEx_GetPeriphCLKFreq+0xd94>)
 8014f44:	681b      	ldr	r3, [r3, #0]
 8014f46:	f003 0320 	and.w	r3, r3, #32
 8014f4a:	2b20      	cmp	r3, #32
 8014f4c:	d117      	bne.n	8014f7e <HAL_RCCEx_GetPeriphCLKFreq+0xd1e>
      {
        frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 8014f4e:	4b29      	ldr	r3, [pc, #164]	@ (8014ff4 <HAL_RCCEx_GetPeriphCLKFreq+0xd94>)
 8014f50:	689b      	ldr	r3, [r3, #8]
 8014f52:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 8014f56:	2b00      	cmp	r3, #0
 8014f58:	d005      	beq.n	8014f66 <HAL_RCCEx_GetPeriphCLKFreq+0xd06>
 8014f5a:	4b26      	ldr	r3, [pc, #152]	@ (8014ff4 <HAL_RCCEx_GetPeriphCLKFreq+0xd94>)
 8014f5c:	689b      	ldr	r3, [r3, #8]
 8014f5e:	0e1b      	lsrs	r3, r3, #24
 8014f60:	f003 030f 	and.w	r3, r3, #15
 8014f64:	e006      	b.n	8014f74 <HAL_RCCEx_GetPeriphCLKFreq+0xd14>
 8014f66:	4b23      	ldr	r3, [pc, #140]	@ (8014ff4 <HAL_RCCEx_GetPeriphCLKFreq+0xd94>)
 8014f68:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 8014f6c:	041b      	lsls	r3, r3, #16
 8014f6e:	0e1b      	lsrs	r3, r3, #24
 8014f70:	f003 030f 	and.w	r3, r3, #15
 8014f74:	4a21      	ldr	r2, [pc, #132]	@ (8014ffc <HAL_RCCEx_GetPeriphCLKFreq+0xd9c>)
 8014f76:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8014f7a:	637b      	str	r3, [r7, #52]	@ 0x34
 8014f7c:	e344      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
      }
      else
      {
        frequency = 0U;
 8014f7e:	2300      	movs	r3, #0
 8014f80:	637b      	str	r3, [r7, #52]	@ 0x34
 8014f82:	e341      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
      }
    }
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIRDY)) && (srcclk == RCC_LPTIM34CLKSOURCE_LSI))
 8014f84:	4b1b      	ldr	r3, [pc, #108]	@ (8014ff4 <HAL_RCCEx_GetPeriphCLKFreq+0xd94>)
 8014f86:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8014f8a:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8014f8e:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 8014f92:	d112      	bne.n	8014fba <HAL_RCCEx_GetPeriphCLKFreq+0xd5a>
 8014f94:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014f96:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8014f9a:	d10e      	bne.n	8014fba <HAL_RCCEx_GetPeriphCLKFreq+0xd5a>
    {
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIPREDIV))
 8014f9c:	4b15      	ldr	r3, [pc, #84]	@ (8014ff4 <HAL_RCCEx_GetPeriphCLKFreq+0xd94>)
 8014f9e:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8014fa2:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 8014fa6:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 8014faa:	d102      	bne.n	8014fb2 <HAL_RCCEx_GetPeriphCLKFreq+0xd52>
      {
        frequency = LSI_VALUE / 128U;
 8014fac:	23fa      	movs	r3, #250	@ 0xfa
 8014fae:	637b      	str	r3, [r7, #52]	@ 0x34
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIPREDIV))
 8014fb0:	e32a      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
      }
      else
      {
        frequency = LSI_VALUE;
 8014fb2:	f44f 43fa 	mov.w	r3, #32000	@ 0x7d00
 8014fb6:	637b      	str	r3, [r7, #52]	@ 0x34
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIPREDIV))
 8014fb8:	e326      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
      }
    }
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_LPTIM34CLKSOURCE_HSI))
 8014fba:	4b0e      	ldr	r3, [pc, #56]	@ (8014ff4 <HAL_RCCEx_GetPeriphCLKFreq+0xd94>)
 8014fbc:	681b      	ldr	r3, [r3, #0]
 8014fbe:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8014fc2:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 8014fc6:	d106      	bne.n	8014fd6 <HAL_RCCEx_GetPeriphCLKFreq+0xd76>
 8014fc8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014fca:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8014fce:	d102      	bne.n	8014fd6 <HAL_RCCEx_GetPeriphCLKFreq+0xd76>
    {
      frequency = HSI_VALUE;
 8014fd0:	4b09      	ldr	r3, [pc, #36]	@ (8014ff8 <HAL_RCCEx_GetPeriphCLKFreq+0xd98>)
 8014fd2:	637b      	str	r3, [r7, #52]	@ 0x34
 8014fd4:	e318      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_LPTIM34CLKSOURCE_LSE))
 8014fd6:	4b07      	ldr	r3, [pc, #28]	@ (8014ff4 <HAL_RCCEx_GetPeriphCLKFreq+0xd94>)
 8014fd8:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8014fdc:	f003 0302 	and.w	r3, r3, #2
 8014fe0:	2b02      	cmp	r3, #2
 8014fe2:	d10d      	bne.n	8015000 <HAL_RCCEx_GetPeriphCLKFreq+0xda0>
 8014fe4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8014fe6:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
 8014fea:	d109      	bne.n	8015000 <HAL_RCCEx_GetPeriphCLKFreq+0xda0>
    {
      frequency = LSE_VALUE;
 8014fec:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 8014ff0:	637b      	str	r3, [r7, #52]	@ 0x34
 8014ff2:	e309      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
 8014ff4:	46020c00 	.word	0x46020c00
 8014ff8:	00f42400 	.word	0x00f42400
 8014ffc:	0802a4e0 	.word	0x0802a4e0
    }
    /* Clock not enabled for LPTIM34 */
    else
    {
      frequency = 0U;
 8015000:	2300      	movs	r3, #0
 8015002:	637b      	str	r3, [r7, #52]	@ 0x34
 8015004:	e300      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_LPTIM1)
 8015006:	e9d7 2300 	ldrd	r2, r3, [r7]
 801500a:	f5a2 7100 	sub.w	r1, r2, #512	@ 0x200
 801500e:	430b      	orrs	r3, r1
 8015010:	d164      	bne.n	80150dc <HAL_RCCEx_GetPeriphCLKFreq+0xe7c>
  {
    /* Get the current LPTIM1 source */
    srcclk = __HAL_RCC_GET_LPTIM1_SOURCE();
 8015012:	4ba2      	ldr	r3, [pc, #648]	@ (801529c <HAL_RCCEx_GetPeriphCLKFreq+0x103c>)
 8015014:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 8015018:	f403 6340 	and.w	r3, r3, #3072	@ 0xc00
 801501c:	633b      	str	r3, [r7, #48]	@ 0x30

    if (srcclk == RCC_LPTIM1CLKSOURCE_MSIK)
 801501e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8015020:	2b00      	cmp	r3, #0
 8015022:	d120      	bne.n	8015066 <HAL_RCCEx_GetPeriphCLKFreq+0xe06>
    {
      if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 8015024:	4b9d      	ldr	r3, [pc, #628]	@ (801529c <HAL_RCCEx_GetPeriphCLKFreq+0x103c>)
 8015026:	681b      	ldr	r3, [r3, #0]
 8015028:	f003 0320 	and.w	r3, r3, #32
 801502c:	2b20      	cmp	r3, #32
 801502e:	d117      	bne.n	8015060 <HAL_RCCEx_GetPeriphCLKFreq+0xe00>
      {
        frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 8015030:	4b9a      	ldr	r3, [pc, #616]	@ (801529c <HAL_RCCEx_GetPeriphCLKFreq+0x103c>)
 8015032:	689b      	ldr	r3, [r3, #8]
 8015034:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 8015038:	2b00      	cmp	r3, #0
 801503a:	d005      	beq.n	8015048 <HAL_RCCEx_GetPeriphCLKFreq+0xde8>
 801503c:	4b97      	ldr	r3, [pc, #604]	@ (801529c <HAL_RCCEx_GetPeriphCLKFreq+0x103c>)
 801503e:	689b      	ldr	r3, [r3, #8]
 8015040:	0e1b      	lsrs	r3, r3, #24
 8015042:	f003 030f 	and.w	r3, r3, #15
 8015046:	e006      	b.n	8015056 <HAL_RCCEx_GetPeriphCLKFreq+0xdf6>
 8015048:	4b94      	ldr	r3, [pc, #592]	@ (801529c <HAL_RCCEx_GetPeriphCLKFreq+0x103c>)
 801504a:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 801504e:	041b      	lsls	r3, r3, #16
 8015050:	0e1b      	lsrs	r3, r3, #24
 8015052:	f003 030f 	and.w	r3, r3, #15
 8015056:	4a92      	ldr	r2, [pc, #584]	@ (80152a0 <HAL_RCCEx_GetPeriphCLKFreq+0x1040>)
 8015058:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801505c:	637b      	str	r3, [r7, #52]	@ 0x34
 801505e:	e2d3      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
      }
      else
      {
        frequency = 0U;
 8015060:	2300      	movs	r3, #0
 8015062:	637b      	str	r3, [r7, #52]	@ 0x34
 8015064:	e2d0      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
      }
    }
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIRDY)) && (srcclk == RCC_LPTIM1CLKSOURCE_LSI))
 8015066:	4b8d      	ldr	r3, [pc, #564]	@ (801529c <HAL_RCCEx_GetPeriphCLKFreq+0x103c>)
 8015068:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 801506c:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8015070:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 8015074:	d112      	bne.n	801509c <HAL_RCCEx_GetPeriphCLKFreq+0xe3c>
 8015076:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8015078:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 801507c:	d10e      	bne.n	801509c <HAL_RCCEx_GetPeriphCLKFreq+0xe3c>
    {
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIPREDIV))
 801507e:	4b87      	ldr	r3, [pc, #540]	@ (801529c <HAL_RCCEx_GetPeriphCLKFreq+0x103c>)
 8015080:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8015084:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 8015088:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 801508c:	d102      	bne.n	8015094 <HAL_RCCEx_GetPeriphCLKFreq+0xe34>
      {
        frequency = LSI_VALUE / 128U;
 801508e:	23fa      	movs	r3, #250	@ 0xfa
 8015090:	637b      	str	r3, [r7, #52]	@ 0x34
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIPREDIV))
 8015092:	e2b9      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
      }
      else
      {
        frequency = LSI_VALUE;
 8015094:	f44f 43fa 	mov.w	r3, #32000	@ 0x7d00
 8015098:	637b      	str	r3, [r7, #52]	@ 0x34
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIPREDIV))
 801509a:	e2b5      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
      }
    }
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_LPTIM1CLKSOURCE_HSI))
 801509c:	4b7f      	ldr	r3, [pc, #508]	@ (801529c <HAL_RCCEx_GetPeriphCLKFreq+0x103c>)
 801509e:	681b      	ldr	r3, [r3, #0]
 80150a0:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 80150a4:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 80150a8:	d106      	bne.n	80150b8 <HAL_RCCEx_GetPeriphCLKFreq+0xe58>
 80150aa:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80150ac:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 80150b0:	d102      	bne.n	80150b8 <HAL_RCCEx_GetPeriphCLKFreq+0xe58>
    {
      frequency = HSI_VALUE;
 80150b2:	4b7c      	ldr	r3, [pc, #496]	@ (80152a4 <HAL_RCCEx_GetPeriphCLKFreq+0x1044>)
 80150b4:	637b      	str	r3, [r7, #52]	@ 0x34
 80150b6:	e2a7      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_LPTIM1CLKSOURCE_LSE))
 80150b8:	4b78      	ldr	r3, [pc, #480]	@ (801529c <HAL_RCCEx_GetPeriphCLKFreq+0x103c>)
 80150ba:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 80150be:	f003 0302 	and.w	r3, r3, #2
 80150c2:	2b02      	cmp	r3, #2
 80150c4:	d107      	bne.n	80150d6 <HAL_RCCEx_GetPeriphCLKFreq+0xe76>
 80150c6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80150c8:	f5b3 6f40 	cmp.w	r3, #3072	@ 0xc00
 80150cc:	d103      	bne.n	80150d6 <HAL_RCCEx_GetPeriphCLKFreq+0xe76>
    {
      frequency = LSE_VALUE;
 80150ce:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 80150d2:	637b      	str	r3, [r7, #52]	@ 0x34
 80150d4:	e298      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
    /* Clock not enabled for LPTIM1 */
    else
    {
      frequency = 0U;
 80150d6:	2300      	movs	r3, #0
 80150d8:	637b      	str	r3, [r7, #52]	@ 0x34
 80150da:	e295      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_LPTIM2)
 80150dc:	e9d7 2300 	ldrd	r2, r3, [r7]
 80150e0:	f5a2 6180 	sub.w	r1, r2, #1024	@ 0x400
 80150e4:	430b      	orrs	r3, r1
 80150e6:	d147      	bne.n	8015178 <HAL_RCCEx_GetPeriphCLKFreq+0xf18>
  {
    /* Get the current LPTIM2 source */
    srcclk = __HAL_RCC_GET_LPTIM2_SOURCE();
 80150e8:	4b6c      	ldr	r3, [pc, #432]	@ (801529c <HAL_RCCEx_GetPeriphCLKFreq+0x103c>)
 80150ea:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 80150ee:	f403 2340 	and.w	r3, r3, #786432	@ 0xc0000
 80150f2:	633b      	str	r3, [r7, #48]	@ 0x30

    if (srcclk == RCC_LPTIM2CLKSOURCE_PCLK1)
 80150f4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80150f6:	2b00      	cmp	r3, #0
 80150f8:	d103      	bne.n	8015102 <HAL_RCCEx_GetPeriphCLKFreq+0xea2>
    {
      frequency = HAL_RCC_GetPCLK1Freq();
 80150fa:	f7fd fe21 	bl	8012d40 <HAL_RCC_GetPCLK1Freq>
 80150fe:	6378      	str	r0, [r7, #52]	@ 0x34
 8015100:	e282      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIRDY)) && (srcclk == RCC_LPTIM2CLKSOURCE_LSI))
 8015102:	4b66      	ldr	r3, [pc, #408]	@ (801529c <HAL_RCCEx_GetPeriphCLKFreq+0x103c>)
 8015104:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8015108:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 801510c:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 8015110:	d112      	bne.n	8015138 <HAL_RCCEx_GetPeriphCLKFreq+0xed8>
 8015112:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8015114:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 8015118:	d10e      	bne.n	8015138 <HAL_RCCEx_GetPeriphCLKFreq+0xed8>
    {
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIPREDIV))
 801511a:	4b60      	ldr	r3, [pc, #384]	@ (801529c <HAL_RCCEx_GetPeriphCLKFreq+0x103c>)
 801511c:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8015120:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 8015124:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 8015128:	d102      	bne.n	8015130 <HAL_RCCEx_GetPeriphCLKFreq+0xed0>
      {
        frequency = LSI_VALUE / 128U;
 801512a:	23fa      	movs	r3, #250	@ 0xfa
 801512c:	637b      	str	r3, [r7, #52]	@ 0x34
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIPREDIV))
 801512e:	e26b      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
      }
      else
      {
        frequency = LSI_VALUE;
 8015130:	f44f 43fa 	mov.w	r3, #32000	@ 0x7d00
 8015134:	637b      	str	r3, [r7, #52]	@ 0x34
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIPREDIV))
 8015136:	e267      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
      }
    }
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_LPTIM2CLKSOURCE_HSI))
 8015138:	4b58      	ldr	r3, [pc, #352]	@ (801529c <HAL_RCCEx_GetPeriphCLKFreq+0x103c>)
 801513a:	681b      	ldr	r3, [r3, #0]
 801513c:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8015140:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 8015144:	d106      	bne.n	8015154 <HAL_RCCEx_GetPeriphCLKFreq+0xef4>
 8015146:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8015148:	f5b3 2f00 	cmp.w	r3, #524288	@ 0x80000
 801514c:	d102      	bne.n	8015154 <HAL_RCCEx_GetPeriphCLKFreq+0xef4>
    {
      frequency = HSI_VALUE;
 801514e:	4b55      	ldr	r3, [pc, #340]	@ (80152a4 <HAL_RCCEx_GetPeriphCLKFreq+0x1044>)
 8015150:	637b      	str	r3, [r7, #52]	@ 0x34
 8015152:	e259      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_LPTIM2CLKSOURCE_LSE))
 8015154:	4b51      	ldr	r3, [pc, #324]	@ (801529c <HAL_RCCEx_GetPeriphCLKFreq+0x103c>)
 8015156:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 801515a:	f003 0302 	and.w	r3, r3, #2
 801515e:	2b02      	cmp	r3, #2
 8015160:	d107      	bne.n	8015172 <HAL_RCCEx_GetPeriphCLKFreq+0xf12>
 8015162:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8015164:	f5b3 2f40 	cmp.w	r3, #786432	@ 0xc0000
 8015168:	d103      	bne.n	8015172 <HAL_RCCEx_GetPeriphCLKFreq+0xf12>
    {
      frequency = LSE_VALUE;
 801516a:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 801516e:	637b      	str	r3, [r7, #52]	@ 0x34
 8015170:	e24a      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
    /* Clock not enabled for LPTIM2 */
    else
    {
      frequency = 0U;
 8015172:	2300      	movs	r3, #0
 8015174:	637b      	str	r3, [r7, #52]	@ 0x34
 8015176:	e247      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_FDCAN1)
 8015178:	e9d7 2300 	ldrd	r2, r3, [r7]
 801517c:	f102 4178 	add.w	r1, r2, #4160749568	@ 0xf8000000
 8015180:	430b      	orrs	r3, r1
 8015182:	d12d      	bne.n	80151e0 <HAL_RCCEx_GetPeriphCLKFreq+0xf80>
  {
    /* Get the current FDCAN1 kernel source */
    srcclk = __HAL_RCC_GET_FDCAN1_SOURCE();
 8015184:	4b45      	ldr	r3, [pc, #276]	@ (801529c <HAL_RCCEx_GetPeriphCLKFreq+0x103c>)
 8015186:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 801518a:	f003 7340 	and.w	r3, r3, #50331648	@ 0x3000000
 801518e:	633b      	str	r3, [r7, #48]	@ 0x30

    if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (srcclk == RCC_FDCAN1CLKSOURCE_HSE))
 8015190:	4b42      	ldr	r3, [pc, #264]	@ (801529c <HAL_RCCEx_GetPeriphCLKFreq+0x103c>)
 8015192:	681b      	ldr	r3, [r3, #0]
 8015194:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8015198:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 801519c:	d105      	bne.n	80151aa <HAL_RCCEx_GetPeriphCLKFreq+0xf4a>
 801519e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80151a0:	2b00      	cmp	r3, #0
 80151a2:	d102      	bne.n	80151aa <HAL_RCCEx_GetPeriphCLKFreq+0xf4a>
    {
      frequency = HSE_VALUE;
 80151a4:	4b3f      	ldr	r3, [pc, #252]	@ (80152a4 <HAL_RCCEx_GetPeriphCLKFreq+0x1044>)
 80151a6:	637b      	str	r3, [r7, #52]	@ 0x34
 80151a8:	e22e      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
    else if (srcclk == RCC_FDCAN1CLKSOURCE_PLL1) /* PLL1 ? */
 80151aa:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80151ac:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
 80151b0:	d107      	bne.n	80151c2 <HAL_RCCEx_GetPeriphCLKFreq+0xf62>
    {
      HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 80151b2:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 80151b6:	4618      	mov	r0, r3
 80151b8:	f7fe fc44 	bl	8013a44 <HAL_RCCEx_GetPLL1ClockFreq>
      frequency = pll1_clocks.PLL1_Q_Frequency;
 80151bc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80151be:	637b      	str	r3, [r7, #52]	@ 0x34
 80151c0:	e222      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
    else if (srcclk == RCC_FDCAN1CLKSOURCE_PLL2) /* PLL2 ? */
 80151c2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80151c4:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 80151c8:	d107      	bne.n	80151da <HAL_RCCEx_GetPeriphCLKFreq+0xf7a>
    {
      HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 80151ca:	f107 0318 	add.w	r3, r7, #24
 80151ce:	4618      	mov	r0, r3
 80151d0:	f7fe fd92 	bl	8013cf8 <HAL_RCCEx_GetPLL2ClockFreq>
      frequency = pll2_clocks.PLL2_P_Frequency;
 80151d4:	69bb      	ldr	r3, [r7, #24]
 80151d6:	637b      	str	r3, [r7, #52]	@ 0x34
 80151d8:	e216      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
    /* Clock not enabled for FDCAN1 */
    else
    {
      frequency = 0U;
 80151da:	2300      	movs	r3, #0
 80151dc:	637b      	str	r3, [r7, #52]	@ 0x34
 80151de:	e213      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_SPI1)
 80151e0:	e9d7 2300 	ldrd	r2, r3, [r7]
 80151e4:	f5a2 0100 	sub.w	r1, r2, #8388608	@ 0x800000
 80151e8:	430b      	orrs	r3, r1
 80151ea:	d15d      	bne.n	80152a8 <HAL_RCCEx_GetPeriphCLKFreq+0x1048>
  {
    /* Get the current SPI1 kernel source */
    srcclk = __HAL_RCC_GET_SPI1_SOURCE();
 80151ec:	4b2b      	ldr	r3, [pc, #172]	@ (801529c <HAL_RCCEx_GetPeriphCLKFreq+0x103c>)
 80151ee:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 80151f2:	f403 1340 	and.w	r3, r3, #3145728	@ 0x300000
 80151f6:	633b      	str	r3, [r7, #48]	@ 0x30
    switch (srcclk)
 80151f8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80151fa:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
 80151fe:	d028      	beq.n	8015252 <HAL_RCCEx_GetPeriphCLKFreq+0xff2>
 8015200:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8015202:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
 8015206:	d845      	bhi.n	8015294 <HAL_RCCEx_GetPeriphCLKFreq+0x1034>
 8015208:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801520a:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 801520e:	d013      	beq.n	8015238 <HAL_RCCEx_GetPeriphCLKFreq+0xfd8>
 8015210:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8015212:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 8015216:	d83d      	bhi.n	8015294 <HAL_RCCEx_GetPeriphCLKFreq+0x1034>
 8015218:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801521a:	2b00      	cmp	r3, #0
 801521c:	d004      	beq.n	8015228 <HAL_RCCEx_GetPeriphCLKFreq+0xfc8>
 801521e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8015220:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 8015224:	d004      	beq.n	8015230 <HAL_RCCEx_GetPeriphCLKFreq+0xfd0>
 8015226:	e035      	b.n	8015294 <HAL_RCCEx_GetPeriphCLKFreq+0x1034>
    {
      case RCC_SPI1CLKSOURCE_PCLK2:

        frequency = HAL_RCC_GetPCLK2Freq();
 8015228:	f7fd fd9e 	bl	8012d68 <HAL_RCC_GetPCLK2Freq>
 801522c:	6378      	str	r0, [r7, #52]	@ 0x34
        break;
 801522e:	e1eb      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>

      case RCC_SPI1CLKSOURCE_SYSCLK:

        frequency = HAL_RCC_GetSysClockFreq();
 8015230:	f7fd fc6a 	bl	8012b08 <HAL_RCC_GetSysClockFreq>
 8015234:	6378      	str	r0, [r7, #52]	@ 0x34
        break;
 8015236:	e1e7      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>

      case RCC_SPI1CLKSOURCE_HSI:

        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
 8015238:	4b18      	ldr	r3, [pc, #96]	@ (801529c <HAL_RCCEx_GetPeriphCLKFreq+0x103c>)
 801523a:	681b      	ldr	r3, [r3, #0]
 801523c:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8015240:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 8015244:	d102      	bne.n	801524c <HAL_RCCEx_GetPeriphCLKFreq+0xfec>
        {
          frequency = HSI_VALUE;
 8015246:	4b17      	ldr	r3, [pc, #92]	@ (80152a4 <HAL_RCCEx_GetPeriphCLKFreq+0x1044>)
 8015248:	637b      	str	r3, [r7, #52]	@ 0x34
        }
        else
        {
          frequency = 0U;
        }
        break;
 801524a:	e1dd      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
          frequency = 0U;
 801524c:	2300      	movs	r3, #0
 801524e:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8015250:	e1da      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>

      case RCC_SPI1CLKSOURCE_MSIK:

        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 8015252:	4b12      	ldr	r3, [pc, #72]	@ (801529c <HAL_RCCEx_GetPeriphCLKFreq+0x103c>)
 8015254:	681b      	ldr	r3, [r3, #0]
 8015256:	f003 0320 	and.w	r3, r3, #32
 801525a:	2b20      	cmp	r3, #32
 801525c:	d117      	bne.n	801528e <HAL_RCCEx_GetPeriphCLKFreq+0x102e>
        {
          frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 801525e:	4b0f      	ldr	r3, [pc, #60]	@ (801529c <HAL_RCCEx_GetPeriphCLKFreq+0x103c>)
 8015260:	689b      	ldr	r3, [r3, #8]
 8015262:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 8015266:	2b00      	cmp	r3, #0
 8015268:	d005      	beq.n	8015276 <HAL_RCCEx_GetPeriphCLKFreq+0x1016>
 801526a:	4b0c      	ldr	r3, [pc, #48]	@ (801529c <HAL_RCCEx_GetPeriphCLKFreq+0x103c>)
 801526c:	689b      	ldr	r3, [r3, #8]
 801526e:	0e1b      	lsrs	r3, r3, #24
 8015270:	f003 030f 	and.w	r3, r3, #15
 8015274:	e006      	b.n	8015284 <HAL_RCCEx_GetPeriphCLKFreq+0x1024>
 8015276:	4b09      	ldr	r3, [pc, #36]	@ (801529c <HAL_RCCEx_GetPeriphCLKFreq+0x103c>)
 8015278:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 801527c:	041b      	lsls	r3, r3, #16
 801527e:	0e1b      	lsrs	r3, r3, #24
 8015280:	f003 030f 	and.w	r3, r3, #15
 8015284:	4a06      	ldr	r2, [pc, #24]	@ (80152a0 <HAL_RCCEx_GetPeriphCLKFreq+0x1040>)
 8015286:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801528a:	637b      	str	r3, [r7, #52]	@ 0x34
        }
        else
        {
          frequency = 0U;
        }
        break;
 801528c:	e1bc      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
          frequency = 0U;
 801528e:	2300      	movs	r3, #0
 8015290:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8015292:	e1b9      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>

      default:

        frequency = 0U;
 8015294:	2300      	movs	r3, #0
 8015296:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8015298:	e1b6      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
 801529a:	bf00      	nop
 801529c:	46020c00 	.word	0x46020c00
 80152a0:	0802a4e0 	.word	0x0802a4e0
 80152a4:	00f42400 	.word	0x00f42400
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_SPI2)
 80152a8:	e9d7 2300 	ldrd	r2, r3, [r7]
 80152ac:	f102 417f 	add.w	r1, r2, #4278190080	@ 0xff000000
 80152b0:	430b      	orrs	r3, r1
 80152b2:	d156      	bne.n	8015362 <HAL_RCCEx_GetPeriphCLKFreq+0x1102>
  {
    /* Get the current SPI2 kernel source */
    srcclk = __HAL_RCC_GET_SPI2_SOURCE();
 80152b4:	4ba5      	ldr	r3, [pc, #660]	@ (801554c <HAL_RCCEx_GetPeriphCLKFreq+0x12ec>)
 80152b6:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 80152ba:	f403 3340 	and.w	r3, r3, #196608	@ 0x30000
 80152be:	633b      	str	r3, [r7, #48]	@ 0x30
    switch (srcclk)
 80152c0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80152c2:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
 80152c6:	d028      	beq.n	801531a <HAL_RCCEx_GetPeriphCLKFreq+0x10ba>
 80152c8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80152ca:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
 80152ce:	d845      	bhi.n	801535c <HAL_RCCEx_GetPeriphCLKFreq+0x10fc>
 80152d0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80152d2:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 80152d6:	d013      	beq.n	8015300 <HAL_RCCEx_GetPeriphCLKFreq+0x10a0>
 80152d8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80152da:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 80152de:	d83d      	bhi.n	801535c <HAL_RCCEx_GetPeriphCLKFreq+0x10fc>
 80152e0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80152e2:	2b00      	cmp	r3, #0
 80152e4:	d004      	beq.n	80152f0 <HAL_RCCEx_GetPeriphCLKFreq+0x1090>
 80152e6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80152e8:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 80152ec:	d004      	beq.n	80152f8 <HAL_RCCEx_GetPeriphCLKFreq+0x1098>
 80152ee:	e035      	b.n	801535c <HAL_RCCEx_GetPeriphCLKFreq+0x10fc>
    {
      case RCC_SPI2CLKSOURCE_PCLK1:

        frequency = HAL_RCC_GetPCLK1Freq();
 80152f0:	f7fd fd26 	bl	8012d40 <HAL_RCC_GetPCLK1Freq>
 80152f4:	6378      	str	r0, [r7, #52]	@ 0x34
        break;
 80152f6:	e187      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>

      case RCC_SPI2CLKSOURCE_SYSCLK:

        frequency = HAL_RCC_GetSysClockFreq();
 80152f8:	f7fd fc06 	bl	8012b08 <HAL_RCC_GetSysClockFreq>
 80152fc:	6378      	str	r0, [r7, #52]	@ 0x34
        break;
 80152fe:	e183      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>

      case RCC_SPI2CLKSOURCE_HSI:

        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
 8015300:	4b92      	ldr	r3, [pc, #584]	@ (801554c <HAL_RCCEx_GetPeriphCLKFreq+0x12ec>)
 8015302:	681b      	ldr	r3, [r3, #0]
 8015304:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8015308:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 801530c:	d102      	bne.n	8015314 <HAL_RCCEx_GetPeriphCLKFreq+0x10b4>
        {
          frequency = HSI_VALUE;
 801530e:	4b90      	ldr	r3, [pc, #576]	@ (8015550 <HAL_RCCEx_GetPeriphCLKFreq+0x12f0>)
 8015310:	637b      	str	r3, [r7, #52]	@ 0x34
        }
        else
        {
          frequency = 0U;
        }
        break;
 8015312:	e179      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
          frequency = 0U;
 8015314:	2300      	movs	r3, #0
 8015316:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8015318:	e176      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>

      case RCC_SPI2CLKSOURCE_MSIK:

        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 801531a:	4b8c      	ldr	r3, [pc, #560]	@ (801554c <HAL_RCCEx_GetPeriphCLKFreq+0x12ec>)
 801531c:	681b      	ldr	r3, [r3, #0]
 801531e:	f003 0320 	and.w	r3, r3, #32
 8015322:	2b20      	cmp	r3, #32
 8015324:	d117      	bne.n	8015356 <HAL_RCCEx_GetPeriphCLKFreq+0x10f6>
        {
          frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 8015326:	4b89      	ldr	r3, [pc, #548]	@ (801554c <HAL_RCCEx_GetPeriphCLKFreq+0x12ec>)
 8015328:	689b      	ldr	r3, [r3, #8]
 801532a:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 801532e:	2b00      	cmp	r3, #0
 8015330:	d005      	beq.n	801533e <HAL_RCCEx_GetPeriphCLKFreq+0x10de>
 8015332:	4b86      	ldr	r3, [pc, #536]	@ (801554c <HAL_RCCEx_GetPeriphCLKFreq+0x12ec>)
 8015334:	689b      	ldr	r3, [r3, #8]
 8015336:	0e1b      	lsrs	r3, r3, #24
 8015338:	f003 030f 	and.w	r3, r3, #15
 801533c:	e006      	b.n	801534c <HAL_RCCEx_GetPeriphCLKFreq+0x10ec>
 801533e:	4b83      	ldr	r3, [pc, #524]	@ (801554c <HAL_RCCEx_GetPeriphCLKFreq+0x12ec>)
 8015340:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 8015344:	041b      	lsls	r3, r3, #16
 8015346:	0e1b      	lsrs	r3, r3, #24
 8015348:	f003 030f 	and.w	r3, r3, #15
 801534c:	4a81      	ldr	r2, [pc, #516]	@ (8015554 <HAL_RCCEx_GetPeriphCLKFreq+0x12f4>)
 801534e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8015352:	637b      	str	r3, [r7, #52]	@ 0x34
        }
        else
        {
          frequency = 0U;
        }
        break;
 8015354:	e158      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
          frequency = 0U;
 8015356:	2300      	movs	r3, #0
 8015358:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 801535a:	e155      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>

      default:

        frequency = 0U;
 801535c:	2300      	movs	r3, #0
 801535e:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8015360:	e152      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_SPI3)
 8015362:	e9d7 2300 	ldrd	r2, r3, [r7]
 8015366:	f102 417e 	add.w	r1, r2, #4261412864	@ 0xfe000000
 801536a:	430b      	orrs	r3, r1
 801536c:	d177      	bne.n	801545e <HAL_RCCEx_GetPeriphCLKFreq+0x11fe>
  {
    /* Get the current SPI3 kernel source */
    srcclk = __HAL_RCC_GET_SPI3_SOURCE();
 801536e:	4b77      	ldr	r3, [pc, #476]	@ (801554c <HAL_RCCEx_GetPeriphCLKFreq+0x12ec>)
 8015370:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 8015374:	f003 0318 	and.w	r3, r3, #24
 8015378:	633b      	str	r3, [r7, #48]	@ 0x30
    switch (srcclk)
 801537a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801537c:	2b18      	cmp	r3, #24
 801537e:	d86b      	bhi.n	8015458 <HAL_RCCEx_GetPeriphCLKFreq+0x11f8>
 8015380:	a201      	add	r2, pc, #4	@ (adr r2, 8015388 <HAL_RCCEx_GetPeriphCLKFreq+0x1128>)
 8015382:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8015386:	bf00      	nop
 8015388:	080153ed 	.word	0x080153ed
 801538c:	08015459 	.word	0x08015459
 8015390:	08015459 	.word	0x08015459
 8015394:	08015459 	.word	0x08015459
 8015398:	08015459 	.word	0x08015459
 801539c:	08015459 	.word	0x08015459
 80153a0:	08015459 	.word	0x08015459
 80153a4:	08015459 	.word	0x08015459
 80153a8:	080153f5 	.word	0x080153f5
 80153ac:	08015459 	.word	0x08015459
 80153b0:	08015459 	.word	0x08015459
 80153b4:	08015459 	.word	0x08015459
 80153b8:	08015459 	.word	0x08015459
 80153bc:	08015459 	.word	0x08015459
 80153c0:	08015459 	.word	0x08015459
 80153c4:	08015459 	.word	0x08015459
 80153c8:	080153fd 	.word	0x080153fd
 80153cc:	08015459 	.word	0x08015459
 80153d0:	08015459 	.word	0x08015459
 80153d4:	08015459 	.word	0x08015459
 80153d8:	08015459 	.word	0x08015459
 80153dc:	08015459 	.word	0x08015459
 80153e0:	08015459 	.word	0x08015459
 80153e4:	08015459 	.word	0x08015459
 80153e8:	08015417 	.word	0x08015417
    {
      case RCC_SPI3CLKSOURCE_PCLK3:

        frequency = HAL_RCC_GetPCLK3Freq();
 80153ec:	f7fd fcd0 	bl	8012d90 <HAL_RCC_GetPCLK3Freq>
 80153f0:	6378      	str	r0, [r7, #52]	@ 0x34
        break;
 80153f2:	e109      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>

      case RCC_SPI3CLKSOURCE_SYSCLK:

        frequency = HAL_RCC_GetSysClockFreq();
 80153f4:	f7fd fb88 	bl	8012b08 <HAL_RCC_GetSysClockFreq>
 80153f8:	6378      	str	r0, [r7, #52]	@ 0x34
        break;
 80153fa:	e105      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>

      case RCC_SPI3CLKSOURCE_HSI:

        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
 80153fc:	4b53      	ldr	r3, [pc, #332]	@ (801554c <HAL_RCCEx_GetPeriphCLKFreq+0x12ec>)
 80153fe:	681b      	ldr	r3, [r3, #0]
 8015400:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8015404:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 8015408:	d102      	bne.n	8015410 <HAL_RCCEx_GetPeriphCLKFreq+0x11b0>
        {
          frequency = HSI_VALUE;
 801540a:	4b51      	ldr	r3, [pc, #324]	@ (8015550 <HAL_RCCEx_GetPeriphCLKFreq+0x12f0>)
 801540c:	637b      	str	r3, [r7, #52]	@ 0x34
        }
        else
        {
          frequency = 0U;
        }
        break;
 801540e:	e0fb      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
          frequency = 0U;
 8015410:	2300      	movs	r3, #0
 8015412:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8015414:	e0f8      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>

      case RCC_SPI3CLKSOURCE_MSIK:

        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 8015416:	4b4d      	ldr	r3, [pc, #308]	@ (801554c <HAL_RCCEx_GetPeriphCLKFreq+0x12ec>)
 8015418:	681b      	ldr	r3, [r3, #0]
 801541a:	f003 0320 	and.w	r3, r3, #32
 801541e:	2b20      	cmp	r3, #32
 8015420:	d117      	bne.n	8015452 <HAL_RCCEx_GetPeriphCLKFreq+0x11f2>
        {
          frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 8015422:	4b4a      	ldr	r3, [pc, #296]	@ (801554c <HAL_RCCEx_GetPeriphCLKFreq+0x12ec>)
 8015424:	689b      	ldr	r3, [r3, #8]
 8015426:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 801542a:	2b00      	cmp	r3, #0
 801542c:	d005      	beq.n	801543a <HAL_RCCEx_GetPeriphCLKFreq+0x11da>
 801542e:	4b47      	ldr	r3, [pc, #284]	@ (801554c <HAL_RCCEx_GetPeriphCLKFreq+0x12ec>)
 8015430:	689b      	ldr	r3, [r3, #8]
 8015432:	0e1b      	lsrs	r3, r3, #24
 8015434:	f003 030f 	and.w	r3, r3, #15
 8015438:	e006      	b.n	8015448 <HAL_RCCEx_GetPeriphCLKFreq+0x11e8>
 801543a:	4b44      	ldr	r3, [pc, #272]	@ (801554c <HAL_RCCEx_GetPeriphCLKFreq+0x12ec>)
 801543c:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 8015440:	041b      	lsls	r3, r3, #16
 8015442:	0e1b      	lsrs	r3, r3, #24
 8015444:	f003 030f 	and.w	r3, r3, #15
 8015448:	4a42      	ldr	r2, [pc, #264]	@ (8015554 <HAL_RCCEx_GetPeriphCLKFreq+0x12f4>)
 801544a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801544e:	637b      	str	r3, [r7, #52]	@ 0x34
        }
        else
        {
          frequency = 0U;
        }
        break;
 8015450:	e0da      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
          frequency = 0U;
 8015452:	2300      	movs	r3, #0
 8015454:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8015456:	e0d7      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>

      default:

        frequency = 0U;
 8015458:	2300      	movs	r3, #0
 801545a:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 801545c:	e0d4      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_OSPI)
 801545e:	e9d7 2300 	ldrd	r2, r3, [r7]
 8015462:	f102 417c 	add.w	r1, r2, #4227858432	@ 0xfc000000
 8015466:	430b      	orrs	r3, r1
 8015468:	d155      	bne.n	8015516 <HAL_RCCEx_GetPeriphCLKFreq+0x12b6>
  {
    /* Get the current OSPI kernel source */
    srcclk = __HAL_RCC_GET_OSPI_SOURCE();
 801546a:	4b38      	ldr	r3, [pc, #224]	@ (801554c <HAL_RCCEx_GetPeriphCLKFreq+0x12ec>)
 801546c:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
 8015470:	f403 1340 	and.w	r3, r3, #3145728	@ 0x300000
 8015474:	633b      	str	r3, [r7, #48]	@ 0x30

    switch (srcclk)
 8015476:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8015478:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
 801547c:	d013      	beq.n	80154a6 <HAL_RCCEx_GetPeriphCLKFreq+0x1246>
 801547e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8015480:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
 8015484:	d844      	bhi.n	8015510 <HAL_RCCEx_GetPeriphCLKFreq+0x12b0>
 8015486:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8015488:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 801548c:	d013      	beq.n	80154b6 <HAL_RCCEx_GetPeriphCLKFreq+0x1256>
 801548e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8015490:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 8015494:	d83c      	bhi.n	8015510 <HAL_RCCEx_GetPeriphCLKFreq+0x12b0>
 8015496:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8015498:	2b00      	cmp	r3, #0
 801549a:	d014      	beq.n	80154c6 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
 801549c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801549e:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 80154a2:	d014      	beq.n	80154ce <HAL_RCCEx_GetPeriphCLKFreq+0x126e>
 80154a4:	e034      	b.n	8015510 <HAL_RCCEx_GetPeriphCLKFreq+0x12b0>
    {
      case RCC_OSPICLKSOURCE_PLL2:

        HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 80154a6:	f107 0318 	add.w	r3, r7, #24
 80154aa:	4618      	mov	r0, r3
 80154ac:	f7fe fc24 	bl	8013cf8 <HAL_RCCEx_GetPLL2ClockFreq>
        frequency = pll2_clocks.PLL2_Q_Frequency;
 80154b0:	69fb      	ldr	r3, [r7, #28]
 80154b2:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 80154b4:	e0a8      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>

      case RCC_OSPICLKSOURCE_PLL1:

        HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 80154b6:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 80154ba:	4618      	mov	r0, r3
 80154bc:	f7fe fac2 	bl	8013a44 <HAL_RCCEx_GetPLL1ClockFreq>
        frequency = pll1_clocks.PLL1_Q_Frequency;
 80154c0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80154c2:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 80154c4:	e0a0      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>

      case RCC_OSPICLKSOURCE_SYSCLK:

        frequency = HAL_RCC_GetSysClockFreq();
 80154c6:	f7fd fb1f 	bl	8012b08 <HAL_RCC_GetSysClockFreq>
 80154ca:	6378      	str	r0, [r7, #52]	@ 0x34
        break;
 80154cc:	e09c      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>

      case RCC_OSPICLKSOURCE_MSIK:

        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 80154ce:	4b1f      	ldr	r3, [pc, #124]	@ (801554c <HAL_RCCEx_GetPeriphCLKFreq+0x12ec>)
 80154d0:	681b      	ldr	r3, [r3, #0]
 80154d2:	f003 0320 	and.w	r3, r3, #32
 80154d6:	2b20      	cmp	r3, #32
 80154d8:	d117      	bne.n	801550a <HAL_RCCEx_GetPeriphCLKFreq+0x12aa>
        {
          frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 80154da:	4b1c      	ldr	r3, [pc, #112]	@ (801554c <HAL_RCCEx_GetPeriphCLKFreq+0x12ec>)
 80154dc:	689b      	ldr	r3, [r3, #8]
 80154de:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 80154e2:	2b00      	cmp	r3, #0
 80154e4:	d005      	beq.n	80154f2 <HAL_RCCEx_GetPeriphCLKFreq+0x1292>
 80154e6:	4b19      	ldr	r3, [pc, #100]	@ (801554c <HAL_RCCEx_GetPeriphCLKFreq+0x12ec>)
 80154e8:	689b      	ldr	r3, [r3, #8]
 80154ea:	0e1b      	lsrs	r3, r3, #24
 80154ec:	f003 030f 	and.w	r3, r3, #15
 80154f0:	e006      	b.n	8015500 <HAL_RCCEx_GetPeriphCLKFreq+0x12a0>
 80154f2:	4b16      	ldr	r3, [pc, #88]	@ (801554c <HAL_RCCEx_GetPeriphCLKFreq+0x12ec>)
 80154f4:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 80154f8:	041b      	lsls	r3, r3, #16
 80154fa:	0e1b      	lsrs	r3, r3, #24
 80154fc:	f003 030f 	and.w	r3, r3, #15
 8015500:	4a14      	ldr	r2, [pc, #80]	@ (8015554 <HAL_RCCEx_GetPeriphCLKFreq+0x12f4>)
 8015502:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8015506:	637b      	str	r3, [r7, #52]	@ 0x34
        }
        else
        {
          frequency = 0U;
        }
        break;
 8015508:	e07e      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
          frequency = 0U;
 801550a:	2300      	movs	r3, #0
 801550c:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 801550e:	e07b      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>

      default:

        frequency = 0U;
 8015510:	2300      	movs	r3, #0
 8015512:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8015514:	e078      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
        frequency = 0U;
        break;
    }
  }
#endif /* defined(HSPI1) */
  else if (PeriphClk == RCC_PERIPHCLK_DAC1)
 8015516:	e9d7 2300 	ldrd	r2, r3, [r7]
 801551a:	f102 4170 	add.w	r1, r2, #4026531840	@ 0xf0000000
 801551e:	430b      	orrs	r3, r1
 8015520:	d138      	bne.n	8015594 <HAL_RCCEx_GetPeriphCLKFreq+0x1334>
  {
    /* Get the current DAC1 kernel source */
    srcclk = __HAL_RCC_GET_DAC1_SOURCE();
 8015522:	4b0a      	ldr	r3, [pc, #40]	@ (801554c <HAL_RCCEx_GetPeriphCLKFreq+0x12ec>)
 8015524:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 8015528:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 801552c:	633b      	str	r3, [r7, #48]	@ 0x30

    /* Check if LSE is ready and if DAC1 clock selection is LSE */
    if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_DAC1CLKSOURCE_LSE))
 801552e:	4b07      	ldr	r3, [pc, #28]	@ (801554c <HAL_RCCEx_GetPeriphCLKFreq+0x12ec>)
 8015530:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8015534:	f003 0302 	and.w	r3, r3, #2
 8015538:	2b02      	cmp	r3, #2
 801553a:	d10d      	bne.n	8015558 <HAL_RCCEx_GetPeriphCLKFreq+0x12f8>
 801553c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801553e:	2b00      	cmp	r3, #0
 8015540:	d10a      	bne.n	8015558 <HAL_RCCEx_GetPeriphCLKFreq+0x12f8>
    {
      frequency = LSE_VALUE;
 8015542:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 8015546:	637b      	str	r3, [r7, #52]	@ 0x34
 8015548:	e05e      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
 801554a:	bf00      	nop
 801554c:	46020c00 	.word	0x46020c00
 8015550:	00f42400 	.word	0x00f42400
 8015554:	0802a4e0 	.word	0x0802a4e0
    }
    /* Check if LSI is ready and if DAC1 clock selection is LSI */
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIRDY)) && (srcclk == RCC_DAC1CLKSOURCE_LSI))
 8015558:	4b2e      	ldr	r3, [pc, #184]	@ (8015614 <HAL_RCCEx_GetPeriphCLKFreq+0x13b4>)
 801555a:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 801555e:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8015562:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 8015566:	d112      	bne.n	801558e <HAL_RCCEx_GetPeriphCLKFreq+0x132e>
 8015568:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801556a:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 801556e:	d10e      	bne.n	801558e <HAL_RCCEx_GetPeriphCLKFreq+0x132e>
    {
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIPREDIV))
 8015570:	4b28      	ldr	r3, [pc, #160]	@ (8015614 <HAL_RCCEx_GetPeriphCLKFreq+0x13b4>)
 8015572:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8015576:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 801557a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 801557e:	d102      	bne.n	8015586 <HAL_RCCEx_GetPeriphCLKFreq+0x1326>
      {
        frequency = LSI_VALUE / 128U;
 8015580:	23fa      	movs	r3, #250	@ 0xfa
 8015582:	637b      	str	r3, [r7, #52]	@ 0x34
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIPREDIV))
 8015584:	e040      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
      }
      else
      {
        frequency = LSI_VALUE;
 8015586:	f44f 43fa 	mov.w	r3, #32000	@ 0x7d00
 801558a:	637b      	str	r3, [r7, #52]	@ 0x34
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIPREDIV))
 801558c:	e03c      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
      }
    }
    /* Clock not enabled for DAC1*/
    else
    {
      frequency = 0U;
 801558e:	2300      	movs	r3, #0
 8015590:	637b      	str	r3, [r7, #52]	@ 0x34
 8015592:	e039      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }

  }
  else if (PeriphClk == RCC_PERIPHCLK_RNG)
 8015594:	e9d7 2300 	ldrd	r2, r3, [r7]
 8015598:	f5a2 2100 	sub.w	r1, r2, #524288	@ 0x80000
 801559c:	430b      	orrs	r3, r1
 801559e:	d131      	bne.n	8015604 <HAL_RCCEx_GetPeriphCLKFreq+0x13a4>
  {
    /* Get the current RNG kernel source */
    srcclk = __HAL_RCC_GET_RNG_SOURCE();
 80155a0:	4b1c      	ldr	r3, [pc, #112]	@ (8015614 <HAL_RCCEx_GetPeriphCLKFreq+0x13b4>)
 80155a2:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
 80155a6:	f403 5340 	and.w	r3, r3, #12288	@ 0x3000
 80155aa:	633b      	str	r3, [r7, #48]	@ 0x30

    /* Check if HSI48 is ready and if RNG clock selection is HSI48 */
    if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSI48RDY)) && (srcclk == RCC_RNGCLKSOURCE_HSI48))
 80155ac:	4b19      	ldr	r3, [pc, #100]	@ (8015614 <HAL_RCCEx_GetPeriphCLKFreq+0x13b4>)
 80155ae:	681b      	ldr	r3, [r3, #0]
 80155b0:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 80155b4:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 80155b8:	d105      	bne.n	80155c6 <HAL_RCCEx_GetPeriphCLKFreq+0x1366>
 80155ba:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80155bc:	2b00      	cmp	r3, #0
 80155be:	d102      	bne.n	80155c6 <HAL_RCCEx_GetPeriphCLKFreq+0x1366>
    {
      frequency = HSI48_VALUE;
 80155c0:	4b15      	ldr	r3, [pc, #84]	@ (8015618 <HAL_RCCEx_GetPeriphCLKFreq+0x13b8>)
 80155c2:	637b      	str	r3, [r7, #52]	@ 0x34
 80155c4:	e020      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }

    /* Check if HSI48 is ready and if RNG clock selection is HSI48_DIV2 */
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSI48RDY)) && (srcclk == RCC_RNGCLKSOURCE_HSI48_DIV2))
 80155c6:	4b13      	ldr	r3, [pc, #76]	@ (8015614 <HAL_RCCEx_GetPeriphCLKFreq+0x13b4>)
 80155c8:	681b      	ldr	r3, [r3, #0]
 80155ca:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 80155ce:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 80155d2:	d106      	bne.n	80155e2 <HAL_RCCEx_GetPeriphCLKFreq+0x1382>
 80155d4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80155d6:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 80155da:	d102      	bne.n	80155e2 <HAL_RCCEx_GetPeriphCLKFreq+0x1382>
    {
      frequency = HSI48_VALUE >> 1U ;
 80155dc:	4b0f      	ldr	r3, [pc, #60]	@ (801561c <HAL_RCCEx_GetPeriphCLKFreq+0x13bc>)
 80155de:	637b      	str	r3, [r7, #52]	@ 0x34
 80155e0:	e012      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }

    /* Check if HSI is ready and if RNG clock selection is HSI */
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_RNGCLKSOURCE_HSI))
 80155e2:	4b0c      	ldr	r3, [pc, #48]	@ (8015614 <HAL_RCCEx_GetPeriphCLKFreq+0x13b4>)
 80155e4:	681b      	ldr	r3, [r3, #0]
 80155e6:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 80155ea:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 80155ee:	d106      	bne.n	80155fe <HAL_RCCEx_GetPeriphCLKFreq+0x139e>
 80155f0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80155f2:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 80155f6:	d102      	bne.n	80155fe <HAL_RCCEx_GetPeriphCLKFreq+0x139e>
    {
      frequency = HSI_VALUE;
 80155f8:	4b09      	ldr	r3, [pc, #36]	@ (8015620 <HAL_RCCEx_GetPeriphCLKFreq+0x13c0>)
 80155fa:	637b      	str	r3, [r7, #52]	@ 0x34
 80155fc:	e004      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
    }
    /* Clock not enabled for RNG */
    else
    {
      frequency = 0U;
 80155fe:	2300      	movs	r3, #0
 8015600:	637b      	str	r3, [r7, #52]	@ 0x34
 8015602:	e001      	b.n	8015608 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
  }
#endif /* defined(USB_OTG_HS) */

  else
  {
    frequency = 0;
 8015604:	2300      	movs	r3, #0
 8015606:	637b      	str	r3, [r7, #52]	@ 0x34
  }
  return (frequency);
 8015608:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
}
 801560a:	4618      	mov	r0, r3
 801560c:	3738      	adds	r7, #56	@ 0x38
 801560e:	46bd      	mov	sp, r7
 8015610:	bd80      	pop	{r7, pc}
 8015612:	bf00      	nop
 8015614:	46020c00 	.word	0x46020c00
 8015618:	02dc6c00 	.word	0x02dc6c00
 801561c:	016e3600 	.word	0x016e3600
 8015620:	00f42400 	.word	0x00f42400

08015624 <RCCEx_PLL2_Config>:
  * @note   PLL2 is temporary disabled to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLL2_Config(const RCC_PLL2InitTypeDef *pll2)
{
 8015624:	b580      	push	{r7, lr}
 8015626:	b084      	sub	sp, #16
 8015628:	af00      	add	r7, sp, #0
 801562a:	6078      	str	r0, [r7, #4]
  assert_param(IS_RCC_PLLP_VALUE(pll2->PLL2P));
  assert_param(IS_RCC_PLLQ_VALUE(pll2->PLL2Q));
  assert_param(IS_RCC_PLLR_VALUE(pll2->PLL2R));

  /* Disable  PLL2 */
  __HAL_RCC_PLL2_DISABLE();
 801562c:	4b47      	ldr	r3, [pc, #284]	@ (801574c <RCCEx_PLL2_Config+0x128>)
 801562e:	681b      	ldr	r3, [r3, #0]
 8015630:	4a46      	ldr	r2, [pc, #280]	@ (801574c <RCCEx_PLL2_Config+0x128>)
 8015632:	f023 6380 	bic.w	r3, r3, #67108864	@ 0x4000000
 8015636:	6013      	str	r3, [r2, #0]

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 8015638:	f7f8 fa12 	bl	800da60 <HAL_GetTick>
 801563c:	60f8      	str	r0, [r7, #12]

  /* Wait till PLL is ready */
  while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != 0U)
 801563e:	e008      	b.n	8015652 <RCCEx_PLL2_Config+0x2e>
  {
    if ((HAL_GetTick() - tickstart) > PLL2_TIMEOUT_VALUE)
 8015640:	f7f8 fa0e 	bl	800da60 <HAL_GetTick>
 8015644:	4602      	mov	r2, r0
 8015646:	68fb      	ldr	r3, [r7, #12]
 8015648:	1ad3      	subs	r3, r2, r3
 801564a:	2b02      	cmp	r3, #2
 801564c:	d901      	bls.n	8015652 <RCCEx_PLL2_Config+0x2e>
    {
      return HAL_TIMEOUT;
 801564e:	2303      	movs	r3, #3
 8015650:	e077      	b.n	8015742 <RCCEx_PLL2_Config+0x11e>
  while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != 0U)
 8015652:	4b3e      	ldr	r3, [pc, #248]	@ (801574c <RCCEx_PLL2_Config+0x128>)
 8015654:	681b      	ldr	r3, [r3, #0]
 8015656:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 801565a:	2b00      	cmp	r3, #0
 801565c:	d1f0      	bne.n	8015640 <RCCEx_PLL2_Config+0x1c>
    }
  }

  /* Configure PLL2 multiplication and division factors */
  __HAL_RCC_PLL2_CONFIG(pll2->PLL2Source,
 801565e:	4b3b      	ldr	r3, [pc, #236]	@ (801574c <RCCEx_PLL2_Config+0x128>)
 8015660:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8015662:	f423 6370 	bic.w	r3, r3, #3840	@ 0xf00
 8015666:	f023 0303 	bic.w	r3, r3, #3
 801566a:	687a      	ldr	r2, [r7, #4]
 801566c:	6811      	ldr	r1, [r2, #0]
 801566e:	687a      	ldr	r2, [r7, #4]
 8015670:	6852      	ldr	r2, [r2, #4]
 8015672:	3a01      	subs	r2, #1
 8015674:	0212      	lsls	r2, r2, #8
 8015676:	430a      	orrs	r2, r1
 8015678:	4934      	ldr	r1, [pc, #208]	@ (801574c <RCCEx_PLL2_Config+0x128>)
 801567a:	4313      	orrs	r3, r2
 801567c:	62cb      	str	r3, [r1, #44]	@ 0x2c
 801567e:	4b33      	ldr	r3, [pc, #204]	@ (801574c <RCCEx_PLL2_Config+0x128>)
 8015680:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 8015682:	4b33      	ldr	r3, [pc, #204]	@ (8015750 <RCCEx_PLL2_Config+0x12c>)
 8015684:	4013      	ands	r3, r2
 8015686:	687a      	ldr	r2, [r7, #4]
 8015688:	6892      	ldr	r2, [r2, #8]
 801568a:	3a01      	subs	r2, #1
 801568c:	f3c2 0108 	ubfx	r1, r2, #0, #9
 8015690:	687a      	ldr	r2, [r7, #4]
 8015692:	68d2      	ldr	r2, [r2, #12]
 8015694:	3a01      	subs	r2, #1
 8015696:	0252      	lsls	r2, r2, #9
 8015698:	b292      	uxth	r2, r2
 801569a:	4311      	orrs	r1, r2
 801569c:	687a      	ldr	r2, [r7, #4]
 801569e:	6912      	ldr	r2, [r2, #16]
 80156a0:	3a01      	subs	r2, #1
 80156a2:	0412      	lsls	r2, r2, #16
 80156a4:	f402 02fe 	and.w	r2, r2, #8323072	@ 0x7f0000
 80156a8:	4311      	orrs	r1, r2
 80156aa:	687a      	ldr	r2, [r7, #4]
 80156ac:	6952      	ldr	r2, [r2, #20]
 80156ae:	3a01      	subs	r2, #1
 80156b0:	0612      	lsls	r2, r2, #24
 80156b2:	f002 42fe 	and.w	r2, r2, #2130706432	@ 0x7f000000
 80156b6:	430a      	orrs	r2, r1
 80156b8:	4924      	ldr	r1, [pc, #144]	@ (801574c <RCCEx_PLL2_Config+0x128>)
 80156ba:	4313      	orrs	r3, r2
 80156bc:	63cb      	str	r3, [r1, #60]	@ 0x3c
                        pll2->PLL2P,
                        pll2->PLL2Q,
                        pll2->PLL2R);

  /* Select PLL2 input reference frequency range: VCI */
  __HAL_RCC_PLL2_VCIRANGE(pll2->PLL2RGE);
 80156be:	4b23      	ldr	r3, [pc, #140]	@ (801574c <RCCEx_PLL2_Config+0x128>)
 80156c0:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80156c2:	f023 020c 	bic.w	r2, r3, #12
 80156c6:	687b      	ldr	r3, [r7, #4]
 80156c8:	699b      	ldr	r3, [r3, #24]
 80156ca:	4920      	ldr	r1, [pc, #128]	@ (801574c <RCCEx_PLL2_Config+0x128>)
 80156cc:	4313      	orrs	r3, r2
 80156ce:	62cb      	str	r3, [r1, #44]	@ 0x2c

  /* Configure the PLL2 Clock output(s) */
  __HAL_RCC_PLL2CLKOUT_ENABLE(pll2->PLL2ClockOut);
 80156d0:	4b1e      	ldr	r3, [pc, #120]	@ (801574c <RCCEx_PLL2_Config+0x128>)
 80156d2:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 80156d4:	687b      	ldr	r3, [r7, #4]
 80156d6:	6a1b      	ldr	r3, [r3, #32]
 80156d8:	491c      	ldr	r1, [pc, #112]	@ (801574c <RCCEx_PLL2_Config+0x128>)
 80156da:	4313      	orrs	r3, r2
 80156dc:	62cb      	str	r3, [r1, #44]	@ 0x2c

  /* Disable PLL2FRACN  */
  __HAL_RCC_PLL2FRACN_DISABLE();
 80156de:	4b1b      	ldr	r3, [pc, #108]	@ (801574c <RCCEx_PLL2_Config+0x128>)
 80156e0:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80156e2:	4a1a      	ldr	r2, [pc, #104]	@ (801574c <RCCEx_PLL2_Config+0x128>)
 80156e4:	f023 0310 	bic.w	r3, r3, #16
 80156e8:	62d3      	str	r3, [r2, #44]	@ 0x2c

  /* Configures PLL2 clock Fractional Part Of The Multiplication Factor */
  __HAL_RCC_PLL2FRACN_CONFIG(pll2->PLL2FRACN);
 80156ea:	4b18      	ldr	r3, [pc, #96]	@ (801574c <RCCEx_PLL2_Config+0x128>)
 80156ec:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80156ee:	f423 437f 	bic.w	r3, r3, #65280	@ 0xff00
 80156f2:	f023 03f8 	bic.w	r3, r3, #248	@ 0xf8
 80156f6:	687a      	ldr	r2, [r7, #4]
 80156f8:	69d2      	ldr	r2, [r2, #28]
 80156fa:	00d2      	lsls	r2, r2, #3
 80156fc:	4913      	ldr	r1, [pc, #76]	@ (801574c <RCCEx_PLL2_Config+0x128>)
 80156fe:	4313      	orrs	r3, r2
 8015700:	640b      	str	r3, [r1, #64]	@ 0x40

  /* Enable PLL2FRACN  */
  __HAL_RCC_PLL2FRACN_ENABLE();
 8015702:	4b12      	ldr	r3, [pc, #72]	@ (801574c <RCCEx_PLL2_Config+0x128>)
 8015704:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8015706:	4a11      	ldr	r2, [pc, #68]	@ (801574c <RCCEx_PLL2_Config+0x128>)
 8015708:	f043 0310 	orr.w	r3, r3, #16
 801570c:	62d3      	str	r3, [r2, #44]	@ 0x2c

  /* Enable  PLL2 */
  __HAL_RCC_PLL2_ENABLE();
 801570e:	4b0f      	ldr	r3, [pc, #60]	@ (801574c <RCCEx_PLL2_Config+0x128>)
 8015710:	681b      	ldr	r3, [r3, #0]
 8015712:	4a0e      	ldr	r2, [pc, #56]	@ (801574c <RCCEx_PLL2_Config+0x128>)
 8015714:	f043 6380 	orr.w	r3, r3, #67108864	@ 0x4000000
 8015718:	6013      	str	r3, [r2, #0]

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 801571a:	f7f8 f9a1 	bl	800da60 <HAL_GetTick>
 801571e:	60f8      	str	r0, [r7, #12]

  /* Wait till PLL2 is ready */
  while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == 0U)
 8015720:	e008      	b.n	8015734 <RCCEx_PLL2_Config+0x110>
  {
    if ((HAL_GetTick() - tickstart) > PLL2_TIMEOUT_VALUE)
 8015722:	f7f8 f99d 	bl	800da60 <HAL_GetTick>
 8015726:	4602      	mov	r2, r0
 8015728:	68fb      	ldr	r3, [r7, #12]
 801572a:	1ad3      	subs	r3, r2, r3
 801572c:	2b02      	cmp	r3, #2
 801572e:	d901      	bls.n	8015734 <RCCEx_PLL2_Config+0x110>
    {
      return HAL_TIMEOUT;
 8015730:	2303      	movs	r3, #3
 8015732:	e006      	b.n	8015742 <RCCEx_PLL2_Config+0x11e>
  while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == 0U)
 8015734:	4b05      	ldr	r3, [pc, #20]	@ (801574c <RCCEx_PLL2_Config+0x128>)
 8015736:	681b      	ldr	r3, [r3, #0]
 8015738:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 801573c:	2b00      	cmp	r3, #0
 801573e:	d0f0      	beq.n	8015722 <RCCEx_PLL2_Config+0xfe>
    }
  }
  return HAL_OK;
 8015740:	2300      	movs	r3, #0

}
 8015742:	4618      	mov	r0, r3
 8015744:	3710      	adds	r7, #16
 8015746:	46bd      	mov	sp, r7
 8015748:	bd80      	pop	{r7, pc}
 801574a:	bf00      	nop
 801574c:	46020c00 	.word	0x46020c00
 8015750:	80800000 	.word	0x80800000

08015754 <RCCEx_PLL3_Config>:
  *         contains the configuration parameters as well as VCI clock ranges.
  * @note   PLL3 is temporary disabled to apply new parameters
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLL3_Config(const RCC_PLL3InitTypeDef *pll3)
{
 8015754:	b580      	push	{r7, lr}
 8015756:	b084      	sub	sp, #16
 8015758:	af00      	add	r7, sp, #0
 801575a:	6078      	str	r0, [r7, #4]
  assert_param(IS_RCC_PLLP_VALUE(pll3->PLL3P));
  assert_param(IS_RCC_PLLQ_VALUE(pll3->PLL3Q));
  assert_param(IS_RCC_PLLR_VALUE(pll3->PLL3R));

  /* Disable  PLL3 */
  __HAL_RCC_PLL3_DISABLE();
 801575c:	4b47      	ldr	r3, [pc, #284]	@ (801587c <RCCEx_PLL3_Config+0x128>)
 801575e:	681b      	ldr	r3, [r3, #0]
 8015760:	4a46      	ldr	r2, [pc, #280]	@ (801587c <RCCEx_PLL3_Config+0x128>)
 8015762:	f023 5380 	bic.w	r3, r3, #268435456	@ 0x10000000
 8015766:	6013      	str	r3, [r2, #0]

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 8015768:	f7f8 f97a 	bl	800da60 <HAL_GetTick>
 801576c:	60f8      	str	r0, [r7, #12]

  /* Wait till PLL is ready */
  while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != 0U)
 801576e:	e008      	b.n	8015782 <RCCEx_PLL3_Config+0x2e>
  {
    if ((HAL_GetTick() - tickstart) > PLL3_TIMEOUT_VALUE)
 8015770:	f7f8 f976 	bl	800da60 <HAL_GetTick>
 8015774:	4602      	mov	r2, r0
 8015776:	68fb      	ldr	r3, [r7, #12]
 8015778:	1ad3      	subs	r3, r2, r3
 801577a:	2b02      	cmp	r3, #2
 801577c:	d901      	bls.n	8015782 <RCCEx_PLL3_Config+0x2e>
    {
      return HAL_TIMEOUT;
 801577e:	2303      	movs	r3, #3
 8015780:	e077      	b.n	8015872 <RCCEx_PLL3_Config+0x11e>
  while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != 0U)
 8015782:	4b3e      	ldr	r3, [pc, #248]	@ (801587c <RCCEx_PLL3_Config+0x128>)
 8015784:	681b      	ldr	r3, [r3, #0]
 8015786:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 801578a:	2b00      	cmp	r3, #0
 801578c:	d1f0      	bne.n	8015770 <RCCEx_PLL3_Config+0x1c>
    }
  }

  /* Configure PLL3 multiplication and division factors */
  __HAL_RCC_PLL3_CONFIG(pll3->PLL3Source,
 801578e:	4b3b      	ldr	r3, [pc, #236]	@ (801587c <RCCEx_PLL3_Config+0x128>)
 8015790:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8015792:	f423 6370 	bic.w	r3, r3, #3840	@ 0xf00
 8015796:	f023 0303 	bic.w	r3, r3, #3
 801579a:	687a      	ldr	r2, [r7, #4]
 801579c:	6811      	ldr	r1, [r2, #0]
 801579e:	687a      	ldr	r2, [r7, #4]
 80157a0:	6852      	ldr	r2, [r2, #4]
 80157a2:	3a01      	subs	r2, #1
 80157a4:	0212      	lsls	r2, r2, #8
 80157a6:	430a      	orrs	r2, r1
 80157a8:	4934      	ldr	r1, [pc, #208]	@ (801587c <RCCEx_PLL3_Config+0x128>)
 80157aa:	4313      	orrs	r3, r2
 80157ac:	630b      	str	r3, [r1, #48]	@ 0x30
 80157ae:	4b33      	ldr	r3, [pc, #204]	@ (801587c <RCCEx_PLL3_Config+0x128>)
 80157b0:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 80157b2:	4b33      	ldr	r3, [pc, #204]	@ (8015880 <RCCEx_PLL3_Config+0x12c>)
 80157b4:	4013      	ands	r3, r2
 80157b6:	687a      	ldr	r2, [r7, #4]
 80157b8:	6892      	ldr	r2, [r2, #8]
 80157ba:	3a01      	subs	r2, #1
 80157bc:	f3c2 0108 	ubfx	r1, r2, #0, #9
 80157c0:	687a      	ldr	r2, [r7, #4]
 80157c2:	68d2      	ldr	r2, [r2, #12]
 80157c4:	3a01      	subs	r2, #1
 80157c6:	0252      	lsls	r2, r2, #9
 80157c8:	b292      	uxth	r2, r2
 80157ca:	4311      	orrs	r1, r2
 80157cc:	687a      	ldr	r2, [r7, #4]
 80157ce:	6912      	ldr	r2, [r2, #16]
 80157d0:	3a01      	subs	r2, #1
 80157d2:	0412      	lsls	r2, r2, #16
 80157d4:	f402 02fe 	and.w	r2, r2, #8323072	@ 0x7f0000
 80157d8:	4311      	orrs	r1, r2
 80157da:	687a      	ldr	r2, [r7, #4]
 80157dc:	6952      	ldr	r2, [r2, #20]
 80157de:	3a01      	subs	r2, #1
 80157e0:	0612      	lsls	r2, r2, #24
 80157e2:	f002 42fe 	and.w	r2, r2, #2130706432	@ 0x7f000000
 80157e6:	430a      	orrs	r2, r1
 80157e8:	4924      	ldr	r1, [pc, #144]	@ (801587c <RCCEx_PLL3_Config+0x128>)
 80157ea:	4313      	orrs	r3, r2
 80157ec:	644b      	str	r3, [r1, #68]	@ 0x44
                        pll3->PLL3P,
                        pll3->PLL3Q,
                        pll3->PLL3R);

  /* Select PLL3 input reference frequency range: VCI */
  __HAL_RCC_PLL3_VCIRANGE(pll3->PLL3RGE);
 80157ee:	4b23      	ldr	r3, [pc, #140]	@ (801587c <RCCEx_PLL3_Config+0x128>)
 80157f0:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80157f2:	f023 020c 	bic.w	r2, r3, #12
 80157f6:	687b      	ldr	r3, [r7, #4]
 80157f8:	699b      	ldr	r3, [r3, #24]
 80157fa:	4920      	ldr	r1, [pc, #128]	@ (801587c <RCCEx_PLL3_Config+0x128>)
 80157fc:	4313      	orrs	r3, r2
 80157fe:	630b      	str	r3, [r1, #48]	@ 0x30

  /* Configure the PLL3 Clock output(s) */
  __HAL_RCC_PLL3CLKOUT_ENABLE(pll3->PLL3ClockOut);
 8015800:	4b1e      	ldr	r3, [pc, #120]	@ (801587c <RCCEx_PLL3_Config+0x128>)
 8015802:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8015804:	687b      	ldr	r3, [r7, #4]
 8015806:	6a1b      	ldr	r3, [r3, #32]
 8015808:	491c      	ldr	r1, [pc, #112]	@ (801587c <RCCEx_PLL3_Config+0x128>)
 801580a:	4313      	orrs	r3, r2
 801580c:	630b      	str	r3, [r1, #48]	@ 0x30

  /* Disable PLL3FRACN  */
  __HAL_RCC_PLL3FRACN_DISABLE();
 801580e:	4b1b      	ldr	r3, [pc, #108]	@ (801587c <RCCEx_PLL3_Config+0x128>)
 8015810:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8015812:	4a1a      	ldr	r2, [pc, #104]	@ (801587c <RCCEx_PLL3_Config+0x128>)
 8015814:	f023 0310 	bic.w	r3, r3, #16
 8015818:	6313      	str	r3, [r2, #48]	@ 0x30

  /* Configures PLL3 clock Fractional Part Of The Multiplication Factor */
  __HAL_RCC_PLL3FRACN_CONFIG(pll3->PLL3FRACN);
 801581a:	4b18      	ldr	r3, [pc, #96]	@ (801587c <RCCEx_PLL3_Config+0x128>)
 801581c:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 801581e:	f423 437f 	bic.w	r3, r3, #65280	@ 0xff00
 8015822:	f023 03f8 	bic.w	r3, r3, #248	@ 0xf8
 8015826:	687a      	ldr	r2, [r7, #4]
 8015828:	69d2      	ldr	r2, [r2, #28]
 801582a:	00d2      	lsls	r2, r2, #3
 801582c:	4913      	ldr	r1, [pc, #76]	@ (801587c <RCCEx_PLL3_Config+0x128>)
 801582e:	4313      	orrs	r3, r2
 8015830:	648b      	str	r3, [r1, #72]	@ 0x48

  /* Enable PLL3FRACN  */
  __HAL_RCC_PLL3FRACN_ENABLE();
 8015832:	4b12      	ldr	r3, [pc, #72]	@ (801587c <RCCEx_PLL3_Config+0x128>)
 8015834:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8015836:	4a11      	ldr	r2, [pc, #68]	@ (801587c <RCCEx_PLL3_Config+0x128>)
 8015838:	f043 0310 	orr.w	r3, r3, #16
 801583c:	6313      	str	r3, [r2, #48]	@ 0x30

  /* Enable  PLL3 */
  __HAL_RCC_PLL3_ENABLE();
 801583e:	4b0f      	ldr	r3, [pc, #60]	@ (801587c <RCCEx_PLL3_Config+0x128>)
 8015840:	681b      	ldr	r3, [r3, #0]
 8015842:	4a0e      	ldr	r2, [pc, #56]	@ (801587c <RCCEx_PLL3_Config+0x128>)
 8015844:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 8015848:	6013      	str	r3, [r2, #0]

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 801584a:	f7f8 f909 	bl	800da60 <HAL_GetTick>
 801584e:	60f8      	str	r0, [r7, #12]

  /* Wait till PLL3 is ready */
  while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == 0U)
 8015850:	e008      	b.n	8015864 <RCCEx_PLL3_Config+0x110>
  {
    if ((HAL_GetTick() - tickstart) > PLL3_TIMEOUT_VALUE)
 8015852:	f7f8 f905 	bl	800da60 <HAL_GetTick>
 8015856:	4602      	mov	r2, r0
 8015858:	68fb      	ldr	r3, [r7, #12]
 801585a:	1ad3      	subs	r3, r2, r3
 801585c:	2b02      	cmp	r3, #2
 801585e:	d901      	bls.n	8015864 <RCCEx_PLL3_Config+0x110>
    {
      return HAL_TIMEOUT;
 8015860:	2303      	movs	r3, #3
 8015862:	e006      	b.n	8015872 <RCCEx_PLL3_Config+0x11e>
  while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == 0U)
 8015864:	4b05      	ldr	r3, [pc, #20]	@ (801587c <RCCEx_PLL3_Config+0x128>)
 8015866:	681b      	ldr	r3, [r3, #0]
 8015868:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 801586c:	2b00      	cmp	r3, #0
 801586e:	d0f0      	beq.n	8015852 <RCCEx_PLL3_Config+0xfe>
    }
  }
  return HAL_OK;
 8015870:	2300      	movs	r3, #0
}
 8015872:	4618      	mov	r0, r3
 8015874:	3710      	adds	r7, #16
 8015876:	46bd      	mov	sp, r7
 8015878:	bd80      	pop	{r7, pc}
 801587a:	bf00      	nop
 801587c:	46020c00 	.word	0x46020c00
 8015880:	80800000 	.word	0x80800000

08015884 <HAL_SPI_Init>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
{
 8015884:	b580      	push	{r7, lr}
 8015886:	b084      	sub	sp, #16
 8015888:	af00      	add	r7, sp, #0
 801588a:	6078      	str	r0, [r7, #4]
  uint32_t crc_length;
  uint32_t packet_length;

  /* Check the SPI handle allocation */
  if (hspi == NULL)
 801588c:	687b      	ldr	r3, [r7, #4]
 801588e:	2b00      	cmp	r3, #0
 8015890:	d101      	bne.n	8015896 <HAL_SPI_Init+0x12>
  {
    return HAL_ERROR;
 8015892:	2301      	movs	r3, #1
 8015894:	e0fb      	b.n	8015a8e <HAL_SPI_Init+0x20a>

  /* Check the parameters */
  assert_param(IS_SPI_ALL_INSTANCE(hspi->Instance));
  assert_param(IS_SPI_MODE(hspi->Init.Mode));
  assert_param(IS_SPI_DIRECTION(hspi->Init.Direction));
  if (IS_SPI_LIMITED_INSTANCE(hspi->Instance))
 8015896:	687b      	ldr	r3, [r7, #4]
 8015898:	681b      	ldr	r3, [r3, #0]
 801589a:	4a7f      	ldr	r2, [pc, #508]	@ (8015a98 <HAL_SPI_Init+0x214>)
 801589c:	4293      	cmp	r3, r2
 801589e:	d004      	beq.n	80158aa <HAL_SPI_Init+0x26>
 80158a0:	687b      	ldr	r3, [r7, #4]
 80158a2:	681b      	ldr	r3, [r3, #0]
 80158a4:	4a7d      	ldr	r2, [pc, #500]	@ (8015a9c <HAL_SPI_Init+0x218>)
 80158a6:	4293      	cmp	r3, r2
 80158a8:	e000      	b.n	80158ac <HAL_SPI_Init+0x28>
  {
    assert_param(IS_SPI_LIMITED_DATASIZE(hspi->Init.DataSize));
    assert_param(IS_SPI_LIMITED_FIFOTHRESHOLD(hspi->Init.FifoThreshold));
 80158aa:	bf00      	nop
    assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
    assert_param(IS_SPI_CRC_INITIALIZATION_PATTERN(hspi->Init.TxCRCInitializationPattern));
    assert_param(IS_SPI_CRC_INITIALIZATION_PATTERN(hspi->Init.RxCRCInitializationPattern));
  }
#else
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 80158ac:	687b      	ldr	r3, [r7, #4]
 80158ae:	2200      	movs	r2, #0
 80158b0:	629a      	str	r2, [r3, #40]	@ 0x28
  assert_param(IS_SPI_RDY_MASTER_MANAGEMENT(hspi->Init.ReadyMasterManagement));
  assert_param(IS_SPI_RDY_POLARITY(hspi->Init.ReadyPolarity));
  assert_param(IS_SPI_MASTER_RX_AUTOSUSP(hspi->Init.MasterReceiverAutoSusp));

  /* Verify that the SPI instance supports Data Size higher than 16bits */
  if ((IS_SPI_LIMITED_INSTANCE(hspi->Instance)) && (hspi->Init.DataSize > SPI_DATASIZE_16BIT))
 80158b2:	687b      	ldr	r3, [r7, #4]
 80158b4:	681b      	ldr	r3, [r3, #0]
 80158b6:	4a78      	ldr	r2, [pc, #480]	@ (8015a98 <HAL_SPI_Init+0x214>)
 80158b8:	4293      	cmp	r3, r2
 80158ba:	d004      	beq.n	80158c6 <HAL_SPI_Init+0x42>
 80158bc:	687b      	ldr	r3, [r7, #4]
 80158be:	681b      	ldr	r3, [r3, #0]
 80158c0:	4a76      	ldr	r2, [pc, #472]	@ (8015a9c <HAL_SPI_Init+0x218>)
 80158c2:	4293      	cmp	r3, r2
 80158c4:	d105      	bne.n	80158d2 <HAL_SPI_Init+0x4e>
 80158c6:	687b      	ldr	r3, [r7, #4]
 80158c8:	68db      	ldr	r3, [r3, #12]
 80158ca:	2b0f      	cmp	r3, #15
 80158cc:	d901      	bls.n	80158d2 <HAL_SPI_Init+0x4e>
  {
    return HAL_ERROR;
 80158ce:	2301      	movs	r3, #1
 80158d0:	e0dd      	b.n	8015a8e <HAL_SPI_Init+0x20a>
  }

  /* Verify that the SPI instance supports requested data packing */
  packet_length = SPI_GetPacketSize(hspi);
 80158d2:	6878      	ldr	r0, [r7, #4]
 80158d4:	f000 fe42 	bl	801655c <SPI_GetPacketSize>
 80158d8:	60f8      	str	r0, [r7, #12]
  if (((IS_SPI_LIMITED_INSTANCE(hspi->Instance)) && (packet_length > SPI_LOWEND_FIFO_SIZE)) ||
 80158da:	687b      	ldr	r3, [r7, #4]
 80158dc:	681b      	ldr	r3, [r3, #0]
 80158de:	4a6e      	ldr	r2, [pc, #440]	@ (8015a98 <HAL_SPI_Init+0x214>)
 80158e0:	4293      	cmp	r3, r2
 80158e2:	d004      	beq.n	80158ee <HAL_SPI_Init+0x6a>
 80158e4:	687b      	ldr	r3, [r7, #4]
 80158e6:	681b      	ldr	r3, [r3, #0]
 80158e8:	4a6c      	ldr	r2, [pc, #432]	@ (8015a9c <HAL_SPI_Init+0x218>)
 80158ea:	4293      	cmp	r3, r2
 80158ec:	d102      	bne.n	80158f4 <HAL_SPI_Init+0x70>
 80158ee:	68fb      	ldr	r3, [r7, #12]
 80158f0:	2b08      	cmp	r3, #8
 80158f2:	d816      	bhi.n	8015922 <HAL_SPI_Init+0x9e>
      ((IS_SPI_FULL_INSTANCE(hspi->Instance)) && (packet_length > SPI_HIGHEND_FIFO_SIZE)))
 80158f4:	687b      	ldr	r3, [r7, #4]
 80158f6:	681b      	ldr	r3, [r3, #0]
  if (((IS_SPI_LIMITED_INSTANCE(hspi->Instance)) && (packet_length > SPI_LOWEND_FIFO_SIZE)) ||
 80158f8:	4a69      	ldr	r2, [pc, #420]	@ (8015aa0 <HAL_SPI_Init+0x21c>)
 80158fa:	4293      	cmp	r3, r2
 80158fc:	d00e      	beq.n	801591c <HAL_SPI_Init+0x98>
      ((IS_SPI_FULL_INSTANCE(hspi->Instance)) && (packet_length > SPI_HIGHEND_FIFO_SIZE)))
 80158fe:	687b      	ldr	r3, [r7, #4]
 8015900:	681b      	ldr	r3, [r3, #0]
 8015902:	4a68      	ldr	r2, [pc, #416]	@ (8015aa4 <HAL_SPI_Init+0x220>)
 8015904:	4293      	cmp	r3, r2
 8015906:	d009      	beq.n	801591c <HAL_SPI_Init+0x98>
 8015908:	687b      	ldr	r3, [r7, #4]
 801590a:	681b      	ldr	r3, [r3, #0]
 801590c:	4a66      	ldr	r2, [pc, #408]	@ (8015aa8 <HAL_SPI_Init+0x224>)
 801590e:	4293      	cmp	r3, r2
 8015910:	d004      	beq.n	801591c <HAL_SPI_Init+0x98>
 8015912:	687b      	ldr	r3, [r7, #4]
 8015914:	681b      	ldr	r3, [r3, #0]
 8015916:	4a65      	ldr	r2, [pc, #404]	@ (8015aac <HAL_SPI_Init+0x228>)
 8015918:	4293      	cmp	r3, r2
 801591a:	d104      	bne.n	8015926 <HAL_SPI_Init+0xa2>
 801591c:	68fb      	ldr	r3, [r7, #12]
 801591e:	2b10      	cmp	r3, #16
 8015920:	d901      	bls.n	8015926 <HAL_SPI_Init+0xa2>
  {
    return HAL_ERROR;
 8015922:	2301      	movs	r3, #1
 8015924:	e0b3      	b.n	8015a8e <HAL_SPI_Init+0x20a>
  {
    crc_length = hspi->Init.DataSize << SPI_CFG1_CRCSIZE_Pos;
  }
#endif /* USE_SPI_CRC */

  if (hspi->State == HAL_SPI_STATE_RESET)
 8015926:	687b      	ldr	r3, [r7, #4]
 8015928:	f893 3089 	ldrb.w	r3, [r3, #137]	@ 0x89
 801592c:	b2db      	uxtb	r3, r3
 801592e:	2b00      	cmp	r3, #0
 8015930:	d106      	bne.n	8015940 <HAL_SPI_Init+0xbc>
  {
    /* Allocate lock resource and initialize it */
    hspi->Lock = HAL_UNLOCKED;
 8015932:	687b      	ldr	r3, [r7, #4]
 8015934:	2200      	movs	r2, #0
 8015936:	f883 2088 	strb.w	r2, [r3, #136]	@ 0x88

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    hspi->MspInitCallback(hspi);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_SPI_MspInit(hspi);
 801593a:	6878      	ldr	r0, [r7, #4]
 801593c:	f7f0 fc6c 	bl	8006218 <HAL_SPI_MspInit>
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
  }

  hspi->State = HAL_SPI_STATE_BUSY;
 8015940:	687b      	ldr	r3, [r7, #4]
 8015942:	2202      	movs	r2, #2
 8015944:	f883 2089 	strb.w	r2, [r3, #137]	@ 0x89

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 8015948:	687b      	ldr	r3, [r7, #4]
 801594a:	681b      	ldr	r3, [r3, #0]
 801594c:	681a      	ldr	r2, [r3, #0]
 801594e:	687b      	ldr	r3, [r7, #4]
 8015950:	681b      	ldr	r3, [r3, #0]
 8015952:	f022 0201 	bic.w	r2, r2, #1
 8015956:	601a      	str	r2, [r3, #0]

#if (USE_SPI_CRC == 0)
  /* Keep the default value of CRCSIZE in case of CRC is not used */
  crc_length = hspi->Instance->CFG1 & SPI_CFG1_CRCSIZE;
 8015958:	687b      	ldr	r3, [r7, #4]
 801595a:	681b      	ldr	r3, [r3, #0]
 801595c:	689b      	ldr	r3, [r3, #8]
 801595e:	f403 13f8 	and.w	r3, r3, #2031616	@ 0x1f0000
 8015962:	60bb      	str	r3, [r7, #8]
  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Clock polarity and phase, NSS management,
  Communication speed, First bit, CRC calculation state, CRC Length */

  /* SPIx NSS Software Management Configuration */
  if ((hspi->Init.NSS == SPI_NSS_SOFT) && (((hspi->Init.Mode == SPI_MODE_MASTER) &&  \
 8015964:	687b      	ldr	r3, [r7, #4]
 8015966:	699b      	ldr	r3, [r3, #24]
 8015968:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
 801596c:	d119      	bne.n	80159a2 <HAL_SPI_Init+0x11e>
 801596e:	687b      	ldr	r3, [r7, #4]
 8015970:	685b      	ldr	r3, [r3, #4]
 8015972:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
 8015976:	d103      	bne.n	8015980 <HAL_SPI_Init+0xfc>
                                            (hspi->Init.NSSPolarity == SPI_NSS_POLARITY_LOW)) || \
 8015978:	687b      	ldr	r3, [r7, #4]
 801597a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
  if ((hspi->Init.NSS == SPI_NSS_SOFT) && (((hspi->Init.Mode == SPI_MODE_MASTER) &&  \
 801597c:	2b00      	cmp	r3, #0
 801597e:	d008      	beq.n	8015992 <HAL_SPI_Init+0x10e>
                                           ((hspi->Init.Mode == SPI_MODE_SLAVE) && \
 8015980:	687b      	ldr	r3, [r7, #4]
 8015982:	685b      	ldr	r3, [r3, #4]
                                            (hspi->Init.NSSPolarity == SPI_NSS_POLARITY_LOW)) || \
 8015984:	2b00      	cmp	r3, #0
 8015986:	d10c      	bne.n	80159a2 <HAL_SPI_Init+0x11e>
                                            (hspi->Init.NSSPolarity == SPI_NSS_POLARITY_HIGH))))
 8015988:	687b      	ldr	r3, [r7, #4]
 801598a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
                                           ((hspi->Init.Mode == SPI_MODE_SLAVE) && \
 801598c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 8015990:	d107      	bne.n	80159a2 <HAL_SPI_Init+0x11e>
  {
    SET_BIT(hspi->Instance->CR1, SPI_CR1_SSI);
 8015992:	687b      	ldr	r3, [r7, #4]
 8015994:	681b      	ldr	r3, [r3, #0]
 8015996:	681a      	ldr	r2, [r3, #0]
 8015998:	687b      	ldr	r3, [r7, #4]
 801599a:	681b      	ldr	r3, [r3, #0]
 801599c:	f442 5280 	orr.w	r2, r2, #4096	@ 0x1000
 80159a0:	601a      	str	r2, [r3, #0]
  }

  /* SPIx Master Rx Auto Suspend Configuration */
  if (((hspi->Init.Mode & SPI_MODE_MASTER) == SPI_MODE_MASTER) && (hspi->Init.DataSize >= SPI_DATASIZE_8BIT))
 80159a2:	687b      	ldr	r3, [r7, #4]
 80159a4:	685b      	ldr	r3, [r3, #4]
 80159a6:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
 80159aa:	2b00      	cmp	r3, #0
 80159ac:	d00f      	beq.n	80159ce <HAL_SPI_Init+0x14a>
 80159ae:	687b      	ldr	r3, [r7, #4]
 80159b0:	68db      	ldr	r3, [r3, #12]
 80159b2:	2b06      	cmp	r3, #6
 80159b4:	d90b      	bls.n	80159ce <HAL_SPI_Init+0x14a>
  {
    MODIFY_REG(hspi->Instance->CR1, SPI_CR1_MASRX, hspi->Init.MasterReceiverAutoSusp);
 80159b6:	687b      	ldr	r3, [r7, #4]
 80159b8:	681b      	ldr	r3, [r3, #0]
 80159ba:	681b      	ldr	r3, [r3, #0]
 80159bc:	f423 7180 	bic.w	r1, r3, #256	@ 0x100
 80159c0:	687b      	ldr	r3, [r7, #4]
 80159c2:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
 80159c4:	687b      	ldr	r3, [r7, #4]
 80159c6:	681b      	ldr	r3, [r3, #0]
 80159c8:	430a      	orrs	r2, r1
 80159ca:	601a      	str	r2, [r3, #0]
 80159cc:	e007      	b.n	80159de <HAL_SPI_Init+0x15a>
  }
  else
  {
    CLEAR_BIT(hspi->Instance->CR1, SPI_CR1_MASRX);
 80159ce:	687b      	ldr	r3, [r7, #4]
 80159d0:	681b      	ldr	r3, [r3, #0]
 80159d2:	681a      	ldr	r2, [r3, #0]
 80159d4:	687b      	ldr	r3, [r7, #4]
 80159d6:	681b      	ldr	r3, [r3, #0]
 80159d8:	f422 7280 	bic.w	r2, r2, #256	@ 0x100
 80159dc:	601a      	str	r2, [r3, #0]
  }

  /* SPIx CFG1 Configuration */
  WRITE_REG(hspi->Instance->CFG1, (hspi->Init.BaudRatePrescaler | hspi->Init.CRCCalculation | crc_length |
 80159de:	687b      	ldr	r3, [r7, #4]
 80159e0:	69da      	ldr	r2, [r3, #28]
 80159e2:	687b      	ldr	r3, [r7, #4]
 80159e4:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80159e6:	431a      	orrs	r2, r3
 80159e8:	68bb      	ldr	r3, [r7, #8]
 80159ea:	431a      	orrs	r2, r3
 80159ec:	687b      	ldr	r3, [r7, #4]
 80159ee:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80159f0:	ea42 0103 	orr.w	r1, r2, r3
 80159f4:	687b      	ldr	r3, [r7, #4]
 80159f6:	68da      	ldr	r2, [r3, #12]
 80159f8:	687b      	ldr	r3, [r7, #4]
 80159fa:	681b      	ldr	r3, [r3, #0]
 80159fc:	430a      	orrs	r2, r1
 80159fe:	609a      	str	r2, [r3, #8]
                                   hspi->Init.FifoThreshold     | hspi->Init.DataSize));

  /* SPIx CFG2 Configuration */
  WRITE_REG(hspi->Instance->CFG2, (hspi->Init.NSSPMode                | hspi->Init.TIMode    |
 8015a00:	687b      	ldr	r3, [r7, #4]
 8015a02:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8015a04:	687b      	ldr	r3, [r7, #4]
 8015a06:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8015a08:	431a      	orrs	r2, r3
 8015a0a:	687b      	ldr	r3, [r7, #4]
 8015a0c:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8015a0e:	431a      	orrs	r2, r3
 8015a10:	687b      	ldr	r3, [r7, #4]
 8015a12:	699b      	ldr	r3, [r3, #24]
 8015a14:	431a      	orrs	r2, r3
 8015a16:	687b      	ldr	r3, [r7, #4]
 8015a18:	691b      	ldr	r3, [r3, #16]
 8015a1a:	431a      	orrs	r2, r3
 8015a1c:	687b      	ldr	r3, [r7, #4]
 8015a1e:	695b      	ldr	r3, [r3, #20]
 8015a20:	431a      	orrs	r2, r3
 8015a22:	687b      	ldr	r3, [r7, #4]
 8015a24:	6a1b      	ldr	r3, [r3, #32]
 8015a26:	431a      	orrs	r2, r3
 8015a28:	687b      	ldr	r3, [r7, #4]
 8015a2a:	685b      	ldr	r3, [r3, #4]
 8015a2c:	431a      	orrs	r2, r3
 8015a2e:	687b      	ldr	r3, [r7, #4]
 8015a30:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8015a32:	431a      	orrs	r2, r3
 8015a34:	687b      	ldr	r3, [r7, #4]
 8015a36:	689b      	ldr	r3, [r3, #8]
 8015a38:	431a      	orrs	r2, r3
 8015a3a:	687b      	ldr	r3, [r7, #4]
 8015a3c:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 8015a3e:	431a      	orrs	r2, r3
 8015a40:	687b      	ldr	r3, [r7, #4]
 8015a42:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8015a44:	431a      	orrs	r2, r3
 8015a46:	687b      	ldr	r3, [r7, #4]
 8015a48:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8015a4a:	ea42 0103 	orr.w	r1, r2, r3
 8015a4e:	687b      	ldr	r3, [r7, #4]
 8015a50:	6e1a      	ldr	r2, [r3, #96]	@ 0x60
 8015a52:	687b      	ldr	r3, [r7, #4]
 8015a54:	681b      	ldr	r3, [r3, #0]
 8015a56:	430a      	orrs	r2, r1
 8015a58:	60da      	str	r2, [r3, #12]
  /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
#endif /* SPI_I2SCFGR_I2SMOD */

  /* Insure that AFCNTR is managed only by Master */
  if ((hspi->Init.Mode & SPI_MODE_MASTER) == SPI_MODE_MASTER)
 8015a5a:	687b      	ldr	r3, [r7, #4]
 8015a5c:	685b      	ldr	r3, [r3, #4]
 8015a5e:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
 8015a62:	2b00      	cmp	r3, #0
 8015a64:	d00a      	beq.n	8015a7c <HAL_SPI_Init+0x1f8>
  {
    /* Alternate function GPIOs control */
    MODIFY_REG(hspi->Instance->CFG2, SPI_CFG2_AFCNTR, (hspi->Init.MasterKeepIOState));
 8015a66:	687b      	ldr	r3, [r7, #4]
 8015a68:	681b      	ldr	r3, [r3, #0]
 8015a6a:	68db      	ldr	r3, [r3, #12]
 8015a6c:	f023 4100 	bic.w	r1, r3, #2147483648	@ 0x80000000
 8015a70:	687b      	ldr	r3, [r7, #4]
 8015a72:	6d5a      	ldr	r2, [r3, #84]	@ 0x54
 8015a74:	687b      	ldr	r3, [r7, #4]
 8015a76:	681b      	ldr	r3, [r3, #0]
 8015a78:	430a      	orrs	r2, r1
 8015a7a:	60da      	str	r2, [r3, #12]
  }

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 8015a7c:	687b      	ldr	r3, [r7, #4]
 8015a7e:	2200      	movs	r2, #0
 8015a80:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
  hspi->State     = HAL_SPI_STATE_READY;
 8015a84:	687b      	ldr	r3, [r7, #4]
 8015a86:	2201      	movs	r2, #1
 8015a88:	f883 2089 	strb.w	r2, [r3, #137]	@ 0x89

  return HAL_OK;
 8015a8c:	2300      	movs	r3, #0
}
 8015a8e:	4618      	mov	r0, r3
 8015a90:	3710      	adds	r7, #16
 8015a92:	46bd      	mov	sp, r7
 8015a94:	bd80      	pop	{r7, pc}
 8015a96:	bf00      	nop
 8015a98:	46002000 	.word	0x46002000
 8015a9c:	56002000 	.word	0x56002000
 8015aa0:	40013000 	.word	0x40013000
 8015aa4:	50013000 	.word	0x50013000
 8015aa8:	40003800 	.word	0x40003800
 8015aac:	50003800 	.word	0x50003800

08015ab0 <HAL_SPI_TransmitReceive>:
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, const uint8_t *pTxData, uint8_t *pRxData,
                                          uint16_t Size, uint32_t Timeout)
{
 8015ab0:	b580      	push	{r7, lr}
 8015ab2:	b08c      	sub	sp, #48	@ 0x30
 8015ab4:	af02      	add	r7, sp, #8
 8015ab6:	60f8      	str	r0, [r7, #12]
 8015ab8:	60b9      	str	r1, [r7, #8]
 8015aba:	607a      	str	r2, [r7, #4]
 8015abc:	807b      	strh	r3, [r7, #2]
#if defined (__GNUC__)
  __IO uint16_t *ptxdr_16bits = (__IO uint16_t *)(&(hspi->Instance->TXDR));
 8015abe:	68fb      	ldr	r3, [r7, #12]
 8015ac0:	681b      	ldr	r3, [r3, #0]
 8015ac2:	3320      	adds	r3, #32
 8015ac4:	61fb      	str	r3, [r7, #28]
  __IO uint16_t *prxdr_16bits = (__IO uint16_t *)(&(hspi->Instance->RXDR));
 8015ac6:	68fb      	ldr	r3, [r7, #12]
 8015ac8:	681b      	ldr	r3, [r3, #0]
 8015aca:	3330      	adds	r3, #48	@ 0x30
 8015acc:	61bb      	str	r3, [r7, #24]

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));

  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();
 8015ace:	f7f7 ffc7 	bl	800da60 <HAL_GetTick>
 8015ad2:	6178      	str	r0, [r7, #20]

  initial_TxXferCount = Size;
 8015ad4:	887b      	ldrh	r3, [r7, #2]
 8015ad6:	847b      	strh	r3, [r7, #34]	@ 0x22
  initial_RxXferCount = Size;
 8015ad8:	887b      	ldrh	r3, [r7, #2]
 8015ada:	843b      	strh	r3, [r7, #32]

  if (hspi->State != HAL_SPI_STATE_READY)
 8015adc:	68fb      	ldr	r3, [r7, #12]
 8015ade:	f893 3089 	ldrb.w	r3, [r3, #137]	@ 0x89
 8015ae2:	b2db      	uxtb	r3, r3
 8015ae4:	2b01      	cmp	r3, #1
 8015ae6:	d001      	beq.n	8015aec <HAL_SPI_TransmitReceive+0x3c>
  {
    return HAL_BUSY;
 8015ae8:	2302      	movs	r3, #2
 8015aea:	e237      	b.n	8015f5c <HAL_SPI_TransmitReceive+0x4ac>
  }

  if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0UL))
 8015aec:	68bb      	ldr	r3, [r7, #8]
 8015aee:	2b00      	cmp	r3, #0
 8015af0:	d005      	beq.n	8015afe <HAL_SPI_TransmitReceive+0x4e>
 8015af2:	687b      	ldr	r3, [r7, #4]
 8015af4:	2b00      	cmp	r3, #0
 8015af6:	d002      	beq.n	8015afe <HAL_SPI_TransmitReceive+0x4e>
 8015af8:	887b      	ldrh	r3, [r7, #2]
 8015afa:	2b00      	cmp	r3, #0
 8015afc:	d101      	bne.n	8015b02 <HAL_SPI_TransmitReceive+0x52>
  {
    return HAL_ERROR;
 8015afe:	2301      	movs	r3, #1
 8015b00:	e22c      	b.n	8015f5c <HAL_SPI_TransmitReceive+0x4ac>
  }

  /* Lock the process */
  __HAL_LOCK(hspi);
 8015b02:	68fb      	ldr	r3, [r7, #12]
 8015b04:	f893 3088 	ldrb.w	r3, [r3, #136]	@ 0x88
 8015b08:	2b01      	cmp	r3, #1
 8015b0a:	d101      	bne.n	8015b10 <HAL_SPI_TransmitReceive+0x60>
 8015b0c:	2302      	movs	r3, #2
 8015b0e:	e225      	b.n	8015f5c <HAL_SPI_TransmitReceive+0x4ac>
 8015b10:	68fb      	ldr	r3, [r7, #12]
 8015b12:	2201      	movs	r2, #1
 8015b14:	f883 2088 	strb.w	r2, [r3, #136]	@ 0x88

  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_TX_RX;
 8015b18:	68fb      	ldr	r3, [r7, #12]
 8015b1a:	2205      	movs	r2, #5
 8015b1c:	f883 2089 	strb.w	r2, [r3, #137]	@ 0x89
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8015b20:	68fb      	ldr	r3, [r7, #12]
 8015b22:	2200      	movs	r2, #0
 8015b24:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
  hspi->pRxBuffPtr  = (uint8_t *)pRxData;
 8015b28:	68fb      	ldr	r3, [r7, #12]
 8015b2a:	687a      	ldr	r2, [r7, #4]
 8015b2c:	66da      	str	r2, [r3, #108]	@ 0x6c
  hspi->RxXferCount = Size;
 8015b2e:	68fb      	ldr	r3, [r7, #12]
 8015b30:	887a      	ldrh	r2, [r7, #2]
 8015b32:	f8a3 2072 	strh.w	r2, [r3, #114]	@ 0x72
  hspi->RxXferSize  = Size;
 8015b36:	68fb      	ldr	r3, [r7, #12]
 8015b38:	887a      	ldrh	r2, [r7, #2]
 8015b3a:	f8a3 2070 	strh.w	r2, [r3, #112]	@ 0x70
  hspi->pTxBuffPtr  = (const uint8_t *)pTxData;
 8015b3e:	68fb      	ldr	r3, [r7, #12]
 8015b40:	68ba      	ldr	r2, [r7, #8]
 8015b42:	665a      	str	r2, [r3, #100]	@ 0x64
  hspi->TxXferCount = Size;
 8015b44:	68fb      	ldr	r3, [r7, #12]
 8015b46:	887a      	ldrh	r2, [r7, #2]
 8015b48:	f8a3 206a 	strh.w	r2, [r3, #106]	@ 0x6a
  hspi->TxXferSize  = Size;
 8015b4c:	68fb      	ldr	r3, [r7, #12]
 8015b4e:	887a      	ldrh	r2, [r7, #2]
 8015b50:	f8a3 2068 	strh.w	r2, [r3, #104]	@ 0x68

  /*Init field not used in handle to zero */
  hspi->RxISR       = NULL;
 8015b54:	68fb      	ldr	r3, [r7, #12]
 8015b56:	2200      	movs	r2, #0
 8015b58:	679a      	str	r2, [r3, #120]	@ 0x78
  hspi->TxISR       = NULL;
 8015b5a:	68fb      	ldr	r3, [r7, #12]
 8015b5c:	2200      	movs	r2, #0
 8015b5e:	67da      	str	r2, [r3, #124]	@ 0x7c

  /* Set Full-Duplex mode */
  SPI_2LINES(hspi);
 8015b60:	68fb      	ldr	r3, [r7, #12]
 8015b62:	681b      	ldr	r3, [r3, #0]
 8015b64:	68da      	ldr	r2, [r3, #12]
 8015b66:	68fb      	ldr	r3, [r7, #12]
 8015b68:	681b      	ldr	r3, [r3, #0]
 8015b6a:	f422 22c0 	bic.w	r2, r2, #393216	@ 0x60000
 8015b6e:	60da      	str	r2, [r3, #12]

  /* Initialize FIFO length */
  if (IS_SPI_FULL_INSTANCE(hspi->Instance))
 8015b70:	68fb      	ldr	r3, [r7, #12]
 8015b72:	681b      	ldr	r3, [r3, #0]
 8015b74:	4a6c      	ldr	r2, [pc, #432]	@ (8015d28 <HAL_SPI_TransmitReceive+0x278>)
 8015b76:	4293      	cmp	r3, r2
 8015b78:	d00e      	beq.n	8015b98 <HAL_SPI_TransmitReceive+0xe8>
 8015b7a:	68fb      	ldr	r3, [r7, #12]
 8015b7c:	681b      	ldr	r3, [r3, #0]
 8015b7e:	4a6b      	ldr	r2, [pc, #428]	@ (8015d2c <HAL_SPI_TransmitReceive+0x27c>)
 8015b80:	4293      	cmp	r3, r2
 8015b82:	d009      	beq.n	8015b98 <HAL_SPI_TransmitReceive+0xe8>
 8015b84:	68fb      	ldr	r3, [r7, #12]
 8015b86:	681b      	ldr	r3, [r3, #0]
 8015b88:	4a69      	ldr	r2, [pc, #420]	@ (8015d30 <HAL_SPI_TransmitReceive+0x280>)
 8015b8a:	4293      	cmp	r3, r2
 8015b8c:	d004      	beq.n	8015b98 <HAL_SPI_TransmitReceive+0xe8>
 8015b8e:	68fb      	ldr	r3, [r7, #12]
 8015b90:	681b      	ldr	r3, [r3, #0]
 8015b92:	4a68      	ldr	r2, [pc, #416]	@ (8015d34 <HAL_SPI_TransmitReceive+0x284>)
 8015b94:	4293      	cmp	r3, r2
 8015b96:	d102      	bne.n	8015b9e <HAL_SPI_TransmitReceive+0xee>
  {
    fifo_length = SPI_HIGHEND_FIFO_SIZE;
 8015b98:	2310      	movs	r3, #16
 8015b9a:	627b      	str	r3, [r7, #36]	@ 0x24
 8015b9c:	e001      	b.n	8015ba2 <HAL_SPI_TransmitReceive+0xf2>
  }
  else
  {
    fifo_length = SPI_LOWEND_FIFO_SIZE;
 8015b9e:	2308      	movs	r3, #8
 8015ba0:	627b      	str	r3, [r7, #36]	@ 0x24
  }

  /* Set the number of data at current transfer */
  MODIFY_REG(hspi->Instance->CR2, SPI_CR2_TSIZE, Size);
 8015ba2:	68fb      	ldr	r3, [r7, #12]
 8015ba4:	681b      	ldr	r3, [r3, #0]
 8015ba6:	685b      	ldr	r3, [r3, #4]
 8015ba8:	0c1b      	lsrs	r3, r3, #16
 8015baa:	041b      	lsls	r3, r3, #16
 8015bac:	8879      	ldrh	r1, [r7, #2]
 8015bae:	68fa      	ldr	r2, [r7, #12]
 8015bb0:	6812      	ldr	r2, [r2, #0]
 8015bb2:	430b      	orrs	r3, r1
 8015bb4:	6053      	str	r3, [r2, #4]

  __HAL_SPI_ENABLE(hspi);
 8015bb6:	68fb      	ldr	r3, [r7, #12]
 8015bb8:	681b      	ldr	r3, [r3, #0]
 8015bba:	681a      	ldr	r2, [r3, #0]
 8015bbc:	68fb      	ldr	r3, [r7, #12]
 8015bbe:	681b      	ldr	r3, [r3, #0]
 8015bc0:	f042 0201 	orr.w	r2, r2, #1
 8015bc4:	601a      	str	r2, [r3, #0]

  if (((hspi->Instance->AUTOCR & SPI_AUTOCR_TRIGEN) == 0U) && (hspi->Init.Mode == SPI_MODE_MASTER))
 8015bc6:	68fb      	ldr	r3, [r7, #12]
 8015bc8:	681b      	ldr	r3, [r3, #0]
 8015bca:	69db      	ldr	r3, [r3, #28]
 8015bcc:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
 8015bd0:	2b00      	cmp	r3, #0
 8015bd2:	d10c      	bne.n	8015bee <HAL_SPI_TransmitReceive+0x13e>
 8015bd4:	68fb      	ldr	r3, [r7, #12]
 8015bd6:	685b      	ldr	r3, [r3, #4]
 8015bd8:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
 8015bdc:	d107      	bne.n	8015bee <HAL_SPI_TransmitReceive+0x13e>
  {
    /* Master transfer start */
    SET_BIT(hspi->Instance->CR1, SPI_CR1_CSTART);
 8015bde:	68fb      	ldr	r3, [r7, #12]
 8015be0:	681b      	ldr	r3, [r3, #0]
 8015be2:	681a      	ldr	r2, [r3, #0]
 8015be4:	68fb      	ldr	r3, [r7, #12]
 8015be6:	681b      	ldr	r3, [r3, #0]
 8015be8:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 8015bec:	601a      	str	r2, [r3, #0]
  }

  /* Transmit and Receive data in 32 Bit mode */
  if ((hspi->Init.DataSize > SPI_DATASIZE_16BIT) && (IS_SPI_FULL_INSTANCE(hspi->Instance)))
 8015bee:	68fb      	ldr	r3, [r7, #12]
 8015bf0:	68db      	ldr	r3, [r3, #12]
 8015bf2:	2b0f      	cmp	r3, #15
 8015bf4:	f240 808e 	bls.w	8015d14 <HAL_SPI_TransmitReceive+0x264>
 8015bf8:	68fb      	ldr	r3, [r7, #12]
 8015bfa:	681b      	ldr	r3, [r3, #0]
 8015bfc:	4a4a      	ldr	r2, [pc, #296]	@ (8015d28 <HAL_SPI_TransmitReceive+0x278>)
 8015bfe:	4293      	cmp	r3, r2
 8015c00:	d00e      	beq.n	8015c20 <HAL_SPI_TransmitReceive+0x170>
 8015c02:	68fb      	ldr	r3, [r7, #12]
 8015c04:	681b      	ldr	r3, [r3, #0]
 8015c06:	4a49      	ldr	r2, [pc, #292]	@ (8015d2c <HAL_SPI_TransmitReceive+0x27c>)
 8015c08:	4293      	cmp	r3, r2
 8015c0a:	d009      	beq.n	8015c20 <HAL_SPI_TransmitReceive+0x170>
 8015c0c:	68fb      	ldr	r3, [r7, #12]
 8015c0e:	681b      	ldr	r3, [r3, #0]
 8015c10:	4a47      	ldr	r2, [pc, #284]	@ (8015d30 <HAL_SPI_TransmitReceive+0x280>)
 8015c12:	4293      	cmp	r3, r2
 8015c14:	d004      	beq.n	8015c20 <HAL_SPI_TransmitReceive+0x170>
 8015c16:	68fb      	ldr	r3, [r7, #12]
 8015c18:	681b      	ldr	r3, [r3, #0]
 8015c1a:	4a46      	ldr	r2, [pc, #280]	@ (8015d34 <HAL_SPI_TransmitReceive+0x284>)
 8015c1c:	4293      	cmp	r3, r2
 8015c1e:	d179      	bne.n	8015d14 <HAL_SPI_TransmitReceive+0x264>
  {
    /* Adapt fifo length to 32bits data width */
    fifo_length = (fifo_length / 4UL);
 8015c20:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8015c22:	089b      	lsrs	r3, r3, #2
 8015c24:	627b      	str	r3, [r7, #36]	@ 0x24

    while ((initial_TxXferCount > 0UL) || (initial_RxXferCount > 0UL))
 8015c26:	e06e      	b.n	8015d06 <HAL_SPI_TransmitReceive+0x256>
    {
      /* Check TXP flag */
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXP)) && (initial_TxXferCount > 0UL) &&
 8015c28:	68fb      	ldr	r3, [r7, #12]
 8015c2a:	681b      	ldr	r3, [r3, #0]
 8015c2c:	695b      	ldr	r3, [r3, #20]
 8015c2e:	f003 0302 	and.w	r3, r3, #2
 8015c32:	2b02      	cmp	r3, #2
 8015c34:	d120      	bne.n	8015c78 <HAL_SPI_TransmitReceive+0x1c8>
 8015c36:	8c7b      	ldrh	r3, [r7, #34]	@ 0x22
 8015c38:	2b00      	cmp	r3, #0
 8015c3a:	d01d      	beq.n	8015c78 <HAL_SPI_TransmitReceive+0x1c8>
          (initial_RxXferCount  < (initial_TxXferCount + fifo_length)))
 8015c3c:	8c3a      	ldrh	r2, [r7, #32]
 8015c3e:	8c79      	ldrh	r1, [r7, #34]	@ 0x22
 8015c40:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8015c42:	440b      	add	r3, r1
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXP)) && (initial_TxXferCount > 0UL) &&
 8015c44:	429a      	cmp	r2, r3
 8015c46:	d217      	bcs.n	8015c78 <HAL_SPI_TransmitReceive+0x1c8>
      {
        *((__IO uint32_t *)&hspi->Instance->TXDR) = *((const uint32_t *)hspi->pTxBuffPtr);
 8015c48:	68fb      	ldr	r3, [r7, #12]
 8015c4a:	6e5a      	ldr	r2, [r3, #100]	@ 0x64
 8015c4c:	68fb      	ldr	r3, [r7, #12]
 8015c4e:	681b      	ldr	r3, [r3, #0]
 8015c50:	6812      	ldr	r2, [r2, #0]
 8015c52:	621a      	str	r2, [r3, #32]
        hspi->pTxBuffPtr += sizeof(uint32_t);
 8015c54:	68fb      	ldr	r3, [r7, #12]
 8015c56:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8015c58:	1d1a      	adds	r2, r3, #4
 8015c5a:	68fb      	ldr	r3, [r7, #12]
 8015c5c:	665a      	str	r2, [r3, #100]	@ 0x64
        hspi->TxXferCount --;
 8015c5e:	68fb      	ldr	r3, [r7, #12]
 8015c60:	f8b3 306a 	ldrh.w	r3, [r3, #106]	@ 0x6a
 8015c64:	b29b      	uxth	r3, r3
 8015c66:	3b01      	subs	r3, #1
 8015c68:	b29a      	uxth	r2, r3
 8015c6a:	68fb      	ldr	r3, [r7, #12]
 8015c6c:	f8a3 206a 	strh.w	r2, [r3, #106]	@ 0x6a
        initial_TxXferCount = hspi->TxXferCount;
 8015c70:	68fb      	ldr	r3, [r7, #12]
 8015c72:	f8b3 306a 	ldrh.w	r3, [r3, #106]	@ 0x6a
 8015c76:	847b      	strh	r3, [r7, #34]	@ 0x22
      }

      /* Check RXWNE/EOT flag */
      if (((hspi->Instance->SR & (SPI_FLAG_RXWNE | SPI_FLAG_EOT)) != 0UL) && (initial_RxXferCount > 0UL))
 8015c78:	68fb      	ldr	r3, [r7, #12]
 8015c7a:	681b      	ldr	r3, [r3, #0]
 8015c7c:	695a      	ldr	r2, [r3, #20]
 8015c7e:	f248 0308 	movw	r3, #32776	@ 0x8008
 8015c82:	4013      	ands	r3, r2
 8015c84:	2b00      	cmp	r3, #0
 8015c86:	d01a      	beq.n	8015cbe <HAL_SPI_TransmitReceive+0x20e>
 8015c88:	8c3b      	ldrh	r3, [r7, #32]
 8015c8a:	2b00      	cmp	r3, #0
 8015c8c:	d017      	beq.n	8015cbe <HAL_SPI_TransmitReceive+0x20e>
      {
        *((uint32_t *)hspi->pRxBuffPtr) = *((__IO uint32_t *)&hspi->Instance->RXDR);
 8015c8e:	68fb      	ldr	r3, [r7, #12]
 8015c90:	681a      	ldr	r2, [r3, #0]
 8015c92:	68fb      	ldr	r3, [r7, #12]
 8015c94:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 8015c96:	6b12      	ldr	r2, [r2, #48]	@ 0x30
 8015c98:	601a      	str	r2, [r3, #0]
        hspi->pRxBuffPtr += sizeof(uint32_t);
 8015c9a:	68fb      	ldr	r3, [r7, #12]
 8015c9c:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 8015c9e:	1d1a      	adds	r2, r3, #4
 8015ca0:	68fb      	ldr	r3, [r7, #12]
 8015ca2:	66da      	str	r2, [r3, #108]	@ 0x6c
        hspi->RxXferCount --;
 8015ca4:	68fb      	ldr	r3, [r7, #12]
 8015ca6:	f8b3 3072 	ldrh.w	r3, [r3, #114]	@ 0x72
 8015caa:	b29b      	uxth	r3, r3
 8015cac:	3b01      	subs	r3, #1
 8015cae:	b29a      	uxth	r2, r3
 8015cb0:	68fb      	ldr	r3, [r7, #12]
 8015cb2:	f8a3 2072 	strh.w	r2, [r3, #114]	@ 0x72
        initial_RxXferCount = hspi->RxXferCount;
 8015cb6:	68fb      	ldr	r3, [r7, #12]
 8015cb8:	f8b3 3072 	ldrh.w	r3, [r3, #114]	@ 0x72
 8015cbc:	843b      	strh	r3, [r7, #32]
      }

      /* Timeout management */
      if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 8015cbe:	f7f7 fecf 	bl	800da60 <HAL_GetTick>
 8015cc2:	4602      	mov	r2, r0
 8015cc4:	697b      	ldr	r3, [r7, #20]
 8015cc6:	1ad3      	subs	r3, r2, r3
 8015cc8:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8015cca:	429a      	cmp	r2, r3
 8015ccc:	d803      	bhi.n	8015cd6 <HAL_SPI_TransmitReceive+0x226>
 8015cce:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8015cd0:	f1b3 3fff 	cmp.w	r3, #4294967295
 8015cd4:	d102      	bne.n	8015cdc <HAL_SPI_TransmitReceive+0x22c>
 8015cd6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8015cd8:	2b00      	cmp	r3, #0
 8015cda:	d114      	bne.n	8015d06 <HAL_SPI_TransmitReceive+0x256>
      {
        /* Call standard close procedure with error check */
        SPI_CloseTransfer(hspi);
 8015cdc:	68f8      	ldr	r0, [r7, #12]
 8015cde:	f000 fb6f 	bl	80163c0 <SPI_CloseTransfer>

        SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_TIMEOUT);
 8015ce2:	68fb      	ldr	r3, [r7, #12]
 8015ce4:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8015ce8:	f443 7280 	orr.w	r2, r3, #256	@ 0x100
 8015cec:	68fb      	ldr	r3, [r7, #12]
 8015cee:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
        hspi->State = HAL_SPI_STATE_READY;
 8015cf2:	68fb      	ldr	r3, [r7, #12]
 8015cf4:	2201      	movs	r2, #1
 8015cf6:	f883 2089 	strb.w	r2, [r3, #137]	@ 0x89

        /* Unlock the process */
        __HAL_UNLOCK(hspi);
 8015cfa:	68fb      	ldr	r3, [r7, #12]
 8015cfc:	2200      	movs	r2, #0
 8015cfe:	f883 2088 	strb.w	r2, [r3, #136]	@ 0x88

        return HAL_TIMEOUT;
 8015d02:	2303      	movs	r3, #3
 8015d04:	e12a      	b.n	8015f5c <HAL_SPI_TransmitReceive+0x4ac>
    while ((initial_TxXferCount > 0UL) || (initial_RxXferCount > 0UL))
 8015d06:	8c7b      	ldrh	r3, [r7, #34]	@ 0x22
 8015d08:	2b00      	cmp	r3, #0
 8015d0a:	d18d      	bne.n	8015c28 <HAL_SPI_TransmitReceive+0x178>
 8015d0c:	8c3b      	ldrh	r3, [r7, #32]
 8015d0e:	2b00      	cmp	r3, #0
 8015d10:	d18a      	bne.n	8015c28 <HAL_SPI_TransmitReceive+0x178>
  if ((hspi->Init.DataSize > SPI_DATASIZE_16BIT) && (IS_SPI_FULL_INSTANCE(hspi->Instance)))
 8015d12:	e0fd      	b.n	8015f10 <HAL_SPI_TransmitReceive+0x460>
      }
    }
  }
  /* Transmit and Receive data in 16 Bit mode */
  else if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8015d14:	68fb      	ldr	r3, [r7, #12]
 8015d16:	68db      	ldr	r3, [r3, #12]
 8015d18:	2b07      	cmp	r3, #7
 8015d1a:	f240 80f3 	bls.w	8015f04 <HAL_SPI_TransmitReceive+0x454>
  {
    /* Adapt fifo length to 16bits data width */
    fifo_length = (fifo_length / 2UL);
 8015d1e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8015d20:	085b      	lsrs	r3, r3, #1
 8015d22:	627b      	str	r3, [r7, #36]	@ 0x24

    while ((initial_TxXferCount > 0UL) || (initial_RxXferCount > 0UL))
 8015d24:	e075      	b.n	8015e12 <HAL_SPI_TransmitReceive+0x362>
 8015d26:	bf00      	nop
 8015d28:	40013000 	.word	0x40013000
 8015d2c:	50013000 	.word	0x50013000
 8015d30:	40003800 	.word	0x40003800
 8015d34:	50003800 	.word	0x50003800
    {
      /* Check the TXP flag */
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXP)) && (initial_TxXferCount > 0UL) &&
 8015d38:	68fb      	ldr	r3, [r7, #12]
 8015d3a:	681b      	ldr	r3, [r3, #0]
 8015d3c:	695b      	ldr	r3, [r3, #20]
 8015d3e:	f003 0302 	and.w	r3, r3, #2
 8015d42:	2b02      	cmp	r3, #2
 8015d44:	d11f      	bne.n	8015d86 <HAL_SPI_TransmitReceive+0x2d6>
 8015d46:	8c7b      	ldrh	r3, [r7, #34]	@ 0x22
 8015d48:	2b00      	cmp	r3, #0
 8015d4a:	d01c      	beq.n	8015d86 <HAL_SPI_TransmitReceive+0x2d6>
          (initial_RxXferCount  < (initial_TxXferCount + fifo_length)))
 8015d4c:	8c3a      	ldrh	r2, [r7, #32]
 8015d4e:	8c79      	ldrh	r1, [r7, #34]	@ 0x22
 8015d50:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8015d52:	440b      	add	r3, r1
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXP)) && (initial_TxXferCount > 0UL) &&
 8015d54:	429a      	cmp	r2, r3
 8015d56:	d216      	bcs.n	8015d86 <HAL_SPI_TransmitReceive+0x2d6>
      {
#if defined (__GNUC__)
        *ptxdr_16bits = *((const uint16_t *)hspi->pTxBuffPtr);
 8015d58:	68fb      	ldr	r3, [r7, #12]
 8015d5a:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8015d5c:	881a      	ldrh	r2, [r3, #0]
 8015d5e:	69fb      	ldr	r3, [r7, #28]
 8015d60:	801a      	strh	r2, [r3, #0]
#else
        *((__IO uint16_t *)&hspi->Instance->TXDR) = *((const uint16_t *)hspi->pTxBuffPtr);
#endif /* __GNUC__ */
        hspi->pTxBuffPtr += sizeof(uint16_t);
 8015d62:	68fb      	ldr	r3, [r7, #12]
 8015d64:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8015d66:	1c9a      	adds	r2, r3, #2
 8015d68:	68fb      	ldr	r3, [r7, #12]
 8015d6a:	665a      	str	r2, [r3, #100]	@ 0x64
        hspi->TxXferCount--;
 8015d6c:	68fb      	ldr	r3, [r7, #12]
 8015d6e:	f8b3 306a 	ldrh.w	r3, [r3, #106]	@ 0x6a
 8015d72:	b29b      	uxth	r3, r3
 8015d74:	3b01      	subs	r3, #1
 8015d76:	b29a      	uxth	r2, r3
 8015d78:	68fb      	ldr	r3, [r7, #12]
 8015d7a:	f8a3 206a 	strh.w	r2, [r3, #106]	@ 0x6a
        initial_TxXferCount = hspi->TxXferCount;
 8015d7e:	68fb      	ldr	r3, [r7, #12]
 8015d80:	f8b3 306a 	ldrh.w	r3, [r3, #106]	@ 0x6a
 8015d84:	847b      	strh	r3, [r7, #34]	@ 0x22
      }

      /* Check the RXP flag */
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXP)) && (initial_RxXferCount > 0UL))
 8015d86:	68fb      	ldr	r3, [r7, #12]
 8015d88:	681b      	ldr	r3, [r3, #0]
 8015d8a:	695b      	ldr	r3, [r3, #20]
 8015d8c:	f003 0301 	and.w	r3, r3, #1
 8015d90:	2b01      	cmp	r3, #1
 8015d92:	d11a      	bne.n	8015dca <HAL_SPI_TransmitReceive+0x31a>
 8015d94:	8c3b      	ldrh	r3, [r7, #32]
 8015d96:	2b00      	cmp	r3, #0
 8015d98:	d017      	beq.n	8015dca <HAL_SPI_TransmitReceive+0x31a>
      {
#if defined (__GNUC__)
        *((uint16_t *)hspi->pRxBuffPtr) = *prxdr_16bits;
 8015d9a:	68fb      	ldr	r3, [r7, #12]
 8015d9c:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 8015d9e:	69ba      	ldr	r2, [r7, #24]
 8015da0:	8812      	ldrh	r2, [r2, #0]
 8015da2:	b292      	uxth	r2, r2
 8015da4:	801a      	strh	r2, [r3, #0]
#else
        *((uint16_t *)hspi->pRxBuffPtr) = *((__IO uint16_t *)&hspi->Instance->RXDR);
#endif /* __GNUC__ */
        hspi->pRxBuffPtr += sizeof(uint16_t);
 8015da6:	68fb      	ldr	r3, [r7, #12]
 8015da8:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 8015daa:	1c9a      	adds	r2, r3, #2
 8015dac:	68fb      	ldr	r3, [r7, #12]
 8015dae:	66da      	str	r2, [r3, #108]	@ 0x6c
        hspi->RxXferCount--;
 8015db0:	68fb      	ldr	r3, [r7, #12]
 8015db2:	f8b3 3072 	ldrh.w	r3, [r3, #114]	@ 0x72
 8015db6:	b29b      	uxth	r3, r3
 8015db8:	3b01      	subs	r3, #1
 8015dba:	b29a      	uxth	r2, r3
 8015dbc:	68fb      	ldr	r3, [r7, #12]
 8015dbe:	f8a3 2072 	strh.w	r2, [r3, #114]	@ 0x72
        initial_RxXferCount = hspi->RxXferCount;
 8015dc2:	68fb      	ldr	r3, [r7, #12]
 8015dc4:	f8b3 3072 	ldrh.w	r3, [r3, #114]	@ 0x72
 8015dc8:	843b      	strh	r3, [r7, #32]
      }

      /* Timeout management */
      if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 8015dca:	f7f7 fe49 	bl	800da60 <HAL_GetTick>
 8015dce:	4602      	mov	r2, r0
 8015dd0:	697b      	ldr	r3, [r7, #20]
 8015dd2:	1ad3      	subs	r3, r2, r3
 8015dd4:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8015dd6:	429a      	cmp	r2, r3
 8015dd8:	d803      	bhi.n	8015de2 <HAL_SPI_TransmitReceive+0x332>
 8015dda:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8015ddc:	f1b3 3fff 	cmp.w	r3, #4294967295
 8015de0:	d102      	bne.n	8015de8 <HAL_SPI_TransmitReceive+0x338>
 8015de2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8015de4:	2b00      	cmp	r3, #0
 8015de6:	d114      	bne.n	8015e12 <HAL_SPI_TransmitReceive+0x362>
      {
        /* Call standard close procedure with error check */
        SPI_CloseTransfer(hspi);
 8015de8:	68f8      	ldr	r0, [r7, #12]
 8015dea:	f000 fae9 	bl	80163c0 <SPI_CloseTransfer>

        SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_TIMEOUT);
 8015dee:	68fb      	ldr	r3, [r7, #12]
 8015df0:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8015df4:	f443 7280 	orr.w	r2, r3, #256	@ 0x100
 8015df8:	68fb      	ldr	r3, [r7, #12]
 8015dfa:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
        hspi->State = HAL_SPI_STATE_READY;
 8015dfe:	68fb      	ldr	r3, [r7, #12]
 8015e00:	2201      	movs	r2, #1
 8015e02:	f883 2089 	strb.w	r2, [r3, #137]	@ 0x89

        /* Unlock the process */
        __HAL_UNLOCK(hspi);
 8015e06:	68fb      	ldr	r3, [r7, #12]
 8015e08:	2200      	movs	r2, #0
 8015e0a:	f883 2088 	strb.w	r2, [r3, #136]	@ 0x88

        return HAL_TIMEOUT;
 8015e0e:	2303      	movs	r3, #3
 8015e10:	e0a4      	b.n	8015f5c <HAL_SPI_TransmitReceive+0x4ac>
    while ((initial_TxXferCount > 0UL) || (initial_RxXferCount > 0UL))
 8015e12:	8c7b      	ldrh	r3, [r7, #34]	@ 0x22
 8015e14:	2b00      	cmp	r3, #0
 8015e16:	d18f      	bne.n	8015d38 <HAL_SPI_TransmitReceive+0x288>
 8015e18:	8c3b      	ldrh	r3, [r7, #32]
 8015e1a:	2b00      	cmp	r3, #0
 8015e1c:	d18c      	bne.n	8015d38 <HAL_SPI_TransmitReceive+0x288>
 8015e1e:	e077      	b.n	8015f10 <HAL_SPI_TransmitReceive+0x460>
  else
  {
    while ((initial_TxXferCount > 0UL) || (initial_RxXferCount > 0UL))
    {
      /* Check the TXP flag */
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXP)) && (initial_TxXferCount > 0UL) &&
 8015e20:	68fb      	ldr	r3, [r7, #12]
 8015e22:	681b      	ldr	r3, [r3, #0]
 8015e24:	695b      	ldr	r3, [r3, #20]
 8015e26:	f003 0302 	and.w	r3, r3, #2
 8015e2a:	2b02      	cmp	r3, #2
 8015e2c:	d121      	bne.n	8015e72 <HAL_SPI_TransmitReceive+0x3c2>
 8015e2e:	8c7b      	ldrh	r3, [r7, #34]	@ 0x22
 8015e30:	2b00      	cmp	r3, #0
 8015e32:	d01e      	beq.n	8015e72 <HAL_SPI_TransmitReceive+0x3c2>
          (initial_RxXferCount  < (initial_TxXferCount + fifo_length)))
 8015e34:	8c3a      	ldrh	r2, [r7, #32]
 8015e36:	8c79      	ldrh	r1, [r7, #34]	@ 0x22
 8015e38:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8015e3a:	440b      	add	r3, r1
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXP)) && (initial_TxXferCount > 0UL) &&
 8015e3c:	429a      	cmp	r2, r3
 8015e3e:	d218      	bcs.n	8015e72 <HAL_SPI_TransmitReceive+0x3c2>
      {
        *((__IO uint8_t *)&hspi->Instance->TXDR) = *((const uint8_t *)hspi->pTxBuffPtr);
 8015e40:	68fb      	ldr	r3, [r7, #12]
 8015e42:	6e5a      	ldr	r2, [r3, #100]	@ 0x64
 8015e44:	68fb      	ldr	r3, [r7, #12]
 8015e46:	681b      	ldr	r3, [r3, #0]
 8015e48:	3320      	adds	r3, #32
 8015e4a:	7812      	ldrb	r2, [r2, #0]
 8015e4c:	701a      	strb	r2, [r3, #0]
        hspi->pTxBuffPtr += sizeof(uint8_t);
 8015e4e:	68fb      	ldr	r3, [r7, #12]
 8015e50:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8015e52:	1c5a      	adds	r2, r3, #1
 8015e54:	68fb      	ldr	r3, [r7, #12]
 8015e56:	665a      	str	r2, [r3, #100]	@ 0x64
        hspi->TxXferCount--;
 8015e58:	68fb      	ldr	r3, [r7, #12]
 8015e5a:	f8b3 306a 	ldrh.w	r3, [r3, #106]	@ 0x6a
 8015e5e:	b29b      	uxth	r3, r3
 8015e60:	3b01      	subs	r3, #1
 8015e62:	b29a      	uxth	r2, r3
 8015e64:	68fb      	ldr	r3, [r7, #12]
 8015e66:	f8a3 206a 	strh.w	r2, [r3, #106]	@ 0x6a
        initial_TxXferCount = hspi->TxXferCount;
 8015e6a:	68fb      	ldr	r3, [r7, #12]
 8015e6c:	f8b3 306a 	ldrh.w	r3, [r3, #106]	@ 0x6a
 8015e70:	847b      	strh	r3, [r7, #34]	@ 0x22
      }

      /* Check the RXP flag */
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXP)) && (initial_RxXferCount > 0UL))
 8015e72:	68fb      	ldr	r3, [r7, #12]
 8015e74:	681b      	ldr	r3, [r3, #0]
 8015e76:	695b      	ldr	r3, [r3, #20]
 8015e78:	f003 0301 	and.w	r3, r3, #1
 8015e7c:	2b01      	cmp	r3, #1
 8015e7e:	d11d      	bne.n	8015ebc <HAL_SPI_TransmitReceive+0x40c>
 8015e80:	8c3b      	ldrh	r3, [r7, #32]
 8015e82:	2b00      	cmp	r3, #0
 8015e84:	d01a      	beq.n	8015ebc <HAL_SPI_TransmitReceive+0x40c>
      {
        *((uint8_t *)hspi->pRxBuffPtr) = *((__IO uint8_t *)&hspi->Instance->RXDR);
 8015e86:	68fb      	ldr	r3, [r7, #12]
 8015e88:	681b      	ldr	r3, [r3, #0]
 8015e8a:	f103 0230 	add.w	r2, r3, #48	@ 0x30
 8015e8e:	68fb      	ldr	r3, [r7, #12]
 8015e90:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 8015e92:	7812      	ldrb	r2, [r2, #0]
 8015e94:	b2d2      	uxtb	r2, r2
 8015e96:	701a      	strb	r2, [r3, #0]
        hspi->pRxBuffPtr += sizeof(uint8_t);
 8015e98:	68fb      	ldr	r3, [r7, #12]
 8015e9a:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 8015e9c:	1c5a      	adds	r2, r3, #1
 8015e9e:	68fb      	ldr	r3, [r7, #12]
 8015ea0:	66da      	str	r2, [r3, #108]	@ 0x6c
        hspi->RxXferCount--;
 8015ea2:	68fb      	ldr	r3, [r7, #12]
 8015ea4:	f8b3 3072 	ldrh.w	r3, [r3, #114]	@ 0x72
 8015ea8:	b29b      	uxth	r3, r3
 8015eaa:	3b01      	subs	r3, #1
 8015eac:	b29a      	uxth	r2, r3
 8015eae:	68fb      	ldr	r3, [r7, #12]
 8015eb0:	f8a3 2072 	strh.w	r2, [r3, #114]	@ 0x72
        initial_RxXferCount = hspi->RxXferCount;
 8015eb4:	68fb      	ldr	r3, [r7, #12]
 8015eb6:	f8b3 3072 	ldrh.w	r3, [r3, #114]	@ 0x72
 8015eba:	843b      	strh	r3, [r7, #32]
      }

      /* Timeout management */
      if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 8015ebc:	f7f7 fdd0 	bl	800da60 <HAL_GetTick>
 8015ec0:	4602      	mov	r2, r0
 8015ec2:	697b      	ldr	r3, [r7, #20]
 8015ec4:	1ad3      	subs	r3, r2, r3
 8015ec6:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8015ec8:	429a      	cmp	r2, r3
 8015eca:	d803      	bhi.n	8015ed4 <HAL_SPI_TransmitReceive+0x424>
 8015ecc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8015ece:	f1b3 3fff 	cmp.w	r3, #4294967295
 8015ed2:	d102      	bne.n	8015eda <HAL_SPI_TransmitReceive+0x42a>
 8015ed4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8015ed6:	2b00      	cmp	r3, #0
 8015ed8:	d114      	bne.n	8015f04 <HAL_SPI_TransmitReceive+0x454>
      {
        /* Call standard close procedure with error check */
        SPI_CloseTransfer(hspi);
 8015eda:	68f8      	ldr	r0, [r7, #12]
 8015edc:	f000 fa70 	bl	80163c0 <SPI_CloseTransfer>

        SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_TIMEOUT);
 8015ee0:	68fb      	ldr	r3, [r7, #12]
 8015ee2:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8015ee6:	f443 7280 	orr.w	r2, r3, #256	@ 0x100
 8015eea:	68fb      	ldr	r3, [r7, #12]
 8015eec:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
        hspi->State = HAL_SPI_STATE_READY;
 8015ef0:	68fb      	ldr	r3, [r7, #12]
 8015ef2:	2201      	movs	r2, #1
 8015ef4:	f883 2089 	strb.w	r2, [r3, #137]	@ 0x89

        /* Unlock the process */
        __HAL_UNLOCK(hspi);
 8015ef8:	68fb      	ldr	r3, [r7, #12]
 8015efa:	2200      	movs	r2, #0
 8015efc:	f883 2088 	strb.w	r2, [r3, #136]	@ 0x88

        return HAL_TIMEOUT;
 8015f00:	2303      	movs	r3, #3
 8015f02:	e02b      	b.n	8015f5c <HAL_SPI_TransmitReceive+0x4ac>
    while ((initial_TxXferCount > 0UL) || (initial_RxXferCount > 0UL))
 8015f04:	8c7b      	ldrh	r3, [r7, #34]	@ 0x22
 8015f06:	2b00      	cmp	r3, #0
 8015f08:	d18a      	bne.n	8015e20 <HAL_SPI_TransmitReceive+0x370>
 8015f0a:	8c3b      	ldrh	r3, [r7, #32]
 8015f0c:	2b00      	cmp	r3, #0
 8015f0e:	d187      	bne.n	8015e20 <HAL_SPI_TransmitReceive+0x370>
      }
    }
  }

  /* Wait for Tx/Rx (and CRC) data to be sent/received */
  if (SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_EOT, RESET, Timeout, tickstart) != HAL_OK)
 8015f10:	697b      	ldr	r3, [r7, #20]
 8015f12:	9300      	str	r3, [sp, #0]
 8015f14:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8015f16:	2200      	movs	r2, #0
 8015f18:	2108      	movs	r1, #8
 8015f1a:	68f8      	ldr	r0, [r7, #12]
 8015f1c:	f000 faf0 	bl	8016500 <SPI_WaitOnFlagUntilTimeout>
 8015f20:	4603      	mov	r3, r0
 8015f22:	2b00      	cmp	r3, #0
 8015f24:	d007      	beq.n	8015f36 <HAL_SPI_TransmitReceive+0x486>
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8015f26:	68fb      	ldr	r3, [r7, #12]
 8015f28:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8015f2c:	f043 0220 	orr.w	r2, r3, #32
 8015f30:	68fb      	ldr	r3, [r7, #12]
 8015f32:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
  }

  /* Call standard close procedure with error check */
  SPI_CloseTransfer(hspi);
 8015f36:	68f8      	ldr	r0, [r7, #12]
 8015f38:	f000 fa42 	bl	80163c0 <SPI_CloseTransfer>

  hspi->State = HAL_SPI_STATE_READY;
 8015f3c:	68fb      	ldr	r3, [r7, #12]
 8015f3e:	2201      	movs	r2, #1
 8015f40:	f883 2089 	strb.w	r2, [r3, #137]	@ 0x89

  /* Unlock the process */
  __HAL_UNLOCK(hspi);
 8015f44:	68fb      	ldr	r3, [r7, #12]
 8015f46:	2200      	movs	r2, #0
 8015f48:	f883 2088 	strb.w	r2, [r3, #136]	@ 0x88

  if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 8015f4c:	68fb      	ldr	r3, [r7, #12]
 8015f4e:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8015f52:	2b00      	cmp	r3, #0
 8015f54:	d001      	beq.n	8015f5a <HAL_SPI_TransmitReceive+0x4aa>
  {
    return HAL_ERROR;
 8015f56:	2301      	movs	r3, #1
 8015f58:	e000      	b.n	8015f5c <HAL_SPI_TransmitReceive+0x4ac>
  }
  else
  {
    return HAL_OK;
 8015f5a:	2300      	movs	r3, #0
  }
}
 8015f5c:	4618      	mov	r0, r3
 8015f5e:	3728      	adds	r7, #40	@ 0x28
 8015f60:	46bd      	mov	sp, r7
 8015f62:	bd80      	pop	{r7, pc}

08015f64 <HAL_SPI_IRQHandler>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for the specified SPI module.
  * @retval None
  */
void HAL_SPI_IRQHandler(SPI_HandleTypeDef *hspi)
{
 8015f64:	b580      	push	{r7, lr}
 8015f66:	b08a      	sub	sp, #40	@ 0x28
 8015f68:	af00      	add	r7, sp, #0
 8015f6a:	6078      	str	r0, [r7, #4]
  uint32_t itsource = hspi->Instance->IER;
 8015f6c:	687b      	ldr	r3, [r7, #4]
 8015f6e:	681b      	ldr	r3, [r3, #0]
 8015f70:	691b      	ldr	r3, [r3, #16]
 8015f72:	623b      	str	r3, [r7, #32]
  uint32_t itflag   = hspi->Instance->SR;
 8015f74:	687b      	ldr	r3, [r7, #4]
 8015f76:	681b      	ldr	r3, [r3, #0]
 8015f78:	695b      	ldr	r3, [r3, #20]
 8015f7a:	61fb      	str	r3, [r7, #28]
  uint32_t trigger  = itsource & itflag;
 8015f7c:	6a3a      	ldr	r2, [r7, #32]
 8015f7e:	69fb      	ldr	r3, [r7, #28]
 8015f80:	4013      	ands	r3, r2
 8015f82:	61bb      	str	r3, [r7, #24]
  uint32_t cfg1     = hspi->Instance->CFG1;
 8015f84:	687b      	ldr	r3, [r7, #4]
 8015f86:	681b      	ldr	r3, [r3, #0]
 8015f88:	689b      	ldr	r3, [r3, #8]
 8015f8a:	617b      	str	r3, [r7, #20]
  uint32_t handled  = 0UL;
 8015f8c:	2300      	movs	r3, #0
 8015f8e:	627b      	str	r3, [r7, #36]	@ 0x24

  HAL_SPI_StateTypeDef State = hspi->State;
 8015f90:	687b      	ldr	r3, [r7, #4]
 8015f92:	f893 3089 	ldrb.w	r3, [r3, #137]	@ 0x89
 8015f96:	74fb      	strb	r3, [r7, #19]
#if defined (__GNUC__)
  __IO uint16_t *prxdr_16bits = (__IO uint16_t *)(&(hspi->Instance->RXDR));
 8015f98:	687b      	ldr	r3, [r7, #4]
 8015f9a:	681b      	ldr	r3, [r3, #0]
 8015f9c:	3330      	adds	r3, #48	@ 0x30
 8015f9e:	60fb      	str	r3, [r7, #12]
#endif /* __GNUC__ */

  /* SPI in SUSPEND mode  ----------------------------------------------------*/
  if (HAL_IS_BIT_SET(itflag, SPI_FLAG_SUSP) && HAL_IS_BIT_SET(itsource, SPI_FLAG_EOT))
 8015fa0:	69fb      	ldr	r3, [r7, #28]
 8015fa2:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 8015fa6:	2b00      	cmp	r3, #0
 8015fa8:	d010      	beq.n	8015fcc <HAL_SPI_IRQHandler+0x68>
 8015faa:	6a3b      	ldr	r3, [r7, #32]
 8015fac:	f003 0308 	and.w	r3, r3, #8
 8015fb0:	2b00      	cmp	r3, #0
 8015fb2:	d00b      	beq.n	8015fcc <HAL_SPI_IRQHandler+0x68>
  {
    /* Clear the Suspend flag */
    __HAL_SPI_CLEAR_SUSPFLAG(hspi);
 8015fb4:	687b      	ldr	r3, [r7, #4]
 8015fb6:	681b      	ldr	r3, [r3, #0]
 8015fb8:	699a      	ldr	r2, [r3, #24]
 8015fba:	687b      	ldr	r3, [r7, #4]
 8015fbc:	681b      	ldr	r3, [r3, #0]
 8015fbe:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
 8015fc2:	619a      	str	r2, [r3, #24]

    /* Suspend on going, Call the Suspend callback */
#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1UL)
    hspi->SuspendCallback(hspi);
#else
    HAL_SPI_SuspendCallback(hspi);
 8015fc4:	6878      	ldr	r0, [r7, #4]
 8015fc6:	f000 f9c9 	bl	801635c <HAL_SPI_SuspendCallback>
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
    return;
 8015fca:	e19a      	b.n	8016302 <HAL_SPI_IRQHandler+0x39e>
  }

  /* SPI in mode Transmitter and Receiver ------------------------------------*/
  if (HAL_IS_BIT_CLR(trigger, SPI_FLAG_OVR) && HAL_IS_BIT_CLR(trigger, SPI_FLAG_UDR) && \
 8015fcc:	69bb      	ldr	r3, [r7, #24]
 8015fce:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8015fd2:	2b00      	cmp	r3, #0
 8015fd4:	d113      	bne.n	8015ffe <HAL_SPI_IRQHandler+0x9a>
 8015fd6:	69bb      	ldr	r3, [r7, #24]
 8015fd8:	f003 0320 	and.w	r3, r3, #32
 8015fdc:	2b00      	cmp	r3, #0
 8015fde:	d10e      	bne.n	8015ffe <HAL_SPI_IRQHandler+0x9a>
      HAL_IS_BIT_SET(trigger, SPI_FLAG_DXP))
 8015fe0:	69bb      	ldr	r3, [r7, #24]
 8015fe2:	f003 0304 	and.w	r3, r3, #4
  if (HAL_IS_BIT_CLR(trigger, SPI_FLAG_OVR) && HAL_IS_BIT_CLR(trigger, SPI_FLAG_UDR) && \
 8015fe6:	2b00      	cmp	r3, #0
 8015fe8:	d009      	beq.n	8015ffe <HAL_SPI_IRQHandler+0x9a>
  {
    hspi->TxISR(hspi);
 8015fea:	687b      	ldr	r3, [r7, #4]
 8015fec:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
 8015fee:	6878      	ldr	r0, [r7, #4]
 8015ff0:	4798      	blx	r3
    hspi->RxISR(hspi);
 8015ff2:	687b      	ldr	r3, [r7, #4]
 8015ff4:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 8015ff6:	6878      	ldr	r0, [r7, #4]
 8015ff8:	4798      	blx	r3
    handled = 1UL;
 8015ffa:	2301      	movs	r3, #1
 8015ffc:	627b      	str	r3, [r7, #36]	@ 0x24
  }

  /* SPI in mode Receiver ----------------------------------------------------*/
  if (HAL_IS_BIT_CLR(trigger, SPI_FLAG_OVR) && HAL_IS_BIT_SET(trigger, SPI_FLAG_RXP) && \
 8015ffe:	69bb      	ldr	r3, [r7, #24]
 8016000:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8016004:	2b00      	cmp	r3, #0
 8016006:	d10f      	bne.n	8016028 <HAL_SPI_IRQHandler+0xc4>
 8016008:	69bb      	ldr	r3, [r7, #24]
 801600a:	f003 0301 	and.w	r3, r3, #1
 801600e:	2b00      	cmp	r3, #0
 8016010:	d00a      	beq.n	8016028 <HAL_SPI_IRQHandler+0xc4>
      HAL_IS_BIT_CLR(trigger, SPI_FLAG_DXP))
 8016012:	69bb      	ldr	r3, [r7, #24]
 8016014:	f003 0304 	and.w	r3, r3, #4
  if (HAL_IS_BIT_CLR(trigger, SPI_FLAG_OVR) && HAL_IS_BIT_SET(trigger, SPI_FLAG_RXP) && \
 8016018:	2b00      	cmp	r3, #0
 801601a:	d105      	bne.n	8016028 <HAL_SPI_IRQHandler+0xc4>
  {
    hspi->RxISR(hspi);
 801601c:	687b      	ldr	r3, [r7, #4]
 801601e:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 8016020:	6878      	ldr	r0, [r7, #4]
 8016022:	4798      	blx	r3
    handled = 1UL;
 8016024:	2301      	movs	r3, #1
 8016026:	627b      	str	r3, [r7, #36]	@ 0x24
  }

  /* SPI in mode Transmitter -------------------------------------------------*/
  if (HAL_IS_BIT_CLR(trigger, SPI_FLAG_UDR) && HAL_IS_BIT_SET(trigger, SPI_FLAG_TXP) && \
 8016028:	69bb      	ldr	r3, [r7, #24]
 801602a:	f003 0320 	and.w	r3, r3, #32
 801602e:	2b00      	cmp	r3, #0
 8016030:	d10f      	bne.n	8016052 <HAL_SPI_IRQHandler+0xee>
 8016032:	69bb      	ldr	r3, [r7, #24]
 8016034:	f003 0302 	and.w	r3, r3, #2
 8016038:	2b00      	cmp	r3, #0
 801603a:	d00a      	beq.n	8016052 <HAL_SPI_IRQHandler+0xee>
      HAL_IS_BIT_CLR(trigger, SPI_FLAG_DXP))
 801603c:	69bb      	ldr	r3, [r7, #24]
 801603e:	f003 0304 	and.w	r3, r3, #4
  if (HAL_IS_BIT_CLR(trigger, SPI_FLAG_UDR) && HAL_IS_BIT_SET(trigger, SPI_FLAG_TXP) && \
 8016042:	2b00      	cmp	r3, #0
 8016044:	d105      	bne.n	8016052 <HAL_SPI_IRQHandler+0xee>
  {
    hspi->TxISR(hspi);
 8016046:	687b      	ldr	r3, [r7, #4]
 8016048:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
 801604a:	6878      	ldr	r0, [r7, #4]
 801604c:	4798      	blx	r3
    handled = 1UL;
 801604e:	2301      	movs	r3, #1
 8016050:	627b      	str	r3, [r7, #36]	@ 0x24
  }

  if (handled != 0UL)
 8016052:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016054:	2b00      	cmp	r3, #0
 8016056:	f040 814f 	bne.w	80162f8 <HAL_SPI_IRQHandler+0x394>
  {
    return;
  }

  /* SPI End Of Transfer: DMA or IT based transfer */
  if (HAL_IS_BIT_SET(trigger, SPI_FLAG_EOT))
 801605a:	69bb      	ldr	r3, [r7, #24]
 801605c:	f003 0308 	and.w	r3, r3, #8
 8016060:	2b00      	cmp	r3, #0
 8016062:	f000 808b 	beq.w	801617c <HAL_SPI_IRQHandler+0x218>
  {
    /* Clear EOT/TXTF/SUSP flag */
    __HAL_SPI_CLEAR_EOTFLAG(hspi);
 8016066:	687b      	ldr	r3, [r7, #4]
 8016068:	681b      	ldr	r3, [r3, #0]
 801606a:	699a      	ldr	r2, [r3, #24]
 801606c:	687b      	ldr	r3, [r7, #4]
 801606e:	681b      	ldr	r3, [r3, #0]
 8016070:	f042 0208 	orr.w	r2, r2, #8
 8016074:	619a      	str	r2, [r3, #24]
    __HAL_SPI_CLEAR_TXTFFLAG(hspi);
 8016076:	687b      	ldr	r3, [r7, #4]
 8016078:	681b      	ldr	r3, [r3, #0]
 801607a:	699a      	ldr	r2, [r3, #24]
 801607c:	687b      	ldr	r3, [r7, #4]
 801607e:	681b      	ldr	r3, [r3, #0]
 8016080:	f042 0210 	orr.w	r2, r2, #16
 8016084:	619a      	str	r2, [r3, #24]
    __HAL_SPI_CLEAR_SUSPFLAG(hspi);
 8016086:	687b      	ldr	r3, [r7, #4]
 8016088:	681b      	ldr	r3, [r3, #0]
 801608a:	699a      	ldr	r2, [r3, #24]
 801608c:	687b      	ldr	r3, [r7, #4]
 801608e:	681b      	ldr	r3, [r3, #0]
 8016090:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
 8016094:	619a      	str	r2, [r3, #24]

    /* Disable EOT interrupt */
    __HAL_SPI_DISABLE_IT(hspi, SPI_IT_EOT);
 8016096:	687b      	ldr	r3, [r7, #4]
 8016098:	681b      	ldr	r3, [r3, #0]
 801609a:	691a      	ldr	r2, [r3, #16]
 801609c:	687b      	ldr	r3, [r7, #4]
 801609e:	681b      	ldr	r3, [r3, #0]
 80160a0:	f022 0208 	bic.w	r2, r2, #8
 80160a4:	611a      	str	r2, [r3, #16]

    /* For the IT based receive extra polling maybe required for last packet */
    if (HAL_IS_BIT_CLR(hspi->Instance->CFG1, SPI_CFG1_TXDMAEN | SPI_CFG1_RXDMAEN))
 80160a6:	687b      	ldr	r3, [r7, #4]
 80160a8:	681b      	ldr	r3, [r3, #0]
 80160aa:	689b      	ldr	r3, [r3, #8]
 80160ac:	f403 4340 	and.w	r3, r3, #49152	@ 0xc000
 80160b0:	2b00      	cmp	r3, #0
 80160b2:	d13d      	bne.n	8016130 <HAL_SPI_IRQHandler+0x1cc>
    {
      /* Pooling remaining data */
      while (hspi->RxXferCount != 0UL)
 80160b4:	e036      	b.n	8016124 <HAL_SPI_IRQHandler+0x1c0>
      {
        /* Receive data in 32 Bit mode */
        if (hspi->Init.DataSize > SPI_DATASIZE_16BIT)
 80160b6:	687b      	ldr	r3, [r7, #4]
 80160b8:	68db      	ldr	r3, [r3, #12]
 80160ba:	2b0f      	cmp	r3, #15
 80160bc:	d90b      	bls.n	80160d6 <HAL_SPI_IRQHandler+0x172>
        {
          *((uint32_t *)hspi->pRxBuffPtr) = *((__IO uint32_t *)&hspi->Instance->RXDR);
 80160be:	687b      	ldr	r3, [r7, #4]
 80160c0:	681a      	ldr	r2, [r3, #0]
 80160c2:	687b      	ldr	r3, [r7, #4]
 80160c4:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 80160c6:	6b12      	ldr	r2, [r2, #48]	@ 0x30
 80160c8:	601a      	str	r2, [r3, #0]
          hspi->pRxBuffPtr += sizeof(uint32_t);
 80160ca:	687b      	ldr	r3, [r7, #4]
 80160cc:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 80160ce:	1d1a      	adds	r2, r3, #4
 80160d0:	687b      	ldr	r3, [r7, #4]
 80160d2:	66da      	str	r2, [r3, #108]	@ 0x6c
 80160d4:	e01d      	b.n	8016112 <HAL_SPI_IRQHandler+0x1ae>
        }
        /* Receive data in 16 Bit mode */
        else if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 80160d6:	687b      	ldr	r3, [r7, #4]
 80160d8:	68db      	ldr	r3, [r3, #12]
 80160da:	2b07      	cmp	r3, #7
 80160dc:	d90b      	bls.n	80160f6 <HAL_SPI_IRQHandler+0x192>
        {
#if defined (__GNUC__)
          *((uint16_t *)hspi->pRxBuffPtr) = *prxdr_16bits;
 80160de:	687b      	ldr	r3, [r7, #4]
 80160e0:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 80160e2:	68fa      	ldr	r2, [r7, #12]
 80160e4:	8812      	ldrh	r2, [r2, #0]
 80160e6:	b292      	uxth	r2, r2
 80160e8:	801a      	strh	r2, [r3, #0]
#else
          *((uint16_t *)hspi->pRxBuffPtr) = *((__IO uint16_t *)&hspi->Instance->RXDR);
#endif /* __GNUC__ */
          hspi->pRxBuffPtr += sizeof(uint16_t);
 80160ea:	687b      	ldr	r3, [r7, #4]
 80160ec:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 80160ee:	1c9a      	adds	r2, r3, #2
 80160f0:	687b      	ldr	r3, [r7, #4]
 80160f2:	66da      	str	r2, [r3, #108]	@ 0x6c
 80160f4:	e00d      	b.n	8016112 <HAL_SPI_IRQHandler+0x1ae>
        }
        /* Receive data in 8 Bit mode */
        else
        {
          *((uint8_t *)hspi->pRxBuffPtr) = *((__IO uint8_t *)&hspi->Instance->RXDR);
 80160f6:	687b      	ldr	r3, [r7, #4]
 80160f8:	681b      	ldr	r3, [r3, #0]
 80160fa:	f103 0230 	add.w	r2, r3, #48	@ 0x30
 80160fe:	687b      	ldr	r3, [r7, #4]
 8016100:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 8016102:	7812      	ldrb	r2, [r2, #0]
 8016104:	b2d2      	uxtb	r2, r2
 8016106:	701a      	strb	r2, [r3, #0]
          hspi->pRxBuffPtr += sizeof(uint8_t);
 8016108:	687b      	ldr	r3, [r7, #4]
 801610a:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 801610c:	1c5a      	adds	r2, r3, #1
 801610e:	687b      	ldr	r3, [r7, #4]
 8016110:	66da      	str	r2, [r3, #108]	@ 0x6c
        }

        hspi->RxXferCount--;
 8016112:	687b      	ldr	r3, [r7, #4]
 8016114:	f8b3 3072 	ldrh.w	r3, [r3, #114]	@ 0x72
 8016118:	b29b      	uxth	r3, r3
 801611a:	3b01      	subs	r3, #1
 801611c:	b29a      	uxth	r2, r3
 801611e:	687b      	ldr	r3, [r7, #4]
 8016120:	f8a3 2072 	strh.w	r2, [r3, #114]	@ 0x72
      while (hspi->RxXferCount != 0UL)
 8016124:	687b      	ldr	r3, [r7, #4]
 8016126:	f8b3 3072 	ldrh.w	r3, [r3, #114]	@ 0x72
 801612a:	b29b      	uxth	r3, r3
 801612c:	2b00      	cmp	r3, #0
 801612e:	d1c2      	bne.n	80160b6 <HAL_SPI_IRQHandler+0x152>
      }
    }

    /* Call SPI Standard close procedure */
    SPI_CloseTransfer(hspi);
 8016130:	6878      	ldr	r0, [r7, #4]
 8016132:	f000 f945 	bl	80163c0 <SPI_CloseTransfer>

    hspi->State = HAL_SPI_STATE_READY;
 8016136:	687b      	ldr	r3, [r7, #4]
 8016138:	2201      	movs	r2, #1
 801613a:	f883 2089 	strb.w	r2, [r3, #137]	@ 0x89
    if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 801613e:	687b      	ldr	r3, [r7, #4]
 8016140:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8016144:	2b00      	cmp	r3, #0
 8016146:	d003      	beq.n	8016150 <HAL_SPI_IRQHandler+0x1ec>
    {
#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1UL)
      hspi->ErrorCallback(hspi);
#else
      HAL_SPI_ErrorCallback(hspi);
 8016148:	6878      	ldr	r0, [r7, #4]
 801614a:	f000 f8fd 	bl	8016348 <HAL_SPI_ErrorCallback>
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
      return;
 801614e:	e0d8      	b.n	8016302 <HAL_SPI_IRQHandler+0x39e>
    {
      hspi->TxCpltCallback(hspi);
    }
#else
    /* Call appropriate user callback */
    if (State == HAL_SPI_STATE_BUSY_TX_RX)
 8016150:	7cfb      	ldrb	r3, [r7, #19]
 8016152:	2b05      	cmp	r3, #5
 8016154:	d103      	bne.n	801615e <HAL_SPI_IRQHandler+0x1fa>
    {
      HAL_SPI_TxRxCpltCallback(hspi);
 8016156:	6878      	ldr	r0, [r7, #4]
 8016158:	f000 f8ec 	bl	8016334 <HAL_SPI_TxRxCpltCallback>
    else
    {
      /* End of the appropriate call */
    }

    return;
 801615c:	e0ce      	b.n	80162fc <HAL_SPI_IRQHandler+0x398>
    else if (State == HAL_SPI_STATE_BUSY_RX)
 801615e:	7cfb      	ldrb	r3, [r7, #19]
 8016160:	2b04      	cmp	r3, #4
 8016162:	d103      	bne.n	801616c <HAL_SPI_IRQHandler+0x208>
      HAL_SPI_RxCpltCallback(hspi);
 8016164:	6878      	ldr	r0, [r7, #4]
 8016166:	f000 f8db 	bl	8016320 <HAL_SPI_RxCpltCallback>
    return;
 801616a:	e0c7      	b.n	80162fc <HAL_SPI_IRQHandler+0x398>
    else if (State == HAL_SPI_STATE_BUSY_TX)
 801616c:	7cfb      	ldrb	r3, [r7, #19]
 801616e:	2b03      	cmp	r3, #3
 8016170:	f040 80c4 	bne.w	80162fc <HAL_SPI_IRQHandler+0x398>
      HAL_SPI_TxCpltCallback(hspi);
 8016174:	6878      	ldr	r0, [r7, #4]
 8016176:	f000 f8c9 	bl	801630c <HAL_SPI_TxCpltCallback>
    return;
 801617a:	e0bf      	b.n	80162fc <HAL_SPI_IRQHandler+0x398>
  }

  /* SPI in Error Treatment --------------------------------------------------*/
  if ((trigger & (SPI_FLAG_MODF | SPI_FLAG_OVR | SPI_FLAG_FRE | SPI_FLAG_UDR)) != 0UL)
 801617c:	69bb      	ldr	r3, [r7, #24]
 801617e:	f403 7358 	and.w	r3, r3, #864	@ 0x360
 8016182:	2b00      	cmp	r3, #0
 8016184:	f000 80bd 	beq.w	8016302 <HAL_SPI_IRQHandler+0x39e>
  {
    /* SPI Overrun error interrupt occurred ----------------------------------*/
    if ((trigger & SPI_FLAG_OVR) != 0UL)
 8016188:	69bb      	ldr	r3, [r7, #24]
 801618a:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 801618e:	2b00      	cmp	r3, #0
 8016190:	d00f      	beq.n	80161b2 <HAL_SPI_IRQHandler+0x24e>
    {
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_OVR);
 8016192:	687b      	ldr	r3, [r7, #4]
 8016194:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8016198:	f043 0204 	orr.w	r2, r3, #4
 801619c:	687b      	ldr	r3, [r7, #4]
 801619e:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
      __HAL_SPI_CLEAR_OVRFLAG(hspi);
 80161a2:	687b      	ldr	r3, [r7, #4]
 80161a4:	681b      	ldr	r3, [r3, #0]
 80161a6:	699a      	ldr	r2, [r3, #24]
 80161a8:	687b      	ldr	r3, [r7, #4]
 80161aa:	681b      	ldr	r3, [r3, #0]
 80161ac:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 80161b0:	619a      	str	r2, [r3, #24]
    }

    /* SPI Mode Fault error interrupt occurred -------------------------------*/
    if ((trigger & SPI_FLAG_MODF) != 0UL)
 80161b2:	69bb      	ldr	r3, [r7, #24]
 80161b4:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 80161b8:	2b00      	cmp	r3, #0
 80161ba:	d00f      	beq.n	80161dc <HAL_SPI_IRQHandler+0x278>
    {
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_MODF);
 80161bc:	687b      	ldr	r3, [r7, #4]
 80161be:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 80161c2:	f043 0201 	orr.w	r2, r3, #1
 80161c6:	687b      	ldr	r3, [r7, #4]
 80161c8:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
      __HAL_SPI_CLEAR_MODFFLAG(hspi);
 80161cc:	687b      	ldr	r3, [r7, #4]
 80161ce:	681b      	ldr	r3, [r3, #0]
 80161d0:	699a      	ldr	r2, [r3, #24]
 80161d2:	687b      	ldr	r3, [r7, #4]
 80161d4:	681b      	ldr	r3, [r3, #0]
 80161d6:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 80161da:	619a      	str	r2, [r3, #24]
    }

    /* SPI Frame error interrupt occurred ------------------------------------*/
    if ((trigger & SPI_FLAG_FRE) != 0UL)
 80161dc:	69bb      	ldr	r3, [r7, #24]
 80161de:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 80161e2:	2b00      	cmp	r3, #0
 80161e4:	d00f      	beq.n	8016206 <HAL_SPI_IRQHandler+0x2a2>
    {
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FRE);
 80161e6:	687b      	ldr	r3, [r7, #4]
 80161e8:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 80161ec:	f043 0208 	orr.w	r2, r3, #8
 80161f0:	687b      	ldr	r3, [r7, #4]
 80161f2:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
      __HAL_SPI_CLEAR_FREFLAG(hspi);
 80161f6:	687b      	ldr	r3, [r7, #4]
 80161f8:	681b      	ldr	r3, [r3, #0]
 80161fa:	699a      	ldr	r2, [r3, #24]
 80161fc:	687b      	ldr	r3, [r7, #4]
 80161fe:	681b      	ldr	r3, [r3, #0]
 8016200:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
 8016204:	619a      	str	r2, [r3, #24]
    }

    /* SPI Underrun error interrupt occurred ------------------------------------*/
    if ((trigger & SPI_FLAG_UDR) != 0UL)
 8016206:	69bb      	ldr	r3, [r7, #24]
 8016208:	f003 0320 	and.w	r3, r3, #32
 801620c:	2b00      	cmp	r3, #0
 801620e:	d00f      	beq.n	8016230 <HAL_SPI_IRQHandler+0x2cc>
    {
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_UDR);
 8016210:	687b      	ldr	r3, [r7, #4]
 8016212:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8016216:	f043 0280 	orr.w	r2, r3, #128	@ 0x80
 801621a:	687b      	ldr	r3, [r7, #4]
 801621c:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
      __HAL_SPI_CLEAR_UDRFLAG(hspi);
 8016220:	687b      	ldr	r3, [r7, #4]
 8016222:	681b      	ldr	r3, [r3, #0]
 8016224:	699a      	ldr	r2, [r3, #24]
 8016226:	687b      	ldr	r3, [r7, #4]
 8016228:	681b      	ldr	r3, [r3, #0]
 801622a:	f042 0220 	orr.w	r2, r2, #32
 801622e:	619a      	str	r2, [r3, #24]
    }

    if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 8016230:	687b      	ldr	r3, [r7, #4]
 8016232:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8016236:	2b00      	cmp	r3, #0
 8016238:	d062      	beq.n	8016300 <HAL_SPI_IRQHandler+0x39c>
    {
      /* Disable SPI peripheral */
      __HAL_SPI_DISABLE(hspi);
 801623a:	687b      	ldr	r3, [r7, #4]
 801623c:	681b      	ldr	r3, [r3, #0]
 801623e:	681a      	ldr	r2, [r3, #0]
 8016240:	687b      	ldr	r3, [r7, #4]
 8016242:	681b      	ldr	r3, [r3, #0]
 8016244:	f022 0201 	bic.w	r2, r2, #1
 8016248:	601a      	str	r2, [r3, #0]

      /* Disable all interrupts */
      __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_EOT | SPI_IT_RXP | SPI_IT_TXP | SPI_IT_MODF |
 801624a:	687b      	ldr	r3, [r7, #4]
 801624c:	681b      	ldr	r3, [r3, #0]
 801624e:	691b      	ldr	r3, [r3, #16]
 8016250:	687a      	ldr	r2, [r7, #4]
 8016252:	6812      	ldr	r2, [r2, #0]
 8016254:	f423 735a 	bic.w	r3, r3, #872	@ 0x368
 8016258:	f023 0303 	bic.w	r3, r3, #3
 801625c:	6113      	str	r3, [r2, #16]
                                  SPI_IT_OVR | SPI_IT_FRE | SPI_IT_UDR));

      /* Disable the SPI DMA requests if enabled */
      if (HAL_IS_BIT_SET(cfg1, SPI_CFG1_TXDMAEN | SPI_CFG1_RXDMAEN))
 801625e:	697b      	ldr	r3, [r7, #20]
 8016260:	f403 4340 	and.w	r3, r3, #49152	@ 0xc000
 8016264:	f5b3 4f40 	cmp.w	r3, #49152	@ 0xc000
 8016268:	d13e      	bne.n	80162e8 <HAL_SPI_IRQHandler+0x384>
      {
        /* Disable the SPI DMA requests */
        CLEAR_BIT(hspi->Instance->CFG1, SPI_CFG1_TXDMAEN | SPI_CFG1_RXDMAEN);
 801626a:	687b      	ldr	r3, [r7, #4]
 801626c:	681b      	ldr	r3, [r3, #0]
 801626e:	689a      	ldr	r2, [r3, #8]
 8016270:	687b      	ldr	r3, [r7, #4]
 8016272:	681b      	ldr	r3, [r3, #0]
 8016274:	f422 4240 	bic.w	r2, r2, #49152	@ 0xc000
 8016278:	609a      	str	r2, [r3, #8]

        /* Abort the SPI DMA Rx channel */
        if (hspi->hdmarx != NULL)
 801627a:	687b      	ldr	r3, [r7, #4]
 801627c:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 8016280:	2b00      	cmp	r3, #0
 8016282:	d015      	beq.n	80162b0 <HAL_SPI_IRQHandler+0x34c>
        {
          /* Set the SPI DMA Abort callback :
          will lead to call HAL_SPI_ErrorCallback() at end of DMA abort procedure */
          hspi->hdmarx->XferAbortCallback = SPI_DMAAbortOnError;
 8016284:	687b      	ldr	r3, [r7, #4]
 8016286:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 801628a:	4a1f      	ldr	r2, [pc, #124]	@ (8016308 <HAL_SPI_IRQHandler+0x3a4>)
 801628c:	66da      	str	r2, [r3, #108]	@ 0x6c
          if (HAL_OK != HAL_DMA_Abort_IT(hspi->hdmarx))
 801628e:	687b      	ldr	r3, [r7, #4]
 8016290:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 8016294:	4618      	mov	r0, r3
 8016296:	f7f8 fa23 	bl	800e6e0 <HAL_DMA_Abort_IT>
 801629a:	4603      	mov	r3, r0
 801629c:	2b00      	cmp	r3, #0
 801629e:	d007      	beq.n	80162b0 <HAL_SPI_IRQHandler+0x34c>
          {
            SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
 80162a0:	687b      	ldr	r3, [r7, #4]
 80162a2:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 80162a6:	f043 0240 	orr.w	r2, r3, #64	@ 0x40
 80162aa:	687b      	ldr	r3, [r7, #4]
 80162ac:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
          }
        }
        /* Abort the SPI DMA Tx channel */
        if (hspi->hdmatx != NULL)
 80162b0:	687b      	ldr	r3, [r7, #4]
 80162b2:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 80162b6:	2b00      	cmp	r3, #0
 80162b8:	d022      	beq.n	8016300 <HAL_SPI_IRQHandler+0x39c>
        {
          /* Set the SPI DMA Abort callback :
          will lead to call HAL_SPI_ErrorCallback() at end of DMA abort procedure */
          hspi->hdmatx->XferAbortCallback = SPI_DMAAbortOnError;
 80162ba:	687b      	ldr	r3, [r7, #4]
 80162bc:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 80162c0:	4a11      	ldr	r2, [pc, #68]	@ (8016308 <HAL_SPI_IRQHandler+0x3a4>)
 80162c2:	66da      	str	r2, [r3, #108]	@ 0x6c
          if (HAL_OK != HAL_DMA_Abort_IT(hspi->hdmatx))
 80162c4:	687b      	ldr	r3, [r7, #4]
 80162c6:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 80162ca:	4618      	mov	r0, r3
 80162cc:	f7f8 fa08 	bl	800e6e0 <HAL_DMA_Abort_IT>
 80162d0:	4603      	mov	r3, r0
 80162d2:	2b00      	cmp	r3, #0
 80162d4:	d014      	beq.n	8016300 <HAL_SPI_IRQHandler+0x39c>
          {
            SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
 80162d6:	687b      	ldr	r3, [r7, #4]
 80162d8:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 80162dc:	f043 0240 	orr.w	r2, r3, #64	@ 0x40
 80162e0:	687b      	ldr	r3, [r7, #4]
 80162e2:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
#else
        HAL_SPI_ErrorCallback(hspi);
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
      }
    }
    return;
 80162e6:	e00b      	b.n	8016300 <HAL_SPI_IRQHandler+0x39c>
        hspi->State = HAL_SPI_STATE_READY;
 80162e8:	687b      	ldr	r3, [r7, #4]
 80162ea:	2201      	movs	r2, #1
 80162ec:	f883 2089 	strb.w	r2, [r3, #137]	@ 0x89
        HAL_SPI_ErrorCallback(hspi);
 80162f0:	6878      	ldr	r0, [r7, #4]
 80162f2:	f000 f829 	bl	8016348 <HAL_SPI_ErrorCallback>
    return;
 80162f6:	e003      	b.n	8016300 <HAL_SPI_IRQHandler+0x39c>
    return;
 80162f8:	bf00      	nop
 80162fa:	e002      	b.n	8016302 <HAL_SPI_IRQHandler+0x39e>
    return;
 80162fc:	bf00      	nop
 80162fe:	e000      	b.n	8016302 <HAL_SPI_IRQHandler+0x39e>
    return;
 8016300:	bf00      	nop
  }
}
 8016302:	3728      	adds	r7, #40	@ 0x28
 8016304:	46bd      	mov	sp, r7
 8016306:	bd80      	pop	{r7, pc}
 8016308:	0801638d 	.word	0x0801638d

0801630c <HAL_SPI_TxCpltCallback>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */
__weak void HAL_SPI_TxCpltCallback(SPI_HandleTypeDef *hspi) /* Derogation MISRAC2012-Rule-8.13 */
{
 801630c:	b480      	push	{r7}
 801630e:	b083      	sub	sp, #12
 8016310:	af00      	add	r7, sp, #0
 8016312:	6078      	str	r0, [r7, #4]
  UNUSED(hspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_SPI_TxCpltCallback should be implemented in the user file
   */
}
 8016314:	bf00      	nop
 8016316:	370c      	adds	r7, #12
 8016318:	46bd      	mov	sp, r7
 801631a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801631e:	4770      	bx	lr

08016320 <HAL_SPI_RxCpltCallback>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */
__weak void HAL_SPI_RxCpltCallback(SPI_HandleTypeDef *hspi) /* Derogation MISRAC2012-Rule-8.13 */
{
 8016320:	b480      	push	{r7}
 8016322:	b083      	sub	sp, #12
 8016324:	af00      	add	r7, sp, #0
 8016326:	6078      	str	r0, [r7, #4]
  UNUSED(hspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_SPI_RxCpltCallback should be implemented in the user file
   */
}
 8016328:	bf00      	nop
 801632a:	370c      	adds	r7, #12
 801632c:	46bd      	mov	sp, r7
 801632e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016332:	4770      	bx	lr

08016334 <HAL_SPI_TxRxCpltCallback>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */
__weak void HAL_SPI_TxRxCpltCallback(SPI_HandleTypeDef *hspi) /* Derogation MISRAC2012-Rule-8.13 */
{
 8016334:	b480      	push	{r7}
 8016336:	b083      	sub	sp, #12
 8016338:	af00      	add	r7, sp, #0
 801633a:	6078      	str	r0, [r7, #4]
  UNUSED(hspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_SPI_TxRxCpltCallback should be implemented in the user file
   */
}
 801633c:	bf00      	nop
 801633e:	370c      	adds	r7, #12
 8016340:	46bd      	mov	sp, r7
 8016342:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016346:	4770      	bx	lr

08016348 <HAL_SPI_ErrorCallback>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */
__weak void HAL_SPI_ErrorCallback(SPI_HandleTypeDef *hspi) /* Derogation MISRAC2012-Rule-8.13 */
{
 8016348:	b480      	push	{r7}
 801634a:	b083      	sub	sp, #12
 801634c:	af00      	add	r7, sp, #0
 801634e:	6078      	str	r0, [r7, #4]
            the HAL_SPI_ErrorCallback should be implemented in the user file
   */
  /* NOTE : The ErrorCode parameter in the hspi handle is updated by the SPI processes
            and user can use HAL_SPI_GetError() API to check the latest error occurred
   */
}
 8016350:	bf00      	nop
 8016352:	370c      	adds	r7, #12
 8016354:	46bd      	mov	sp, r7
 8016356:	f85d 7b04 	ldr.w	r7, [sp], #4
 801635a:	4770      	bx	lr

0801635c <HAL_SPI_SuspendCallback>:
  * @brief  SPI Suspend callback.
  * @param  hspi SPI handle.
  * @retval None
  */
__weak void HAL_SPI_SuspendCallback(SPI_HandleTypeDef *hspi) /* Derogation MISRAC2012-Rule-8.13 */
{
 801635c:	b480      	push	{r7}
 801635e:	b083      	sub	sp, #12
 8016360:	af00      	add	r7, sp, #0
 8016362:	6078      	str	r0, [r7, #4]
  UNUSED(hspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_SPI_SuspendCallback can be implemented in the user file.
   */
}
 8016364:	bf00      	nop
 8016366:	370c      	adds	r7, #12
 8016368:	46bd      	mov	sp, r7
 801636a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801636e:	4770      	bx	lr

08016370 <HAL_SPI_GetState>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval SPI state
  */
HAL_SPI_StateTypeDef HAL_SPI_GetState(const SPI_HandleTypeDef *hspi)
{
 8016370:	b480      	push	{r7}
 8016372:	b083      	sub	sp, #12
 8016374:	af00      	add	r7, sp, #0
 8016376:	6078      	str	r0, [r7, #4]
  /* Return SPI handle state */
  return hspi->State;
 8016378:	687b      	ldr	r3, [r7, #4]
 801637a:	f893 3089 	ldrb.w	r3, [r3, #137]	@ 0x89
 801637e:	b2db      	uxtb	r3, r3
}
 8016380:	4618      	mov	r0, r3
 8016382:	370c      	adds	r7, #12
 8016384:	46bd      	mov	sp, r7
 8016386:	f85d 7b04 	ldr.w	r7, [sp], #4
 801638a:	4770      	bx	lr

0801638c <SPI_DMAAbortOnError>:
  *         (To be called at end of DMA Abort procedure following error occurrence).
  * @param  hdma DMA handle.
  * @retval None
  */
static void SPI_DMAAbortOnError(DMA_HandleTypeDef *hdma)
{
 801638c:	b580      	push	{r7, lr}
 801638e:	b084      	sub	sp, #16
 8016390:	af00      	add	r7, sp, #0
 8016392:	6078      	str	r0, [r7, #4]
  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8016394:	687b      	ldr	r3, [r7, #4]
 8016396:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8016398:	60fb      	str	r3, [r7, #12]
  hspi->RxXferCount = (uint16_t) 0UL;
 801639a:	68fb      	ldr	r3, [r7, #12]
 801639c:	2200      	movs	r2, #0
 801639e:	f8a3 2072 	strh.w	r2, [r3, #114]	@ 0x72
  hspi->TxXferCount = (uint16_t) 0UL;
 80163a2:	68fb      	ldr	r3, [r7, #12]
 80163a4:	2200      	movs	r2, #0
 80163a6:	f8a3 206a 	strh.w	r2, [r3, #106]	@ 0x6a

  /* Restore hspi->State to Ready */
  hspi->State = HAL_SPI_STATE_READY;
 80163aa:	68fb      	ldr	r3, [r7, #12]
 80163ac:	2201      	movs	r2, #1
 80163ae:	f883 2089 	strb.w	r2, [r3, #137]	@ 0x89

#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1UL)
  hspi->ErrorCallback(hspi);
#else
  HAL_SPI_ErrorCallback(hspi);
 80163b2:	68f8      	ldr	r0, [r7, #12]
 80163b4:	f7ff ffc8 	bl	8016348 <HAL_SPI_ErrorCallback>
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
}
 80163b8:	bf00      	nop
 80163ba:	3710      	adds	r7, #16
 80163bc:	46bd      	mov	sp, r7
 80163be:	bd80      	pop	{r7, pc}

080163c0 <SPI_CloseTransfer>:
  *               the configuration information for SPI module.
  * @retval HAL_ERROR: if any error detected
  *         HAL_OK: if nothing detected
  */
static void SPI_CloseTransfer(SPI_HandleTypeDef *hspi)
{
 80163c0:	b480      	push	{r7}
 80163c2:	b085      	sub	sp, #20
 80163c4:	af00      	add	r7, sp, #0
 80163c6:	6078      	str	r0, [r7, #4]
  uint32_t itflag = hspi->Instance->SR;
 80163c8:	687b      	ldr	r3, [r7, #4]
 80163ca:	681b      	ldr	r3, [r3, #0]
 80163cc:	695b      	ldr	r3, [r3, #20]
 80163ce:	60fb      	str	r3, [r7, #12]

  __HAL_SPI_CLEAR_EOTFLAG(hspi);
 80163d0:	687b      	ldr	r3, [r7, #4]
 80163d2:	681b      	ldr	r3, [r3, #0]
 80163d4:	699a      	ldr	r2, [r3, #24]
 80163d6:	687b      	ldr	r3, [r7, #4]
 80163d8:	681b      	ldr	r3, [r3, #0]
 80163da:	f042 0208 	orr.w	r2, r2, #8
 80163de:	619a      	str	r2, [r3, #24]
  __HAL_SPI_CLEAR_TXTFFLAG(hspi);
 80163e0:	687b      	ldr	r3, [r7, #4]
 80163e2:	681b      	ldr	r3, [r3, #0]
 80163e4:	699a      	ldr	r2, [r3, #24]
 80163e6:	687b      	ldr	r3, [r7, #4]
 80163e8:	681b      	ldr	r3, [r3, #0]
 80163ea:	f042 0210 	orr.w	r2, r2, #16
 80163ee:	619a      	str	r2, [r3, #24]

  /* Disable SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 80163f0:	687b      	ldr	r3, [r7, #4]
 80163f2:	681b      	ldr	r3, [r3, #0]
 80163f4:	681a      	ldr	r2, [r3, #0]
 80163f6:	687b      	ldr	r3, [r7, #4]
 80163f8:	681b      	ldr	r3, [r3, #0]
 80163fa:	f022 0201 	bic.w	r2, r2, #1
 80163fe:	601a      	str	r2, [r3, #0]

  /* Disable ITs */
  __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_EOT | SPI_IT_TXP | SPI_IT_RXP | SPI_IT_DXP | SPI_IT_UDR | SPI_IT_OVR | \
 8016400:	687b      	ldr	r3, [r7, #4]
 8016402:	681b      	ldr	r3, [r3, #0]
 8016404:	691b      	ldr	r3, [r3, #16]
 8016406:	687a      	ldr	r2, [r7, #4]
 8016408:	6812      	ldr	r2, [r2, #0]
 801640a:	f423 735b 	bic.w	r3, r3, #876	@ 0x36c
 801640e:	f023 0303 	bic.w	r3, r3, #3
 8016412:	6113      	str	r3, [r2, #16]
                              SPI_IT_FRE | SPI_IT_MODF));

  /* Disable Tx DMA Request */
  CLEAR_BIT(hspi->Instance->CFG1, SPI_CFG1_TXDMAEN | SPI_CFG1_RXDMAEN);
 8016414:	687b      	ldr	r3, [r7, #4]
 8016416:	681b      	ldr	r3, [r3, #0]
 8016418:	689a      	ldr	r2, [r3, #8]
 801641a:	687b      	ldr	r3, [r7, #4]
 801641c:	681b      	ldr	r3, [r3, #0]
 801641e:	f422 4240 	bic.w	r2, r2, #49152	@ 0xc000
 8016422:	609a      	str	r2, [r3, #8]

  /* Report UnderRun error for non RX Only communication */
  if (hspi->State != HAL_SPI_STATE_BUSY_RX)
 8016424:	687b      	ldr	r3, [r7, #4]
 8016426:	f893 3089 	ldrb.w	r3, [r3, #137]	@ 0x89
 801642a:	b2db      	uxtb	r3, r3
 801642c:	2b04      	cmp	r3, #4
 801642e:	d014      	beq.n	801645a <SPI_CloseTransfer+0x9a>
  {
    if ((itflag & SPI_FLAG_UDR) != 0UL)
 8016430:	68fb      	ldr	r3, [r7, #12]
 8016432:	f003 0320 	and.w	r3, r3, #32
 8016436:	2b00      	cmp	r3, #0
 8016438:	d00f      	beq.n	801645a <SPI_CloseTransfer+0x9a>
    {
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_UDR);
 801643a:	687b      	ldr	r3, [r7, #4]
 801643c:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8016440:	f043 0280 	orr.w	r2, r3, #128	@ 0x80
 8016444:	687b      	ldr	r3, [r7, #4]
 8016446:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
      __HAL_SPI_CLEAR_UDRFLAG(hspi);
 801644a:	687b      	ldr	r3, [r7, #4]
 801644c:	681b      	ldr	r3, [r3, #0]
 801644e:	699a      	ldr	r2, [r3, #24]
 8016450:	687b      	ldr	r3, [r7, #4]
 8016452:	681b      	ldr	r3, [r3, #0]
 8016454:	f042 0220 	orr.w	r2, r2, #32
 8016458:	619a      	str	r2, [r3, #24]
    }
  }

  /* Report OverRun error for non TX Only communication */
  if (hspi->State != HAL_SPI_STATE_BUSY_TX)
 801645a:	687b      	ldr	r3, [r7, #4]
 801645c:	f893 3089 	ldrb.w	r3, [r3, #137]	@ 0x89
 8016460:	b2db      	uxtb	r3, r3
 8016462:	2b03      	cmp	r3, #3
 8016464:	d014      	beq.n	8016490 <SPI_CloseTransfer+0xd0>
  {
    if ((itflag & SPI_FLAG_OVR) != 0UL)
 8016466:	68fb      	ldr	r3, [r7, #12]
 8016468:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 801646c:	2b00      	cmp	r3, #0
 801646e:	d00f      	beq.n	8016490 <SPI_CloseTransfer+0xd0>
    {
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_OVR);
 8016470:	687b      	ldr	r3, [r7, #4]
 8016472:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8016476:	f043 0204 	orr.w	r2, r3, #4
 801647a:	687b      	ldr	r3, [r7, #4]
 801647c:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
      __HAL_SPI_CLEAR_OVRFLAG(hspi);
 8016480:	687b      	ldr	r3, [r7, #4]
 8016482:	681b      	ldr	r3, [r3, #0]
 8016484:	699a      	ldr	r2, [r3, #24]
 8016486:	687b      	ldr	r3, [r7, #4]
 8016488:	681b      	ldr	r3, [r3, #0]
 801648a:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 801648e:	619a      	str	r2, [r3, #24]
    }
#endif /* USE_SPI_CRC */
  }

  /* SPI Mode Fault error interrupt occurred -------------------------------*/
  if ((itflag & SPI_FLAG_MODF) != 0UL)
 8016490:	68fb      	ldr	r3, [r7, #12]
 8016492:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 8016496:	2b00      	cmp	r3, #0
 8016498:	d00f      	beq.n	80164ba <SPI_CloseTransfer+0xfa>
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_MODF);
 801649a:	687b      	ldr	r3, [r7, #4]
 801649c:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 80164a0:	f043 0201 	orr.w	r2, r3, #1
 80164a4:	687b      	ldr	r3, [r7, #4]
 80164a6:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
    __HAL_SPI_CLEAR_MODFFLAG(hspi);
 80164aa:	687b      	ldr	r3, [r7, #4]
 80164ac:	681b      	ldr	r3, [r3, #0]
 80164ae:	699a      	ldr	r2, [r3, #24]
 80164b0:	687b      	ldr	r3, [r7, #4]
 80164b2:	681b      	ldr	r3, [r3, #0]
 80164b4:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 80164b8:	619a      	str	r2, [r3, #24]
  }

  /* SPI Frame error interrupt occurred ------------------------------------*/
  if ((itflag & SPI_FLAG_FRE) != 0UL)
 80164ba:	68fb      	ldr	r3, [r7, #12]
 80164bc:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 80164c0:	2b00      	cmp	r3, #0
 80164c2:	d00f      	beq.n	80164e4 <SPI_CloseTransfer+0x124>
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FRE);
 80164c4:	687b      	ldr	r3, [r7, #4]
 80164c6:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 80164ca:	f043 0208 	orr.w	r2, r3, #8
 80164ce:	687b      	ldr	r3, [r7, #4]
 80164d0:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
    __HAL_SPI_CLEAR_FREFLAG(hspi);
 80164d4:	687b      	ldr	r3, [r7, #4]
 80164d6:	681b      	ldr	r3, [r3, #0]
 80164d8:	699a      	ldr	r2, [r3, #24]
 80164da:	687b      	ldr	r3, [r7, #4]
 80164dc:	681b      	ldr	r3, [r3, #0]
 80164de:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
 80164e2:	619a      	str	r2, [r3, #24]
  }

  hspi->TxXferCount = (uint16_t)0UL;
 80164e4:	687b      	ldr	r3, [r7, #4]
 80164e6:	2200      	movs	r2, #0
 80164e8:	f8a3 206a 	strh.w	r2, [r3, #106]	@ 0x6a
  hspi->RxXferCount = (uint16_t)0UL;
 80164ec:	687b      	ldr	r3, [r7, #4]
 80164ee:	2200      	movs	r2, #0
 80164f0:	f8a3 2072 	strh.w	r2, [r3, #114]	@ 0x72
}
 80164f4:	bf00      	nop
 80164f6:	3714      	adds	r7, #20
 80164f8:	46bd      	mov	sp, r7
 80164fa:	f85d 7b04 	ldr.w	r7, [sp], #4
 80164fe:	4770      	bx	lr

08016500 <SPI_WaitOnFlagUntilTimeout>:
  * @param Tickstart: Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_WaitOnFlagUntilTimeout(const SPI_HandleTypeDef *hspi, uint32_t Flag, FlagStatus Status,
                                                    uint32_t Timeout, uint32_t Tickstart)
{
 8016500:	b580      	push	{r7, lr}
 8016502:	b084      	sub	sp, #16
 8016504:	af00      	add	r7, sp, #0
 8016506:	60f8      	str	r0, [r7, #12]
 8016508:	60b9      	str	r1, [r7, #8]
 801650a:	603b      	str	r3, [r7, #0]
 801650c:	4613      	mov	r3, r2
 801650e:	71fb      	strb	r3, [r7, #7]
  /* Wait until flag is set */
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) == Status)
 8016510:	e010      	b.n	8016534 <SPI_WaitOnFlagUntilTimeout+0x34>
  {
    /* Check for the Timeout */
    if ((((HAL_GetTick() - Tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 8016512:	f7f7 faa5 	bl	800da60 <HAL_GetTick>
 8016516:	4602      	mov	r2, r0
 8016518:	69bb      	ldr	r3, [r7, #24]
 801651a:	1ad3      	subs	r3, r2, r3
 801651c:	683a      	ldr	r2, [r7, #0]
 801651e:	429a      	cmp	r2, r3
 8016520:	d803      	bhi.n	801652a <SPI_WaitOnFlagUntilTimeout+0x2a>
 8016522:	683b      	ldr	r3, [r7, #0]
 8016524:	f1b3 3fff 	cmp.w	r3, #4294967295
 8016528:	d102      	bne.n	8016530 <SPI_WaitOnFlagUntilTimeout+0x30>
 801652a:	683b      	ldr	r3, [r7, #0]
 801652c:	2b00      	cmp	r3, #0
 801652e:	d101      	bne.n	8016534 <SPI_WaitOnFlagUntilTimeout+0x34>
    {
      return HAL_TIMEOUT;
 8016530:	2303      	movs	r3, #3
 8016532:	e00f      	b.n	8016554 <SPI_WaitOnFlagUntilTimeout+0x54>
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) == Status)
 8016534:	68fb      	ldr	r3, [r7, #12]
 8016536:	681b      	ldr	r3, [r3, #0]
 8016538:	695a      	ldr	r2, [r3, #20]
 801653a:	68bb      	ldr	r3, [r7, #8]
 801653c:	4013      	ands	r3, r2
 801653e:	68ba      	ldr	r2, [r7, #8]
 8016540:	429a      	cmp	r2, r3
 8016542:	bf0c      	ite	eq
 8016544:	2301      	moveq	r3, #1
 8016546:	2300      	movne	r3, #0
 8016548:	b2db      	uxtb	r3, r3
 801654a:	461a      	mov	r2, r3
 801654c:	79fb      	ldrb	r3, [r7, #7]
 801654e:	429a      	cmp	r2, r3
 8016550:	d0df      	beq.n	8016512 <SPI_WaitOnFlagUntilTimeout+0x12>
    }
  }
  return HAL_OK;
 8016552:	2300      	movs	r3, #0
}
 8016554:	4618      	mov	r0, r3
 8016556:	3710      	adds	r7, #16
 8016558:	46bd      	mov	sp, r7
 801655a:	bd80      	pop	{r7, pc}

0801655c <SPI_GetPacketSize>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval Packet size occupied in the fifo
  */
static uint32_t SPI_GetPacketSize(const SPI_HandleTypeDef *hspi)
{
 801655c:	b480      	push	{r7}
 801655e:	b085      	sub	sp, #20
 8016560:	af00      	add	r7, sp, #0
 8016562:	6078      	str	r0, [r7, #4]
  uint32_t fifo_threashold = (hspi->Init.FifoThreshold >> SPI_CFG1_FTHLV_Pos) + 1UL;
 8016564:	687b      	ldr	r3, [r7, #4]
 8016566:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8016568:	095b      	lsrs	r3, r3, #5
 801656a:	3301      	adds	r3, #1
 801656c:	60fb      	str	r3, [r7, #12]
  uint32_t data_size       = (hspi->Init.DataSize      >> SPI_CFG1_DSIZE_Pos) + 1UL;
 801656e:	687b      	ldr	r3, [r7, #4]
 8016570:	68db      	ldr	r3, [r3, #12]
 8016572:	3301      	adds	r3, #1
 8016574:	60bb      	str	r3, [r7, #8]

  /* Convert data size to Byte */
  data_size = (data_size + 7UL) / 8UL;
 8016576:	68bb      	ldr	r3, [r7, #8]
 8016578:	3307      	adds	r3, #7
 801657a:	08db      	lsrs	r3, r3, #3
 801657c:	60bb      	str	r3, [r7, #8]

  return data_size * fifo_threashold;
 801657e:	68bb      	ldr	r3, [r7, #8]
 8016580:	68fa      	ldr	r2, [r7, #12]
 8016582:	fb02 f303 	mul.w	r3, r2, r3
}
 8016586:	4618      	mov	r0, r3
 8016588:	3714      	adds	r7, #20
 801658a:	46bd      	mov	sp, r7
 801658c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016590:	4770      	bx	lr

08016592 <HAL_SPIEx_SetConfigAutonomousMode>:
  *                the configuration information of the autonomous mode for the specified SPIx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPIEx_SetConfigAutonomousMode(SPI_HandleTypeDef *hspi,
                                                    const SPI_AutonomousModeConfTypeDef *sConfig)
{
 8016592:	b480      	push	{r7}
 8016594:	b083      	sub	sp, #12
 8016596:	af00      	add	r7, sp, #0
 8016598:	6078      	str	r0, [r7, #4]
 801659a:	6039      	str	r1, [r7, #0]
  if (hspi->State == HAL_SPI_STATE_READY)
 801659c:	687b      	ldr	r3, [r7, #4]
 801659e:	f893 3089 	ldrb.w	r3, [r3, #137]	@ 0x89
 80165a2:	b2db      	uxtb	r3, r3
 80165a4:	2b01      	cmp	r3, #1
 80165a6:	d12e      	bne.n	8016606 <HAL_SPIEx_SetConfigAutonomousMode+0x74>
  {
    /* Process Locked */
    __HAL_LOCK(hspi);
 80165a8:	687b      	ldr	r3, [r7, #4]
 80165aa:	f893 3088 	ldrb.w	r3, [r3, #136]	@ 0x88
 80165ae:	2b01      	cmp	r3, #1
 80165b0:	d101      	bne.n	80165b6 <HAL_SPIEx_SetConfigAutonomousMode+0x24>
 80165b2:	2302      	movs	r3, #2
 80165b4:	e028      	b.n	8016608 <HAL_SPIEx_SetConfigAutonomousMode+0x76>
 80165b6:	687b      	ldr	r3, [r7, #4]
 80165b8:	2201      	movs	r2, #1
 80165ba:	f883 2088 	strb.w	r2, [r3, #136]	@ 0x88

    hspi->State = HAL_SPI_STATE_BUSY;
 80165be:	687b      	ldr	r3, [r7, #4]
 80165c0:	2202      	movs	r2, #2
 80165c2:	f883 2089 	strb.w	r2, [r3, #137]	@ 0x89
    assert_param(IS_SPI_AUTONOMOUS_INSTANCE(hspi->Instance));
    assert_param(IS_SPI_TRIG_SOURCE(hspi->Instance, sConfig->TriggerSelection));
    assert_param(IS_SPI_AUTO_MODE_TRG_POL(sConfig->TriggerPolarity));

    /* Disable the selected SPI peripheral to be able to configure AUTOCR */
    __HAL_SPI_DISABLE(hspi);
 80165c6:	687b      	ldr	r3, [r7, #4]
 80165c8:	681b      	ldr	r3, [r3, #0]
 80165ca:	681a      	ldr	r2, [r3, #0]
 80165cc:	687b      	ldr	r3, [r7, #4]
 80165ce:	681b      	ldr	r3, [r3, #0]
 80165d0:	f022 0201 	bic.w	r2, r2, #1
 80165d4:	601a      	str	r2, [r3, #0]

    /* SPIx AUTOCR Configuration */
    WRITE_REG(hspi->Instance->AUTOCR, (sConfig->TriggerState | ((sConfig->TriggerSelection) & SPI_AUTOCR_TRIGSEL_Msk) |
 80165d6:	683b      	ldr	r3, [r7, #0]
 80165d8:	681a      	ldr	r2, [r3, #0]
 80165da:	683b      	ldr	r3, [r7, #0]
 80165dc:	685b      	ldr	r3, [r3, #4]
 80165de:	f403 2370 	and.w	r3, r3, #983040	@ 0xf0000
 80165e2:	ea42 0103 	orr.w	r1, r2, r3
 80165e6:	683b      	ldr	r3, [r7, #0]
 80165e8:	689a      	ldr	r2, [r3, #8]
 80165ea:	687b      	ldr	r3, [r7, #4]
 80165ec:	681b      	ldr	r3, [r3, #0]
 80165ee:	430a      	orrs	r2, r1
 80165f0:	61da      	str	r2, [r3, #28]
                                       sConfig->TriggerPolarity));

    hspi->State = HAL_SPI_STATE_READY;
 80165f2:	687b      	ldr	r3, [r7, #4]
 80165f4:	2201      	movs	r2, #1
 80165f6:	f883 2089 	strb.w	r2, [r3, #137]	@ 0x89

    /* Process Unlocked */
    __HAL_UNLOCK(hspi);
 80165fa:	687b      	ldr	r3, [r7, #4]
 80165fc:	2200      	movs	r2, #0
 80165fe:	f883 2088 	strb.w	r2, [r3, #136]	@ 0x88

    return HAL_OK;
 8016602:	2300      	movs	r3, #0
 8016604:	e000      	b.n	8016608 <HAL_SPIEx_SetConfigAutonomousMode+0x76>
  }
  else
  {
    return HAL_ERROR;
 8016606:	2301      	movs	r3, #1
  }
}
 8016608:	4618      	mov	r0, r3
 801660a:	370c      	adds	r7, #12
 801660c:	46bd      	mov	sp, r7
 801660e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016612:	4770      	bx	lr

08016614 <HAL_TIM_OC_Init>:
  *         Ex: call @ref HAL_TIM_OC_DeInit() before HAL_TIM_OC_Init()
  * @param  htim TIM Output Compare handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_OC_Init(TIM_HandleTypeDef *htim)
{
 8016614:	b580      	push	{r7, lr}
 8016616:	b082      	sub	sp, #8
 8016618:	af00      	add	r7, sp, #0
 801661a:	6078      	str	r0, [r7, #4]
  /* Check the TIM handle allocation */
  if (htim == NULL)
 801661c:	687b      	ldr	r3, [r7, #4]
 801661e:	2b00      	cmp	r3, #0
 8016620:	d101      	bne.n	8016626 <HAL_TIM_OC_Init+0x12>
  {
    return HAL_ERROR;
 8016622:	2301      	movs	r3, #1
 8016624:	e049      	b.n	80166ba <HAL_TIM_OC_Init+0xa6>
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
  assert_param(IS_TIM_PERIOD(htim, htim->Init.Period));
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));

  if (htim->State == HAL_TIM_STATE_RESET)
 8016626:	687b      	ldr	r3, [r7, #4]
 8016628:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 801662c:	b2db      	uxtb	r3, r3
 801662e:	2b00      	cmp	r3, #0
 8016630:	d106      	bne.n	8016640 <HAL_TIM_OC_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
 8016632:	687b      	ldr	r3, [r7, #4]
 8016634:	2200      	movs	r2, #0
 8016636:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c
    }
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    htim->OC_MspInitCallback(htim);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    HAL_TIM_OC_MspInit(htim);
 801663a:	6878      	ldr	r0, [r7, #4]
 801663c:	f7ef ff02 	bl	8006444 <HAL_TIM_OC_MspInit>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 8016640:	687b      	ldr	r3, [r7, #4]
 8016642:	2202      	movs	r2, #2
 8016644:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

  /* Init the base time for the Output Compare */
  TIM_Base_SetConfig(htim->Instance,  &htim->Init);
 8016648:	687b      	ldr	r3, [r7, #4]
 801664a:	681a      	ldr	r2, [r3, #0]
 801664c:	687b      	ldr	r3, [r7, #4]
 801664e:	3304      	adds	r3, #4
 8016650:	4619      	mov	r1, r3
 8016652:	4610      	mov	r0, r2
 8016654:	f000 fd6e 	bl	8017134 <TIM_Base_SetConfig>

  /* Initialize the DMA burst operation state */
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 8016658:	687b      	ldr	r3, [r7, #4]
 801665a:	2201      	movs	r2, #1
 801665c:	f883 2048 	strb.w	r2, [r3, #72]	@ 0x48

  /* Initialize the TIM channels state */
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8016660:	687b      	ldr	r3, [r7, #4]
 8016662:	2201      	movs	r2, #1
 8016664:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
 8016668:	687b      	ldr	r3, [r7, #4]
 801666a:	2201      	movs	r2, #1
 801666c:	f883 203f 	strb.w	r2, [r3, #63]	@ 0x3f
 8016670:	687b      	ldr	r3, [r7, #4]
 8016672:	2201      	movs	r2, #1
 8016674:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
 8016678:	687b      	ldr	r3, [r7, #4]
 801667a:	2201      	movs	r2, #1
 801667c:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
 8016680:	687b      	ldr	r3, [r7, #4]
 8016682:	2201      	movs	r2, #1
 8016684:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
 8016688:	687b      	ldr	r3, [r7, #4]
 801668a:	2201      	movs	r2, #1
 801668c:	f883 2043 	strb.w	r2, [r3, #67]	@ 0x43
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8016690:	687b      	ldr	r3, [r7, #4]
 8016692:	2201      	movs	r2, #1
 8016694:	f883 2044 	strb.w	r2, [r3, #68]	@ 0x44
 8016698:	687b      	ldr	r3, [r7, #4]
 801669a:	2201      	movs	r2, #1
 801669c:	f883 2045 	strb.w	r2, [r3, #69]	@ 0x45
 80166a0:	687b      	ldr	r3, [r7, #4]
 80166a2:	2201      	movs	r2, #1
 80166a4:	f883 2046 	strb.w	r2, [r3, #70]	@ 0x46
 80166a8:	687b      	ldr	r3, [r7, #4]
 80166aa:	2201      	movs	r2, #1
 80166ac:	f883 2047 	strb.w	r2, [r3, #71]	@ 0x47

  /* Initialize the TIM state*/
  htim->State = HAL_TIM_STATE_READY;
 80166b0:	687b      	ldr	r3, [r7, #4]
 80166b2:	2201      	movs	r2, #1
 80166b4:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

  return HAL_OK;
 80166b8:	2300      	movs	r3, #0
}
 80166ba:	4618      	mov	r0, r3
 80166bc:	3708      	adds	r7, #8
 80166be:	46bd      	mov	sp, r7
 80166c0:	bd80      	pop	{r7, pc}

080166c2 <HAL_TIM_OC_DeInit>:
  * @brief  DeInitializes the TIM peripheral
  * @param  htim TIM Output Compare handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_OC_DeInit(TIM_HandleTypeDef *htim)
{
 80166c2:	b580      	push	{r7, lr}
 80166c4:	b082      	sub	sp, #8
 80166c6:	af00      	add	r7, sp, #0
 80166c8:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  htim->State = HAL_TIM_STATE_BUSY;
 80166ca:	687b      	ldr	r3, [r7, #4]
 80166cc:	2202      	movs	r2, #2
 80166ce:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

  /* Disable the TIM Peripheral Clock */
  __HAL_TIM_DISABLE(htim);
 80166d2:	687b      	ldr	r3, [r7, #4]
 80166d4:	681b      	ldr	r3, [r3, #0]
 80166d6:	6a1a      	ldr	r2, [r3, #32]
 80166d8:	f241 1311 	movw	r3, #4369	@ 0x1111
 80166dc:	4013      	ands	r3, r2
 80166de:	2b00      	cmp	r3, #0
 80166e0:	d10f      	bne.n	8016702 <HAL_TIM_OC_DeInit+0x40>
 80166e2:	687b      	ldr	r3, [r7, #4]
 80166e4:	681b      	ldr	r3, [r3, #0]
 80166e6:	6a1a      	ldr	r2, [r3, #32]
 80166e8:	f244 4344 	movw	r3, #17476	@ 0x4444
 80166ec:	4013      	ands	r3, r2
 80166ee:	2b00      	cmp	r3, #0
 80166f0:	d107      	bne.n	8016702 <HAL_TIM_OC_DeInit+0x40>
 80166f2:	687b      	ldr	r3, [r7, #4]
 80166f4:	681b      	ldr	r3, [r3, #0]
 80166f6:	681a      	ldr	r2, [r3, #0]
 80166f8:	687b      	ldr	r3, [r7, #4]
 80166fa:	681b      	ldr	r3, [r3, #0]
 80166fc:	f022 0201 	bic.w	r2, r2, #1
 8016700:	601a      	str	r2, [r3, #0]
  }
  /* DeInit the low level hardware */
  htim->OC_MspDeInitCallback(htim);
#else
  /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
  HAL_TIM_OC_MspDeInit(htim);
 8016702:	6878      	ldr	r0, [r7, #4]
 8016704:	f7ef fec6 	bl	8006494 <HAL_TIM_OC_MspDeInit>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */

  /* Change the DMA burst operation state */
  htim->DMABurstState = HAL_DMA_BURST_STATE_RESET;
 8016708:	687b      	ldr	r3, [r7, #4]
 801670a:	2200      	movs	r2, #0
 801670c:	f883 2048 	strb.w	r2, [r3, #72]	@ 0x48

  /* Change the TIM channels state */
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);
 8016710:	687b      	ldr	r3, [r7, #4]
 8016712:	2200      	movs	r2, #0
 8016714:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
 8016718:	687b      	ldr	r3, [r7, #4]
 801671a:	2200      	movs	r2, #0
 801671c:	f883 203f 	strb.w	r2, [r3, #63]	@ 0x3f
 8016720:	687b      	ldr	r3, [r7, #4]
 8016722:	2200      	movs	r2, #0
 8016724:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
 8016728:	687b      	ldr	r3, [r7, #4]
 801672a:	2200      	movs	r2, #0
 801672c:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
 8016730:	687b      	ldr	r3, [r7, #4]
 8016732:	2200      	movs	r2, #0
 8016734:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
 8016738:	687b      	ldr	r3, [r7, #4]
 801673a:	2200      	movs	r2, #0
 801673c:	f883 2043 	strb.w	r2, [r3, #67]	@ 0x43
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);
 8016740:	687b      	ldr	r3, [r7, #4]
 8016742:	2200      	movs	r2, #0
 8016744:	f883 2044 	strb.w	r2, [r3, #68]	@ 0x44
 8016748:	687b      	ldr	r3, [r7, #4]
 801674a:	2200      	movs	r2, #0
 801674c:	f883 2045 	strb.w	r2, [r3, #69]	@ 0x45
 8016750:	687b      	ldr	r3, [r7, #4]
 8016752:	2200      	movs	r2, #0
 8016754:	f883 2046 	strb.w	r2, [r3, #70]	@ 0x46
 8016758:	687b      	ldr	r3, [r7, #4]
 801675a:	2200      	movs	r2, #0
 801675c:	f883 2047 	strb.w	r2, [r3, #71]	@ 0x47

  /* Change TIM state */
  htim->State = HAL_TIM_STATE_RESET;
 8016760:	687b      	ldr	r3, [r7, #4]
 8016762:	2200      	movs	r2, #0
 8016764:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

  /* Release Lock */
  __HAL_UNLOCK(htim);
 8016768:	687b      	ldr	r3, [r7, #4]
 801676a:	2200      	movs	r2, #0
 801676c:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

  return HAL_OK;
 8016770:	2300      	movs	r3, #0
}
 8016772:	4618      	mov	r0, r3
 8016774:	3708      	adds	r7, #8
 8016776:	46bd      	mov	sp, r7
 8016778:	bd80      	pop	{r7, pc}
	...

0801677c <HAL_TIM_OC_Start_IT>:
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_OC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
{
 801677c:	b580      	push	{r7, lr}
 801677e:	b084      	sub	sp, #16
 8016780:	af00      	add	r7, sp, #0
 8016782:	6078      	str	r0, [r7, #4]
 8016784:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
 8016786:	2300      	movs	r3, #0
 8016788:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_TIM_CCX_CHANNEL(htim->Instance, Channel));

  /* Check the TIM channel state */
  if (TIM_CHANNEL_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)
 801678a:	683b      	ldr	r3, [r7, #0]
 801678c:	2b00      	cmp	r3, #0
 801678e:	d109      	bne.n	80167a4 <HAL_TIM_OC_Start_IT+0x28>
 8016790:	687b      	ldr	r3, [r7, #4]
 8016792:	f893 303e 	ldrb.w	r3, [r3, #62]	@ 0x3e
 8016796:	b2db      	uxtb	r3, r3
 8016798:	2b01      	cmp	r3, #1
 801679a:	bf14      	ite	ne
 801679c:	2301      	movne	r3, #1
 801679e:	2300      	moveq	r3, #0
 80167a0:	b2db      	uxtb	r3, r3
 80167a2:	e03c      	b.n	801681e <HAL_TIM_OC_Start_IT+0xa2>
 80167a4:	683b      	ldr	r3, [r7, #0]
 80167a6:	2b04      	cmp	r3, #4
 80167a8:	d109      	bne.n	80167be <HAL_TIM_OC_Start_IT+0x42>
 80167aa:	687b      	ldr	r3, [r7, #4]
 80167ac:	f893 303f 	ldrb.w	r3, [r3, #63]	@ 0x3f
 80167b0:	b2db      	uxtb	r3, r3
 80167b2:	2b01      	cmp	r3, #1
 80167b4:	bf14      	ite	ne
 80167b6:	2301      	movne	r3, #1
 80167b8:	2300      	moveq	r3, #0
 80167ba:	b2db      	uxtb	r3, r3
 80167bc:	e02f      	b.n	801681e <HAL_TIM_OC_Start_IT+0xa2>
 80167be:	683b      	ldr	r3, [r7, #0]
 80167c0:	2b08      	cmp	r3, #8
 80167c2:	d109      	bne.n	80167d8 <HAL_TIM_OC_Start_IT+0x5c>
 80167c4:	687b      	ldr	r3, [r7, #4]
 80167c6:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
 80167ca:	b2db      	uxtb	r3, r3
 80167cc:	2b01      	cmp	r3, #1
 80167ce:	bf14      	ite	ne
 80167d0:	2301      	movne	r3, #1
 80167d2:	2300      	moveq	r3, #0
 80167d4:	b2db      	uxtb	r3, r3
 80167d6:	e022      	b.n	801681e <HAL_TIM_OC_Start_IT+0xa2>
 80167d8:	683b      	ldr	r3, [r7, #0]
 80167da:	2b0c      	cmp	r3, #12
 80167dc:	d109      	bne.n	80167f2 <HAL_TIM_OC_Start_IT+0x76>
 80167de:	687b      	ldr	r3, [r7, #4]
 80167e0:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 80167e4:	b2db      	uxtb	r3, r3
 80167e6:	2b01      	cmp	r3, #1
 80167e8:	bf14      	ite	ne
 80167ea:	2301      	movne	r3, #1
 80167ec:	2300      	moveq	r3, #0
 80167ee:	b2db      	uxtb	r3, r3
 80167f0:	e015      	b.n	801681e <HAL_TIM_OC_Start_IT+0xa2>
 80167f2:	683b      	ldr	r3, [r7, #0]
 80167f4:	2b10      	cmp	r3, #16
 80167f6:	d109      	bne.n	801680c <HAL_TIM_OC_Start_IT+0x90>
 80167f8:	687b      	ldr	r3, [r7, #4]
 80167fa:	f893 3042 	ldrb.w	r3, [r3, #66]	@ 0x42
 80167fe:	b2db      	uxtb	r3, r3
 8016800:	2b01      	cmp	r3, #1
 8016802:	bf14      	ite	ne
 8016804:	2301      	movne	r3, #1
 8016806:	2300      	moveq	r3, #0
 8016808:	b2db      	uxtb	r3, r3
 801680a:	e008      	b.n	801681e <HAL_TIM_OC_Start_IT+0xa2>
 801680c:	687b      	ldr	r3, [r7, #4]
 801680e:	f893 3043 	ldrb.w	r3, [r3, #67]	@ 0x43
 8016812:	b2db      	uxtb	r3, r3
 8016814:	2b01      	cmp	r3, #1
 8016816:	bf14      	ite	ne
 8016818:	2301      	movne	r3, #1
 801681a:	2300      	moveq	r3, #0
 801681c:	b2db      	uxtb	r3, r3
 801681e:	2b00      	cmp	r3, #0
 8016820:	d001      	beq.n	8016826 <HAL_TIM_OC_Start_IT+0xaa>
  {
    return HAL_ERROR;
 8016822:	2301      	movs	r3, #1
 8016824:	e124      	b.n	8016a70 <HAL_TIM_OC_Start_IT+0x2f4>
  }

  /* Set the TIM channel state */
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 8016826:	683b      	ldr	r3, [r7, #0]
 8016828:	2b00      	cmp	r3, #0
 801682a:	d104      	bne.n	8016836 <HAL_TIM_OC_Start_IT+0xba>
 801682c:	687b      	ldr	r3, [r7, #4]
 801682e:	2202      	movs	r2, #2
 8016830:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
 8016834:	e023      	b.n	801687e <HAL_TIM_OC_Start_IT+0x102>
 8016836:	683b      	ldr	r3, [r7, #0]
 8016838:	2b04      	cmp	r3, #4
 801683a:	d104      	bne.n	8016846 <HAL_TIM_OC_Start_IT+0xca>
 801683c:	687b      	ldr	r3, [r7, #4]
 801683e:	2202      	movs	r2, #2
 8016840:	f883 203f 	strb.w	r2, [r3, #63]	@ 0x3f
 8016844:	e01b      	b.n	801687e <HAL_TIM_OC_Start_IT+0x102>
 8016846:	683b      	ldr	r3, [r7, #0]
 8016848:	2b08      	cmp	r3, #8
 801684a:	d104      	bne.n	8016856 <HAL_TIM_OC_Start_IT+0xda>
 801684c:	687b      	ldr	r3, [r7, #4]
 801684e:	2202      	movs	r2, #2
 8016850:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
 8016854:	e013      	b.n	801687e <HAL_TIM_OC_Start_IT+0x102>
 8016856:	683b      	ldr	r3, [r7, #0]
 8016858:	2b0c      	cmp	r3, #12
 801685a:	d104      	bne.n	8016866 <HAL_TIM_OC_Start_IT+0xea>
 801685c:	687b      	ldr	r3, [r7, #4]
 801685e:	2202      	movs	r2, #2
 8016860:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
 8016864:	e00b      	b.n	801687e <HAL_TIM_OC_Start_IT+0x102>
 8016866:	683b      	ldr	r3, [r7, #0]
 8016868:	2b10      	cmp	r3, #16
 801686a:	d104      	bne.n	8016876 <HAL_TIM_OC_Start_IT+0xfa>
 801686c:	687b      	ldr	r3, [r7, #4]
 801686e:	2202      	movs	r2, #2
 8016870:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
 8016874:	e003      	b.n	801687e <HAL_TIM_OC_Start_IT+0x102>
 8016876:	687b      	ldr	r3, [r7, #4]
 8016878:	2202      	movs	r2, #2
 801687a:	f883 2043 	strb.w	r2, [r3, #67]	@ 0x43

  switch (Channel)
 801687e:	683b      	ldr	r3, [r7, #0]
 8016880:	2b0c      	cmp	r3, #12
 8016882:	d841      	bhi.n	8016908 <HAL_TIM_OC_Start_IT+0x18c>
 8016884:	a201      	add	r2, pc, #4	@ (adr r2, 801688c <HAL_TIM_OC_Start_IT+0x110>)
 8016886:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801688a:	bf00      	nop
 801688c:	080168c1 	.word	0x080168c1
 8016890:	08016909 	.word	0x08016909
 8016894:	08016909 	.word	0x08016909
 8016898:	08016909 	.word	0x08016909
 801689c:	080168d3 	.word	0x080168d3
 80168a0:	08016909 	.word	0x08016909
 80168a4:	08016909 	.word	0x08016909
 80168a8:	08016909 	.word	0x08016909
 80168ac:	080168e5 	.word	0x080168e5
 80168b0:	08016909 	.word	0x08016909
 80168b4:	08016909 	.word	0x08016909
 80168b8:	08016909 	.word	0x08016909
 80168bc:	080168f7 	.word	0x080168f7
  {
    case TIM_CHANNEL_1:
    {
      /* Enable the TIM Capture/Compare 1 interrupt */
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
 80168c0:	687b      	ldr	r3, [r7, #4]
 80168c2:	681b      	ldr	r3, [r3, #0]
 80168c4:	68da      	ldr	r2, [r3, #12]
 80168c6:	687b      	ldr	r3, [r7, #4]
 80168c8:	681b      	ldr	r3, [r3, #0]
 80168ca:	f042 0202 	orr.w	r2, r2, #2
 80168ce:	60da      	str	r2, [r3, #12]
      break;
 80168d0:	e01d      	b.n	801690e <HAL_TIM_OC_Start_IT+0x192>
    }

    case TIM_CHANNEL_2:
    {
      /* Enable the TIM Capture/Compare 2 interrupt */
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
 80168d2:	687b      	ldr	r3, [r7, #4]
 80168d4:	681b      	ldr	r3, [r3, #0]
 80168d6:	68da      	ldr	r2, [r3, #12]
 80168d8:	687b      	ldr	r3, [r7, #4]
 80168da:	681b      	ldr	r3, [r3, #0]
 80168dc:	f042 0204 	orr.w	r2, r2, #4
 80168e0:	60da      	str	r2, [r3, #12]
      break;
 80168e2:	e014      	b.n	801690e <HAL_TIM_OC_Start_IT+0x192>
    }

    case TIM_CHANNEL_3:
    {
      /* Enable the TIM Capture/Compare 3 interrupt */
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
 80168e4:	687b      	ldr	r3, [r7, #4]
 80168e6:	681b      	ldr	r3, [r3, #0]
 80168e8:	68da      	ldr	r2, [r3, #12]
 80168ea:	687b      	ldr	r3, [r7, #4]
 80168ec:	681b      	ldr	r3, [r3, #0]
 80168ee:	f042 0208 	orr.w	r2, r2, #8
 80168f2:	60da      	str	r2, [r3, #12]
      break;
 80168f4:	e00b      	b.n	801690e <HAL_TIM_OC_Start_IT+0x192>
    }

    case TIM_CHANNEL_4:
    {
      /* Enable the TIM Capture/Compare 4 interrupt */
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
 80168f6:	687b      	ldr	r3, [r7, #4]
 80168f8:	681b      	ldr	r3, [r3, #0]
 80168fa:	68da      	ldr	r2, [r3, #12]
 80168fc:	687b      	ldr	r3, [r7, #4]
 80168fe:	681b      	ldr	r3, [r3, #0]
 8016900:	f042 0210 	orr.w	r2, r2, #16
 8016904:	60da      	str	r2, [r3, #12]
      break;
 8016906:	e002      	b.n	801690e <HAL_TIM_OC_Start_IT+0x192>
    }

    default:
      status = HAL_ERROR;
 8016908:	2301      	movs	r3, #1
 801690a:	73fb      	strb	r3, [r7, #15]
      break;
 801690c:	bf00      	nop
  }

  if (status == HAL_OK)
 801690e:	7bfb      	ldrb	r3, [r7, #15]
 8016910:	2b00      	cmp	r3, #0
 8016912:	f040 80ac 	bne.w	8016a6e <HAL_TIM_OC_Start_IT+0x2f2>
  {
    /* Enable the Output compare channel */
    TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
 8016916:	687b      	ldr	r3, [r7, #4]
 8016918:	681b      	ldr	r3, [r3, #0]
 801691a:	2201      	movs	r2, #1
 801691c:	6839      	ldr	r1, [r7, #0]
 801691e:	4618      	mov	r0, r3
 8016920:	f001 f8e4 	bl	8017aec <TIM_CCxChannelCmd>

    if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 8016924:	687b      	ldr	r3, [r7, #4]
 8016926:	681b      	ldr	r3, [r3, #0]
 8016928:	4a53      	ldr	r2, [pc, #332]	@ (8016a78 <HAL_TIM_OC_Start_IT+0x2fc>)
 801692a:	4293      	cmp	r3, r2
 801692c:	d02c      	beq.n	8016988 <HAL_TIM_OC_Start_IT+0x20c>
 801692e:	687b      	ldr	r3, [r7, #4]
 8016930:	681b      	ldr	r3, [r3, #0]
 8016932:	4a52      	ldr	r2, [pc, #328]	@ (8016a7c <HAL_TIM_OC_Start_IT+0x300>)
 8016934:	4293      	cmp	r3, r2
 8016936:	d027      	beq.n	8016988 <HAL_TIM_OC_Start_IT+0x20c>
 8016938:	687b      	ldr	r3, [r7, #4]
 801693a:	681b      	ldr	r3, [r3, #0]
 801693c:	4a50      	ldr	r2, [pc, #320]	@ (8016a80 <HAL_TIM_OC_Start_IT+0x304>)
 801693e:	4293      	cmp	r3, r2
 8016940:	d022      	beq.n	8016988 <HAL_TIM_OC_Start_IT+0x20c>
 8016942:	687b      	ldr	r3, [r7, #4]
 8016944:	681b      	ldr	r3, [r3, #0]
 8016946:	4a4f      	ldr	r2, [pc, #316]	@ (8016a84 <HAL_TIM_OC_Start_IT+0x308>)
 8016948:	4293      	cmp	r3, r2
 801694a:	d01d      	beq.n	8016988 <HAL_TIM_OC_Start_IT+0x20c>
 801694c:	687b      	ldr	r3, [r7, #4]
 801694e:	681b      	ldr	r3, [r3, #0]
 8016950:	4a4d      	ldr	r2, [pc, #308]	@ (8016a88 <HAL_TIM_OC_Start_IT+0x30c>)
 8016952:	4293      	cmp	r3, r2
 8016954:	d018      	beq.n	8016988 <HAL_TIM_OC_Start_IT+0x20c>
 8016956:	687b      	ldr	r3, [r7, #4]
 8016958:	681b      	ldr	r3, [r3, #0]
 801695a:	4a4c      	ldr	r2, [pc, #304]	@ (8016a8c <HAL_TIM_OC_Start_IT+0x310>)
 801695c:	4293      	cmp	r3, r2
 801695e:	d013      	beq.n	8016988 <HAL_TIM_OC_Start_IT+0x20c>
 8016960:	687b      	ldr	r3, [r7, #4]
 8016962:	681b      	ldr	r3, [r3, #0]
 8016964:	4a4a      	ldr	r2, [pc, #296]	@ (8016a90 <HAL_TIM_OC_Start_IT+0x314>)
 8016966:	4293      	cmp	r3, r2
 8016968:	d00e      	beq.n	8016988 <HAL_TIM_OC_Start_IT+0x20c>
 801696a:	687b      	ldr	r3, [r7, #4]
 801696c:	681b      	ldr	r3, [r3, #0]
 801696e:	4a49      	ldr	r2, [pc, #292]	@ (8016a94 <HAL_TIM_OC_Start_IT+0x318>)
 8016970:	4293      	cmp	r3, r2
 8016972:	d009      	beq.n	8016988 <HAL_TIM_OC_Start_IT+0x20c>
 8016974:	687b      	ldr	r3, [r7, #4]
 8016976:	681b      	ldr	r3, [r3, #0]
 8016978:	4a47      	ldr	r2, [pc, #284]	@ (8016a98 <HAL_TIM_OC_Start_IT+0x31c>)
 801697a:	4293      	cmp	r3, r2
 801697c:	d004      	beq.n	8016988 <HAL_TIM_OC_Start_IT+0x20c>
 801697e:	687b      	ldr	r3, [r7, #4]
 8016980:	681b      	ldr	r3, [r3, #0]
 8016982:	4a46      	ldr	r2, [pc, #280]	@ (8016a9c <HAL_TIM_OC_Start_IT+0x320>)
 8016984:	4293      	cmp	r3, r2
 8016986:	d101      	bne.n	801698c <HAL_TIM_OC_Start_IT+0x210>
 8016988:	2301      	movs	r3, #1
 801698a:	e000      	b.n	801698e <HAL_TIM_OC_Start_IT+0x212>
 801698c:	2300      	movs	r3, #0
 801698e:	2b00      	cmp	r3, #0
 8016990:	d007      	beq.n	80169a2 <HAL_TIM_OC_Start_IT+0x226>
    {
      /* Enable the main output */
      __HAL_TIM_MOE_ENABLE(htim);
 8016992:	687b      	ldr	r3, [r7, #4]
 8016994:	681b      	ldr	r3, [r3, #0]
 8016996:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 8016998:	687b      	ldr	r3, [r7, #4]
 801699a:	681b      	ldr	r3, [r3, #0]
 801699c:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
 80169a0:	645a      	str	r2, [r3, #68]	@ 0x44
    }

    /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 80169a2:	687b      	ldr	r3, [r7, #4]
 80169a4:	681b      	ldr	r3, [r3, #0]
 80169a6:	4a34      	ldr	r2, [pc, #208]	@ (8016a78 <HAL_TIM_OC_Start_IT+0x2fc>)
 80169a8:	4293      	cmp	r3, r2
 80169aa:	d040      	beq.n	8016a2e <HAL_TIM_OC_Start_IT+0x2b2>
 80169ac:	687b      	ldr	r3, [r7, #4]
 80169ae:	681b      	ldr	r3, [r3, #0]
 80169b0:	4a32      	ldr	r2, [pc, #200]	@ (8016a7c <HAL_TIM_OC_Start_IT+0x300>)
 80169b2:	4293      	cmp	r3, r2
 80169b4:	d03b      	beq.n	8016a2e <HAL_TIM_OC_Start_IT+0x2b2>
 80169b6:	687b      	ldr	r3, [r7, #4]
 80169b8:	681b      	ldr	r3, [r3, #0]
 80169ba:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 80169be:	d036      	beq.n	8016a2e <HAL_TIM_OC_Start_IT+0x2b2>
 80169c0:	687b      	ldr	r3, [r7, #4]
 80169c2:	681b      	ldr	r3, [r3, #0]
 80169c4:	f1b3 4fa0 	cmp.w	r3, #1342177280	@ 0x50000000
 80169c8:	d031      	beq.n	8016a2e <HAL_TIM_OC_Start_IT+0x2b2>
 80169ca:	687b      	ldr	r3, [r7, #4]
 80169cc:	681b      	ldr	r3, [r3, #0]
 80169ce:	4a34      	ldr	r2, [pc, #208]	@ (8016aa0 <HAL_TIM_OC_Start_IT+0x324>)
 80169d0:	4293      	cmp	r3, r2
 80169d2:	d02c      	beq.n	8016a2e <HAL_TIM_OC_Start_IT+0x2b2>
 80169d4:	687b      	ldr	r3, [r7, #4]
 80169d6:	681b      	ldr	r3, [r3, #0]
 80169d8:	4a32      	ldr	r2, [pc, #200]	@ (8016aa4 <HAL_TIM_OC_Start_IT+0x328>)
 80169da:	4293      	cmp	r3, r2
 80169dc:	d027      	beq.n	8016a2e <HAL_TIM_OC_Start_IT+0x2b2>
 80169de:	687b      	ldr	r3, [r7, #4]
 80169e0:	681b      	ldr	r3, [r3, #0]
 80169e2:	4a31      	ldr	r2, [pc, #196]	@ (8016aa8 <HAL_TIM_OC_Start_IT+0x32c>)
 80169e4:	4293      	cmp	r3, r2
 80169e6:	d022      	beq.n	8016a2e <HAL_TIM_OC_Start_IT+0x2b2>
 80169e8:	687b      	ldr	r3, [r7, #4]
 80169ea:	681b      	ldr	r3, [r3, #0]
 80169ec:	4a2f      	ldr	r2, [pc, #188]	@ (8016aac <HAL_TIM_OC_Start_IT+0x330>)
 80169ee:	4293      	cmp	r3, r2
 80169f0:	d01d      	beq.n	8016a2e <HAL_TIM_OC_Start_IT+0x2b2>
 80169f2:	687b      	ldr	r3, [r7, #4]
 80169f4:	681b      	ldr	r3, [r3, #0]
 80169f6:	4a2e      	ldr	r2, [pc, #184]	@ (8016ab0 <HAL_TIM_OC_Start_IT+0x334>)
 80169f8:	4293      	cmp	r3, r2
 80169fa:	d018      	beq.n	8016a2e <HAL_TIM_OC_Start_IT+0x2b2>
 80169fc:	687b      	ldr	r3, [r7, #4]
 80169fe:	681b      	ldr	r3, [r3, #0]
 8016a00:	4a2c      	ldr	r2, [pc, #176]	@ (8016ab4 <HAL_TIM_OC_Start_IT+0x338>)
 8016a02:	4293      	cmp	r3, r2
 8016a04:	d013      	beq.n	8016a2e <HAL_TIM_OC_Start_IT+0x2b2>
 8016a06:	687b      	ldr	r3, [r7, #4]
 8016a08:	681b      	ldr	r3, [r3, #0]
 8016a0a:	4a1d      	ldr	r2, [pc, #116]	@ (8016a80 <HAL_TIM_OC_Start_IT+0x304>)
 8016a0c:	4293      	cmp	r3, r2
 8016a0e:	d00e      	beq.n	8016a2e <HAL_TIM_OC_Start_IT+0x2b2>
 8016a10:	687b      	ldr	r3, [r7, #4]
 8016a12:	681b      	ldr	r3, [r3, #0]
 8016a14:	4a1b      	ldr	r2, [pc, #108]	@ (8016a84 <HAL_TIM_OC_Start_IT+0x308>)
 8016a16:	4293      	cmp	r3, r2
 8016a18:	d009      	beq.n	8016a2e <HAL_TIM_OC_Start_IT+0x2b2>
 8016a1a:	687b      	ldr	r3, [r7, #4]
 8016a1c:	681b      	ldr	r3, [r3, #0]
 8016a1e:	4a1a      	ldr	r2, [pc, #104]	@ (8016a88 <HAL_TIM_OC_Start_IT+0x30c>)
 8016a20:	4293      	cmp	r3, r2
 8016a22:	d004      	beq.n	8016a2e <HAL_TIM_OC_Start_IT+0x2b2>
 8016a24:	687b      	ldr	r3, [r7, #4]
 8016a26:	681b      	ldr	r3, [r3, #0]
 8016a28:	4a18      	ldr	r2, [pc, #96]	@ (8016a8c <HAL_TIM_OC_Start_IT+0x310>)
 8016a2a:	4293      	cmp	r3, r2
 8016a2c:	d115      	bne.n	8016a5a <HAL_TIM_OC_Start_IT+0x2de>
    {
      tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 8016a2e:	687b      	ldr	r3, [r7, #4]
 8016a30:	681b      	ldr	r3, [r3, #0]
 8016a32:	689a      	ldr	r2, [r3, #8]
 8016a34:	4b20      	ldr	r3, [pc, #128]	@ (8016ab8 <HAL_TIM_OC_Start_IT+0x33c>)
 8016a36:	4013      	ands	r3, r2
 8016a38:	60bb      	str	r3, [r7, #8]
      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8016a3a:	68bb      	ldr	r3, [r7, #8]
 8016a3c:	2b06      	cmp	r3, #6
 8016a3e:	d015      	beq.n	8016a6c <HAL_TIM_OC_Start_IT+0x2f0>
 8016a40:	68bb      	ldr	r3, [r7, #8]
 8016a42:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 8016a46:	d011      	beq.n	8016a6c <HAL_TIM_OC_Start_IT+0x2f0>
      {
        __HAL_TIM_ENABLE(htim);
 8016a48:	687b      	ldr	r3, [r7, #4]
 8016a4a:	681b      	ldr	r3, [r3, #0]
 8016a4c:	681a      	ldr	r2, [r3, #0]
 8016a4e:	687b      	ldr	r3, [r7, #4]
 8016a50:	681b      	ldr	r3, [r3, #0]
 8016a52:	f042 0201 	orr.w	r2, r2, #1
 8016a56:	601a      	str	r2, [r3, #0]
      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8016a58:	e008      	b.n	8016a6c <HAL_TIM_OC_Start_IT+0x2f0>
      }
    }
    else
    {
      __HAL_TIM_ENABLE(htim);
 8016a5a:	687b      	ldr	r3, [r7, #4]
 8016a5c:	681b      	ldr	r3, [r3, #0]
 8016a5e:	681a      	ldr	r2, [r3, #0]
 8016a60:	687b      	ldr	r3, [r7, #4]
 8016a62:	681b      	ldr	r3, [r3, #0]
 8016a64:	f042 0201 	orr.w	r2, r2, #1
 8016a68:	601a      	str	r2, [r3, #0]
 8016a6a:	e000      	b.n	8016a6e <HAL_TIM_OC_Start_IT+0x2f2>
      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8016a6c:	bf00      	nop
    }
  }

  /* Return function status */
  return status;
 8016a6e:	7bfb      	ldrb	r3, [r7, #15]
}
 8016a70:	4618      	mov	r0, r3
 8016a72:	3710      	adds	r7, #16
 8016a74:	46bd      	mov	sp, r7
 8016a76:	bd80      	pop	{r7, pc}
 8016a78:	40012c00 	.word	0x40012c00
 8016a7c:	50012c00 	.word	0x50012c00
 8016a80:	40013400 	.word	0x40013400
 8016a84:	50013400 	.word	0x50013400
 8016a88:	40014000 	.word	0x40014000
 8016a8c:	50014000 	.word	0x50014000
 8016a90:	40014400 	.word	0x40014400
 8016a94:	50014400 	.word	0x50014400
 8016a98:	40014800 	.word	0x40014800
 8016a9c:	50014800 	.word	0x50014800
 8016aa0:	40000400 	.word	0x40000400
 8016aa4:	50000400 	.word	0x50000400
 8016aa8:	40000800 	.word	0x40000800
 8016aac:	50000800 	.word	0x50000800
 8016ab0:	40000c00 	.word	0x40000c00
 8016ab4:	50000c00 	.word	0x50000c00
 8016ab8:	00010007 	.word	0x00010007

08016abc <HAL_TIM_OC_Stop_IT>:
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_OC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
{
 8016abc:	b580      	push	{r7, lr}
 8016abe:	b084      	sub	sp, #16
 8016ac0:	af00      	add	r7, sp, #0
 8016ac2:	6078      	str	r0, [r7, #4]
 8016ac4:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
 8016ac6:	2300      	movs	r3, #0
 8016ac8:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_TIM_CCX_CHANNEL(htim->Instance, Channel));

  switch (Channel)
 8016aca:	683b      	ldr	r3, [r7, #0]
 8016acc:	2b0c      	cmp	r3, #12
 8016ace:	d841      	bhi.n	8016b54 <HAL_TIM_OC_Stop_IT+0x98>
 8016ad0:	a201      	add	r2, pc, #4	@ (adr r2, 8016ad8 <HAL_TIM_OC_Stop_IT+0x1c>)
 8016ad2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8016ad6:	bf00      	nop
 8016ad8:	08016b0d 	.word	0x08016b0d
 8016adc:	08016b55 	.word	0x08016b55
 8016ae0:	08016b55 	.word	0x08016b55
 8016ae4:	08016b55 	.word	0x08016b55
 8016ae8:	08016b1f 	.word	0x08016b1f
 8016aec:	08016b55 	.word	0x08016b55
 8016af0:	08016b55 	.word	0x08016b55
 8016af4:	08016b55 	.word	0x08016b55
 8016af8:	08016b31 	.word	0x08016b31
 8016afc:	08016b55 	.word	0x08016b55
 8016b00:	08016b55 	.word	0x08016b55
 8016b04:	08016b55 	.word	0x08016b55
 8016b08:	08016b43 	.word	0x08016b43
  {
    case TIM_CHANNEL_1:
    {
      /* Disable the TIM Capture/Compare 1 interrupt */
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
 8016b0c:	687b      	ldr	r3, [r7, #4]
 8016b0e:	681b      	ldr	r3, [r3, #0]
 8016b10:	68da      	ldr	r2, [r3, #12]
 8016b12:	687b      	ldr	r3, [r7, #4]
 8016b14:	681b      	ldr	r3, [r3, #0]
 8016b16:	f022 0202 	bic.w	r2, r2, #2
 8016b1a:	60da      	str	r2, [r3, #12]
      break;
 8016b1c:	e01d      	b.n	8016b5a <HAL_TIM_OC_Stop_IT+0x9e>
    }

    case TIM_CHANNEL_2:
    {
      /* Disable the TIM Capture/Compare 2 interrupt */
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
 8016b1e:	687b      	ldr	r3, [r7, #4]
 8016b20:	681b      	ldr	r3, [r3, #0]
 8016b22:	68da      	ldr	r2, [r3, #12]
 8016b24:	687b      	ldr	r3, [r7, #4]
 8016b26:	681b      	ldr	r3, [r3, #0]
 8016b28:	f022 0204 	bic.w	r2, r2, #4
 8016b2c:	60da      	str	r2, [r3, #12]
      break;
 8016b2e:	e014      	b.n	8016b5a <HAL_TIM_OC_Stop_IT+0x9e>
    }

    case TIM_CHANNEL_3:
    {
      /* Disable the TIM Capture/Compare 3 interrupt */
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
 8016b30:	687b      	ldr	r3, [r7, #4]
 8016b32:	681b      	ldr	r3, [r3, #0]
 8016b34:	68da      	ldr	r2, [r3, #12]
 8016b36:	687b      	ldr	r3, [r7, #4]
 8016b38:	681b      	ldr	r3, [r3, #0]
 8016b3a:	f022 0208 	bic.w	r2, r2, #8
 8016b3e:	60da      	str	r2, [r3, #12]
      break;
 8016b40:	e00b      	b.n	8016b5a <HAL_TIM_OC_Stop_IT+0x9e>
    }

    case TIM_CHANNEL_4:
    {
      /* Disable the TIM Capture/Compare 4 interrupt */
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
 8016b42:	687b      	ldr	r3, [r7, #4]
 8016b44:	681b      	ldr	r3, [r3, #0]
 8016b46:	68da      	ldr	r2, [r3, #12]
 8016b48:	687b      	ldr	r3, [r7, #4]
 8016b4a:	681b      	ldr	r3, [r3, #0]
 8016b4c:	f022 0210 	bic.w	r2, r2, #16
 8016b50:	60da      	str	r2, [r3, #12]
      break;
 8016b52:	e002      	b.n	8016b5a <HAL_TIM_OC_Stop_IT+0x9e>
    }

    default:
      status = HAL_ERROR;
 8016b54:	2301      	movs	r3, #1
 8016b56:	73fb      	strb	r3, [r7, #15]
      break;
 8016b58:	bf00      	nop
  }

  if (status == HAL_OK)
 8016b5a:	7bfb      	ldrb	r3, [r7, #15]
 8016b5c:	2b00      	cmp	r3, #0
 8016b5e:	f040 809a 	bne.w	8016c96 <HAL_TIM_OC_Stop_IT+0x1da>
  {
    /* Disable the Output compare channel */
    TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
 8016b62:	687b      	ldr	r3, [r7, #4]
 8016b64:	681b      	ldr	r3, [r3, #0]
 8016b66:	2200      	movs	r2, #0
 8016b68:	6839      	ldr	r1, [r7, #0]
 8016b6a:	4618      	mov	r0, r3
 8016b6c:	f000 ffbe 	bl	8017aec <TIM_CCxChannelCmd>

    if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 8016b70:	687b      	ldr	r3, [r7, #4]
 8016b72:	681b      	ldr	r3, [r3, #0]
 8016b74:	4a4a      	ldr	r2, [pc, #296]	@ (8016ca0 <HAL_TIM_OC_Stop_IT+0x1e4>)
 8016b76:	4293      	cmp	r3, r2
 8016b78:	d02c      	beq.n	8016bd4 <HAL_TIM_OC_Stop_IT+0x118>
 8016b7a:	687b      	ldr	r3, [r7, #4]
 8016b7c:	681b      	ldr	r3, [r3, #0]
 8016b7e:	4a49      	ldr	r2, [pc, #292]	@ (8016ca4 <HAL_TIM_OC_Stop_IT+0x1e8>)
 8016b80:	4293      	cmp	r3, r2
 8016b82:	d027      	beq.n	8016bd4 <HAL_TIM_OC_Stop_IT+0x118>
 8016b84:	687b      	ldr	r3, [r7, #4]
 8016b86:	681b      	ldr	r3, [r3, #0]
 8016b88:	4a47      	ldr	r2, [pc, #284]	@ (8016ca8 <HAL_TIM_OC_Stop_IT+0x1ec>)
 8016b8a:	4293      	cmp	r3, r2
 8016b8c:	d022      	beq.n	8016bd4 <HAL_TIM_OC_Stop_IT+0x118>
 8016b8e:	687b      	ldr	r3, [r7, #4]
 8016b90:	681b      	ldr	r3, [r3, #0]
 8016b92:	4a46      	ldr	r2, [pc, #280]	@ (8016cac <HAL_TIM_OC_Stop_IT+0x1f0>)
 8016b94:	4293      	cmp	r3, r2
 8016b96:	d01d      	beq.n	8016bd4 <HAL_TIM_OC_Stop_IT+0x118>
 8016b98:	687b      	ldr	r3, [r7, #4]
 8016b9a:	681b      	ldr	r3, [r3, #0]
 8016b9c:	4a44      	ldr	r2, [pc, #272]	@ (8016cb0 <HAL_TIM_OC_Stop_IT+0x1f4>)
 8016b9e:	4293      	cmp	r3, r2
 8016ba0:	d018      	beq.n	8016bd4 <HAL_TIM_OC_Stop_IT+0x118>
 8016ba2:	687b      	ldr	r3, [r7, #4]
 8016ba4:	681b      	ldr	r3, [r3, #0]
 8016ba6:	4a43      	ldr	r2, [pc, #268]	@ (8016cb4 <HAL_TIM_OC_Stop_IT+0x1f8>)
 8016ba8:	4293      	cmp	r3, r2
 8016baa:	d013      	beq.n	8016bd4 <HAL_TIM_OC_Stop_IT+0x118>
 8016bac:	687b      	ldr	r3, [r7, #4]
 8016bae:	681b      	ldr	r3, [r3, #0]
 8016bb0:	4a41      	ldr	r2, [pc, #260]	@ (8016cb8 <HAL_TIM_OC_Stop_IT+0x1fc>)
 8016bb2:	4293      	cmp	r3, r2
 8016bb4:	d00e      	beq.n	8016bd4 <HAL_TIM_OC_Stop_IT+0x118>
 8016bb6:	687b      	ldr	r3, [r7, #4]
 8016bb8:	681b      	ldr	r3, [r3, #0]
 8016bba:	4a40      	ldr	r2, [pc, #256]	@ (8016cbc <HAL_TIM_OC_Stop_IT+0x200>)
 8016bbc:	4293      	cmp	r3, r2
 8016bbe:	d009      	beq.n	8016bd4 <HAL_TIM_OC_Stop_IT+0x118>
 8016bc0:	687b      	ldr	r3, [r7, #4]
 8016bc2:	681b      	ldr	r3, [r3, #0]
 8016bc4:	4a3e      	ldr	r2, [pc, #248]	@ (8016cc0 <HAL_TIM_OC_Stop_IT+0x204>)
 8016bc6:	4293      	cmp	r3, r2
 8016bc8:	d004      	beq.n	8016bd4 <HAL_TIM_OC_Stop_IT+0x118>
 8016bca:	687b      	ldr	r3, [r7, #4]
 8016bcc:	681b      	ldr	r3, [r3, #0]
 8016bce:	4a3d      	ldr	r2, [pc, #244]	@ (8016cc4 <HAL_TIM_OC_Stop_IT+0x208>)
 8016bd0:	4293      	cmp	r3, r2
 8016bd2:	d101      	bne.n	8016bd8 <HAL_TIM_OC_Stop_IT+0x11c>
 8016bd4:	2301      	movs	r3, #1
 8016bd6:	e000      	b.n	8016bda <HAL_TIM_OC_Stop_IT+0x11e>
 8016bd8:	2300      	movs	r3, #0
 8016bda:	2b00      	cmp	r3, #0
 8016bdc:	d017      	beq.n	8016c0e <HAL_TIM_OC_Stop_IT+0x152>
    {
      /* Disable the Main Output */
      __HAL_TIM_MOE_DISABLE(htim);
 8016bde:	687b      	ldr	r3, [r7, #4]
 8016be0:	681b      	ldr	r3, [r3, #0]
 8016be2:	6a1a      	ldr	r2, [r3, #32]
 8016be4:	f241 1311 	movw	r3, #4369	@ 0x1111
 8016be8:	4013      	ands	r3, r2
 8016bea:	2b00      	cmp	r3, #0
 8016bec:	d10f      	bne.n	8016c0e <HAL_TIM_OC_Stop_IT+0x152>
 8016bee:	687b      	ldr	r3, [r7, #4]
 8016bf0:	681b      	ldr	r3, [r3, #0]
 8016bf2:	6a1a      	ldr	r2, [r3, #32]
 8016bf4:	f244 4344 	movw	r3, #17476	@ 0x4444
 8016bf8:	4013      	ands	r3, r2
 8016bfa:	2b00      	cmp	r3, #0
 8016bfc:	d107      	bne.n	8016c0e <HAL_TIM_OC_Stop_IT+0x152>
 8016bfe:	687b      	ldr	r3, [r7, #4]
 8016c00:	681b      	ldr	r3, [r3, #0]
 8016c02:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 8016c04:	687b      	ldr	r3, [r7, #4]
 8016c06:	681b      	ldr	r3, [r3, #0]
 8016c08:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
 8016c0c:	645a      	str	r2, [r3, #68]	@ 0x44
    }

    /* Disable the Peripheral */
    __HAL_TIM_DISABLE(htim);
 8016c0e:	687b      	ldr	r3, [r7, #4]
 8016c10:	681b      	ldr	r3, [r3, #0]
 8016c12:	6a1a      	ldr	r2, [r3, #32]
 8016c14:	f241 1311 	movw	r3, #4369	@ 0x1111
 8016c18:	4013      	ands	r3, r2
 8016c1a:	2b00      	cmp	r3, #0
 8016c1c:	d10f      	bne.n	8016c3e <HAL_TIM_OC_Stop_IT+0x182>
 8016c1e:	687b      	ldr	r3, [r7, #4]
 8016c20:	681b      	ldr	r3, [r3, #0]
 8016c22:	6a1a      	ldr	r2, [r3, #32]
 8016c24:	f244 4344 	movw	r3, #17476	@ 0x4444
 8016c28:	4013      	ands	r3, r2
 8016c2a:	2b00      	cmp	r3, #0
 8016c2c:	d107      	bne.n	8016c3e <HAL_TIM_OC_Stop_IT+0x182>
 8016c2e:	687b      	ldr	r3, [r7, #4]
 8016c30:	681b      	ldr	r3, [r3, #0]
 8016c32:	681a      	ldr	r2, [r3, #0]
 8016c34:	687b      	ldr	r3, [r7, #4]
 8016c36:	681b      	ldr	r3, [r3, #0]
 8016c38:	f022 0201 	bic.w	r2, r2, #1
 8016c3c:	601a      	str	r2, [r3, #0]

    /* Set the TIM channel state */
    TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
 8016c3e:	683b      	ldr	r3, [r7, #0]
 8016c40:	2b00      	cmp	r3, #0
 8016c42:	d104      	bne.n	8016c4e <HAL_TIM_OC_Stop_IT+0x192>
 8016c44:	687b      	ldr	r3, [r7, #4]
 8016c46:	2201      	movs	r2, #1
 8016c48:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
 8016c4c:	e023      	b.n	8016c96 <HAL_TIM_OC_Stop_IT+0x1da>
 8016c4e:	683b      	ldr	r3, [r7, #0]
 8016c50:	2b04      	cmp	r3, #4
 8016c52:	d104      	bne.n	8016c5e <HAL_TIM_OC_Stop_IT+0x1a2>
 8016c54:	687b      	ldr	r3, [r7, #4]
 8016c56:	2201      	movs	r2, #1
 8016c58:	f883 203f 	strb.w	r2, [r3, #63]	@ 0x3f
 8016c5c:	e01b      	b.n	8016c96 <HAL_TIM_OC_Stop_IT+0x1da>
 8016c5e:	683b      	ldr	r3, [r7, #0]
 8016c60:	2b08      	cmp	r3, #8
 8016c62:	d104      	bne.n	8016c6e <HAL_TIM_OC_Stop_IT+0x1b2>
 8016c64:	687b      	ldr	r3, [r7, #4]
 8016c66:	2201      	movs	r2, #1
 8016c68:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
 8016c6c:	e013      	b.n	8016c96 <HAL_TIM_OC_Stop_IT+0x1da>
 8016c6e:	683b      	ldr	r3, [r7, #0]
 8016c70:	2b0c      	cmp	r3, #12
 8016c72:	d104      	bne.n	8016c7e <HAL_TIM_OC_Stop_IT+0x1c2>
 8016c74:	687b      	ldr	r3, [r7, #4]
 8016c76:	2201      	movs	r2, #1
 8016c78:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
 8016c7c:	e00b      	b.n	8016c96 <HAL_TIM_OC_Stop_IT+0x1da>
 8016c7e:	683b      	ldr	r3, [r7, #0]
 8016c80:	2b10      	cmp	r3, #16
 8016c82:	d104      	bne.n	8016c8e <HAL_TIM_OC_Stop_IT+0x1d2>
 8016c84:	687b      	ldr	r3, [r7, #4]
 8016c86:	2201      	movs	r2, #1
 8016c88:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
 8016c8c:	e003      	b.n	8016c96 <HAL_TIM_OC_Stop_IT+0x1da>
 8016c8e:	687b      	ldr	r3, [r7, #4]
 8016c90:	2201      	movs	r2, #1
 8016c92:	f883 2043 	strb.w	r2, [r3, #67]	@ 0x43
  }

  /* Return function status */
  return status;
 8016c96:	7bfb      	ldrb	r3, [r7, #15]
}
 8016c98:	4618      	mov	r0, r3
 8016c9a:	3710      	adds	r7, #16
 8016c9c:	46bd      	mov	sp, r7
 8016c9e:	bd80      	pop	{r7, pc}
 8016ca0:	40012c00 	.word	0x40012c00
 8016ca4:	50012c00 	.word	0x50012c00
 8016ca8:	40013400 	.word	0x40013400
 8016cac:	50013400 	.word	0x50013400
 8016cb0:	40014000 	.word	0x40014000
 8016cb4:	50014000 	.word	0x50014000
 8016cb8:	40014400 	.word	0x40014400
 8016cbc:	50014400 	.word	0x50014400
 8016cc0:	40014800 	.word	0x40014800
 8016cc4:	50014800 	.word	0x50014800

08016cc8 <HAL_TIM_IRQHandler>:
  * @brief  This function handles TIM interrupts requests.
  * @param  htim TIM  handle
  * @retval None
  */
void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
{
 8016cc8:	b580      	push	{r7, lr}
 8016cca:	b084      	sub	sp, #16
 8016ccc:	af00      	add	r7, sp, #0
 8016cce:	6078      	str	r0, [r7, #4]
  uint32_t itsource = htim->Instance->DIER;
 8016cd0:	687b      	ldr	r3, [r7, #4]
 8016cd2:	681b      	ldr	r3, [r3, #0]
 8016cd4:	68db      	ldr	r3, [r3, #12]
 8016cd6:	60fb      	str	r3, [r7, #12]
  uint32_t itflag   = htim->Instance->SR;
 8016cd8:	687b      	ldr	r3, [r7, #4]
 8016cda:	681b      	ldr	r3, [r3, #0]
 8016cdc:	691b      	ldr	r3, [r3, #16]
 8016cde:	60bb      	str	r3, [r7, #8]

  /* Capture compare 1 event */
  if ((itflag & (TIM_FLAG_CC1)) == (TIM_FLAG_CC1))
 8016ce0:	68bb      	ldr	r3, [r7, #8]
 8016ce2:	f003 0302 	and.w	r3, r3, #2
 8016ce6:	2b00      	cmp	r3, #0
 8016ce8:	d020      	beq.n	8016d2c <HAL_TIM_IRQHandler+0x64>
  {
    if ((itsource & (TIM_IT_CC1)) == (TIM_IT_CC1))
 8016cea:	68fb      	ldr	r3, [r7, #12]
 8016cec:	f003 0302 	and.w	r3, r3, #2
 8016cf0:	2b00      	cmp	r3, #0
 8016cf2:	d01b      	beq.n	8016d2c <HAL_TIM_IRQHandler+0x64>
    {
      {
        __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC1);
 8016cf4:	687b      	ldr	r3, [r7, #4]
 8016cf6:	681b      	ldr	r3, [r3, #0]
 8016cf8:	f06f 0202 	mvn.w	r2, #2
 8016cfc:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 8016cfe:	687b      	ldr	r3, [r7, #4]
 8016d00:	2201      	movs	r2, #1
 8016d02:	771a      	strb	r2, [r3, #28]

        /* Input capture event */
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 8016d04:	687b      	ldr	r3, [r7, #4]
 8016d06:	681b      	ldr	r3, [r3, #0]
 8016d08:	699b      	ldr	r3, [r3, #24]
 8016d0a:	f003 0303 	and.w	r3, r3, #3
 8016d0e:	2b00      	cmp	r3, #0
 8016d10:	d003      	beq.n	8016d1a <HAL_TIM_IRQHandler+0x52>
        {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
          htim->IC_CaptureCallback(htim);
#else
          HAL_TIM_IC_CaptureCallback(htim);
 8016d12:	6878      	ldr	r0, [r7, #4]
 8016d14:	f000 f9f0 	bl	80170f8 <HAL_TIM_IC_CaptureCallback>
 8016d18:	e005      	b.n	8016d26 <HAL_TIM_IRQHandler+0x5e>
        {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
          htim->OC_DelayElapsedCallback(htim);
          htim->PWM_PulseFinishedCallback(htim);
#else
          HAL_TIM_OC_DelayElapsedCallback(htim);
 8016d1a:	6878      	ldr	r0, [r7, #4]
 8016d1c:	f7ec fa16 	bl	800314c <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 8016d20:	6878      	ldr	r0, [r7, #4]
 8016d22:	f000 f9f3 	bl	801710c <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
        }
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8016d26:	687b      	ldr	r3, [r7, #4]
 8016d28:	2200      	movs	r2, #0
 8016d2a:	771a      	strb	r2, [r3, #28]
      }
    }
  }
  /* Capture compare 2 event */
  if ((itflag & (TIM_FLAG_CC2)) == (TIM_FLAG_CC2))
 8016d2c:	68bb      	ldr	r3, [r7, #8]
 8016d2e:	f003 0304 	and.w	r3, r3, #4
 8016d32:	2b00      	cmp	r3, #0
 8016d34:	d020      	beq.n	8016d78 <HAL_TIM_IRQHandler+0xb0>
  {
    if ((itsource & (TIM_IT_CC2)) == (TIM_IT_CC2))
 8016d36:	68fb      	ldr	r3, [r7, #12]
 8016d38:	f003 0304 	and.w	r3, r3, #4
 8016d3c:	2b00      	cmp	r3, #0
 8016d3e:	d01b      	beq.n	8016d78 <HAL_TIM_IRQHandler+0xb0>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC2);
 8016d40:	687b      	ldr	r3, [r7, #4]
 8016d42:	681b      	ldr	r3, [r3, #0]
 8016d44:	f06f 0204 	mvn.w	r2, #4
 8016d48:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 8016d4a:	687b      	ldr	r3, [r7, #4]
 8016d4c:	2202      	movs	r2, #2
 8016d4e:	771a      	strb	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 8016d50:	687b      	ldr	r3, [r7, #4]
 8016d52:	681b      	ldr	r3, [r3, #0]
 8016d54:	699b      	ldr	r3, [r3, #24]
 8016d56:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 8016d5a:	2b00      	cmp	r3, #0
 8016d5c:	d003      	beq.n	8016d66 <HAL_TIM_IRQHandler+0x9e>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 8016d5e:	6878      	ldr	r0, [r7, #4]
 8016d60:	f000 f9ca 	bl	80170f8 <HAL_TIM_IC_CaptureCallback>
 8016d64:	e005      	b.n	8016d72 <HAL_TIM_IRQHandler+0xaa>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8016d66:	6878      	ldr	r0, [r7, #4]
 8016d68:	f7ec f9f0 	bl	800314c <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8016d6c:	6878      	ldr	r0, [r7, #4]
 8016d6e:	f000 f9cd 	bl	801710c <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8016d72:	687b      	ldr	r3, [r7, #4]
 8016d74:	2200      	movs	r2, #0
 8016d76:	771a      	strb	r2, [r3, #28]
    }
  }
  /* Capture compare 3 event */
  if ((itflag & (TIM_FLAG_CC3)) == (TIM_FLAG_CC3))
 8016d78:	68bb      	ldr	r3, [r7, #8]
 8016d7a:	f003 0308 	and.w	r3, r3, #8
 8016d7e:	2b00      	cmp	r3, #0
 8016d80:	d020      	beq.n	8016dc4 <HAL_TIM_IRQHandler+0xfc>
  {
    if ((itsource & (TIM_IT_CC3)) == (TIM_IT_CC3))
 8016d82:	68fb      	ldr	r3, [r7, #12]
 8016d84:	f003 0308 	and.w	r3, r3, #8
 8016d88:	2b00      	cmp	r3, #0
 8016d8a:	d01b      	beq.n	8016dc4 <HAL_TIM_IRQHandler+0xfc>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC3);
 8016d8c:	687b      	ldr	r3, [r7, #4]
 8016d8e:	681b      	ldr	r3, [r3, #0]
 8016d90:	f06f 0208 	mvn.w	r2, #8
 8016d94:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 8016d96:	687b      	ldr	r3, [r7, #4]
 8016d98:	2204      	movs	r2, #4
 8016d9a:	771a      	strb	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 8016d9c:	687b      	ldr	r3, [r7, #4]
 8016d9e:	681b      	ldr	r3, [r3, #0]
 8016da0:	69db      	ldr	r3, [r3, #28]
 8016da2:	f003 0303 	and.w	r3, r3, #3
 8016da6:	2b00      	cmp	r3, #0
 8016da8:	d003      	beq.n	8016db2 <HAL_TIM_IRQHandler+0xea>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 8016daa:	6878      	ldr	r0, [r7, #4]
 8016dac:	f000 f9a4 	bl	80170f8 <HAL_TIM_IC_CaptureCallback>
 8016db0:	e005      	b.n	8016dbe <HAL_TIM_IRQHandler+0xf6>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8016db2:	6878      	ldr	r0, [r7, #4]
 8016db4:	f7ec f9ca 	bl	800314c <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8016db8:	6878      	ldr	r0, [r7, #4]
 8016dba:	f000 f9a7 	bl	801710c <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8016dbe:	687b      	ldr	r3, [r7, #4]
 8016dc0:	2200      	movs	r2, #0
 8016dc2:	771a      	strb	r2, [r3, #28]
    }
  }
  /* Capture compare 4 event */
  if ((itflag & (TIM_FLAG_CC4)) == (TIM_FLAG_CC4))
 8016dc4:	68bb      	ldr	r3, [r7, #8]
 8016dc6:	f003 0310 	and.w	r3, r3, #16
 8016dca:	2b00      	cmp	r3, #0
 8016dcc:	d020      	beq.n	8016e10 <HAL_TIM_IRQHandler+0x148>
  {
    if ((itsource & (TIM_IT_CC4)) == (TIM_IT_CC4))
 8016dce:	68fb      	ldr	r3, [r7, #12]
 8016dd0:	f003 0310 	and.w	r3, r3, #16
 8016dd4:	2b00      	cmp	r3, #0
 8016dd6:	d01b      	beq.n	8016e10 <HAL_TIM_IRQHandler+0x148>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC4);
 8016dd8:	687b      	ldr	r3, [r7, #4]
 8016dda:	681b      	ldr	r3, [r3, #0]
 8016ddc:	f06f 0210 	mvn.w	r2, #16
 8016de0:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 8016de2:	687b      	ldr	r3, [r7, #4]
 8016de4:	2208      	movs	r2, #8
 8016de6:	771a      	strb	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 8016de8:	687b      	ldr	r3, [r7, #4]
 8016dea:	681b      	ldr	r3, [r3, #0]
 8016dec:	69db      	ldr	r3, [r3, #28]
 8016dee:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 8016df2:	2b00      	cmp	r3, #0
 8016df4:	d003      	beq.n	8016dfe <HAL_TIM_IRQHandler+0x136>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 8016df6:	6878      	ldr	r0, [r7, #4]
 8016df8:	f000 f97e 	bl	80170f8 <HAL_TIM_IC_CaptureCallback>
 8016dfc:	e005      	b.n	8016e0a <HAL_TIM_IRQHandler+0x142>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8016dfe:	6878      	ldr	r0, [r7, #4]
 8016e00:	f7ec f9a4 	bl	800314c <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8016e04:	6878      	ldr	r0, [r7, #4]
 8016e06:	f000 f981 	bl	801710c <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8016e0a:	687b      	ldr	r3, [r7, #4]
 8016e0c:	2200      	movs	r2, #0
 8016e0e:	771a      	strb	r2, [r3, #28]
    }
  }
  /* TIM Update event */
  if ((itflag & (TIM_FLAG_UPDATE)) == (TIM_FLAG_UPDATE))
 8016e10:	68bb      	ldr	r3, [r7, #8]
 8016e12:	f003 0301 	and.w	r3, r3, #1
 8016e16:	2b00      	cmp	r3, #0
 8016e18:	d00c      	beq.n	8016e34 <HAL_TIM_IRQHandler+0x16c>
  {
    if ((itsource & (TIM_IT_UPDATE)) == (TIM_IT_UPDATE))
 8016e1a:	68fb      	ldr	r3, [r7, #12]
 8016e1c:	f003 0301 	and.w	r3, r3, #1
 8016e20:	2b00      	cmp	r3, #0
 8016e22:	d007      	beq.n	8016e34 <HAL_TIM_IRQHandler+0x16c>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_UPDATE);
 8016e24:	687b      	ldr	r3, [r7, #4]
 8016e26:	681b      	ldr	r3, [r3, #0]
 8016e28:	f06f 0201 	mvn.w	r2, #1
 8016e2c:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->PeriodElapsedCallback(htim);
#else
      HAL_TIM_PeriodElapsedCallback(htim);
 8016e2e:	6878      	ldr	r0, [r7, #4]
 8016e30:	f000 f958 	bl	80170e4 <HAL_TIM_PeriodElapsedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Break input event */
  if (((itflag & (TIM_FLAG_BREAK)) == (TIM_FLAG_BREAK)) || \
 8016e34:	68bb      	ldr	r3, [r7, #8]
 8016e36:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8016e3a:	2b00      	cmp	r3, #0
 8016e3c:	d104      	bne.n	8016e48 <HAL_TIM_IRQHandler+0x180>
      ((itflag & (TIM_FLAG_SYSTEM_BREAK)) == (TIM_FLAG_SYSTEM_BREAK)))
 8016e3e:	68bb      	ldr	r3, [r7, #8]
 8016e40:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
  if (((itflag & (TIM_FLAG_BREAK)) == (TIM_FLAG_BREAK)) || \
 8016e44:	2b00      	cmp	r3, #0
 8016e46:	d00c      	beq.n	8016e62 <HAL_TIM_IRQHandler+0x19a>
  {
    if ((itsource & (TIM_IT_BREAK)) == (TIM_IT_BREAK))
 8016e48:	68fb      	ldr	r3, [r7, #12]
 8016e4a:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8016e4e:	2b00      	cmp	r3, #0
 8016e50:	d007      	beq.n	8016e62 <HAL_TIM_IRQHandler+0x19a>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK | TIM_FLAG_SYSTEM_BREAK);
 8016e52:	687b      	ldr	r3, [r7, #4]
 8016e54:	681b      	ldr	r3, [r3, #0]
 8016e56:	f46f 5202 	mvn.w	r2, #8320	@ 0x2080
 8016e5a:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->BreakCallback(htim);
#else
      HAL_TIMEx_BreakCallback(htim);
 8016e5c:	6878      	ldr	r0, [r7, #4]
 8016e5e:	f000 fe74 	bl	8017b4a <HAL_TIMEx_BreakCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Break2 input event */
  if ((itflag & (TIM_FLAG_BREAK2)) == (TIM_FLAG_BREAK2))
 8016e62:	68bb      	ldr	r3, [r7, #8]
 8016e64:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8016e68:	2b00      	cmp	r3, #0
 8016e6a:	d00c      	beq.n	8016e86 <HAL_TIM_IRQHandler+0x1be>
  {
    if ((itsource & (TIM_IT_BREAK)) == (TIM_IT_BREAK))
 8016e6c:	68fb      	ldr	r3, [r7, #12]
 8016e6e:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8016e72:	2b00      	cmp	r3, #0
 8016e74:	d007      	beq.n	8016e86 <HAL_TIM_IRQHandler+0x1be>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK2);
 8016e76:	687b      	ldr	r3, [r7, #4]
 8016e78:	681b      	ldr	r3, [r3, #0]
 8016e7a:	f46f 7280 	mvn.w	r2, #256	@ 0x100
 8016e7e:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->Break2Callback(htim);
#else
      HAL_TIMEx_Break2Callback(htim);
 8016e80:	6878      	ldr	r0, [r7, #4]
 8016e82:	f000 fe6c 	bl	8017b5e <HAL_TIMEx_Break2Callback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Trigger detection event */
  if ((itflag & (TIM_FLAG_TRIGGER)) == (TIM_FLAG_TRIGGER))
 8016e86:	68bb      	ldr	r3, [r7, #8]
 8016e88:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8016e8c:	2b00      	cmp	r3, #0
 8016e8e:	d00c      	beq.n	8016eaa <HAL_TIM_IRQHandler+0x1e2>
  {
    if ((itsource & (TIM_IT_TRIGGER)) == (TIM_IT_TRIGGER))
 8016e90:	68fb      	ldr	r3, [r7, #12]
 8016e92:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8016e96:	2b00      	cmp	r3, #0
 8016e98:	d007      	beq.n	8016eaa <HAL_TIM_IRQHandler+0x1e2>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_TRIGGER);
 8016e9a:	687b      	ldr	r3, [r7, #4]
 8016e9c:	681b      	ldr	r3, [r3, #0]
 8016e9e:	f06f 0240 	mvn.w	r2, #64	@ 0x40
 8016ea2:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->TriggerCallback(htim);
#else
      HAL_TIM_TriggerCallback(htim);
 8016ea4:	6878      	ldr	r0, [r7, #4]
 8016ea6:	f000 f93b 	bl	8017120 <HAL_TIM_TriggerCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM commutation event */
  if ((itflag & (TIM_FLAG_COM)) == (TIM_FLAG_COM))
 8016eaa:	68bb      	ldr	r3, [r7, #8]
 8016eac:	f003 0320 	and.w	r3, r3, #32
 8016eb0:	2b00      	cmp	r3, #0
 8016eb2:	d00c      	beq.n	8016ece <HAL_TIM_IRQHandler+0x206>
  {
    if ((itsource & (TIM_IT_COM)) == (TIM_IT_COM))
 8016eb4:	68fb      	ldr	r3, [r7, #12]
 8016eb6:	f003 0320 	and.w	r3, r3, #32
 8016eba:	2b00      	cmp	r3, #0
 8016ebc:	d007      	beq.n	8016ece <HAL_TIM_IRQHandler+0x206>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_COM);
 8016ebe:	687b      	ldr	r3, [r7, #4]
 8016ec0:	681b      	ldr	r3, [r3, #0]
 8016ec2:	f06f 0220 	mvn.w	r2, #32
 8016ec6:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->CommutationCallback(htim);
#else
      HAL_TIMEx_CommutCallback(htim);
 8016ec8:	6878      	ldr	r0, [r7, #4]
 8016eca:	f000 fe34 	bl	8017b36 <HAL_TIMEx_CommutCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Encoder index event */
  if ((itflag & (TIM_FLAG_IDX)) == (TIM_FLAG_IDX))
 8016ece:	68bb      	ldr	r3, [r7, #8]
 8016ed0:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
 8016ed4:	2b00      	cmp	r3, #0
 8016ed6:	d00c      	beq.n	8016ef2 <HAL_TIM_IRQHandler+0x22a>
  {
    if ((itsource & (TIM_IT_IDX)) == (TIM_IT_IDX))
 8016ed8:	68fb      	ldr	r3, [r7, #12]
 8016eda:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
 8016ede:	2b00      	cmp	r3, #0
 8016ee0:	d007      	beq.n	8016ef2 <HAL_TIM_IRQHandler+0x22a>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_IDX);
 8016ee2:	687b      	ldr	r3, [r7, #4]
 8016ee4:	681b      	ldr	r3, [r3, #0]
 8016ee6:	f46f 1280 	mvn.w	r2, #1048576	@ 0x100000
 8016eea:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->EncoderIndexCallback(htim);
#else
      HAL_TIMEx_EncoderIndexCallback(htim);
 8016eec:	6878      	ldr	r0, [r7, #4]
 8016eee:	f000 fe40 	bl	8017b72 <HAL_TIMEx_EncoderIndexCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Direction change event */
  if ((itflag & (TIM_FLAG_DIR)) == (TIM_FLAG_DIR))
 8016ef2:	68bb      	ldr	r3, [r7, #8]
 8016ef4:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
 8016ef8:	2b00      	cmp	r3, #0
 8016efa:	d00c      	beq.n	8016f16 <HAL_TIM_IRQHandler+0x24e>
  {
    if ((itsource & (TIM_IT_DIR)) == (TIM_IT_DIR))
 8016efc:	68fb      	ldr	r3, [r7, #12]
 8016efe:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
 8016f02:	2b00      	cmp	r3, #0
 8016f04:	d007      	beq.n	8016f16 <HAL_TIM_IRQHandler+0x24e>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_DIR);
 8016f06:	687b      	ldr	r3, [r7, #4]
 8016f08:	681b      	ldr	r3, [r3, #0]
 8016f0a:	f46f 1200 	mvn.w	r2, #2097152	@ 0x200000
 8016f0e:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->DirectionChangeCallback(htim);
#else
      HAL_TIMEx_DirectionChangeCallback(htim);
 8016f10:	6878      	ldr	r0, [r7, #4]
 8016f12:	f000 fe38 	bl	8017b86 <HAL_TIMEx_DirectionChangeCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Index error event */
  if ((itflag & (TIM_FLAG_IERR)) == (TIM_FLAG_IERR))
 8016f16:	68bb      	ldr	r3, [r7, #8]
 8016f18:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
 8016f1c:	2b00      	cmp	r3, #0
 8016f1e:	d00c      	beq.n	8016f3a <HAL_TIM_IRQHandler+0x272>
  {
    if ((itsource & (TIM_IT_IERR)) == (TIM_IT_IERR))
 8016f20:	68fb      	ldr	r3, [r7, #12]
 8016f22:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
 8016f26:	2b00      	cmp	r3, #0
 8016f28:	d007      	beq.n	8016f3a <HAL_TIM_IRQHandler+0x272>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_IERR);
 8016f2a:	687b      	ldr	r3, [r7, #4]
 8016f2c:	681b      	ldr	r3, [r3, #0]
 8016f2e:	f46f 0280 	mvn.w	r2, #4194304	@ 0x400000
 8016f32:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->IndexErrorCallback(htim);
#else
      HAL_TIMEx_IndexErrorCallback(htim);
 8016f34:	6878      	ldr	r0, [r7, #4]
 8016f36:	f000 fe30 	bl	8017b9a <HAL_TIMEx_IndexErrorCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Transition error event */
  if ((itflag & (TIM_FLAG_TERR)) == (TIM_FLAG_TERR))
 8016f3a:	68bb      	ldr	r3, [r7, #8]
 8016f3c:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 8016f40:	2b00      	cmp	r3, #0
 8016f42:	d00c      	beq.n	8016f5e <HAL_TIM_IRQHandler+0x296>
  {
    if ((itsource & (TIM_IT_TERR)) == (TIM_IT_TERR))
 8016f44:	68fb      	ldr	r3, [r7, #12]
 8016f46:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 8016f4a:	2b00      	cmp	r3, #0
 8016f4c:	d007      	beq.n	8016f5e <HAL_TIM_IRQHandler+0x296>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_TERR);
 8016f4e:	687b      	ldr	r3, [r7, #4]
 8016f50:	681b      	ldr	r3, [r3, #0]
 8016f52:	f46f 0200 	mvn.w	r2, #8388608	@ 0x800000
 8016f56:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->TransitionErrorCallback(htim);
#else
      HAL_TIMEx_TransitionErrorCallback(htim);
 8016f58:	6878      	ldr	r0, [r7, #4]
 8016f5a:	f000 fe28 	bl	8017bae <HAL_TIMEx_TransitionErrorCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
}
 8016f5e:	bf00      	nop
 8016f60:	3710      	adds	r7, #16
 8016f62:	46bd      	mov	sp, r7
 8016f64:	bd80      	pop	{r7, pc}
	...

08016f68 <HAL_TIM_OC_ConfigChannel>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_OC_ConfigChannel(TIM_HandleTypeDef *htim,
                                           const TIM_OC_InitTypeDef *sConfig,
                                           uint32_t Channel)
{
 8016f68:	b580      	push	{r7, lr}
 8016f6a:	b086      	sub	sp, #24
 8016f6c:	af00      	add	r7, sp, #0
 8016f6e:	60f8      	str	r0, [r7, #12]
 8016f70:	60b9      	str	r1, [r7, #8]
 8016f72:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 8016f74:	2300      	movs	r3, #0
 8016f76:	75fb      	strb	r3, [r7, #23]
  assert_param(IS_TIM_CHANNELS(Channel));
  assert_param(IS_TIM_OC_CHANNEL_MODE(sConfig->OCMode, Channel));
  assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));

  /* Process Locked */
  __HAL_LOCK(htim);
 8016f78:	68fb      	ldr	r3, [r7, #12]
 8016f7a:	f893 303c 	ldrb.w	r3, [r3, #60]	@ 0x3c
 8016f7e:	2b01      	cmp	r3, #1
 8016f80:	d101      	bne.n	8016f86 <HAL_TIM_OC_ConfigChannel+0x1e>
 8016f82:	2302      	movs	r3, #2
 8016f84:	e066      	b.n	8017054 <HAL_TIM_OC_ConfigChannel+0xec>
 8016f86:	68fb      	ldr	r3, [r7, #12]
 8016f88:	2201      	movs	r2, #1
 8016f8a:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

  switch (Channel)
 8016f8e:	687b      	ldr	r3, [r7, #4]
 8016f90:	2b14      	cmp	r3, #20
 8016f92:	d857      	bhi.n	8017044 <HAL_TIM_OC_ConfigChannel+0xdc>
 8016f94:	a201      	add	r2, pc, #4	@ (adr r2, 8016f9c <HAL_TIM_OC_ConfigChannel+0x34>)
 8016f96:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8016f9a:	bf00      	nop
 8016f9c:	08016ff1 	.word	0x08016ff1
 8016fa0:	08017045 	.word	0x08017045
 8016fa4:	08017045 	.word	0x08017045
 8016fa8:	08017045 	.word	0x08017045
 8016fac:	08016fff 	.word	0x08016fff
 8016fb0:	08017045 	.word	0x08017045
 8016fb4:	08017045 	.word	0x08017045
 8016fb8:	08017045 	.word	0x08017045
 8016fbc:	0801700d 	.word	0x0801700d
 8016fc0:	08017045 	.word	0x08017045
 8016fc4:	08017045 	.word	0x08017045
 8016fc8:	08017045 	.word	0x08017045
 8016fcc:	0801701b 	.word	0x0801701b
 8016fd0:	08017045 	.word	0x08017045
 8016fd4:	08017045 	.word	0x08017045
 8016fd8:	08017045 	.word	0x08017045
 8016fdc:	08017029 	.word	0x08017029
 8016fe0:	08017045 	.word	0x08017045
 8016fe4:	08017045 	.word	0x08017045
 8016fe8:	08017045 	.word	0x08017045
 8016fec:	08017037 	.word	0x08017037
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));

      /* Configure the TIM Channel 1 in Output Compare */
      TIM_OC1_SetConfig(htim->Instance, sConfig);
 8016ff0:	68fb      	ldr	r3, [r7, #12]
 8016ff2:	681b      	ldr	r3, [r3, #0]
 8016ff4:	68b9      	ldr	r1, [r7, #8]
 8016ff6:	4618      	mov	r0, r3
 8016ff8:	f000 f9a2 	bl	8017340 <TIM_OC1_SetConfig>
      break;
 8016ffc:	e025      	b.n	801704a <HAL_TIM_OC_ConfigChannel+0xe2>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));

      /* Configure the TIM Channel 2 in Output Compare */
      TIM_OC2_SetConfig(htim->Instance, sConfig);
 8016ffe:	68fb      	ldr	r3, [r7, #12]
 8017000:	681b      	ldr	r3, [r3, #0]
 8017002:	68b9      	ldr	r1, [r7, #8]
 8017004:	4618      	mov	r0, r3
 8017006:	f000 fa5d 	bl	80174c4 <TIM_OC2_SetConfig>
      break;
 801700a:	e01e      	b.n	801704a <HAL_TIM_OC_ConfigChannel+0xe2>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));

      /* Configure the TIM Channel 3 in Output Compare */
      TIM_OC3_SetConfig(htim->Instance, sConfig);
 801700c:	68fb      	ldr	r3, [r7, #12]
 801700e:	681b      	ldr	r3, [r3, #0]
 8017010:	68b9      	ldr	r1, [r7, #8]
 8017012:	4618      	mov	r0, r3
 8017014:	f000 fb06 	bl	8017624 <TIM_OC3_SetConfig>
      break;
 8017018:	e017      	b.n	801704a <HAL_TIM_OC_ConfigChannel+0xe2>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));

      /* Configure the TIM Channel 4 in Output Compare */
      TIM_OC4_SetConfig(htim->Instance, sConfig);
 801701a:	68fb      	ldr	r3, [r7, #12]
 801701c:	681b      	ldr	r3, [r3, #0]
 801701e:	68b9      	ldr	r1, [r7, #8]
 8017020:	4618      	mov	r0, r3
 8017022:	f000 fbad 	bl	8017780 <TIM_OC4_SetConfig>
      break;
 8017026:	e010      	b.n	801704a <HAL_TIM_OC_ConfigChannel+0xe2>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC5_INSTANCE(htim->Instance));

      /* Configure the TIM Channel 5 in Output Compare */
      TIM_OC5_SetConfig(htim->Instance, sConfig);
 8017028:	68fb      	ldr	r3, [r7, #12]
 801702a:	681b      	ldr	r3, [r3, #0]
 801702c:	68b9      	ldr	r1, [r7, #8]
 801702e:	4618      	mov	r0, r3
 8017030:	f000 fc56 	bl	80178e0 <TIM_OC5_SetConfig>
      break;
 8017034:	e009      	b.n	801704a <HAL_TIM_OC_ConfigChannel+0xe2>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC6_INSTANCE(htim->Instance));

      /* Configure the TIM Channel 6 in Output Compare */
      TIM_OC6_SetConfig(htim->Instance, sConfig);
 8017036:	68fb      	ldr	r3, [r7, #12]
 8017038:	681b      	ldr	r3, [r3, #0]
 801703a:	68b9      	ldr	r1, [r7, #8]
 801703c:	4618      	mov	r0, r3
 801703e:	f000 fcd1 	bl	80179e4 <TIM_OC6_SetConfig>
      break;
 8017042:	e002      	b.n	801704a <HAL_TIM_OC_ConfigChannel+0xe2>
    }

    default:
      status = HAL_ERROR;
 8017044:	2301      	movs	r3, #1
 8017046:	75fb      	strb	r3, [r7, #23]
      break;
 8017048:	bf00      	nop
  }

  __HAL_UNLOCK(htim);
 801704a:	68fb      	ldr	r3, [r7, #12]
 801704c:	2200      	movs	r2, #0
 801704e:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

  return status;
 8017052:	7dfb      	ldrb	r3, [r7, #23]
}
 8017054:	4618      	mov	r0, r3
 8017056:	3718      	adds	r7, #24
 8017058:	46bd      	mov	sp, r7
 801705a:	bd80      	pop	{r7, pc}

0801705c <HAL_TIM_ReadCapturedValue>:
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval Captured value
  */
uint32_t HAL_TIM_ReadCapturedValue(const TIM_HandleTypeDef *htim, uint32_t Channel)
{
 801705c:	b480      	push	{r7}
 801705e:	b085      	sub	sp, #20
 8017060:	af00      	add	r7, sp, #0
 8017062:	6078      	str	r0, [r7, #4]
 8017064:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0U;
 8017066:	2300      	movs	r3, #0
 8017068:	60fb      	str	r3, [r7, #12]

  switch (Channel)
 801706a:	683b      	ldr	r3, [r7, #0]
 801706c:	2b0c      	cmp	r3, #12
 801706e:	d831      	bhi.n	80170d4 <HAL_TIM_ReadCapturedValue+0x78>
 8017070:	a201      	add	r2, pc, #4	@ (adr r2, 8017078 <HAL_TIM_ReadCapturedValue+0x1c>)
 8017072:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8017076:	bf00      	nop
 8017078:	080170ad 	.word	0x080170ad
 801707c:	080170d5 	.word	0x080170d5
 8017080:	080170d5 	.word	0x080170d5
 8017084:	080170d5 	.word	0x080170d5
 8017088:	080170b7 	.word	0x080170b7
 801708c:	080170d5 	.word	0x080170d5
 8017090:	080170d5 	.word	0x080170d5
 8017094:	080170d5 	.word	0x080170d5
 8017098:	080170c1 	.word	0x080170c1
 801709c:	080170d5 	.word	0x080170d5
 80170a0:	080170d5 	.word	0x080170d5
 80170a4:	080170d5 	.word	0x080170d5
 80170a8:	080170cb 	.word	0x080170cb
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));

      /* Return the capture 1 value */
      tmpreg =  htim->Instance->CCR1;
 80170ac:	687b      	ldr	r3, [r7, #4]
 80170ae:	681b      	ldr	r3, [r3, #0]
 80170b0:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80170b2:	60fb      	str	r3, [r7, #12]

      break;
 80170b4:	e00f      	b.n	80170d6 <HAL_TIM_ReadCapturedValue+0x7a>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));

      /* Return the capture 2 value */
      tmpreg =   htim->Instance->CCR2;
 80170b6:	687b      	ldr	r3, [r7, #4]
 80170b8:	681b      	ldr	r3, [r3, #0]
 80170ba:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80170bc:	60fb      	str	r3, [r7, #12]

      break;
 80170be:	e00a      	b.n	80170d6 <HAL_TIM_ReadCapturedValue+0x7a>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));

      /* Return the capture 3 value */
      tmpreg =   htim->Instance->CCR3;
 80170c0:	687b      	ldr	r3, [r7, #4]
 80170c2:	681b      	ldr	r3, [r3, #0]
 80170c4:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80170c6:	60fb      	str	r3, [r7, #12]

      break;
 80170c8:	e005      	b.n	80170d6 <HAL_TIM_ReadCapturedValue+0x7a>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));

      /* Return the capture 4 value */
      tmpreg =   htim->Instance->CCR4;
 80170ca:	687b      	ldr	r3, [r7, #4]
 80170cc:	681b      	ldr	r3, [r3, #0]
 80170ce:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80170d0:	60fb      	str	r3, [r7, #12]

      break;
 80170d2:	e000      	b.n	80170d6 <HAL_TIM_ReadCapturedValue+0x7a>
    }

    default:
      break;
 80170d4:	bf00      	nop
  }

  return tmpreg;
 80170d6:	68fb      	ldr	r3, [r7, #12]
}
 80170d8:	4618      	mov	r0, r3
 80170da:	3714      	adds	r7, #20
 80170dc:	46bd      	mov	sp, r7
 80170de:	f85d 7b04 	ldr.w	r7, [sp], #4
 80170e2:	4770      	bx	lr

080170e4 <HAL_TIM_PeriodElapsedCallback>:
  * @brief  Period elapsed callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
 80170e4:	b480      	push	{r7}
 80170e6:	b083      	sub	sp, #12
 80170e8:	af00      	add	r7, sp, #0
 80170ea:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_PeriodElapsedCallback could be implemented in the user file
   */
}
 80170ec:	bf00      	nop
 80170ee:	370c      	adds	r7, #12
 80170f0:	46bd      	mov	sp, r7
 80170f2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80170f6:	4770      	bx	lr

080170f8 <HAL_TIM_IC_CaptureCallback>:
  * @brief  Input Capture callback in non-blocking mode
  * @param  htim TIM IC handle
  * @retval None
  */
__weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
{
 80170f8:	b480      	push	{r7}
 80170fa:	b083      	sub	sp, #12
 80170fc:	af00      	add	r7, sp, #0
 80170fe:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_IC_CaptureCallback could be implemented in the user file
   */
}
 8017100:	bf00      	nop
 8017102:	370c      	adds	r7, #12
 8017104:	46bd      	mov	sp, r7
 8017106:	f85d 7b04 	ldr.w	r7, [sp], #4
 801710a:	4770      	bx	lr

0801710c <HAL_TIM_PWM_PulseFinishedCallback>:
  * @brief  PWM Pulse finished callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
{
 801710c:	b480      	push	{r7}
 801710e:	b083      	sub	sp, #12
 8017110:	af00      	add	r7, sp, #0
 8017112:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
   */
}
 8017114:	bf00      	nop
 8017116:	370c      	adds	r7, #12
 8017118:	46bd      	mov	sp, r7
 801711a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801711e:	4770      	bx	lr

08017120 <HAL_TIM_TriggerCallback>:
  * @brief  Hall Trigger detection callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
{
 8017120:	b480      	push	{r7}
 8017122:	b083      	sub	sp, #12
 8017124:	af00      	add	r7, sp, #0
 8017126:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_TriggerCallback could be implemented in the user file
   */
}
 8017128:	bf00      	nop
 801712a:	370c      	adds	r7, #12
 801712c:	46bd      	mov	sp, r7
 801712e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017132:	4770      	bx	lr

08017134 <TIM_Base_SetConfig>:
  * @param  TIMx TIM peripheral
  * @param  Structure TIM Base configuration structure
  * @retval None
  */
void TIM_Base_SetConfig(TIM_TypeDef *TIMx, const TIM_Base_InitTypeDef *Structure)
{
 8017134:	b480      	push	{r7}
 8017136:	b085      	sub	sp, #20
 8017138:	af00      	add	r7, sp, #0
 801713a:	6078      	str	r0, [r7, #4]
 801713c:	6039      	str	r1, [r7, #0]
  uint32_t tmpcr1;
  tmpcr1 = TIMx->CR1;
 801713e:	687b      	ldr	r3, [r7, #4]
 8017140:	681b      	ldr	r3, [r3, #0]
 8017142:	60fb      	str	r3, [r7, #12]

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8017144:	687b      	ldr	r3, [r7, #4]
 8017146:	4a6e      	ldr	r2, [pc, #440]	@ (8017300 <TIM_Base_SetConfig+0x1cc>)
 8017148:	4293      	cmp	r3, r2
 801714a:	d02b      	beq.n	80171a4 <TIM_Base_SetConfig+0x70>
 801714c:	687b      	ldr	r3, [r7, #4]
 801714e:	4a6d      	ldr	r2, [pc, #436]	@ (8017304 <TIM_Base_SetConfig+0x1d0>)
 8017150:	4293      	cmp	r3, r2
 8017152:	d027      	beq.n	80171a4 <TIM_Base_SetConfig+0x70>
 8017154:	687b      	ldr	r3, [r7, #4]
 8017156:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 801715a:	d023      	beq.n	80171a4 <TIM_Base_SetConfig+0x70>
 801715c:	687b      	ldr	r3, [r7, #4]
 801715e:	f1b3 4fa0 	cmp.w	r3, #1342177280	@ 0x50000000
 8017162:	d01f      	beq.n	80171a4 <TIM_Base_SetConfig+0x70>
 8017164:	687b      	ldr	r3, [r7, #4]
 8017166:	4a68      	ldr	r2, [pc, #416]	@ (8017308 <TIM_Base_SetConfig+0x1d4>)
 8017168:	4293      	cmp	r3, r2
 801716a:	d01b      	beq.n	80171a4 <TIM_Base_SetConfig+0x70>
 801716c:	687b      	ldr	r3, [r7, #4]
 801716e:	4a67      	ldr	r2, [pc, #412]	@ (801730c <TIM_Base_SetConfig+0x1d8>)
 8017170:	4293      	cmp	r3, r2
 8017172:	d017      	beq.n	80171a4 <TIM_Base_SetConfig+0x70>
 8017174:	687b      	ldr	r3, [r7, #4]
 8017176:	4a66      	ldr	r2, [pc, #408]	@ (8017310 <TIM_Base_SetConfig+0x1dc>)
 8017178:	4293      	cmp	r3, r2
 801717a:	d013      	beq.n	80171a4 <TIM_Base_SetConfig+0x70>
 801717c:	687b      	ldr	r3, [r7, #4]
 801717e:	4a65      	ldr	r2, [pc, #404]	@ (8017314 <TIM_Base_SetConfig+0x1e0>)
 8017180:	4293      	cmp	r3, r2
 8017182:	d00f      	beq.n	80171a4 <TIM_Base_SetConfig+0x70>
 8017184:	687b      	ldr	r3, [r7, #4]
 8017186:	4a64      	ldr	r2, [pc, #400]	@ (8017318 <TIM_Base_SetConfig+0x1e4>)
 8017188:	4293      	cmp	r3, r2
 801718a:	d00b      	beq.n	80171a4 <TIM_Base_SetConfig+0x70>
 801718c:	687b      	ldr	r3, [r7, #4]
 801718e:	4a63      	ldr	r2, [pc, #396]	@ (801731c <TIM_Base_SetConfig+0x1e8>)
 8017190:	4293      	cmp	r3, r2
 8017192:	d007      	beq.n	80171a4 <TIM_Base_SetConfig+0x70>
 8017194:	687b      	ldr	r3, [r7, #4]
 8017196:	4a62      	ldr	r2, [pc, #392]	@ (8017320 <TIM_Base_SetConfig+0x1ec>)
 8017198:	4293      	cmp	r3, r2
 801719a:	d003      	beq.n	80171a4 <TIM_Base_SetConfig+0x70>
 801719c:	687b      	ldr	r3, [r7, #4]
 801719e:	4a61      	ldr	r2, [pc, #388]	@ (8017324 <TIM_Base_SetConfig+0x1f0>)
 80171a0:	4293      	cmp	r3, r2
 80171a2:	d108      	bne.n	80171b6 <TIM_Base_SetConfig+0x82>
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 80171a4:	68fb      	ldr	r3, [r7, #12]
 80171a6:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
 80171aa:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= Structure->CounterMode;
 80171ac:	683b      	ldr	r3, [r7, #0]
 80171ae:	685b      	ldr	r3, [r3, #4]
 80171b0:	68fa      	ldr	r2, [r7, #12]
 80171b2:	4313      	orrs	r3, r2
 80171b4:	60fb      	str	r3, [r7, #12]
  }

  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 80171b6:	687b      	ldr	r3, [r7, #4]
 80171b8:	4a51      	ldr	r2, [pc, #324]	@ (8017300 <TIM_Base_SetConfig+0x1cc>)
 80171ba:	4293      	cmp	r3, r2
 80171bc:	d043      	beq.n	8017246 <TIM_Base_SetConfig+0x112>
 80171be:	687b      	ldr	r3, [r7, #4]
 80171c0:	4a50      	ldr	r2, [pc, #320]	@ (8017304 <TIM_Base_SetConfig+0x1d0>)
 80171c2:	4293      	cmp	r3, r2
 80171c4:	d03f      	beq.n	8017246 <TIM_Base_SetConfig+0x112>
 80171c6:	687b      	ldr	r3, [r7, #4]
 80171c8:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 80171cc:	d03b      	beq.n	8017246 <TIM_Base_SetConfig+0x112>
 80171ce:	687b      	ldr	r3, [r7, #4]
 80171d0:	f1b3 4fa0 	cmp.w	r3, #1342177280	@ 0x50000000
 80171d4:	d037      	beq.n	8017246 <TIM_Base_SetConfig+0x112>
 80171d6:	687b      	ldr	r3, [r7, #4]
 80171d8:	4a4b      	ldr	r2, [pc, #300]	@ (8017308 <TIM_Base_SetConfig+0x1d4>)
 80171da:	4293      	cmp	r3, r2
 80171dc:	d033      	beq.n	8017246 <TIM_Base_SetConfig+0x112>
 80171de:	687b      	ldr	r3, [r7, #4]
 80171e0:	4a4a      	ldr	r2, [pc, #296]	@ (801730c <TIM_Base_SetConfig+0x1d8>)
 80171e2:	4293      	cmp	r3, r2
 80171e4:	d02f      	beq.n	8017246 <TIM_Base_SetConfig+0x112>
 80171e6:	687b      	ldr	r3, [r7, #4]
 80171e8:	4a49      	ldr	r2, [pc, #292]	@ (8017310 <TIM_Base_SetConfig+0x1dc>)
 80171ea:	4293      	cmp	r3, r2
 80171ec:	d02b      	beq.n	8017246 <TIM_Base_SetConfig+0x112>
 80171ee:	687b      	ldr	r3, [r7, #4]
 80171f0:	4a48      	ldr	r2, [pc, #288]	@ (8017314 <TIM_Base_SetConfig+0x1e0>)
 80171f2:	4293      	cmp	r3, r2
 80171f4:	d027      	beq.n	8017246 <TIM_Base_SetConfig+0x112>
 80171f6:	687b      	ldr	r3, [r7, #4]
 80171f8:	4a47      	ldr	r2, [pc, #284]	@ (8017318 <TIM_Base_SetConfig+0x1e4>)
 80171fa:	4293      	cmp	r3, r2
 80171fc:	d023      	beq.n	8017246 <TIM_Base_SetConfig+0x112>
 80171fe:	687b      	ldr	r3, [r7, #4]
 8017200:	4a46      	ldr	r2, [pc, #280]	@ (801731c <TIM_Base_SetConfig+0x1e8>)
 8017202:	4293      	cmp	r3, r2
 8017204:	d01f      	beq.n	8017246 <TIM_Base_SetConfig+0x112>
 8017206:	687b      	ldr	r3, [r7, #4]
 8017208:	4a45      	ldr	r2, [pc, #276]	@ (8017320 <TIM_Base_SetConfig+0x1ec>)
 801720a:	4293      	cmp	r3, r2
 801720c:	d01b      	beq.n	8017246 <TIM_Base_SetConfig+0x112>
 801720e:	687b      	ldr	r3, [r7, #4]
 8017210:	4a44      	ldr	r2, [pc, #272]	@ (8017324 <TIM_Base_SetConfig+0x1f0>)
 8017212:	4293      	cmp	r3, r2
 8017214:	d017      	beq.n	8017246 <TIM_Base_SetConfig+0x112>
 8017216:	687b      	ldr	r3, [r7, #4]
 8017218:	4a43      	ldr	r2, [pc, #268]	@ (8017328 <TIM_Base_SetConfig+0x1f4>)
 801721a:	4293      	cmp	r3, r2
 801721c:	d013      	beq.n	8017246 <TIM_Base_SetConfig+0x112>
 801721e:	687b      	ldr	r3, [r7, #4]
 8017220:	4a42      	ldr	r2, [pc, #264]	@ (801732c <TIM_Base_SetConfig+0x1f8>)
 8017222:	4293      	cmp	r3, r2
 8017224:	d00f      	beq.n	8017246 <TIM_Base_SetConfig+0x112>
 8017226:	687b      	ldr	r3, [r7, #4]
 8017228:	4a41      	ldr	r2, [pc, #260]	@ (8017330 <TIM_Base_SetConfig+0x1fc>)
 801722a:	4293      	cmp	r3, r2
 801722c:	d00b      	beq.n	8017246 <TIM_Base_SetConfig+0x112>
 801722e:	687b      	ldr	r3, [r7, #4]
 8017230:	4a40      	ldr	r2, [pc, #256]	@ (8017334 <TIM_Base_SetConfig+0x200>)
 8017232:	4293      	cmp	r3, r2
 8017234:	d007      	beq.n	8017246 <TIM_Base_SetConfig+0x112>
 8017236:	687b      	ldr	r3, [r7, #4]
 8017238:	4a3f      	ldr	r2, [pc, #252]	@ (8017338 <TIM_Base_SetConfig+0x204>)
 801723a:	4293      	cmp	r3, r2
 801723c:	d003      	beq.n	8017246 <TIM_Base_SetConfig+0x112>
 801723e:	687b      	ldr	r3, [r7, #4]
 8017240:	4a3e      	ldr	r2, [pc, #248]	@ (801733c <TIM_Base_SetConfig+0x208>)
 8017242:	4293      	cmp	r3, r2
 8017244:	d108      	bne.n	8017258 <TIM_Base_SetConfig+0x124>
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
 8017246:	68fb      	ldr	r3, [r7, #12]
 8017248:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
 801724c:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 801724e:	683b      	ldr	r3, [r7, #0]
 8017250:	68db      	ldr	r3, [r3, #12]
 8017252:	68fa      	ldr	r2, [r7, #12]
 8017254:	4313      	orrs	r3, r2
 8017256:	60fb      	str	r3, [r7, #12]
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8017258:	68fb      	ldr	r3, [r7, #12]
 801725a:	f023 0280 	bic.w	r2, r3, #128	@ 0x80
 801725e:	683b      	ldr	r3, [r7, #0]
 8017260:	695b      	ldr	r3, [r3, #20]
 8017262:	4313      	orrs	r3, r2
 8017264:	60fb      	str	r3, [r7, #12]

  TIMx->CR1 = tmpcr1;
 8017266:	687b      	ldr	r3, [r7, #4]
 8017268:	68fa      	ldr	r2, [r7, #12]
 801726a:	601a      	str	r2, [r3, #0]

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 801726c:	683b      	ldr	r3, [r7, #0]
 801726e:	689a      	ldr	r2, [r3, #8]
 8017270:	687b      	ldr	r3, [r7, #4]
 8017272:	62da      	str	r2, [r3, #44]	@ 0x2c

  /* Set the Prescaler value */
  TIMx->PSC = Structure->Prescaler;
 8017274:	683b      	ldr	r3, [r7, #0]
 8017276:	681a      	ldr	r2, [r3, #0]
 8017278:	687b      	ldr	r3, [r7, #4]
 801727a:	629a      	str	r2, [r3, #40]	@ 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 801727c:	687b      	ldr	r3, [r7, #4]
 801727e:	4a20      	ldr	r2, [pc, #128]	@ (8017300 <TIM_Base_SetConfig+0x1cc>)
 8017280:	4293      	cmp	r3, r2
 8017282:	d023      	beq.n	80172cc <TIM_Base_SetConfig+0x198>
 8017284:	687b      	ldr	r3, [r7, #4]
 8017286:	4a1f      	ldr	r2, [pc, #124]	@ (8017304 <TIM_Base_SetConfig+0x1d0>)
 8017288:	4293      	cmp	r3, r2
 801728a:	d01f      	beq.n	80172cc <TIM_Base_SetConfig+0x198>
 801728c:	687b      	ldr	r3, [r7, #4]
 801728e:	4a24      	ldr	r2, [pc, #144]	@ (8017320 <TIM_Base_SetConfig+0x1ec>)
 8017290:	4293      	cmp	r3, r2
 8017292:	d01b      	beq.n	80172cc <TIM_Base_SetConfig+0x198>
 8017294:	687b      	ldr	r3, [r7, #4]
 8017296:	4a23      	ldr	r2, [pc, #140]	@ (8017324 <TIM_Base_SetConfig+0x1f0>)
 8017298:	4293      	cmp	r3, r2
 801729a:	d017      	beq.n	80172cc <TIM_Base_SetConfig+0x198>
 801729c:	687b      	ldr	r3, [r7, #4]
 801729e:	4a22      	ldr	r2, [pc, #136]	@ (8017328 <TIM_Base_SetConfig+0x1f4>)
 80172a0:	4293      	cmp	r3, r2
 80172a2:	d013      	beq.n	80172cc <TIM_Base_SetConfig+0x198>
 80172a4:	687b      	ldr	r3, [r7, #4]
 80172a6:	4a21      	ldr	r2, [pc, #132]	@ (801732c <TIM_Base_SetConfig+0x1f8>)
 80172a8:	4293      	cmp	r3, r2
 80172aa:	d00f      	beq.n	80172cc <TIM_Base_SetConfig+0x198>
 80172ac:	687b      	ldr	r3, [r7, #4]
 80172ae:	4a20      	ldr	r2, [pc, #128]	@ (8017330 <TIM_Base_SetConfig+0x1fc>)
 80172b0:	4293      	cmp	r3, r2
 80172b2:	d00b      	beq.n	80172cc <TIM_Base_SetConfig+0x198>
 80172b4:	687b      	ldr	r3, [r7, #4]
 80172b6:	4a1f      	ldr	r2, [pc, #124]	@ (8017334 <TIM_Base_SetConfig+0x200>)
 80172b8:	4293      	cmp	r3, r2
 80172ba:	d007      	beq.n	80172cc <TIM_Base_SetConfig+0x198>
 80172bc:	687b      	ldr	r3, [r7, #4]
 80172be:	4a1e      	ldr	r2, [pc, #120]	@ (8017338 <TIM_Base_SetConfig+0x204>)
 80172c0:	4293      	cmp	r3, r2
 80172c2:	d003      	beq.n	80172cc <TIM_Base_SetConfig+0x198>
 80172c4:	687b      	ldr	r3, [r7, #4]
 80172c6:	4a1d      	ldr	r2, [pc, #116]	@ (801733c <TIM_Base_SetConfig+0x208>)
 80172c8:	4293      	cmp	r3, r2
 80172ca:	d103      	bne.n	80172d4 <TIM_Base_SetConfig+0x1a0>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = Structure->RepetitionCounter;
 80172cc:	683b      	ldr	r3, [r7, #0]
 80172ce:	691a      	ldr	r2, [r3, #16]
 80172d0:	687b      	ldr	r3, [r7, #4]
 80172d2:	631a      	str	r2, [r3, #48]	@ 0x30
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 80172d4:	687b      	ldr	r3, [r7, #4]
 80172d6:	2201      	movs	r2, #1
 80172d8:	615a      	str	r2, [r3, #20]

  /* Check if the update flag is set after the Update Generation, if so clear the UIF flag */
  if (HAL_IS_BIT_SET(TIMx->SR, TIM_FLAG_UPDATE))
 80172da:	687b      	ldr	r3, [r7, #4]
 80172dc:	691b      	ldr	r3, [r3, #16]
 80172de:	f003 0301 	and.w	r3, r3, #1
 80172e2:	2b01      	cmp	r3, #1
 80172e4:	d105      	bne.n	80172f2 <TIM_Base_SetConfig+0x1be>
  {
    /* Clear the update flag */
    CLEAR_BIT(TIMx->SR, TIM_FLAG_UPDATE);
 80172e6:	687b      	ldr	r3, [r7, #4]
 80172e8:	691b      	ldr	r3, [r3, #16]
 80172ea:	f023 0201 	bic.w	r2, r3, #1
 80172ee:	687b      	ldr	r3, [r7, #4]
 80172f0:	611a      	str	r2, [r3, #16]
  }
}
 80172f2:	bf00      	nop
 80172f4:	3714      	adds	r7, #20
 80172f6:	46bd      	mov	sp, r7
 80172f8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80172fc:	4770      	bx	lr
 80172fe:	bf00      	nop
 8017300:	40012c00 	.word	0x40012c00
 8017304:	50012c00 	.word	0x50012c00
 8017308:	40000400 	.word	0x40000400
 801730c:	50000400 	.word	0x50000400
 8017310:	40000800 	.word	0x40000800
 8017314:	50000800 	.word	0x50000800
 8017318:	40000c00 	.word	0x40000c00
 801731c:	50000c00 	.word	0x50000c00
 8017320:	40013400 	.word	0x40013400
 8017324:	50013400 	.word	0x50013400
 8017328:	40014000 	.word	0x40014000
 801732c:	50014000 	.word	0x50014000
 8017330:	40014400 	.word	0x40014400
 8017334:	50014400 	.word	0x50014400
 8017338:	40014800 	.word	0x40014800
 801733c:	50014800 	.word	0x50014800

08017340 <TIM_OC1_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, const TIM_OC_InitTypeDef *OC_Config)
{
 8017340:	b480      	push	{r7}
 8017342:	b087      	sub	sp, #28
 8017344:	af00      	add	r7, sp, #0
 8017346:	6078      	str	r0, [r7, #4]
 8017348:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 801734a:	687b      	ldr	r3, [r7, #4]
 801734c:	6a1b      	ldr	r3, [r3, #32]
 801734e:	617b      	str	r3, [r7, #20]

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8017350:	687b      	ldr	r3, [r7, #4]
 8017352:	6a1b      	ldr	r3, [r3, #32]
 8017354:	f023 0201 	bic.w	r2, r3, #1
 8017358:	687b      	ldr	r3, [r7, #4]
 801735a:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 801735c:	687b      	ldr	r3, [r7, #4]
 801735e:	685b      	ldr	r3, [r3, #4]
 8017360:	613b      	str	r3, [r7, #16]

  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 8017362:	687b      	ldr	r3, [r7, #4]
 8017364:	699b      	ldr	r3, [r3, #24]
 8017366:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~TIM_CCMR1_OC1M;
 8017368:	68fb      	ldr	r3, [r7, #12]
 801736a:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 801736e:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
 8017372:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR1_CC1S;
 8017374:	68fb      	ldr	r3, [r7, #12]
 8017376:	f023 0303 	bic.w	r3, r3, #3
 801737a:	60fb      	str	r3, [r7, #12]
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 801737c:	683b      	ldr	r3, [r7, #0]
 801737e:	681b      	ldr	r3, [r3, #0]
 8017380:	68fa      	ldr	r2, [r7, #12]
 8017382:	4313      	orrs	r3, r2
 8017384:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC1P;
 8017386:	697b      	ldr	r3, [r7, #20]
 8017388:	f023 0302 	bic.w	r3, r3, #2
 801738c:	617b      	str	r3, [r7, #20]
  /* Set the Output Compare Polarity */
  tmpccer |= OC_Config->OCPolarity;
 801738e:	683b      	ldr	r3, [r7, #0]
 8017390:	689b      	ldr	r3, [r3, #8]
 8017392:	697a      	ldr	r2, [r7, #20]
 8017394:	4313      	orrs	r3, r2
 8017396:	617b      	str	r3, [r7, #20]

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
 8017398:	687b      	ldr	r3, [r7, #4]
 801739a:	4a40      	ldr	r2, [pc, #256]	@ (801749c <TIM_OC1_SetConfig+0x15c>)
 801739c:	4293      	cmp	r3, r2
 801739e:	d023      	beq.n	80173e8 <TIM_OC1_SetConfig+0xa8>
 80173a0:	687b      	ldr	r3, [r7, #4]
 80173a2:	4a3f      	ldr	r2, [pc, #252]	@ (80174a0 <TIM_OC1_SetConfig+0x160>)
 80173a4:	4293      	cmp	r3, r2
 80173a6:	d01f      	beq.n	80173e8 <TIM_OC1_SetConfig+0xa8>
 80173a8:	687b      	ldr	r3, [r7, #4]
 80173aa:	4a3e      	ldr	r2, [pc, #248]	@ (80174a4 <TIM_OC1_SetConfig+0x164>)
 80173ac:	4293      	cmp	r3, r2
 80173ae:	d01b      	beq.n	80173e8 <TIM_OC1_SetConfig+0xa8>
 80173b0:	687b      	ldr	r3, [r7, #4]
 80173b2:	4a3d      	ldr	r2, [pc, #244]	@ (80174a8 <TIM_OC1_SetConfig+0x168>)
 80173b4:	4293      	cmp	r3, r2
 80173b6:	d017      	beq.n	80173e8 <TIM_OC1_SetConfig+0xa8>
 80173b8:	687b      	ldr	r3, [r7, #4]
 80173ba:	4a3c      	ldr	r2, [pc, #240]	@ (80174ac <TIM_OC1_SetConfig+0x16c>)
 80173bc:	4293      	cmp	r3, r2
 80173be:	d013      	beq.n	80173e8 <TIM_OC1_SetConfig+0xa8>
 80173c0:	687b      	ldr	r3, [r7, #4]
 80173c2:	4a3b      	ldr	r2, [pc, #236]	@ (80174b0 <TIM_OC1_SetConfig+0x170>)
 80173c4:	4293      	cmp	r3, r2
 80173c6:	d00f      	beq.n	80173e8 <TIM_OC1_SetConfig+0xa8>
 80173c8:	687b      	ldr	r3, [r7, #4]
 80173ca:	4a3a      	ldr	r2, [pc, #232]	@ (80174b4 <TIM_OC1_SetConfig+0x174>)
 80173cc:	4293      	cmp	r3, r2
 80173ce:	d00b      	beq.n	80173e8 <TIM_OC1_SetConfig+0xa8>
 80173d0:	687b      	ldr	r3, [r7, #4]
 80173d2:	4a39      	ldr	r2, [pc, #228]	@ (80174b8 <TIM_OC1_SetConfig+0x178>)
 80173d4:	4293      	cmp	r3, r2
 80173d6:	d007      	beq.n	80173e8 <TIM_OC1_SetConfig+0xa8>
 80173d8:	687b      	ldr	r3, [r7, #4]
 80173da:	4a38      	ldr	r2, [pc, #224]	@ (80174bc <TIM_OC1_SetConfig+0x17c>)
 80173dc:	4293      	cmp	r3, r2
 80173de:	d003      	beq.n	80173e8 <TIM_OC1_SetConfig+0xa8>
 80173e0:	687b      	ldr	r3, [r7, #4]
 80173e2:	4a37      	ldr	r2, [pc, #220]	@ (80174c0 <TIM_OC1_SetConfig+0x180>)
 80173e4:	4293      	cmp	r3, r2
 80173e6:	d10c      	bne.n	8017402 <TIM_OC1_SetConfig+0xc2>
  {
    /* Check parameters */
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC1NP;
 80173e8:	697b      	ldr	r3, [r7, #20]
 80173ea:	f023 0308 	bic.w	r3, r3, #8
 80173ee:	617b      	str	r3, [r7, #20]
    /* Set the Output N Polarity */
    tmpccer |= OC_Config->OCNPolarity;
 80173f0:	683b      	ldr	r3, [r7, #0]
 80173f2:	68db      	ldr	r3, [r3, #12]
 80173f4:	697a      	ldr	r2, [r7, #20]
 80173f6:	4313      	orrs	r3, r2
 80173f8:	617b      	str	r3, [r7, #20]
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC1NE;
 80173fa:	697b      	ldr	r3, [r7, #20]
 80173fc:	f023 0304 	bic.w	r3, r3, #4
 8017400:	617b      	str	r3, [r7, #20]
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8017402:	687b      	ldr	r3, [r7, #4]
 8017404:	4a25      	ldr	r2, [pc, #148]	@ (801749c <TIM_OC1_SetConfig+0x15c>)
 8017406:	4293      	cmp	r3, r2
 8017408:	d023      	beq.n	8017452 <TIM_OC1_SetConfig+0x112>
 801740a:	687b      	ldr	r3, [r7, #4]
 801740c:	4a24      	ldr	r2, [pc, #144]	@ (80174a0 <TIM_OC1_SetConfig+0x160>)
 801740e:	4293      	cmp	r3, r2
 8017410:	d01f      	beq.n	8017452 <TIM_OC1_SetConfig+0x112>
 8017412:	687b      	ldr	r3, [r7, #4]
 8017414:	4a23      	ldr	r2, [pc, #140]	@ (80174a4 <TIM_OC1_SetConfig+0x164>)
 8017416:	4293      	cmp	r3, r2
 8017418:	d01b      	beq.n	8017452 <TIM_OC1_SetConfig+0x112>
 801741a:	687b      	ldr	r3, [r7, #4]
 801741c:	4a22      	ldr	r2, [pc, #136]	@ (80174a8 <TIM_OC1_SetConfig+0x168>)
 801741e:	4293      	cmp	r3, r2
 8017420:	d017      	beq.n	8017452 <TIM_OC1_SetConfig+0x112>
 8017422:	687b      	ldr	r3, [r7, #4]
 8017424:	4a21      	ldr	r2, [pc, #132]	@ (80174ac <TIM_OC1_SetConfig+0x16c>)
 8017426:	4293      	cmp	r3, r2
 8017428:	d013      	beq.n	8017452 <TIM_OC1_SetConfig+0x112>
 801742a:	687b      	ldr	r3, [r7, #4]
 801742c:	4a20      	ldr	r2, [pc, #128]	@ (80174b0 <TIM_OC1_SetConfig+0x170>)
 801742e:	4293      	cmp	r3, r2
 8017430:	d00f      	beq.n	8017452 <TIM_OC1_SetConfig+0x112>
 8017432:	687b      	ldr	r3, [r7, #4]
 8017434:	4a1f      	ldr	r2, [pc, #124]	@ (80174b4 <TIM_OC1_SetConfig+0x174>)
 8017436:	4293      	cmp	r3, r2
 8017438:	d00b      	beq.n	8017452 <TIM_OC1_SetConfig+0x112>
 801743a:	687b      	ldr	r3, [r7, #4]
 801743c:	4a1e      	ldr	r2, [pc, #120]	@ (80174b8 <TIM_OC1_SetConfig+0x178>)
 801743e:	4293      	cmp	r3, r2
 8017440:	d007      	beq.n	8017452 <TIM_OC1_SetConfig+0x112>
 8017442:	687b      	ldr	r3, [r7, #4]
 8017444:	4a1d      	ldr	r2, [pc, #116]	@ (80174bc <TIM_OC1_SetConfig+0x17c>)
 8017446:	4293      	cmp	r3, r2
 8017448:	d003      	beq.n	8017452 <TIM_OC1_SetConfig+0x112>
 801744a:	687b      	ldr	r3, [r7, #4]
 801744c:	4a1c      	ldr	r2, [pc, #112]	@ (80174c0 <TIM_OC1_SetConfig+0x180>)
 801744e:	4293      	cmp	r3, r2
 8017450:	d111      	bne.n	8017476 <TIM_OC1_SetConfig+0x136>
    /* Check parameters */
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS1;
 8017452:	693b      	ldr	r3, [r7, #16]
 8017454:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
 8017458:	613b      	str	r3, [r7, #16]
    tmpcr2 &= ~TIM_CR2_OIS1N;
 801745a:	693b      	ldr	r3, [r7, #16]
 801745c:	f423 7300 	bic.w	r3, r3, #512	@ 0x200
 8017460:	613b      	str	r3, [r7, #16]
    /* Set the Output Idle state */
    tmpcr2 |= OC_Config->OCIdleState;
 8017462:	683b      	ldr	r3, [r7, #0]
 8017464:	695b      	ldr	r3, [r3, #20]
 8017466:	693a      	ldr	r2, [r7, #16]
 8017468:	4313      	orrs	r3, r2
 801746a:	613b      	str	r3, [r7, #16]
    /* Set the Output N Idle state */
    tmpcr2 |= OC_Config->OCNIdleState;
 801746c:	683b      	ldr	r3, [r7, #0]
 801746e:	699b      	ldr	r3, [r3, #24]
 8017470:	693a      	ldr	r2, [r7, #16]
 8017472:	4313      	orrs	r3, r2
 8017474:	613b      	str	r3, [r7, #16]
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8017476:	687b      	ldr	r3, [r7, #4]
 8017478:	693a      	ldr	r2, [r7, #16]
 801747a:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 801747c:	687b      	ldr	r3, [r7, #4]
 801747e:	68fa      	ldr	r2, [r7, #12]
 8017480:	619a      	str	r2, [r3, #24]

  /* Set the Capture Compare Register value */
  TIMx->CCR1 = OC_Config->Pulse;
 8017482:	683b      	ldr	r3, [r7, #0]
 8017484:	685a      	ldr	r2, [r3, #4]
 8017486:	687b      	ldr	r3, [r7, #4]
 8017488:	635a      	str	r2, [r3, #52]	@ 0x34

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 801748a:	687b      	ldr	r3, [r7, #4]
 801748c:	697a      	ldr	r2, [r7, #20]
 801748e:	621a      	str	r2, [r3, #32]
}
 8017490:	bf00      	nop
 8017492:	371c      	adds	r7, #28
 8017494:	46bd      	mov	sp, r7
 8017496:	f85d 7b04 	ldr.w	r7, [sp], #4
 801749a:	4770      	bx	lr
 801749c:	40012c00 	.word	0x40012c00
 80174a0:	50012c00 	.word	0x50012c00
 80174a4:	40013400 	.word	0x40013400
 80174a8:	50013400 	.word	0x50013400
 80174ac:	40014000 	.word	0x40014000
 80174b0:	50014000 	.word	0x50014000
 80174b4:	40014400 	.word	0x40014400
 80174b8:	50014400 	.word	0x50014400
 80174bc:	40014800 	.word	0x40014800
 80174c0:	50014800 	.word	0x50014800

080174c4 <TIM_OC2_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  */
void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, const TIM_OC_InitTypeDef *OC_Config)
{
 80174c4:	b480      	push	{r7}
 80174c6:	b087      	sub	sp, #28
 80174c8:	af00      	add	r7, sp, #0
 80174ca:	6078      	str	r0, [r7, #4]
 80174cc:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 80174ce:	687b      	ldr	r3, [r7, #4]
 80174d0:	6a1b      	ldr	r3, [r3, #32]
 80174d2:	617b      	str	r3, [r7, #20]

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC2E;
 80174d4:	687b      	ldr	r3, [r7, #4]
 80174d6:	6a1b      	ldr	r3, [r3, #32]
 80174d8:	f023 0210 	bic.w	r2, r3, #16
 80174dc:	687b      	ldr	r3, [r7, #4]
 80174de:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 80174e0:	687b      	ldr	r3, [r7, #4]
 80174e2:	685b      	ldr	r3, [r3, #4]
 80174e4:	613b      	str	r3, [r7, #16]

  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 80174e6:	687b      	ldr	r3, [r7, #4]
 80174e8:	699b      	ldr	r3, [r3, #24]
 80174ea:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR1_OC2M;
 80174ec:	68fb      	ldr	r3, [r7, #12]
 80174ee:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
 80174f2:	f423 43e0 	bic.w	r3, r3, #28672	@ 0x7000
 80174f6:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR1_CC2S;
 80174f8:	68fb      	ldr	r3, [r7, #12]
 80174fa:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
 80174fe:	60fb      	str	r3, [r7, #12]

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8017500:	683b      	ldr	r3, [r7, #0]
 8017502:	681b      	ldr	r3, [r3, #0]
 8017504:	021b      	lsls	r3, r3, #8
 8017506:	68fa      	ldr	r2, [r7, #12]
 8017508:	4313      	orrs	r3, r2
 801750a:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC2P;
 801750c:	697b      	ldr	r3, [r7, #20]
 801750e:	f023 0320 	bic.w	r3, r3, #32
 8017512:	617b      	str	r3, [r7, #20]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 4U);
 8017514:	683b      	ldr	r3, [r7, #0]
 8017516:	689b      	ldr	r3, [r3, #8]
 8017518:	011b      	lsls	r3, r3, #4
 801751a:	697a      	ldr	r2, [r7, #20]
 801751c:	4313      	orrs	r3, r2
 801751e:	617b      	str	r3, [r7, #20]

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
 8017520:	687b      	ldr	r3, [r7, #4]
 8017522:	4a36      	ldr	r2, [pc, #216]	@ (80175fc <TIM_OC2_SetConfig+0x138>)
 8017524:	4293      	cmp	r3, r2
 8017526:	d00b      	beq.n	8017540 <TIM_OC2_SetConfig+0x7c>
 8017528:	687b      	ldr	r3, [r7, #4]
 801752a:	4a35      	ldr	r2, [pc, #212]	@ (8017600 <TIM_OC2_SetConfig+0x13c>)
 801752c:	4293      	cmp	r3, r2
 801752e:	d007      	beq.n	8017540 <TIM_OC2_SetConfig+0x7c>
 8017530:	687b      	ldr	r3, [r7, #4]
 8017532:	4a34      	ldr	r2, [pc, #208]	@ (8017604 <TIM_OC2_SetConfig+0x140>)
 8017534:	4293      	cmp	r3, r2
 8017536:	d003      	beq.n	8017540 <TIM_OC2_SetConfig+0x7c>
 8017538:	687b      	ldr	r3, [r7, #4]
 801753a:	4a33      	ldr	r2, [pc, #204]	@ (8017608 <TIM_OC2_SetConfig+0x144>)
 801753c:	4293      	cmp	r3, r2
 801753e:	d10d      	bne.n	801755c <TIM_OC2_SetConfig+0x98>
  {
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC2NP;
 8017540:	697b      	ldr	r3, [r7, #20]
 8017542:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 8017546:	617b      	str	r3, [r7, #20]
    /* Set the Output N Polarity */
    tmpccer |= (OC_Config->OCNPolarity << 4U);
 8017548:	683b      	ldr	r3, [r7, #0]
 801754a:	68db      	ldr	r3, [r3, #12]
 801754c:	011b      	lsls	r3, r3, #4
 801754e:	697a      	ldr	r2, [r7, #20]
 8017550:	4313      	orrs	r3, r2
 8017552:	617b      	str	r3, [r7, #20]
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC2NE;
 8017554:	697b      	ldr	r3, [r7, #20]
 8017556:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 801755a:	617b      	str	r3, [r7, #20]

  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 801755c:	687b      	ldr	r3, [r7, #4]
 801755e:	4a27      	ldr	r2, [pc, #156]	@ (80175fc <TIM_OC2_SetConfig+0x138>)
 8017560:	4293      	cmp	r3, r2
 8017562:	d023      	beq.n	80175ac <TIM_OC2_SetConfig+0xe8>
 8017564:	687b      	ldr	r3, [r7, #4]
 8017566:	4a26      	ldr	r2, [pc, #152]	@ (8017600 <TIM_OC2_SetConfig+0x13c>)
 8017568:	4293      	cmp	r3, r2
 801756a:	d01f      	beq.n	80175ac <TIM_OC2_SetConfig+0xe8>
 801756c:	687b      	ldr	r3, [r7, #4]
 801756e:	4a25      	ldr	r2, [pc, #148]	@ (8017604 <TIM_OC2_SetConfig+0x140>)
 8017570:	4293      	cmp	r3, r2
 8017572:	d01b      	beq.n	80175ac <TIM_OC2_SetConfig+0xe8>
 8017574:	687b      	ldr	r3, [r7, #4]
 8017576:	4a24      	ldr	r2, [pc, #144]	@ (8017608 <TIM_OC2_SetConfig+0x144>)
 8017578:	4293      	cmp	r3, r2
 801757a:	d017      	beq.n	80175ac <TIM_OC2_SetConfig+0xe8>
 801757c:	687b      	ldr	r3, [r7, #4]
 801757e:	4a23      	ldr	r2, [pc, #140]	@ (801760c <TIM_OC2_SetConfig+0x148>)
 8017580:	4293      	cmp	r3, r2
 8017582:	d013      	beq.n	80175ac <TIM_OC2_SetConfig+0xe8>
 8017584:	687b      	ldr	r3, [r7, #4]
 8017586:	4a22      	ldr	r2, [pc, #136]	@ (8017610 <TIM_OC2_SetConfig+0x14c>)
 8017588:	4293      	cmp	r3, r2
 801758a:	d00f      	beq.n	80175ac <TIM_OC2_SetConfig+0xe8>
 801758c:	687b      	ldr	r3, [r7, #4]
 801758e:	4a21      	ldr	r2, [pc, #132]	@ (8017614 <TIM_OC2_SetConfig+0x150>)
 8017590:	4293      	cmp	r3, r2
 8017592:	d00b      	beq.n	80175ac <TIM_OC2_SetConfig+0xe8>
 8017594:	687b      	ldr	r3, [r7, #4]
 8017596:	4a20      	ldr	r2, [pc, #128]	@ (8017618 <TIM_OC2_SetConfig+0x154>)
 8017598:	4293      	cmp	r3, r2
 801759a:	d007      	beq.n	80175ac <TIM_OC2_SetConfig+0xe8>
 801759c:	687b      	ldr	r3, [r7, #4]
 801759e:	4a1f      	ldr	r2, [pc, #124]	@ (801761c <TIM_OC2_SetConfig+0x158>)
 80175a0:	4293      	cmp	r3, r2
 80175a2:	d003      	beq.n	80175ac <TIM_OC2_SetConfig+0xe8>
 80175a4:	687b      	ldr	r3, [r7, #4]
 80175a6:	4a1e      	ldr	r2, [pc, #120]	@ (8017620 <TIM_OC2_SetConfig+0x15c>)
 80175a8:	4293      	cmp	r3, r2
 80175aa:	d113      	bne.n	80175d4 <TIM_OC2_SetConfig+0x110>
    /* Check parameters */
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS2;
 80175ac:	693b      	ldr	r3, [r7, #16]
 80175ae:	f423 6380 	bic.w	r3, r3, #1024	@ 0x400
 80175b2:	613b      	str	r3, [r7, #16]
    tmpcr2 &= ~TIM_CR2_OIS2N;
 80175b4:	693b      	ldr	r3, [r7, #16]
 80175b6:	f423 6300 	bic.w	r3, r3, #2048	@ 0x800
 80175ba:	613b      	str	r3, [r7, #16]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 2U);
 80175bc:	683b      	ldr	r3, [r7, #0]
 80175be:	695b      	ldr	r3, [r3, #20]
 80175c0:	009b      	lsls	r3, r3, #2
 80175c2:	693a      	ldr	r2, [r7, #16]
 80175c4:	4313      	orrs	r3, r2
 80175c6:	613b      	str	r3, [r7, #16]
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 80175c8:	683b      	ldr	r3, [r7, #0]
 80175ca:	699b      	ldr	r3, [r3, #24]
 80175cc:	009b      	lsls	r3, r3, #2
 80175ce:	693a      	ldr	r2, [r7, #16]
 80175d0:	4313      	orrs	r3, r2
 80175d2:	613b      	str	r3, [r7, #16]
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 80175d4:	687b      	ldr	r3, [r7, #4]
 80175d6:	693a      	ldr	r2, [r7, #16]
 80175d8:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 80175da:	687b      	ldr	r3, [r7, #4]
 80175dc:	68fa      	ldr	r2, [r7, #12]
 80175de:	619a      	str	r2, [r3, #24]

  /* Set the Capture Compare Register value */
  TIMx->CCR2 = OC_Config->Pulse;
 80175e0:	683b      	ldr	r3, [r7, #0]
 80175e2:	685a      	ldr	r2, [r3, #4]
 80175e4:	687b      	ldr	r3, [r7, #4]
 80175e6:	639a      	str	r2, [r3, #56]	@ 0x38

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 80175e8:	687b      	ldr	r3, [r7, #4]
 80175ea:	697a      	ldr	r2, [r7, #20]
 80175ec:	621a      	str	r2, [r3, #32]
}
 80175ee:	bf00      	nop
 80175f0:	371c      	adds	r7, #28
 80175f2:	46bd      	mov	sp, r7
 80175f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80175f8:	4770      	bx	lr
 80175fa:	bf00      	nop
 80175fc:	40012c00 	.word	0x40012c00
 8017600:	50012c00 	.word	0x50012c00
 8017604:	40013400 	.word	0x40013400
 8017608:	50013400 	.word	0x50013400
 801760c:	40014000 	.word	0x40014000
 8017610:	50014000 	.word	0x50014000
 8017614:	40014400 	.word	0x40014400
 8017618:	50014400 	.word	0x50014400
 801761c:	40014800 	.word	0x40014800
 8017620:	50014800 	.word	0x50014800

08017624 <TIM_OC3_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, const TIM_OC_InitTypeDef *OC_Config)
{
 8017624:	b480      	push	{r7}
 8017626:	b087      	sub	sp, #28
 8017628:	af00      	add	r7, sp, #0
 801762a:	6078      	str	r0, [r7, #4]
 801762c:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 801762e:	687b      	ldr	r3, [r7, #4]
 8017630:	6a1b      	ldr	r3, [r3, #32]
 8017632:	617b      	str	r3, [r7, #20]

  /* Disable the Channel 3: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC3E;
 8017634:	687b      	ldr	r3, [r7, #4]
 8017636:	6a1b      	ldr	r3, [r3, #32]
 8017638:	f423 7280 	bic.w	r2, r3, #256	@ 0x100
 801763c:	687b      	ldr	r3, [r7, #4]
 801763e:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8017640:	687b      	ldr	r3, [r7, #4]
 8017642:	685b      	ldr	r3, [r3, #4]
 8017644:	613b      	str	r3, [r7, #16]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 8017646:	687b      	ldr	r3, [r7, #4]
 8017648:	69db      	ldr	r3, [r3, #28]
 801764a:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC3M;
 801764c:	68fb      	ldr	r3, [r7, #12]
 801764e:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 8017652:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
 8017656:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR2_CC3S;
 8017658:	68fb      	ldr	r3, [r7, #12]
 801765a:	f023 0303 	bic.w	r3, r3, #3
 801765e:	60fb      	str	r3, [r7, #12]
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 8017660:	683b      	ldr	r3, [r7, #0]
 8017662:	681b      	ldr	r3, [r3, #0]
 8017664:	68fa      	ldr	r2, [r7, #12]
 8017666:	4313      	orrs	r3, r2
 8017668:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
 801766a:	697b      	ldr	r3, [r7, #20]
 801766c:	f423 7300 	bic.w	r3, r3, #512	@ 0x200
 8017670:	617b      	str	r3, [r7, #20]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 8U);
 8017672:	683b      	ldr	r3, [r7, #0]
 8017674:	689b      	ldr	r3, [r3, #8]
 8017676:	021b      	lsls	r3, r3, #8
 8017678:	697a      	ldr	r2, [r7, #20]
 801767a:	4313      	orrs	r3, r2
 801767c:	617b      	str	r3, [r7, #20]

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
 801767e:	687b      	ldr	r3, [r7, #4]
 8017680:	4a35      	ldr	r2, [pc, #212]	@ (8017758 <TIM_OC3_SetConfig+0x134>)
 8017682:	4293      	cmp	r3, r2
 8017684:	d00b      	beq.n	801769e <TIM_OC3_SetConfig+0x7a>
 8017686:	687b      	ldr	r3, [r7, #4]
 8017688:	4a34      	ldr	r2, [pc, #208]	@ (801775c <TIM_OC3_SetConfig+0x138>)
 801768a:	4293      	cmp	r3, r2
 801768c:	d007      	beq.n	801769e <TIM_OC3_SetConfig+0x7a>
 801768e:	687b      	ldr	r3, [r7, #4]
 8017690:	4a33      	ldr	r2, [pc, #204]	@ (8017760 <TIM_OC3_SetConfig+0x13c>)
 8017692:	4293      	cmp	r3, r2
 8017694:	d003      	beq.n	801769e <TIM_OC3_SetConfig+0x7a>
 8017696:	687b      	ldr	r3, [r7, #4]
 8017698:	4a32      	ldr	r2, [pc, #200]	@ (8017764 <TIM_OC3_SetConfig+0x140>)
 801769a:	4293      	cmp	r3, r2
 801769c:	d10d      	bne.n	80176ba <TIM_OC3_SetConfig+0x96>
  {
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC3NP;
 801769e:	697b      	ldr	r3, [r7, #20]
 80176a0:	f423 6300 	bic.w	r3, r3, #2048	@ 0x800
 80176a4:	617b      	str	r3, [r7, #20]
    /* Set the Output N Polarity */
    tmpccer |= (OC_Config->OCNPolarity << 8U);
 80176a6:	683b      	ldr	r3, [r7, #0]
 80176a8:	68db      	ldr	r3, [r3, #12]
 80176aa:	021b      	lsls	r3, r3, #8
 80176ac:	697a      	ldr	r2, [r7, #20]
 80176ae:	4313      	orrs	r3, r2
 80176b0:	617b      	str	r3, [r7, #20]
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC3NE;
 80176b2:	697b      	ldr	r3, [r7, #20]
 80176b4:	f423 6380 	bic.w	r3, r3, #1024	@ 0x400
 80176b8:	617b      	str	r3, [r7, #20]
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 80176ba:	687b      	ldr	r3, [r7, #4]
 80176bc:	4a26      	ldr	r2, [pc, #152]	@ (8017758 <TIM_OC3_SetConfig+0x134>)
 80176be:	4293      	cmp	r3, r2
 80176c0:	d023      	beq.n	801770a <TIM_OC3_SetConfig+0xe6>
 80176c2:	687b      	ldr	r3, [r7, #4]
 80176c4:	4a25      	ldr	r2, [pc, #148]	@ (801775c <TIM_OC3_SetConfig+0x138>)
 80176c6:	4293      	cmp	r3, r2
 80176c8:	d01f      	beq.n	801770a <TIM_OC3_SetConfig+0xe6>
 80176ca:	687b      	ldr	r3, [r7, #4]
 80176cc:	4a24      	ldr	r2, [pc, #144]	@ (8017760 <TIM_OC3_SetConfig+0x13c>)
 80176ce:	4293      	cmp	r3, r2
 80176d0:	d01b      	beq.n	801770a <TIM_OC3_SetConfig+0xe6>
 80176d2:	687b      	ldr	r3, [r7, #4]
 80176d4:	4a23      	ldr	r2, [pc, #140]	@ (8017764 <TIM_OC3_SetConfig+0x140>)
 80176d6:	4293      	cmp	r3, r2
 80176d8:	d017      	beq.n	801770a <TIM_OC3_SetConfig+0xe6>
 80176da:	687b      	ldr	r3, [r7, #4]
 80176dc:	4a22      	ldr	r2, [pc, #136]	@ (8017768 <TIM_OC3_SetConfig+0x144>)
 80176de:	4293      	cmp	r3, r2
 80176e0:	d013      	beq.n	801770a <TIM_OC3_SetConfig+0xe6>
 80176e2:	687b      	ldr	r3, [r7, #4]
 80176e4:	4a21      	ldr	r2, [pc, #132]	@ (801776c <TIM_OC3_SetConfig+0x148>)
 80176e6:	4293      	cmp	r3, r2
 80176e8:	d00f      	beq.n	801770a <TIM_OC3_SetConfig+0xe6>
 80176ea:	687b      	ldr	r3, [r7, #4]
 80176ec:	4a20      	ldr	r2, [pc, #128]	@ (8017770 <TIM_OC3_SetConfig+0x14c>)
 80176ee:	4293      	cmp	r3, r2
 80176f0:	d00b      	beq.n	801770a <TIM_OC3_SetConfig+0xe6>
 80176f2:	687b      	ldr	r3, [r7, #4]
 80176f4:	4a1f      	ldr	r2, [pc, #124]	@ (8017774 <TIM_OC3_SetConfig+0x150>)
 80176f6:	4293      	cmp	r3, r2
 80176f8:	d007      	beq.n	801770a <TIM_OC3_SetConfig+0xe6>
 80176fa:	687b      	ldr	r3, [r7, #4]
 80176fc:	4a1e      	ldr	r2, [pc, #120]	@ (8017778 <TIM_OC3_SetConfig+0x154>)
 80176fe:	4293      	cmp	r3, r2
 8017700:	d003      	beq.n	801770a <TIM_OC3_SetConfig+0xe6>
 8017702:	687b      	ldr	r3, [r7, #4]
 8017704:	4a1d      	ldr	r2, [pc, #116]	@ (801777c <TIM_OC3_SetConfig+0x158>)
 8017706:	4293      	cmp	r3, r2
 8017708:	d113      	bne.n	8017732 <TIM_OC3_SetConfig+0x10e>
    /* Check parameters */
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS3;
 801770a:	693b      	ldr	r3, [r7, #16]
 801770c:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
 8017710:	613b      	str	r3, [r7, #16]
    tmpcr2 &= ~TIM_CR2_OIS3N;
 8017712:	693b      	ldr	r3, [r7, #16]
 8017714:	f423 5300 	bic.w	r3, r3, #8192	@ 0x2000
 8017718:	613b      	str	r3, [r7, #16]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 4U);
 801771a:	683b      	ldr	r3, [r7, #0]
 801771c:	695b      	ldr	r3, [r3, #20]
 801771e:	011b      	lsls	r3, r3, #4
 8017720:	693a      	ldr	r2, [r7, #16]
 8017722:	4313      	orrs	r3, r2
 8017724:	613b      	str	r3, [r7, #16]
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 8017726:	683b      	ldr	r3, [r7, #0]
 8017728:	699b      	ldr	r3, [r3, #24]
 801772a:	011b      	lsls	r3, r3, #4
 801772c:	693a      	ldr	r2, [r7, #16]
 801772e:	4313      	orrs	r3, r2
 8017730:	613b      	str	r3, [r7, #16]
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8017732:	687b      	ldr	r3, [r7, #4]
 8017734:	693a      	ldr	r2, [r7, #16]
 8017736:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 8017738:	687b      	ldr	r3, [r7, #4]
 801773a:	68fa      	ldr	r2, [r7, #12]
 801773c:	61da      	str	r2, [r3, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR3 = OC_Config->Pulse;
 801773e:	683b      	ldr	r3, [r7, #0]
 8017740:	685a      	ldr	r2, [r3, #4]
 8017742:	687b      	ldr	r3, [r7, #4]
 8017744:	63da      	str	r2, [r3, #60]	@ 0x3c

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8017746:	687b      	ldr	r3, [r7, #4]
 8017748:	697a      	ldr	r2, [r7, #20]
 801774a:	621a      	str	r2, [r3, #32]
}
 801774c:	bf00      	nop
 801774e:	371c      	adds	r7, #28
 8017750:	46bd      	mov	sp, r7
 8017752:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017756:	4770      	bx	lr
 8017758:	40012c00 	.word	0x40012c00
 801775c:	50012c00 	.word	0x50012c00
 8017760:	40013400 	.word	0x40013400
 8017764:	50013400 	.word	0x50013400
 8017768:	40014000 	.word	0x40014000
 801776c:	50014000 	.word	0x50014000
 8017770:	40014400 	.word	0x40014400
 8017774:	50014400 	.word	0x50014400
 8017778:	40014800 	.word	0x40014800
 801777c:	50014800 	.word	0x50014800

08017780 <TIM_OC4_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, const TIM_OC_InitTypeDef *OC_Config)
{
 8017780:	b480      	push	{r7}
 8017782:	b087      	sub	sp, #28
 8017784:	af00      	add	r7, sp, #0
 8017786:	6078      	str	r0, [r7, #4]
 8017788:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 801778a:	687b      	ldr	r3, [r7, #4]
 801778c:	6a1b      	ldr	r3, [r3, #32]
 801778e:	617b      	str	r3, [r7, #20]

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= ~TIM_CCER_CC4E;
 8017790:	687b      	ldr	r3, [r7, #4]
 8017792:	6a1b      	ldr	r3, [r3, #32]
 8017794:	f423 5280 	bic.w	r2, r3, #4096	@ 0x1000
 8017798:	687b      	ldr	r3, [r7, #4]
 801779a:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 801779c:	687b      	ldr	r3, [r7, #4]
 801779e:	685b      	ldr	r3, [r3, #4]
 80177a0:	613b      	str	r3, [r7, #16]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 80177a2:	687b      	ldr	r3, [r7, #4]
 80177a4:	69db      	ldr	r3, [r3, #28]
 80177a6:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC4M;
 80177a8:	68fb      	ldr	r3, [r7, #12]
 80177aa:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
 80177ae:	f423 43e0 	bic.w	r3, r3, #28672	@ 0x7000
 80177b2:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR2_CC4S;
 80177b4:	68fb      	ldr	r3, [r7, #12]
 80177b6:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
 80177ba:	60fb      	str	r3, [r7, #12]

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 80177bc:	683b      	ldr	r3, [r7, #0]
 80177be:	681b      	ldr	r3, [r3, #0]
 80177c0:	021b      	lsls	r3, r3, #8
 80177c2:	68fa      	ldr	r2, [r7, #12]
 80177c4:	4313      	orrs	r3, r2
 80177c6:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC4P;
 80177c8:	697b      	ldr	r3, [r7, #20]
 80177ca:	f423 5300 	bic.w	r3, r3, #8192	@ 0x2000
 80177ce:	617b      	str	r3, [r7, #20]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 12U);
 80177d0:	683b      	ldr	r3, [r7, #0]
 80177d2:	689b      	ldr	r3, [r3, #8]
 80177d4:	031b      	lsls	r3, r3, #12
 80177d6:	697a      	ldr	r2, [r7, #20]
 80177d8:	4313      	orrs	r3, r2
 80177da:	617b      	str	r3, [r7, #20]

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_4))
 80177dc:	687b      	ldr	r3, [r7, #4]
 80177de:	4a36      	ldr	r2, [pc, #216]	@ (80178b8 <TIM_OC4_SetConfig+0x138>)
 80177e0:	4293      	cmp	r3, r2
 80177e2:	d00b      	beq.n	80177fc <TIM_OC4_SetConfig+0x7c>
 80177e4:	687b      	ldr	r3, [r7, #4]
 80177e6:	4a35      	ldr	r2, [pc, #212]	@ (80178bc <TIM_OC4_SetConfig+0x13c>)
 80177e8:	4293      	cmp	r3, r2
 80177ea:	d007      	beq.n	80177fc <TIM_OC4_SetConfig+0x7c>
 80177ec:	687b      	ldr	r3, [r7, #4]
 80177ee:	4a34      	ldr	r2, [pc, #208]	@ (80178c0 <TIM_OC4_SetConfig+0x140>)
 80177f0:	4293      	cmp	r3, r2
 80177f2:	d003      	beq.n	80177fc <TIM_OC4_SetConfig+0x7c>
 80177f4:	687b      	ldr	r3, [r7, #4]
 80177f6:	4a33      	ldr	r2, [pc, #204]	@ (80178c4 <TIM_OC4_SetConfig+0x144>)
 80177f8:	4293      	cmp	r3, r2
 80177fa:	d10d      	bne.n	8017818 <TIM_OC4_SetConfig+0x98>
  {
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC4NP;
 80177fc:	697b      	ldr	r3, [r7, #20]
 80177fe:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
 8017802:	617b      	str	r3, [r7, #20]
    /* Set the Output N Polarity */
    tmpccer |= (OC_Config->OCNPolarity << 12U);
 8017804:	683b      	ldr	r3, [r7, #0]
 8017806:	68db      	ldr	r3, [r3, #12]
 8017808:	031b      	lsls	r3, r3, #12
 801780a:	697a      	ldr	r2, [r7, #20]
 801780c:	4313      	orrs	r3, r2
 801780e:	617b      	str	r3, [r7, #20]
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC4NE;
 8017810:	697b      	ldr	r3, [r7, #20]
 8017812:	f423 4380 	bic.w	r3, r3, #16384	@ 0x4000
 8017816:	617b      	str	r3, [r7, #20]
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8017818:	687b      	ldr	r3, [r7, #4]
 801781a:	4a27      	ldr	r2, [pc, #156]	@ (80178b8 <TIM_OC4_SetConfig+0x138>)
 801781c:	4293      	cmp	r3, r2
 801781e:	d023      	beq.n	8017868 <TIM_OC4_SetConfig+0xe8>
 8017820:	687b      	ldr	r3, [r7, #4]
 8017822:	4a26      	ldr	r2, [pc, #152]	@ (80178bc <TIM_OC4_SetConfig+0x13c>)
 8017824:	4293      	cmp	r3, r2
 8017826:	d01f      	beq.n	8017868 <TIM_OC4_SetConfig+0xe8>
 8017828:	687b      	ldr	r3, [r7, #4]
 801782a:	4a25      	ldr	r2, [pc, #148]	@ (80178c0 <TIM_OC4_SetConfig+0x140>)
 801782c:	4293      	cmp	r3, r2
 801782e:	d01b      	beq.n	8017868 <TIM_OC4_SetConfig+0xe8>
 8017830:	687b      	ldr	r3, [r7, #4]
 8017832:	4a24      	ldr	r2, [pc, #144]	@ (80178c4 <TIM_OC4_SetConfig+0x144>)
 8017834:	4293      	cmp	r3, r2
 8017836:	d017      	beq.n	8017868 <TIM_OC4_SetConfig+0xe8>
 8017838:	687b      	ldr	r3, [r7, #4]
 801783a:	4a23      	ldr	r2, [pc, #140]	@ (80178c8 <TIM_OC4_SetConfig+0x148>)
 801783c:	4293      	cmp	r3, r2
 801783e:	d013      	beq.n	8017868 <TIM_OC4_SetConfig+0xe8>
 8017840:	687b      	ldr	r3, [r7, #4]
 8017842:	4a22      	ldr	r2, [pc, #136]	@ (80178cc <TIM_OC4_SetConfig+0x14c>)
 8017844:	4293      	cmp	r3, r2
 8017846:	d00f      	beq.n	8017868 <TIM_OC4_SetConfig+0xe8>
 8017848:	687b      	ldr	r3, [r7, #4]
 801784a:	4a21      	ldr	r2, [pc, #132]	@ (80178d0 <TIM_OC4_SetConfig+0x150>)
 801784c:	4293      	cmp	r3, r2
 801784e:	d00b      	beq.n	8017868 <TIM_OC4_SetConfig+0xe8>
 8017850:	687b      	ldr	r3, [r7, #4]
 8017852:	4a20      	ldr	r2, [pc, #128]	@ (80178d4 <TIM_OC4_SetConfig+0x154>)
 8017854:	4293      	cmp	r3, r2
 8017856:	d007      	beq.n	8017868 <TIM_OC4_SetConfig+0xe8>
 8017858:	687b      	ldr	r3, [r7, #4]
 801785a:	4a1f      	ldr	r2, [pc, #124]	@ (80178d8 <TIM_OC4_SetConfig+0x158>)
 801785c:	4293      	cmp	r3, r2
 801785e:	d003      	beq.n	8017868 <TIM_OC4_SetConfig+0xe8>
 8017860:	687b      	ldr	r3, [r7, #4]
 8017862:	4a1e      	ldr	r2, [pc, #120]	@ (80178dc <TIM_OC4_SetConfig+0x15c>)
 8017864:	4293      	cmp	r3, r2
 8017866:	d113      	bne.n	8017890 <TIM_OC4_SetConfig+0x110>
    /* Check parameters */
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS4;
 8017868:	693b      	ldr	r3, [r7, #16]
 801786a:	f423 4380 	bic.w	r3, r3, #16384	@ 0x4000
 801786e:	613b      	str	r3, [r7, #16]
    /* Reset the Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS4N;
 8017870:	693b      	ldr	r3, [r7, #16]
 8017872:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
 8017876:	613b      	str	r3, [r7, #16]

    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 6U);
 8017878:	683b      	ldr	r3, [r7, #0]
 801787a:	695b      	ldr	r3, [r3, #20]
 801787c:	019b      	lsls	r3, r3, #6
 801787e:	693a      	ldr	r2, [r7, #16]
 8017880:	4313      	orrs	r3, r2
 8017882:	613b      	str	r3, [r7, #16]
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 6U);
 8017884:	683b      	ldr	r3, [r7, #0]
 8017886:	699b      	ldr	r3, [r3, #24]
 8017888:	019b      	lsls	r3, r3, #6
 801788a:	693a      	ldr	r2, [r7, #16]
 801788c:	4313      	orrs	r3, r2
 801788e:	613b      	str	r3, [r7, #16]
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8017890:	687b      	ldr	r3, [r7, #4]
 8017892:	693a      	ldr	r2, [r7, #16]
 8017894:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 8017896:	687b      	ldr	r3, [r7, #4]
 8017898:	68fa      	ldr	r2, [r7, #12]
 801789a:	61da      	str	r2, [r3, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR4 = OC_Config->Pulse;
 801789c:	683b      	ldr	r3, [r7, #0]
 801789e:	685a      	ldr	r2, [r3, #4]
 80178a0:	687b      	ldr	r3, [r7, #4]
 80178a2:	641a      	str	r2, [r3, #64]	@ 0x40

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 80178a4:	687b      	ldr	r3, [r7, #4]
 80178a6:	697a      	ldr	r2, [r7, #20]
 80178a8:	621a      	str	r2, [r3, #32]
}
 80178aa:	bf00      	nop
 80178ac:	371c      	adds	r7, #28
 80178ae:	46bd      	mov	sp, r7
 80178b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80178b4:	4770      	bx	lr
 80178b6:	bf00      	nop
 80178b8:	40012c00 	.word	0x40012c00
 80178bc:	50012c00 	.word	0x50012c00
 80178c0:	40013400 	.word	0x40013400
 80178c4:	50013400 	.word	0x50013400
 80178c8:	40014000 	.word	0x40014000
 80178cc:	50014000 	.word	0x50014000
 80178d0:	40014400 	.word	0x40014400
 80178d4:	50014400 	.word	0x50014400
 80178d8:	40014800 	.word	0x40014800
 80178dc:	50014800 	.word	0x50014800

080178e0 <TIM_OC5_SetConfig>:
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC5_SetConfig(TIM_TypeDef *TIMx,
                              const TIM_OC_InitTypeDef *OC_Config)
{
 80178e0:	b480      	push	{r7}
 80178e2:	b087      	sub	sp, #28
 80178e4:	af00      	add	r7, sp, #0
 80178e6:	6078      	str	r0, [r7, #4]
 80178e8:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 80178ea:	687b      	ldr	r3, [r7, #4]
 80178ec:	6a1b      	ldr	r3, [r3, #32]
 80178ee:	613b      	str	r3, [r7, #16]

  /* Disable the output: Reset the CCxE Bit */
  TIMx->CCER &= ~TIM_CCER_CC5E;
 80178f0:	687b      	ldr	r3, [r7, #4]
 80178f2:	6a1b      	ldr	r3, [r3, #32]
 80178f4:	f423 3280 	bic.w	r2, r3, #65536	@ 0x10000
 80178f8:	687b      	ldr	r3, [r7, #4]
 80178fa:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 80178fc:	687b      	ldr	r3, [r7, #4]
 80178fe:	685b      	ldr	r3, [r3, #4]
 8017900:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR3;
 8017902:	687b      	ldr	r3, [r7, #4]
 8017904:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8017906:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~(TIM_CCMR3_OC5M);
 8017908:	68fb      	ldr	r3, [r7, #12]
 801790a:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 801790e:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
 8017912:	60fb      	str	r3, [r7, #12]
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 8017914:	683b      	ldr	r3, [r7, #0]
 8017916:	681b      	ldr	r3, [r3, #0]
 8017918:	68fa      	ldr	r2, [r7, #12]
 801791a:	4313      	orrs	r3, r2
 801791c:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC5P;
 801791e:	693b      	ldr	r3, [r7, #16]
 8017920:	f423 3300 	bic.w	r3, r3, #131072	@ 0x20000
 8017924:	613b      	str	r3, [r7, #16]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 16U);
 8017926:	683b      	ldr	r3, [r7, #0]
 8017928:	689b      	ldr	r3, [r3, #8]
 801792a:	041b      	lsls	r3, r3, #16
 801792c:	693a      	ldr	r2, [r7, #16]
 801792e:	4313      	orrs	r3, r2
 8017930:	613b      	str	r3, [r7, #16]

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8017932:	687b      	ldr	r3, [r7, #4]
 8017934:	4a21      	ldr	r2, [pc, #132]	@ (80179bc <TIM_OC5_SetConfig+0xdc>)
 8017936:	4293      	cmp	r3, r2
 8017938:	d023      	beq.n	8017982 <TIM_OC5_SetConfig+0xa2>
 801793a:	687b      	ldr	r3, [r7, #4]
 801793c:	4a20      	ldr	r2, [pc, #128]	@ (80179c0 <TIM_OC5_SetConfig+0xe0>)
 801793e:	4293      	cmp	r3, r2
 8017940:	d01f      	beq.n	8017982 <TIM_OC5_SetConfig+0xa2>
 8017942:	687b      	ldr	r3, [r7, #4]
 8017944:	4a1f      	ldr	r2, [pc, #124]	@ (80179c4 <TIM_OC5_SetConfig+0xe4>)
 8017946:	4293      	cmp	r3, r2
 8017948:	d01b      	beq.n	8017982 <TIM_OC5_SetConfig+0xa2>
 801794a:	687b      	ldr	r3, [r7, #4]
 801794c:	4a1e      	ldr	r2, [pc, #120]	@ (80179c8 <TIM_OC5_SetConfig+0xe8>)
 801794e:	4293      	cmp	r3, r2
 8017950:	d017      	beq.n	8017982 <TIM_OC5_SetConfig+0xa2>
 8017952:	687b      	ldr	r3, [r7, #4]
 8017954:	4a1d      	ldr	r2, [pc, #116]	@ (80179cc <TIM_OC5_SetConfig+0xec>)
 8017956:	4293      	cmp	r3, r2
 8017958:	d013      	beq.n	8017982 <TIM_OC5_SetConfig+0xa2>
 801795a:	687b      	ldr	r3, [r7, #4]
 801795c:	4a1c      	ldr	r2, [pc, #112]	@ (80179d0 <TIM_OC5_SetConfig+0xf0>)
 801795e:	4293      	cmp	r3, r2
 8017960:	d00f      	beq.n	8017982 <TIM_OC5_SetConfig+0xa2>
 8017962:	687b      	ldr	r3, [r7, #4]
 8017964:	4a1b      	ldr	r2, [pc, #108]	@ (80179d4 <TIM_OC5_SetConfig+0xf4>)
 8017966:	4293      	cmp	r3, r2
 8017968:	d00b      	beq.n	8017982 <TIM_OC5_SetConfig+0xa2>
 801796a:	687b      	ldr	r3, [r7, #4]
 801796c:	4a1a      	ldr	r2, [pc, #104]	@ (80179d8 <TIM_OC5_SetConfig+0xf8>)
 801796e:	4293      	cmp	r3, r2
 8017970:	d007      	beq.n	8017982 <TIM_OC5_SetConfig+0xa2>
 8017972:	687b      	ldr	r3, [r7, #4]
 8017974:	4a19      	ldr	r2, [pc, #100]	@ (80179dc <TIM_OC5_SetConfig+0xfc>)
 8017976:	4293      	cmp	r3, r2
 8017978:	d003      	beq.n	8017982 <TIM_OC5_SetConfig+0xa2>
 801797a:	687b      	ldr	r3, [r7, #4]
 801797c:	4a18      	ldr	r2, [pc, #96]	@ (80179e0 <TIM_OC5_SetConfig+0x100>)
 801797e:	4293      	cmp	r3, r2
 8017980:	d109      	bne.n	8017996 <TIM_OC5_SetConfig+0xb6>
  {
    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS5;
 8017982:	697b      	ldr	r3, [r7, #20]
 8017984:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 8017988:	617b      	str	r3, [r7, #20]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 8U);
 801798a:	683b      	ldr	r3, [r7, #0]
 801798c:	695b      	ldr	r3, [r3, #20]
 801798e:	021b      	lsls	r3, r3, #8
 8017990:	697a      	ldr	r2, [r7, #20]
 8017992:	4313      	orrs	r3, r2
 8017994:	617b      	str	r3, [r7, #20]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8017996:	687b      	ldr	r3, [r7, #4]
 8017998:	697a      	ldr	r2, [r7, #20]
 801799a:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR3 */
  TIMx->CCMR3 = tmpccmrx;
 801799c:	687b      	ldr	r3, [r7, #4]
 801799e:	68fa      	ldr	r2, [r7, #12]
 80179a0:	651a      	str	r2, [r3, #80]	@ 0x50

  /* Set the Capture Compare Register value */
  TIMx->CCR5 = OC_Config->Pulse;
 80179a2:	683b      	ldr	r3, [r7, #0]
 80179a4:	685a      	ldr	r2, [r3, #4]
 80179a6:	687b      	ldr	r3, [r7, #4]
 80179a8:	649a      	str	r2, [r3, #72]	@ 0x48

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 80179aa:	687b      	ldr	r3, [r7, #4]
 80179ac:	693a      	ldr	r2, [r7, #16]
 80179ae:	621a      	str	r2, [r3, #32]
}
 80179b0:	bf00      	nop
 80179b2:	371c      	adds	r7, #28
 80179b4:	46bd      	mov	sp, r7
 80179b6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80179ba:	4770      	bx	lr
 80179bc:	40012c00 	.word	0x40012c00
 80179c0:	50012c00 	.word	0x50012c00
 80179c4:	40013400 	.word	0x40013400
 80179c8:	50013400 	.word	0x50013400
 80179cc:	40014000 	.word	0x40014000
 80179d0:	50014000 	.word	0x50014000
 80179d4:	40014400 	.word	0x40014400
 80179d8:	50014400 	.word	0x50014400
 80179dc:	40014800 	.word	0x40014800
 80179e0:	50014800 	.word	0x50014800

080179e4 <TIM_OC6_SetConfig>:
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC6_SetConfig(TIM_TypeDef *TIMx,
                              const TIM_OC_InitTypeDef *OC_Config)
{
 80179e4:	b480      	push	{r7}
 80179e6:	b087      	sub	sp, #28
 80179e8:	af00      	add	r7, sp, #0
 80179ea:	6078      	str	r0, [r7, #4]
 80179ec:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 80179ee:	687b      	ldr	r3, [r7, #4]
 80179f0:	6a1b      	ldr	r3, [r3, #32]
 80179f2:	613b      	str	r3, [r7, #16]

  /* Disable the output: Reset the CCxE Bit */
  TIMx->CCER &= ~TIM_CCER_CC6E;
 80179f4:	687b      	ldr	r3, [r7, #4]
 80179f6:	6a1b      	ldr	r3, [r3, #32]
 80179f8:	f423 1280 	bic.w	r2, r3, #1048576	@ 0x100000
 80179fc:	687b      	ldr	r3, [r7, #4]
 80179fe:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8017a00:	687b      	ldr	r3, [r7, #4]
 8017a02:	685b      	ldr	r3, [r3, #4]
 8017a04:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR3;
 8017a06:	687b      	ldr	r3, [r7, #4]
 8017a08:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8017a0a:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~(TIM_CCMR3_OC6M);
 8017a0c:	68fb      	ldr	r3, [r7, #12]
 8017a0e:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
 8017a12:	f423 43e0 	bic.w	r3, r3, #28672	@ 0x7000
 8017a16:	60fb      	str	r3, [r7, #12]
  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8017a18:	683b      	ldr	r3, [r7, #0]
 8017a1a:	681b      	ldr	r3, [r3, #0]
 8017a1c:	021b      	lsls	r3, r3, #8
 8017a1e:	68fa      	ldr	r2, [r7, #12]
 8017a20:	4313      	orrs	r3, r2
 8017a22:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC6P;
 8017a24:	693b      	ldr	r3, [r7, #16]
 8017a26:	f423 1300 	bic.w	r3, r3, #2097152	@ 0x200000
 8017a2a:	613b      	str	r3, [r7, #16]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 20U);
 8017a2c:	683b      	ldr	r3, [r7, #0]
 8017a2e:	689b      	ldr	r3, [r3, #8]
 8017a30:	051b      	lsls	r3, r3, #20
 8017a32:	693a      	ldr	r2, [r7, #16]
 8017a34:	4313      	orrs	r3, r2
 8017a36:	613b      	str	r3, [r7, #16]

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8017a38:	687b      	ldr	r3, [r7, #4]
 8017a3a:	4a22      	ldr	r2, [pc, #136]	@ (8017ac4 <TIM_OC6_SetConfig+0xe0>)
 8017a3c:	4293      	cmp	r3, r2
 8017a3e:	d023      	beq.n	8017a88 <TIM_OC6_SetConfig+0xa4>
 8017a40:	687b      	ldr	r3, [r7, #4]
 8017a42:	4a21      	ldr	r2, [pc, #132]	@ (8017ac8 <TIM_OC6_SetConfig+0xe4>)
 8017a44:	4293      	cmp	r3, r2
 8017a46:	d01f      	beq.n	8017a88 <TIM_OC6_SetConfig+0xa4>
 8017a48:	687b      	ldr	r3, [r7, #4]
 8017a4a:	4a20      	ldr	r2, [pc, #128]	@ (8017acc <TIM_OC6_SetConfig+0xe8>)
 8017a4c:	4293      	cmp	r3, r2
 8017a4e:	d01b      	beq.n	8017a88 <TIM_OC6_SetConfig+0xa4>
 8017a50:	687b      	ldr	r3, [r7, #4]
 8017a52:	4a1f      	ldr	r2, [pc, #124]	@ (8017ad0 <TIM_OC6_SetConfig+0xec>)
 8017a54:	4293      	cmp	r3, r2
 8017a56:	d017      	beq.n	8017a88 <TIM_OC6_SetConfig+0xa4>
 8017a58:	687b      	ldr	r3, [r7, #4]
 8017a5a:	4a1e      	ldr	r2, [pc, #120]	@ (8017ad4 <TIM_OC6_SetConfig+0xf0>)
 8017a5c:	4293      	cmp	r3, r2
 8017a5e:	d013      	beq.n	8017a88 <TIM_OC6_SetConfig+0xa4>
 8017a60:	687b      	ldr	r3, [r7, #4]
 8017a62:	4a1d      	ldr	r2, [pc, #116]	@ (8017ad8 <TIM_OC6_SetConfig+0xf4>)
 8017a64:	4293      	cmp	r3, r2
 8017a66:	d00f      	beq.n	8017a88 <TIM_OC6_SetConfig+0xa4>
 8017a68:	687b      	ldr	r3, [r7, #4]
 8017a6a:	4a1c      	ldr	r2, [pc, #112]	@ (8017adc <TIM_OC6_SetConfig+0xf8>)
 8017a6c:	4293      	cmp	r3, r2
 8017a6e:	d00b      	beq.n	8017a88 <TIM_OC6_SetConfig+0xa4>
 8017a70:	687b      	ldr	r3, [r7, #4]
 8017a72:	4a1b      	ldr	r2, [pc, #108]	@ (8017ae0 <TIM_OC6_SetConfig+0xfc>)
 8017a74:	4293      	cmp	r3, r2
 8017a76:	d007      	beq.n	8017a88 <TIM_OC6_SetConfig+0xa4>
 8017a78:	687b      	ldr	r3, [r7, #4]
 8017a7a:	4a1a      	ldr	r2, [pc, #104]	@ (8017ae4 <TIM_OC6_SetConfig+0x100>)
 8017a7c:	4293      	cmp	r3, r2
 8017a7e:	d003      	beq.n	8017a88 <TIM_OC6_SetConfig+0xa4>
 8017a80:	687b      	ldr	r3, [r7, #4]
 8017a82:	4a19      	ldr	r2, [pc, #100]	@ (8017ae8 <TIM_OC6_SetConfig+0x104>)
 8017a84:	4293      	cmp	r3, r2
 8017a86:	d109      	bne.n	8017a9c <TIM_OC6_SetConfig+0xb8>
  {
    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS6;
 8017a88:	697b      	ldr	r3, [r7, #20]
 8017a8a:	f423 2380 	bic.w	r3, r3, #262144	@ 0x40000
 8017a8e:	617b      	str	r3, [r7, #20]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 10U);
 8017a90:	683b      	ldr	r3, [r7, #0]
 8017a92:	695b      	ldr	r3, [r3, #20]
 8017a94:	029b      	lsls	r3, r3, #10
 8017a96:	697a      	ldr	r2, [r7, #20]
 8017a98:	4313      	orrs	r3, r2
 8017a9a:	617b      	str	r3, [r7, #20]
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8017a9c:	687b      	ldr	r3, [r7, #4]
 8017a9e:	697a      	ldr	r2, [r7, #20]
 8017aa0:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR3 */
  TIMx->CCMR3 = tmpccmrx;
 8017aa2:	687b      	ldr	r3, [r7, #4]
 8017aa4:	68fa      	ldr	r2, [r7, #12]
 8017aa6:	651a      	str	r2, [r3, #80]	@ 0x50

  /* Set the Capture Compare Register value */
  TIMx->CCR6 = OC_Config->Pulse;
 8017aa8:	683b      	ldr	r3, [r7, #0]
 8017aaa:	685a      	ldr	r2, [r3, #4]
 8017aac:	687b      	ldr	r3, [r7, #4]
 8017aae:	64da      	str	r2, [r3, #76]	@ 0x4c

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8017ab0:	687b      	ldr	r3, [r7, #4]
 8017ab2:	693a      	ldr	r2, [r7, #16]
 8017ab4:	621a      	str	r2, [r3, #32]
}
 8017ab6:	bf00      	nop
 8017ab8:	371c      	adds	r7, #28
 8017aba:	46bd      	mov	sp, r7
 8017abc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017ac0:	4770      	bx	lr
 8017ac2:	bf00      	nop
 8017ac4:	40012c00 	.word	0x40012c00
 8017ac8:	50012c00 	.word	0x50012c00
 8017acc:	40013400 	.word	0x40013400
 8017ad0:	50013400 	.word	0x50013400
 8017ad4:	40014000 	.word	0x40014000
 8017ad8:	50014000 	.word	0x50014000
 8017adc:	40014400 	.word	0x40014400
 8017ae0:	50014400 	.word	0x50014400
 8017ae4:	40014800 	.word	0x40014800
 8017ae8:	50014800 	.word	0x50014800

08017aec <TIM_CCxChannelCmd>:
  * @param  ChannelState specifies the TIM Channel CCxE bit new state.
  *          This parameter can be: TIM_CCx_ENABLE or TIM_CCx_DISABLE.
  * @retval None
  */
void TIM_CCxChannelCmd(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ChannelState)
{
 8017aec:	b480      	push	{r7}
 8017aee:	b087      	sub	sp, #28
 8017af0:	af00      	add	r7, sp, #0
 8017af2:	60f8      	str	r0, [r7, #12]
 8017af4:	60b9      	str	r1, [r7, #8]
 8017af6:	607a      	str	r2, [r7, #4]

  /* Check the parameters */
  assert_param(IS_TIM_CC1_INSTANCE(TIMx));
  assert_param(IS_TIM_CHANNELS(Channel));

  tmp = TIM_CCER_CC1E << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
 8017af8:	68bb      	ldr	r3, [r7, #8]
 8017afa:	f003 031f 	and.w	r3, r3, #31
 8017afe:	2201      	movs	r2, #1
 8017b00:	fa02 f303 	lsl.w	r3, r2, r3
 8017b04:	617b      	str	r3, [r7, #20]

  /* Reset the CCxE Bit */
  TIMx->CCER &= ~tmp;
 8017b06:	68fb      	ldr	r3, [r7, #12]
 8017b08:	6a1a      	ldr	r2, [r3, #32]
 8017b0a:	697b      	ldr	r3, [r7, #20]
 8017b0c:	43db      	mvns	r3, r3
 8017b0e:	401a      	ands	r2, r3
 8017b10:	68fb      	ldr	r3, [r7, #12]
 8017b12:	621a      	str	r2, [r3, #32]

  /* Set or reset the CCxE Bit */
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
 8017b14:	68fb      	ldr	r3, [r7, #12]
 8017b16:	6a1a      	ldr	r2, [r3, #32]
 8017b18:	68bb      	ldr	r3, [r7, #8]
 8017b1a:	f003 031f 	and.w	r3, r3, #31
 8017b1e:	6879      	ldr	r1, [r7, #4]
 8017b20:	fa01 f303 	lsl.w	r3, r1, r3
 8017b24:	431a      	orrs	r2, r3
 8017b26:	68fb      	ldr	r3, [r7, #12]
 8017b28:	621a      	str	r2, [r3, #32]
}
 8017b2a:	bf00      	nop
 8017b2c:	371c      	adds	r7, #28
 8017b2e:	46bd      	mov	sp, r7
 8017b30:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017b34:	4770      	bx	lr

08017b36 <HAL_TIMEx_CommutCallback>:
  * @brief  Hall commutation changed callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_CommutCallback(TIM_HandleTypeDef *htim)
{
 8017b36:	b480      	push	{r7}
 8017b38:	b083      	sub	sp, #12
 8017b3a:	af00      	add	r7, sp, #0
 8017b3c:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_CommutCallback could be implemented in the user file
   */
}
 8017b3e:	bf00      	nop
 8017b40:	370c      	adds	r7, #12
 8017b42:	46bd      	mov	sp, r7
 8017b44:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017b48:	4770      	bx	lr

08017b4a <HAL_TIMEx_BreakCallback>:
  * @brief  Hall Break detection callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim)
{
 8017b4a:	b480      	push	{r7}
 8017b4c:	b083      	sub	sp, #12
 8017b4e:	af00      	add	r7, sp, #0
 8017b50:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_BreakCallback could be implemented in the user file
   */
}
 8017b52:	bf00      	nop
 8017b54:	370c      	adds	r7, #12
 8017b56:	46bd      	mov	sp, r7
 8017b58:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017b5c:	4770      	bx	lr

08017b5e <HAL_TIMEx_Break2Callback>:
  * @brief  Hall Break2 detection callback in non blocking mode
  * @param  htim: TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_Break2Callback(TIM_HandleTypeDef *htim)
{
 8017b5e:	b480      	push	{r7}
 8017b60:	b083      	sub	sp, #12
 8017b62:	af00      	add	r7, sp, #0
 8017b64:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_TIMEx_Break2Callback could be implemented in the user file
   */
}
 8017b66:	bf00      	nop
 8017b68:	370c      	adds	r7, #12
 8017b6a:	46bd      	mov	sp, r7
 8017b6c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017b70:	4770      	bx	lr

08017b72 <HAL_TIMEx_EncoderIndexCallback>:
  * @brief  Encoder index callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_EncoderIndexCallback(TIM_HandleTypeDef *htim)
{
 8017b72:	b480      	push	{r7}
 8017b74:	b083      	sub	sp, #12
 8017b76:	af00      	add	r7, sp, #0
 8017b78:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_EncoderIndexCallback could be implemented in the user file
   */
}
 8017b7a:	bf00      	nop
 8017b7c:	370c      	adds	r7, #12
 8017b7e:	46bd      	mov	sp, r7
 8017b80:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017b84:	4770      	bx	lr

08017b86 <HAL_TIMEx_DirectionChangeCallback>:
  * @brief  Direction change callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_DirectionChangeCallback(TIM_HandleTypeDef *htim)
{
 8017b86:	b480      	push	{r7}
 8017b88:	b083      	sub	sp, #12
 8017b8a:	af00      	add	r7, sp, #0
 8017b8c:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_DirectionChangeCallback could be implemented in the user file
   */
}
 8017b8e:	bf00      	nop
 8017b90:	370c      	adds	r7, #12
 8017b92:	46bd      	mov	sp, r7
 8017b94:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017b98:	4770      	bx	lr

08017b9a <HAL_TIMEx_IndexErrorCallback>:
  * @brief  Index error callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_IndexErrorCallback(TIM_HandleTypeDef *htim)
{
 8017b9a:	b480      	push	{r7}
 8017b9c:	b083      	sub	sp, #12
 8017b9e:	af00      	add	r7, sp, #0
 8017ba0:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_IndexErrorCallback could be implemented in the user file
   */
}
 8017ba2:	bf00      	nop
 8017ba4:	370c      	adds	r7, #12
 8017ba6:	46bd      	mov	sp, r7
 8017ba8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017bac:	4770      	bx	lr

08017bae <HAL_TIMEx_TransitionErrorCallback>:
  * @brief  Transition error callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_TransitionErrorCallback(TIM_HandleTypeDef *htim)
{
 8017bae:	b480      	push	{r7}
 8017bb0:	b083      	sub	sp, #12
 8017bb2:	af00      	add	r7, sp, #0
 8017bb4:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_TransitionErrorCallback could be implemented in the user file
   */
}
 8017bb6:	bf00      	nop
 8017bb8:	370c      	adds	r7, #12
 8017bba:	46bd      	mov	sp, r7
 8017bbc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017bc0:	4770      	bx	lr

08017bc2 <HAL_UART_Init>:
  *        parameters in the UART_InitTypeDef and initialize the associated handle.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
 8017bc2:	b580      	push	{r7, lr}
 8017bc4:	b082      	sub	sp, #8
 8017bc6:	af00      	add	r7, sp, #0
 8017bc8:	6078      	str	r0, [r7, #4]
  /* Check the UART handle allocation */
  if (huart == NULL)
 8017bca:	687b      	ldr	r3, [r7, #4]
 8017bcc:	2b00      	cmp	r3, #0
 8017bce:	d101      	bne.n	8017bd4 <HAL_UART_Init+0x12>
  {
    return HAL_ERROR;
 8017bd0:	2301      	movs	r3, #1
 8017bd2:	e042      	b.n	8017c5a <HAL_UART_Init+0x98>
  {
    /* Check the parameters */
    assert_param((IS_UART_INSTANCE(huart->Instance)) || (IS_LPUART_INSTANCE(huart->Instance)));
  }

  if (huart->gState == HAL_UART_STATE_RESET)
 8017bd4:	687b      	ldr	r3, [r7, #4]
 8017bd6:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 8017bda:	2b00      	cmp	r3, #0
 8017bdc:	d106      	bne.n	8017bec <HAL_UART_Init+0x2a>
  {
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
 8017bde:	687b      	ldr	r3, [r7, #4]
 8017be0:	2200      	movs	r2, #0
 8017be2:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

    /* Init the low level hardware */
    huart->MspInitCallback(huart);
#else
    /* Init the low level hardware : GPIO, CLOCK */
    HAL_UART_MspInit(huart);
 8017be6:	6878      	ldr	r0, [r7, #4]
 8017be8:	f000 f83b 	bl	8017c62 <HAL_UART_MspInit>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
  }

  huart->gState = HAL_UART_STATE_BUSY;
 8017bec:	687b      	ldr	r3, [r7, #4]
 8017bee:	2224      	movs	r2, #36	@ 0x24
 8017bf0:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

  __HAL_UART_DISABLE(huart);
 8017bf4:	687b      	ldr	r3, [r7, #4]
 8017bf6:	681b      	ldr	r3, [r3, #0]
 8017bf8:	681a      	ldr	r2, [r3, #0]
 8017bfa:	687b      	ldr	r3, [r7, #4]
 8017bfc:	681b      	ldr	r3, [r3, #0]
 8017bfe:	f022 0201 	bic.w	r2, r2, #1
 8017c02:	601a      	str	r2, [r3, #0]

  /* Perform advanced settings configuration */
  /* For some items, configuration requires to be done prior TE and RE bits are set */
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 8017c04:	687b      	ldr	r3, [r7, #4]
 8017c06:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8017c08:	2b00      	cmp	r3, #0
 8017c0a:	d002      	beq.n	8017c12 <HAL_UART_Init+0x50>
  {
    UART_AdvFeatureConfig(huart);
 8017c0c:	6878      	ldr	r0, [r7, #4]
 8017c0e:	f000 fa73 	bl	80180f8 <UART_AdvFeatureConfig>
  }

  /* Set the UART Communication parameters */
  if (UART_SetConfig(huart) == HAL_ERROR)
 8017c12:	6878      	ldr	r0, [r7, #4]
 8017c14:	f000 f8ce 	bl	8017db4 <UART_SetConfig>
 8017c18:	4603      	mov	r3, r0
 8017c1a:	2b01      	cmp	r3, #1
 8017c1c:	d101      	bne.n	8017c22 <HAL_UART_Init+0x60>
  {
    return HAL_ERROR;
 8017c1e:	2301      	movs	r3, #1
 8017c20:	e01b      	b.n	8017c5a <HAL_UART_Init+0x98>
  }

  /* In asynchronous mode, the following bits must be kept cleared:
  - LINEN and CLKEN bits in the USART_CR2 register,
  - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8017c22:	687b      	ldr	r3, [r7, #4]
 8017c24:	681b      	ldr	r3, [r3, #0]
 8017c26:	685a      	ldr	r2, [r3, #4]
 8017c28:	687b      	ldr	r3, [r7, #4]
 8017c2a:	681b      	ldr	r3, [r3, #0]
 8017c2c:	f422 4290 	bic.w	r2, r2, #18432	@ 0x4800
 8017c30:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 8017c32:	687b      	ldr	r3, [r7, #4]
 8017c34:	681b      	ldr	r3, [r3, #0]
 8017c36:	689a      	ldr	r2, [r3, #8]
 8017c38:	687b      	ldr	r3, [r7, #4]
 8017c3a:	681b      	ldr	r3, [r3, #0]
 8017c3c:	f022 022a 	bic.w	r2, r2, #42	@ 0x2a
 8017c40:	609a      	str	r2, [r3, #8]

  __HAL_UART_ENABLE(huart);
 8017c42:	687b      	ldr	r3, [r7, #4]
 8017c44:	681b      	ldr	r3, [r3, #0]
 8017c46:	681a      	ldr	r2, [r3, #0]
 8017c48:	687b      	ldr	r3, [r7, #4]
 8017c4a:	681b      	ldr	r3, [r3, #0]
 8017c4c:	f042 0201 	orr.w	r2, r2, #1
 8017c50:	601a      	str	r2, [r3, #0]

  /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
  return (UART_CheckIdleState(huart));
 8017c52:	6878      	ldr	r0, [r7, #4]
 8017c54:	f000 faf2 	bl	801823c <UART_CheckIdleState>
 8017c58:	4603      	mov	r3, r0
}
 8017c5a:	4618      	mov	r0, r3
 8017c5c:	3708      	adds	r7, #8
 8017c5e:	46bd      	mov	sp, r7
 8017c60:	bd80      	pop	{r7, pc}

08017c62 <HAL_UART_MspInit>:
  * @brief Initialize the UART MSP.
  * @param huart UART handle.
  * @retval None
  */
__weak void HAL_UART_MspInit(UART_HandleTypeDef *huart)
{
 8017c62:	b480      	push	{r7}
 8017c64:	b083      	sub	sp, #12
 8017c66:	af00      	add	r7, sp, #0
 8017c68:	6078      	str	r0, [r7, #4]
  UNUSED(huart);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UART_MspInit can be implemented in the user file
   */
}
 8017c6a:	bf00      	nop
 8017c6c:	370c      	adds	r7, #12
 8017c6e:	46bd      	mov	sp, r7
 8017c70:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017c74:	4770      	bx	lr

08017c76 <HAL_UART_Transmit>:
  * @param Size    Amount of data elements (u8 or u16) to be sent.
  * @param Timeout Timeout duration.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 8017c76:	b580      	push	{r7, lr}
 8017c78:	b08a      	sub	sp, #40	@ 0x28
 8017c7a:	af02      	add	r7, sp, #8
 8017c7c:	60f8      	str	r0, [r7, #12]
 8017c7e:	60b9      	str	r1, [r7, #8]
 8017c80:	603b      	str	r3, [r7, #0]
 8017c82:	4613      	mov	r3, r2
 8017c84:	80fb      	strh	r3, [r7, #6]
  const uint8_t  *pdata8bits;
  const uint16_t *pdata16bits;
  uint32_t tickstart;

  /* Check that a Tx process is not already ongoing */
  if (huart->gState == HAL_UART_STATE_READY)
 8017c86:	68fb      	ldr	r3, [r7, #12]
 8017c88:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 8017c8c:	2b20      	cmp	r3, #32
 8017c8e:	f040 808b 	bne.w	8017da8 <HAL_UART_Transmit+0x132>
  {
    if ((pData == NULL) || (Size == 0U))
 8017c92:	68bb      	ldr	r3, [r7, #8]
 8017c94:	2b00      	cmp	r3, #0
 8017c96:	d002      	beq.n	8017c9e <HAL_UART_Transmit+0x28>
 8017c98:	88fb      	ldrh	r3, [r7, #6]
 8017c9a:	2b00      	cmp	r3, #0
 8017c9c:	d101      	bne.n	8017ca2 <HAL_UART_Transmit+0x2c>
    {
      return  HAL_ERROR;
 8017c9e:	2301      	movs	r3, #1
 8017ca0:	e083      	b.n	8017daa <HAL_UART_Transmit+0x134>
    }

#if defined(USART_DMAREQUESTS_SW_WA)
    /* Disable the UART DMA Tx request if enabled */
    if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
 8017ca2:	68fb      	ldr	r3, [r7, #12]
 8017ca4:	681b      	ldr	r3, [r3, #0]
 8017ca6:	689b      	ldr	r3, [r3, #8]
 8017ca8:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8017cac:	2b80      	cmp	r3, #128	@ 0x80
 8017cae:	d107      	bne.n	8017cc0 <HAL_UART_Transmit+0x4a>
    {
      CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 8017cb0:	68fb      	ldr	r3, [r7, #12]
 8017cb2:	681b      	ldr	r3, [r3, #0]
 8017cb4:	689a      	ldr	r2, [r3, #8]
 8017cb6:	68fb      	ldr	r3, [r7, #12]
 8017cb8:	681b      	ldr	r3, [r3, #0]
 8017cba:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
 8017cbe:	609a      	str	r2, [r3, #8]
    }

#endif /* USART_DMAREQUESTS_SW_WA */
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8017cc0:	68fb      	ldr	r3, [r7, #12]
 8017cc2:	2200      	movs	r2, #0
 8017cc4:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
    huart->gState = HAL_UART_STATE_BUSY_TX;
 8017cc8:	68fb      	ldr	r3, [r7, #12]
 8017cca:	2221      	movs	r2, #33	@ 0x21
 8017ccc:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

    /* Init tickstart for timeout management */
    tickstart = HAL_GetTick();
 8017cd0:	f7f5 fec6 	bl	800da60 <HAL_GetTick>
 8017cd4:	6178      	str	r0, [r7, #20]

    huart->TxXferSize  = Size;
 8017cd6:	68fb      	ldr	r3, [r7, #12]
 8017cd8:	88fa      	ldrh	r2, [r7, #6]
 8017cda:	f8a3 2054 	strh.w	r2, [r3, #84]	@ 0x54
    huart->TxXferCount = Size;
 8017cde:	68fb      	ldr	r3, [r7, #12]
 8017ce0:	88fa      	ldrh	r2, [r7, #6]
 8017ce2:	f8a3 2056 	strh.w	r2, [r3, #86]	@ 0x56

    /* In case of 9bits/No Parity transfer, pData needs to be handled as a uint16_t pointer */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8017ce6:	68fb      	ldr	r3, [r7, #12]
 8017ce8:	689b      	ldr	r3, [r3, #8]
 8017cea:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 8017cee:	d108      	bne.n	8017d02 <HAL_UART_Transmit+0x8c>
 8017cf0:	68fb      	ldr	r3, [r7, #12]
 8017cf2:	691b      	ldr	r3, [r3, #16]
 8017cf4:	2b00      	cmp	r3, #0
 8017cf6:	d104      	bne.n	8017d02 <HAL_UART_Transmit+0x8c>
    {
      pdata8bits  = NULL;
 8017cf8:	2300      	movs	r3, #0
 8017cfa:	61fb      	str	r3, [r7, #28]
      pdata16bits = (const uint16_t *) pData;
 8017cfc:	68bb      	ldr	r3, [r7, #8]
 8017cfe:	61bb      	str	r3, [r7, #24]
 8017d00:	e003      	b.n	8017d0a <HAL_UART_Transmit+0x94>
    }
    else
    {
      pdata8bits  = pData;
 8017d02:	68bb      	ldr	r3, [r7, #8]
 8017d04:	61fb      	str	r3, [r7, #28]
      pdata16bits = NULL;
 8017d06:	2300      	movs	r3, #0
 8017d08:	61bb      	str	r3, [r7, #24]
    }

    while (huart->TxXferCount > 0U)
 8017d0a:	e030      	b.n	8017d6e <HAL_UART_Transmit+0xf8>
    {
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 8017d0c:	683b      	ldr	r3, [r7, #0]
 8017d0e:	9300      	str	r3, [sp, #0]
 8017d10:	697b      	ldr	r3, [r7, #20]
 8017d12:	2200      	movs	r2, #0
 8017d14:	2180      	movs	r1, #128	@ 0x80
 8017d16:	68f8      	ldr	r0, [r7, #12]
 8017d18:	f000 fb3a 	bl	8018390 <UART_WaitOnFlagUntilTimeout>
 8017d1c:	4603      	mov	r3, r0
 8017d1e:	2b00      	cmp	r3, #0
 8017d20:	d005      	beq.n	8017d2e <HAL_UART_Transmit+0xb8>
      {

        huart->gState = HAL_UART_STATE_READY;
 8017d22:	68fb      	ldr	r3, [r7, #12]
 8017d24:	2220      	movs	r2, #32
 8017d26:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

        return HAL_TIMEOUT;
 8017d2a:	2303      	movs	r3, #3
 8017d2c:	e03d      	b.n	8017daa <HAL_UART_Transmit+0x134>
      }
      if (pdata8bits == NULL)
 8017d2e:	69fb      	ldr	r3, [r7, #28]
 8017d30:	2b00      	cmp	r3, #0
 8017d32:	d10b      	bne.n	8017d4c <HAL_UART_Transmit+0xd6>
      {
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
 8017d34:	69bb      	ldr	r3, [r7, #24]
 8017d36:	881b      	ldrh	r3, [r3, #0]
 8017d38:	461a      	mov	r2, r3
 8017d3a:	68fb      	ldr	r3, [r7, #12]
 8017d3c:	681b      	ldr	r3, [r3, #0]
 8017d3e:	f3c2 0208 	ubfx	r2, r2, #0, #9
 8017d42:	629a      	str	r2, [r3, #40]	@ 0x28
        pdata16bits++;
 8017d44:	69bb      	ldr	r3, [r7, #24]
 8017d46:	3302      	adds	r3, #2
 8017d48:	61bb      	str	r3, [r7, #24]
 8017d4a:	e007      	b.n	8017d5c <HAL_UART_Transmit+0xe6>
      }
      else
      {
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
 8017d4c:	69fb      	ldr	r3, [r7, #28]
 8017d4e:	781a      	ldrb	r2, [r3, #0]
 8017d50:	68fb      	ldr	r3, [r7, #12]
 8017d52:	681b      	ldr	r3, [r3, #0]
 8017d54:	629a      	str	r2, [r3, #40]	@ 0x28
        pdata8bits++;
 8017d56:	69fb      	ldr	r3, [r7, #28]
 8017d58:	3301      	adds	r3, #1
 8017d5a:	61fb      	str	r3, [r7, #28]
      }
      huart->TxXferCount--;
 8017d5c:	68fb      	ldr	r3, [r7, #12]
 8017d5e:	f8b3 3056 	ldrh.w	r3, [r3, #86]	@ 0x56
 8017d62:	b29b      	uxth	r3, r3
 8017d64:	3b01      	subs	r3, #1
 8017d66:	b29a      	uxth	r2, r3
 8017d68:	68fb      	ldr	r3, [r7, #12]
 8017d6a:	f8a3 2056 	strh.w	r2, [r3, #86]	@ 0x56
    while (huart->TxXferCount > 0U)
 8017d6e:	68fb      	ldr	r3, [r7, #12]
 8017d70:	f8b3 3056 	ldrh.w	r3, [r3, #86]	@ 0x56
 8017d74:	b29b      	uxth	r3, r3
 8017d76:	2b00      	cmp	r3, #0
 8017d78:	d1c8      	bne.n	8017d0c <HAL_UART_Transmit+0x96>
    }

    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 8017d7a:	683b      	ldr	r3, [r7, #0]
 8017d7c:	9300      	str	r3, [sp, #0]
 8017d7e:	697b      	ldr	r3, [r7, #20]
 8017d80:	2200      	movs	r2, #0
 8017d82:	2140      	movs	r1, #64	@ 0x40
 8017d84:	68f8      	ldr	r0, [r7, #12]
 8017d86:	f000 fb03 	bl	8018390 <UART_WaitOnFlagUntilTimeout>
 8017d8a:	4603      	mov	r3, r0
 8017d8c:	2b00      	cmp	r3, #0
 8017d8e:	d005      	beq.n	8017d9c <HAL_UART_Transmit+0x126>
    {
      huart->gState = HAL_UART_STATE_READY;
 8017d90:	68fb      	ldr	r3, [r7, #12]
 8017d92:	2220      	movs	r2, #32
 8017d94:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

      return HAL_TIMEOUT;
 8017d98:	2303      	movs	r3, #3
 8017d9a:	e006      	b.n	8017daa <HAL_UART_Transmit+0x134>
    }

    /* At end of Tx process, restore huart->gState to Ready */
    huart->gState = HAL_UART_STATE_READY;
 8017d9c:	68fb      	ldr	r3, [r7, #12]
 8017d9e:	2220      	movs	r2, #32
 8017da0:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

    return HAL_OK;
 8017da4:	2300      	movs	r3, #0
 8017da6:	e000      	b.n	8017daa <HAL_UART_Transmit+0x134>
  }
  else
  {
    return HAL_BUSY;
 8017da8:	2302      	movs	r3, #2
  }
}
 8017daa:	4618      	mov	r0, r3
 8017dac:	3720      	adds	r7, #32
 8017dae:	46bd      	mov	sp, r7
 8017db0:	bd80      	pop	{r7, pc}
	...

08017db4 <UART_SetConfig>:
  * @brief Configure the UART peripheral.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
 8017db4:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8017db8:	b094      	sub	sp, #80	@ 0x50
 8017dba:	af00      	add	r7, sp, #0
 8017dbc:	62f8      	str	r0, [r7, #44]	@ 0x2c
  uint32_t tmpreg;
  uint16_t brrtemp;
  uint32_t clocksource;
  uint32_t usartdiv;
  HAL_StatusTypeDef ret               = HAL_OK;
 8017dbe:	2300      	movs	r3, #0
 8017dc0:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
  uint32_t pclk;

  /* Check the parameters */
  assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
  assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
  if (UART_INSTANCE_LOWPOWER(huart))
 8017dc4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8017dc6:	681a      	ldr	r2, [r3, #0]
 8017dc8:	4b7e      	ldr	r3, [pc, #504]	@ (8017fc4 <UART_SetConfig+0x210>)
 8017dca:	429a      	cmp	r2, r3
  *  the UART Word Length, Parity, Mode and oversampling:
  *  set the M bits according to huart->Init.WordLength value
  *  set PCE and PS bits according to huart->Init.Parity value
  *  set TE and RE bits according to huart->Init.Mode value
  *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8017dcc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8017dce:	689a      	ldr	r2, [r3, #8]
 8017dd0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8017dd2:	691b      	ldr	r3, [r3, #16]
 8017dd4:	431a      	orrs	r2, r3
 8017dd6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8017dd8:	695b      	ldr	r3, [r3, #20]
 8017dda:	431a      	orrs	r2, r3
 8017ddc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8017dde:	69db      	ldr	r3, [r3, #28]
 8017de0:	4313      	orrs	r3, r2
 8017de2:	64fb      	str	r3, [r7, #76]	@ 0x4c
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 8017de4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8017de6:	681b      	ldr	r3, [r3, #0]
 8017de8:	681b      	ldr	r3, [r3, #0]
 8017dea:	4977      	ldr	r1, [pc, #476]	@ (8017fc8 <UART_SetConfig+0x214>)
 8017dec:	4019      	ands	r1, r3
 8017dee:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8017df0:	681a      	ldr	r2, [r3, #0]
 8017df2:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8017df4:	430b      	orrs	r3, r1
 8017df6:	6013      	str	r3, [r2, #0]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according
  * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 8017df8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8017dfa:	681b      	ldr	r3, [r3, #0]
 8017dfc:	685b      	ldr	r3, [r3, #4]
 8017dfe:	f423 5040 	bic.w	r0, r3, #12288	@ 0x3000
 8017e02:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8017e04:	68d9      	ldr	r1, [r3, #12]
 8017e06:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8017e08:	681a      	ldr	r2, [r3, #0]
 8017e0a:	ea40 0301 	orr.w	r3, r0, r1
 8017e0e:	6053      	str	r3, [r2, #4]
  /* Configure
  * - UART HardWare Flow Control: set CTSE and RTSE bits according
  *   to huart->Init.HwFlowCtl value
  * - one-bit sampling method versus three samples' majority rule according
  *   to huart->Init.OneBitSampling (not applicable to LPUART) */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 8017e10:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8017e12:	699b      	ldr	r3, [r3, #24]
 8017e14:	64fb      	str	r3, [r7, #76]	@ 0x4c

  if (!(UART_INSTANCE_LOWPOWER(huart)))
 8017e16:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8017e18:	681a      	ldr	r2, [r3, #0]
 8017e1a:	4b6a      	ldr	r3, [pc, #424]	@ (8017fc4 <UART_SetConfig+0x210>)
 8017e1c:	429a      	cmp	r2, r3
 8017e1e:	d009      	beq.n	8017e34 <UART_SetConfig+0x80>
 8017e20:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8017e22:	681a      	ldr	r2, [r3, #0]
 8017e24:	4b69      	ldr	r3, [pc, #420]	@ (8017fcc <UART_SetConfig+0x218>)
 8017e26:	429a      	cmp	r2, r3
 8017e28:	d004      	beq.n	8017e34 <UART_SetConfig+0x80>
  {
    tmpreg |= huart->Init.OneBitSampling;
 8017e2a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8017e2c:	6a1a      	ldr	r2, [r3, #32]
 8017e2e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8017e30:	4313      	orrs	r3, r2
 8017e32:	64fb      	str	r3, [r7, #76]	@ 0x4c
  }
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 8017e34:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8017e36:	681b      	ldr	r3, [r3, #0]
 8017e38:	689b      	ldr	r3, [r3, #8]
 8017e3a:	f023 416e 	bic.w	r1, r3, #3992977408	@ 0xee000000
 8017e3e:	f421 6130 	bic.w	r1, r1, #2816	@ 0xb00
 8017e42:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8017e44:	681a      	ldr	r2, [r3, #0]
 8017e46:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8017e48:	430b      	orrs	r3, r1
 8017e4a:	6093      	str	r3, [r2, #8]

  /*-------------------------- USART PRESC Configuration -----------------------*/
  /* Configure
  * - UART Clock Prescaler : set PRESCALER according to huart->Init.ClockPrescaler value */
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 8017e4c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8017e4e:	681b      	ldr	r3, [r3, #0]
 8017e50:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8017e52:	f023 000f 	bic.w	r0, r3, #15
 8017e56:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8017e58:	6a59      	ldr	r1, [r3, #36]	@ 0x24
 8017e5a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8017e5c:	681a      	ldr	r2, [r3, #0]
 8017e5e:	ea40 0301 	orr.w	r3, r0, r1
 8017e62:	62d3      	str	r3, [r2, #44]	@ 0x2c

  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
 8017e64:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8017e66:	681a      	ldr	r2, [r3, #0]
 8017e68:	4b59      	ldr	r3, [pc, #356]	@ (8017fd0 <UART_SetConfig+0x21c>)
 8017e6a:	429a      	cmp	r2, r3
 8017e6c:	d102      	bne.n	8017e74 <UART_SetConfig+0xc0>
 8017e6e:	2301      	movs	r3, #1
 8017e70:	64bb      	str	r3, [r7, #72]	@ 0x48
 8017e72:	e029      	b.n	8017ec8 <UART_SetConfig+0x114>
 8017e74:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8017e76:	681a      	ldr	r2, [r3, #0]
 8017e78:	4b56      	ldr	r3, [pc, #344]	@ (8017fd4 <UART_SetConfig+0x220>)
 8017e7a:	429a      	cmp	r2, r3
 8017e7c:	d102      	bne.n	8017e84 <UART_SetConfig+0xd0>
 8017e7e:	2302      	movs	r3, #2
 8017e80:	64bb      	str	r3, [r7, #72]	@ 0x48
 8017e82:	e021      	b.n	8017ec8 <UART_SetConfig+0x114>
 8017e84:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8017e86:	681a      	ldr	r2, [r3, #0]
 8017e88:	4b53      	ldr	r3, [pc, #332]	@ (8017fd8 <UART_SetConfig+0x224>)
 8017e8a:	429a      	cmp	r2, r3
 8017e8c:	d102      	bne.n	8017e94 <UART_SetConfig+0xe0>
 8017e8e:	2304      	movs	r3, #4
 8017e90:	64bb      	str	r3, [r7, #72]	@ 0x48
 8017e92:	e019      	b.n	8017ec8 <UART_SetConfig+0x114>
 8017e94:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8017e96:	681a      	ldr	r2, [r3, #0]
 8017e98:	4b50      	ldr	r3, [pc, #320]	@ (8017fdc <UART_SetConfig+0x228>)
 8017e9a:	429a      	cmp	r2, r3
 8017e9c:	d102      	bne.n	8017ea4 <UART_SetConfig+0xf0>
 8017e9e:	2308      	movs	r3, #8
 8017ea0:	64bb      	str	r3, [r7, #72]	@ 0x48
 8017ea2:	e011      	b.n	8017ec8 <UART_SetConfig+0x114>
 8017ea4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8017ea6:	681a      	ldr	r2, [r3, #0]
 8017ea8:	4b4d      	ldr	r3, [pc, #308]	@ (8017fe0 <UART_SetConfig+0x22c>)
 8017eaa:	429a      	cmp	r2, r3
 8017eac:	d102      	bne.n	8017eb4 <UART_SetConfig+0x100>
 8017eae:	2310      	movs	r3, #16
 8017eb0:	64bb      	str	r3, [r7, #72]	@ 0x48
 8017eb2:	e009      	b.n	8017ec8 <UART_SetConfig+0x114>
 8017eb4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8017eb6:	681a      	ldr	r2, [r3, #0]
 8017eb8:	4b42      	ldr	r3, [pc, #264]	@ (8017fc4 <UART_SetConfig+0x210>)
 8017eba:	429a      	cmp	r2, r3
 8017ebc:	d102      	bne.n	8017ec4 <UART_SetConfig+0x110>
 8017ebe:	2320      	movs	r3, #32
 8017ec0:	64bb      	str	r3, [r7, #72]	@ 0x48
 8017ec2:	e001      	b.n	8017ec8 <UART_SetConfig+0x114>
 8017ec4:	2300      	movs	r3, #0
 8017ec6:	64bb      	str	r3, [r7, #72]	@ 0x48

  /* Check LPUART instance */
  if (UART_INSTANCE_LOWPOWER(huart))
 8017ec8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8017eca:	681a      	ldr	r2, [r3, #0]
 8017ecc:	4b3d      	ldr	r3, [pc, #244]	@ (8017fc4 <UART_SetConfig+0x210>)
 8017ece:	429a      	cmp	r2, r3
 8017ed0:	d005      	beq.n	8017ede <UART_SetConfig+0x12a>
 8017ed2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8017ed4:	681a      	ldr	r2, [r3, #0]
 8017ed6:	4b3d      	ldr	r3, [pc, #244]	@ (8017fcc <UART_SetConfig+0x218>)
 8017ed8:	429a      	cmp	r2, r3
 8017eda:	f040 8085 	bne.w	8017fe8 <UART_SetConfig+0x234>
  {
    /* Retrieve frequency clock */
    pclk = HAL_RCCEx_GetPeriphCLKFreq(clocksource);
 8017ede:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8017ee0:	2200      	movs	r2, #0
 8017ee2:	623b      	str	r3, [r7, #32]
 8017ee4:	627a      	str	r2, [r7, #36]	@ 0x24
 8017ee6:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 8017eea:	f7fc f9b9 	bl	8014260 <HAL_RCCEx_GetPeriphCLKFreq>
 8017eee:	6438      	str	r0, [r7, #64]	@ 0x40

    /* If proper clock source reported */
    if (pclk != 0U)
 8017ef0:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8017ef2:	2b00      	cmp	r3, #0
 8017ef4:	f000 80e8 	beq.w	80180c8 <UART_SetConfig+0x314>
    {
      /* Compute clock after Prescaler */
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 8017ef8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8017efa:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8017efc:	4a39      	ldr	r2, [pc, #228]	@ (8017fe4 <UART_SetConfig+0x230>)
 8017efe:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8017f02:	461a      	mov	r2, r3
 8017f04:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8017f06:	fbb3 f3f2 	udiv	r3, r3, r2
 8017f0a:	637b      	str	r3, [r7, #52]	@ 0x34

      /* Ensure that Frequency clock is in the range [3 * baudrate, 4096 * baudrate] */
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 8017f0c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8017f0e:	685a      	ldr	r2, [r3, #4]
 8017f10:	4613      	mov	r3, r2
 8017f12:	005b      	lsls	r3, r3, #1
 8017f14:	4413      	add	r3, r2
 8017f16:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8017f18:	429a      	cmp	r2, r3
 8017f1a:	d305      	bcc.n	8017f28 <UART_SetConfig+0x174>
          (lpuart_ker_ck_pres > (4096U * huart->Init.BaudRate)))
 8017f1c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8017f1e:	685b      	ldr	r3, [r3, #4]
 8017f20:	031b      	lsls	r3, r3, #12
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 8017f22:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8017f24:	429a      	cmp	r2, r3
 8017f26:	d903      	bls.n	8017f30 <UART_SetConfig+0x17c>
      {
        ret = HAL_ERROR;
 8017f28:	2301      	movs	r3, #1
 8017f2a:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
 8017f2e:	e048      	b.n	8017fc2 <UART_SetConfig+0x20e>
      }
      else
      {
        /* Check computed UsartDiv value is in allocated range
           (it is forbidden to write values lower than 0x300 in the LPUART_BRR register) */
        usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8017f30:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8017f32:	2200      	movs	r2, #0
 8017f34:	61bb      	str	r3, [r7, #24]
 8017f36:	61fa      	str	r2, [r7, #28]
 8017f38:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8017f3a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8017f3c:	4a29      	ldr	r2, [pc, #164]	@ (8017fe4 <UART_SetConfig+0x230>)
 8017f3e:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8017f42:	b29b      	uxth	r3, r3
 8017f44:	2200      	movs	r2, #0
 8017f46:	613b      	str	r3, [r7, #16]
 8017f48:	617a      	str	r2, [r7, #20]
 8017f4a:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 8017f4e:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 8017f52:	f7e8 fea7 	bl	8000ca4 <__aeabi_uldivmod>
 8017f56:	4602      	mov	r2, r0
 8017f58:	460b      	mov	r3, r1
 8017f5a:	4610      	mov	r0, r2
 8017f5c:	4619      	mov	r1, r3
 8017f5e:	f04f 0200 	mov.w	r2, #0
 8017f62:	f04f 0300 	mov.w	r3, #0
 8017f66:	020b      	lsls	r3, r1, #8
 8017f68:	ea43 6310 	orr.w	r3, r3, r0, lsr #24
 8017f6c:	0202      	lsls	r2, r0, #8
 8017f6e:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 8017f70:	6849      	ldr	r1, [r1, #4]
 8017f72:	0849      	lsrs	r1, r1, #1
 8017f74:	2000      	movs	r0, #0
 8017f76:	460c      	mov	r4, r1
 8017f78:	4605      	mov	r5, r0
 8017f7a:	eb12 0804 	adds.w	r8, r2, r4
 8017f7e:	eb43 0905 	adc.w	r9, r3, r5
 8017f82:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8017f84:	685b      	ldr	r3, [r3, #4]
 8017f86:	2200      	movs	r2, #0
 8017f88:	60bb      	str	r3, [r7, #8]
 8017f8a:	60fa      	str	r2, [r7, #12]
 8017f8c:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 8017f90:	4640      	mov	r0, r8
 8017f92:	4649      	mov	r1, r9
 8017f94:	f7e8 fe86 	bl	8000ca4 <__aeabi_uldivmod>
 8017f98:	4602      	mov	r2, r0
 8017f9a:	460b      	mov	r3, r1
 8017f9c:	4613      	mov	r3, r2
 8017f9e:	63fb      	str	r3, [r7, #60]	@ 0x3c
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
 8017fa0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8017fa2:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
 8017fa6:	d308      	bcc.n	8017fba <UART_SetConfig+0x206>
 8017fa8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8017faa:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 8017fae:	d204      	bcs.n	8017fba <UART_SetConfig+0x206>
        {
          huart->Instance->BRR = usartdiv;
 8017fb0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8017fb2:	681b      	ldr	r3, [r3, #0]
 8017fb4:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8017fb6:	60da      	str	r2, [r3, #12]
 8017fb8:	e003      	b.n	8017fc2 <UART_SetConfig+0x20e>
        }
        else
        {
          ret = HAL_ERROR;
 8017fba:	2301      	movs	r3, #1
 8017fbc:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
    if (pclk != 0U)
 8017fc0:	e082      	b.n	80180c8 <UART_SetConfig+0x314>
 8017fc2:	e081      	b.n	80180c8 <UART_SetConfig+0x314>
 8017fc4:	46002400 	.word	0x46002400
 8017fc8:	cfff69f3 	.word	0xcfff69f3
 8017fcc:	56002400 	.word	0x56002400
 8017fd0:	40013800 	.word	0x40013800
 8017fd4:	40004400 	.word	0x40004400
 8017fd8:	40004800 	.word	0x40004800
 8017fdc:	40004c00 	.word	0x40004c00
 8017fe0:	40005000 	.word	0x40005000
 8017fe4:	0802a5a0 	.word	0x0802a5a0
      } /* if ( (lpuart_ker_ck_pres < (3 * huart->Init.BaudRate) ) ||
                (lpuart_ker_ck_pres > (4096 * huart->Init.BaudRate) )) */
    } /* if (pclk != 0) */
  }
  /* Check UART Over Sampling to set Baud Rate Register */
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8017fe8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8017fea:	69db      	ldr	r3, [r3, #28]
 8017fec:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 8017ff0:	d13c      	bne.n	801806c <UART_SetConfig+0x2b8>
  {
    pclk = HAL_RCCEx_GetPeriphCLKFreq(clocksource);
 8017ff2:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8017ff4:	2200      	movs	r2, #0
 8017ff6:	603b      	str	r3, [r7, #0]
 8017ff8:	607a      	str	r2, [r7, #4]
 8017ffa:	e9d7 0100 	ldrd	r0, r1, [r7]
 8017ffe:	f7fc f92f 	bl	8014260 <HAL_RCCEx_GetPeriphCLKFreq>
 8018002:	6438      	str	r0, [r7, #64]	@ 0x40

    /* USARTDIV must be greater than or equal to 0d16 */
    if (pclk != 0U)
 8018004:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8018006:	2b00      	cmp	r3, #0
 8018008:	d05e      	beq.n	80180c8 <UART_SetConfig+0x314>
    {
      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 801800a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801800c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801800e:	4a39      	ldr	r2, [pc, #228]	@ (80180f4 <UART_SetConfig+0x340>)
 8018010:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8018014:	461a      	mov	r2, r3
 8018016:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8018018:	fbb3 f3f2 	udiv	r3, r3, r2
 801801c:	005a      	lsls	r2, r3, #1
 801801e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8018020:	685b      	ldr	r3, [r3, #4]
 8018022:	085b      	lsrs	r3, r3, #1
 8018024:	441a      	add	r2, r3
 8018026:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8018028:	685b      	ldr	r3, [r3, #4]
 801802a:	fbb2 f3f3 	udiv	r3, r2, r3
 801802e:	63fb      	str	r3, [r7, #60]	@ 0x3c
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 8018030:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8018032:	2b0f      	cmp	r3, #15
 8018034:	d916      	bls.n	8018064 <UART_SetConfig+0x2b0>
 8018036:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8018038:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 801803c:	d212      	bcs.n	8018064 <UART_SetConfig+0x2b0>
      {
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 801803e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8018040:	b29b      	uxth	r3, r3
 8018042:	f023 030f 	bic.w	r3, r3, #15
 8018046:	877b      	strh	r3, [r7, #58]	@ 0x3a
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 8018048:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801804a:	085b      	lsrs	r3, r3, #1
 801804c:	b29b      	uxth	r3, r3
 801804e:	f003 0307 	and.w	r3, r3, #7
 8018052:	b29a      	uxth	r2, r3
 8018054:	8f7b      	ldrh	r3, [r7, #58]	@ 0x3a
 8018056:	4313      	orrs	r3, r2
 8018058:	877b      	strh	r3, [r7, #58]	@ 0x3a
        huart->Instance->BRR = brrtemp;
 801805a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801805c:	681b      	ldr	r3, [r3, #0]
 801805e:	8f7a      	ldrh	r2, [r7, #58]	@ 0x3a
 8018060:	60da      	str	r2, [r3, #12]
 8018062:	e031      	b.n	80180c8 <UART_SetConfig+0x314>
      }
      else
      {
        ret = HAL_ERROR;
 8018064:	2301      	movs	r3, #1
 8018066:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
 801806a:	e02d      	b.n	80180c8 <UART_SetConfig+0x314>
      }
    }
  }
  else
  {
    pclk = HAL_RCCEx_GetPeriphCLKFreq(clocksource);
 801806c:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801806e:	2200      	movs	r2, #0
 8018070:	469a      	mov	sl, r3
 8018072:	4693      	mov	fp, r2
 8018074:	4650      	mov	r0, sl
 8018076:	4659      	mov	r1, fp
 8018078:	f7fc f8f2 	bl	8014260 <HAL_RCCEx_GetPeriphCLKFreq>
 801807c:	6438      	str	r0, [r7, #64]	@ 0x40

    if (pclk != 0U)
 801807e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8018080:	2b00      	cmp	r3, #0
 8018082:	d021      	beq.n	80180c8 <UART_SetConfig+0x314>
    {
      /* USARTDIV must be greater than or equal to 0d16 */
      usartdiv = (uint32_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8018084:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8018086:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8018088:	4a1a      	ldr	r2, [pc, #104]	@ (80180f4 <UART_SetConfig+0x340>)
 801808a:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 801808e:	461a      	mov	r2, r3
 8018090:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8018092:	fbb3 f2f2 	udiv	r2, r3, r2
 8018096:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8018098:	685b      	ldr	r3, [r3, #4]
 801809a:	085b      	lsrs	r3, r3, #1
 801809c:	441a      	add	r2, r3
 801809e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80180a0:	685b      	ldr	r3, [r3, #4]
 80180a2:	fbb2 f3f3 	udiv	r3, r2, r3
 80180a6:	63fb      	str	r3, [r7, #60]	@ 0x3c
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 80180a8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80180aa:	2b0f      	cmp	r3, #15
 80180ac:	d909      	bls.n	80180c2 <UART_SetConfig+0x30e>
 80180ae:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80180b0:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 80180b4:	d205      	bcs.n	80180c2 <UART_SetConfig+0x30e>
      {
        huart->Instance->BRR = (uint16_t)usartdiv;
 80180b6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80180b8:	b29a      	uxth	r2, r3
 80180ba:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80180bc:	681b      	ldr	r3, [r3, #0]
 80180be:	60da      	str	r2, [r3, #12]
 80180c0:	e002      	b.n	80180c8 <UART_SetConfig+0x314>
      }
      else
      {
        ret = HAL_ERROR;
 80180c2:	2301      	movs	r3, #1
 80180c4:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
      }
    }
  }

  /* Initialize the number of data to process during RX/TX ISR execution */
  huart->NbTxDataToProcess = 1;
 80180c8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80180ca:	2201      	movs	r2, #1
 80180cc:	f8a3 206a 	strh.w	r2, [r3, #106]	@ 0x6a
  huart->NbRxDataToProcess = 1;
 80180d0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80180d2:	2201      	movs	r2, #1
 80180d4:	f8a3 2068 	strh.w	r2, [r3, #104]	@ 0x68

  /* Clear ISR function pointers */
  huart->RxISR = NULL;
 80180d8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80180da:	2200      	movs	r2, #0
 80180dc:	675a      	str	r2, [r3, #116]	@ 0x74
  huart->TxISR = NULL;
 80180de:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80180e0:	2200      	movs	r2, #0
 80180e2:	679a      	str	r2, [r3, #120]	@ 0x78

  return ret;
 80180e4:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
}
 80180e8:	4618      	mov	r0, r3
 80180ea:	3750      	adds	r7, #80	@ 0x50
 80180ec:	46bd      	mov	sp, r7
 80180ee:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 80180f2:	bf00      	nop
 80180f4:	0802a5a0 	.word	0x0802a5a0

080180f8 <UART_AdvFeatureConfig>:
  * @brief Configure the UART peripheral advanced features.
  * @param huart UART handle.
  * @retval None
  */
void UART_AdvFeatureConfig(UART_HandleTypeDef *huart)
{
 80180f8:	b480      	push	{r7}
 80180fa:	b083      	sub	sp, #12
 80180fc:	af00      	add	r7, sp, #0
 80180fe:	6078      	str	r0, [r7, #4]
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure RX/TX pins swap */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 8018100:	687b      	ldr	r3, [r7, #4]
 8018102:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8018104:	f003 0308 	and.w	r3, r3, #8
 8018108:	2b00      	cmp	r3, #0
 801810a:	d00a      	beq.n	8018122 <UART_AdvFeatureConfig+0x2a>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 801810c:	687b      	ldr	r3, [r7, #4]
 801810e:	681b      	ldr	r3, [r3, #0]
 8018110:	685b      	ldr	r3, [r3, #4]
 8018112:	f423 4100 	bic.w	r1, r3, #32768	@ 0x8000
 8018116:	687b      	ldr	r3, [r7, #4]
 8018118:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 801811a:	687b      	ldr	r3, [r7, #4]
 801811c:	681b      	ldr	r3, [r3, #0]
 801811e:	430a      	orrs	r2, r1
 8018120:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure TX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 8018122:	687b      	ldr	r3, [r7, #4]
 8018124:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8018126:	f003 0301 	and.w	r3, r3, #1
 801812a:	2b00      	cmp	r3, #0
 801812c:	d00a      	beq.n	8018144 <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 801812e:	687b      	ldr	r3, [r7, #4]
 8018130:	681b      	ldr	r3, [r3, #0]
 8018132:	685b      	ldr	r3, [r3, #4]
 8018134:	f423 3100 	bic.w	r1, r3, #131072	@ 0x20000
 8018138:	687b      	ldr	r3, [r7, #4]
 801813a:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 801813c:	687b      	ldr	r3, [r7, #4]
 801813e:	681b      	ldr	r3, [r3, #0]
 8018140:	430a      	orrs	r2, r1
 8018142:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 8018144:	687b      	ldr	r3, [r7, #4]
 8018146:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8018148:	f003 0302 	and.w	r3, r3, #2
 801814c:	2b00      	cmp	r3, #0
 801814e:	d00a      	beq.n	8018166 <UART_AdvFeatureConfig+0x6e>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 8018150:	687b      	ldr	r3, [r7, #4]
 8018152:	681b      	ldr	r3, [r3, #0]
 8018154:	685b      	ldr	r3, [r3, #4]
 8018156:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
 801815a:	687b      	ldr	r3, [r7, #4]
 801815c:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 801815e:	687b      	ldr	r3, [r7, #4]
 8018160:	681b      	ldr	r3, [r3, #0]
 8018162:	430a      	orrs	r2, r1
 8018164:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure data inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 8018166:	687b      	ldr	r3, [r7, #4]
 8018168:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 801816a:	f003 0304 	and.w	r3, r3, #4
 801816e:	2b00      	cmp	r3, #0
 8018170:	d00a      	beq.n	8018188 <UART_AdvFeatureConfig+0x90>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 8018172:	687b      	ldr	r3, [r7, #4]
 8018174:	681b      	ldr	r3, [r3, #0]
 8018176:	685b      	ldr	r3, [r3, #4]
 8018178:	f423 2180 	bic.w	r1, r3, #262144	@ 0x40000
 801817c:	687b      	ldr	r3, [r7, #4]
 801817e:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8018180:	687b      	ldr	r3, [r7, #4]
 8018182:	681b      	ldr	r3, [r3, #0]
 8018184:	430a      	orrs	r2, r1
 8018186:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 8018188:	687b      	ldr	r3, [r7, #4]
 801818a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 801818c:	f003 0310 	and.w	r3, r3, #16
 8018190:	2b00      	cmp	r3, #0
 8018192:	d00a      	beq.n	80181aa <UART_AdvFeatureConfig+0xb2>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 8018194:	687b      	ldr	r3, [r7, #4]
 8018196:	681b      	ldr	r3, [r3, #0]
 8018198:	689b      	ldr	r3, [r3, #8]
 801819a:	f423 5180 	bic.w	r1, r3, #4096	@ 0x1000
 801819e:	687b      	ldr	r3, [r7, #4]
 80181a0:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 80181a2:	687b      	ldr	r3, [r7, #4]
 80181a4:	681b      	ldr	r3, [r3, #0]
 80181a6:	430a      	orrs	r2, r1
 80181a8:	609a      	str	r2, [r3, #8]
  }

#if defined(HAL_DMA_MODULE_ENABLED)
  /* if required, configure DMA disabling on reception error */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 80181aa:	687b      	ldr	r3, [r7, #4]
 80181ac:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80181ae:	f003 0320 	and.w	r3, r3, #32
 80181b2:	2b00      	cmp	r3, #0
 80181b4:	d00a      	beq.n	80181cc <UART_AdvFeatureConfig+0xd4>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 80181b6:	687b      	ldr	r3, [r7, #4]
 80181b8:	681b      	ldr	r3, [r3, #0]
 80181ba:	689b      	ldr	r3, [r3, #8]
 80181bc:	f423 5100 	bic.w	r1, r3, #8192	@ 0x2000
 80181c0:	687b      	ldr	r3, [r7, #4]
 80181c2:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
 80181c4:	687b      	ldr	r3, [r7, #4]
 80181c6:	681b      	ldr	r3, [r3, #0]
 80181c8:	430a      	orrs	r2, r1
 80181ca:	609a      	str	r2, [r3, #8]
  }
#endif /* HAL_DMA_MODULE_ENABLED */

  /* if required, configure auto Baud rate detection scheme */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 80181cc:	687b      	ldr	r3, [r7, #4]
 80181ce:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80181d0:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 80181d4:	2b00      	cmp	r3, #0
 80181d6:	d01a      	beq.n	801820e <UART_AdvFeatureConfig+0x116>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 80181d8:	687b      	ldr	r3, [r7, #4]
 80181da:	681b      	ldr	r3, [r3, #0]
 80181dc:	685b      	ldr	r3, [r3, #4]
 80181de:	f423 1180 	bic.w	r1, r3, #1048576	@ 0x100000
 80181e2:	687b      	ldr	r3, [r7, #4]
 80181e4:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 80181e6:	687b      	ldr	r3, [r7, #4]
 80181e8:	681b      	ldr	r3, [r3, #0]
 80181ea:	430a      	orrs	r2, r1
 80181ec:	605a      	str	r2, [r3, #4]
    /* set auto Baudrate detection parameters if detection is enabled */
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 80181ee:	687b      	ldr	r3, [r7, #4]
 80181f0:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 80181f2:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 80181f6:	d10a      	bne.n	801820e <UART_AdvFeatureConfig+0x116>
    {
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 80181f8:	687b      	ldr	r3, [r7, #4]
 80181fa:	681b      	ldr	r3, [r3, #0]
 80181fc:	685b      	ldr	r3, [r3, #4]
 80181fe:	f423 01c0 	bic.w	r1, r3, #6291456	@ 0x600000
 8018202:	687b      	ldr	r3, [r7, #4]
 8018204:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
 8018206:	687b      	ldr	r3, [r7, #4]
 8018208:	681b      	ldr	r3, [r3, #0]
 801820a:	430a      	orrs	r2, r1
 801820c:	605a      	str	r2, [r3, #4]
    }
  }

  /* if required, configure MSB first on communication line */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 801820e:	687b      	ldr	r3, [r7, #4]
 8018210:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8018212:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8018216:	2b00      	cmp	r3, #0
 8018218:	d00a      	beq.n	8018230 <UART_AdvFeatureConfig+0x138>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 801821a:	687b      	ldr	r3, [r7, #4]
 801821c:	681b      	ldr	r3, [r3, #0]
 801821e:	685b      	ldr	r3, [r3, #4]
 8018220:	f423 2100 	bic.w	r1, r3, #524288	@ 0x80000
 8018224:	687b      	ldr	r3, [r7, #4]
 8018226:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8018228:	687b      	ldr	r3, [r7, #4]
 801822a:	681b      	ldr	r3, [r3, #0]
 801822c:	430a      	orrs	r2, r1
 801822e:	605a      	str	r2, [r3, #4]
  }
}
 8018230:	bf00      	nop
 8018232:	370c      	adds	r7, #12
 8018234:	46bd      	mov	sp, r7
 8018236:	f85d 7b04 	ldr.w	r7, [sp], #4
 801823a:	4770      	bx	lr

0801823c <UART_CheckIdleState>:
  * @brief Check the UART Idle State.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
{
 801823c:	b580      	push	{r7, lr}
 801823e:	b098      	sub	sp, #96	@ 0x60
 8018240:	af02      	add	r7, sp, #8
 8018242:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Initialize the UART ErrorCode */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8018244:	687b      	ldr	r3, [r7, #4]
 8018246:	2200      	movs	r2, #0
 8018248:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90

  /* Init tickstart for timeout management */
  tickstart = HAL_GetTick();
 801824c:	f7f5 fc08 	bl	800da60 <HAL_GetTick>
 8018250:	6578      	str	r0, [r7, #84]	@ 0x54

  /* Check if the Transmitter is enabled */
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 8018252:	687b      	ldr	r3, [r7, #4]
 8018254:	681b      	ldr	r3, [r3, #0]
 8018256:	681b      	ldr	r3, [r3, #0]
 8018258:	f003 0308 	and.w	r3, r3, #8
 801825c:	2b08      	cmp	r3, #8
 801825e:	d12f      	bne.n	80182c0 <UART_CheckIdleState+0x84>
  {
    /* Wait until TEACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8018260:	f06f 437e 	mvn.w	r3, #4261412864	@ 0xfe000000
 8018264:	9300      	str	r3, [sp, #0]
 8018266:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8018268:	2200      	movs	r2, #0
 801826a:	f44f 1100 	mov.w	r1, #2097152	@ 0x200000
 801826e:	6878      	ldr	r0, [r7, #4]
 8018270:	f000 f88e 	bl	8018390 <UART_WaitOnFlagUntilTimeout>
 8018274:	4603      	mov	r3, r0
 8018276:	2b00      	cmp	r3, #0
 8018278:	d022      	beq.n	80182c0 <UART_CheckIdleState+0x84>
    {
      /* Disable TXE interrupt for the interrupt process */
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE_TXFNFIE));
 801827a:	687b      	ldr	r3, [r7, #4]
 801827c:	681b      	ldr	r3, [r3, #0]
 801827e:	63bb      	str	r3, [r7, #56]	@ 0x38
 */
__STATIC_FORCEINLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8018280:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8018282:	e853 3f00 	ldrex	r3, [r3]
 8018286:	637b      	str	r3, [r7, #52]	@ 0x34
   return(result);
 8018288:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801828a:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 801828e:	653b      	str	r3, [r7, #80]	@ 0x50
 8018290:	687b      	ldr	r3, [r7, #4]
 8018292:	681b      	ldr	r3, [r3, #0]
 8018294:	461a      	mov	r2, r3
 8018296:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8018298:	647b      	str	r3, [r7, #68]	@ 0x44
 801829a:	643a      	str	r2, [r7, #64]	@ 0x40
 */
__STATIC_FORCEINLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 801829c:	6c39      	ldr	r1, [r7, #64]	@ 0x40
 801829e:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 80182a0:	e841 2300 	strex	r3, r2, [r1]
 80182a4:	63fb      	str	r3, [r7, #60]	@ 0x3c
   return(result);
 80182a6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80182a8:	2b00      	cmp	r3, #0
 80182aa:	d1e6      	bne.n	801827a <UART_CheckIdleState+0x3e>

      huart->gState = HAL_UART_STATE_READY;
 80182ac:	687b      	ldr	r3, [r7, #4]
 80182ae:	2220      	movs	r2, #32
 80182b0:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

      __HAL_UNLOCK(huart);
 80182b4:	687b      	ldr	r3, [r7, #4]
 80182b6:	2200      	movs	r2, #0
 80182b8:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

      /* Timeout occurred */
      return HAL_TIMEOUT;
 80182bc:	2303      	movs	r3, #3
 80182be:	e063      	b.n	8018388 <UART_CheckIdleState+0x14c>
    }
  }

  /* Check if the Receiver is enabled */
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 80182c0:	687b      	ldr	r3, [r7, #4]
 80182c2:	681b      	ldr	r3, [r3, #0]
 80182c4:	681b      	ldr	r3, [r3, #0]
 80182c6:	f003 0304 	and.w	r3, r3, #4
 80182ca:	2b04      	cmp	r3, #4
 80182cc:	d149      	bne.n	8018362 <UART_CheckIdleState+0x126>
  {
    /* Wait until REACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 80182ce:	f06f 437e 	mvn.w	r3, #4261412864	@ 0xfe000000
 80182d2:	9300      	str	r3, [sp, #0]
 80182d4:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80182d6:	2200      	movs	r2, #0
 80182d8:	f44f 0180 	mov.w	r1, #4194304	@ 0x400000
 80182dc:	6878      	ldr	r0, [r7, #4]
 80182de:	f000 f857 	bl	8018390 <UART_WaitOnFlagUntilTimeout>
 80182e2:	4603      	mov	r3, r0
 80182e4:	2b00      	cmp	r3, #0
 80182e6:	d03c      	beq.n	8018362 <UART_CheckIdleState+0x126>
    {
      /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error)
      interrupts for the interrupt process */
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 80182e8:	687b      	ldr	r3, [r7, #4]
 80182ea:	681b      	ldr	r3, [r3, #0]
 80182ec:	627b      	str	r3, [r7, #36]	@ 0x24
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80182ee:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80182f0:	e853 3f00 	ldrex	r3, [r3]
 80182f4:	623b      	str	r3, [r7, #32]
   return(result);
 80182f6:	6a3b      	ldr	r3, [r7, #32]
 80182f8:	f423 7390 	bic.w	r3, r3, #288	@ 0x120
 80182fc:	64fb      	str	r3, [r7, #76]	@ 0x4c
 80182fe:	687b      	ldr	r3, [r7, #4]
 8018300:	681b      	ldr	r3, [r3, #0]
 8018302:	461a      	mov	r2, r3
 8018304:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8018306:	633b      	str	r3, [r7, #48]	@ 0x30
 8018308:	62fa      	str	r2, [r7, #44]	@ 0x2c
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 801830a:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 801830c:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801830e:	e841 2300 	strex	r3, r2, [r1]
 8018312:	62bb      	str	r3, [r7, #40]	@ 0x28
   return(result);
 8018314:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8018316:	2b00      	cmp	r3, #0
 8018318:	d1e6      	bne.n	80182e8 <UART_CheckIdleState+0xac>
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 801831a:	687b      	ldr	r3, [r7, #4]
 801831c:	681b      	ldr	r3, [r3, #0]
 801831e:	3308      	adds	r3, #8
 8018320:	613b      	str	r3, [r7, #16]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8018322:	693b      	ldr	r3, [r7, #16]
 8018324:	e853 3f00 	ldrex	r3, [r3]
 8018328:	60fb      	str	r3, [r7, #12]
   return(result);
 801832a:	68fb      	ldr	r3, [r7, #12]
 801832c:	f023 0301 	bic.w	r3, r3, #1
 8018330:	64bb      	str	r3, [r7, #72]	@ 0x48
 8018332:	687b      	ldr	r3, [r7, #4]
 8018334:	681b      	ldr	r3, [r3, #0]
 8018336:	3308      	adds	r3, #8
 8018338:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 801833a:	61fa      	str	r2, [r7, #28]
 801833c:	61bb      	str	r3, [r7, #24]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 801833e:	69b9      	ldr	r1, [r7, #24]
 8018340:	69fa      	ldr	r2, [r7, #28]
 8018342:	e841 2300 	strex	r3, r2, [r1]
 8018346:	617b      	str	r3, [r7, #20]
   return(result);
 8018348:	697b      	ldr	r3, [r7, #20]
 801834a:	2b00      	cmp	r3, #0
 801834c:	d1e5      	bne.n	801831a <UART_CheckIdleState+0xde>

      huart->RxState = HAL_UART_STATE_READY;
 801834e:	687b      	ldr	r3, [r7, #4]
 8018350:	2220      	movs	r2, #32
 8018352:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c

      __HAL_UNLOCK(huart);
 8018356:	687b      	ldr	r3, [r7, #4]
 8018358:	2200      	movs	r2, #0
 801835a:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

      /* Timeout occurred */
      return HAL_TIMEOUT;
 801835e:	2303      	movs	r3, #3
 8018360:	e012      	b.n	8018388 <UART_CheckIdleState+0x14c>
    }
  }

  /* Initialize the UART State */
  huart->gState = HAL_UART_STATE_READY;
 8018362:	687b      	ldr	r3, [r7, #4]
 8018364:	2220      	movs	r2, #32
 8018366:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
  huart->RxState = HAL_UART_STATE_READY;
 801836a:	687b      	ldr	r3, [r7, #4]
 801836c:	2220      	movs	r2, #32
 801836e:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8018372:	687b      	ldr	r3, [r7, #4]
 8018374:	2200      	movs	r2, #0
 8018376:	66da      	str	r2, [r3, #108]	@ 0x6c
  huart->RxEventType = HAL_UART_RXEVENT_TC;
 8018378:	687b      	ldr	r3, [r7, #4]
 801837a:	2200      	movs	r2, #0
 801837c:	671a      	str	r2, [r3, #112]	@ 0x70

  __HAL_UNLOCK(huart);
 801837e:	687b      	ldr	r3, [r7, #4]
 8018380:	2200      	movs	r2, #0
 8018382:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

  return HAL_OK;
 8018386:	2300      	movs	r3, #0
}
 8018388:	4618      	mov	r0, r3
 801838a:	3758      	adds	r7, #88	@ 0x58
 801838c:	46bd      	mov	sp, r7
 801838e:	bd80      	pop	{r7, pc}

08018390 <UART_WaitOnFlagUntilTimeout>:
  * @param Timeout   Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,
                                              uint32_t Tickstart, uint32_t Timeout)
{
 8018390:	b580      	push	{r7, lr}
 8018392:	b084      	sub	sp, #16
 8018394:	af00      	add	r7, sp, #0
 8018396:	60f8      	str	r0, [r7, #12]
 8018398:	60b9      	str	r1, [r7, #8]
 801839a:	603b      	str	r3, [r7, #0]
 801839c:	4613      	mov	r3, r2
 801839e:	71fb      	strb	r3, [r7, #7]
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 80183a0:	e04f      	b.n	8018442 <UART_WaitOnFlagUntilTimeout+0xb2>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 80183a2:	69bb      	ldr	r3, [r7, #24]
 80183a4:	f1b3 3fff 	cmp.w	r3, #4294967295
 80183a8:	d04b      	beq.n	8018442 <UART_WaitOnFlagUntilTimeout+0xb2>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 80183aa:	f7f5 fb59 	bl	800da60 <HAL_GetTick>
 80183ae:	4602      	mov	r2, r0
 80183b0:	683b      	ldr	r3, [r7, #0]
 80183b2:	1ad3      	subs	r3, r2, r3
 80183b4:	69ba      	ldr	r2, [r7, #24]
 80183b6:	429a      	cmp	r2, r3
 80183b8:	d302      	bcc.n	80183c0 <UART_WaitOnFlagUntilTimeout+0x30>
 80183ba:	69bb      	ldr	r3, [r7, #24]
 80183bc:	2b00      	cmp	r3, #0
 80183be:	d101      	bne.n	80183c4 <UART_WaitOnFlagUntilTimeout+0x34>
      {

        return HAL_TIMEOUT;
 80183c0:	2303      	movs	r3, #3
 80183c2:	e04e      	b.n	8018462 <UART_WaitOnFlagUntilTimeout+0xd2>
      }

      if ((READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U) && (Flag != UART_FLAG_TXE) && (Flag != UART_FLAG_TC))
 80183c4:	68fb      	ldr	r3, [r7, #12]
 80183c6:	681b      	ldr	r3, [r3, #0]
 80183c8:	681b      	ldr	r3, [r3, #0]
 80183ca:	f003 0304 	and.w	r3, r3, #4
 80183ce:	2b00      	cmp	r3, #0
 80183d0:	d037      	beq.n	8018442 <UART_WaitOnFlagUntilTimeout+0xb2>
 80183d2:	68bb      	ldr	r3, [r7, #8]
 80183d4:	2b80      	cmp	r3, #128	@ 0x80
 80183d6:	d034      	beq.n	8018442 <UART_WaitOnFlagUntilTimeout+0xb2>
 80183d8:	68bb      	ldr	r3, [r7, #8]
 80183da:	2b40      	cmp	r3, #64	@ 0x40
 80183dc:	d031      	beq.n	8018442 <UART_WaitOnFlagUntilTimeout+0xb2>
      {
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_ORE) == SET)
 80183de:	68fb      	ldr	r3, [r7, #12]
 80183e0:	681b      	ldr	r3, [r3, #0]
 80183e2:	69db      	ldr	r3, [r3, #28]
 80183e4:	f003 0308 	and.w	r3, r3, #8
 80183e8:	2b08      	cmp	r3, #8
 80183ea:	d110      	bne.n	801840e <UART_WaitOnFlagUntilTimeout+0x7e>
        {
          /* Clear Overrun Error flag*/
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
 80183ec:	68fb      	ldr	r3, [r7, #12]
 80183ee:	681b      	ldr	r3, [r3, #0]
 80183f0:	2208      	movs	r2, #8
 80183f2:	621a      	str	r2, [r3, #32]

          /* Blocking error : transfer is aborted
          Set the UART state ready to be able to start again the process,
          Disable Rx Interrupts if ongoing */
          UART_EndRxTransfer(huart);
 80183f4:	68f8      	ldr	r0, [r7, #12]
 80183f6:	f000 f838 	bl	801846a <UART_EndRxTransfer>

          huart->ErrorCode = HAL_UART_ERROR_ORE;
 80183fa:	68fb      	ldr	r3, [r7, #12]
 80183fc:	2208      	movs	r2, #8
 80183fe:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90

          /* Process Unlocked */
          __HAL_UNLOCK(huart);
 8018402:	68fb      	ldr	r3, [r7, #12]
 8018404:	2200      	movs	r2, #0
 8018406:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

          return HAL_ERROR;
 801840a:	2301      	movs	r3, #1
 801840c:	e029      	b.n	8018462 <UART_WaitOnFlagUntilTimeout+0xd2>
        }
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 801840e:	68fb      	ldr	r3, [r7, #12]
 8018410:	681b      	ldr	r3, [r3, #0]
 8018412:	69db      	ldr	r3, [r3, #28]
 8018414:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 8018418:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 801841c:	d111      	bne.n	8018442 <UART_WaitOnFlagUntilTimeout+0xb2>
        {
          /* Clear Receiver Timeout flag*/
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 801841e:	68fb      	ldr	r3, [r7, #12]
 8018420:	681b      	ldr	r3, [r3, #0]
 8018422:	f44f 6200 	mov.w	r2, #2048	@ 0x800
 8018426:	621a      	str	r2, [r3, #32]

          /* Blocking error : transfer is aborted
          Set the UART state ready to be able to start again the process,
          Disable Rx Interrupts if ongoing */
          UART_EndRxTransfer(huart);
 8018428:	68f8      	ldr	r0, [r7, #12]
 801842a:	f000 f81e 	bl	801846a <UART_EndRxTransfer>

          huart->ErrorCode = HAL_UART_ERROR_RTO;
 801842e:	68fb      	ldr	r3, [r7, #12]
 8018430:	2220      	movs	r2, #32
 8018432:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90

          /* Process Unlocked */
          __HAL_UNLOCK(huart);
 8018436:	68fb      	ldr	r3, [r7, #12]
 8018438:	2200      	movs	r2, #0
 801843a:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

          return HAL_TIMEOUT;
 801843e:	2303      	movs	r3, #3
 8018440:	e00f      	b.n	8018462 <UART_WaitOnFlagUntilTimeout+0xd2>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8018442:	68fb      	ldr	r3, [r7, #12]
 8018444:	681b      	ldr	r3, [r3, #0]
 8018446:	69da      	ldr	r2, [r3, #28]
 8018448:	68bb      	ldr	r3, [r7, #8]
 801844a:	4013      	ands	r3, r2
 801844c:	68ba      	ldr	r2, [r7, #8]
 801844e:	429a      	cmp	r2, r3
 8018450:	bf0c      	ite	eq
 8018452:	2301      	moveq	r3, #1
 8018454:	2300      	movne	r3, #0
 8018456:	b2db      	uxtb	r3, r3
 8018458:	461a      	mov	r2, r3
 801845a:	79fb      	ldrb	r3, [r7, #7]
 801845c:	429a      	cmp	r2, r3
 801845e:	d0a0      	beq.n	80183a2 <UART_WaitOnFlagUntilTimeout+0x12>
        }
      }
    }
  }
  return HAL_OK;
 8018460:	2300      	movs	r3, #0
}
 8018462:	4618      	mov	r0, r3
 8018464:	3710      	adds	r7, #16
 8018466:	46bd      	mov	sp, r7
 8018468:	bd80      	pop	{r7, pc}

0801846a <UART_EndRxTransfer>:
  * @brief  End ongoing Rx transfer on UART peripheral (following error detection or Reception completion).
  * @param  huart UART handle.
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
 801846a:	b480      	push	{r7}
 801846c:	b095      	sub	sp, #84	@ 0x54
 801846e:	af00      	add	r7, sp, #0
 8018470:	6078      	str	r0, [r7, #4]
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 8018472:	687b      	ldr	r3, [r7, #4]
 8018474:	681b      	ldr	r3, [r3, #0]
 8018476:	637b      	str	r3, [r7, #52]	@ 0x34
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8018478:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801847a:	e853 3f00 	ldrex	r3, [r3]
 801847e:	633b      	str	r3, [r7, #48]	@ 0x30
   return(result);
 8018480:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8018482:	f423 7390 	bic.w	r3, r3, #288	@ 0x120
 8018486:	64fb      	str	r3, [r7, #76]	@ 0x4c
 8018488:	687b      	ldr	r3, [r7, #4]
 801848a:	681b      	ldr	r3, [r3, #0]
 801848c:	461a      	mov	r2, r3
 801848e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8018490:	643b      	str	r3, [r7, #64]	@ 0x40
 8018492:	63fa      	str	r2, [r7, #60]	@ 0x3c
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8018494:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
 8018496:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8018498:	e841 2300 	strex	r3, r2, [r1]
 801849c:	63bb      	str	r3, [r7, #56]	@ 0x38
   return(result);
 801849e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80184a0:	2b00      	cmp	r3, #0
 80184a2:	d1e6      	bne.n	8018472 <UART_EndRxTransfer+0x8>
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 80184a4:	687b      	ldr	r3, [r7, #4]
 80184a6:	681b      	ldr	r3, [r3, #0]
 80184a8:	3308      	adds	r3, #8
 80184aa:	623b      	str	r3, [r7, #32]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80184ac:	6a3b      	ldr	r3, [r7, #32]
 80184ae:	e853 3f00 	ldrex	r3, [r3]
 80184b2:	61fb      	str	r3, [r7, #28]
   return(result);
 80184b4:	69fb      	ldr	r3, [r7, #28]
 80184b6:	f023 5380 	bic.w	r3, r3, #268435456	@ 0x10000000
 80184ba:	f023 0301 	bic.w	r3, r3, #1
 80184be:	64bb      	str	r3, [r7, #72]	@ 0x48
 80184c0:	687b      	ldr	r3, [r7, #4]
 80184c2:	681b      	ldr	r3, [r3, #0]
 80184c4:	3308      	adds	r3, #8
 80184c6:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 80184c8:	62fa      	str	r2, [r7, #44]	@ 0x2c
 80184ca:	62bb      	str	r3, [r7, #40]	@ 0x28
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80184cc:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 80184ce:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80184d0:	e841 2300 	strex	r3, r2, [r1]
 80184d4:	627b      	str	r3, [r7, #36]	@ 0x24
   return(result);
 80184d6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80184d8:	2b00      	cmp	r3, #0
 80184da:	d1e3      	bne.n	80184a4 <UART_EndRxTransfer+0x3a>

  /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 80184dc:	687b      	ldr	r3, [r7, #4]
 80184de:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 80184e0:	2b01      	cmp	r3, #1
 80184e2:	d118      	bne.n	8018516 <UART_EndRxTransfer+0xac>
  {
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 80184e4:	687b      	ldr	r3, [r7, #4]
 80184e6:	681b      	ldr	r3, [r3, #0]
 80184e8:	60fb      	str	r3, [r7, #12]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80184ea:	68fb      	ldr	r3, [r7, #12]
 80184ec:	e853 3f00 	ldrex	r3, [r3]
 80184f0:	60bb      	str	r3, [r7, #8]
   return(result);
 80184f2:	68bb      	ldr	r3, [r7, #8]
 80184f4:	f023 0310 	bic.w	r3, r3, #16
 80184f8:	647b      	str	r3, [r7, #68]	@ 0x44
 80184fa:	687b      	ldr	r3, [r7, #4]
 80184fc:	681b      	ldr	r3, [r3, #0]
 80184fe:	461a      	mov	r2, r3
 8018500:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8018502:	61bb      	str	r3, [r7, #24]
 8018504:	617a      	str	r2, [r7, #20]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8018506:	6979      	ldr	r1, [r7, #20]
 8018508:	69ba      	ldr	r2, [r7, #24]
 801850a:	e841 2300 	strex	r3, r2, [r1]
 801850e:	613b      	str	r3, [r7, #16]
   return(result);
 8018510:	693b      	ldr	r3, [r7, #16]
 8018512:	2b00      	cmp	r3, #0
 8018514:	d1e6      	bne.n	80184e4 <UART_EndRxTransfer+0x7a>
  }

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
 8018516:	687b      	ldr	r3, [r7, #4]
 8018518:	2220      	movs	r2, #32
 801851a:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 801851e:	687b      	ldr	r3, [r7, #4]
 8018520:	2200      	movs	r2, #0
 8018522:	66da      	str	r2, [r3, #108]	@ 0x6c

  /* Reset RxIsr function pointer */
  huart->RxISR = NULL;
 8018524:	687b      	ldr	r3, [r7, #4]
 8018526:	2200      	movs	r2, #0
 8018528:	675a      	str	r2, [r3, #116]	@ 0x74
}
 801852a:	bf00      	nop
 801852c:	3754      	adds	r7, #84	@ 0x54
 801852e:	46bd      	mov	sp, r7
 8018530:	f85d 7b04 	ldr.w	r7, [sp], #4
 8018534:	4770      	bx	lr

08018536 <HAL_UARTEx_DisableFifoMode>:
  * @brief  Disable the FIFO mode.
  * @param huart      UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UARTEx_DisableFifoMode(UART_HandleTypeDef *huart)
{
 8018536:	b480      	push	{r7}
 8018538:	b085      	sub	sp, #20
 801853a:	af00      	add	r7, sp, #0
 801853c:	6078      	str	r0, [r7, #4]

  /* Check parameters */
  assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));

  /* Process Locked */
  __HAL_LOCK(huart);
 801853e:	687b      	ldr	r3, [r7, #4]
 8018540:	f893 3084 	ldrb.w	r3, [r3, #132]	@ 0x84
 8018544:	2b01      	cmp	r3, #1
 8018546:	d101      	bne.n	801854c <HAL_UARTEx_DisableFifoMode+0x16>
 8018548:	2302      	movs	r3, #2
 801854a:	e027      	b.n	801859c <HAL_UARTEx_DisableFifoMode+0x66>
 801854c:	687b      	ldr	r3, [r7, #4]
 801854e:	2201      	movs	r2, #1
 8018550:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

  huart->gState = HAL_UART_STATE_BUSY;
 8018554:	687b      	ldr	r3, [r7, #4]
 8018556:	2224      	movs	r2, #36	@ 0x24
 8018558:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

  /* Save actual UART configuration */
  tmpcr1 = READ_REG(huart->Instance->CR1);
 801855c:	687b      	ldr	r3, [r7, #4]
 801855e:	681b      	ldr	r3, [r3, #0]
 8018560:	681b      	ldr	r3, [r3, #0]
 8018562:	60fb      	str	r3, [r7, #12]

  /* Disable UART */
  __HAL_UART_DISABLE(huart);
 8018564:	687b      	ldr	r3, [r7, #4]
 8018566:	681b      	ldr	r3, [r3, #0]
 8018568:	681a      	ldr	r2, [r3, #0]
 801856a:	687b      	ldr	r3, [r7, #4]
 801856c:	681b      	ldr	r3, [r3, #0]
 801856e:	f022 0201 	bic.w	r2, r2, #1
 8018572:	601a      	str	r2, [r3, #0]

  /* Enable FIFO mode */
  CLEAR_BIT(tmpcr1, USART_CR1_FIFOEN);
 8018574:	68fb      	ldr	r3, [r7, #12]
 8018576:	f023 5300 	bic.w	r3, r3, #536870912	@ 0x20000000
 801857a:	60fb      	str	r3, [r7, #12]
  huart->FifoMode = UART_FIFOMODE_DISABLE;
 801857c:	687b      	ldr	r3, [r7, #4]
 801857e:	2200      	movs	r2, #0
 8018580:	665a      	str	r2, [r3, #100]	@ 0x64

  /* Restore UART configuration */
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 8018582:	687b      	ldr	r3, [r7, #4]
 8018584:	681b      	ldr	r3, [r3, #0]
 8018586:	68fa      	ldr	r2, [r7, #12]
 8018588:	601a      	str	r2, [r3, #0]

  huart->gState = HAL_UART_STATE_READY;
 801858a:	687b      	ldr	r3, [r7, #4]
 801858c:	2220      	movs	r2, #32
 801858e:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
 8018592:	687b      	ldr	r3, [r7, #4]
 8018594:	2200      	movs	r2, #0
 8018596:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

  return HAL_OK;
 801859a:	2300      	movs	r3, #0
}
 801859c:	4618      	mov	r0, r3
 801859e:	3714      	adds	r7, #20
 80185a0:	46bd      	mov	sp, r7
 80185a2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80185a6:	4770      	bx	lr

080185a8 <HAL_UARTEx_SetTxFifoThreshold>:
  *            @arg @ref UART_TXFIFO_THRESHOLD_7_8
  *            @arg @ref UART_TXFIFO_THRESHOLD_8_8
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UARTEx_SetTxFifoThreshold(UART_HandleTypeDef *huart, uint32_t Threshold)
{
 80185a8:	b580      	push	{r7, lr}
 80185aa:	b084      	sub	sp, #16
 80185ac:	af00      	add	r7, sp, #0
 80185ae:	6078      	str	r0, [r7, #4]
 80185b0:	6039      	str	r1, [r7, #0]
  /* Check parameters */
  assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));
  assert_param(IS_UART_TXFIFO_THRESHOLD(Threshold));

  /* Process Locked */
  __HAL_LOCK(huart);
 80185b2:	687b      	ldr	r3, [r7, #4]
 80185b4:	f893 3084 	ldrb.w	r3, [r3, #132]	@ 0x84
 80185b8:	2b01      	cmp	r3, #1
 80185ba:	d101      	bne.n	80185c0 <HAL_UARTEx_SetTxFifoThreshold+0x18>
 80185bc:	2302      	movs	r3, #2
 80185be:	e02d      	b.n	801861c <HAL_UARTEx_SetTxFifoThreshold+0x74>
 80185c0:	687b      	ldr	r3, [r7, #4]
 80185c2:	2201      	movs	r2, #1
 80185c4:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

  huart->gState = HAL_UART_STATE_BUSY;
 80185c8:	687b      	ldr	r3, [r7, #4]
 80185ca:	2224      	movs	r2, #36	@ 0x24
 80185cc:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

  /* Save actual UART configuration */
  tmpcr1 = READ_REG(huart->Instance->CR1);
 80185d0:	687b      	ldr	r3, [r7, #4]
 80185d2:	681b      	ldr	r3, [r3, #0]
 80185d4:	681b      	ldr	r3, [r3, #0]
 80185d6:	60fb      	str	r3, [r7, #12]

  /* Disable UART */
  __HAL_UART_DISABLE(huart);
 80185d8:	687b      	ldr	r3, [r7, #4]
 80185da:	681b      	ldr	r3, [r3, #0]
 80185dc:	681a      	ldr	r2, [r3, #0]
 80185de:	687b      	ldr	r3, [r7, #4]
 80185e0:	681b      	ldr	r3, [r3, #0]
 80185e2:	f022 0201 	bic.w	r2, r2, #1
 80185e6:	601a      	str	r2, [r3, #0]

  /* Update TX threshold configuration */
  MODIFY_REG(huart->Instance->CR3, USART_CR3_TXFTCFG, Threshold);
 80185e8:	687b      	ldr	r3, [r7, #4]
 80185ea:	681b      	ldr	r3, [r3, #0]
 80185ec:	689b      	ldr	r3, [r3, #8]
 80185ee:	f023 4160 	bic.w	r1, r3, #3758096384	@ 0xe0000000
 80185f2:	687b      	ldr	r3, [r7, #4]
 80185f4:	681b      	ldr	r3, [r3, #0]
 80185f6:	683a      	ldr	r2, [r7, #0]
 80185f8:	430a      	orrs	r2, r1
 80185fa:	609a      	str	r2, [r3, #8]

  /* Determine the number of data to process during RX/TX ISR execution */
  UARTEx_SetNbDataToProcess(huart);
 80185fc:	6878      	ldr	r0, [r7, #4]
 80185fe:	f000 f84f 	bl	80186a0 <UARTEx_SetNbDataToProcess>

  /* Restore UART configuration */
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 8018602:	687b      	ldr	r3, [r7, #4]
 8018604:	681b      	ldr	r3, [r3, #0]
 8018606:	68fa      	ldr	r2, [r7, #12]
 8018608:	601a      	str	r2, [r3, #0]

  huart->gState = HAL_UART_STATE_READY;
 801860a:	687b      	ldr	r3, [r7, #4]
 801860c:	2220      	movs	r2, #32
 801860e:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
 8018612:	687b      	ldr	r3, [r7, #4]
 8018614:	2200      	movs	r2, #0
 8018616:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

  return HAL_OK;
 801861a:	2300      	movs	r3, #0
}
 801861c:	4618      	mov	r0, r3
 801861e:	3710      	adds	r7, #16
 8018620:	46bd      	mov	sp, r7
 8018622:	bd80      	pop	{r7, pc}

08018624 <HAL_UARTEx_SetRxFifoThreshold>:
  *            @arg @ref UART_RXFIFO_THRESHOLD_7_8
  *            @arg @ref UART_RXFIFO_THRESHOLD_8_8
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UARTEx_SetRxFifoThreshold(UART_HandleTypeDef *huart, uint32_t Threshold)
{
 8018624:	b580      	push	{r7, lr}
 8018626:	b084      	sub	sp, #16
 8018628:	af00      	add	r7, sp, #0
 801862a:	6078      	str	r0, [r7, #4]
 801862c:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));
  assert_param(IS_UART_RXFIFO_THRESHOLD(Threshold));

  /* Process Locked */
  __HAL_LOCK(huart);
 801862e:	687b      	ldr	r3, [r7, #4]
 8018630:	f893 3084 	ldrb.w	r3, [r3, #132]	@ 0x84
 8018634:	2b01      	cmp	r3, #1
 8018636:	d101      	bne.n	801863c <HAL_UARTEx_SetRxFifoThreshold+0x18>
 8018638:	2302      	movs	r3, #2
 801863a:	e02d      	b.n	8018698 <HAL_UARTEx_SetRxFifoThreshold+0x74>
 801863c:	687b      	ldr	r3, [r7, #4]
 801863e:	2201      	movs	r2, #1
 8018640:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

  huart->gState = HAL_UART_STATE_BUSY;
 8018644:	687b      	ldr	r3, [r7, #4]
 8018646:	2224      	movs	r2, #36	@ 0x24
 8018648:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

  /* Save actual UART configuration */
  tmpcr1 = READ_REG(huart->Instance->CR1);
 801864c:	687b      	ldr	r3, [r7, #4]
 801864e:	681b      	ldr	r3, [r3, #0]
 8018650:	681b      	ldr	r3, [r3, #0]
 8018652:	60fb      	str	r3, [r7, #12]

  /* Disable UART */
  __HAL_UART_DISABLE(huart);
 8018654:	687b      	ldr	r3, [r7, #4]
 8018656:	681b      	ldr	r3, [r3, #0]
 8018658:	681a      	ldr	r2, [r3, #0]
 801865a:	687b      	ldr	r3, [r7, #4]
 801865c:	681b      	ldr	r3, [r3, #0]
 801865e:	f022 0201 	bic.w	r2, r2, #1
 8018662:	601a      	str	r2, [r3, #0]

  /* Update RX threshold configuration */
  MODIFY_REG(huart->Instance->CR3, USART_CR3_RXFTCFG, Threshold);
 8018664:	687b      	ldr	r3, [r7, #4]
 8018666:	681b      	ldr	r3, [r3, #0]
 8018668:	689b      	ldr	r3, [r3, #8]
 801866a:	f023 6160 	bic.w	r1, r3, #234881024	@ 0xe000000
 801866e:	687b      	ldr	r3, [r7, #4]
 8018670:	681b      	ldr	r3, [r3, #0]
 8018672:	683a      	ldr	r2, [r7, #0]
 8018674:	430a      	orrs	r2, r1
 8018676:	609a      	str	r2, [r3, #8]

  /* Determine the number of data to process during RX/TX ISR execution */
  UARTEx_SetNbDataToProcess(huart);
 8018678:	6878      	ldr	r0, [r7, #4]
 801867a:	f000 f811 	bl	80186a0 <UARTEx_SetNbDataToProcess>

  /* Restore UART configuration */
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 801867e:	687b      	ldr	r3, [r7, #4]
 8018680:	681b      	ldr	r3, [r3, #0]
 8018682:	68fa      	ldr	r2, [r7, #12]
 8018684:	601a      	str	r2, [r3, #0]

  huart->gState = HAL_UART_STATE_READY;
 8018686:	687b      	ldr	r3, [r7, #4]
 8018688:	2220      	movs	r2, #32
 801868a:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
 801868e:	687b      	ldr	r3, [r7, #4]
 8018690:	2200      	movs	r2, #0
 8018692:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

  return HAL_OK;
 8018696:	2300      	movs	r3, #0
}
 8018698:	4618      	mov	r0, r3
 801869a:	3710      	adds	r7, #16
 801869c:	46bd      	mov	sp, r7
 801869e:	bd80      	pop	{r7, pc}

080186a0 <UARTEx_SetNbDataToProcess>:
  *       the UART configuration registers.
  * @param huart UART handle.
  * @retval None
  */
static void UARTEx_SetNbDataToProcess(UART_HandleTypeDef *huart)
{
 80186a0:	b480      	push	{r7}
 80186a2:	b085      	sub	sp, #20
 80186a4:	af00      	add	r7, sp, #0
 80186a6:	6078      	str	r0, [r7, #4]
  uint8_t rx_fifo_threshold;
  uint8_t tx_fifo_threshold;
  static const uint8_t numerator[] = {1U, 1U, 1U, 3U, 7U, 1U, 0U, 0U};
  static const uint8_t denominator[] = {8U, 4U, 2U, 4U, 8U, 1U, 1U, 1U};

  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
 80186a8:	687b      	ldr	r3, [r7, #4]
 80186aa:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 80186ac:	2b00      	cmp	r3, #0
 80186ae:	d108      	bne.n	80186c2 <UARTEx_SetNbDataToProcess+0x22>
  {
    huart->NbTxDataToProcess = 1U;
 80186b0:	687b      	ldr	r3, [r7, #4]
 80186b2:	2201      	movs	r2, #1
 80186b4:	f8a3 206a 	strh.w	r2, [r3, #106]	@ 0x6a
    huart->NbRxDataToProcess = 1U;
 80186b8:	687b      	ldr	r3, [r7, #4]
 80186ba:	2201      	movs	r2, #1
 80186bc:	f8a3 2068 	strh.w	r2, [r3, #104]	@ 0x68
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
                               (uint16_t)denominator[tx_fifo_threshold];
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
                               (uint16_t)denominator[rx_fifo_threshold];
  }
}
 80186c0:	e031      	b.n	8018726 <UARTEx_SetNbDataToProcess+0x86>
    rx_fifo_depth = RX_FIFO_DEPTH;
 80186c2:	2308      	movs	r3, #8
 80186c4:	73fb      	strb	r3, [r7, #15]
    tx_fifo_depth = TX_FIFO_DEPTH;
 80186c6:	2308      	movs	r3, #8
 80186c8:	73bb      	strb	r3, [r7, #14]
    rx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_RXFTCFG) >> USART_CR3_RXFTCFG_Pos);
 80186ca:	687b      	ldr	r3, [r7, #4]
 80186cc:	681b      	ldr	r3, [r3, #0]
 80186ce:	689b      	ldr	r3, [r3, #8]
 80186d0:	0e5b      	lsrs	r3, r3, #25
 80186d2:	b2db      	uxtb	r3, r3
 80186d4:	f003 0307 	and.w	r3, r3, #7
 80186d8:	737b      	strb	r3, [r7, #13]
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
 80186da:	687b      	ldr	r3, [r7, #4]
 80186dc:	681b      	ldr	r3, [r3, #0]
 80186de:	689b      	ldr	r3, [r3, #8]
 80186e0:	0f5b      	lsrs	r3, r3, #29
 80186e2:	b2db      	uxtb	r3, r3
 80186e4:	f003 0307 	and.w	r3, r3, #7
 80186e8:	733b      	strb	r3, [r7, #12]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 80186ea:	7bbb      	ldrb	r3, [r7, #14]
 80186ec:	7b3a      	ldrb	r2, [r7, #12]
 80186ee:	4911      	ldr	r1, [pc, #68]	@ (8018734 <UARTEx_SetNbDataToProcess+0x94>)
 80186f0:	5c8a      	ldrb	r2, [r1, r2]
 80186f2:	fb02 f303 	mul.w	r3, r2, r3
                               (uint16_t)denominator[tx_fifo_threshold];
 80186f6:	7b3a      	ldrb	r2, [r7, #12]
 80186f8:	490f      	ldr	r1, [pc, #60]	@ (8018738 <UARTEx_SetNbDataToProcess+0x98>)
 80186fa:	5c8a      	ldrb	r2, [r1, r2]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 80186fc:	fb93 f3f2 	sdiv	r3, r3, r2
 8018700:	b29a      	uxth	r2, r3
 8018702:	687b      	ldr	r3, [r7, #4]
 8018704:	f8a3 206a 	strh.w	r2, [r3, #106]	@ 0x6a
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8018708:	7bfb      	ldrb	r3, [r7, #15]
 801870a:	7b7a      	ldrb	r2, [r7, #13]
 801870c:	4909      	ldr	r1, [pc, #36]	@ (8018734 <UARTEx_SetNbDataToProcess+0x94>)
 801870e:	5c8a      	ldrb	r2, [r1, r2]
 8018710:	fb02 f303 	mul.w	r3, r2, r3
                               (uint16_t)denominator[rx_fifo_threshold];
 8018714:	7b7a      	ldrb	r2, [r7, #13]
 8018716:	4908      	ldr	r1, [pc, #32]	@ (8018738 <UARTEx_SetNbDataToProcess+0x98>)
 8018718:	5c8a      	ldrb	r2, [r1, r2]
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 801871a:	fb93 f3f2 	sdiv	r3, r3, r2
 801871e:	b29a      	uxth	r2, r3
 8018720:	687b      	ldr	r3, [r7, #4]
 8018722:	f8a3 2068 	strh.w	r2, [r3, #104]	@ 0x68
}
 8018726:	bf00      	nop
 8018728:	3714      	adds	r7, #20
 801872a:	46bd      	mov	sp, r7
 801872c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8018730:	4770      	bx	lr
 8018732:	bf00      	nop
 8018734:	0802a5b8 	.word	0x0802a5b8
 8018738:	0802a5c0 	.word	0x0802a5c0

0801873c <aci_gap_pass_key_resp>:
  }
  return BLE_STATUS_SUCCESS;
}
tBleStatus aci_gap_pass_key_resp(uint16_t Connection_Handle,
                                 uint32_t Pass_Key)
{
 801873c:	b580      	push	{r7, lr}
 801873e:	f5ad 7d12 	sub.w	sp, sp, #584	@ 0x248
 8018742:	af00      	add	r7, sp, #0
 8018744:	4602      	mov	r2, r0
 8018746:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 801874a:	f5a3 7312 	sub.w	r3, r3, #584	@ 0x248
 801874e:	6019      	str	r1, [r3, #0]
 8018750:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8018754:	f2a3 2342 	subw	r3, r3, #578	@ 0x242
 8018758:	801a      	strh	r2, [r3, #0]
  struct hci_request rq;
  uint8_t cmd_buffer[532];
  aci_gap_pass_key_resp_cp0 *cp0 = (aci_gap_pass_key_resp_cp0*)(cmd_buffer);
 801875a:	f107 0310 	add.w	r3, r7, #16
 801875e:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
  tBleStatus status = 0;
 8018762:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8018766:	f2a3 2339 	subw	r3, r3, #569	@ 0x239
 801876a:	2200      	movs	r2, #0
 801876c:	701a      	strb	r2, [r3, #0]
  uint8_t index_input = 0;
 801876e:	2300      	movs	r3, #0
 8018770:	f887 3243 	strb.w	r3, [r7, #579]	@ 0x243
  cp0->Connection_Handle = htob(Connection_Handle, 2);
 8018774:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 8018778:	f507 7212 	add.w	r2, r7, #584	@ 0x248
 801877c:	f2a2 2242 	subw	r2, r2, #578	@ 0x242
 8018780:	8812      	ldrh	r2, [r2, #0]
 8018782:	801a      	strh	r2, [r3, #0]
  index_input += 2;
 8018784:	f897 3243 	ldrb.w	r3, [r7, #579]	@ 0x243
 8018788:	3302      	adds	r3, #2
 801878a:	f887 3243 	strb.w	r3, [r7, #579]	@ 0x243
  cp0->Pass_Key = htob(Pass_Key, 4);
 801878e:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 8018792:	f507 7212 	add.w	r2, r7, #584	@ 0x248
 8018796:	f5a2 7212 	sub.w	r2, r2, #584	@ 0x248
 801879a:	6812      	ldr	r2, [r2, #0]
 801879c:	f8c3 2002 	str.w	r2, [r3, #2]
  index_input += 4;
 80187a0:	f897 3243 	ldrb.w	r3, [r7, #579]	@ 0x243
 80187a4:	3304      	adds	r3, #4
 80187a6:	f887 3243 	strb.w	r3, [r7, #579]	@ 0x243
  BLUENRG_memset(&rq, 0, sizeof(rq));
 80187aa:	f507 7309 	add.w	r3, r7, #548	@ 0x224
 80187ae:	221c      	movs	r2, #28
 80187b0:	2100      	movs	r1, #0
 80187b2:	4618      	mov	r0, r3
 80187b4:	f00b fc56 	bl	8024064 <memset>
  rq.ext_aci = TRUE;
 80187b8:	2301      	movs	r3, #1
 80187ba:	f887 3224 	strb.w	r3, [r7, #548]	@ 0x224
  rq.ogf = 0x3f;
 80187be:	233f      	movs	r3, #63	@ 0x3f
 80187c0:	f8a7 3226 	strh.w	r3, [r7, #550]	@ 0x226
  rq.ocf = 0x088;
 80187c4:	2388      	movs	r3, #136	@ 0x88
 80187c6:	f8a7 3228 	strh.w	r3, [r7, #552]	@ 0x228
  rq.cparam = cmd_buffer;
 80187ca:	f107 0310 	add.w	r3, r7, #16
 80187ce:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230
  rq.clen = index_input;
 80187d2:	f897 3243 	ldrb.w	r3, [r7, #579]	@ 0x243
 80187d6:	f8c7 3234 	str.w	r3, [r7, #564]	@ 0x234
  rq.rparam = &status;
 80187da:	f107 030f 	add.w	r3, r7, #15
 80187de:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
  rq.rlen = 1;
 80187e2:	2301      	movs	r3, #1
 80187e4:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
  if (hci_send_req(&rq, FALSE) < 0)
 80187e8:	f507 7309 	add.w	r3, r7, #548	@ 0x224
 80187ec:	2100      	movs	r1, #0
 80187ee:	4618      	mov	r0, r3
 80187f0:	f003 fb7e 	bl	801bef0 <hci_send_req>
 80187f4:	4603      	mov	r3, r0
 80187f6:	2b00      	cmp	r3, #0
 80187f8:	da01      	bge.n	80187fe <aci_gap_pass_key_resp+0xc2>
    return BLE_STATUS_TIMEOUT;
 80187fa:	23ff      	movs	r3, #255	@ 0xff
 80187fc:	e00d      	b.n	801881a <aci_gap_pass_key_resp+0xde>
  if (status) {
 80187fe:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8018802:	f2a3 2339 	subw	r3, r3, #569	@ 0x239
 8018806:	781b      	ldrb	r3, [r3, #0]
 8018808:	2b00      	cmp	r3, #0
 801880a:	d005      	beq.n	8018818 <aci_gap_pass_key_resp+0xdc>
    return status;
 801880c:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8018810:	f2a3 2339 	subw	r3, r3, #569	@ 0x239
 8018814:	781b      	ldrb	r3, [r3, #0]
 8018816:	e000      	b.n	801881a <aci_gap_pass_key_resp+0xde>
  }
  return BLE_STATUS_SUCCESS;
 8018818:	2300      	movs	r3, #0
}
 801881a:	4618      	mov	r0, r3
 801881c:	f507 7712 	add.w	r7, r7, #584	@ 0x248
 8018820:	46bd      	mov	sp, r7
 8018822:	bd80      	pop	{r7, pc}

08018824 <aci_gap_init>:
                        uint8_t Device_Name_Char_Len,
                        uint8_t Identity_Address_Type,
                        uint16_t *Service_Handle,
                        uint16_t *Dev_Name_Char_Handle,
                        uint16_t *Appearance_Char_Handle)
{
 8018824:	b5b0      	push	{r4, r5, r7, lr}
 8018826:	f5ad 7d12 	sub.w	sp, sp, #584	@ 0x248
 801882a:	af00      	add	r7, sp, #0
 801882c:	4605      	mov	r5, r0
 801882e:	460c      	mov	r4, r1
 8018830:	4610      	mov	r0, r2
 8018832:	4619      	mov	r1, r3
 8018834:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8018838:	f2a3 2341 	subw	r3, r3, #577	@ 0x241
 801883c:	462a      	mov	r2, r5
 801883e:	701a      	strb	r2, [r3, #0]
 8018840:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8018844:	f2a3 2342 	subw	r3, r3, #578	@ 0x242
 8018848:	4622      	mov	r2, r4
 801884a:	701a      	strb	r2, [r3, #0]
 801884c:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8018850:	f2a3 2343 	subw	r3, r3, #579	@ 0x243
 8018854:	4602      	mov	r2, r0
 8018856:	701a      	strb	r2, [r3, #0]
 8018858:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 801885c:	f5a3 7311 	sub.w	r3, r3, #580	@ 0x244
 8018860:	460a      	mov	r2, r1
 8018862:	701a      	strb	r2, [r3, #0]
  struct hci_request rq;
  uint8_t cmd_buffer[532];
  aci_gap_init_cp0 *cp0 = (aci_gap_init_cp0*)(cmd_buffer);
 8018864:	f107 0310 	add.w	r3, r7, #16
 8018868:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
  aci_gap_init_rp0 resp;
  BLUENRG_memset(&resp, 0, sizeof(resp));
 801886c:	f107 0308 	add.w	r3, r7, #8
 8018870:	2207      	movs	r2, #7
 8018872:	2100      	movs	r1, #0
 8018874:	4618      	mov	r0, r3
 8018876:	f00b fbf5 	bl	8024064 <memset>
  uint8_t index_input = 0;
 801887a:	2300      	movs	r3, #0
 801887c:	f887 3243 	strb.w	r3, [r7, #579]	@ 0x243
  cp0->Role = htob(Role, 1);
 8018880:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 8018884:	f507 7212 	add.w	r2, r7, #584	@ 0x248
 8018888:	f2a2 2241 	subw	r2, r2, #577	@ 0x241
 801888c:	7812      	ldrb	r2, [r2, #0]
 801888e:	701a      	strb	r2, [r3, #0]
  index_input += 1;
 8018890:	f897 3243 	ldrb.w	r3, [r7, #579]	@ 0x243
 8018894:	3301      	adds	r3, #1
 8018896:	f887 3243 	strb.w	r3, [r7, #579]	@ 0x243
  cp0->Privacy_Type = htob(Privacy_Type, 1);
 801889a:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 801889e:	f507 7212 	add.w	r2, r7, #584	@ 0x248
 80188a2:	f2a2 2242 	subw	r2, r2, #578	@ 0x242
 80188a6:	7812      	ldrb	r2, [r2, #0]
 80188a8:	705a      	strb	r2, [r3, #1]
  index_input += 1;
 80188aa:	f897 3243 	ldrb.w	r3, [r7, #579]	@ 0x243
 80188ae:	3301      	adds	r3, #1
 80188b0:	f887 3243 	strb.w	r3, [r7, #579]	@ 0x243
  cp0->Device_Name_Char_Len = htob(Device_Name_Char_Len, 1);
 80188b4:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 80188b8:	f507 7212 	add.w	r2, r7, #584	@ 0x248
 80188bc:	f2a2 2243 	subw	r2, r2, #579	@ 0x243
 80188c0:	7812      	ldrb	r2, [r2, #0]
 80188c2:	709a      	strb	r2, [r3, #2]
  index_input += 1;
 80188c4:	f897 3243 	ldrb.w	r3, [r7, #579]	@ 0x243
 80188c8:	3301      	adds	r3, #1
 80188ca:	f887 3243 	strb.w	r3, [r7, #579]	@ 0x243
  cp0->Identity_Address_Type = htob(Identity_Address_Type, 1);
 80188ce:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 80188d2:	f507 7212 	add.w	r2, r7, #584	@ 0x248
 80188d6:	f5a2 7211 	sub.w	r2, r2, #580	@ 0x244
 80188da:	7812      	ldrb	r2, [r2, #0]
 80188dc:	70da      	strb	r2, [r3, #3]
  index_input += 1;
 80188de:	f897 3243 	ldrb.w	r3, [r7, #579]	@ 0x243
 80188e2:	3301      	adds	r3, #1
 80188e4:	f887 3243 	strb.w	r3, [r7, #579]	@ 0x243
  BLUENRG_memset(&rq, 0, sizeof(rq));
 80188e8:	f507 7309 	add.w	r3, r7, #548	@ 0x224
 80188ec:	221c      	movs	r2, #28
 80188ee:	2100      	movs	r1, #0
 80188f0:	4618      	mov	r0, r3
 80188f2:	f00b fbb7 	bl	8024064 <memset>
  rq.ext_aci = TRUE;
 80188f6:	2301      	movs	r3, #1
 80188f8:	f887 3224 	strb.w	r3, [r7, #548]	@ 0x224
  rq.ogf = 0x3f;
 80188fc:	233f      	movs	r3, #63	@ 0x3f
 80188fe:	f8a7 3226 	strh.w	r3, [r7, #550]	@ 0x226
  rq.ocf = 0x08a;
 8018902:	238a      	movs	r3, #138	@ 0x8a
 8018904:	f8a7 3228 	strh.w	r3, [r7, #552]	@ 0x228
  rq.cparam = cmd_buffer;
 8018908:	f107 0310 	add.w	r3, r7, #16
 801890c:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230
  rq.clen = index_input;
 8018910:	f897 3243 	ldrb.w	r3, [r7, #579]	@ 0x243
 8018914:	f8c7 3234 	str.w	r3, [r7, #564]	@ 0x234
  rq.rparam = &resp;
 8018918:	f107 0308 	add.w	r3, r7, #8
 801891c:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
  rq.rlen = sizeof(resp);
 8018920:	2307      	movs	r3, #7
 8018922:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
  if (hci_send_req(&rq, FALSE) < 0)
 8018926:	f507 7309 	add.w	r3, r7, #548	@ 0x224
 801892a:	2100      	movs	r1, #0
 801892c:	4618      	mov	r0, r3
 801892e:	f003 fadf 	bl	801bef0 <hci_send_req>
 8018932:	4603      	mov	r3, r0
 8018934:	2b00      	cmp	r3, #0
 8018936:	da01      	bge.n	801893c <aci_gap_init+0x118>
    return BLE_STATUS_TIMEOUT;
 8018938:	23ff      	movs	r3, #255	@ 0xff
 801893a:	e02b      	b.n	8018994 <aci_gap_init+0x170>
  if (resp.Status) {
 801893c:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8018940:	f5a3 7310 	sub.w	r3, r3, #576	@ 0x240
 8018944:	781b      	ldrb	r3, [r3, #0]
 8018946:	2b00      	cmp	r3, #0
 8018948:	d005      	beq.n	8018956 <aci_gap_init+0x132>
    return resp.Status;
 801894a:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 801894e:	f5a3 7310 	sub.w	r3, r3, #576	@ 0x240
 8018952:	781b      	ldrb	r3, [r3, #0]
 8018954:	e01e      	b.n	8018994 <aci_gap_init+0x170>
  }
  *Service_Handle = btoh(resp.Service_Handle, 2);
 8018956:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 801895a:	f5a3 7310 	sub.w	r3, r3, #576	@ 0x240
 801895e:	f8b3 3001 	ldrh.w	r3, [r3, #1]
 8018962:	b29a      	uxth	r2, r3
 8018964:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 8018968:	801a      	strh	r2, [r3, #0]
  *Dev_Name_Char_Handle = btoh(resp.Dev_Name_Char_Handle, 2);
 801896a:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 801896e:	f5a3 7310 	sub.w	r3, r3, #576	@ 0x240
 8018972:	f8b3 3003 	ldrh.w	r3, [r3, #3]
 8018976:	b29a      	uxth	r2, r3
 8018978:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 801897c:	801a      	strh	r2, [r3, #0]
  *Appearance_Char_Handle = btoh(resp.Appearance_Char_Handle, 2);
 801897e:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8018982:	f5a3 7310 	sub.w	r3, r3, #576	@ 0x240
 8018986:	f8b3 3005 	ldrh.w	r3, [r3, #5]
 801898a:	b29a      	uxth	r2, r3
 801898c:	f8d7 3260 	ldr.w	r3, [r7, #608]	@ 0x260
 8018990:	801a      	strh	r2, [r3, #0]
  return BLE_STATUS_SUCCESS;
 8018992:	2300      	movs	r3, #0
}
 8018994:	4618      	mov	r0, r3
 8018996:	f507 7712 	add.w	r7, r7, #584	@ 0x248
 801899a:	46bd      	mov	sp, r7
 801899c:	bdb0      	pop	{r4, r5, r7, pc}

0801899e <aci_gap_slave_security_req>:
tBleStatus aci_gap_slave_security_req(uint16_t Connection_Handle)
{
 801899e:	b580      	push	{r7, lr}
 80189a0:	f5ad 7d12 	sub.w	sp, sp, #584	@ 0x248
 80189a4:	af00      	add	r7, sp, #0
 80189a6:	4602      	mov	r2, r0
 80189a8:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 80189ac:	f2a3 2342 	subw	r3, r3, #578	@ 0x242
 80189b0:	801a      	strh	r2, [r3, #0]
  struct hci_request rq;
  uint8_t cmd_buffer[532];
  aci_gap_slave_security_req_cp0 *cp0 = (aci_gap_slave_security_req_cp0*)(cmd_buffer);
 80189b2:	f107 0310 	add.w	r3, r7, #16
 80189b6:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
  tBleStatus status = 0;
 80189ba:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 80189be:	f2a3 2339 	subw	r3, r3, #569	@ 0x239
 80189c2:	2200      	movs	r2, #0
 80189c4:	701a      	strb	r2, [r3, #0]
  uint8_t index_input = 0;
 80189c6:	2300      	movs	r3, #0
 80189c8:	f887 3243 	strb.w	r3, [r7, #579]	@ 0x243
  cp0->Connection_Handle = htob(Connection_Handle, 2);
 80189cc:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 80189d0:	f507 7212 	add.w	r2, r7, #584	@ 0x248
 80189d4:	f2a2 2242 	subw	r2, r2, #578	@ 0x242
 80189d8:	8812      	ldrh	r2, [r2, #0]
 80189da:	801a      	strh	r2, [r3, #0]
  index_input += 2;
 80189dc:	f897 3243 	ldrb.w	r3, [r7, #579]	@ 0x243
 80189e0:	3302      	adds	r3, #2
 80189e2:	f887 3243 	strb.w	r3, [r7, #579]	@ 0x243
  BLUENRG_memset(&rq, 0, sizeof(rq));
 80189e6:	f507 7309 	add.w	r3, r7, #548	@ 0x224
 80189ea:	221c      	movs	r2, #28
 80189ec:	2100      	movs	r1, #0
 80189ee:	4618      	mov	r0, r3
 80189f0:	f00b fb38 	bl	8024064 <memset>
  rq.ext_aci = TRUE;
 80189f4:	2301      	movs	r3, #1
 80189f6:	f887 3224 	strb.w	r3, [r7, #548]	@ 0x224
  rq.ogf = 0x3f;
 80189fa:	233f      	movs	r3, #63	@ 0x3f
 80189fc:	f8a7 3226 	strh.w	r3, [r7, #550]	@ 0x226
  rq.ocf = 0x08d;
 8018a00:	238d      	movs	r3, #141	@ 0x8d
 8018a02:	f8a7 3228 	strh.w	r3, [r7, #552]	@ 0x228
  rq.event = 0x0F;
 8018a06:	230f      	movs	r3, #15
 8018a08:	f8c7 322c 	str.w	r3, [r7, #556]	@ 0x22c
  rq.cparam = cmd_buffer;
 8018a0c:	f107 0310 	add.w	r3, r7, #16
 8018a10:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230
  rq.clen = index_input;
 8018a14:	f897 3243 	ldrb.w	r3, [r7, #579]	@ 0x243
 8018a18:	f8c7 3234 	str.w	r3, [r7, #564]	@ 0x234
  rq.rparam = &status;
 8018a1c:	f107 030f 	add.w	r3, r7, #15
 8018a20:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
  rq.rlen = 1;
 8018a24:	2301      	movs	r3, #1
 8018a26:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
  if (hci_send_req(&rq, FALSE) < 0)
 8018a2a:	f507 7309 	add.w	r3, r7, #548	@ 0x224
 8018a2e:	2100      	movs	r1, #0
 8018a30:	4618      	mov	r0, r3
 8018a32:	f003 fa5d 	bl	801bef0 <hci_send_req>
 8018a36:	4603      	mov	r3, r0
 8018a38:	2b00      	cmp	r3, #0
 8018a3a:	da01      	bge.n	8018a40 <aci_gap_slave_security_req+0xa2>
    return BLE_STATUS_TIMEOUT;
 8018a3c:	23ff      	movs	r3, #255	@ 0xff
 8018a3e:	e00d      	b.n	8018a5c <aci_gap_slave_security_req+0xbe>
  if (status) {
 8018a40:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8018a44:	f2a3 2339 	subw	r3, r3, #569	@ 0x239
 8018a48:	781b      	ldrb	r3, [r3, #0]
 8018a4a:	2b00      	cmp	r3, #0
 8018a4c:	d005      	beq.n	8018a5a <aci_gap_slave_security_req+0xbc>
    return status;
 8018a4e:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8018a52:	f2a3 2339 	subw	r3, r3, #569	@ 0x239
 8018a56:	781b      	ldrb	r3, [r3, #0]
 8018a58:	e000      	b.n	8018a5c <aci_gap_slave_security_req+0xbe>
  }
  return BLE_STATUS_SUCCESS;
 8018a5a:	2300      	movs	r3, #0
}
 8018a5c:	4618      	mov	r0, r3
 8018a5e:	f507 7712 	add.w	r7, r7, #584	@ 0x248
 8018a62:	46bd      	mov	sp, r7
 8018a64:	bd80      	pop	{r7, pc}

08018a66 <aci_gap_terminate>:
  }
  return BLE_STATUS_SUCCESS;
}
tBleStatus aci_gap_terminate(uint16_t Connection_Handle,
                             uint8_t Reason)
{
 8018a66:	b580      	push	{r7, lr}
 8018a68:	f5ad 7d12 	sub.w	sp, sp, #584	@ 0x248
 8018a6c:	af00      	add	r7, sp, #0
 8018a6e:	4602      	mov	r2, r0
 8018a70:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8018a74:	f2a3 2342 	subw	r3, r3, #578	@ 0x242
 8018a78:	801a      	strh	r2, [r3, #0]
 8018a7a:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8018a7e:	f2a3 2343 	subw	r3, r3, #579	@ 0x243
 8018a82:	460a      	mov	r2, r1
 8018a84:	701a      	strb	r2, [r3, #0]
  struct hci_request rq;
  uint8_t cmd_buffer[532];
  aci_gap_terminate_cp0 *cp0 = (aci_gap_terminate_cp0*)(cmd_buffer);
 8018a86:	f107 0310 	add.w	r3, r7, #16
 8018a8a:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
  tBleStatus status = 0;
 8018a8e:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8018a92:	f2a3 2339 	subw	r3, r3, #569	@ 0x239
 8018a96:	2200      	movs	r2, #0
 8018a98:	701a      	strb	r2, [r3, #0]
  uint8_t index_input = 0;
 8018a9a:	2300      	movs	r3, #0
 8018a9c:	f887 3243 	strb.w	r3, [r7, #579]	@ 0x243
  cp0->Connection_Handle = htob(Connection_Handle, 2);
 8018aa0:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 8018aa4:	f507 7212 	add.w	r2, r7, #584	@ 0x248
 8018aa8:	f2a2 2242 	subw	r2, r2, #578	@ 0x242
 8018aac:	8812      	ldrh	r2, [r2, #0]
 8018aae:	801a      	strh	r2, [r3, #0]
  index_input += 2;
 8018ab0:	f897 3243 	ldrb.w	r3, [r7, #579]	@ 0x243
 8018ab4:	3302      	adds	r3, #2
 8018ab6:	f887 3243 	strb.w	r3, [r7, #579]	@ 0x243
  cp0->Reason = htob(Reason, 1);
 8018aba:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 8018abe:	f507 7212 	add.w	r2, r7, #584	@ 0x248
 8018ac2:	f2a2 2243 	subw	r2, r2, #579	@ 0x243
 8018ac6:	7812      	ldrb	r2, [r2, #0]
 8018ac8:	709a      	strb	r2, [r3, #2]
  index_input += 1;
 8018aca:	f897 3243 	ldrb.w	r3, [r7, #579]	@ 0x243
 8018ace:	3301      	adds	r3, #1
 8018ad0:	f887 3243 	strb.w	r3, [r7, #579]	@ 0x243
  BLUENRG_memset(&rq, 0, sizeof(rq));
 8018ad4:	f507 7309 	add.w	r3, r7, #548	@ 0x224
 8018ad8:	221c      	movs	r2, #28
 8018ada:	2100      	movs	r1, #0
 8018adc:	4618      	mov	r0, r3
 8018ade:	f00b fac1 	bl	8024064 <memset>
  rq.ext_aci = TRUE;
 8018ae2:	2301      	movs	r3, #1
 8018ae4:	f887 3224 	strb.w	r3, [r7, #548]	@ 0x224
  rq.ogf = 0x3f;
 8018ae8:	233f      	movs	r3, #63	@ 0x3f
 8018aea:	f8a7 3226 	strh.w	r3, [r7, #550]	@ 0x226
  rq.ocf = 0x093;
 8018aee:	2393      	movs	r3, #147	@ 0x93
 8018af0:	f8a7 3228 	strh.w	r3, [r7, #552]	@ 0x228
  rq.event = 0x0F;
 8018af4:	230f      	movs	r3, #15
 8018af6:	f8c7 322c 	str.w	r3, [r7, #556]	@ 0x22c
  rq.cparam = cmd_buffer;
 8018afa:	f107 0310 	add.w	r3, r7, #16
 8018afe:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230
  rq.clen = index_input;
 8018b02:	f897 3243 	ldrb.w	r3, [r7, #579]	@ 0x243
 8018b06:	f8c7 3234 	str.w	r3, [r7, #564]	@ 0x234
  rq.rparam = &status;
 8018b0a:	f107 030f 	add.w	r3, r7, #15
 8018b0e:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
  rq.rlen = 1;
 8018b12:	2301      	movs	r3, #1
 8018b14:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
  if (hci_send_req(&rq, FALSE) < 0)
 8018b18:	f507 7309 	add.w	r3, r7, #548	@ 0x224
 8018b1c:	2100      	movs	r1, #0
 8018b1e:	4618      	mov	r0, r3
 8018b20:	f003 f9e6 	bl	801bef0 <hci_send_req>
 8018b24:	4603      	mov	r3, r0
 8018b26:	2b00      	cmp	r3, #0
 8018b28:	da01      	bge.n	8018b2e <aci_gap_terminate+0xc8>
    return BLE_STATUS_TIMEOUT;
 8018b2a:	23ff      	movs	r3, #255	@ 0xff
 8018b2c:	e00d      	b.n	8018b4a <aci_gap_terminate+0xe4>
  if (status) {
 8018b2e:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8018b32:	f2a3 2339 	subw	r3, r3, #569	@ 0x239
 8018b36:	781b      	ldrb	r3, [r3, #0]
 8018b38:	2b00      	cmp	r3, #0
 8018b3a:	d005      	beq.n	8018b48 <aci_gap_terminate+0xe2>
    return status;
 8018b3c:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8018b40:	f2a3 2339 	subw	r3, r3, #569	@ 0x239
 8018b44:	781b      	ldrb	r3, [r3, #0]
 8018b46:	e000      	b.n	8018b4a <aci_gap_terminate+0xe4>
  }
  return BLE_STATUS_SUCCESS;
 8018b48:	2300      	movs	r3, #0
}
 8018b4a:	4618      	mov	r0, r3
 8018b4c:	f507 7712 	add.w	r7, r7, #584	@ 0x248
 8018b50:	46bd      	mov	sp, r7
 8018b52:	bd80      	pop	{r7, pc}

08018b54 <aci_gap_allow_rebond>:
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
tBleStatus aci_gap_allow_rebond(uint16_t Connection_Handle)
{
 8018b54:	b580      	push	{r7, lr}
 8018b56:	f5ad 7d12 	sub.w	sp, sp, #584	@ 0x248
 8018b5a:	af00      	add	r7, sp, #0
 8018b5c:	4602      	mov	r2, r0
 8018b5e:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8018b62:	f2a3 2342 	subw	r3, r3, #578	@ 0x242
 8018b66:	801a      	strh	r2, [r3, #0]
  struct hci_request rq;
  uint8_t cmd_buffer[532];
  aci_gap_allow_rebond_cp0 *cp0 = (aci_gap_allow_rebond_cp0*)(cmd_buffer);
 8018b68:	f107 0310 	add.w	r3, r7, #16
 8018b6c:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
  tBleStatus status = 0;
 8018b70:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8018b74:	f2a3 2339 	subw	r3, r3, #569	@ 0x239
 8018b78:	2200      	movs	r2, #0
 8018b7a:	701a      	strb	r2, [r3, #0]
  uint8_t index_input = 0;
 8018b7c:	2300      	movs	r3, #0
 8018b7e:	f887 3243 	strb.w	r3, [r7, #579]	@ 0x243
  cp0->Connection_Handle = htob(Connection_Handle, 2);
 8018b82:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 8018b86:	f507 7212 	add.w	r2, r7, #584	@ 0x248
 8018b8a:	f2a2 2242 	subw	r2, r2, #578	@ 0x242
 8018b8e:	8812      	ldrh	r2, [r2, #0]
 8018b90:	801a      	strh	r2, [r3, #0]
  index_input += 2;
 8018b92:	f897 3243 	ldrb.w	r3, [r7, #579]	@ 0x243
 8018b96:	3302      	adds	r3, #2
 8018b98:	f887 3243 	strb.w	r3, [r7, #579]	@ 0x243
  BLUENRG_memset(&rq, 0, sizeof(rq));
 8018b9c:	f507 7309 	add.w	r3, r7, #548	@ 0x224
 8018ba0:	221c      	movs	r2, #28
 8018ba2:	2100      	movs	r1, #0
 8018ba4:	4618      	mov	r0, r3
 8018ba6:	f00b fa5d 	bl	8024064 <memset>
  rq.ext_aci = TRUE;
 8018baa:	2301      	movs	r3, #1
 8018bac:	f887 3224 	strb.w	r3, [r7, #548]	@ 0x224
  rq.ogf = 0x3f;
 8018bb0:	233f      	movs	r3, #63	@ 0x3f
 8018bb2:	f8a7 3226 	strh.w	r3, [r7, #550]	@ 0x226
  rq.ocf = 0x095;
 8018bb6:	2395      	movs	r3, #149	@ 0x95
 8018bb8:	f8a7 3228 	strh.w	r3, [r7, #552]	@ 0x228
  rq.cparam = cmd_buffer;
 8018bbc:	f107 0310 	add.w	r3, r7, #16
 8018bc0:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230
  rq.clen = index_input;
 8018bc4:	f897 3243 	ldrb.w	r3, [r7, #579]	@ 0x243
 8018bc8:	f8c7 3234 	str.w	r3, [r7, #564]	@ 0x234
  rq.rparam = &status;
 8018bcc:	f107 030f 	add.w	r3, r7, #15
 8018bd0:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
  rq.rlen = 1;
 8018bd4:	2301      	movs	r3, #1
 8018bd6:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
  if (hci_send_req(&rq, FALSE) < 0)
 8018bda:	f507 7309 	add.w	r3, r7, #548	@ 0x224
 8018bde:	2100      	movs	r1, #0
 8018be0:	4618      	mov	r0, r3
 8018be2:	f003 f985 	bl	801bef0 <hci_send_req>
 8018be6:	4603      	mov	r3, r0
 8018be8:	2b00      	cmp	r3, #0
 8018bea:	da01      	bge.n	8018bf0 <aci_gap_allow_rebond+0x9c>
    return BLE_STATUS_TIMEOUT;
 8018bec:	23ff      	movs	r3, #255	@ 0xff
 8018bee:	e00d      	b.n	8018c0c <aci_gap_allow_rebond+0xb8>
  if (status) {
 8018bf0:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8018bf4:	f2a3 2339 	subw	r3, r3, #569	@ 0x239
 8018bf8:	781b      	ldrb	r3, [r3, #0]
 8018bfa:	2b00      	cmp	r3, #0
 8018bfc:	d005      	beq.n	8018c0a <aci_gap_allow_rebond+0xb6>
    return status;
 8018bfe:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8018c02:	f2a3 2339 	subw	r3, r3, #569	@ 0x239
 8018c06:	781b      	ldrb	r3, [r3, #0]
 8018c08:	e000      	b.n	8018c0c <aci_gap_allow_rebond+0xb8>
  }
  return BLE_STATUS_SUCCESS;
 8018c0a:	2300      	movs	r3, #0
}
 8018c0c:	4618      	mov	r0, r3
 8018c0e:	f507 7712 	add.w	r7, r7, #584	@ 0x248
 8018c12:	46bd      	mov	sp, r7
 8018c14:	bd80      	pop	{r7, pc}

08018c16 <aci_gap_get_bonded_devices>:
}
tBleStatus aci_gap_get_bonded_devices(uint8_t Offset,
                                      uint8_t Max_Num_Of_Addresses,
                                      uint8_t *Num_of_Addresses,
                                      Bonded_Device_Entry_t Bonded_Device_Entry[])
{
 8018c16:	b590      	push	{r4, r7, lr}
 8018c18:	f5ad 7d53 	sub.w	sp, sp, #844	@ 0x34c
 8018c1c:	af00      	add	r7, sp, #0
 8018c1e:	4604      	mov	r4, r0
 8018c20:	4608      	mov	r0, r1
 8018c22:	f507 7152 	add.w	r1, r7, #840	@ 0x348
 8018c26:	f5a1 7150 	sub.w	r1, r1, #832	@ 0x340
 8018c2a:	600a      	str	r2, [r1, #0]
 8018c2c:	f507 7252 	add.w	r2, r7, #840	@ 0x348
 8018c30:	f5a2 7251 	sub.w	r2, r2, #836	@ 0x344
 8018c34:	6013      	str	r3, [r2, #0]
 8018c36:	f507 7352 	add.w	r3, r7, #840	@ 0x348
 8018c3a:	f2a3 3339 	subw	r3, r3, #825	@ 0x339
 8018c3e:	4622      	mov	r2, r4
 8018c40:	701a      	strb	r2, [r3, #0]
 8018c42:	f507 7352 	add.w	r3, r7, #840	@ 0x348
 8018c46:	f2a3 333a 	subw	r3, r3, #826	@ 0x33a
 8018c4a:	4602      	mov	r2, r0
 8018c4c:	701a      	strb	r2, [r3, #0]
  struct hci_request rq;
  uint8_t cmd_buffer[532];
  aci_gap_get_bonded_devices_cp0 *cp0 = (aci_gap_get_bonded_devices_cp0*)(cmd_buffer);
 8018c4e:	f507 7388 	add.w	r3, r7, #272	@ 0x110
 8018c52:	f8c7 3344 	str.w	r3, [r7, #836]	@ 0x344
  aci_gap_get_bonded_devices_rp0 resp;
  BLUENRG_memset(&resp, 0, sizeof(resp));
 8018c56:	f107 0310 	add.w	r3, r7, #16
 8018c5a:	22fe      	movs	r2, #254	@ 0xfe
 8018c5c:	2100      	movs	r1, #0
 8018c5e:	4618      	mov	r0, r3
 8018c60:	f00b fa00 	bl	8024064 <memset>
  uint8_t index_input = 0;
 8018c64:	2300      	movs	r3, #0
 8018c66:	f887 3343 	strb.w	r3, [r7, #835]	@ 0x343
  cp0->Offset = htob(Offset, 1);
 8018c6a:	f8d7 3344 	ldr.w	r3, [r7, #836]	@ 0x344
 8018c6e:	f507 7252 	add.w	r2, r7, #840	@ 0x348
 8018c72:	f2a2 3239 	subw	r2, r2, #825	@ 0x339
 8018c76:	7812      	ldrb	r2, [r2, #0]
 8018c78:	701a      	strb	r2, [r3, #0]
  index_input += 1;
 8018c7a:	f897 3343 	ldrb.w	r3, [r7, #835]	@ 0x343
 8018c7e:	3301      	adds	r3, #1
 8018c80:	f887 3343 	strb.w	r3, [r7, #835]	@ 0x343
  cp0->Max_Num_Of_Addresses = htob(Max_Num_Of_Addresses, 1);
 8018c84:	f8d7 3344 	ldr.w	r3, [r7, #836]	@ 0x344
 8018c88:	f507 7252 	add.w	r2, r7, #840	@ 0x348
 8018c8c:	f2a2 323a 	subw	r2, r2, #826	@ 0x33a
 8018c90:	7812      	ldrb	r2, [r2, #0]
 8018c92:	705a      	strb	r2, [r3, #1]
  index_input += 1;
 8018c94:	f897 3343 	ldrb.w	r3, [r7, #835]	@ 0x343
 8018c98:	3301      	adds	r3, #1
 8018c9a:	f887 3343 	strb.w	r3, [r7, #835]	@ 0x343
  BLUENRG_memset(&rq, 0, sizeof(rq));
 8018c9e:	f507 7349 	add.w	r3, r7, #804	@ 0x324
 8018ca2:	221c      	movs	r2, #28
 8018ca4:	2100      	movs	r1, #0
 8018ca6:	4618      	mov	r0, r3
 8018ca8:	f00b f9dc 	bl	8024064 <memset>
  rq.ext_aci = TRUE;
 8018cac:	2301      	movs	r3, #1
 8018cae:	f887 3324 	strb.w	r3, [r7, #804]	@ 0x324
  rq.ogf = 0x3f;
 8018cb2:	233f      	movs	r3, #63	@ 0x3f
 8018cb4:	f8a7 3326 	strh.w	r3, [r7, #806]	@ 0x326
  rq.ocf = 0x0a3;
 8018cb8:	23a3      	movs	r3, #163	@ 0xa3
 8018cba:	f8a7 3328 	strh.w	r3, [r7, #808]	@ 0x328
  rq.cparam = cmd_buffer;
 8018cbe:	f507 7388 	add.w	r3, r7, #272	@ 0x110
 8018cc2:	f8c7 3330 	str.w	r3, [r7, #816]	@ 0x330
  rq.clen = index_input;
 8018cc6:	f897 3343 	ldrb.w	r3, [r7, #835]	@ 0x343
 8018cca:	f8c7 3334 	str.w	r3, [r7, #820]	@ 0x334
  rq.rparam = &resp;
 8018cce:	f107 0310 	add.w	r3, r7, #16
 8018cd2:	f8c7 3338 	str.w	r3, [r7, #824]	@ 0x338
  rq.rlen = sizeof(resp);
 8018cd6:	23fe      	movs	r3, #254	@ 0xfe
 8018cd8:	f8c7 333c 	str.w	r3, [r7, #828]	@ 0x33c
  if (hci_send_req(&rq, FALSE) < 0)
 8018cdc:	f507 7349 	add.w	r3, r7, #804	@ 0x324
 8018ce0:	2100      	movs	r1, #0
 8018ce2:	4618      	mov	r0, r3
 8018ce4:	f003 f904 	bl	801bef0 <hci_send_req>
 8018ce8:	4603      	mov	r3, r0
 8018cea:	2b00      	cmp	r3, #0
 8018cec:	da01      	bge.n	8018cf2 <aci_gap_get_bonded_devices+0xdc>
    return BLE_STATUS_TIMEOUT;
 8018cee:	23ff      	movs	r3, #255	@ 0xff
 8018cf0:	e02c      	b.n	8018d4c <aci_gap_get_bonded_devices+0x136>
  if (resp.Status) {
 8018cf2:	f507 7352 	add.w	r3, r7, #840	@ 0x348
 8018cf6:	f5a3 734e 	sub.w	r3, r3, #824	@ 0x338
 8018cfa:	781b      	ldrb	r3, [r3, #0]
 8018cfc:	2b00      	cmp	r3, #0
 8018cfe:	d005      	beq.n	8018d0c <aci_gap_get_bonded_devices+0xf6>
    return resp.Status;
 8018d00:	f507 7352 	add.w	r3, r7, #840	@ 0x348
 8018d04:	f5a3 734e 	sub.w	r3, r3, #824	@ 0x338
 8018d08:	781b      	ldrb	r3, [r3, #0]
 8018d0a:	e01f      	b.n	8018d4c <aci_gap_get_bonded_devices+0x136>
  }
  *Num_of_Addresses = btoh(resp.Num_of_Addresses, 1);
 8018d0c:	f507 7352 	add.w	r3, r7, #840	@ 0x348
 8018d10:	f5a3 734e 	sub.w	r3, r3, #824	@ 0x338
 8018d14:	785a      	ldrb	r2, [r3, #1]
 8018d16:	f507 7352 	add.w	r3, r7, #840	@ 0x348
 8018d1a:	f5a3 7350 	sub.w	r3, r3, #832	@ 0x340
 8018d1e:	681b      	ldr	r3, [r3, #0]
 8018d20:	701a      	strb	r2, [r3, #0]
  BLUENRG_memcpy((void *) Bonded_Device_Entry, (const void *) resp.Bonded_Device_Entry, *Num_of_Addresses*sizeof(Bonded_Device_Entry_t));
 8018d22:	f507 7352 	add.w	r3, r7, #840	@ 0x348
 8018d26:	f5a3 7350 	sub.w	r3, r3, #832	@ 0x340
 8018d2a:	681b      	ldr	r3, [r3, #0]
 8018d2c:	781b      	ldrb	r3, [r3, #0]
 8018d2e:	461a      	mov	r2, r3
 8018d30:	4613      	mov	r3, r2
 8018d32:	00db      	lsls	r3, r3, #3
 8018d34:	1a9a      	subs	r2, r3, r2
 8018d36:	f107 0310 	add.w	r3, r7, #16
 8018d3a:	1c99      	adds	r1, r3, #2
 8018d3c:	f507 7352 	add.w	r3, r7, #840	@ 0x348
 8018d40:	f5a3 7351 	sub.w	r3, r3, #836	@ 0x344
 8018d44:	6818      	ldr	r0, [r3, #0]
 8018d46:	f00b fa52 	bl	80241ee <memcpy>
  return BLE_STATUS_SUCCESS;
 8018d4a:	2300      	movs	r3, #0
}
 8018d4c:	4618      	mov	r0, r3
 8018d4e:	f507 7753 	add.w	r7, r7, #844	@ 0x34c
 8018d52:	46bd      	mov	sp, r7
 8018d54:	bd90      	pop	{r4, r7, pc}

08018d56 <aci_gap_is_device_bonded>:
tBleStatus aci_gap_is_device_bonded(uint8_t Peer_Address_Type,
                                    uint8_t Peer_Address[6])
{
 8018d56:	b580      	push	{r7, lr}
 8018d58:	f5ad 7d12 	sub.w	sp, sp, #584	@ 0x248
 8018d5c:	af00      	add	r7, sp, #0
 8018d5e:	4602      	mov	r2, r0
 8018d60:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8018d64:	f5a3 7312 	sub.w	r3, r3, #584	@ 0x248
 8018d68:	6019      	str	r1, [r3, #0]
 8018d6a:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8018d6e:	f2a3 2341 	subw	r3, r3, #577	@ 0x241
 8018d72:	701a      	strb	r2, [r3, #0]
  struct hci_request rq;
  uint8_t cmd_buffer[532];
  aci_gap_is_device_bonded_cp0 *cp0 = (aci_gap_is_device_bonded_cp0*)(cmd_buffer);
 8018d74:	f107 0310 	add.w	r3, r7, #16
 8018d78:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
  tBleStatus status = 0;
 8018d7c:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8018d80:	f2a3 2339 	subw	r3, r3, #569	@ 0x239
 8018d84:	2200      	movs	r2, #0
 8018d86:	701a      	strb	r2, [r3, #0]
  uint8_t index_input = 0;
 8018d88:	2300      	movs	r3, #0
 8018d8a:	f887 3243 	strb.w	r3, [r7, #579]	@ 0x243
  cp0->Peer_Address_Type = htob(Peer_Address_Type, 1);
 8018d8e:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 8018d92:	f507 7212 	add.w	r2, r7, #584	@ 0x248
 8018d96:	f2a2 2241 	subw	r2, r2, #577	@ 0x241
 8018d9a:	7812      	ldrb	r2, [r2, #0]
 8018d9c:	701a      	strb	r2, [r3, #0]
  index_input += 1;
 8018d9e:	f897 3243 	ldrb.w	r3, [r7, #579]	@ 0x243
 8018da2:	3301      	adds	r3, #1
 8018da4:	f887 3243 	strb.w	r3, [r7, #579]	@ 0x243
  BLUENRG_memcpy((void *) &cp0->Peer_Address, (const void *) Peer_Address, 6);
 8018da8:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 8018dac:	1c58      	adds	r0, r3, #1
 8018dae:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8018db2:	f5a3 7312 	sub.w	r3, r3, #584	@ 0x248
 8018db6:	2206      	movs	r2, #6
 8018db8:	6819      	ldr	r1, [r3, #0]
 8018dba:	f00b fa18 	bl	80241ee <memcpy>
  index_input += 6;
 8018dbe:	f897 3243 	ldrb.w	r3, [r7, #579]	@ 0x243
 8018dc2:	3306      	adds	r3, #6
 8018dc4:	f887 3243 	strb.w	r3, [r7, #579]	@ 0x243
  BLUENRG_memset(&rq, 0, sizeof(rq));
 8018dc8:	f507 7309 	add.w	r3, r7, #548	@ 0x224
 8018dcc:	221c      	movs	r2, #28
 8018dce:	2100      	movs	r1, #0
 8018dd0:	4618      	mov	r0, r3
 8018dd2:	f00b f947 	bl	8024064 <memset>
  rq.ext_aci = TRUE;
 8018dd6:	2301      	movs	r3, #1
 8018dd8:	f887 3224 	strb.w	r3, [r7, #548]	@ 0x224
  rq.ogf = 0x3f;
 8018ddc:	233f      	movs	r3, #63	@ 0x3f
 8018dde:	f8a7 3226 	strh.w	r3, [r7, #550]	@ 0x226
  rq.ocf = 0x0a4;
 8018de2:	23a4      	movs	r3, #164	@ 0xa4
 8018de4:	f8a7 3228 	strh.w	r3, [r7, #552]	@ 0x228
  rq.cparam = cmd_buffer;
 8018de8:	f107 0310 	add.w	r3, r7, #16
 8018dec:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230
  rq.clen = index_input;
 8018df0:	f897 3243 	ldrb.w	r3, [r7, #579]	@ 0x243
 8018df4:	f8c7 3234 	str.w	r3, [r7, #564]	@ 0x234
  rq.rparam = &status;
 8018df8:	f107 030f 	add.w	r3, r7, #15
 8018dfc:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
  rq.rlen = 1;
 8018e00:	2301      	movs	r3, #1
 8018e02:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
  if (hci_send_req(&rq, FALSE) < 0)
 8018e06:	f507 7309 	add.w	r3, r7, #548	@ 0x224
 8018e0a:	2100      	movs	r1, #0
 8018e0c:	4618      	mov	r0, r3
 8018e0e:	f003 f86f 	bl	801bef0 <hci_send_req>
 8018e12:	4603      	mov	r3, r0
 8018e14:	2b00      	cmp	r3, #0
 8018e16:	da01      	bge.n	8018e1c <aci_gap_is_device_bonded+0xc6>
    return BLE_STATUS_TIMEOUT;
 8018e18:	23ff      	movs	r3, #255	@ 0xff
 8018e1a:	e00d      	b.n	8018e38 <aci_gap_is_device_bonded+0xe2>
  if (status) {
 8018e1c:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8018e20:	f2a3 2339 	subw	r3, r3, #569	@ 0x239
 8018e24:	781b      	ldrb	r3, [r3, #0]
 8018e26:	2b00      	cmp	r3, #0
 8018e28:	d005      	beq.n	8018e36 <aci_gap_is_device_bonded+0xe0>
    return status;
 8018e2a:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8018e2e:	f2a3 2339 	subw	r3, r3, #569	@ 0x239
 8018e32:	781b      	ldrb	r3, [r3, #0]
 8018e34:	e000      	b.n	8018e38 <aci_gap_is_device_bonded+0xe2>
  }
  return BLE_STATUS_SUCCESS;
 8018e36:	2300      	movs	r3, #0
}
 8018e38:	4618      	mov	r0, r3
 8018e3a:	f507 7712 	add.w	r7, r7, #584	@ 0x248
 8018e3e:	46bd      	mov	sp, r7
 8018e40:	bd80      	pop	{r7, pc}

08018e42 <aci_gap_numeric_comparison_value_confirm_yesno>:
tBleStatus aci_gap_numeric_comparison_value_confirm_yesno(uint16_t Connection_Handle,
                                                          uint8_t Confirm_Yes_No)
{
 8018e42:	b580      	push	{r7, lr}
 8018e44:	f5ad 7d12 	sub.w	sp, sp, #584	@ 0x248
 8018e48:	af00      	add	r7, sp, #0
 8018e4a:	4602      	mov	r2, r0
 8018e4c:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8018e50:	f2a3 2342 	subw	r3, r3, #578	@ 0x242
 8018e54:	801a      	strh	r2, [r3, #0]
 8018e56:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8018e5a:	f2a3 2343 	subw	r3, r3, #579	@ 0x243
 8018e5e:	460a      	mov	r2, r1
 8018e60:	701a      	strb	r2, [r3, #0]
  struct hci_request rq;
  uint8_t cmd_buffer[532];
  aci_gap_numeric_comparison_value_confirm_yesno_cp0 *cp0 = (aci_gap_numeric_comparison_value_confirm_yesno_cp0*)(cmd_buffer);
 8018e62:	f107 0310 	add.w	r3, r7, #16
 8018e66:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
  tBleStatus status = 0;
 8018e6a:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8018e6e:	f2a3 2339 	subw	r3, r3, #569	@ 0x239
 8018e72:	2200      	movs	r2, #0
 8018e74:	701a      	strb	r2, [r3, #0]
  uint8_t index_input = 0;
 8018e76:	2300      	movs	r3, #0
 8018e78:	f887 3243 	strb.w	r3, [r7, #579]	@ 0x243
  cp0->Connection_Handle = htob(Connection_Handle, 2);
 8018e7c:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 8018e80:	f507 7212 	add.w	r2, r7, #584	@ 0x248
 8018e84:	f2a2 2242 	subw	r2, r2, #578	@ 0x242
 8018e88:	8812      	ldrh	r2, [r2, #0]
 8018e8a:	801a      	strh	r2, [r3, #0]
  index_input += 2;
 8018e8c:	f897 3243 	ldrb.w	r3, [r7, #579]	@ 0x243
 8018e90:	3302      	adds	r3, #2
 8018e92:	f887 3243 	strb.w	r3, [r7, #579]	@ 0x243
  cp0->Confirm_Yes_No = htob(Confirm_Yes_No, 1);
 8018e96:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 8018e9a:	f507 7212 	add.w	r2, r7, #584	@ 0x248
 8018e9e:	f2a2 2243 	subw	r2, r2, #579	@ 0x243
 8018ea2:	7812      	ldrb	r2, [r2, #0]
 8018ea4:	709a      	strb	r2, [r3, #2]
  index_input += 1;
 8018ea6:	f897 3243 	ldrb.w	r3, [r7, #579]	@ 0x243
 8018eaa:	3301      	adds	r3, #1
 8018eac:	f887 3243 	strb.w	r3, [r7, #579]	@ 0x243
  BLUENRG_memset(&rq, 0, sizeof(rq));
 8018eb0:	f507 7309 	add.w	r3, r7, #548	@ 0x224
 8018eb4:	221c      	movs	r2, #28
 8018eb6:	2100      	movs	r1, #0
 8018eb8:	4618      	mov	r0, r3
 8018eba:	f00b f8d3 	bl	8024064 <memset>
  rq.ext_aci = TRUE;
 8018ebe:	2301      	movs	r3, #1
 8018ec0:	f887 3224 	strb.w	r3, [r7, #548]	@ 0x224
  rq.ogf = 0x3f;
 8018ec4:	233f      	movs	r3, #63	@ 0x3f
 8018ec6:	f8a7 3226 	strh.w	r3, [r7, #550]	@ 0x226
  rq.ocf = 0x0a5;
 8018eca:	23a5      	movs	r3, #165	@ 0xa5
 8018ecc:	f8a7 3228 	strh.w	r3, [r7, #552]	@ 0x228
  rq.cparam = cmd_buffer;
 8018ed0:	f107 0310 	add.w	r3, r7, #16
 8018ed4:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230
  rq.clen = index_input;
 8018ed8:	f897 3243 	ldrb.w	r3, [r7, #579]	@ 0x243
 8018edc:	f8c7 3234 	str.w	r3, [r7, #564]	@ 0x234
  rq.rparam = &status;
 8018ee0:	f107 030f 	add.w	r3, r7, #15
 8018ee4:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
  rq.rlen = 1;
 8018ee8:	2301      	movs	r3, #1
 8018eea:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
  if (hci_send_req(&rq, FALSE) < 0)
 8018eee:	f507 7309 	add.w	r3, r7, #548	@ 0x224
 8018ef2:	2100      	movs	r1, #0
 8018ef4:	4618      	mov	r0, r3
 8018ef6:	f002 fffb 	bl	801bef0 <hci_send_req>
 8018efa:	4603      	mov	r3, r0
 8018efc:	2b00      	cmp	r3, #0
 8018efe:	da01      	bge.n	8018f04 <aci_gap_numeric_comparison_value_confirm_yesno+0xc2>
    return BLE_STATUS_TIMEOUT;
 8018f00:	23ff      	movs	r3, #255	@ 0xff
 8018f02:	e00d      	b.n	8018f20 <aci_gap_numeric_comparison_value_confirm_yesno+0xde>
  if (status) {
 8018f04:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8018f08:	f2a3 2339 	subw	r3, r3, #569	@ 0x239
 8018f0c:	781b      	ldrb	r3, [r3, #0]
 8018f0e:	2b00      	cmp	r3, #0
 8018f10:	d005      	beq.n	8018f1e <aci_gap_numeric_comparison_value_confirm_yesno+0xdc>
    return status;
 8018f12:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8018f16:	f2a3 2339 	subw	r3, r3, #569	@ 0x239
 8018f1a:	781b      	ldrb	r3, [r3, #0]
 8018f1c:	e000      	b.n	8018f20 <aci_gap_numeric_comparison_value_confirm_yesno+0xde>
  }
  return BLE_STATUS_SUCCESS;
 8018f1e:	2300      	movs	r3, #0
}
 8018f20:	4618      	mov	r0, r3
 8018f22:	f507 7712 	add.w	r7, r7, #584	@ 0x248
 8018f26:	46bd      	mov	sp, r7
 8018f28:	bd80      	pop	{r7, pc}

08018f2a <aci_gap_configure_white_and_resolving_list>:
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
tBleStatus aci_gap_configure_white_and_resolving_list(uint8_t Lists)
{
 8018f2a:	b580      	push	{r7, lr}
 8018f2c:	f5ad 7d12 	sub.w	sp, sp, #584	@ 0x248
 8018f30:	af00      	add	r7, sp, #0
 8018f32:	4602      	mov	r2, r0
 8018f34:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8018f38:	f2a3 2341 	subw	r3, r3, #577	@ 0x241
 8018f3c:	701a      	strb	r2, [r3, #0]
  struct hci_request rq;
  uint8_t cmd_buffer[532];
  aci_gap_configure_white_and_resolving_list_cp0 *cp0 = (aci_gap_configure_white_and_resolving_list_cp0*)(cmd_buffer);
 8018f3e:	f107 0310 	add.w	r3, r7, #16
 8018f42:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
  tBleStatus status = 0;
 8018f46:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8018f4a:	f2a3 2339 	subw	r3, r3, #569	@ 0x239
 8018f4e:	2200      	movs	r2, #0
 8018f50:	701a      	strb	r2, [r3, #0]
  uint8_t index_input = 0;
 8018f52:	2300      	movs	r3, #0
 8018f54:	f887 3243 	strb.w	r3, [r7, #579]	@ 0x243
  cp0->Lists = htob(Lists, 1);
 8018f58:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 8018f5c:	f507 7212 	add.w	r2, r7, #584	@ 0x248
 8018f60:	f2a2 2241 	subw	r2, r2, #577	@ 0x241
 8018f64:	7812      	ldrb	r2, [r2, #0]
 8018f66:	701a      	strb	r2, [r3, #0]
  index_input += 1;
 8018f68:	f897 3243 	ldrb.w	r3, [r7, #579]	@ 0x243
 8018f6c:	3301      	adds	r3, #1
 8018f6e:	f887 3243 	strb.w	r3, [r7, #579]	@ 0x243
  BLUENRG_memset(&rq, 0, sizeof(rq));
 8018f72:	f507 7309 	add.w	r3, r7, #548	@ 0x224
 8018f76:	221c      	movs	r2, #28
 8018f78:	2100      	movs	r1, #0
 8018f7a:	4618      	mov	r0, r3
 8018f7c:	f00b f872 	bl	8024064 <memset>
  rq.ext_aci = TRUE;
 8018f80:	2301      	movs	r3, #1
 8018f82:	f887 3224 	strb.w	r3, [r7, #548]	@ 0x224
  rq.ogf = 0x3f;
 8018f86:	233f      	movs	r3, #63	@ 0x3f
 8018f88:	f8a7 3226 	strh.w	r3, [r7, #550]	@ 0x226
  rq.ocf = 0x0b4;
 8018f8c:	23b4      	movs	r3, #180	@ 0xb4
 8018f8e:	f8a7 3228 	strh.w	r3, [r7, #552]	@ 0x228
  rq.cparam = cmd_buffer;
 8018f92:	f107 0310 	add.w	r3, r7, #16
 8018f96:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230
  rq.clen = index_input;
 8018f9a:	f897 3243 	ldrb.w	r3, [r7, #579]	@ 0x243
 8018f9e:	f8c7 3234 	str.w	r3, [r7, #564]	@ 0x234
  rq.rparam = &status;
 8018fa2:	f107 030f 	add.w	r3, r7, #15
 8018fa6:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
  rq.rlen = 1;
 8018faa:	2301      	movs	r3, #1
 8018fac:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
  if (hci_send_req(&rq, FALSE) < 0)
 8018fb0:	f507 7309 	add.w	r3, r7, #548	@ 0x224
 8018fb4:	2100      	movs	r1, #0
 8018fb6:	4618      	mov	r0, r3
 8018fb8:	f002 ff9a 	bl	801bef0 <hci_send_req>
 8018fbc:	4603      	mov	r3, r0
 8018fbe:	2b00      	cmp	r3, #0
 8018fc0:	da01      	bge.n	8018fc6 <aci_gap_configure_white_and_resolving_list+0x9c>
    return BLE_STATUS_TIMEOUT;
 8018fc2:	23ff      	movs	r3, #255	@ 0xff
 8018fc4:	e00d      	b.n	8018fe2 <aci_gap_configure_white_and_resolving_list+0xb8>
  if (status) {
 8018fc6:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8018fca:	f2a3 2339 	subw	r3, r3, #569	@ 0x239
 8018fce:	781b      	ldrb	r3, [r3, #0]
 8018fd0:	2b00      	cmp	r3, #0
 8018fd2:	d005      	beq.n	8018fe0 <aci_gap_configure_white_and_resolving_list+0xb6>
    return status;
 8018fd4:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8018fd8:	f2a3 2339 	subw	r3, r3, #569	@ 0x239
 8018fdc:	781b      	ldrb	r3, [r3, #0]
 8018fde:	e000      	b.n	8018fe2 <aci_gap_configure_white_and_resolving_list+0xb8>
  }
  return BLE_STATUS_SUCCESS;
 8018fe0:	2300      	movs	r3, #0
}
 8018fe2:	4618      	mov	r0, r3
 8018fe4:	f507 7712 	add.w	r7, r7, #584	@ 0x248
 8018fe8:	46bd      	mov	sp, r7
 8018fea:	bd80      	pop	{r7, pc}

08018fec <aci_gatt_srv_init>:
#include "ble_types.h"
#include "bluenrg_lp_gatt_aci.h"
#include "hci_tl.h"

tBleStatus aci_gatt_srv_init(void)
{
 8018fec:	b580      	push	{r7, lr}
 8018fee:	b088      	sub	sp, #32
 8018ff0:	af00      	add	r7, sp, #0
  struct hci_request rq;
  tBleStatus status = 0;
 8018ff2:	2300      	movs	r3, #0
 8018ff4:	70fb      	strb	r3, [r7, #3]
  BLUENRG_memset(&rq, 0, sizeof(rq));
 8018ff6:	1d3b      	adds	r3, r7, #4
 8018ff8:	221c      	movs	r2, #28
 8018ffa:	2100      	movs	r1, #0
 8018ffc:	4618      	mov	r0, r3
 8018ffe:	f00b f831 	bl	8024064 <memset>
  rq.ext_aci = TRUE;
 8019002:	2301      	movs	r3, #1
 8019004:	713b      	strb	r3, [r7, #4]
  rq.ogf = 0x3f;
 8019006:	233f      	movs	r3, #63	@ 0x3f
 8019008:	80fb      	strh	r3, [r7, #6]
  rq.ocf = 0x101;
 801900a:	f240 1301 	movw	r3, #257	@ 0x101
 801900e:	813b      	strh	r3, [r7, #8]
  rq.rparam = &status;
 8019010:	1cfb      	adds	r3, r7, #3
 8019012:	61bb      	str	r3, [r7, #24]
  rq.rlen = 1;
 8019014:	2301      	movs	r3, #1
 8019016:	61fb      	str	r3, [r7, #28]
  if (hci_send_req(&rq, FALSE) < 0)
 8019018:	1d3b      	adds	r3, r7, #4
 801901a:	2100      	movs	r1, #0
 801901c:	4618      	mov	r0, r3
 801901e:	f002 ff67 	bl	801bef0 <hci_send_req>
 8019022:	4603      	mov	r3, r0
 8019024:	2b00      	cmp	r3, #0
 8019026:	da01      	bge.n	801902c <aci_gatt_srv_init+0x40>
    return BLE_STATUS_TIMEOUT;
 8019028:	23ff      	movs	r3, #255	@ 0xff
 801902a:	e005      	b.n	8019038 <aci_gatt_srv_init+0x4c>
  if (status) {
 801902c:	78fb      	ldrb	r3, [r7, #3]
 801902e:	2b00      	cmp	r3, #0
 8019030:	d001      	beq.n	8019036 <aci_gatt_srv_init+0x4a>
    return status;
 8019032:	78fb      	ldrb	r3, [r7, #3]
 8019034:	e000      	b.n	8019038 <aci_gatt_srv_init+0x4c>
  }
  return BLE_STATUS_SUCCESS;
 8019036:	2300      	movs	r3, #0
}
 8019038:	4618      	mov	r0, r3
 801903a:	3720      	adds	r7, #32
 801903c:	46bd      	mov	sp, r7
 801903e:	bd80      	pop	{r7, pc}

08019040 <aci_gatt_srv_write_handle_value_nwk>:
}
tBleStatus aci_gatt_srv_write_handle_value_nwk(uint16_t Attr_Handle,
                                               uint16_t Val_Offset,
                                               uint16_t Value_Length,
                                               uint8_t Value[])
{
 8019040:	b590      	push	{r4, r7, lr}
 8019042:	f5ad 7d15 	sub.w	sp, sp, #596	@ 0x254
 8019046:	af00      	add	r7, sp, #0
 8019048:	4604      	mov	r4, r0
 801904a:	4608      	mov	r0, r1
 801904c:	4611      	mov	r1, r2
 801904e:	f507 7214 	add.w	r2, r7, #592	@ 0x250
 8019052:	f5a2 7213 	sub.w	r2, r2, #588	@ 0x24c
 8019056:	6013      	str	r3, [r2, #0]
 8019058:	f507 7314 	add.w	r3, r7, #592	@ 0x250
 801905c:	f2a3 2342 	subw	r3, r3, #578	@ 0x242
 8019060:	4622      	mov	r2, r4
 8019062:	801a      	strh	r2, [r3, #0]
 8019064:	f507 7314 	add.w	r3, r7, #592	@ 0x250
 8019068:	f5a3 7311 	sub.w	r3, r3, #580	@ 0x244
 801906c:	4602      	mov	r2, r0
 801906e:	801a      	strh	r2, [r3, #0]
 8019070:	f507 7314 	add.w	r3, r7, #592	@ 0x250
 8019074:	f2a3 2346 	subw	r3, r3, #582	@ 0x246
 8019078:	460a      	mov	r2, r1
 801907a:	801a      	strh	r2, [r3, #0]
  struct hci_request rq;
  uint8_t cmd_buffer[532];
  aci_gatt_srv_write_handle_value_nwk_cp0 *cp0 = (aci_gatt_srv_write_handle_value_nwk_cp0*)(cmd_buffer);
 801907c:	f107 0318 	add.w	r3, r7, #24
 8019080:	f8c7 324c 	str.w	r3, [r7, #588]	@ 0x24c
  tBleStatus status = 0;
 8019084:	f507 7314 	add.w	r3, r7, #592	@ 0x250
 8019088:	f2a3 2339 	subw	r3, r3, #569	@ 0x239
 801908c:	2200      	movs	r2, #0
 801908e:	701a      	strb	r2, [r3, #0]
  uint8_t index_input = 0;
 8019090:	2300      	movs	r3, #0
 8019092:	f887 324b 	strb.w	r3, [r7, #587]	@ 0x24b
  cp0->Attr_Handle = htob(Attr_Handle, 2);
 8019096:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 801909a:	f507 7214 	add.w	r2, r7, #592	@ 0x250
 801909e:	f2a2 2242 	subw	r2, r2, #578	@ 0x242
 80190a2:	8812      	ldrh	r2, [r2, #0]
 80190a4:	801a      	strh	r2, [r3, #0]
  index_input += 2;
 80190a6:	f897 324b 	ldrb.w	r3, [r7, #587]	@ 0x24b
 80190aa:	3302      	adds	r3, #2
 80190ac:	f887 324b 	strb.w	r3, [r7, #587]	@ 0x24b
  cp0->Val_Offset = htob(Val_Offset, 2);
 80190b0:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 80190b4:	f507 7214 	add.w	r2, r7, #592	@ 0x250
 80190b8:	f5a2 7211 	sub.w	r2, r2, #580	@ 0x244
 80190bc:	8812      	ldrh	r2, [r2, #0]
 80190be:	805a      	strh	r2, [r3, #2]
  index_input += 2;
 80190c0:	f897 324b 	ldrb.w	r3, [r7, #587]	@ 0x24b
 80190c4:	3302      	adds	r3, #2
 80190c6:	f887 324b 	strb.w	r3, [r7, #587]	@ 0x24b
  cp0->Value_Length = htob(Value_Length, 2);
 80190ca:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 80190ce:	f507 7214 	add.w	r2, r7, #592	@ 0x250
 80190d2:	f2a2 2246 	subw	r2, r2, #582	@ 0x246
 80190d6:	8812      	ldrh	r2, [r2, #0]
 80190d8:	809a      	strh	r2, [r3, #4]
  index_input += 2;
 80190da:	f897 324b 	ldrb.w	r3, [r7, #587]	@ 0x24b
 80190de:	3302      	adds	r3, #2
 80190e0:	f887 324b 	strb.w	r3, [r7, #587]	@ 0x24b
  /* var_len_data input */
  {
    BLUENRG_memcpy((void *) &cp0->Value, (const void *) Value, Value_Length*sizeof(uint8_t));
 80190e4:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 80190e8:	1d98      	adds	r0, r3, #6
 80190ea:	f507 7314 	add.w	r3, r7, #592	@ 0x250
 80190ee:	f2a3 2346 	subw	r3, r3, #582	@ 0x246
 80190f2:	881a      	ldrh	r2, [r3, #0]
 80190f4:	f507 7314 	add.w	r3, r7, #592	@ 0x250
 80190f8:	f5a3 7313 	sub.w	r3, r3, #588	@ 0x24c
 80190fc:	6819      	ldr	r1, [r3, #0]
 80190fe:	f00b f876 	bl	80241ee <memcpy>
    index_input += Value_Length*sizeof(uint8_t);
 8019102:	f507 7314 	add.w	r3, r7, #592	@ 0x250
 8019106:	f2a3 2346 	subw	r3, r3, #582	@ 0x246
 801910a:	881b      	ldrh	r3, [r3, #0]
 801910c:	b2da      	uxtb	r2, r3
 801910e:	f897 324b 	ldrb.w	r3, [r7, #587]	@ 0x24b
 8019112:	4413      	add	r3, r2
 8019114:	f887 324b 	strb.w	r3, [r7, #587]	@ 0x24b
  }
  BLUENRG_memset(&rq, 0, sizeof(rq));
 8019118:	f507 730b 	add.w	r3, r7, #556	@ 0x22c
 801911c:	221c      	movs	r2, #28
 801911e:	2100      	movs	r1, #0
 8019120:	4618      	mov	r0, r3
 8019122:	f00a ff9f 	bl	8024064 <memset>
  rq.ext_aci = TRUE;
 8019126:	2301      	movs	r3, #1
 8019128:	f887 322c 	strb.w	r3, [r7, #556]	@ 0x22c
  rq.ogf = 0x3f;
 801912c:	233f      	movs	r3, #63	@ 0x3f
 801912e:	f8a7 322e 	strh.w	r3, [r7, #558]	@ 0x22e
  rq.ocf = 0x106;
 8019132:	f44f 7383 	mov.w	r3, #262	@ 0x106
 8019136:	f8a7 3230 	strh.w	r3, [r7, #560]	@ 0x230
  rq.cparam = cmd_buffer;
 801913a:	f107 0318 	add.w	r3, r7, #24
 801913e:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
  rq.clen = index_input;
 8019142:	f897 324b 	ldrb.w	r3, [r7, #587]	@ 0x24b
 8019146:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
  rq.rparam = &status;
 801914a:	f107 0317 	add.w	r3, r7, #23
 801914e:	f8c7 3240 	str.w	r3, [r7, #576]	@ 0x240
  rq.rlen = 1;
 8019152:	2301      	movs	r3, #1
 8019154:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
  if (hci_send_req(&rq, FALSE) < 0)
 8019158:	f507 730b 	add.w	r3, r7, #556	@ 0x22c
 801915c:	2100      	movs	r1, #0
 801915e:	4618      	mov	r0, r3
 8019160:	f002 fec6 	bl	801bef0 <hci_send_req>
 8019164:	4603      	mov	r3, r0
 8019166:	2b00      	cmp	r3, #0
 8019168:	da01      	bge.n	801916e <aci_gatt_srv_write_handle_value_nwk+0x12e>
    return BLE_STATUS_TIMEOUT;
 801916a:	23ff      	movs	r3, #255	@ 0xff
 801916c:	e00d      	b.n	801918a <aci_gatt_srv_write_handle_value_nwk+0x14a>
  if (status) {
 801916e:	f507 7314 	add.w	r3, r7, #592	@ 0x250
 8019172:	f2a3 2339 	subw	r3, r3, #569	@ 0x239
 8019176:	781b      	ldrb	r3, [r3, #0]
 8019178:	2b00      	cmp	r3, #0
 801917a:	d005      	beq.n	8019188 <aci_gatt_srv_write_handle_value_nwk+0x148>
    return status;
 801917c:	f507 7314 	add.w	r3, r7, #592	@ 0x250
 8019180:	f2a3 2339 	subw	r3, r3, #569	@ 0x239
 8019184:	781b      	ldrb	r3, [r3, #0]
 8019186:	e000      	b.n	801918a <aci_gatt_srv_write_handle_value_nwk+0x14a>
  }
  return BLE_STATUS_SUCCESS;
 8019188:	2300      	movs	r3, #0
}
 801918a:	4618      	mov	r0, r3
 801918c:	f507 7715 	add.w	r7, r7, #596	@ 0x254
 8019190:	46bd      	mov	sp, r7
 8019192:	bd90      	pop	{r4, r7, pc}

08019194 <aci_gatt_clt_exchange_config>:
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
tBleStatus aci_gatt_clt_exchange_config(uint16_t Connection_Handle)
{
 8019194:	b580      	push	{r7, lr}
 8019196:	f5ad 7d12 	sub.w	sp, sp, #584	@ 0x248
 801919a:	af00      	add	r7, sp, #0
 801919c:	4602      	mov	r2, r0
 801919e:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 80191a2:	f2a3 2342 	subw	r3, r3, #578	@ 0x242
 80191a6:	801a      	strh	r2, [r3, #0]
  struct hci_request rq;
  uint8_t cmd_buffer[532];
  aci_gatt_clt_exchange_config_cp0 *cp0 = (aci_gatt_clt_exchange_config_cp0*)(cmd_buffer);
 80191a8:	f107 0310 	add.w	r3, r7, #16
 80191ac:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
  tBleStatus status = 0;
 80191b0:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 80191b4:	f2a3 2339 	subw	r3, r3, #569	@ 0x239
 80191b8:	2200      	movs	r2, #0
 80191ba:	701a      	strb	r2, [r3, #0]
  uint8_t index_input = 0;
 80191bc:	2300      	movs	r3, #0
 80191be:	f887 3243 	strb.w	r3, [r7, #579]	@ 0x243
  cp0->Connection_Handle = htob(Connection_Handle, 2);
 80191c2:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 80191c6:	f507 7212 	add.w	r2, r7, #584	@ 0x248
 80191ca:	f2a2 2242 	subw	r2, r2, #578	@ 0x242
 80191ce:	8812      	ldrh	r2, [r2, #0]
 80191d0:	801a      	strh	r2, [r3, #0]
  index_input += 2;
 80191d2:	f897 3243 	ldrb.w	r3, [r7, #579]	@ 0x243
 80191d6:	3302      	adds	r3, #2
 80191d8:	f887 3243 	strb.w	r3, [r7, #579]	@ 0x243
  BLUENRG_memset(&rq, 0, sizeof(rq));
 80191dc:	f507 7309 	add.w	r3, r7, #548	@ 0x224
 80191e0:	221c      	movs	r2, #28
 80191e2:	2100      	movs	r1, #0
 80191e4:	4618      	mov	r0, r3
 80191e6:	f00a ff3d 	bl	8024064 <memset>
  rq.ext_aci = TRUE;
 80191ea:	2301      	movs	r3, #1
 80191ec:	f887 3224 	strb.w	r3, [r7, #548]	@ 0x224
  rq.ogf = 0x3f;
 80191f0:	233f      	movs	r3, #63	@ 0x3f
 80191f2:	f8a7 3226 	strh.w	r3, [r7, #550]	@ 0x226
  rq.ocf = 0x10b;
 80191f6:	f240 130b 	movw	r3, #267	@ 0x10b
 80191fa:	f8a7 3228 	strh.w	r3, [r7, #552]	@ 0x228
  rq.event = 0x0F;
 80191fe:	230f      	movs	r3, #15
 8019200:	f8c7 322c 	str.w	r3, [r7, #556]	@ 0x22c
  rq.cparam = cmd_buffer;
 8019204:	f107 0310 	add.w	r3, r7, #16
 8019208:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230
  rq.clen = index_input;
 801920c:	f897 3243 	ldrb.w	r3, [r7, #579]	@ 0x243
 8019210:	f8c7 3234 	str.w	r3, [r7, #564]	@ 0x234
  rq.rparam = &status;
 8019214:	f107 030f 	add.w	r3, r7, #15
 8019218:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
  rq.rlen = 1;
 801921c:	2301      	movs	r3, #1
 801921e:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
  if (hci_send_req(&rq, FALSE) < 0)
 8019222:	f507 7309 	add.w	r3, r7, #548	@ 0x224
 8019226:	2100      	movs	r1, #0
 8019228:	4618      	mov	r0, r3
 801922a:	f002 fe61 	bl	801bef0 <hci_send_req>
 801922e:	4603      	mov	r3, r0
 8019230:	2b00      	cmp	r3, #0
 8019232:	da01      	bge.n	8019238 <aci_gatt_clt_exchange_config+0xa4>
    return BLE_STATUS_TIMEOUT;
 8019234:	23ff      	movs	r3, #255	@ 0xff
 8019236:	e00d      	b.n	8019254 <aci_gatt_clt_exchange_config+0xc0>
  if (status) {
 8019238:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 801923c:	f2a3 2339 	subw	r3, r3, #569	@ 0x239
 8019240:	781b      	ldrb	r3, [r3, #0]
 8019242:	2b00      	cmp	r3, #0
 8019244:	d005      	beq.n	8019252 <aci_gatt_clt_exchange_config+0xbe>
    return status;
 8019246:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 801924a:	f2a3 2339 	subw	r3, r3, #569	@ 0x239
 801924e:	781b      	ldrb	r3, [r3, #0]
 8019250:	e000      	b.n	8019254 <aci_gatt_clt_exchange_config+0xc0>
  }
  return BLE_STATUS_SUCCESS;
 8019252:	2300      	movs	r3, #0
}
 8019254:	4618      	mov	r0, r3
 8019256:	f507 7712 	add.w	r7, r7, #584	@ 0x248
 801925a:	46bd      	mov	sp, r7
 801925c:	bd80      	pop	{r7, pc}

0801925e <aci_gatt_clt_confirm_indication>:
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
tBleStatus aci_gatt_clt_confirm_indication(uint16_t Connection_Handle)
{
 801925e:	b580      	push	{r7, lr}
 8019260:	f5ad 7d12 	sub.w	sp, sp, #584	@ 0x248
 8019264:	af00      	add	r7, sp, #0
 8019266:	4602      	mov	r2, r0
 8019268:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 801926c:	f2a3 2342 	subw	r3, r3, #578	@ 0x242
 8019270:	801a      	strh	r2, [r3, #0]
  struct hci_request rq;
  uint8_t cmd_buffer[532];
  aci_gatt_clt_confirm_indication_cp0 *cp0 = (aci_gatt_clt_confirm_indication_cp0*)(cmd_buffer);
 8019272:	f107 0310 	add.w	r3, r7, #16
 8019276:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
  tBleStatus status = 0;
 801927a:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 801927e:	f2a3 2339 	subw	r3, r3, #569	@ 0x239
 8019282:	2200      	movs	r2, #0
 8019284:	701a      	strb	r2, [r3, #0]
  uint8_t index_input = 0;
 8019286:	2300      	movs	r3, #0
 8019288:	f887 3243 	strb.w	r3, [r7, #579]	@ 0x243
  cp0->Connection_Handle = htob(Connection_Handle, 2);
 801928c:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 8019290:	f507 7212 	add.w	r2, r7, #584	@ 0x248
 8019294:	f2a2 2242 	subw	r2, r2, #578	@ 0x242
 8019298:	8812      	ldrh	r2, [r2, #0]
 801929a:	801a      	strh	r2, [r3, #0]
  index_input += 2;
 801929c:	f897 3243 	ldrb.w	r3, [r7, #579]	@ 0x243
 80192a0:	3302      	adds	r3, #2
 80192a2:	f887 3243 	strb.w	r3, [r7, #579]	@ 0x243
  BLUENRG_memset(&rq, 0, sizeof(rq));
 80192a6:	f507 7309 	add.w	r3, r7, #548	@ 0x224
 80192aa:	221c      	movs	r2, #28
 80192ac:	2100      	movs	r1, #0
 80192ae:	4618      	mov	r0, r3
 80192b0:	f00a fed8 	bl	8024064 <memset>
  rq.ext_aci = TRUE;
 80192b4:	2301      	movs	r3, #1
 80192b6:	f887 3224 	strb.w	r3, [r7, #548]	@ 0x224
  rq.ogf = 0x3f;
 80192ba:	233f      	movs	r3, #63	@ 0x3f
 80192bc:	f8a7 3226 	strh.w	r3, [r7, #550]	@ 0x226
  rq.ocf = 0x125;
 80192c0:	f240 1325 	movw	r3, #293	@ 0x125
 80192c4:	f8a7 3228 	strh.w	r3, [r7, #552]	@ 0x228
  rq.cparam = cmd_buffer;
 80192c8:	f107 0310 	add.w	r3, r7, #16
 80192cc:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230
  rq.clen = index_input;
 80192d0:	f897 3243 	ldrb.w	r3, [r7, #579]	@ 0x243
 80192d4:	f8c7 3234 	str.w	r3, [r7, #564]	@ 0x234
  rq.rparam = &status;
 80192d8:	f107 030f 	add.w	r3, r7, #15
 80192dc:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
  rq.rlen = 1;
 80192e0:	2301      	movs	r3, #1
 80192e2:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
  if (hci_send_req(&rq, FALSE) < 0)
 80192e6:	f507 7309 	add.w	r3, r7, #548	@ 0x224
 80192ea:	2100      	movs	r1, #0
 80192ec:	4618      	mov	r0, r3
 80192ee:	f002 fdff 	bl	801bef0 <hci_send_req>
 80192f2:	4603      	mov	r3, r0
 80192f4:	2b00      	cmp	r3, #0
 80192f6:	da01      	bge.n	80192fc <aci_gatt_clt_confirm_indication+0x9e>
    return BLE_STATUS_TIMEOUT;
 80192f8:	23ff      	movs	r3, #255	@ 0xff
 80192fa:	e00d      	b.n	8019318 <aci_gatt_clt_confirm_indication+0xba>
  if (status) {
 80192fc:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8019300:	f2a3 2339 	subw	r3, r3, #569	@ 0x239
 8019304:	781b      	ldrb	r3, [r3, #0]
 8019306:	2b00      	cmp	r3, #0
 8019308:	d005      	beq.n	8019316 <aci_gatt_clt_confirm_indication+0xb8>
    return status;
 801930a:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 801930e:	f2a3 2339 	subw	r3, r3, #569	@ 0x239
 8019312:	781b      	ldrb	r3, [r3, #0]
 8019314:	e000      	b.n	8019318 <aci_gatt_clt_confirm_indication+0xba>
  }
  return BLE_STATUS_SUCCESS;
 8019316:	2300      	movs	r3, #0
}
 8019318:	4618      	mov	r0, r3
 801931a:	f507 7712 	add.w	r7, r7, #584	@ 0x248
 801931e:	46bd      	mov	sp, r7
 8019320:	bd80      	pop	{r7, pc}

08019322 <aci_gatt_srv_notify>:
tBleStatus aci_gatt_srv_notify(uint16_t Connection_Handle,
                               uint16_t Attr_Handle,
                               uint8_t Flags,
                               uint16_t Val_Length,
                               uint8_t Val[])
{
 8019322:	b5b0      	push	{r4, r5, r7, lr}
 8019324:	f5ad 7d12 	sub.w	sp, sp, #584	@ 0x248
 8019328:	af00      	add	r7, sp, #0
 801932a:	4605      	mov	r5, r0
 801932c:	460c      	mov	r4, r1
 801932e:	4610      	mov	r0, r2
 8019330:	4619      	mov	r1, r3
 8019332:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8019336:	f2a3 2342 	subw	r3, r3, #578	@ 0x242
 801933a:	462a      	mov	r2, r5
 801933c:	801a      	strh	r2, [r3, #0]
 801933e:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8019342:	f5a3 7311 	sub.w	r3, r3, #580	@ 0x244
 8019346:	4622      	mov	r2, r4
 8019348:	801a      	strh	r2, [r3, #0]
 801934a:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 801934e:	f2a3 2345 	subw	r3, r3, #581	@ 0x245
 8019352:	4602      	mov	r2, r0
 8019354:	701a      	strb	r2, [r3, #0]
 8019356:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 801935a:	f5a3 7312 	sub.w	r3, r3, #584	@ 0x248
 801935e:	460a      	mov	r2, r1
 8019360:	801a      	strh	r2, [r3, #0]
  struct hci_request rq;
  uint8_t cmd_buffer[532];
  aci_gatt_srv_notify_cp0 *cp0 = (aci_gatt_srv_notify_cp0*)(cmd_buffer);
 8019362:	f107 0310 	add.w	r3, r7, #16
 8019366:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
  tBleStatus status = 0;
 801936a:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 801936e:	f2a3 2339 	subw	r3, r3, #569	@ 0x239
 8019372:	2200      	movs	r2, #0
 8019374:	701a      	strb	r2, [r3, #0]
  uint8_t index_input = 0;
 8019376:	2300      	movs	r3, #0
 8019378:	f887 3243 	strb.w	r3, [r7, #579]	@ 0x243
  cp0->Connection_Handle = htob(Connection_Handle, 2);
 801937c:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 8019380:	f507 7212 	add.w	r2, r7, #584	@ 0x248
 8019384:	f2a2 2242 	subw	r2, r2, #578	@ 0x242
 8019388:	8812      	ldrh	r2, [r2, #0]
 801938a:	801a      	strh	r2, [r3, #0]
  index_input += 2;
 801938c:	f897 3243 	ldrb.w	r3, [r7, #579]	@ 0x243
 8019390:	3302      	adds	r3, #2
 8019392:	f887 3243 	strb.w	r3, [r7, #579]	@ 0x243
  cp0->Attr_Handle = htob(Attr_Handle, 2);
 8019396:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 801939a:	f507 7212 	add.w	r2, r7, #584	@ 0x248
 801939e:	f5a2 7211 	sub.w	r2, r2, #580	@ 0x244
 80193a2:	8812      	ldrh	r2, [r2, #0]
 80193a4:	805a      	strh	r2, [r3, #2]
  index_input += 2;
 80193a6:	f897 3243 	ldrb.w	r3, [r7, #579]	@ 0x243
 80193aa:	3302      	adds	r3, #2
 80193ac:	f887 3243 	strb.w	r3, [r7, #579]	@ 0x243
  cp0->Flags = htob(Flags, 1);
 80193b0:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 80193b4:	f507 7212 	add.w	r2, r7, #584	@ 0x248
 80193b8:	f2a2 2245 	subw	r2, r2, #581	@ 0x245
 80193bc:	7812      	ldrb	r2, [r2, #0]
 80193be:	711a      	strb	r2, [r3, #4]
  index_input += 1;
 80193c0:	f897 3243 	ldrb.w	r3, [r7, #579]	@ 0x243
 80193c4:	3301      	adds	r3, #1
 80193c6:	f887 3243 	strb.w	r3, [r7, #579]	@ 0x243
  cp0->Val_Length = htob(Val_Length, 2);
 80193ca:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 80193ce:	f507 7212 	add.w	r2, r7, #584	@ 0x248
 80193d2:	f5a2 7212 	sub.w	r2, r2, #584	@ 0x248
 80193d6:	8812      	ldrh	r2, [r2, #0]
 80193d8:	f8a3 2005 	strh.w	r2, [r3, #5]
  index_input += 2;
 80193dc:	f897 3243 	ldrb.w	r3, [r7, #579]	@ 0x243
 80193e0:	3302      	adds	r3, #2
 80193e2:	f887 3243 	strb.w	r3, [r7, #579]	@ 0x243
  /* var_len_data input */
  {
    BLUENRG_memcpy((void *) &cp0->Val, (const void *) Val, Val_Length*sizeof(uint8_t));
 80193e6:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 80193ea:	1dd8      	adds	r0, r3, #7
 80193ec:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 80193f0:	f5a3 7312 	sub.w	r3, r3, #584	@ 0x248
 80193f4:	881b      	ldrh	r3, [r3, #0]
 80193f6:	461a      	mov	r2, r3
 80193f8:	f8d7 1258 	ldr.w	r1, [r7, #600]	@ 0x258
 80193fc:	f00a fef7 	bl	80241ee <memcpy>
    index_input += Val_Length*sizeof(uint8_t);
 8019400:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8019404:	f5a3 7312 	sub.w	r3, r3, #584	@ 0x248
 8019408:	881b      	ldrh	r3, [r3, #0]
 801940a:	b2da      	uxtb	r2, r3
 801940c:	f897 3243 	ldrb.w	r3, [r7, #579]	@ 0x243
 8019410:	4413      	add	r3, r2
 8019412:	f887 3243 	strb.w	r3, [r7, #579]	@ 0x243
  }
  BLUENRG_memset(&rq, 0, sizeof(rq));
 8019416:	f507 7309 	add.w	r3, r7, #548	@ 0x224
 801941a:	221c      	movs	r2, #28
 801941c:	2100      	movs	r1, #0
 801941e:	4618      	mov	r0, r3
 8019420:	f00a fe20 	bl	8024064 <memset>
  rq.ext_aci = TRUE;
 8019424:	2301      	movs	r3, #1
 8019426:	f887 3224 	strb.w	r3, [r7, #548]	@ 0x224
  rq.ogf = 0x3f;
 801942a:	233f      	movs	r3, #63	@ 0x3f
 801942c:	f8a7 3226 	strh.w	r3, [r7, #550]	@ 0x226
  rq.ocf = 0x12f;
 8019430:	f240 132f 	movw	r3, #303	@ 0x12f
 8019434:	f8a7 3228 	strh.w	r3, [r7, #552]	@ 0x228
  rq.cparam = cmd_buffer;
 8019438:	f107 0310 	add.w	r3, r7, #16
 801943c:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230
  rq.clen = index_input;
 8019440:	f897 3243 	ldrb.w	r3, [r7, #579]	@ 0x243
 8019444:	f8c7 3234 	str.w	r3, [r7, #564]	@ 0x234
  rq.rparam = &status;
 8019448:	f107 030f 	add.w	r3, r7, #15
 801944c:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
  rq.rlen = 1;
 8019450:	2301      	movs	r3, #1
 8019452:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
  if (hci_send_req(&rq, FALSE) < 0)
 8019456:	f507 7309 	add.w	r3, r7, #548	@ 0x224
 801945a:	2100      	movs	r1, #0
 801945c:	4618      	mov	r0, r3
 801945e:	f002 fd47 	bl	801bef0 <hci_send_req>
 8019462:	4603      	mov	r3, r0
 8019464:	2b00      	cmp	r3, #0
 8019466:	da01      	bge.n	801946c <aci_gatt_srv_notify+0x14a>
    return BLE_STATUS_TIMEOUT;
 8019468:	23ff      	movs	r3, #255	@ 0xff
 801946a:	e00d      	b.n	8019488 <aci_gatt_srv_notify+0x166>
  if (status) {
 801946c:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8019470:	f2a3 2339 	subw	r3, r3, #569	@ 0x239
 8019474:	781b      	ldrb	r3, [r3, #0]
 8019476:	2b00      	cmp	r3, #0
 8019478:	d005      	beq.n	8019486 <aci_gatt_srv_notify+0x164>
    return status;
 801947a:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 801947e:	f2a3 2339 	subw	r3, r3, #569	@ 0x239
 8019482:	781b      	ldrb	r3, [r3, #0]
 8019484:	e000      	b.n	8019488 <aci_gatt_srv_notify+0x166>
  }
  return BLE_STATUS_SUCCESS;
 8019486:	2300      	movs	r3, #0
}
 8019488:	4618      	mov	r0, r3
 801948a:	f507 7712 	add.w	r7, r7, #584	@ 0x248
 801948e:	46bd      	mov	sp, r7
 8019490:	bdb0      	pop	{r4, r5, r7, pc}

08019492 <aci_gatt_srv_authorize_resp_nwk>:
                                           uint8_t Operation_Type,
                                           uint8_t Error_Code,
                                           uint16_t Attr_Val_Offset,
                                           uint16_t Data_Length,
                                           uint8_t Data[])
{
 8019492:	b5b0      	push	{r4, r5, r7, lr}
 8019494:	f5ad 7d12 	sub.w	sp, sp, #584	@ 0x248
 8019498:	af00      	add	r7, sp, #0
 801949a:	4605      	mov	r5, r0
 801949c:	460c      	mov	r4, r1
 801949e:	4610      	mov	r0, r2
 80194a0:	4619      	mov	r1, r3
 80194a2:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 80194a6:	f2a3 2342 	subw	r3, r3, #578	@ 0x242
 80194aa:	462a      	mov	r2, r5
 80194ac:	801a      	strh	r2, [r3, #0]
 80194ae:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 80194b2:	f5a3 7311 	sub.w	r3, r3, #580	@ 0x244
 80194b6:	4622      	mov	r2, r4
 80194b8:	801a      	strh	r2, [r3, #0]
 80194ba:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 80194be:	f2a3 2345 	subw	r3, r3, #581	@ 0x245
 80194c2:	4602      	mov	r2, r0
 80194c4:	701a      	strb	r2, [r3, #0]
 80194c6:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 80194ca:	f2a3 2346 	subw	r3, r3, #582	@ 0x246
 80194ce:	460a      	mov	r2, r1
 80194d0:	701a      	strb	r2, [r3, #0]
  struct hci_request rq;
  uint8_t cmd_buffer[532];
  aci_gatt_srv_authorize_resp_nwk_cp0 *cp0 = (aci_gatt_srv_authorize_resp_nwk_cp0*)(cmd_buffer);
 80194d2:	f107 0310 	add.w	r3, r7, #16
 80194d6:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
  tBleStatus status = 0;
 80194da:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 80194de:	f2a3 2339 	subw	r3, r3, #569	@ 0x239
 80194e2:	2200      	movs	r2, #0
 80194e4:	701a      	strb	r2, [r3, #0]
  uint8_t index_input = 0;
 80194e6:	2300      	movs	r3, #0
 80194e8:	f887 3243 	strb.w	r3, [r7, #579]	@ 0x243
  cp0->Conn_Handle = htob(Conn_Handle, 2);
 80194ec:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 80194f0:	f507 7212 	add.w	r2, r7, #584	@ 0x248
 80194f4:	f2a2 2242 	subw	r2, r2, #578	@ 0x242
 80194f8:	8812      	ldrh	r2, [r2, #0]
 80194fa:	801a      	strh	r2, [r3, #0]
  index_input += 2;
 80194fc:	f897 3243 	ldrb.w	r3, [r7, #579]	@ 0x243
 8019500:	3302      	adds	r3, #2
 8019502:	f887 3243 	strb.w	r3, [r7, #579]	@ 0x243
  cp0->Attr_Handle = htob(Attr_Handle, 2);
 8019506:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 801950a:	f507 7212 	add.w	r2, r7, #584	@ 0x248
 801950e:	f5a2 7211 	sub.w	r2, r2, #580	@ 0x244
 8019512:	8812      	ldrh	r2, [r2, #0]
 8019514:	805a      	strh	r2, [r3, #2]
  index_input += 2;
 8019516:	f897 3243 	ldrb.w	r3, [r7, #579]	@ 0x243
 801951a:	3302      	adds	r3, #2
 801951c:	f887 3243 	strb.w	r3, [r7, #579]	@ 0x243
  cp0->Operation_Type = htob(Operation_Type, 1);
 8019520:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 8019524:	f507 7212 	add.w	r2, r7, #584	@ 0x248
 8019528:	f2a2 2245 	subw	r2, r2, #581	@ 0x245
 801952c:	7812      	ldrb	r2, [r2, #0]
 801952e:	711a      	strb	r2, [r3, #4]
  index_input += 1;
 8019530:	f897 3243 	ldrb.w	r3, [r7, #579]	@ 0x243
 8019534:	3301      	adds	r3, #1
 8019536:	f887 3243 	strb.w	r3, [r7, #579]	@ 0x243
  cp0->Error_Code = htob(Error_Code, 1);
 801953a:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 801953e:	f507 7212 	add.w	r2, r7, #584	@ 0x248
 8019542:	f2a2 2246 	subw	r2, r2, #582	@ 0x246
 8019546:	7812      	ldrb	r2, [r2, #0]
 8019548:	715a      	strb	r2, [r3, #5]
  index_input += 1;
 801954a:	f897 3243 	ldrb.w	r3, [r7, #579]	@ 0x243
 801954e:	3301      	adds	r3, #1
 8019550:	f887 3243 	strb.w	r3, [r7, #579]	@ 0x243
  cp0->Attr_Val_Offset = htob(Attr_Val_Offset, 2);
 8019554:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 8019558:	f8b7 2258 	ldrh.w	r2, [r7, #600]	@ 0x258
 801955c:	80da      	strh	r2, [r3, #6]
  index_input += 2;
 801955e:	f897 3243 	ldrb.w	r3, [r7, #579]	@ 0x243
 8019562:	3302      	adds	r3, #2
 8019564:	f887 3243 	strb.w	r3, [r7, #579]	@ 0x243
  cp0->Data_Length = htob(Data_Length, 2);
 8019568:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 801956c:	f8b7 225c 	ldrh.w	r2, [r7, #604]	@ 0x25c
 8019570:	811a      	strh	r2, [r3, #8]
  index_input += 2;
 8019572:	f897 3243 	ldrb.w	r3, [r7, #579]	@ 0x243
 8019576:	3302      	adds	r3, #2
 8019578:	f887 3243 	strb.w	r3, [r7, #579]	@ 0x243
  /* var_len_data input */
  {
    BLUENRG_memcpy((void *) &cp0->Data, (const void *) Data, Data_Length*sizeof(uint8_t));
 801957c:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 8019580:	330a      	adds	r3, #10
 8019582:	f8b7 225c 	ldrh.w	r2, [r7, #604]	@ 0x25c
 8019586:	f8d7 1260 	ldr.w	r1, [r7, #608]	@ 0x260
 801958a:	4618      	mov	r0, r3
 801958c:	f00a fe2f 	bl	80241ee <memcpy>
    index_input += Data_Length*sizeof(uint8_t);
 8019590:	f8b7 325c 	ldrh.w	r3, [r7, #604]	@ 0x25c
 8019594:	b2da      	uxtb	r2, r3
 8019596:	f897 3243 	ldrb.w	r3, [r7, #579]	@ 0x243
 801959a:	4413      	add	r3, r2
 801959c:	f887 3243 	strb.w	r3, [r7, #579]	@ 0x243
  }
  BLUENRG_memset(&rq, 0, sizeof(rq));
 80195a0:	f507 7309 	add.w	r3, r7, #548	@ 0x224
 80195a4:	221c      	movs	r2, #28
 80195a6:	2100      	movs	r1, #0
 80195a8:	4618      	mov	r0, r3
 80195aa:	f00a fd5b 	bl	8024064 <memset>
  rq.ext_aci = TRUE;
 80195ae:	2301      	movs	r3, #1
 80195b0:	f887 3224 	strb.w	r3, [r7, #548]	@ 0x224
  rq.ogf = 0x3f;
 80195b4:	233f      	movs	r3, #63	@ 0x3f
 80195b6:	f8a7 3226 	strh.w	r3, [r7, #550]	@ 0x226
  rq.ocf = 0x133;
 80195ba:	f240 1333 	movw	r3, #307	@ 0x133
 80195be:	f8a7 3228 	strh.w	r3, [r7, #552]	@ 0x228
  rq.event = 0x0F;
 80195c2:	230f      	movs	r3, #15
 80195c4:	f8c7 322c 	str.w	r3, [r7, #556]	@ 0x22c
  rq.cparam = cmd_buffer;
 80195c8:	f107 0310 	add.w	r3, r7, #16
 80195cc:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230
  rq.clen = index_input;
 80195d0:	f897 3243 	ldrb.w	r3, [r7, #579]	@ 0x243
 80195d4:	f8c7 3234 	str.w	r3, [r7, #564]	@ 0x234
  rq.rparam = &status;
 80195d8:	f107 030f 	add.w	r3, r7, #15
 80195dc:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
  rq.rlen = 1;
 80195e0:	2301      	movs	r3, #1
 80195e2:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
  if (hci_send_req(&rq, FALSE) < 0)
 80195e6:	f507 7309 	add.w	r3, r7, #548	@ 0x224
 80195ea:	2100      	movs	r1, #0
 80195ec:	4618      	mov	r0, r3
 80195ee:	f002 fc7f 	bl	801bef0 <hci_send_req>
 80195f2:	4603      	mov	r3, r0
 80195f4:	2b00      	cmp	r3, #0
 80195f6:	da01      	bge.n	80195fc <aci_gatt_srv_authorize_resp_nwk+0x16a>
    return BLE_STATUS_TIMEOUT;
 80195f8:	23ff      	movs	r3, #255	@ 0xff
 80195fa:	e00d      	b.n	8019618 <aci_gatt_srv_authorize_resp_nwk+0x186>
  if (status) {
 80195fc:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8019600:	f2a3 2339 	subw	r3, r3, #569	@ 0x239
 8019604:	781b      	ldrb	r3, [r3, #0]
 8019606:	2b00      	cmp	r3, #0
 8019608:	d005      	beq.n	8019616 <aci_gatt_srv_authorize_resp_nwk+0x184>
    return status;
 801960a:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 801960e:	f2a3 2339 	subw	r3, r3, #569	@ 0x239
 8019612:	781b      	ldrb	r3, [r3, #0]
 8019614:	e000      	b.n	8019618 <aci_gatt_srv_authorize_resp_nwk+0x186>
  }
  return BLE_STATUS_SUCCESS;
 8019616:	2300      	movs	r3, #0
}
 8019618:	4618      	mov	r0, r3
 801961a:	f507 7712 	add.w	r7, r7, #584	@ 0x248
 801961e:	46bd      	mov	sp, r7
 8019620:	bdb0      	pop	{r4, r5, r7, pc}

08019622 <hci_disconnection_complete_event_process>:
 * @param Reason Reason for disconnection. See Error Codes.
 * @retval None
 */

tBleStatus hci_disconnection_complete_event_process(uint8_t *buffer_in)
{
 8019622:	b580      	push	{r7, lr}
 8019624:	b084      	sub	sp, #16
 8019626:	af00      	add	r7, sp, #0
 8019628:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 801962a:	2300      	movs	r3, #0
 801962c:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  hci_disconnection_complete_event_rp0 *rp0 = (hci_disconnection_complete_event_rp0 *)buffer_in;
 801962e:	687b      	ldr	r3, [r7, #4]
 8019630:	60bb      	str	r3, [r7, #8]
  hci_disconnection_complete_event(rp0->Status,
 8019632:	68bb      	ldr	r3, [r7, #8]
 8019634:	7818      	ldrb	r0, [r3, #0]
 8019636:	68bb      	ldr	r3, [r7, #8]
 8019638:	f8b3 3001 	ldrh.w	r3, [r3, #1]
 801963c:	b299      	uxth	r1, r3
 801963e:	68bb      	ldr	r3, [r7, #8]
 8019640:	78db      	ldrb	r3, [r3, #3]
 8019642:	461a      	mov	r2, r3
 8019644:	f004 fcc6 	bl	801dfd4 <hci_disconnection_complete_event>
                                   rp0->Connection_Handle,
                                   rp0->Reason);

  return status;
 8019648:	7bfb      	ldrb	r3, [r7, #15]
}
 801964a:	4618      	mov	r0, r3
 801964c:	3710      	adds	r7, #16
 801964e:	46bd      	mov	sp, r7
 8019650:	bd80      	pop	{r7, pc}

08019652 <hci_encryption_change_event_process>:
 *        - 0x01: Link Level Encryption is ON with AES-CCM
 * @retval None
 */

tBleStatus hci_encryption_change_event_process(uint8_t *buffer_in)
{
 8019652:	b580      	push	{r7, lr}
 8019654:	b084      	sub	sp, #16
 8019656:	af00      	add	r7, sp, #0
 8019658:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 801965a:	2300      	movs	r3, #0
 801965c:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  hci_encryption_change_event_rp0 *rp0 = (hci_encryption_change_event_rp0 *)buffer_in;
 801965e:	687b      	ldr	r3, [r7, #4]
 8019660:	60bb      	str	r3, [r7, #8]
  hci_encryption_change_event(rp0->Status,
 8019662:	68bb      	ldr	r3, [r7, #8]
 8019664:	7818      	ldrb	r0, [r3, #0]
 8019666:	68bb      	ldr	r3, [r7, #8]
 8019668:	f8b3 3001 	ldrh.w	r3, [r3, #1]
 801966c:	b299      	uxth	r1, r3
 801966e:	68bb      	ldr	r3, [r7, #8]
 8019670:	78db      	ldrb	r3, [r3, #3]
 8019672:	461a      	mov	r2, r3
 8019674:	f005 f851 	bl	801e71a <hci_encryption_change_event>
                              rp0->Connection_Handle,
                              rp0->Encryption_Enabled);

  return status;
 8019678:	7bfb      	ldrb	r3, [r7, #15]
}
 801967a:	4618      	mov	r0, r3
 801967c:	3710      	adds	r7, #16
 801967e:	46bd      	mov	sp, r7
 8019680:	bd80      	pop	{r7, pc}

08019682 <hci_read_remote_version_information_complete_event_process>:
 * @param Subversion Subversion of the LMP in the remote Controller
 * @retval None
 */

tBleStatus hci_read_remote_version_information_complete_event_process(uint8_t *buffer_in)
{
 8019682:	b590      	push	{r4, r7, lr}
 8019684:	b087      	sub	sp, #28
 8019686:	af02      	add	r7, sp, #8
 8019688:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 801968a:	2300      	movs	r3, #0
 801968c:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  hci_read_remote_version_information_complete_event_rp0 *rp0 = (hci_read_remote_version_information_complete_event_rp0 *)buffer_in;
 801968e:	687b      	ldr	r3, [r7, #4]
 8019690:	60bb      	str	r3, [r7, #8]
  hci_read_remote_version_information_complete_event(rp0->Status,
 8019692:	68bb      	ldr	r3, [r7, #8]
 8019694:	7818      	ldrb	r0, [r3, #0]
 8019696:	68bb      	ldr	r3, [r7, #8]
 8019698:	f8b3 3001 	ldrh.w	r3, [r3, #1]
 801969c:	b299      	uxth	r1, r3
 801969e:	68bb      	ldr	r3, [r7, #8]
 80196a0:	78da      	ldrb	r2, [r3, #3]
 80196a2:	68bb      	ldr	r3, [r7, #8]
 80196a4:	889b      	ldrh	r3, [r3, #4]
 80196a6:	b29c      	uxth	r4, r3
 80196a8:	68bb      	ldr	r3, [r7, #8]
 80196aa:	88db      	ldrh	r3, [r3, #6]
 80196ac:	b29b      	uxth	r3, r3
 80196ae:	9300      	str	r3, [sp, #0]
 80196b0:	4623      	mov	r3, r4
 80196b2:	f001 fcb3 	bl	801b01c <hci_read_remote_version_information_complete_event>
                                                     rp0->Connection_Handle,
                                                     rp0->Version,
                                                     rp0->Manufacturer_Name,
                                                     rp0->Subversion);

  return status;
 80196b6:	7bfb      	ldrb	r3, [r7, #15]
}
 80196b8:	4618      	mov	r0, r3
 80196ba:	3714      	adds	r7, #20
 80196bc:	46bd      	mov	sp, r7
 80196be:	bd90      	pop	{r4, r7, pc}

080196c0 <hci_hardware_error_event_process>:
 *        - 0x05: TX Error
 * @retval None
 */

tBleStatus hci_hardware_error_event_process(uint8_t *buffer_in)
{
 80196c0:	b580      	push	{r7, lr}
 80196c2:	b084      	sub	sp, #16
 80196c4:	af00      	add	r7, sp, #0
 80196c6:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 80196c8:	2300      	movs	r3, #0
 80196ca:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  hci_hardware_error_event_rp0 *rp0 = (hci_hardware_error_event_rp0 *)buffer_in;
 80196cc:	687b      	ldr	r3, [r7, #4]
 80196ce:	60bb      	str	r3, [r7, #8]
  hci_hardware_error_event(rp0->Hardware_Code);
 80196d0:	68bb      	ldr	r3, [r7, #8]
 80196d2:	781b      	ldrb	r3, [r3, #0]
 80196d4:	4618      	mov	r0, r3
 80196d6:	f004 ffc3 	bl	801e660 <hci_hardware_error_event>

  return status;
 80196da:	7bfb      	ldrb	r3, [r7, #15]
}
 80196dc:	4618      	mov	r0, r3
 80196de:	3710      	adds	r7, #16
 80196e0:	46bd      	mov	sp, r7
 80196e2:	bd80      	pop	{r7, pc}

080196e4 <hci_number_of_completed_packets_event_process>:
 * @param Handle_Packets_Pair_Entry See @ref Handle_Packets_Pair_Entry_t
 * @retval None
 */

tBleStatus hci_number_of_completed_packets_event_process(uint8_t *buffer_in)
{
 80196e4:	b580      	push	{r7, lr}
 80196e6:	b0c8      	sub	sp, #288	@ 0x120
 80196e8:	af00      	add	r7, sp, #0
 80196ea:	f507 7390 	add.w	r3, r7, #288	@ 0x120
 80196ee:	f5a3 738e 	sub.w	r3, r3, #284	@ 0x11c
 80196f2:	6018      	str	r0, [r3, #0]
  tBleStatus status = BLE_STATUS_SUCCESS;
 80196f4:	2300      	movs	r3, #0
 80196f6:	f887 3117 	strb.w	r3, [r7, #279]	@ 0x117
  /* Input params */
  hci_number_of_completed_packets_event_rp0 *rp0 = (hci_number_of_completed_packets_event_rp0 *)buffer_in;
 80196fa:	f507 7390 	add.w	r3, r7, #288	@ 0x120
 80196fe:	f5a3 738e 	sub.w	r3, r3, #284	@ 0x11c
 8019702:	681b      	ldr	r3, [r3, #0]
 8019704:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110
  uint8_t size = 1;
 8019708:	2301      	movs	r3, #1
 801970a:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f
  int i;
  Handle_Packets_Pair_Entry_t Handle_Packets_Pair_Entry[HCI_MAX_PAYLOAD_SIZE/sizeof(Handle_Packets_Pair_Entry_t)];
  for (i = 0; i < rp0->Number_of_Handles; i++) {
 801970e:	2300      	movs	r3, #0
 8019710:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118
 8019714:	e032      	b.n	801977c <hci_number_of_completed_packets_event_process+0x98>
    Handle_Packets_Pair_Entry[i].Connection_Handle = rp0->Handle_Packets_Pair_Entry[i].Connection_Handle;
 8019716:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 801971a:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 801971e:	009b      	lsls	r3, r3, #2
 8019720:	4413      	add	r3, r2
 8019722:	f8b3 3001 	ldrh.w	r3, [r3, #1]
 8019726:	b299      	uxth	r1, r3
 8019728:	f507 7390 	add.w	r3, r7, #288	@ 0x120
 801972c:	f5a3 738a 	sub.w	r3, r3, #276	@ 0x114
 8019730:	f8d7 2118 	ldr.w	r2, [r7, #280]	@ 0x118
 8019734:	f823 1022 	strh.w	r1, [r3, r2, lsl #2]
    size += 2;
 8019738:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 801973c:	3302      	adds	r3, #2
 801973e:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f
    Handle_Packets_Pair_Entry[i].HC_Num_Of_Completed_Packets = rp0->Handle_Packets_Pair_Entry[i].HC_Num_Of_Completed_Packets;
 8019742:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 8019746:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 801974a:	009b      	lsls	r3, r3, #2
 801974c:	4413      	add	r3, r2
 801974e:	f8b3 3003 	ldrh.w	r3, [r3, #3]
 8019752:	b299      	uxth	r1, r3
 8019754:	f507 7390 	add.w	r3, r7, #288	@ 0x120
 8019758:	f5a3 728a 	sub.w	r2, r3, #276	@ 0x114
 801975c:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 8019760:	009b      	lsls	r3, r3, #2
 8019762:	4413      	add	r3, r2
 8019764:	460a      	mov	r2, r1
 8019766:	805a      	strh	r2, [r3, #2]
    size += 2;
 8019768:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 801976c:	3302      	adds	r3, #2
 801976e:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f
  for (i = 0; i < rp0->Number_of_Handles; i++) {
 8019772:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 8019776:	3301      	adds	r3, #1
 8019778:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118
 801977c:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 8019780:	781b      	ldrb	r3, [r3, #0]
 8019782:	461a      	mov	r2, r3
 8019784:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 8019788:	4293      	cmp	r3, r2
 801978a:	dbc4      	blt.n	8019716 <hci_number_of_completed_packets_event_process+0x32>
  }
  hci_number_of_completed_packets_event(rp0->Number_of_Handles,
 801978c:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 8019790:	781b      	ldrb	r3, [r3, #0]
 8019792:	f107 020c 	add.w	r2, r7, #12
 8019796:	4611      	mov	r1, r2
 8019798:	4618      	mov	r0, r3
 801979a:	f001 fc57 	bl	801b04c <hci_number_of_completed_packets_event>
                                        Handle_Packets_Pair_Entry);

  return status;
 801979e:	f897 3117 	ldrb.w	r3, [r7, #279]	@ 0x117
}
 80197a2:	4618      	mov	r0, r3
 80197a4:	f507 7790 	add.w	r7, r7, #288	@ 0x120
 80197a8:	46bd      	mov	sp, r7
 80197aa:	bd80      	pop	{r7, pc}

080197ac <hci_data_buffer_overflow_event_process>:
 *        - 0x01: ACL Buffer Overflow
 * @retval None
 */

tBleStatus hci_data_buffer_overflow_event_process(uint8_t *buffer_in)
{
 80197ac:	b580      	push	{r7, lr}
 80197ae:	b084      	sub	sp, #16
 80197b0:	af00      	add	r7, sp, #0
 80197b2:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 80197b4:	2300      	movs	r3, #0
 80197b6:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  hci_data_buffer_overflow_event_rp0 *rp0 = (hci_data_buffer_overflow_event_rp0 *)buffer_in;
 80197b8:	687b      	ldr	r3, [r7, #4]
 80197ba:	60bb      	str	r3, [r7, #8]
  hci_data_buffer_overflow_event(rp0->Link_Type);
 80197bc:	68bb      	ldr	r3, [r7, #8]
 80197be:	781b      	ldrb	r3, [r3, #0]
 80197c0:	4618      	mov	r0, r3
 80197c2:	f001 fc53 	bl	801b06c <hci_data_buffer_overflow_event>

  return status;
 80197c6:	7bfb      	ldrb	r3, [r7, #15]
}
 80197c8:	4618      	mov	r0, r3
 80197ca:	3710      	adds	r7, #16
 80197cc:	46bd      	mov	sp, r7
 80197ce:	bd80      	pop	{r7, pc}

080197d0 <hci_encryption_key_refresh_complete_event_process>:
 *        - 0x0000 ... 0x0EFF
 * @retval None
 */

tBleStatus hci_encryption_key_refresh_complete_event_process(uint8_t *buffer_in)
{
 80197d0:	b580      	push	{r7, lr}
 80197d2:	b084      	sub	sp, #16
 80197d4:	af00      	add	r7, sp, #0
 80197d6:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 80197d8:	2300      	movs	r3, #0
 80197da:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  hci_encryption_key_refresh_complete_event_rp0 *rp0 = (hci_encryption_key_refresh_complete_event_rp0 *)buffer_in;
 80197dc:	687b      	ldr	r3, [r7, #4]
 80197de:	60bb      	str	r3, [r7, #8]
  hci_encryption_key_refresh_complete_event(rp0->Status,
 80197e0:	68bb      	ldr	r3, [r7, #8]
 80197e2:	781a      	ldrb	r2, [r3, #0]
 80197e4:	68bb      	ldr	r3, [r7, #8]
 80197e6:	f8b3 3001 	ldrh.w	r3, [r3, #1]
 80197ea:	b29b      	uxth	r3, r3
 80197ec:	4619      	mov	r1, r3
 80197ee:	4610      	mov	r0, r2
 80197f0:	f001 fc4a 	bl	801b088 <hci_encryption_key_refresh_complete_event>
                                            rp0->Connection_Handle);

  return status;
 80197f4:	7bfb      	ldrb	r3, [r7, #15]
}
 80197f6:	4618      	mov	r0, r3
 80197f8:	3710      	adds	r7, #16
 80197fa:	46bd      	mov	sp, r7
 80197fc:	bd80      	pop	{r7, pc}

080197fe <hci_authenticated_payload_timeout_expired_event_process>:
 *        - 0x0000 ... 0x0EFF
 * @retval None
 */

tBleStatus hci_authenticated_payload_timeout_expired_event_process(uint8_t *buffer_in)
{
 80197fe:	b580      	push	{r7, lr}
 8019800:	b084      	sub	sp, #16
 8019802:	af00      	add	r7, sp, #0
 8019804:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 8019806:	2300      	movs	r3, #0
 8019808:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  hci_authenticated_payload_timeout_expired_event_rp0 *rp0 = (hci_authenticated_payload_timeout_expired_event_rp0 *)buffer_in;
 801980a:	687b      	ldr	r3, [r7, #4]
 801980c:	60bb      	str	r3, [r7, #8]
  hci_authenticated_payload_timeout_expired_event(rp0->Connection_Handle);
 801980e:	68bb      	ldr	r3, [r7, #8]
 8019810:	881b      	ldrh	r3, [r3, #0]
 8019812:	b29b      	uxth	r3, r3
 8019814:	4618      	mov	r0, r3
 8019816:	f001 fc49 	bl	801b0ac <hci_authenticated_payload_timeout_expired_event>

  return status;
 801981a:	7bfb      	ldrb	r3, [r7, #15]
}
 801981c:	4618      	mov	r0, r3
 801981e:	3710      	adds	r7, #16
 8019820:	46bd      	mov	sp, r7
 8019822:	bd80      	pop	{r7, pc}

08019824 <aci_blue_initialized_event_process>:
 *        - 0x09: System reset due to ECC error
 * @retval None
 */

tBleStatus aci_blue_initialized_event_process(uint8_t *buffer_in)
{
 8019824:	b580      	push	{r7, lr}
 8019826:	b084      	sub	sp, #16
 8019828:	af00      	add	r7, sp, #0
 801982a:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 801982c:	2300      	movs	r3, #0
 801982e:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  aci_blue_initialized_event_rp0 *rp0 = (aci_blue_initialized_event_rp0 *)buffer_in;
 8019830:	687b      	ldr	r3, [r7, #4]
 8019832:	60bb      	str	r3, [r7, #8]
  aci_blue_initialized_event(rp0->Reason_Code);
 8019834:	68bb      	ldr	r3, [r7, #8]
 8019836:	781b      	ldrb	r3, [r3, #0]
 8019838:	4618      	mov	r0, r3
 801983a:	f001 fd23 	bl	801b284 <aci_blue_initialized_event>

  return status;
 801983e:	7bfb      	ldrb	r3, [r7, #15]
}
 8019840:	4618      	mov	r0, r3
 8019842:	3710      	adds	r7, #16
 8019844:	46bd      	mov	sp, r7
 8019846:	bd80      	pop	{r7, pc}

08019848 <aci_blue_events_lost_event_process>:
 *        - 0x0080000000000000: ACI_GAP_KEYPRESS_NOTIFICATION_EVENT
 * @retval None
 */

tBleStatus aci_blue_events_lost_event_process(uint8_t *buffer_in)
{
 8019848:	b580      	push	{r7, lr}
 801984a:	b084      	sub	sp, #16
 801984c:	af00      	add	r7, sp, #0
 801984e:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 8019850:	2300      	movs	r3, #0
 8019852:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  aci_blue_events_lost_event_rp0 *rp0 = (aci_blue_events_lost_event_rp0 *)buffer_in;
 8019854:	687b      	ldr	r3, [r7, #4]
 8019856:	60bb      	str	r3, [r7, #8]
  aci_blue_events_lost_event(rp0->Lost_Events);
 8019858:	68bb      	ldr	r3, [r7, #8]
 801985a:	4618      	mov	r0, r3
 801985c:	f001 fd22 	bl	801b2a4 <aci_blue_events_lost_event>

  return status;
 8019860:	7bfb      	ldrb	r3, [r7, #15]
}
 8019862:	4618      	mov	r0, r3
 8019864:	3710      	adds	r7, #16
 8019866:	46bd      	mov	sp, r7
 8019868:	bd80      	pop	{r7, pc}

0801986a <aci_blue_crash_info_event_process>:
 * @param Debug_Data Debug data
 * @retval None
 */

tBleStatus aci_blue_crash_info_event_process(uint8_t *buffer_in)
{
 801986a:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 801986e:	b08d      	sub	sp, #52	@ 0x34
 8019870:	af08      	add	r7, sp, #32
 8019872:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 8019874:	2300      	movs	r3, #0
 8019876:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  aci_blue_crash_info_event_rp0 *rp0 = (aci_blue_crash_info_event_rp0 *)buffer_in;
 8019878:	687b      	ldr	r3, [r7, #4]
 801987a:	60bb      	str	r3, [r7, #8]
  aci_blue_crash_info_event(rp0->Crash_Type,
 801987c:	68bb      	ldr	r3, [r7, #8]
 801987e:	f893 c000 	ldrb.w	ip, [r3]
 8019882:	68bb      	ldr	r3, [r7, #8]
 8019884:	f8d3 e001 	ldr.w	lr, [r3, #1]
 8019888:	68bb      	ldr	r3, [r7, #8]
 801988a:	f8d3 8005 	ldr.w	r8, [r3, #5]
 801988e:	68bb      	ldr	r3, [r7, #8]
 8019890:	f8d3 9009 	ldr.w	r9, [r3, #9]
 8019894:	68bb      	ldr	r3, [r7, #8]
 8019896:	f8d3 300d 	ldr.w	r3, [r3, #13]
 801989a:	603b      	str	r3, [r7, #0]
 801989c:	68ba      	ldr	r2, [r7, #8]
 801989e:	f8d2 2011 	ldr.w	r2, [r2, #17]
 80198a2:	68b9      	ldr	r1, [r7, #8]
 80198a4:	f8d1 1015 	ldr.w	r1, [r1, #21]
 80198a8:	68b8      	ldr	r0, [r7, #8]
 80198aa:	f8d0 0019 	ldr.w	r0, [r0, #25]
 80198ae:	68bc      	ldr	r4, [r7, #8]
 80198b0:	f8d4 401d 	ldr.w	r4, [r4, #29]
 80198b4:	68bd      	ldr	r5, [r7, #8]
 80198b6:	f8d5 5021 	ldr.w	r5, [r5, #33]	@ 0x21
 80198ba:	68be      	ldr	r6, [r7, #8]
 80198bc:	f896 6025 	ldrb.w	r6, [r6, #37]	@ 0x25
                            rp0->R12,
                            rp0->LR,
                            rp0->PC,
                            rp0->xPSR,
                            rp0->Debug_Data_Length,
                            rp0->Debug_Data);
 80198c0:	68bb      	ldr	r3, [r7, #8]
 80198c2:	3326      	adds	r3, #38	@ 0x26
  aci_blue_crash_info_event(rp0->Crash_Type,
 80198c4:	9307      	str	r3, [sp, #28]
 80198c6:	9606      	str	r6, [sp, #24]
 80198c8:	9505      	str	r5, [sp, #20]
 80198ca:	9404      	str	r4, [sp, #16]
 80198cc:	9003      	str	r0, [sp, #12]
 80198ce:	9102      	str	r1, [sp, #8]
 80198d0:	9201      	str	r2, [sp, #4]
 80198d2:	683b      	ldr	r3, [r7, #0]
 80198d4:	9300      	str	r3, [sp, #0]
 80198d6:	464b      	mov	r3, r9
 80198d8:	4642      	mov	r2, r8
 80198da:	4671      	mov	r1, lr
 80198dc:	4660      	mov	r0, ip
 80198de:	f001 fcef 	bl	801b2c0 <aci_blue_crash_info_event>

  return status;
 80198e2:	7bfb      	ldrb	r3, [r7, #15]
}
 80198e4:	4618      	mov	r0, r3
 80198e6:	3714      	adds	r7, #20
 80198e8:	46bd      	mov	sp, r7
 80198ea:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

080198ee <aci_hal_end_of_radio_activity_event_process>:
 *        time units.
 * @retval None
 */

tBleStatus aci_hal_end_of_radio_activity_event_process(uint8_t *buffer_in)
{
 80198ee:	b580      	push	{r7, lr}
 80198f0:	b084      	sub	sp, #16
 80198f2:	af00      	add	r7, sp, #0
 80198f4:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 80198f6:	2300      	movs	r3, #0
 80198f8:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  aci_hal_end_of_radio_activity_event_rp0 *rp0 = (aci_hal_end_of_radio_activity_event_rp0 *)buffer_in;
 80198fa:	687b      	ldr	r3, [r7, #4]
 80198fc:	60bb      	str	r3, [r7, #8]
  aci_hal_end_of_radio_activity_event(rp0->Last_State,
 80198fe:	68bb      	ldr	r3, [r7, #8]
 8019900:	7818      	ldrb	r0, [r3, #0]
 8019902:	68bb      	ldr	r3, [r7, #8]
 8019904:	7859      	ldrb	r1, [r3, #1]
 8019906:	68bb      	ldr	r3, [r7, #8]
 8019908:	f8d3 3002 	ldr.w	r3, [r3, #2]
 801990c:	461a      	mov	r2, r3
 801990e:	f001 fce9 	bl	801b2e4 <aci_hal_end_of_radio_activity_event>
                                      rp0->Next_State,
                                      rp0->Next_State_SysTime);

  return status;
 8019912:	7bfb      	ldrb	r3, [r7, #15]
}
 8019914:	4618      	mov	r0, r3
 8019916:	3710      	adds	r7, #16
 8019918:	46bd      	mov	sp, r7
 801991a:	bd80      	pop	{r7, pc}

0801991c <aci_hal_scan_req_report_event_process>:
 *        peer device
 * @retval None
 */

tBleStatus aci_hal_scan_req_report_event_process(uint8_t *buffer_in)
{
 801991c:	b580      	push	{r7, lr}
 801991e:	b084      	sub	sp, #16
 8019920:	af00      	add	r7, sp, #0
 8019922:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 8019924:	2300      	movs	r3, #0
 8019926:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  aci_hal_scan_req_report_event_rp0 *rp0 = (aci_hal_scan_req_report_event_rp0 *)buffer_in;
 8019928:	687b      	ldr	r3, [r7, #4]
 801992a:	60bb      	str	r3, [r7, #8]
  aci_hal_scan_req_report_event(rp0->RSSI,
 801992c:	68bb      	ldr	r3, [r7, #8]
 801992e:	f993 0000 	ldrsb.w	r0, [r3]
 8019932:	68bb      	ldr	r3, [r7, #8]
 8019934:	7859      	ldrb	r1, [r3, #1]
                                rp0->Peer_Address_Type,
                                rp0->Peer_Address);
 8019936:	68bb      	ldr	r3, [r7, #8]
 8019938:	3302      	adds	r3, #2
  aci_hal_scan_req_report_event(rp0->RSSI,
 801993a:	461a      	mov	r2, r3
 801993c:	f001 fce4 	bl	801b308 <aci_hal_scan_req_report_event>

  return status;
 8019940:	7bfb      	ldrb	r3, [r7, #15]
}
 8019942:	4618      	mov	r0, r3
 8019944:	3710      	adds	r7, #16
 8019946:	46bd      	mov	sp, r7
 8019948:	bd80      	pop	{r7, pc}

0801994a <aci_hal_fw_error_event_process>:
 *        condition has occurred.
 * @retval None
 */

tBleStatus aci_hal_fw_error_event_process(uint8_t *buffer_in)
{
 801994a:	b580      	push	{r7, lr}
 801994c:	b084      	sub	sp, #16
 801994e:	af00      	add	r7, sp, #0
 8019950:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 8019952:	2300      	movs	r3, #0
 8019954:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  aci_hal_fw_error_event_rp0 *rp0 = (aci_hal_fw_error_event_rp0 *)buffer_in;
 8019956:	687b      	ldr	r3, [r7, #4]
 8019958:	60bb      	str	r3, [r7, #8]
  aci_hal_fw_error_event(rp0->FW_Error_Type,
 801995a:	68bb      	ldr	r3, [r7, #8]
 801995c:	7818      	ldrb	r0, [r3, #0]
 801995e:	68bb      	ldr	r3, [r7, #8]
 8019960:	7859      	ldrb	r1, [r3, #1]
                         rp0->Data_Length,
                         rp0->Data);
 8019962:	68bb      	ldr	r3, [r7, #8]
 8019964:	3302      	adds	r3, #2
  aci_hal_fw_error_event(rp0->FW_Error_Type,
 8019966:	461a      	mov	r2, r3
 8019968:	f001 fce0 	bl	801b32c <aci_hal_fw_error_event>

  return status;
 801996c:	7bfb      	ldrb	r3, [r7, #15]
}
 801996e:	4618      	mov	r0, r3
 8019970:	3710      	adds	r7, #16
 8019972:	46bd      	mov	sp, r7
 8019974:	bd80      	pop	{r7, pc}

08019976 <aci_hal_le_test_end_event_process>:
 * @param Number_Of_Packets The number of test packets actually transmitted.
 * @retval None
 */

tBleStatus aci_hal_le_test_end_event_process(uint8_t *buffer_in)
{
 8019976:	b580      	push	{r7, lr}
 8019978:	b084      	sub	sp, #16
 801997a:	af00      	add	r7, sp, #0
 801997c:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 801997e:	2300      	movs	r3, #0
 8019980:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  aci_hal_le_test_end_event_rp0 *rp0 = (aci_hal_le_test_end_event_rp0 *)buffer_in;
 8019982:	687b      	ldr	r3, [r7, #4]
 8019984:	60bb      	str	r3, [r7, #8]
  aci_hal_le_test_end_event(rp0->Number_Of_Packets);
 8019986:	68bb      	ldr	r3, [r7, #8]
 8019988:	881b      	ldrh	r3, [r3, #0]
 801998a:	b29b      	uxth	r3, r3
 801998c:	4618      	mov	r0, r3
 801998e:	f001 fcdf 	bl	801b350 <aci_hal_le_test_end_event>

  return status;
 8019992:	7bfb      	ldrb	r3, [r7, #15]
}
 8019994:	4618      	mov	r0, r3
 8019996:	3710      	adds	r7, #16
 8019998:	46bd      	mov	sp, r7
 801999a:	bd80      	pop	{r7, pc}

0801999c <aci_gap_limited_discoverable_event_process>:
 *        discoverable mode ends due to timeout. The timeout is 180 seconds.
 * @retval None
 */

tBleStatus aci_gap_limited_discoverable_event_process(uint8_t *buffer_in)
{
 801999c:	b580      	push	{r7, lr}
 801999e:	b084      	sub	sp, #16
 80199a0:	af00      	add	r7, sp, #0
 80199a2:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 80199a4:	2300      	movs	r3, #0
 80199a6:	73fb      	strb	r3, [r7, #15]
  aci_gap_limited_discoverable_event();
 80199a8:	f001 fbe2 	bl	801b170 <aci_gap_limited_discoverable_event>

  return status;
 80199ac:	7bfb      	ldrb	r3, [r7, #15]
}
 80199ae:	4618      	mov	r0, r3
 80199b0:	3710      	adds	r7, #16
 80199b2:	46bd      	mov	sp, r7
 80199b4:	bd80      	pop	{r7, pc}

080199b6 <aci_gap_pairing_complete_event_process>:
 *        - 0x0C: SMP_SC_NUMCOMPARISON_FAILED
 * @retval None
 */

tBleStatus aci_gap_pairing_complete_event_process(uint8_t *buffer_in)
{
 80199b6:	b580      	push	{r7, lr}
 80199b8:	b084      	sub	sp, #16
 80199ba:	af00      	add	r7, sp, #0
 80199bc:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 80199be:	2300      	movs	r3, #0
 80199c0:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  aci_gap_pairing_complete_event_rp0 *rp0 = (aci_gap_pairing_complete_event_rp0 *)buffer_in;
 80199c2:	687b      	ldr	r3, [r7, #4]
 80199c4:	60bb      	str	r3, [r7, #8]
  aci_gap_pairing_complete_event(rp0->Connection_Handle,
 80199c6:	68bb      	ldr	r3, [r7, #8]
 80199c8:	881b      	ldrh	r3, [r3, #0]
 80199ca:	b298      	uxth	r0, r3
 80199cc:	68bb      	ldr	r3, [r7, #8]
 80199ce:	7899      	ldrb	r1, [r3, #2]
 80199d0:	68bb      	ldr	r3, [r7, #8]
 80199d2:	78db      	ldrb	r3, [r3, #3]
 80199d4:	461a      	mov	r2, r3
 80199d6:	f004 fcd7 	bl	801e388 <aci_gap_pairing_complete_event>
                                 rp0->Status,
                                 rp0->Reason);

  return status;
 80199da:	7bfb      	ldrb	r3, [r7, #15]
}
 80199dc:	4618      	mov	r0, r3
 80199de:	3710      	adds	r7, #16
 80199e0:	46bd      	mov	sp, r7
 80199e2:	bd80      	pop	{r7, pc}

080199e4 <aci_gap_pass_key_req_event_process>:
 *        requested.
 * @retval None
 */

tBleStatus aci_gap_pass_key_req_event_process(uint8_t *buffer_in)
{
 80199e4:	b580      	push	{r7, lr}
 80199e6:	b084      	sub	sp, #16
 80199e8:	af00      	add	r7, sp, #0
 80199ea:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 80199ec:	2300      	movs	r3, #0
 80199ee:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  aci_gap_pass_key_req_event_rp0 *rp0 = (aci_gap_pass_key_req_event_rp0 *)buffer_in;
 80199f0:	687b      	ldr	r3, [r7, #4]
 80199f2:	60bb      	str	r3, [r7, #8]
  aci_gap_pass_key_req_event(rp0->Connection_Handle);
 80199f4:	68bb      	ldr	r3, [r7, #8]
 80199f6:	881b      	ldrh	r3, [r3, #0]
 80199f8:	b29b      	uxth	r3, r3
 80199fa:	4618      	mov	r0, r3
 80199fc:	f004 fca2 	bl	801e344 <aci_gap_pass_key_req_event>

  return status;
 8019a00:	7bfb      	ldrb	r3, [r7, #15]
}
 8019a02:	4618      	mov	r0, r3
 8019a04:	3710      	adds	r7, #16
 8019a06:	46bd      	mov	sp, r7
 8019a08:	bd80      	pop	{r7, pc}

08019a0a <aci_gap_slave_security_initiated_event_process>:
 *        successfully sent to the master.
 * @retval None
 */

tBleStatus aci_gap_slave_security_initiated_event_process(uint8_t *buffer_in)
{
 8019a0a:	b580      	push	{r7, lr}
 8019a0c:	b084      	sub	sp, #16
 8019a0e:	af00      	add	r7, sp, #0
 8019a10:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 8019a12:	2300      	movs	r3, #0
 8019a14:	73fb      	strb	r3, [r7, #15]
  aci_gap_slave_security_initiated_event();
 8019a16:	f001 fbb5 	bl	801b184 <aci_gap_slave_security_initiated_event>

  return status;
 8019a1a:	7bfb      	ldrb	r3, [r7, #15]
}
 8019a1c:	4618      	mov	r0, r3
 8019a1e:	3710      	adds	r7, #16
 8019a20:	46bd      	mov	sp, r7
 8019a22:	bd80      	pop	{r7, pc}

08019a24 <aci_gap_bond_lost_event_process>:
 *        force_rebond set to 1.
 * @retval None
 */

tBleStatus aci_gap_bond_lost_event_process(uint8_t *buffer_in)
{
 8019a24:	b580      	push	{r7, lr}
 8019a26:	b084      	sub	sp, #16
 8019a28:	af00      	add	r7, sp, #0
 8019a2a:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 8019a2c:	2300      	movs	r3, #0
 8019a2e:	73fb      	strb	r3, [r7, #15]
  aci_gap_bond_lost_event();
 8019a30:	f004 fe32 	bl	801e698 <aci_gap_bond_lost_event>

  return status;
 8019a34:	7bfb      	ldrb	r3, [r7, #15]
}
 8019a36:	4618      	mov	r0, r3
 8019a38:	3710      	adds	r7, #16
 8019a3a:	46bd      	mov	sp, r7
 8019a3c:	bd80      	pop	{r7, pc}

08019a3e <aci_gap_proc_complete_event_process>:
 *        of the peer device if the procedure completed successfully.
 * @retval None
 */

tBleStatus aci_gap_proc_complete_event_process(uint8_t *buffer_in)
{
 8019a3e:	b580      	push	{r7, lr}
 8019a40:	b084      	sub	sp, #16
 8019a42:	af00      	add	r7, sp, #0
 8019a44:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 8019a46:	2300      	movs	r3, #0
 8019a48:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  aci_gap_proc_complete_event_rp0 *rp0 = (aci_gap_proc_complete_event_rp0 *)buffer_in;
 8019a4a:	687b      	ldr	r3, [r7, #4]
 8019a4c:	60bb      	str	r3, [r7, #8]
  aci_gap_proc_complete_event(rp0->Procedure_Code,
 8019a4e:	68bb      	ldr	r3, [r7, #8]
 8019a50:	7818      	ldrb	r0, [r3, #0]
 8019a52:	68bb      	ldr	r3, [r7, #8]
 8019a54:	7859      	ldrb	r1, [r3, #1]
 8019a56:	68bb      	ldr	r3, [r7, #8]
 8019a58:	789a      	ldrb	r2, [r3, #2]
                              rp0->Status,
                              rp0->Data_Length,
                              rp0->Data);
 8019a5a:	68bb      	ldr	r3, [r7, #8]
 8019a5c:	3303      	adds	r3, #3
  aci_gap_proc_complete_event(rp0->Procedure_Code,
 8019a5e:	f001 fb9b 	bl	801b198 <aci_gap_proc_complete_event>

  return status;
 8019a62:	7bfb      	ldrb	r3, [r7, #15]
}
 8019a64:	4618      	mov	r0, r3
 8019a66:	3710      	adds	r7, #16
 8019a68:	46bd      	mov	sp, r7
 8019a6a:	bd80      	pop	{r7, pc}

08019a6c <aci_gap_addr_not_resolved_event_process>:
 *        could not be resolved with any of the stored IRK's.
 * @retval None
 */

tBleStatus aci_gap_addr_not_resolved_event_process(uint8_t *buffer_in)
{
 8019a6c:	b580      	push	{r7, lr}
 8019a6e:	b084      	sub	sp, #16
 8019a70:	af00      	add	r7, sp, #0
 8019a72:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 8019a74:	2300      	movs	r3, #0
 8019a76:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  aci_gap_addr_not_resolved_event_rp0 *rp0 = (aci_gap_addr_not_resolved_event_rp0 *)buffer_in;
 8019a78:	687b      	ldr	r3, [r7, #4]
 8019a7a:	60bb      	str	r3, [r7, #8]
  aci_gap_addr_not_resolved_event(rp0->Connection_Handle);
 8019a7c:	68bb      	ldr	r3, [r7, #8]
 8019a7e:	881b      	ldrh	r3, [r3, #0]
 8019a80:	b29b      	uxth	r3, r3
 8019a82:	4618      	mov	r0, r3
 8019a84:	f001 fb9c 	bl	801b1c0 <aci_gap_addr_not_resolved_event>

  return status;
 8019a88:	7bfb      	ldrb	r3, [r7, #15]
}
 8019a8a:	4618      	mov	r0, r3
 8019a8c:	3710      	adds	r7, #16
 8019a8e:	46bd      	mov	sp, r7
 8019a90:	bd80      	pop	{r7, pc}

08019a92 <aci_gap_numeric_comparison_value_event_process>:
 * @param Numeric_Value
 * @retval None
 */

tBleStatus aci_gap_numeric_comparison_value_event_process(uint8_t *buffer_in)
{
 8019a92:	b580      	push	{r7, lr}
 8019a94:	b084      	sub	sp, #16
 8019a96:	af00      	add	r7, sp, #0
 8019a98:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 8019a9a:	2300      	movs	r3, #0
 8019a9c:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  aci_gap_numeric_comparison_value_event_rp0 *rp0 = (aci_gap_numeric_comparison_value_event_rp0 *)buffer_in;
 8019a9e:	687b      	ldr	r3, [r7, #4]
 8019aa0:	60bb      	str	r3, [r7, #8]
  aci_gap_numeric_comparison_value_event(rp0->Connection_Handle,
 8019aa2:	68bb      	ldr	r3, [r7, #8]
 8019aa4:	881b      	ldrh	r3, [r3, #0]
 8019aa6:	b29a      	uxth	r2, r3
 8019aa8:	68bb      	ldr	r3, [r7, #8]
 8019aaa:	f8d3 3002 	ldr.w	r3, [r3, #2]
 8019aae:	4619      	mov	r1, r3
 8019ab0:	4610      	mov	r0, r2
 8019ab2:	f004 fe23 	bl	801e6fc <aci_gap_numeric_comparison_value_event>
                                         rp0->Numeric_Value);

  return status;
 8019ab6:	7bfb      	ldrb	r3, [r7, #15]
}
 8019ab8:	4618      	mov	r0, r3
 8019aba:	3710      	adds	r7, #16
 8019abc:	46bd      	mov	sp, r7
 8019abe:	bd80      	pop	{r7, pc}

08019ac0 <aci_gap_keypress_notification_event_process>:
 *        - 0x04: PASSKEY_ENTRY_COMPLETED
 * @retval None
 */

tBleStatus aci_gap_keypress_notification_event_process(uint8_t *buffer_in)
{
 8019ac0:	b580      	push	{r7, lr}
 8019ac2:	b084      	sub	sp, #16
 8019ac4:	af00      	add	r7, sp, #0
 8019ac6:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 8019ac8:	2300      	movs	r3, #0
 8019aca:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  aci_gap_keypress_notification_event_rp0 *rp0 = (aci_gap_keypress_notification_event_rp0 *)buffer_in;
 8019acc:	687b      	ldr	r3, [r7, #4]
 8019ace:	60bb      	str	r3, [r7, #8]
  aci_gap_keypress_notification_event(rp0->Connection_Handle,
 8019ad0:	68bb      	ldr	r3, [r7, #8]
 8019ad2:	881b      	ldrh	r3, [r3, #0]
 8019ad4:	b29a      	uxth	r2, r3
 8019ad6:	68bb      	ldr	r3, [r7, #8]
 8019ad8:	789b      	ldrb	r3, [r3, #2]
 8019ada:	4619      	mov	r1, r3
 8019adc:	4610      	mov	r0, r2
 8019ade:	f001 fb7d 	bl	801b1dc <aci_gap_keypress_notification_event>
                                      rp0->Notification_Type);

  return status;
 8019ae2:	7bfb      	ldrb	r3, [r7, #15]
}
 8019ae4:	4618      	mov	r0, r3
 8019ae6:	3710      	adds	r7, #16
 8019ae8:	46bd      	mov	sp, r7
 8019aea:	bd80      	pop	{r7, pc}

08019aec <aci_l2cap_connection_update_resp_event_process>:
 * @param Result
 * @retval None
 */

tBleStatus aci_l2cap_connection_update_resp_event_process(uint8_t *buffer_in)
{
 8019aec:	b580      	push	{r7, lr}
 8019aee:	b084      	sub	sp, #16
 8019af0:	af00      	add	r7, sp, #0
 8019af2:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 8019af4:	2300      	movs	r3, #0
 8019af6:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  aci_l2cap_connection_update_resp_event_rp0 *rp0 = (aci_l2cap_connection_update_resp_event_rp0 *)buffer_in;
 8019af8:	687b      	ldr	r3, [r7, #4]
 8019afa:	60bb      	str	r3, [r7, #8]
  aci_l2cap_connection_update_resp_event(rp0->Connection_Handle,
 8019afc:	68bb      	ldr	r3, [r7, #8]
 8019afe:	881b      	ldrh	r3, [r3, #0]
 8019b00:	b29a      	uxth	r2, r3
 8019b02:	68bb      	ldr	r3, [r7, #8]
 8019b04:	885b      	ldrh	r3, [r3, #2]
 8019b06:	b29b      	uxth	r3, r3
 8019b08:	4619      	mov	r1, r3
 8019b0a:	4610      	mov	r0, r2
 8019b0c:	f004 fcb8 	bl	801e480 <aci_l2cap_connection_update_resp_event>
                                         rp0->Result);

  return status;
 8019b10:	7bfb      	ldrb	r3, [r7, #15]
}
 8019b12:	4618      	mov	r0, r3
 8019b14:	3710      	adds	r7, #16
 8019b16:	46bd      	mov	sp, r7
 8019b18:	bd80      	pop	{r7, pc}

08019b1a <aci_l2cap_proc_timeout_event_process>:
 * @param Data
 * @retval None
 */

tBleStatus aci_l2cap_proc_timeout_event_process(uint8_t *buffer_in)
{
 8019b1a:	b580      	push	{r7, lr}
 8019b1c:	b084      	sub	sp, #16
 8019b1e:	af00      	add	r7, sp, #0
 8019b20:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 8019b22:	2300      	movs	r3, #0
 8019b24:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  aci_l2cap_proc_timeout_event_rp0 *rp0 = (aci_l2cap_proc_timeout_event_rp0 *)buffer_in;
 8019b26:	687b      	ldr	r3, [r7, #4]
 8019b28:	60bb      	str	r3, [r7, #8]
  aci_l2cap_proc_timeout_event(rp0->Connection_Handle,
 8019b2a:	68bb      	ldr	r3, [r7, #8]
 8019b2c:	881b      	ldrh	r3, [r3, #0]
 8019b2e:	b298      	uxth	r0, r3
 8019b30:	68bb      	ldr	r3, [r7, #8]
 8019b32:	7899      	ldrb	r1, [r3, #2]
                               rp0->Data_Length,
                               rp0->Data);
 8019b34:	68bb      	ldr	r3, [r7, #8]
 8019b36:	3303      	adds	r3, #3
  aci_l2cap_proc_timeout_event(rp0->Connection_Handle,
 8019b38:	461a      	mov	r2, r3
 8019b3a:	f001 fb61 	bl	801b200 <aci_l2cap_proc_timeout_event>

  return status;
 8019b3e:	7bfb      	ldrb	r3, [r7, #15]
}
 8019b40:	4618      	mov	r0, r3
 8019b42:	3710      	adds	r7, #16
 8019b44:	46bd      	mov	sp, r7
 8019b46:	bd80      	pop	{r7, pc}

08019b48 <aci_l2cap_connection_update_req_event_process>:
 *        - 10 (100 ms)  ... 3200 (32000 ms) 
 * @retval None
 */

tBleStatus aci_l2cap_connection_update_req_event_process(uint8_t *buffer_in)
{
 8019b48:	b5f0      	push	{r4, r5, r6, r7, lr}
 8019b4a:	b089      	sub	sp, #36	@ 0x24
 8019b4c:	af04      	add	r7, sp, #16
 8019b4e:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 8019b50:	2300      	movs	r3, #0
 8019b52:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  aci_l2cap_connection_update_req_event_rp0 *rp0 = (aci_l2cap_connection_update_req_event_rp0 *)buffer_in;
 8019b54:	687b      	ldr	r3, [r7, #4]
 8019b56:	60bb      	str	r3, [r7, #8]
  aci_l2cap_connection_update_req_event(rp0->Connection_Handle,
 8019b58:	68bb      	ldr	r3, [r7, #8]
 8019b5a:	881b      	ldrh	r3, [r3, #0]
 8019b5c:	b298      	uxth	r0, r3
 8019b5e:	68bb      	ldr	r3, [r7, #8]
 8019b60:	789c      	ldrb	r4, [r3, #2]
 8019b62:	68bb      	ldr	r3, [r7, #8]
 8019b64:	f8b3 3003 	ldrh.w	r3, [r3, #3]
 8019b68:	b29d      	uxth	r5, r3
 8019b6a:	68bb      	ldr	r3, [r7, #8]
 8019b6c:	f8b3 3005 	ldrh.w	r3, [r3, #5]
 8019b70:	b29e      	uxth	r6, r3
 8019b72:	68bb      	ldr	r3, [r7, #8]
 8019b74:	f8b3 3007 	ldrh.w	r3, [r3, #7]
 8019b78:	b29b      	uxth	r3, r3
 8019b7a:	68ba      	ldr	r2, [r7, #8]
 8019b7c:	f8b2 2009 	ldrh.w	r2, [r2, #9]
 8019b80:	b292      	uxth	r2, r2
 8019b82:	68b9      	ldr	r1, [r7, #8]
 8019b84:	f8b1 100b 	ldrh.w	r1, [r1, #11]
 8019b88:	b289      	uxth	r1, r1
 8019b8a:	9102      	str	r1, [sp, #8]
 8019b8c:	9201      	str	r2, [sp, #4]
 8019b8e:	9300      	str	r3, [sp, #0]
 8019b90:	4633      	mov	r3, r6
 8019b92:	462a      	mov	r2, r5
 8019b94:	4621      	mov	r1, r4
 8019b96:	f001 fb45 	bl	801b224 <aci_l2cap_connection_update_req_event>
                                        rp0->Interval_Min,
                                        rp0->Interval_Max,
                                        rp0->Slave_Latency,
                                        rp0->Timeout_Multiplier);

  return status;
 8019b9a:	7bfb      	ldrb	r3, [r7, #15]
}
 8019b9c:	4618      	mov	r0, r3
 8019b9e:	3714      	adds	r7, #20
 8019ba0:	46bd      	mov	sp, r7
 8019ba2:	bdf0      	pop	{r4, r5, r6, r7, pc}

08019ba4 <aci_l2cap_cfc_connection_event_process>:
 *        to the L2CAP layer entity as soon as the L2CAP channel is established.
 * @retval None
 */

tBleStatus aci_l2cap_cfc_connection_event_process(uint8_t *buffer_in)
{
 8019ba4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8019ba8:	b08a      	sub	sp, #40	@ 0x28
 8019baa:	af06      	add	r7, sp, #24
 8019bac:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 8019bae:	2300      	movs	r3, #0
 8019bb0:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  aci_l2cap_cfc_connection_event_rp0 *rp0 = (aci_l2cap_cfc_connection_event_rp0 *)buffer_in;
 8019bb2:	687b      	ldr	r3, [r7, #4]
 8019bb4:	60bb      	str	r3, [r7, #8]
  aci_l2cap_cfc_connection_event(rp0->Connection_Handle,
 8019bb6:	68bb      	ldr	r3, [r7, #8]
 8019bb8:	881b      	ldrh	r3, [r3, #0]
 8019bba:	b29e      	uxth	r6, r3
 8019bbc:	68bb      	ldr	r3, [r7, #8]
 8019bbe:	f893 c002 	ldrb.w	ip, [r3, #2]
 8019bc2:	68bb      	ldr	r3, [r7, #8]
 8019bc4:	f8b3 3003 	ldrh.w	r3, [r3, #3]
 8019bc8:	fa1f fe83 	uxth.w	lr, r3
 8019bcc:	68bb      	ldr	r3, [r7, #8]
 8019bce:	f893 8005 	ldrb.w	r8, [r3, #5]
 8019bd2:	68bb      	ldr	r3, [r7, #8]
 8019bd4:	88db      	ldrh	r3, [r3, #6]
 8019bd6:	b29b      	uxth	r3, r3
 8019bd8:	68ba      	ldr	r2, [r7, #8]
 8019bda:	8912      	ldrh	r2, [r2, #8]
 8019bdc:	b292      	uxth	r2, r2
 8019bde:	68b9      	ldr	r1, [r7, #8]
 8019be0:	8949      	ldrh	r1, [r1, #10]
 8019be2:	b289      	uxth	r1, r1
 8019be4:	68b8      	ldr	r0, [r7, #8]
 8019be6:	8980      	ldrh	r0, [r0, #12]
 8019be8:	b280      	uxth	r0, r0
 8019bea:	68bc      	ldr	r4, [r7, #8]
 8019bec:	89e4      	ldrh	r4, [r4, #14]
 8019bee:	b2a4      	uxth	r4, r4
 8019bf0:	68bd      	ldr	r5, [r7, #8]
 8019bf2:	8a2d      	ldrh	r5, [r5, #16]
 8019bf4:	b2ad      	uxth	r5, r5
 8019bf6:	9505      	str	r5, [sp, #20]
 8019bf8:	9404      	str	r4, [sp, #16]
 8019bfa:	9003      	str	r0, [sp, #12]
 8019bfc:	9102      	str	r1, [sp, #8]
 8019bfe:	9201      	str	r2, [sp, #4]
 8019c00:	9300      	str	r3, [sp, #0]
 8019c02:	4643      	mov	r3, r8
 8019c04:	4672      	mov	r2, lr
 8019c06:	4661      	mov	r1, ip
 8019c08:	4630      	mov	r0, r6
 8019c0a:	f001 fbaf 	bl	801b36c <aci_l2cap_cfc_connection_event>
                                 rp0->Remote_CID,
                                 rp0->Peer_MTU,
                                 rp0->Peer_MPS,
                                 rp0->Initial_Credits);

  return status;
 8019c0e:	7bfb      	ldrb	r3, [r7, #15]
}
 8019c10:	4618      	mov	r0, r3
 8019c12:	3710      	adds	r7, #16
 8019c14:	46bd      	mov	sp, r7
 8019c16:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08019c1a <aci_l2cap_disconnection_complete_event_process>:
 * @param CID The local channel endpoint that identifies the L2CAP channel.
 * @retval None
 */

tBleStatus aci_l2cap_disconnection_complete_event_process(uint8_t *buffer_in)
{
 8019c1a:	b580      	push	{r7, lr}
 8019c1c:	b084      	sub	sp, #16
 8019c1e:	af00      	add	r7, sp, #0
 8019c20:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 8019c22:	2300      	movs	r3, #0
 8019c24:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  aci_l2cap_disconnection_complete_event_rp0 *rp0 = (aci_l2cap_disconnection_complete_event_rp0 *)buffer_in;
 8019c26:	687b      	ldr	r3, [r7, #4]
 8019c28:	60bb      	str	r3, [r7, #8]
  aci_l2cap_disconnection_complete_event(rp0->Connection_Handle,
 8019c2a:	68bb      	ldr	r3, [r7, #8]
 8019c2c:	881b      	ldrh	r3, [r3, #0]
 8019c2e:	b29a      	uxth	r2, r3
 8019c30:	68bb      	ldr	r3, [r7, #8]
 8019c32:	885b      	ldrh	r3, [r3, #2]
 8019c34:	b29b      	uxth	r3, r3
 8019c36:	4619      	mov	r1, r3
 8019c38:	4610      	mov	r0, r2
 8019c3a:	f001 fbaf 	bl	801b39c <aci_l2cap_disconnection_complete_event>
                                         rp0->CID);

  return status;
 8019c3e:	7bfb      	ldrb	r3, [r7, #15]
}
 8019c40:	4618      	mov	r0, r3
 8019c42:	3710      	adds	r7, #16
 8019c44:	46bd      	mov	sp, r7
 8019c46:	bd80      	pop	{r7, pc}

08019c48 <aci_l2cap_flow_control_credit_event_process>:
 *        - 1 ... 65535
 * @retval None
 */

tBleStatus aci_l2cap_flow_control_credit_event_process(uint8_t *buffer_in)
{
 8019c48:	b580      	push	{r7, lr}
 8019c4a:	b084      	sub	sp, #16
 8019c4c:	af00      	add	r7, sp, #0
 8019c4e:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 8019c50:	2300      	movs	r3, #0
 8019c52:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  aci_l2cap_flow_control_credit_event_rp0 *rp0 = (aci_l2cap_flow_control_credit_event_rp0 *)buffer_in;
 8019c54:	687b      	ldr	r3, [r7, #4]
 8019c56:	60bb      	str	r3, [r7, #8]
  aci_l2cap_flow_control_credit_event(rp0->Connection_Handle,
 8019c58:	68bb      	ldr	r3, [r7, #8]
 8019c5a:	881b      	ldrh	r3, [r3, #0]
 8019c5c:	b298      	uxth	r0, r3
 8019c5e:	68bb      	ldr	r3, [r7, #8]
 8019c60:	885b      	ldrh	r3, [r3, #2]
 8019c62:	b299      	uxth	r1, r3
 8019c64:	68bb      	ldr	r3, [r7, #8]
 8019c66:	889b      	ldrh	r3, [r3, #4]
 8019c68:	b29a      	uxth	r2, r3
 8019c6a:	68bb      	ldr	r3, [r7, #8]
 8019c6c:	88db      	ldrh	r3, [r3, #6]
 8019c6e:	b29b      	uxth	r3, r3
 8019c70:	f001 fba6 	bl	801b3c0 <aci_l2cap_flow_control_credit_event>
                                      rp0->CID,
                                      rp0->TX_Credits,
                                      rp0->TX_Credit_Balance);

  return status;
 8019c74:	7bfb      	ldrb	r3, [r7, #15]
}
 8019c76:	4618      	mov	r0, r3
 8019c78:	3710      	adds	r7, #16
 8019c7a:	46bd      	mov	sp, r7
 8019c7c:	bd80      	pop	{r7, pc}

08019c7e <aci_l2cap_sdu_data_tx_nwk_event_process>:
 *        entity can currently send to the peer.
 * @retval None
 */

tBleStatus aci_l2cap_sdu_data_tx_nwk_event_process(uint8_t *buffer_in)
{
 8019c7e:	b580      	push	{r7, lr}
 8019c80:	b084      	sub	sp, #16
 8019c82:	af00      	add	r7, sp, #0
 8019c84:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 8019c86:	2300      	movs	r3, #0
 8019c88:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  aci_l2cap_sdu_data_tx_nwk_event_rp0 *rp0 = (aci_l2cap_sdu_data_tx_nwk_event_rp0 *)buffer_in;
 8019c8a:	687b      	ldr	r3, [r7, #4]
 8019c8c:	60bb      	str	r3, [r7, #8]
  aci_l2cap_sdu_data_tx_nwk_event(rp0->Connection_Handle,
 8019c8e:	68bb      	ldr	r3, [r7, #8]
 8019c90:	881b      	ldrh	r3, [r3, #0]
 8019c92:	b298      	uxth	r0, r3
 8019c94:	68bb      	ldr	r3, [r7, #8]
 8019c96:	885b      	ldrh	r3, [r3, #2]
 8019c98:	b299      	uxth	r1, r3
 8019c9a:	68bb      	ldr	r3, [r7, #8]
 8019c9c:	889b      	ldrh	r3, [r3, #4]
 8019c9e:	b29a      	uxth	r2, r3
 8019ca0:	68bb      	ldr	r3, [r7, #8]
 8019ca2:	88db      	ldrh	r3, [r3, #6]
 8019ca4:	b29b      	uxth	r3, r3
 8019ca6:	f001 fba3 	bl	801b3f0 <aci_l2cap_sdu_data_tx_nwk_event>
                                  rp0->CID,
                                  rp0->SDU_Length,
                                  rp0->TX_Credit_Balance);

  return status;
 8019caa:	7bfb      	ldrb	r3, [r7, #15]
}
 8019cac:	4618      	mov	r0, r3
 8019cae:	3710      	adds	r7, #16
 8019cb0:	46bd      	mov	sp, r7
 8019cb2:	bd80      	pop	{r7, pc}

08019cb4 <aci_l2cap_sdu_data_rx_nwk_event_process>:
 * @param SDU_Data
 * @retval None
 */

tBleStatus aci_l2cap_sdu_data_rx_nwk_event_process(uint8_t *buffer_in)
{
 8019cb4:	b590      	push	{r4, r7, lr}
 8019cb6:	b087      	sub	sp, #28
 8019cb8:	af02      	add	r7, sp, #8
 8019cba:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 8019cbc:	2300      	movs	r3, #0
 8019cbe:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  aci_l2cap_sdu_data_rx_nwk_event_rp0 *rp0 = (aci_l2cap_sdu_data_rx_nwk_event_rp0 *)buffer_in;
 8019cc0:	687b      	ldr	r3, [r7, #4]
 8019cc2:	60bb      	str	r3, [r7, #8]
  aci_l2cap_sdu_data_rx_nwk_event(rp0->Connection_Handle,
 8019cc4:	68bb      	ldr	r3, [r7, #8]
 8019cc6:	881b      	ldrh	r3, [r3, #0]
 8019cc8:	b298      	uxth	r0, r3
 8019cca:	68bb      	ldr	r3, [r7, #8]
 8019ccc:	885b      	ldrh	r3, [r3, #2]
 8019cce:	b299      	uxth	r1, r3
 8019cd0:	68bb      	ldr	r3, [r7, #8]
 8019cd2:	889b      	ldrh	r3, [r3, #4]
 8019cd4:	b29a      	uxth	r2, r3
 8019cd6:	68bb      	ldr	r3, [r7, #8]
 8019cd8:	88db      	ldrh	r3, [r3, #6]
 8019cda:	b29c      	uxth	r4, r3
                                  rp0->CID,
                                  rp0->RX_Credit_Balance,
                                  rp0->SDU_Length,
                                  rp0->SDU_Data);
 8019cdc:	68bb      	ldr	r3, [r7, #8]
 8019cde:	3308      	adds	r3, #8
  aci_l2cap_sdu_data_rx_nwk_event(rp0->Connection_Handle,
 8019ce0:	9300      	str	r3, [sp, #0]
 8019ce2:	4623      	mov	r3, r4
 8019ce4:	f001 fb9c 	bl	801b420 <aci_l2cap_sdu_data_rx_nwk_event>

  return status;
 8019ce8:	7bfb      	ldrb	r3, [r7, #15]
}
 8019cea:	4618      	mov	r0, r3
 8019cec:	3714      	adds	r7, #20
 8019cee:	46bd      	mov	sp, r7
 8019cf0:	bd90      	pop	{r4, r7, pc}

08019cf2 <aci_l2cap_command_reject_event_process>:
 * @param Data Data field associated with Reason
 * @retval None
 */

tBleStatus aci_l2cap_command_reject_event_process(uint8_t *buffer_in)
{
 8019cf2:	b590      	push	{r4, r7, lr}
 8019cf4:	b087      	sub	sp, #28
 8019cf6:	af02      	add	r7, sp, #8
 8019cf8:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 8019cfa:	2300      	movs	r3, #0
 8019cfc:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  aci_l2cap_command_reject_event_rp0 *rp0 = (aci_l2cap_command_reject_event_rp0 *)buffer_in;
 8019cfe:	687b      	ldr	r3, [r7, #4]
 8019d00:	60bb      	str	r3, [r7, #8]
  aci_l2cap_command_reject_event(rp0->Connection_Handle,
 8019d02:	68bb      	ldr	r3, [r7, #8]
 8019d04:	881b      	ldrh	r3, [r3, #0]
 8019d06:	b298      	uxth	r0, r3
 8019d08:	68bb      	ldr	r3, [r7, #8]
 8019d0a:	7899      	ldrb	r1, [r3, #2]
 8019d0c:	68bb      	ldr	r3, [r7, #8]
 8019d0e:	f8b3 3003 	ldrh.w	r3, [r3, #3]
 8019d12:	b29a      	uxth	r2, r3
 8019d14:	68bb      	ldr	r3, [r7, #8]
 8019d16:	795c      	ldrb	r4, [r3, #5]
                                 rp0->Identifier,
                                 rp0->Reason,
                                 rp0->Data_Length,
                                 rp0->Data);
 8019d18:	68bb      	ldr	r3, [r7, #8]
 8019d1a:	3306      	adds	r3, #6
  aci_l2cap_command_reject_event(rp0->Connection_Handle,
 8019d1c:	9300      	str	r3, [sp, #0]
 8019d1e:	4623      	mov	r3, r4
 8019d20:	f001 fa98 	bl	801b254 <aci_l2cap_command_reject_event>

  return status;
 8019d24:	7bfb      	ldrb	r3, [r7, #15]
}
 8019d26:	4618      	mov	r0, r3
 8019d28:	3714      	adds	r7, #20
 8019d2a:	46bd      	mov	sp, r7
 8019d2c:	bd90      	pop	{r4, r7, pc}

08019d2e <aci_gatt_srv_attribute_modified_event_process>:
 * @param Attr_Data The modified value
 * @retval None
 */

tBleStatus aci_gatt_srv_attribute_modified_event_process(uint8_t *buffer_in)
{
 8019d2e:	b580      	push	{r7, lr}
 8019d30:	b084      	sub	sp, #16
 8019d32:	af00      	add	r7, sp, #0
 8019d34:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 8019d36:	2300      	movs	r3, #0
 8019d38:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  aci_gatt_srv_attribute_modified_event_rp0 *rp0 = (aci_gatt_srv_attribute_modified_event_rp0 *)buffer_in;
 8019d3a:	687b      	ldr	r3, [r7, #4]
 8019d3c:	60bb      	str	r3, [r7, #8]
  aci_gatt_srv_attribute_modified_event(rp0->Connection_Handle,
 8019d3e:	68bb      	ldr	r3, [r7, #8]
 8019d40:	881b      	ldrh	r3, [r3, #0]
 8019d42:	b298      	uxth	r0, r3
 8019d44:	68bb      	ldr	r3, [r7, #8]
 8019d46:	885b      	ldrh	r3, [r3, #2]
 8019d48:	b299      	uxth	r1, r3
 8019d4a:	68bb      	ldr	r3, [r7, #8]
 8019d4c:	889b      	ldrh	r3, [r3, #4]
 8019d4e:	b29a      	uxth	r2, r3
                                        rp0->Attr_Handle,
                                        rp0->Attr_Data_Length,
                                        rp0->Attr_Data);
 8019d50:	68bb      	ldr	r3, [r7, #8]
 8019d52:	3306      	adds	r3, #6
  aci_gatt_srv_attribute_modified_event(rp0->Connection_Handle,
 8019d54:	f004 faab 	bl	801e2ae <aci_gatt_srv_attribute_modified_event>

  return status;
 8019d58:	7bfb      	ldrb	r3, [r7, #15]
}
 8019d5a:	4618      	mov	r0, r3
 8019d5c:	3710      	adds	r7, #16
 8019d5e:	46bd      	mov	sp, r7
 8019d60:	bd80      	pop	{r7, pc}

08019d62 <aci_gatt_proc_timeout_event_process>:
 *        timed out
 * @retval None
 */

tBleStatus aci_gatt_proc_timeout_event_process(uint8_t *buffer_in)
{
 8019d62:	b580      	push	{r7, lr}
 8019d64:	b084      	sub	sp, #16
 8019d66:	af00      	add	r7, sp, #0
 8019d68:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 8019d6a:	2300      	movs	r3, #0
 8019d6c:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  aci_gatt_proc_timeout_event_rp0 *rp0 = (aci_gatt_proc_timeout_event_rp0 *)buffer_in;
 8019d6e:	687b      	ldr	r3, [r7, #4]
 8019d70:	60bb      	str	r3, [r7, #8]
  aci_gatt_proc_timeout_event(rp0->Connection_Handle);
 8019d72:	68bb      	ldr	r3, [r7, #8]
 8019d74:	881b      	ldrh	r3, [r3, #0]
 8019d76:	b29b      	uxth	r3, r3
 8019d78:	4618      	mov	r0, r3
 8019d7a:	f004 fc55 	bl	801e628 <aci_gatt_proc_timeout_event>

  return status;
 8019d7e:	7bfb      	ldrb	r3, [r7, #15]
}
 8019d80:	4618      	mov	r0, r3
 8019d82:	3710      	adds	r7, #16
 8019d84:	46bd      	mov	sp, r7
 8019d86:	bd80      	pop	{r7, pc}

08019d88 <aci_att_exchange_mtu_resp_event_process>:
 * @param Server_RX_MTU ATT_MTU value agreed between server and client
 * @retval None
 */

tBleStatus aci_att_exchange_mtu_resp_event_process(uint8_t *buffer_in)
{
 8019d88:	b580      	push	{r7, lr}
 8019d8a:	b084      	sub	sp, #16
 8019d8c:	af00      	add	r7, sp, #0
 8019d8e:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 8019d90:	2300      	movs	r3, #0
 8019d92:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  aci_att_exchange_mtu_resp_event_rp0 *rp0 = (aci_att_exchange_mtu_resp_event_rp0 *)buffer_in;
 8019d94:	687b      	ldr	r3, [r7, #4]
 8019d96:	60bb      	str	r3, [r7, #8]
  aci_att_exchange_mtu_resp_event(rp0->Connection_Handle,
 8019d98:	68bb      	ldr	r3, [r7, #8]
 8019d9a:	881b      	ldrh	r3, [r3, #0]
 8019d9c:	b29a      	uxth	r2, r3
 8019d9e:	68bb      	ldr	r3, [r7, #8]
 8019da0:	885b      	ldrh	r3, [r3, #2]
 8019da2:	b29b      	uxth	r3, r3
 8019da4:	4619      	mov	r1, r3
 8019da6:	4610      	mov	r0, r2
 8019da8:	f004 fa98 	bl	801e2dc <aci_att_exchange_mtu_resp_event>
                                  rp0->Server_RX_MTU);

  return status;
 8019dac:	7bfb      	ldrb	r3, [r7, #15]
}
 8019dae:	4618      	mov	r0, r3
 8019db0:	3710      	adds	r7, #16
 8019db2:	46bd      	mov	sp, r7
 8019db4:	bd80      	pop	{r7, pc}

08019db6 <aci_att_clt_find_info_resp_event_process>:
 *        pair is:[2 octets for handle, 16 octets for UUIDs]
 * @retval None
 */

tBleStatus aci_att_clt_find_info_resp_event_process(uint8_t *buffer_in)
{
 8019db6:	b580      	push	{r7, lr}
 8019db8:	b084      	sub	sp, #16
 8019dba:	af00      	add	r7, sp, #0
 8019dbc:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 8019dbe:	2300      	movs	r3, #0
 8019dc0:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  aci_att_clt_find_info_resp_event_rp0 *rp0 = (aci_att_clt_find_info_resp_event_rp0 *)buffer_in;
 8019dc2:	687b      	ldr	r3, [r7, #4]
 8019dc4:	60bb      	str	r3, [r7, #8]
  aci_att_clt_find_info_resp_event(rp0->Connection_Handle,
 8019dc6:	68bb      	ldr	r3, [r7, #8]
 8019dc8:	881b      	ldrh	r3, [r3, #0]
 8019dca:	b298      	uxth	r0, r3
 8019dcc:	68bb      	ldr	r3, [r7, #8]
 8019dce:	7899      	ldrb	r1, [r3, #2]
 8019dd0:	68bb      	ldr	r3, [r7, #8]
 8019dd2:	f8b3 3003 	ldrh.w	r3, [r3, #3]
 8019dd6:	b29a      	uxth	r2, r3
                                   rp0->Format,
                                   rp0->Event_Data_Length,
                                   rp0->Handle_UUID_Pair);
 8019dd8:	68bb      	ldr	r3, [r7, #8]
 8019dda:	3305      	adds	r3, #5
  aci_att_clt_find_info_resp_event(rp0->Connection_Handle,
 8019ddc:	f001 fb38 	bl	801b450 <aci_att_clt_find_info_resp_event>

  return status;
 8019de0:	7bfb      	ldrb	r3, [r7, #15]
}
 8019de2:	4618      	mov	r0, r3
 8019de4:	3710      	adds	r7, #16
 8019de6:	46bd      	mov	sp, r7
 8019de8:	bd80      	pop	{r7, pc}

08019dea <aci_att_clt_find_by_type_value_resp_event_process>:
 * @param Attribute_Group_Handle_Pair See @ref Attribute_Group_Handle_Pair_t
 * @retval None
 */

tBleStatus aci_att_clt_find_by_type_value_resp_event_process(uint8_t *buffer_in)
{
 8019dea:	b580      	push	{r7, lr}
 8019dec:	b0c8      	sub	sp, #288	@ 0x120
 8019dee:	af00      	add	r7, sp, #0
 8019df0:	f507 7390 	add.w	r3, r7, #288	@ 0x120
 8019df4:	f5a3 738e 	sub.w	r3, r3, #284	@ 0x11c
 8019df8:	6018      	str	r0, [r3, #0]
  tBleStatus status = BLE_STATUS_SUCCESS;
 8019dfa:	2300      	movs	r3, #0
 8019dfc:	f887 3117 	strb.w	r3, [r7, #279]	@ 0x117
  /* Input params */
  aci_att_clt_find_by_type_value_resp_event_rp0 *rp0 = (aci_att_clt_find_by_type_value_resp_event_rp0 *)buffer_in;
 8019e00:	f507 7390 	add.w	r3, r7, #288	@ 0x120
 8019e04:	f5a3 738e 	sub.w	r3, r3, #284	@ 0x11c
 8019e08:	681b      	ldr	r3, [r3, #0]
 8019e0a:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110
  uint8_t size = 3;
 8019e0e:	2303      	movs	r3, #3
 8019e10:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f
  int i;
  Attribute_Group_Handle_Pair_t Attribute_Group_Handle_Pair[HCI_MAX_PAYLOAD_SIZE/sizeof(Attribute_Group_Handle_Pair_t)];
  for (i = 0; i < rp0->Num_of_Handle_Pair; i++) {
 8019e14:	2300      	movs	r3, #0
 8019e16:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118
 8019e1a:	e032      	b.n	8019e82 <aci_att_clt_find_by_type_value_resp_event_process+0x98>
    Attribute_Group_Handle_Pair[i].Found_Attribute_Handle = rp0->Attribute_Group_Handle_Pair[i].Found_Attribute_Handle;
 8019e1c:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 8019e20:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 8019e24:	009b      	lsls	r3, r3, #2
 8019e26:	4413      	add	r3, r2
 8019e28:	f8b3 3003 	ldrh.w	r3, [r3, #3]
 8019e2c:	b299      	uxth	r1, r3
 8019e2e:	f507 7390 	add.w	r3, r7, #288	@ 0x120
 8019e32:	f5a3 738a 	sub.w	r3, r3, #276	@ 0x114
 8019e36:	f8d7 2118 	ldr.w	r2, [r7, #280]	@ 0x118
 8019e3a:	f823 1022 	strh.w	r1, [r3, r2, lsl #2]
    size += 2;
 8019e3e:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 8019e42:	3302      	adds	r3, #2
 8019e44:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f
    Attribute_Group_Handle_Pair[i].Group_End_Handle = rp0->Attribute_Group_Handle_Pair[i].Group_End_Handle;
 8019e48:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 8019e4c:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 8019e50:	009b      	lsls	r3, r3, #2
 8019e52:	4413      	add	r3, r2
 8019e54:	f8b3 3005 	ldrh.w	r3, [r3, #5]
 8019e58:	b299      	uxth	r1, r3
 8019e5a:	f507 7390 	add.w	r3, r7, #288	@ 0x120
 8019e5e:	f5a3 728a 	sub.w	r2, r3, #276	@ 0x114
 8019e62:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 8019e66:	009b      	lsls	r3, r3, #2
 8019e68:	4413      	add	r3, r2
 8019e6a:	460a      	mov	r2, r1
 8019e6c:	805a      	strh	r2, [r3, #2]
    size += 2;
 8019e6e:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 8019e72:	3302      	adds	r3, #2
 8019e74:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f
  for (i = 0; i < rp0->Num_of_Handle_Pair; i++) {
 8019e78:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 8019e7c:	3301      	adds	r3, #1
 8019e7e:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118
 8019e82:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 8019e86:	789b      	ldrb	r3, [r3, #2]
 8019e88:	461a      	mov	r2, r3
 8019e8a:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 8019e8e:	4293      	cmp	r3, r2
 8019e90:	dbc4      	blt.n	8019e1c <aci_att_clt_find_by_type_value_resp_event_process+0x32>
  }
  aci_att_clt_find_by_type_value_resp_event(rp0->Connection_Handle,
 8019e92:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 8019e96:	881b      	ldrh	r3, [r3, #0]
 8019e98:	b298      	uxth	r0, r3
 8019e9a:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 8019e9e:	789b      	ldrb	r3, [r3, #2]
 8019ea0:	f107 020c 	add.w	r2, r7, #12
 8019ea4:	4619      	mov	r1, r3
 8019ea6:	f001 fae7 	bl	801b478 <aci_att_clt_find_by_type_value_resp_event>
                                            rp0->Num_of_Handle_Pair,
                                            Attribute_Group_Handle_Pair);

  return status;
 8019eaa:	f897 3117 	ldrb.w	r3, [r7, #279]	@ 0x117
}
 8019eae:	4618      	mov	r0, r3
 8019eb0:	f507 7790 	add.w	r7, r7, #288	@ 0x120
 8019eb4:	46bd      	mov	sp, r7
 8019eb6:	bd80      	pop	{r7, pc}

08019eb8 <aci_att_clt_read_by_type_resp_event_process>:
 *        Value]
 * @retval None
 */

tBleStatus aci_att_clt_read_by_type_resp_event_process(uint8_t *buffer_in)
{
 8019eb8:	b580      	push	{r7, lr}
 8019eba:	b084      	sub	sp, #16
 8019ebc:	af00      	add	r7, sp, #0
 8019ebe:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 8019ec0:	2300      	movs	r3, #0
 8019ec2:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  aci_att_clt_read_by_type_resp_event_rp0 *rp0 = (aci_att_clt_read_by_type_resp_event_rp0 *)buffer_in;
 8019ec4:	687b      	ldr	r3, [r7, #4]
 8019ec6:	60bb      	str	r3, [r7, #8]
  aci_att_clt_read_by_type_resp_event(rp0->Connection_Handle,
 8019ec8:	68bb      	ldr	r3, [r7, #8]
 8019eca:	881b      	ldrh	r3, [r3, #0]
 8019ecc:	b298      	uxth	r0, r3
 8019ece:	68bb      	ldr	r3, [r7, #8]
 8019ed0:	7899      	ldrb	r1, [r3, #2]
 8019ed2:	68bb      	ldr	r3, [r7, #8]
 8019ed4:	f8b3 3003 	ldrh.w	r3, [r3, #3]
 8019ed8:	b29a      	uxth	r2, r3
                                      rp0->Handle_Value_Pair_Length,
                                      rp0->Data_Length,
                                      rp0->Handle_Value_Pair_Data);
 8019eda:	68bb      	ldr	r3, [r7, #8]
 8019edc:	3305      	adds	r3, #5
  aci_att_clt_read_by_type_resp_event(rp0->Connection_Handle,
 8019ede:	f001 fadd 	bl	801b49c <aci_att_clt_read_by_type_resp_event>

  return status;
 8019ee2:	7bfb      	ldrb	r3, [r7, #15]
}
 8019ee4:	4618      	mov	r0, r3
 8019ee6:	3710      	adds	r7, #16
 8019ee8:	46bd      	mov	sp, r7
 8019eea:	bd80      	pop	{r7, pc}

08019eec <aci_att_clt_read_resp_event_process>:
 * @param Attribute_Value The value of the attribute.
 * @retval None
 */

tBleStatus aci_att_clt_read_resp_event_process(uint8_t *buffer_in)
{
 8019eec:	b580      	push	{r7, lr}
 8019eee:	b084      	sub	sp, #16
 8019ef0:	af00      	add	r7, sp, #0
 8019ef2:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 8019ef4:	2300      	movs	r3, #0
 8019ef6:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  aci_att_clt_read_resp_event_rp0 *rp0 = (aci_att_clt_read_resp_event_rp0 *)buffer_in;
 8019ef8:	687b      	ldr	r3, [r7, #4]
 8019efa:	60bb      	str	r3, [r7, #8]
  aci_att_clt_read_resp_event(rp0->Connection_Handle,
 8019efc:	68bb      	ldr	r3, [r7, #8]
 8019efe:	881b      	ldrh	r3, [r3, #0]
 8019f00:	b298      	uxth	r0, r3
 8019f02:	68bb      	ldr	r3, [r7, #8]
 8019f04:	885b      	ldrh	r3, [r3, #2]
 8019f06:	b299      	uxth	r1, r3
                              rp0->Event_Data_Length,
                              rp0->Attribute_Value);
 8019f08:	68bb      	ldr	r3, [r7, #8]
 8019f0a:	3304      	adds	r3, #4
  aci_att_clt_read_resp_event(rp0->Connection_Handle,
 8019f0c:	461a      	mov	r2, r3
 8019f0e:	f001 fad9 	bl	801b4c4 <aci_att_clt_read_resp_event>

  return status;
 8019f12:	7bfb      	ldrb	r3, [r7, #15]
}
 8019f14:	4618      	mov	r0, r3
 8019f16:	3710      	adds	r7, #16
 8019f18:	46bd      	mov	sp, r7
 8019f1a:	bd80      	pop	{r7, pc}

08019f1c <aci_att_clt_read_blob_resp_event_process>:
 * @param Attribute_Value Part of the attribute value.
 * @retval None
 */

tBleStatus aci_att_clt_read_blob_resp_event_process(uint8_t *buffer_in)
{
 8019f1c:	b580      	push	{r7, lr}
 8019f1e:	b084      	sub	sp, #16
 8019f20:	af00      	add	r7, sp, #0
 8019f22:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 8019f24:	2300      	movs	r3, #0
 8019f26:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  aci_att_clt_read_blob_resp_event_rp0 *rp0 = (aci_att_clt_read_blob_resp_event_rp0 *)buffer_in;
 8019f28:	687b      	ldr	r3, [r7, #4]
 8019f2a:	60bb      	str	r3, [r7, #8]
  aci_att_clt_read_blob_resp_event(rp0->Connection_Handle,
 8019f2c:	68bb      	ldr	r3, [r7, #8]
 8019f2e:	881b      	ldrh	r3, [r3, #0]
 8019f30:	b298      	uxth	r0, r3
 8019f32:	68bb      	ldr	r3, [r7, #8]
 8019f34:	885b      	ldrh	r3, [r3, #2]
 8019f36:	b299      	uxth	r1, r3
                                   rp0->Event_Data_Length,
                                   rp0->Attribute_Value);
 8019f38:	68bb      	ldr	r3, [r7, #8]
 8019f3a:	3304      	adds	r3, #4
  aci_att_clt_read_blob_resp_event(rp0->Connection_Handle,
 8019f3c:	461a      	mov	r2, r3
 8019f3e:	f001 fad3 	bl	801b4e8 <aci_att_clt_read_blob_resp_event>

  return status;
 8019f42:	7bfb      	ldrb	r3, [r7, #15]
}
 8019f44:	4618      	mov	r0, r3
 8019f46:	3710      	adds	r7, #16
 8019f48:	46bd      	mov	sp, r7
 8019f4a:	bd80      	pop	{r7, pc}

08019f4c <aci_att_clt_read_multiple_resp_event_process>:
 *        the order that they were requested.
 * @retval None
 */

tBleStatus aci_att_clt_read_multiple_resp_event_process(uint8_t *buffer_in)
{
 8019f4c:	b580      	push	{r7, lr}
 8019f4e:	b084      	sub	sp, #16
 8019f50:	af00      	add	r7, sp, #0
 8019f52:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 8019f54:	2300      	movs	r3, #0
 8019f56:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  aci_att_clt_read_multiple_resp_event_rp0 *rp0 = (aci_att_clt_read_multiple_resp_event_rp0 *)buffer_in;
 8019f58:	687b      	ldr	r3, [r7, #4]
 8019f5a:	60bb      	str	r3, [r7, #8]
  aci_att_clt_read_multiple_resp_event(rp0->Connection_Handle,
 8019f5c:	68bb      	ldr	r3, [r7, #8]
 8019f5e:	881b      	ldrh	r3, [r3, #0]
 8019f60:	b298      	uxth	r0, r3
 8019f62:	68bb      	ldr	r3, [r7, #8]
 8019f64:	885b      	ldrh	r3, [r3, #2]
 8019f66:	b299      	uxth	r1, r3
                                       rp0->Event_Data_Length,
                                       rp0->Set_Of_Values);
 8019f68:	68bb      	ldr	r3, [r7, #8]
 8019f6a:	3304      	adds	r3, #4
  aci_att_clt_read_multiple_resp_event(rp0->Connection_Handle,
 8019f6c:	461a      	mov	r2, r3
 8019f6e:	f001 facd 	bl	801b50c <aci_att_clt_read_multiple_resp_event>

  return status;
 8019f72:	7bfb      	ldrb	r3, [r7, #15]
}
 8019f74:	4618      	mov	r0, r3
 8019f76:	3710      	adds	r7, #16
 8019f78:	46bd      	mov	sp, r7
 8019f7a:	bd80      	pop	{r7, pc}

08019f7c <aci_att_clt_read_by_group_type_resp_event_process>:
 *        Handle, (Attribute_Data_Length - 4 octets) for Attribute Value]
 * @retval None
 */

tBleStatus aci_att_clt_read_by_group_type_resp_event_process(uint8_t *buffer_in)
{
 8019f7c:	b580      	push	{r7, lr}
 8019f7e:	b084      	sub	sp, #16
 8019f80:	af00      	add	r7, sp, #0
 8019f82:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 8019f84:	2300      	movs	r3, #0
 8019f86:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  aci_att_clt_read_by_group_type_resp_event_rp0 *rp0 = (aci_att_clt_read_by_group_type_resp_event_rp0 *)buffer_in;
 8019f88:	687b      	ldr	r3, [r7, #4]
 8019f8a:	60bb      	str	r3, [r7, #8]
  aci_att_clt_read_by_group_type_resp_event(rp0->Connection_Handle,
 8019f8c:	68bb      	ldr	r3, [r7, #8]
 8019f8e:	881b      	ldrh	r3, [r3, #0]
 8019f90:	b298      	uxth	r0, r3
 8019f92:	68bb      	ldr	r3, [r7, #8]
 8019f94:	7899      	ldrb	r1, [r3, #2]
 8019f96:	68bb      	ldr	r3, [r7, #8]
 8019f98:	f8b3 3003 	ldrh.w	r3, [r3, #3]
 8019f9c:	b29a      	uxth	r2, r3
                                            rp0->Attribute_Data_Length,
                                            rp0->Data_Length,
                                            rp0->Attribute_Data_List);
 8019f9e:	68bb      	ldr	r3, [r7, #8]
 8019fa0:	3305      	adds	r3, #5
  aci_att_clt_read_by_group_type_resp_event(rp0->Connection_Handle,
 8019fa2:	f001 fac5 	bl	801b530 <aci_att_clt_read_by_group_type_resp_event>

  return status;
 8019fa6:	7bfb      	ldrb	r3, [r7, #15]
}
 8019fa8:	4618      	mov	r0, r3
 8019faa:	3710      	adds	r7, #16
 8019fac:	46bd      	mov	sp, r7
 8019fae:	bd80      	pop	{r7, pc}

08019fb0 <aci_att_clt_prepare_write_resp_event_process>:
 * @param Part_Attribute_Value The value of the attribute to be written
 * @retval None
 */

tBleStatus aci_att_clt_prepare_write_resp_event_process(uint8_t *buffer_in)
{
 8019fb0:	b590      	push	{r4, r7, lr}
 8019fb2:	b087      	sub	sp, #28
 8019fb4:	af02      	add	r7, sp, #8
 8019fb6:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 8019fb8:	2300      	movs	r3, #0
 8019fba:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  aci_att_clt_prepare_write_resp_event_rp0 *rp0 = (aci_att_clt_prepare_write_resp_event_rp0 *)buffer_in;
 8019fbc:	687b      	ldr	r3, [r7, #4]
 8019fbe:	60bb      	str	r3, [r7, #8]
  aci_att_clt_prepare_write_resp_event(rp0->Connection_Handle,
 8019fc0:	68bb      	ldr	r3, [r7, #8]
 8019fc2:	881b      	ldrh	r3, [r3, #0]
 8019fc4:	b298      	uxth	r0, r3
 8019fc6:	68bb      	ldr	r3, [r7, #8]
 8019fc8:	885b      	ldrh	r3, [r3, #2]
 8019fca:	b299      	uxth	r1, r3
 8019fcc:	68bb      	ldr	r3, [r7, #8]
 8019fce:	889b      	ldrh	r3, [r3, #4]
 8019fd0:	b29a      	uxth	r2, r3
 8019fd2:	68bb      	ldr	r3, [r7, #8]
 8019fd4:	88db      	ldrh	r3, [r3, #6]
 8019fd6:	b29c      	uxth	r4, r3
                                       rp0->Attribute_Handle,
                                       rp0->Offset,
                                       rp0->Part_Attribute_Value_Length,
                                       rp0->Part_Attribute_Value);
 8019fd8:	68bb      	ldr	r3, [r7, #8]
 8019fda:	3308      	adds	r3, #8
  aci_att_clt_prepare_write_resp_event(rp0->Connection_Handle,
 8019fdc:	9300      	str	r3, [sp, #0]
 8019fde:	4623      	mov	r3, r4
 8019fe0:	f001 faba 	bl	801b558 <aci_att_clt_prepare_write_resp_event>

  return status;
 8019fe4:	7bfb      	ldrb	r3, [r7, #15]
}
 8019fe6:	4618      	mov	r0, r3
 8019fe8:	3714      	adds	r7, #20
 8019fea:	46bd      	mov	sp, r7
 8019fec:	bd90      	pop	{r4, r7, pc}

08019fee <aci_att_clt_exec_write_resp_event_process>:
 * @param Connection_Handle Connection handle related to the response
 * @retval None
 */

tBleStatus aci_att_clt_exec_write_resp_event_process(uint8_t *buffer_in)
{
 8019fee:	b580      	push	{r7, lr}
 8019ff0:	b084      	sub	sp, #16
 8019ff2:	af00      	add	r7, sp, #0
 8019ff4:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 8019ff6:	2300      	movs	r3, #0
 8019ff8:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  aci_att_clt_exec_write_resp_event_rp0 *rp0 = (aci_att_clt_exec_write_resp_event_rp0 *)buffer_in;
 8019ffa:	687b      	ldr	r3, [r7, #4]
 8019ffc:	60bb      	str	r3, [r7, #8]
  aci_att_clt_exec_write_resp_event(rp0->Connection_Handle);
 8019ffe:	68bb      	ldr	r3, [r7, #8]
 801a000:	881b      	ldrh	r3, [r3, #0]
 801a002:	b29b      	uxth	r3, r3
 801a004:	4618      	mov	r0, r3
 801a006:	f001 fabf 	bl	801b588 <aci_att_clt_exec_write_resp_event>

  return status;
 801a00a:	7bfb      	ldrb	r3, [r7, #15]
}
 801a00c:	4618      	mov	r0, r3
 801a00e:	3710      	adds	r7, #16
 801a010:	46bd      	mov	sp, r7
 801a012:	bd80      	pop	{r7, pc}

0801a014 <aci_gatt_clt_indication_event_process>:
 * @param Attribute_Value The current value of the attribute
 * @retval None
 */

tBleStatus aci_gatt_clt_indication_event_process(uint8_t *buffer_in)
{
 801a014:	b580      	push	{r7, lr}
 801a016:	b084      	sub	sp, #16
 801a018:	af00      	add	r7, sp, #0
 801a01a:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 801a01c:	2300      	movs	r3, #0
 801a01e:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  aci_gatt_clt_indication_event_rp0 *rp0 = (aci_gatt_clt_indication_event_rp0 *)buffer_in;
 801a020:	687b      	ldr	r3, [r7, #4]
 801a022:	60bb      	str	r3, [r7, #8]
  aci_gatt_clt_indication_event(rp0->Connection_Handle,
 801a024:	68bb      	ldr	r3, [r7, #8]
 801a026:	881b      	ldrh	r3, [r3, #0]
 801a028:	b298      	uxth	r0, r3
 801a02a:	68bb      	ldr	r3, [r7, #8]
 801a02c:	885b      	ldrh	r3, [r3, #2]
 801a02e:	b299      	uxth	r1, r3
 801a030:	68bb      	ldr	r3, [r7, #8]
 801a032:	889b      	ldrh	r3, [r3, #4]
 801a034:	b29a      	uxth	r2, r3
                                rp0->Attribute_Handle,
                                rp0->Attribute_Value_Length,
                                rp0->Attribute_Value);
 801a036:	68bb      	ldr	r3, [r7, #8]
 801a038:	3306      	adds	r3, #6
  aci_gatt_clt_indication_event(rp0->Connection_Handle,
 801a03a:	f004 facd 	bl	801e5d8 <aci_gatt_clt_indication_event>

  return status;
 801a03e:	7bfb      	ldrb	r3, [r7, #15]
}
 801a040:	4618      	mov	r0, r3
 801a042:	3710      	adds	r7, #16
 801a044:	46bd      	mov	sp, r7
 801a046:	bd80      	pop	{r7, pc}

0801a048 <aci_gatt_clt_notification_event_process>:
 * @param Attribute_Value The current value of the attribute
 * @retval None
 */

tBleStatus aci_gatt_clt_notification_event_process(uint8_t *buffer_in)
{
 801a048:	b580      	push	{r7, lr}
 801a04a:	b084      	sub	sp, #16
 801a04c:	af00      	add	r7, sp, #0
 801a04e:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 801a050:	2300      	movs	r3, #0
 801a052:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  aci_gatt_clt_notification_event_rp0 *rp0 = (aci_gatt_clt_notification_event_rp0 *)buffer_in;
 801a054:	687b      	ldr	r3, [r7, #4]
 801a056:	60bb      	str	r3, [r7, #8]
  aci_gatt_clt_notification_event(rp0->Connection_Handle,
 801a058:	68bb      	ldr	r3, [r7, #8]
 801a05a:	881b      	ldrh	r3, [r3, #0]
 801a05c:	b298      	uxth	r0, r3
 801a05e:	68bb      	ldr	r3, [r7, #8]
 801a060:	885b      	ldrh	r3, [r3, #2]
 801a062:	b299      	uxth	r1, r3
 801a064:	68bb      	ldr	r3, [r7, #8]
 801a066:	889b      	ldrh	r3, [r3, #4]
 801a068:	b29a      	uxth	r2, r3
                                  rp0->Attribute_Handle,
                                  rp0->Attribute_Value_Length,
                                  rp0->Attribute_Value);
 801a06a:	68bb      	ldr	r3, [r7, #8]
 801a06c:	3306      	adds	r3, #6
  aci_gatt_clt_notification_event(rp0->Connection_Handle,
 801a06e:	f001 fa99 	bl	801b5a4 <aci_gatt_clt_notification_event>

  return status;
 801a072:	7bfb      	ldrb	r3, [r7, #15]
}
 801a074:	4618      	mov	r0, r3
 801a076:	3710      	adds	r7, #16
 801a078:	46bd      	mov	sp, r7
 801a07a:	bd80      	pop	{r7, pc}

0801a07c <aci_gatt_clt_proc_complete_event_process>:
 *        2, part D. For proprietary error code refer to Error codes section.
 * @retval None
 */

tBleStatus aci_gatt_clt_proc_complete_event_process(uint8_t *buffer_in)
{
 801a07c:	b580      	push	{r7, lr}
 801a07e:	b084      	sub	sp, #16
 801a080:	af00      	add	r7, sp, #0
 801a082:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 801a084:	2300      	movs	r3, #0
 801a086:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  aci_gatt_clt_proc_complete_event_rp0 *rp0 = (aci_gatt_clt_proc_complete_event_rp0 *)buffer_in;
 801a088:	687b      	ldr	r3, [r7, #4]
 801a08a:	60bb      	str	r3, [r7, #8]
  aci_gatt_clt_proc_complete_event(rp0->Connection_Handle,
 801a08c:	68bb      	ldr	r3, [r7, #8]
 801a08e:	881b      	ldrh	r3, [r3, #0]
 801a090:	b29a      	uxth	r2, r3
 801a092:	68bb      	ldr	r3, [r7, #8]
 801a094:	789b      	ldrb	r3, [r3, #2]
 801a096:	4619      	mov	r1, r3
 801a098:	4610      	mov	r0, r2
 801a09a:	f004 fa59 	bl	801e550 <aci_gatt_clt_proc_complete_event>
                                   rp0->Error_Code);

  return status;
 801a09e:	7bfb      	ldrb	r3, [r7, #15]
}
 801a0a0:	4618      	mov	r0, r3
 801a0a2:	3710      	adds	r7, #16
 801a0a4:	46bd      	mov	sp, r7
 801a0a6:	bd80      	pop	{r7, pc}

0801a0a8 <aci_gatt_clt_error_resp_event_process>:
 *        - 0x11: Insufficient resources
 * @retval None
 */

tBleStatus aci_gatt_clt_error_resp_event_process(uint8_t *buffer_in)
{
 801a0a8:	b580      	push	{r7, lr}
 801a0aa:	b084      	sub	sp, #16
 801a0ac:	af00      	add	r7, sp, #0
 801a0ae:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 801a0b0:	2300      	movs	r3, #0
 801a0b2:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  aci_gatt_clt_error_resp_event_rp0 *rp0 = (aci_gatt_clt_error_resp_event_rp0 *)buffer_in;
 801a0b4:	687b      	ldr	r3, [r7, #4]
 801a0b6:	60bb      	str	r3, [r7, #8]
  aci_gatt_clt_error_resp_event(rp0->Connection_Handle,
 801a0b8:	68bb      	ldr	r3, [r7, #8]
 801a0ba:	881b      	ldrh	r3, [r3, #0]
 801a0bc:	b298      	uxth	r0, r3
 801a0be:	68bb      	ldr	r3, [r7, #8]
 801a0c0:	7899      	ldrb	r1, [r3, #2]
 801a0c2:	68bb      	ldr	r3, [r7, #8]
 801a0c4:	f8b3 3003 	ldrh.w	r3, [r3, #3]
 801a0c8:	b29a      	uxth	r2, r3
 801a0ca:	68bb      	ldr	r3, [r7, #8]
 801a0cc:	795b      	ldrb	r3, [r3, #5]
 801a0ce:	f001 fa7d 	bl	801b5cc <aci_gatt_clt_error_resp_event>
                                rp0->Req_Opcode,
                                rp0->Attribute_Handle,
                                rp0->Error_Code);

  return status;
 801a0d2:	7bfb      	ldrb	r3, [r7, #15]
}
 801a0d4:	4618      	mov	r0, r3
 801a0d6:	3710      	adds	r7, #16
 801a0d8:	46bd      	mov	sp, r7
 801a0da:	bd80      	pop	{r7, pc}

0801a0dc <aci_gatt_clt_disc_read_char_by_uuid_resp_event_process>:
 *        Characteristic UUID" has been performed.
 * @retval None
 */

tBleStatus aci_gatt_clt_disc_read_char_by_uuid_resp_event_process(uint8_t *buffer_in)
{
 801a0dc:	b580      	push	{r7, lr}
 801a0de:	b084      	sub	sp, #16
 801a0e0:	af00      	add	r7, sp, #0
 801a0e2:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 801a0e4:	2300      	movs	r3, #0
 801a0e6:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  aci_gatt_clt_disc_read_char_by_uuid_resp_event_rp0 *rp0 = (aci_gatt_clt_disc_read_char_by_uuid_resp_event_rp0 *)buffer_in;
 801a0e8:	687b      	ldr	r3, [r7, #4]
 801a0ea:	60bb      	str	r3, [r7, #8]
  aci_gatt_clt_disc_read_char_by_uuid_resp_event(rp0->Connection_Handle,
 801a0ec:	68bb      	ldr	r3, [r7, #8]
 801a0ee:	881b      	ldrh	r3, [r3, #0]
 801a0f0:	b298      	uxth	r0, r3
 801a0f2:	68bb      	ldr	r3, [r7, #8]
 801a0f4:	885b      	ldrh	r3, [r3, #2]
 801a0f6:	b299      	uxth	r1, r3
 801a0f8:	68bb      	ldr	r3, [r7, #8]
 801a0fa:	791a      	ldrb	r2, [r3, #4]
                                                 rp0->Attribute_Handle,
                                                 rp0->Attribute_Value_Length,
                                                 rp0->Attribute_Value);
 801a0fc:	68bb      	ldr	r3, [r7, #8]
 801a0fe:	3305      	adds	r3, #5
  aci_gatt_clt_disc_read_char_by_uuid_resp_event(rp0->Connection_Handle,
 801a100:	f001 fa7c 	bl	801b5fc <aci_gatt_clt_disc_read_char_by_uuid_resp_event>

  return status;
 801a104:	7bfb      	ldrb	r3, [r7, #15]
}
 801a106:	4618      	mov	r0, r3
 801a108:	3710      	adds	r7, #16
 801a10a:	46bd      	mov	sp, r7
 801a10c:	bd80      	pop	{r7, pc}

0801a10e <aci_gatt_tx_pool_available_event_process>:
 * @param Available_Buffers Not used.
 * @retval None
 */

tBleStatus aci_gatt_tx_pool_available_event_process(uint8_t *buffer_in)
{
 801a10e:	b580      	push	{r7, lr}
 801a110:	b084      	sub	sp, #16
 801a112:	af00      	add	r7, sp, #0
 801a114:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 801a116:	2300      	movs	r3, #0
 801a118:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  aci_gatt_tx_pool_available_event_rp0 *rp0 = (aci_gatt_tx_pool_available_event_rp0 *)buffer_in;
 801a11a:	687b      	ldr	r3, [r7, #4]
 801a11c:	60bb      	str	r3, [r7, #8]
  aci_gatt_tx_pool_available_event(rp0->Connection_Handle,
 801a11e:	68bb      	ldr	r3, [r7, #8]
 801a120:	881b      	ldrh	r3, [r3, #0]
 801a122:	b29a      	uxth	r2, r3
 801a124:	68bb      	ldr	r3, [r7, #8]
 801a126:	885b      	ldrh	r3, [r3, #2]
 801a128:	b29b      	uxth	r3, r3
 801a12a:	4619      	mov	r1, r3
 801a12c:	4610      	mov	r0, r2
 801a12e:	f003 fbf1 	bl	801d914 <aci_gatt_tx_pool_available_event>
                                   rp0->Available_Buffers);

  return status;
 801a132:	7bfb      	ldrb	r3, [r7, #15]
}
 801a134:	4618      	mov	r0, r3
 801a136:	3710      	adds	r7, #16
 801a138:	46bd      	mov	sp, r7
 801a13a:	bd80      	pop	{r7, pc}

0801a13c <aci_gatt_srv_confirmation_event_process>:
 * @param Connection_Handle Connection handle related to the event.
 * @retval None
 */

tBleStatus aci_gatt_srv_confirmation_event_process(uint8_t *buffer_in)
{
 801a13c:	b580      	push	{r7, lr}
 801a13e:	b084      	sub	sp, #16
 801a140:	af00      	add	r7, sp, #0
 801a142:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 801a144:	2300      	movs	r3, #0
 801a146:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  aci_gatt_srv_confirmation_event_rp0 *rp0 = (aci_gatt_srv_confirmation_event_rp0 *)buffer_in;
 801a148:	687b      	ldr	r3, [r7, #4]
 801a14a:	60bb      	str	r3, [r7, #8]
  aci_gatt_srv_confirmation_event(rp0->Connection_Handle);
 801a14c:	68bb      	ldr	r3, [r7, #8]
 801a14e:	881b      	ldrh	r3, [r3, #0]
 801a150:	b29b      	uxth	r3, r3
 801a152:	4618      	mov	r0, r3
 801a154:	f001 fa66 	bl	801b624 <aci_gatt_srv_confirmation_event>

  return status;
 801a158:	7bfb      	ldrb	r3, [r7, #15]
}
 801a15a:	4618      	mov	r0, r3
 801a15c:	3710      	adds	r7, #16
 801a15e:	46bd      	mov	sp, r7
 801a160:	bd80      	pop	{r7, pc}

0801a162 <aci_att_srv_exec_write_req_event_process>:
 *        - 0x01: EXECUTE
 * @retval None
 */

tBleStatus aci_att_srv_exec_write_req_event_process(uint8_t *buffer_in)
{
 801a162:	b580      	push	{r7, lr}
 801a164:	b084      	sub	sp, #16
 801a166:	af00      	add	r7, sp, #0
 801a168:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 801a16a:	2300      	movs	r3, #0
 801a16c:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  aci_att_srv_exec_write_req_event_rp0 *rp0 = (aci_att_srv_exec_write_req_event_rp0 *)buffer_in;
 801a16e:	687b      	ldr	r3, [r7, #4]
 801a170:	60bb      	str	r3, [r7, #8]
  aci_att_srv_exec_write_req_event(rp0->Connection_Handle,
 801a172:	68bb      	ldr	r3, [r7, #8]
 801a174:	881b      	ldrh	r3, [r3, #0]
 801a176:	b29a      	uxth	r2, r3
 801a178:	68bb      	ldr	r3, [r7, #8]
 801a17a:	789b      	ldrb	r3, [r3, #2]
 801a17c:	4619      	mov	r1, r3
 801a17e:	4610      	mov	r0, r2
 801a180:	f001 fa5e 	bl	801b640 <aci_att_srv_exec_write_req_event>
                                   rp0->Flags);

  return status;
 801a184:	7bfb      	ldrb	r3, [r7, #15]
}
 801a186:	4618      	mov	r0, r3
 801a188:	3710      	adds	r7, #16
 801a18a:	46bd      	mov	sp, r7
 801a18c:	bd80      	pop	{r7, pc}

0801a18e <aci_gatt_srv_authorize_nwk_event_process>:
 * @param Data The data that the client has requested to write
 * @retval None
 */

tBleStatus aci_gatt_srv_authorize_nwk_event_process(uint8_t *buffer_in)
{
 801a18e:	b5b0      	push	{r4, r5, r7, lr}
 801a190:	b086      	sub	sp, #24
 801a192:	af02      	add	r7, sp, #8
 801a194:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 801a196:	2300      	movs	r3, #0
 801a198:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  aci_gatt_srv_authorize_nwk_event_rp0 *rp0 = (aci_gatt_srv_authorize_nwk_event_rp0 *)buffer_in;
 801a19a:	687b      	ldr	r3, [r7, #4]
 801a19c:	60bb      	str	r3, [r7, #8]
  aci_gatt_srv_authorize_nwk_event(rp0->Conn_Handle,
 801a19e:	68bb      	ldr	r3, [r7, #8]
 801a1a0:	881b      	ldrh	r3, [r3, #0]
 801a1a2:	b298      	uxth	r0, r3
 801a1a4:	68bb      	ldr	r3, [r7, #8]
 801a1a6:	885b      	ldrh	r3, [r3, #2]
 801a1a8:	b299      	uxth	r1, r3
 801a1aa:	68bb      	ldr	r3, [r7, #8]
 801a1ac:	791c      	ldrb	r4, [r3, #4]
 801a1ae:	68bb      	ldr	r3, [r7, #8]
 801a1b0:	f8b3 3005 	ldrh.w	r3, [r3, #5]
 801a1b4:	b29d      	uxth	r5, r3
 801a1b6:	68bb      	ldr	r3, [r7, #8]
 801a1b8:	79db      	ldrb	r3, [r3, #7]
                                   rp0->Attr_Handle,
                                   rp0->Operation_Type,
                                   rp0->Attr_Val_Offset,
                                   rp0->Data_Length,
                                   rp0->Data);
 801a1ba:	68ba      	ldr	r2, [r7, #8]
 801a1bc:	3208      	adds	r2, #8
  aci_gatt_srv_authorize_nwk_event(rp0->Conn_Handle,
 801a1be:	9201      	str	r2, [sp, #4]
 801a1c0:	9300      	str	r3, [sp, #0]
 801a1c2:	462b      	mov	r3, r5
 801a1c4:	4622      	mov	r2, r4
 801a1c6:	f003 ff35 	bl	801e034 <aci_gatt_srv_authorize_nwk_event>

  return status;
 801a1ca:	7bfb      	ldrb	r3, [r7, #15]
}
 801a1cc:	4618      	mov	r0, r3
 801a1ce:	3710      	adds	r7, #16
 801a1d0:	46bd      	mov	sp, r7
 801a1d2:	bdb0      	pop	{r4, r5, r7, pc}

0801a1d4 <hci_le_connection_complete_event_process>:
 *        - 0x07: 20 ppm
 * @retval None
 */

tBleStatus hci_le_connection_complete_event_process(uint8_t *buffer_in)
{
 801a1d4:	b5f0      	push	{r4, r5, r6, r7, lr}
 801a1d6:	b08b      	sub	sp, #44	@ 0x2c
 801a1d8:	af06      	add	r7, sp, #24
 801a1da:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 801a1dc:	2300      	movs	r3, #0
 801a1de:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  hci_le_connection_complete_event_rp0 *rp0 = (hci_le_connection_complete_event_rp0 *)buffer_in;
 801a1e0:	687b      	ldr	r3, [r7, #4]
 801a1e2:	60bb      	str	r3, [r7, #8]
  hci_le_connection_complete_event(rp0->Status,
 801a1e4:	68bb      	ldr	r3, [r7, #8]
 801a1e6:	781d      	ldrb	r5, [r3, #0]
 801a1e8:	68bb      	ldr	r3, [r7, #8]
 801a1ea:	f8b3 3001 	ldrh.w	r3, [r3, #1]
 801a1ee:	b29e      	uxth	r6, r3
 801a1f0:	68bb      	ldr	r3, [r7, #8]
 801a1f2:	f893 c003 	ldrb.w	ip, [r3, #3]
 801a1f6:	68bb      	ldr	r3, [r7, #8]
 801a1f8:	f893 e004 	ldrb.w	lr, [r3, #4]
                                   rp0->Connection_Handle,
                                   rp0->Role,
                                   rp0->Peer_Address_Type,
                                   rp0->Peer_Address,
 801a1fc:	68bb      	ldr	r3, [r7, #8]
 801a1fe:	3305      	adds	r3, #5
  hci_le_connection_complete_event(rp0->Status,
 801a200:	68ba      	ldr	r2, [r7, #8]
 801a202:	f8b2 200b 	ldrh.w	r2, [r2, #11]
 801a206:	b292      	uxth	r2, r2
 801a208:	68b9      	ldr	r1, [r7, #8]
 801a20a:	f8b1 100d 	ldrh.w	r1, [r1, #13]
 801a20e:	b289      	uxth	r1, r1
 801a210:	68b8      	ldr	r0, [r7, #8]
 801a212:	f8b0 000f 	ldrh.w	r0, [r0, #15]
 801a216:	b280      	uxth	r0, r0
 801a218:	68bc      	ldr	r4, [r7, #8]
 801a21a:	7c64      	ldrb	r4, [r4, #17]
 801a21c:	9404      	str	r4, [sp, #16]
 801a21e:	9003      	str	r0, [sp, #12]
 801a220:	9102      	str	r1, [sp, #8]
 801a222:	9201      	str	r2, [sp, #4]
 801a224:	9300      	str	r3, [sp, #0]
 801a226:	4673      	mov	r3, lr
 801a228:	4662      	mov	r2, ip
 801a22a:	4631      	mov	r1, r6
 801a22c:	4628      	mov	r0, r5
 801a22e:	f003 fe67 	bl	801df00 <hci_le_connection_complete_event>
                                   rp0->Conn_Interval,
                                   rp0->Conn_Latency,
                                   rp0->Supervision_Timeout,
                                   rp0->Master_Clock_Accuracy);

  return status;
 801a232:	7bfb      	ldrb	r3, [r7, #15]
}
 801a234:	4618      	mov	r0, r3
 801a236:	3714      	adds	r7, #20
 801a238:	46bd      	mov	sp, r7
 801a23a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0801a23c <hci_le_advertising_report_event_process>:
 * @param Advertising_Report See @ref Advertising_Report_t
 * @retval None
 */

tBleStatus hci_le_advertising_report_event_process(uint8_t *buffer_in)
{
 801a23c:	b580      	push	{r7, lr}
 801a23e:	b0c8      	sub	sp, #288	@ 0x120
 801a240:	af00      	add	r7, sp, #0
 801a242:	f507 7390 	add.w	r3, r7, #288	@ 0x120
 801a246:	f5a3 738e 	sub.w	r3, r3, #284	@ 0x11c
 801a24a:	6018      	str	r0, [r3, #0]
  tBleStatus status = BLE_STATUS_SUCCESS;
 801a24c:	2300      	movs	r3, #0
 801a24e:	f887 3117 	strb.w	r3, [r7, #279]	@ 0x117
  /* Input params */
  hci_le_advertising_report_event_rp0 *rp0 = (hci_le_advertising_report_event_rp0 *)buffer_in;
 801a252:	f507 7390 	add.w	r3, r7, #288	@ 0x120
 801a256:	f5a3 738e 	sub.w	r3, r3, #284	@ 0x11c
 801a25a:	681b      	ldr	r3, [r3, #0]
 801a25c:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110
  uint8_t size = 1;
 801a260:	2301      	movs	r3, #1
 801a262:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f
  int i;
  Advertising_Report_t Advertising_Report[HCI_MAX_PAYLOAD_SIZE/sizeof(Advertising_Report_t)];
  for (i = 0; i < rp0->Num_Reports; i++) {
 801a266:	2300      	movs	r3, #0
 801a268:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118
 801a26c:	e0c5      	b.n	801a3fa <hci_le_advertising_report_event_process+0x1be>
    Advertising_Report[i].Event_Type = rp0->Advertising_Report[i].Event_Type;
 801a26e:	f8d7 1110 	ldr.w	r1, [r7, #272]	@ 0x110
 801a272:	f8d7 2118 	ldr.w	r2, [r7, #280]	@ 0x118
 801a276:	4613      	mov	r3, r2
 801a278:	009b      	lsls	r3, r3, #2
 801a27a:	4413      	add	r3, r2
 801a27c:	005b      	lsls	r3, r3, #1
 801a27e:	4413      	add	r3, r2
 801a280:	440b      	add	r3, r1
 801a282:	3301      	adds	r3, #1
 801a284:	7818      	ldrb	r0, [r3, #0]
 801a286:	f507 7390 	add.w	r3, r7, #288	@ 0x120
 801a28a:	f5a3 718a 	sub.w	r1, r3, #276	@ 0x114
 801a28e:	f8d7 2118 	ldr.w	r2, [r7, #280]	@ 0x118
 801a292:	4613      	mov	r3, r2
 801a294:	009b      	lsls	r3, r3, #2
 801a296:	4413      	add	r3, r2
 801a298:	009b      	lsls	r3, r3, #2
 801a29a:	440b      	add	r3, r1
 801a29c:	4602      	mov	r2, r0
 801a29e:	701a      	strb	r2, [r3, #0]
    size += 1;
 801a2a0:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 801a2a4:	3301      	adds	r3, #1
 801a2a6:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f
    Advertising_Report[i].Address_Type = rp0->Advertising_Report[i].Address_Type;
 801a2aa:	f8d7 1110 	ldr.w	r1, [r7, #272]	@ 0x110
 801a2ae:	f8d7 2118 	ldr.w	r2, [r7, #280]	@ 0x118
 801a2b2:	4613      	mov	r3, r2
 801a2b4:	009b      	lsls	r3, r3, #2
 801a2b6:	4413      	add	r3, r2
 801a2b8:	005b      	lsls	r3, r3, #1
 801a2ba:	4413      	add	r3, r2
 801a2bc:	440b      	add	r3, r1
 801a2be:	3302      	adds	r3, #2
 801a2c0:	7818      	ldrb	r0, [r3, #0]
 801a2c2:	f507 7390 	add.w	r3, r7, #288	@ 0x120
 801a2c6:	f5a3 718a 	sub.w	r1, r3, #276	@ 0x114
 801a2ca:	f8d7 2118 	ldr.w	r2, [r7, #280]	@ 0x118
 801a2ce:	4613      	mov	r3, r2
 801a2d0:	009b      	lsls	r3, r3, #2
 801a2d2:	4413      	add	r3, r2
 801a2d4:	009b      	lsls	r3, r3, #2
 801a2d6:	440b      	add	r3, r1
 801a2d8:	3301      	adds	r3, #1
 801a2da:	4602      	mov	r2, r0
 801a2dc:	701a      	strb	r2, [r3, #0]
    size += 1;
 801a2de:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 801a2e2:	3301      	adds	r3, #1
 801a2e4:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f
    BLUENRG_memcpy((void *) Advertising_Report[i].Address, (const void *) rp0->Advertising_Report[i].Address, 6);
 801a2e8:	f107 010c 	add.w	r1, r7, #12
 801a2ec:	f8d7 2118 	ldr.w	r2, [r7, #280]	@ 0x118
 801a2f0:	4613      	mov	r3, r2
 801a2f2:	009b      	lsls	r3, r3, #2
 801a2f4:	4413      	add	r3, r2
 801a2f6:	009b      	lsls	r3, r3, #2
 801a2f8:	440b      	add	r3, r1
 801a2fa:	1c98      	adds	r0, r3, #2
 801a2fc:	f8d7 2118 	ldr.w	r2, [r7, #280]	@ 0x118
 801a300:	4613      	mov	r3, r2
 801a302:	009b      	lsls	r3, r3, #2
 801a304:	4413      	add	r3, r2
 801a306:	005b      	lsls	r3, r3, #1
 801a308:	4413      	add	r3, r2
 801a30a:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 801a30e:	4413      	add	r3, r2
 801a310:	3303      	adds	r3, #3
 801a312:	2206      	movs	r2, #6
 801a314:	4619      	mov	r1, r3
 801a316:	f009 ff6a 	bl	80241ee <memcpy>
    size += 6;
 801a31a:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 801a31e:	3306      	adds	r3, #6
 801a320:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f
    Advertising_Report[i].Data_Length = rp0->Advertising_Report[i].Data_Length;
 801a324:	f8d7 1110 	ldr.w	r1, [r7, #272]	@ 0x110
 801a328:	f8d7 2118 	ldr.w	r2, [r7, #280]	@ 0x118
 801a32c:	4613      	mov	r3, r2
 801a32e:	009b      	lsls	r3, r3, #2
 801a330:	4413      	add	r3, r2
 801a332:	005b      	lsls	r3, r3, #1
 801a334:	4413      	add	r3, r2
 801a336:	440b      	add	r3, r1
 801a338:	3309      	adds	r3, #9
 801a33a:	7818      	ldrb	r0, [r3, #0]
 801a33c:	f507 7390 	add.w	r3, r7, #288	@ 0x120
 801a340:	f5a3 718a 	sub.w	r1, r3, #276	@ 0x114
 801a344:	f8d7 2118 	ldr.w	r2, [r7, #280]	@ 0x118
 801a348:	4613      	mov	r3, r2
 801a34a:	009b      	lsls	r3, r3, #2
 801a34c:	4413      	add	r3, r2
 801a34e:	009b      	lsls	r3, r3, #2
 801a350:	440b      	add	r3, r1
 801a352:	3308      	adds	r3, #8
 801a354:	4602      	mov	r2, r0
 801a356:	701a      	strb	r2, [r3, #0]
    size += 1;
 801a358:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 801a35c:	3301      	adds	r3, #1
 801a35e:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f
    Advertising_Report[i].Data = rp0->Advertising_Report[i].Data;
 801a362:	f8d7 2118 	ldr.w	r2, [r7, #280]	@ 0x118
 801a366:	4613      	mov	r3, r2
 801a368:	009b      	lsls	r3, r3, #2
 801a36a:	4413      	add	r3, r2
 801a36c:	005b      	lsls	r3, r3, #1
 801a36e:	4413      	add	r3, r2
 801a370:	3308      	adds	r3, #8
 801a372:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 801a376:	4413      	add	r3, r2
 801a378:	1c99      	adds	r1, r3, #2
 801a37a:	f507 7390 	add.w	r3, r7, #288	@ 0x120
 801a37e:	f5a3 708a 	sub.w	r0, r3, #276	@ 0x114
 801a382:	f8d7 2118 	ldr.w	r2, [r7, #280]	@ 0x118
 801a386:	4613      	mov	r3, r2
 801a388:	009b      	lsls	r3, r3, #2
 801a38a:	4413      	add	r3, r2
 801a38c:	009b      	lsls	r3, r3, #2
 801a38e:	4403      	add	r3, r0
 801a390:	330c      	adds	r3, #12
 801a392:	6019      	str	r1, [r3, #0]
    size += rp0->Advertising_Report[i].Data_Length;
 801a394:	f8d7 1110 	ldr.w	r1, [r7, #272]	@ 0x110
 801a398:	f8d7 2118 	ldr.w	r2, [r7, #280]	@ 0x118
 801a39c:	4613      	mov	r3, r2
 801a39e:	009b      	lsls	r3, r3, #2
 801a3a0:	4413      	add	r3, r2
 801a3a2:	005b      	lsls	r3, r3, #1
 801a3a4:	4413      	add	r3, r2
 801a3a6:	440b      	add	r3, r1
 801a3a8:	3309      	adds	r3, #9
 801a3aa:	781a      	ldrb	r2, [r3, #0]
 801a3ac:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 801a3b0:	4413      	add	r3, r2
 801a3b2:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f
    Advertising_Report[i].RSSI = (uint8_t)buffer_in[size];
 801a3b6:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 801a3ba:	f507 7290 	add.w	r2, r7, #288	@ 0x120
 801a3be:	f5a2 728e 	sub.w	r2, r2, #284	@ 0x11c
 801a3c2:	6812      	ldr	r2, [r2, #0]
 801a3c4:	4413      	add	r3, r2
 801a3c6:	781b      	ldrb	r3, [r3, #0]
 801a3c8:	b258      	sxtb	r0, r3
 801a3ca:	f507 7390 	add.w	r3, r7, #288	@ 0x120
 801a3ce:	f5a3 718a 	sub.w	r1, r3, #276	@ 0x114
 801a3d2:	f8d7 2118 	ldr.w	r2, [r7, #280]	@ 0x118
 801a3d6:	4613      	mov	r3, r2
 801a3d8:	009b      	lsls	r3, r3, #2
 801a3da:	4413      	add	r3, r2
 801a3dc:	009b      	lsls	r3, r3, #2
 801a3de:	440b      	add	r3, r1
 801a3e0:	3310      	adds	r3, #16
 801a3e2:	4602      	mov	r2, r0
 801a3e4:	701a      	strb	r2, [r3, #0]
    size += 1;
 801a3e6:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 801a3ea:	3301      	adds	r3, #1
 801a3ec:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f
  for (i = 0; i < rp0->Num_Reports; i++) {
 801a3f0:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 801a3f4:	3301      	adds	r3, #1
 801a3f6:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118
 801a3fa:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 801a3fe:	781b      	ldrb	r3, [r3, #0]
 801a400:	461a      	mov	r2, r3
 801a402:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 801a406:	4293      	cmp	r3, r2
 801a408:	f6ff af31 	blt.w	801a26e <hci_le_advertising_report_event_process+0x32>
  }
  hci_le_advertising_report_event(rp0->Num_Reports,
 801a40c:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 801a410:	781b      	ldrb	r3, [r3, #0]
 801a412:	f107 020c 	add.w	r2, r7, #12
 801a416:	4611      	mov	r1, r2
 801a418:	4618      	mov	r0, r3
 801a41a:	f7e7 fa07 	bl	800182c <hci_le_advertising_report_event>
                                  Advertising_Report);

  return status;
 801a41e:	f897 3117 	ldrb.w	r3, [r7, #279]	@ 0x117
}
 801a422:	4618      	mov	r0, r3
 801a424:	f507 7790 	add.w	r7, r7, #288	@ 0x120
 801a428:	46bd      	mov	sp, r7
 801a42a:	bd80      	pop	{r7, pc}

0801a42c <hci_le_connection_update_complete_event_process>:
 *        - 0x000A (100 ms)  ... 0x0C80 (32000 ms) 
 * @retval None
 */

tBleStatus hci_le_connection_update_complete_event_process(uint8_t *buffer_in)
{
 801a42c:	b590      	push	{r4, r7, lr}
 801a42e:	b087      	sub	sp, #28
 801a430:	af02      	add	r7, sp, #8
 801a432:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 801a434:	2300      	movs	r3, #0
 801a436:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  hci_le_connection_update_complete_event_rp0 *rp0 = (hci_le_connection_update_complete_event_rp0 *)buffer_in;
 801a438:	687b      	ldr	r3, [r7, #4]
 801a43a:	60bb      	str	r3, [r7, #8]
  hci_le_connection_update_complete_event(rp0->Status,
 801a43c:	68bb      	ldr	r3, [r7, #8]
 801a43e:	7818      	ldrb	r0, [r3, #0]
 801a440:	68bb      	ldr	r3, [r7, #8]
 801a442:	f8b3 3001 	ldrh.w	r3, [r3, #1]
 801a446:	b299      	uxth	r1, r3
 801a448:	68bb      	ldr	r3, [r7, #8]
 801a44a:	f8b3 3003 	ldrh.w	r3, [r3, #3]
 801a44e:	b29a      	uxth	r2, r3
 801a450:	68bb      	ldr	r3, [r7, #8]
 801a452:	f8b3 3005 	ldrh.w	r3, [r3, #5]
 801a456:	b29c      	uxth	r4, r3
 801a458:	68bb      	ldr	r3, [r7, #8]
 801a45a:	f8b3 3007 	ldrh.w	r3, [r3, #7]
 801a45e:	b29b      	uxth	r3, r3
 801a460:	9300      	str	r3, [sp, #0]
 801a462:	4623      	mov	r3, r4
 801a464:	f004 f81a 	bl	801e49c <hci_le_connection_update_complete_event>
                                          rp0->Connection_Handle,
                                          rp0->Conn_Interval,
                                          rp0->Conn_Latency,
                                          rp0->Supervision_Timeout);

  return status;
 801a468:	7bfb      	ldrb	r3, [r7, #15]
}
 801a46a:	4618      	mov	r0, r3
 801a46c:	3714      	adds	r7, #20
 801a46e:	46bd      	mov	sp, r7
 801a470:	bd90      	pop	{r4, r7, pc}

0801a472 <hci_le_read_remote_used_features_complete_event_process>:
 *        Layer specification.
 * @retval None
 */

tBleStatus hci_le_read_remote_used_features_complete_event_process(uint8_t *buffer_in)
{
 801a472:	b580      	push	{r7, lr}
 801a474:	b084      	sub	sp, #16
 801a476:	af00      	add	r7, sp, #0
 801a478:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 801a47a:	2300      	movs	r3, #0
 801a47c:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  hci_le_read_remote_used_features_complete_event_rp0 *rp0 = (hci_le_read_remote_used_features_complete_event_rp0 *)buffer_in;
 801a47e:	687b      	ldr	r3, [r7, #4]
 801a480:	60bb      	str	r3, [r7, #8]
  hci_le_read_remote_used_features_complete_event(rp0->Status,
 801a482:	68bb      	ldr	r3, [r7, #8]
 801a484:	7818      	ldrb	r0, [r3, #0]
 801a486:	68bb      	ldr	r3, [r7, #8]
 801a488:	f8b3 3001 	ldrh.w	r3, [r3, #1]
 801a48c:	b299      	uxth	r1, r3
                                                  rp0->Connection_Handle,
                                                  rp0->LE_Features);
 801a48e:	68bb      	ldr	r3, [r7, #8]
 801a490:	3303      	adds	r3, #3
  hci_le_read_remote_used_features_complete_event(rp0->Status,
 801a492:	461a      	mov	r2, r3
 801a494:	f000 fe18 	bl	801b0c8 <hci_le_read_remote_used_features_complete_event>

  return status;
 801a498:	7bfb      	ldrb	r3, [r7, #15]
}
 801a49a:	4618      	mov	r0, r3
 801a49c:	3710      	adds	r7, #16
 801a49e:	46bd      	mov	sp, r7
 801a4a0:	bd80      	pop	{r7, pc}

0801a4a2 <hci_le_long_term_key_request_event_process>:
 * @param Encrypted_Diversifier 16-bit encrypted diversifier
 * @retval None
 */

tBleStatus hci_le_long_term_key_request_event_process(uint8_t *buffer_in)
{
 801a4a2:	b580      	push	{r7, lr}
 801a4a4:	b084      	sub	sp, #16
 801a4a6:	af00      	add	r7, sp, #0
 801a4a8:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 801a4aa:	2300      	movs	r3, #0
 801a4ac:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  hci_le_long_term_key_request_event_rp0 *rp0 = (hci_le_long_term_key_request_event_rp0 *)buffer_in;
 801a4ae:	687b      	ldr	r3, [r7, #4]
 801a4b0:	60bb      	str	r3, [r7, #8]
  hci_le_long_term_key_request_event(rp0->Connection_Handle,
 801a4b2:	68bb      	ldr	r3, [r7, #8]
 801a4b4:	881b      	ldrh	r3, [r3, #0]
 801a4b6:	b298      	uxth	r0, r3
                                     rp0->Random_Number,
 801a4b8:	68bb      	ldr	r3, [r7, #8]
 801a4ba:	1c99      	adds	r1, r3, #2
  hci_le_long_term_key_request_event(rp0->Connection_Handle,
 801a4bc:	68bb      	ldr	r3, [r7, #8]
 801a4be:	895b      	ldrh	r3, [r3, #10]
 801a4c0:	b29b      	uxth	r3, r3
 801a4c2:	461a      	mov	r2, r3
 801a4c4:	f000 fe12 	bl	801b0ec <hci_le_long_term_key_request_event>
                                     rp0->Encrypted_Diversifier);

  return status;
 801a4c8:	7bfb      	ldrb	r3, [r7, #15]
}
 801a4ca:	4618      	mov	r0, r3
 801a4cc:	3710      	adds	r7, #16
 801a4ce:	46bd      	mov	sp, r7
 801a4d0:	bd80      	pop	{r7, pc}

0801a4d2 <hci_le_data_length_change_event_process>:
 *        future use)
 * @retval None
 */

tBleStatus hci_le_data_length_change_event_process(uint8_t *buffer_in)
{
 801a4d2:	b590      	push	{r4, r7, lr}
 801a4d4:	b087      	sub	sp, #28
 801a4d6:	af02      	add	r7, sp, #8
 801a4d8:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 801a4da:	2300      	movs	r3, #0
 801a4dc:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  hci_le_data_length_change_event_rp0 *rp0 = (hci_le_data_length_change_event_rp0 *)buffer_in;
 801a4de:	687b      	ldr	r3, [r7, #4]
 801a4e0:	60bb      	str	r3, [r7, #8]
  hci_le_data_length_change_event(rp0->Connection_Handle,
 801a4e2:	68bb      	ldr	r3, [r7, #8]
 801a4e4:	881b      	ldrh	r3, [r3, #0]
 801a4e6:	b298      	uxth	r0, r3
 801a4e8:	68bb      	ldr	r3, [r7, #8]
 801a4ea:	885b      	ldrh	r3, [r3, #2]
 801a4ec:	b299      	uxth	r1, r3
 801a4ee:	68bb      	ldr	r3, [r7, #8]
 801a4f0:	889b      	ldrh	r3, [r3, #4]
 801a4f2:	b29a      	uxth	r2, r3
 801a4f4:	68bb      	ldr	r3, [r7, #8]
 801a4f6:	88db      	ldrh	r3, [r3, #6]
 801a4f8:	b29c      	uxth	r4, r3
 801a4fa:	68bb      	ldr	r3, [r7, #8]
 801a4fc:	891b      	ldrh	r3, [r3, #8]
 801a4fe:	b29b      	uxth	r3, r3
 801a500:	9300      	str	r3, [sp, #0]
 801a502:	4623      	mov	r3, r4
 801a504:	f003 ffde 	bl	801e4c4 <hci_le_data_length_change_event>
                                  rp0->MaxTxOctets,
                                  rp0->MaxTxTime,
                                  rp0->MaxRxOctets,
                                  rp0->MaxRxTime);

  return status;
 801a508:	7bfb      	ldrb	r3, [r7, #15]
}
 801a50a:	4618      	mov	r0, r3
 801a50c:	3714      	adds	r7, #20
 801a50e:	46bd      	mov	sp, r7
 801a510:	bd90      	pop	{r4, r7, pc}

0801a512 <hci_le_read_local_p256_public_key_complete_event_process>:
 * @param Local_P256_Public_Key Local P-256 public key.
 * @retval None
 */

tBleStatus hci_le_read_local_p256_public_key_complete_event_process(uint8_t *buffer_in)
{
 801a512:	b580      	push	{r7, lr}
 801a514:	b084      	sub	sp, #16
 801a516:	af00      	add	r7, sp, #0
 801a518:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 801a51a:	2300      	movs	r3, #0
 801a51c:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  hci_le_read_local_p256_public_key_complete_event_rp0 *rp0 = (hci_le_read_local_p256_public_key_complete_event_rp0 *)buffer_in;
 801a51e:	687b      	ldr	r3, [r7, #4]
 801a520:	60bb      	str	r3, [r7, #8]
  hci_le_read_local_p256_public_key_complete_event(rp0->Status,
 801a522:	68bb      	ldr	r3, [r7, #8]
 801a524:	781a      	ldrb	r2, [r3, #0]
                                                   rp0->Local_P256_Public_Key);
 801a526:	68bb      	ldr	r3, [r7, #8]
 801a528:	3301      	adds	r3, #1
  hci_le_read_local_p256_public_key_complete_event(rp0->Status,
 801a52a:	4619      	mov	r1, r3
 801a52c:	4610      	mov	r0, r2
 801a52e:	f000 fdef 	bl	801b110 <hci_le_read_local_p256_public_key_complete_event>

  return status;
 801a532:	7bfb      	ldrb	r3, [r7, #15]
}
 801a534:	4618      	mov	r0, r3
 801a536:	3710      	adds	r7, #16
 801a538:	46bd      	mov	sp, r7
 801a53a:	bd80      	pop	{r7, pc}

0801a53c <hci_le_generate_dhkey_complete_event_process>:
 * @param DHKey Diffie Hellman Key
 * @retval None
 */

tBleStatus hci_le_generate_dhkey_complete_event_process(uint8_t *buffer_in)
{
 801a53c:	b580      	push	{r7, lr}
 801a53e:	b084      	sub	sp, #16
 801a540:	af00      	add	r7, sp, #0
 801a542:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 801a544:	2300      	movs	r3, #0
 801a546:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  hci_le_generate_dhkey_complete_event_rp0 *rp0 = (hci_le_generate_dhkey_complete_event_rp0 *)buffer_in;
 801a548:	687b      	ldr	r3, [r7, #4]
 801a54a:	60bb      	str	r3, [r7, #8]
  hci_le_generate_dhkey_complete_event(rp0->Status,
 801a54c:	68bb      	ldr	r3, [r7, #8]
 801a54e:	781a      	ldrb	r2, [r3, #0]
                                       rp0->DHKey);
 801a550:	68bb      	ldr	r3, [r7, #8]
 801a552:	3301      	adds	r3, #1
  hci_le_generate_dhkey_complete_event(rp0->Status,
 801a554:	4619      	mov	r1, r3
 801a556:	4610      	mov	r0, r2
 801a558:	f000 fdea 	bl	801b130 <hci_le_generate_dhkey_complete_event>

  return status;
 801a55c:	7bfb      	ldrb	r3, [r7, #15]
}
 801a55e:	4618      	mov	r0, r3
 801a560:	3710      	adds	r7, #16
 801a562:	46bd      	mov	sp, r7
 801a564:	bd80      	pop	{r7, pc}

0801a566 <hci_le_enhanced_connection_complete_event_process>:
 *        - 0x07: 20 ppm
 * @retval None
 */

tBleStatus hci_le_enhanced_connection_complete_event_process(uint8_t *buffer_in)
{
 801a566:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 801a56a:	b08d      	sub	sp, #52	@ 0x34
 801a56c:	af08      	add	r7, sp, #32
 801a56e:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 801a570:	2300      	movs	r3, #0
 801a572:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  hci_le_enhanced_connection_complete_event_rp0 *rp0 = (hci_le_enhanced_connection_complete_event_rp0 *)buffer_in;
 801a574:	687b      	ldr	r3, [r7, #4]
 801a576:	60bb      	str	r3, [r7, #8]
  hci_le_enhanced_connection_complete_event(rp0->Status,
 801a578:	68bb      	ldr	r3, [r7, #8]
 801a57a:	f893 c000 	ldrb.w	ip, [r3]
 801a57e:	68bb      	ldr	r3, [r7, #8]
 801a580:	f8b3 3001 	ldrh.w	r3, [r3, #1]
 801a584:	fa1f fe83 	uxth.w	lr, r3
 801a588:	68bb      	ldr	r3, [r7, #8]
 801a58a:	f893 8003 	ldrb.w	r8, [r3, #3]
 801a58e:	68bb      	ldr	r3, [r7, #8]
 801a590:	f893 9004 	ldrb.w	r9, [r3, #4]
                                            rp0->Connection_Handle,
                                            rp0->Role,
                                            rp0->Peer_Address_Type,
                                            rp0->Peer_Address,
 801a594:	68bb      	ldr	r3, [r7, #8]
 801a596:	3305      	adds	r3, #5
                                            rp0->Local_Resolvable_Private_Address,
 801a598:	68ba      	ldr	r2, [r7, #8]
 801a59a:	320b      	adds	r2, #11
                                            rp0->Peer_Resolvable_Private_Address,
 801a59c:	68b9      	ldr	r1, [r7, #8]
 801a59e:	3111      	adds	r1, #17
  hci_le_enhanced_connection_complete_event(rp0->Status,
 801a5a0:	68b8      	ldr	r0, [r7, #8]
 801a5a2:	f8b0 0017 	ldrh.w	r0, [r0, #23]
 801a5a6:	b280      	uxth	r0, r0
 801a5a8:	68bc      	ldr	r4, [r7, #8]
 801a5aa:	f8b4 4019 	ldrh.w	r4, [r4, #25]
 801a5ae:	b2a4      	uxth	r4, r4
 801a5b0:	68bd      	ldr	r5, [r7, #8]
 801a5b2:	f8b5 501b 	ldrh.w	r5, [r5, #27]
 801a5b6:	b2ad      	uxth	r5, r5
 801a5b8:	68be      	ldr	r6, [r7, #8]
 801a5ba:	7f76      	ldrb	r6, [r6, #29]
 801a5bc:	9606      	str	r6, [sp, #24]
 801a5be:	9505      	str	r5, [sp, #20]
 801a5c0:	9404      	str	r4, [sp, #16]
 801a5c2:	9003      	str	r0, [sp, #12]
 801a5c4:	9102      	str	r1, [sp, #8]
 801a5c6:	9201      	str	r2, [sp, #4]
 801a5c8:	9300      	str	r3, [sp, #0]
 801a5ca:	464b      	mov	r3, r9
 801a5cc:	4642      	mov	r2, r8
 801a5ce:	4671      	mov	r1, lr
 801a5d0:	4660      	mov	r0, ip
 801a5d2:	f003 fe47 	bl	801e264 <hci_le_enhanced_connection_complete_event>
                                            rp0->Conn_Interval,
                                            rp0->Conn_Latency,
                                            rp0->Supervision_Timeout,
                                            rp0->Master_Clock_Accuracy);

  return status;
 801a5d6:	7bfb      	ldrb	r3, [r7, #15]
}
 801a5d8:	4618      	mov	r0, r3
 801a5da:	3714      	adds	r7, #20
 801a5dc:	46bd      	mov	sp, r7
 801a5de:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

0801a5e2 <hci_le_direct_advertising_report_event_process>:
 * @param Direct_Advertising_Report See @ref Direct_Advertising_Report_t
 * @retval None
 */

tBleStatus hci_le_direct_advertising_report_event_process(uint8_t *buffer_in)
{
 801a5e2:	b580      	push	{r7, lr}
 801a5e4:	b0c6      	sub	sp, #280	@ 0x118
 801a5e6:	af00      	add	r7, sp, #0
 801a5e8:	f507 738c 	add.w	r3, r7, #280	@ 0x118
 801a5ec:	f5a3 738a 	sub.w	r3, r3, #276	@ 0x114
 801a5f0:	6018      	str	r0, [r3, #0]
  tBleStatus status = BLE_STATUS_SUCCESS;
 801a5f2:	2300      	movs	r3, #0
 801a5f4:	f887 310f 	strb.w	r3, [r7, #271]	@ 0x10f
  /* Input params */
  hci_le_direct_advertising_report_event_rp0 *rp0 = (hci_le_direct_advertising_report_event_rp0 *)buffer_in;
 801a5f8:	f507 738c 	add.w	r3, r7, #280	@ 0x118
 801a5fc:	f5a3 738a 	sub.w	r3, r3, #276	@ 0x114
 801a600:	681b      	ldr	r3, [r3, #0]
 801a602:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
  uint8_t size = 1;
 801a606:	2301      	movs	r3, #1
 801a608:	f887 3117 	strb.w	r3, [r7, #279]	@ 0x117
  int i;
  Direct_Advertising_Report_t Direct_Advertising_Report[HCI_MAX_PAYLOAD_SIZE/sizeof(Direct_Advertising_Report_t)];
  for (i = 0; i < rp0->Num_Reports; i++) {
 801a60c:	2300      	movs	r3, #0
 801a60e:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110
 801a612:	e094      	b.n	801a73e <hci_le_direct_advertising_report_event_process+0x15c>
    Direct_Advertising_Report[i].Event_Type = rp0->Direct_Advertising_Report[i].Event_Type;
 801a614:	f8d7 2108 	ldr.w	r2, [r7, #264]	@ 0x108
 801a618:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 801a61c:	011b      	lsls	r3, r3, #4
 801a61e:	4413      	add	r3, r2
 801a620:	3301      	adds	r3, #1
 801a622:	7819      	ldrb	r1, [r3, #0]
 801a624:	f507 738c 	add.w	r3, r7, #280	@ 0x118
 801a628:	f5a3 7288 	sub.w	r2, r3, #272	@ 0x110
 801a62c:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 801a630:	011b      	lsls	r3, r3, #4
 801a632:	4413      	add	r3, r2
 801a634:	460a      	mov	r2, r1
 801a636:	701a      	strb	r2, [r3, #0]
    size += 1;
 801a638:	f897 3117 	ldrb.w	r3, [r7, #279]	@ 0x117
 801a63c:	3301      	adds	r3, #1
 801a63e:	f887 3117 	strb.w	r3, [r7, #279]	@ 0x117
    Direct_Advertising_Report[i].Address_Type = rp0->Direct_Advertising_Report[i].Address_Type;
 801a642:	f8d7 2108 	ldr.w	r2, [r7, #264]	@ 0x108
 801a646:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 801a64a:	011b      	lsls	r3, r3, #4
 801a64c:	4413      	add	r3, r2
 801a64e:	3302      	adds	r3, #2
 801a650:	7819      	ldrb	r1, [r3, #0]
 801a652:	f507 738c 	add.w	r3, r7, #280	@ 0x118
 801a656:	f5a3 7288 	sub.w	r2, r3, #272	@ 0x110
 801a65a:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 801a65e:	011b      	lsls	r3, r3, #4
 801a660:	4413      	add	r3, r2
 801a662:	3301      	adds	r3, #1
 801a664:	460a      	mov	r2, r1
 801a666:	701a      	strb	r2, [r3, #0]
    size += 1;
 801a668:	f897 3117 	ldrb.w	r3, [r7, #279]	@ 0x117
 801a66c:	3301      	adds	r3, #1
 801a66e:	f887 3117 	strb.w	r3, [r7, #279]	@ 0x117
    BLUENRG_memcpy((void *) Direct_Advertising_Report[i].Address, (const void *) rp0->Direct_Advertising_Report[i].Address, 6);
 801a672:	f107 0208 	add.w	r2, r7, #8
 801a676:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 801a67a:	011b      	lsls	r3, r3, #4
 801a67c:	4413      	add	r3, r2
 801a67e:	1c98      	adds	r0, r3, #2
 801a680:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 801a684:	011b      	lsls	r3, r3, #4
 801a686:	f8d7 2108 	ldr.w	r2, [r7, #264]	@ 0x108
 801a68a:	4413      	add	r3, r2
 801a68c:	3303      	adds	r3, #3
 801a68e:	2206      	movs	r2, #6
 801a690:	4619      	mov	r1, r3
 801a692:	f009 fdac 	bl	80241ee <memcpy>
    size += 6;
 801a696:	f897 3117 	ldrb.w	r3, [r7, #279]	@ 0x117
 801a69a:	3306      	adds	r3, #6
 801a69c:	f887 3117 	strb.w	r3, [r7, #279]	@ 0x117
    Direct_Advertising_Report[i].Direct_Address_Type = rp0->Direct_Advertising_Report[i].Direct_Address_Type;
 801a6a0:	f8d7 2108 	ldr.w	r2, [r7, #264]	@ 0x108
 801a6a4:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 801a6a8:	011b      	lsls	r3, r3, #4
 801a6aa:	4413      	add	r3, r2
 801a6ac:	3309      	adds	r3, #9
 801a6ae:	7819      	ldrb	r1, [r3, #0]
 801a6b0:	f507 738c 	add.w	r3, r7, #280	@ 0x118
 801a6b4:	f5a3 7288 	sub.w	r2, r3, #272	@ 0x110
 801a6b8:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 801a6bc:	011b      	lsls	r3, r3, #4
 801a6be:	4413      	add	r3, r2
 801a6c0:	3308      	adds	r3, #8
 801a6c2:	460a      	mov	r2, r1
 801a6c4:	701a      	strb	r2, [r3, #0]
    size += 1;
 801a6c6:	f897 3117 	ldrb.w	r3, [r7, #279]	@ 0x117
 801a6ca:	3301      	adds	r3, #1
 801a6cc:	f887 3117 	strb.w	r3, [r7, #279]	@ 0x117
    BLUENRG_memcpy((void *) Direct_Advertising_Report[i].Direct_Address, (const void *) rp0->Direct_Advertising_Report[i].Direct_Address, 6);
 801a6d0:	f107 0208 	add.w	r2, r7, #8
 801a6d4:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 801a6d8:	011b      	lsls	r3, r3, #4
 801a6da:	3308      	adds	r3, #8
 801a6dc:	4413      	add	r3, r2
 801a6de:	1c58      	adds	r0, r3, #1
 801a6e0:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 801a6e4:	011b      	lsls	r3, r3, #4
 801a6e6:	3308      	adds	r3, #8
 801a6e8:	f8d7 2108 	ldr.w	r2, [r7, #264]	@ 0x108
 801a6ec:	4413      	add	r3, r2
 801a6ee:	3302      	adds	r3, #2
 801a6f0:	2206      	movs	r2, #6
 801a6f2:	4619      	mov	r1, r3
 801a6f4:	f009 fd7b 	bl	80241ee <memcpy>
    size += 6;
 801a6f8:	f897 3117 	ldrb.w	r3, [r7, #279]	@ 0x117
 801a6fc:	3306      	adds	r3, #6
 801a6fe:	f887 3117 	strb.w	r3, [r7, #279]	@ 0x117
    Direct_Advertising_Report[i].RSSI = rp0->Direct_Advertising_Report[i].RSSI;
 801a702:	f8d7 2108 	ldr.w	r2, [r7, #264]	@ 0x108
 801a706:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 801a70a:	011b      	lsls	r3, r3, #4
 801a70c:	4413      	add	r3, r2
 801a70e:	3310      	adds	r3, #16
 801a710:	f993 1000 	ldrsb.w	r1, [r3]
 801a714:	f507 738c 	add.w	r3, r7, #280	@ 0x118
 801a718:	f5a3 7288 	sub.w	r2, r3, #272	@ 0x110
 801a71c:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 801a720:	011b      	lsls	r3, r3, #4
 801a722:	4413      	add	r3, r2
 801a724:	330f      	adds	r3, #15
 801a726:	460a      	mov	r2, r1
 801a728:	701a      	strb	r2, [r3, #0]
    size += 1;
 801a72a:	f897 3117 	ldrb.w	r3, [r7, #279]	@ 0x117
 801a72e:	3301      	adds	r3, #1
 801a730:	f887 3117 	strb.w	r3, [r7, #279]	@ 0x117
  for (i = 0; i < rp0->Num_Reports; i++) {
 801a734:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 801a738:	3301      	adds	r3, #1
 801a73a:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110
 801a73e:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
 801a742:	781b      	ldrb	r3, [r3, #0]
 801a744:	461a      	mov	r2, r3
 801a746:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 801a74a:	4293      	cmp	r3, r2
 801a74c:	f6ff af62 	blt.w	801a614 <hci_le_direct_advertising_report_event_process+0x32>
  }
  hci_le_direct_advertising_report_event(rp0->Num_Reports,
 801a750:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
 801a754:	781b      	ldrb	r3, [r3, #0]
 801a756:	f107 0208 	add.w	r2, r7, #8
 801a75a:	4611      	mov	r1, r2
 801a75c:	4618      	mov	r0, r3
 801a75e:	f000 fcf7 	bl	801b150 <hci_le_direct_advertising_report_event>
                                         Direct_Advertising_Report);

  return status;
 801a762:	f897 310f 	ldrb.w	r3, [r7, #271]	@ 0x10f
}
 801a766:	4618      	mov	r0, r3
 801a768:	f507 778c 	add.w	r7, r7, #280	@ 0x118
 801a76c:	46bd      	mov	sp, r7
 801a76e:	bd80      	pop	{r7, pc}

0801a770 <hci_le_phy_update_complete_event_process>:
 *        - 0x03: The receiver PHY for the connection is LE Coded
 * @retval None
 */

tBleStatus hci_le_phy_update_complete_event_process(uint8_t *buffer_in)
{
 801a770:	b580      	push	{r7, lr}
 801a772:	b084      	sub	sp, #16
 801a774:	af00      	add	r7, sp, #0
 801a776:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 801a778:	2300      	movs	r3, #0
 801a77a:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  hci_le_phy_update_complete_event_rp0 *rp0 = (hci_le_phy_update_complete_event_rp0 *)buffer_in;
 801a77c:	687b      	ldr	r3, [r7, #4]
 801a77e:	60bb      	str	r3, [r7, #8]
  hci_le_phy_update_complete_event(rp0->Status,
 801a780:	68bb      	ldr	r3, [r7, #8]
 801a782:	7818      	ldrb	r0, [r3, #0]
 801a784:	68bb      	ldr	r3, [r7, #8]
 801a786:	f8b3 3001 	ldrh.w	r3, [r3, #1]
 801a78a:	b299      	uxth	r1, r3
 801a78c:	68bb      	ldr	r3, [r7, #8]
 801a78e:	78da      	ldrb	r2, [r3, #3]
 801a790:	68bb      	ldr	r3, [r7, #8]
 801a792:	791b      	ldrb	r3, [r3, #4]
 801a794:	f003 fef8 	bl	801e588 <hci_le_phy_update_complete_event>
                                   rp0->Connection_Handle,
                                   rp0->TX_PHY,
                                   rp0->RX_PHY);

  return status;
 801a798:	7bfb      	ldrb	r3, [r7, #15]
}
 801a79a:	4618      	mov	r0, r3
 801a79c:	3710      	adds	r7, #16
 801a79e:	46bd      	mov	sp, r7
 801a7a0:	bd80      	pop	{r7, pc}

0801a7a2 <hci_le_extended_advertising_report_event_process>:
 * @param Extended_Advertising_Report See @ref Extended_Advertising_Report_t
 * @retval None
 */

tBleStatus hci_le_extended_advertising_report_event_process(uint8_t *buffer_in)
{
 801a7a2:	b580      	push	{r7, lr}
 801a7a4:	b0c6      	sub	sp, #280	@ 0x118
 801a7a6:	af00      	add	r7, sp, #0
 801a7a8:	f507 738c 	add.w	r3, r7, #280	@ 0x118
 801a7ac:	f5a3 738a 	sub.w	r3, r3, #276	@ 0x114
 801a7b0:	6018      	str	r0, [r3, #0]
  tBleStatus status = BLE_STATUS_SUCCESS;
 801a7b2:	2300      	movs	r3, #0
 801a7b4:	f887 310f 	strb.w	r3, [r7, #271]	@ 0x10f
  /* Input params */
  hci_le_extended_advertising_report_event_rp0 *rp0 = (hci_le_extended_advertising_report_event_rp0 *)buffer_in;
 801a7b8:	f507 738c 	add.w	r3, r7, #280	@ 0x118
 801a7bc:	f5a3 738a 	sub.w	r3, r3, #276	@ 0x114
 801a7c0:	681b      	ldr	r3, [r3, #0]
 801a7c2:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
  uint8_t size = 1;
 801a7c6:	2301      	movs	r3, #1
 801a7c8:	f887 3117 	strb.w	r3, [r7, #279]	@ 0x117
  int i;
  Extended_Advertising_Report_t Extended_Advertising_Report[HCI_MAX_PAYLOAD_SIZE/sizeof(Extended_Advertising_Report_t)];
  for (i = 0; i < rp0->Num_Reports; i++) {
 801a7cc:	2300      	movs	r3, #0
 801a7ce:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110
 801a7d2:	e1a6      	b.n	801ab22 <hci_le_extended_advertising_report_event_process+0x380>
    Extended_Advertising_Report[i].Event_Type = rp0->Extended_Advertising_Report[i].Event_Type;
 801a7d4:	f8d7 1108 	ldr.w	r1, [r7, #264]	@ 0x108
 801a7d8:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 801a7dc:	4613      	mov	r3, r2
 801a7de:	009b      	lsls	r3, r3, #2
 801a7e0:	4413      	add	r3, r2
 801a7e2:	009a      	lsls	r2, r3, #2
 801a7e4:	4413      	add	r3, r2
 801a7e6:	440b      	add	r3, r1
 801a7e8:	f8b3 3001 	ldrh.w	r3, [r3, #1]
 801a7ec:	b298      	uxth	r0, r3
 801a7ee:	f507 738c 	add.w	r3, r7, #280	@ 0x118
 801a7f2:	f5a3 7186 	sub.w	r1, r3, #268	@ 0x10c
 801a7f6:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 801a7fa:	4613      	mov	r3, r2
 801a7fc:	00db      	lsls	r3, r3, #3
 801a7fe:	1a9b      	subs	r3, r3, r2
 801a800:	009b      	lsls	r3, r3, #2
 801a802:	440b      	add	r3, r1
 801a804:	4602      	mov	r2, r0
 801a806:	801a      	strh	r2, [r3, #0]
    size += 2;
 801a808:	f897 3117 	ldrb.w	r3, [r7, #279]	@ 0x117
 801a80c:	3302      	adds	r3, #2
 801a80e:	f887 3117 	strb.w	r3, [r7, #279]	@ 0x117
    Extended_Advertising_Report[i].Address_Type = rp0->Extended_Advertising_Report[i].Address_Type;
 801a812:	f8d7 1108 	ldr.w	r1, [r7, #264]	@ 0x108
 801a816:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 801a81a:	4613      	mov	r3, r2
 801a81c:	009b      	lsls	r3, r3, #2
 801a81e:	4413      	add	r3, r2
 801a820:	009a      	lsls	r2, r3, #2
 801a822:	4413      	add	r3, r2
 801a824:	440b      	add	r3, r1
 801a826:	3303      	adds	r3, #3
 801a828:	7818      	ldrb	r0, [r3, #0]
 801a82a:	f507 738c 	add.w	r3, r7, #280	@ 0x118
 801a82e:	f5a3 7186 	sub.w	r1, r3, #268	@ 0x10c
 801a832:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 801a836:	4613      	mov	r3, r2
 801a838:	00db      	lsls	r3, r3, #3
 801a83a:	1a9b      	subs	r3, r3, r2
 801a83c:	009b      	lsls	r3, r3, #2
 801a83e:	440b      	add	r3, r1
 801a840:	3302      	adds	r3, #2
 801a842:	4602      	mov	r2, r0
 801a844:	701a      	strb	r2, [r3, #0]
    size += 1;
 801a846:	f897 3117 	ldrb.w	r3, [r7, #279]	@ 0x117
 801a84a:	3301      	adds	r3, #1
 801a84c:	f887 3117 	strb.w	r3, [r7, #279]	@ 0x117
    BLUENRG_memcpy((void *) Extended_Advertising_Report[i].Address, (const void *) rp0->Extended_Advertising_Report[i].Address, 6);
 801a850:	f107 010c 	add.w	r1, r7, #12
 801a854:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 801a858:	4613      	mov	r3, r2
 801a85a:	00db      	lsls	r3, r3, #3
 801a85c:	1a9b      	subs	r3, r3, r2
 801a85e:	009b      	lsls	r3, r3, #2
 801a860:	440b      	add	r3, r1
 801a862:	1cd8      	adds	r0, r3, #3
 801a864:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 801a868:	4613      	mov	r3, r2
 801a86a:	009b      	lsls	r3, r3, #2
 801a86c:	4413      	add	r3, r2
 801a86e:	009a      	lsls	r2, r3, #2
 801a870:	4413      	add	r3, r2
 801a872:	f8d7 2108 	ldr.w	r2, [r7, #264]	@ 0x108
 801a876:	4413      	add	r3, r2
 801a878:	3304      	adds	r3, #4
 801a87a:	2206      	movs	r2, #6
 801a87c:	4619      	mov	r1, r3
 801a87e:	f009 fcb6 	bl	80241ee <memcpy>
    size += 6;
 801a882:	f897 3117 	ldrb.w	r3, [r7, #279]	@ 0x117
 801a886:	3306      	adds	r3, #6
 801a888:	f887 3117 	strb.w	r3, [r7, #279]	@ 0x117
    Extended_Advertising_Report[i].Primary_PHY = rp0->Extended_Advertising_Report[i].Primary_PHY;
 801a88c:	f8d7 1108 	ldr.w	r1, [r7, #264]	@ 0x108
 801a890:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 801a894:	4613      	mov	r3, r2
 801a896:	009b      	lsls	r3, r3, #2
 801a898:	4413      	add	r3, r2
 801a89a:	009a      	lsls	r2, r3, #2
 801a89c:	4413      	add	r3, r2
 801a89e:	440b      	add	r3, r1
 801a8a0:	330a      	adds	r3, #10
 801a8a2:	7818      	ldrb	r0, [r3, #0]
 801a8a4:	f507 738c 	add.w	r3, r7, #280	@ 0x118
 801a8a8:	f5a3 7186 	sub.w	r1, r3, #268	@ 0x10c
 801a8ac:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 801a8b0:	4613      	mov	r3, r2
 801a8b2:	00db      	lsls	r3, r3, #3
 801a8b4:	1a9b      	subs	r3, r3, r2
 801a8b6:	009b      	lsls	r3, r3, #2
 801a8b8:	440b      	add	r3, r1
 801a8ba:	3309      	adds	r3, #9
 801a8bc:	4602      	mov	r2, r0
 801a8be:	701a      	strb	r2, [r3, #0]
    size += 1;
 801a8c0:	f897 3117 	ldrb.w	r3, [r7, #279]	@ 0x117
 801a8c4:	3301      	adds	r3, #1
 801a8c6:	f887 3117 	strb.w	r3, [r7, #279]	@ 0x117
    Extended_Advertising_Report[i].Secondary_PHY = rp0->Extended_Advertising_Report[i].Secondary_PHY;
 801a8ca:	f8d7 1108 	ldr.w	r1, [r7, #264]	@ 0x108
 801a8ce:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 801a8d2:	4613      	mov	r3, r2
 801a8d4:	009b      	lsls	r3, r3, #2
 801a8d6:	4413      	add	r3, r2
 801a8d8:	009a      	lsls	r2, r3, #2
 801a8da:	4413      	add	r3, r2
 801a8dc:	440b      	add	r3, r1
 801a8de:	330b      	adds	r3, #11
 801a8e0:	7818      	ldrb	r0, [r3, #0]
 801a8e2:	f507 738c 	add.w	r3, r7, #280	@ 0x118
 801a8e6:	f5a3 7186 	sub.w	r1, r3, #268	@ 0x10c
 801a8ea:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 801a8ee:	4613      	mov	r3, r2
 801a8f0:	00db      	lsls	r3, r3, #3
 801a8f2:	1a9b      	subs	r3, r3, r2
 801a8f4:	009b      	lsls	r3, r3, #2
 801a8f6:	440b      	add	r3, r1
 801a8f8:	330a      	adds	r3, #10
 801a8fa:	4602      	mov	r2, r0
 801a8fc:	701a      	strb	r2, [r3, #0]
    size += 1;
 801a8fe:	f897 3117 	ldrb.w	r3, [r7, #279]	@ 0x117
 801a902:	3301      	adds	r3, #1
 801a904:	f887 3117 	strb.w	r3, [r7, #279]	@ 0x117
    Extended_Advertising_Report[i].Advertising_SID = rp0->Extended_Advertising_Report[i].Advertising_SID;
 801a908:	f8d7 1108 	ldr.w	r1, [r7, #264]	@ 0x108
 801a90c:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 801a910:	4613      	mov	r3, r2
 801a912:	009b      	lsls	r3, r3, #2
 801a914:	4413      	add	r3, r2
 801a916:	009a      	lsls	r2, r3, #2
 801a918:	4413      	add	r3, r2
 801a91a:	440b      	add	r3, r1
 801a91c:	330c      	adds	r3, #12
 801a91e:	7818      	ldrb	r0, [r3, #0]
 801a920:	f507 738c 	add.w	r3, r7, #280	@ 0x118
 801a924:	f5a3 7186 	sub.w	r1, r3, #268	@ 0x10c
 801a928:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 801a92c:	4613      	mov	r3, r2
 801a92e:	00db      	lsls	r3, r3, #3
 801a930:	1a9b      	subs	r3, r3, r2
 801a932:	009b      	lsls	r3, r3, #2
 801a934:	440b      	add	r3, r1
 801a936:	330b      	adds	r3, #11
 801a938:	4602      	mov	r2, r0
 801a93a:	701a      	strb	r2, [r3, #0]
    size += 1;
 801a93c:	f897 3117 	ldrb.w	r3, [r7, #279]	@ 0x117
 801a940:	3301      	adds	r3, #1
 801a942:	f887 3117 	strb.w	r3, [r7, #279]	@ 0x117
    Extended_Advertising_Report[i].TX_Power = rp0->Extended_Advertising_Report[i].TX_Power;
 801a946:	f8d7 1108 	ldr.w	r1, [r7, #264]	@ 0x108
 801a94a:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 801a94e:	4613      	mov	r3, r2
 801a950:	009b      	lsls	r3, r3, #2
 801a952:	4413      	add	r3, r2
 801a954:	009a      	lsls	r2, r3, #2
 801a956:	4413      	add	r3, r2
 801a958:	440b      	add	r3, r1
 801a95a:	330d      	adds	r3, #13
 801a95c:	f993 0000 	ldrsb.w	r0, [r3]
 801a960:	f507 738c 	add.w	r3, r7, #280	@ 0x118
 801a964:	f5a3 7186 	sub.w	r1, r3, #268	@ 0x10c
 801a968:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 801a96c:	4613      	mov	r3, r2
 801a96e:	00db      	lsls	r3, r3, #3
 801a970:	1a9b      	subs	r3, r3, r2
 801a972:	009b      	lsls	r3, r3, #2
 801a974:	440b      	add	r3, r1
 801a976:	330c      	adds	r3, #12
 801a978:	4602      	mov	r2, r0
 801a97a:	701a      	strb	r2, [r3, #0]
    size += 1;
 801a97c:	f897 3117 	ldrb.w	r3, [r7, #279]	@ 0x117
 801a980:	3301      	adds	r3, #1
 801a982:	f887 3117 	strb.w	r3, [r7, #279]	@ 0x117
    Extended_Advertising_Report[i].RSSI = rp0->Extended_Advertising_Report[i].RSSI;
 801a986:	f8d7 1108 	ldr.w	r1, [r7, #264]	@ 0x108
 801a98a:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 801a98e:	4613      	mov	r3, r2
 801a990:	009b      	lsls	r3, r3, #2
 801a992:	4413      	add	r3, r2
 801a994:	009a      	lsls	r2, r3, #2
 801a996:	4413      	add	r3, r2
 801a998:	440b      	add	r3, r1
 801a99a:	330e      	adds	r3, #14
 801a99c:	f993 0000 	ldrsb.w	r0, [r3]
 801a9a0:	f507 738c 	add.w	r3, r7, #280	@ 0x118
 801a9a4:	f5a3 7186 	sub.w	r1, r3, #268	@ 0x10c
 801a9a8:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 801a9ac:	4613      	mov	r3, r2
 801a9ae:	00db      	lsls	r3, r3, #3
 801a9b0:	1a9b      	subs	r3, r3, r2
 801a9b2:	009b      	lsls	r3, r3, #2
 801a9b4:	440b      	add	r3, r1
 801a9b6:	330d      	adds	r3, #13
 801a9b8:	4602      	mov	r2, r0
 801a9ba:	701a      	strb	r2, [r3, #0]
    size += 1;
 801a9bc:	f897 3117 	ldrb.w	r3, [r7, #279]	@ 0x117
 801a9c0:	3301      	adds	r3, #1
 801a9c2:	f887 3117 	strb.w	r3, [r7, #279]	@ 0x117
    Extended_Advertising_Report[i].Periodic_Advertising_Interval = rp0->Extended_Advertising_Report[i].Periodic_Advertising_Interval;
 801a9c6:	f8d7 1108 	ldr.w	r1, [r7, #264]	@ 0x108
 801a9ca:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 801a9ce:	4613      	mov	r3, r2
 801a9d0:	009b      	lsls	r3, r3, #2
 801a9d2:	4413      	add	r3, r2
 801a9d4:	009a      	lsls	r2, r3, #2
 801a9d6:	4413      	add	r3, r2
 801a9d8:	440b      	add	r3, r1
 801a9da:	3308      	adds	r3, #8
 801a9dc:	f8b3 3007 	ldrh.w	r3, [r3, #7]
 801a9e0:	b298      	uxth	r0, r3
 801a9e2:	f507 738c 	add.w	r3, r7, #280	@ 0x118
 801a9e6:	f5a3 7186 	sub.w	r1, r3, #268	@ 0x10c
 801a9ea:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 801a9ee:	4613      	mov	r3, r2
 801a9f0:	00db      	lsls	r3, r3, #3
 801a9f2:	1a9b      	subs	r3, r3, r2
 801a9f4:	009b      	lsls	r3, r3, #2
 801a9f6:	440b      	add	r3, r1
 801a9f8:	330e      	adds	r3, #14
 801a9fa:	4602      	mov	r2, r0
 801a9fc:	801a      	strh	r2, [r3, #0]
    size += 2;
 801a9fe:	f897 3117 	ldrb.w	r3, [r7, #279]	@ 0x117
 801aa02:	3302      	adds	r3, #2
 801aa04:	f887 3117 	strb.w	r3, [r7, #279]	@ 0x117
    Extended_Advertising_Report[i].Direct_Address_Type = rp0->Extended_Advertising_Report[i].Direct_Address_Type;
 801aa08:	f8d7 1108 	ldr.w	r1, [r7, #264]	@ 0x108
 801aa0c:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 801aa10:	4613      	mov	r3, r2
 801aa12:	009b      	lsls	r3, r3, #2
 801aa14:	4413      	add	r3, r2
 801aa16:	009a      	lsls	r2, r3, #2
 801aa18:	4413      	add	r3, r2
 801aa1a:	440b      	add	r3, r1
 801aa1c:	3311      	adds	r3, #17
 801aa1e:	7818      	ldrb	r0, [r3, #0]
 801aa20:	f507 738c 	add.w	r3, r7, #280	@ 0x118
 801aa24:	f5a3 7186 	sub.w	r1, r3, #268	@ 0x10c
 801aa28:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 801aa2c:	4613      	mov	r3, r2
 801aa2e:	00db      	lsls	r3, r3, #3
 801aa30:	1a9b      	subs	r3, r3, r2
 801aa32:	009b      	lsls	r3, r3, #2
 801aa34:	440b      	add	r3, r1
 801aa36:	3310      	adds	r3, #16
 801aa38:	4602      	mov	r2, r0
 801aa3a:	701a      	strb	r2, [r3, #0]
    size += 1;
 801aa3c:	f897 3117 	ldrb.w	r3, [r7, #279]	@ 0x117
 801aa40:	3301      	adds	r3, #1
 801aa42:	f887 3117 	strb.w	r3, [r7, #279]	@ 0x117
    BLUENRG_memcpy((void *) Extended_Advertising_Report[i].Direct_Address, (const void *) rp0->Extended_Advertising_Report[i].Direct_Address, 6);
 801aa46:	f107 010c 	add.w	r1, r7, #12
 801aa4a:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 801aa4e:	4613      	mov	r3, r2
 801aa50:	00db      	lsls	r3, r3, #3
 801aa52:	1a9b      	subs	r3, r3, r2
 801aa54:	009b      	lsls	r3, r3, #2
 801aa56:	3310      	adds	r3, #16
 801aa58:	440b      	add	r3, r1
 801aa5a:	1c58      	adds	r0, r3, #1
 801aa5c:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 801aa60:	4613      	mov	r3, r2
 801aa62:	009b      	lsls	r3, r3, #2
 801aa64:	4413      	add	r3, r2
 801aa66:	009a      	lsls	r2, r3, #2
 801aa68:	4413      	add	r3, r2
 801aa6a:	3310      	adds	r3, #16
 801aa6c:	f8d7 2108 	ldr.w	r2, [r7, #264]	@ 0x108
 801aa70:	4413      	add	r3, r2
 801aa72:	3302      	adds	r3, #2
 801aa74:	2206      	movs	r2, #6
 801aa76:	4619      	mov	r1, r3
 801aa78:	f009 fbb9 	bl	80241ee <memcpy>
    size += 6;
 801aa7c:	f897 3117 	ldrb.w	r3, [r7, #279]	@ 0x117
 801aa80:	3306      	adds	r3, #6
 801aa82:	f887 3117 	strb.w	r3, [r7, #279]	@ 0x117
    Extended_Advertising_Report[i].Data_Length = rp0->Extended_Advertising_Report[i].Data_Length;
 801aa86:	f8d7 1108 	ldr.w	r1, [r7, #264]	@ 0x108
 801aa8a:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 801aa8e:	4613      	mov	r3, r2
 801aa90:	009b      	lsls	r3, r3, #2
 801aa92:	4413      	add	r3, r2
 801aa94:	009a      	lsls	r2, r3, #2
 801aa96:	4413      	add	r3, r2
 801aa98:	440b      	add	r3, r1
 801aa9a:	3318      	adds	r3, #24
 801aa9c:	7818      	ldrb	r0, [r3, #0]
 801aa9e:	f507 738c 	add.w	r3, r7, #280	@ 0x118
 801aaa2:	f5a3 7186 	sub.w	r1, r3, #268	@ 0x10c
 801aaa6:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 801aaaa:	4613      	mov	r3, r2
 801aaac:	00db      	lsls	r3, r3, #3
 801aaae:	1a9b      	subs	r3, r3, r2
 801aab0:	009b      	lsls	r3, r3, #2
 801aab2:	440b      	add	r3, r1
 801aab4:	3317      	adds	r3, #23
 801aab6:	4602      	mov	r2, r0
 801aab8:	701a      	strb	r2, [r3, #0]
    size += 1;
 801aaba:	f897 3117 	ldrb.w	r3, [r7, #279]	@ 0x117
 801aabe:	3301      	adds	r3, #1
 801aac0:	f887 3117 	strb.w	r3, [r7, #279]	@ 0x117
    Extended_Advertising_Report[i].Data = rp0->Extended_Advertising_Report[i].Data;
 801aac4:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 801aac8:	4613      	mov	r3, r2
 801aaca:	009b      	lsls	r3, r3, #2
 801aacc:	4413      	add	r3, r2
 801aace:	009a      	lsls	r2, r3, #2
 801aad0:	4413      	add	r3, r2
 801aad2:	3318      	adds	r3, #24
 801aad4:	f8d7 2108 	ldr.w	r2, [r7, #264]	@ 0x108
 801aad8:	4413      	add	r3, r2
 801aada:	1c59      	adds	r1, r3, #1
 801aadc:	f507 738c 	add.w	r3, r7, #280	@ 0x118
 801aae0:	f5a3 7086 	sub.w	r0, r3, #268	@ 0x10c
 801aae4:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 801aae8:	4613      	mov	r3, r2
 801aaea:	00db      	lsls	r3, r3, #3
 801aaec:	1a9b      	subs	r3, r3, r2
 801aaee:	009b      	lsls	r3, r3, #2
 801aaf0:	4403      	add	r3, r0
 801aaf2:	3318      	adds	r3, #24
 801aaf4:	6019      	str	r1, [r3, #0]
    size += rp0->Extended_Advertising_Report[i].Data_Length;
 801aaf6:	f8d7 1108 	ldr.w	r1, [r7, #264]	@ 0x108
 801aafa:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 801aafe:	4613      	mov	r3, r2
 801ab00:	009b      	lsls	r3, r3, #2
 801ab02:	4413      	add	r3, r2
 801ab04:	009a      	lsls	r2, r3, #2
 801ab06:	4413      	add	r3, r2
 801ab08:	440b      	add	r3, r1
 801ab0a:	3318      	adds	r3, #24
 801ab0c:	781a      	ldrb	r2, [r3, #0]
 801ab0e:	f897 3117 	ldrb.w	r3, [r7, #279]	@ 0x117
 801ab12:	4413      	add	r3, r2
 801ab14:	f887 3117 	strb.w	r3, [r7, #279]	@ 0x117
  for (i = 0; i < rp0->Num_Reports; i++) {
 801ab18:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 801ab1c:	3301      	adds	r3, #1
 801ab1e:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110
 801ab22:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
 801ab26:	781b      	ldrb	r3, [r3, #0]
 801ab28:	461a      	mov	r2, r3
 801ab2a:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 801ab2e:	4293      	cmp	r3, r2
 801ab30:	f6ff ae50 	blt.w	801a7d4 <hci_le_extended_advertising_report_event_process+0x32>
  }
  hci_le_extended_advertising_report_event(rp0->Num_Reports,
 801ab34:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
 801ab38:	781b      	ldrb	r3, [r3, #0]
 801ab3a:	f107 020c 	add.w	r2, r7, #12
 801ab3e:	4611      	mov	r1, r2
 801ab40:	4618      	mov	r0, r3
 801ab42:	f000 fd8f 	bl	801b664 <hci_le_extended_advertising_report_event>
                                           Extended_Advertising_Report);

  return status;
 801ab46:	f897 310f 	ldrb.w	r3, [r7, #271]	@ 0x10f
}
 801ab4a:	4618      	mov	r0, r3
 801ab4c:	f507 778c 	add.w	r7, r7, #280	@ 0x118
 801ab50:	46bd      	mov	sp, r7
 801ab52:	bd80      	pop	{r7, pc}

0801ab54 <hci_le_periodic_advertising_sync_established_event_process>:
 *        - 0x08 ... 0xFF: Reserved for future use
 * @retval None
 */

tBleStatus hci_le_periodic_advertising_sync_established_event_process(uint8_t *buffer_in)
{
 801ab54:	b5f0      	push	{r4, r5, r6, r7, lr}
 801ab56:	b089      	sub	sp, #36	@ 0x24
 801ab58:	af04      	add	r7, sp, #16
 801ab5a:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 801ab5c:	2300      	movs	r3, #0
 801ab5e:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  hci_le_periodic_advertising_sync_established_event_rp0 *rp0 = (hci_le_periodic_advertising_sync_established_event_rp0 *)buffer_in;
 801ab60:	687b      	ldr	r3, [r7, #4]
 801ab62:	60bb      	str	r3, [r7, #8]
  hci_le_periodic_advertising_sync_established_event(rp0->Status,
 801ab64:	68bb      	ldr	r3, [r7, #8]
 801ab66:	781c      	ldrb	r4, [r3, #0]
 801ab68:	68bb      	ldr	r3, [r7, #8]
 801ab6a:	f8b3 3001 	ldrh.w	r3, [r3, #1]
 801ab6e:	b29d      	uxth	r5, r3
 801ab70:	68bb      	ldr	r3, [r7, #8]
 801ab72:	78de      	ldrb	r6, [r3, #3]
 801ab74:	68bb      	ldr	r3, [r7, #8]
 801ab76:	f893 c004 	ldrb.w	ip, [r3, #4]
                                                     rp0->Sync_Handle,
                                                     rp0->Advertising_SID,
                                                     rp0->Advertiser_Address_Type,
                                                     rp0->Advertiser_Address,
 801ab7a:	68bb      	ldr	r3, [r7, #8]
 801ab7c:	3305      	adds	r3, #5
  hci_le_periodic_advertising_sync_established_event(rp0->Status,
 801ab7e:	68ba      	ldr	r2, [r7, #8]
 801ab80:	7ad2      	ldrb	r2, [r2, #11]
 801ab82:	68b9      	ldr	r1, [r7, #8]
 801ab84:	8989      	ldrh	r1, [r1, #12]
 801ab86:	b289      	uxth	r1, r1
 801ab88:	68b8      	ldr	r0, [r7, #8]
 801ab8a:	7b80      	ldrb	r0, [r0, #14]
 801ab8c:	9003      	str	r0, [sp, #12]
 801ab8e:	9102      	str	r1, [sp, #8]
 801ab90:	9201      	str	r2, [sp, #4]
 801ab92:	9300      	str	r3, [sp, #0]
 801ab94:	4663      	mov	r3, ip
 801ab96:	4632      	mov	r2, r6
 801ab98:	4629      	mov	r1, r5
 801ab9a:	4620      	mov	r0, r4
 801ab9c:	f000 fd72 	bl	801b684 <hci_le_periodic_advertising_sync_established_event>
                                                     rp0->Advertiser_PHY,
                                                     rp0->Periodic_Advertising_Interval,
                                                     rp0->Advertiser_Clock_Accuracy);

  return status;
 801aba0:	7bfb      	ldrb	r3, [r7, #15]
}
 801aba2:	4618      	mov	r0, r3
 801aba4:	3714      	adds	r7, #20
 801aba6:	46bd      	mov	sp, r7
 801aba8:	bdf0      	pop	{r4, r5, r6, r7, pc}

0801abaa <hci_le_periodic_advertising_report_event_process>:
 * @param Data Data received from a Periodic Advertising packet
 * @retval None
 */

tBleStatus hci_le_periodic_advertising_report_event_process(uint8_t *buffer_in)
{
 801abaa:	b5f0      	push	{r4, r5, r6, r7, lr}
 801abac:	b089      	sub	sp, #36	@ 0x24
 801abae:	af04      	add	r7, sp, #16
 801abb0:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 801abb2:	2300      	movs	r3, #0
 801abb4:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  hci_le_periodic_advertising_report_event_rp0 *rp0 = (hci_le_periodic_advertising_report_event_rp0 *)buffer_in;
 801abb6:	687b      	ldr	r3, [r7, #4]
 801abb8:	60bb      	str	r3, [r7, #8]
  hci_le_periodic_advertising_report_event(rp0->Sync_Handle,
 801abba:	68bb      	ldr	r3, [r7, #8]
 801abbc:	881b      	ldrh	r3, [r3, #0]
 801abbe:	b298      	uxth	r0, r3
 801abc0:	68bb      	ldr	r3, [r7, #8]
 801abc2:	f993 4002 	ldrsb.w	r4, [r3, #2]
 801abc6:	68bb      	ldr	r3, [r7, #8]
 801abc8:	f993 5003 	ldrsb.w	r5, [r3, #3]
 801abcc:	68bb      	ldr	r3, [r7, #8]
 801abce:	791e      	ldrb	r6, [r3, #4]
 801abd0:	68bb      	ldr	r3, [r7, #8]
 801abd2:	795b      	ldrb	r3, [r3, #5]
 801abd4:	68ba      	ldr	r2, [r7, #8]
 801abd6:	7992      	ldrb	r2, [r2, #6]
                                           rp0->TX_Power,
                                           rp0->RSSI,
                                           rp0->CTE_Type,
                                           rp0->Data_Status,
                                           rp0->Data_Length,
                                           rp0->Data);
 801abd8:	68b9      	ldr	r1, [r7, #8]
 801abda:	3107      	adds	r1, #7
  hci_le_periodic_advertising_report_event(rp0->Sync_Handle,
 801abdc:	9102      	str	r1, [sp, #8]
 801abde:	9201      	str	r2, [sp, #4]
 801abe0:	9300      	str	r3, [sp, #0]
 801abe2:	4633      	mov	r3, r6
 801abe4:	462a      	mov	r2, r5
 801abe6:	4621      	mov	r1, r4
 801abe8:	f000 fd64 	bl	801b6b4 <hci_le_periodic_advertising_report_event>

  return status;
 801abec:	7bfb      	ldrb	r3, [r7, #15]
}
 801abee:	4618      	mov	r0, r3
 801abf0:	3714      	adds	r7, #20
 801abf2:	46bd      	mov	sp, r7
 801abf4:	bdf0      	pop	{r4, r5, r6, r7, pc}

0801abf6 <hci_le_periodic_advertising_sync_lost_event_process>:
 *        - 0x0000 ... 0x0EFF
 * @retval None
 */

tBleStatus hci_le_periodic_advertising_sync_lost_event_process(uint8_t *buffer_in)
{
 801abf6:	b580      	push	{r7, lr}
 801abf8:	b084      	sub	sp, #16
 801abfa:	af00      	add	r7, sp, #0
 801abfc:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 801abfe:	2300      	movs	r3, #0
 801ac00:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  hci_le_periodic_advertising_sync_lost_event_rp0 *rp0 = (hci_le_periodic_advertising_sync_lost_event_rp0 *)buffer_in;
 801ac02:	687b      	ldr	r3, [r7, #4]
 801ac04:	60bb      	str	r3, [r7, #8]
  hci_le_periodic_advertising_sync_lost_event(rp0->Sync_Handle);
 801ac06:	68bb      	ldr	r3, [r7, #8]
 801ac08:	881b      	ldrh	r3, [r3, #0]
 801ac0a:	b29b      	uxth	r3, r3
 801ac0c:	4618      	mov	r0, r3
 801ac0e:	f000 fd69 	bl	801b6e4 <hci_le_periodic_advertising_sync_lost_event>

  return status;
 801ac12:	7bfb      	ldrb	r3, [r7, #15]
}
 801ac14:	4618      	mov	r0, r3
 801ac16:	3710      	adds	r7, #16
 801ac18:	46bd      	mov	sp, r7
 801ac1a:	bd80      	pop	{r7, pc}

0801ac1c <hci_le_scan_timeout_event_process>:
 *        scanning was enabled using the LE Set Extended Scan Enable command.
 * @retval None
 */

tBleStatus hci_le_scan_timeout_event_process(uint8_t *buffer_in)
{
 801ac1c:	b580      	push	{r7, lr}
 801ac1e:	b084      	sub	sp, #16
 801ac20:	af00      	add	r7, sp, #0
 801ac22:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 801ac24:	2300      	movs	r3, #0
 801ac26:	73fb      	strb	r3, [r7, #15]
  hci_le_scan_timeout_event();
 801ac28:	f000 fd6a 	bl	801b700 <hci_le_scan_timeout_event>

  return status;
 801ac2c:	7bfb      	ldrb	r3, [r7, #15]
}
 801ac2e:	4618      	mov	r0, r3
 801ac30:	3710      	adds	r7, #16
 801ac32:	46bd      	mov	sp, r7
 801ac34:	bd80      	pop	{r7, pc}

0801ac36 <hci_le_advertising_set_terminated_event_process>:
 *        advertising events transmitted by the Controller
 * @retval None
 */

tBleStatus hci_le_advertising_set_terminated_event_process(uint8_t *buffer_in)
{
 801ac36:	b580      	push	{r7, lr}
 801ac38:	b084      	sub	sp, #16
 801ac3a:	af00      	add	r7, sp, #0
 801ac3c:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 801ac3e:	2300      	movs	r3, #0
 801ac40:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  hci_le_advertising_set_terminated_event_rp0 *rp0 = (hci_le_advertising_set_terminated_event_rp0 *)buffer_in;
 801ac42:	687b      	ldr	r3, [r7, #4]
 801ac44:	60bb      	str	r3, [r7, #8]
  hci_le_advertising_set_terminated_event(rp0->Status,
 801ac46:	68bb      	ldr	r3, [r7, #8]
 801ac48:	7818      	ldrb	r0, [r3, #0]
 801ac4a:	68bb      	ldr	r3, [r7, #8]
 801ac4c:	7859      	ldrb	r1, [r3, #1]
 801ac4e:	68bb      	ldr	r3, [r7, #8]
 801ac50:	885b      	ldrh	r3, [r3, #2]
 801ac52:	b29a      	uxth	r2, r3
 801ac54:	68bb      	ldr	r3, [r7, #8]
 801ac56:	791b      	ldrb	r3, [r3, #4]
 801ac58:	f000 fd5c 	bl	801b714 <hci_le_advertising_set_terminated_event>
                                          rp0->Advertising_Handle,
                                          rp0->Connection_Handle,
                                          rp0->Num_Completed_Extended_Advertising_Events);

  return status;
 801ac5c:	7bfb      	ldrb	r3, [r7, #15]
}
 801ac5e:	4618      	mov	r0, r3
 801ac60:	3710      	adds	r7, #16
 801ac62:	46bd      	mov	sp, r7
 801ac64:	bd80      	pop	{r7, pc}

0801ac66 <hci_le_scan_request_received_event_process>:
 *        advertising device
 * @retval None
 */

tBleStatus hci_le_scan_request_received_event_process(uint8_t *buffer_in)
{
 801ac66:	b580      	push	{r7, lr}
 801ac68:	b084      	sub	sp, #16
 801ac6a:	af00      	add	r7, sp, #0
 801ac6c:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 801ac6e:	2300      	movs	r3, #0
 801ac70:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  hci_le_scan_request_received_event_rp0 *rp0 = (hci_le_scan_request_received_event_rp0 *)buffer_in;
 801ac72:	687b      	ldr	r3, [r7, #4]
 801ac74:	60bb      	str	r3, [r7, #8]
  hci_le_scan_request_received_event(rp0->Advertising_Handle,
 801ac76:	68bb      	ldr	r3, [r7, #8]
 801ac78:	7818      	ldrb	r0, [r3, #0]
 801ac7a:	68bb      	ldr	r3, [r7, #8]
 801ac7c:	7859      	ldrb	r1, [r3, #1]
                                     rp0->Scanner_Address_Type,
                                     rp0->Scanner_Address);
 801ac7e:	68bb      	ldr	r3, [r7, #8]
 801ac80:	3302      	adds	r3, #2
  hci_le_scan_request_received_event(rp0->Advertising_Handle,
 801ac82:	461a      	mov	r2, r3
 801ac84:	f000 fd5e 	bl	801b744 <hci_le_scan_request_received_event>

  return status;
 801ac88:	7bfb      	ldrb	r3, [r7, #15]
}
 801ac8a:	4618      	mov	r0, r3
 801ac8c:	3710      	adds	r7, #16
 801ac8e:	46bd      	mov	sp, r7
 801ac90:	bd80      	pop	{r7, pc}

0801ac92 <hci_le_channel_selection_algorithm_event_process>:
 *        - 0x02 ... 0xFF: Reserved for future use
 * @retval None
 */

tBleStatus hci_le_channel_selection_algorithm_event_process(uint8_t *buffer_in)
{
 801ac92:	b580      	push	{r7, lr}
 801ac94:	b084      	sub	sp, #16
 801ac96:	af00      	add	r7, sp, #0
 801ac98:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 801ac9a:	2300      	movs	r3, #0
 801ac9c:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  hci_le_channel_selection_algorithm_event_rp0 *rp0 = (hci_le_channel_selection_algorithm_event_rp0 *)buffer_in;
 801ac9e:	687b      	ldr	r3, [r7, #4]
 801aca0:	60bb      	str	r3, [r7, #8]
  hci_le_channel_selection_algorithm_event(rp0->Connection_Handle,
 801aca2:	68bb      	ldr	r3, [r7, #8]
 801aca4:	881b      	ldrh	r3, [r3, #0]
 801aca6:	b29a      	uxth	r2, r3
 801aca8:	68bb      	ldr	r3, [r7, #8]
 801acaa:	789b      	ldrb	r3, [r3, #2]
 801acac:	4619      	mov	r1, r3
 801acae:	4610      	mov	r0, r2
 801acb0:	f000 fd5a 	bl	801b768 <hci_le_channel_selection_algorithm_event>
                                           rp0->Channel_Selection_Algorithm);

  return status;
 801acb4:	7bfb      	ldrb	r3, [r7, #15]
}
 801acb6:	4618      	mov	r0, r3
 801acb8:	3710      	adds	r7, #16
 801acba:	46bd      	mov	sp, r7
 801acbc:	bd80      	pop	{r7, pc}

0801acbe <hci_le_connectionless_iq_report_event_process>:
 * @param Samples See @ref Samples_t
 * @retval None
 */

tBleStatus hci_le_connectionless_iq_report_event_process(uint8_t *buffer_in)
{
 801acbe:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801acc2:	b0ce      	sub	sp, #312	@ 0x138
 801acc4:	af06      	add	r7, sp, #24
 801acc6:	f507 7390 	add.w	r3, r7, #288	@ 0x120
 801acca:	f5a3 738e 	sub.w	r3, r3, #284	@ 0x11c
 801acce:	6018      	str	r0, [r3, #0]
  tBleStatus status = BLE_STATUS_SUCCESS;
 801acd0:	2300      	movs	r3, #0
 801acd2:	f887 3117 	strb.w	r3, [r7, #279]	@ 0x117
  /* Input params */
  hci_le_connectionless_iq_report_event_rp0 *rp0 = (hci_le_connectionless_iq_report_event_rp0 *)buffer_in;
 801acd6:	f507 7390 	add.w	r3, r7, #288	@ 0x120
 801acda:	f5a3 738e 	sub.w	r3, r3, #284	@ 0x11c
 801acde:	681b      	ldr	r3, [r3, #0]
 801ace0:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110
  uint8_t size = 12;
 801ace4:	230c      	movs	r3, #12
 801ace6:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f
  int i;
  Samples_t Samples[HCI_MAX_PAYLOAD_SIZE/sizeof(Samples_t)];
  for (i = 0; i < rp0->Sample_Count; i++) {
 801acea:	2300      	movs	r3, #0
 801acec:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118
 801acf0:	e032      	b.n	801ad58 <hci_le_connectionless_iq_report_event_process+0x9a>
    Samples[i].I_Sample = rp0->Samples[i].I_Sample;
 801acf2:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 801acf6:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 801acfa:	3304      	adds	r3, #4
 801acfc:	005b      	lsls	r3, r3, #1
 801acfe:	4413      	add	r3, r2
 801ad00:	f993 1004 	ldrsb.w	r1, [r3, #4]
 801ad04:	f507 7390 	add.w	r3, r7, #288	@ 0x120
 801ad08:	f5a3 738a 	sub.w	r3, r3, #276	@ 0x114
 801ad0c:	f8d7 2118 	ldr.w	r2, [r7, #280]	@ 0x118
 801ad10:	f803 1012 	strb.w	r1, [r3, r2, lsl #1]
    size += 1;
 801ad14:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 801ad18:	3301      	adds	r3, #1
 801ad1a:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f
    Samples[i].Q_Sample = rp0->Samples[i].Q_Sample;
 801ad1e:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 801ad22:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 801ad26:	3304      	adds	r3, #4
 801ad28:	005b      	lsls	r3, r3, #1
 801ad2a:	4413      	add	r3, r2
 801ad2c:	f993 1005 	ldrsb.w	r1, [r3, #5]
 801ad30:	f507 7390 	add.w	r3, r7, #288	@ 0x120
 801ad34:	f5a3 728a 	sub.w	r2, r3, #276	@ 0x114
 801ad38:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 801ad3c:	005b      	lsls	r3, r3, #1
 801ad3e:	4413      	add	r3, r2
 801ad40:	460a      	mov	r2, r1
 801ad42:	705a      	strb	r2, [r3, #1]
    size += 1;
 801ad44:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 801ad48:	3301      	adds	r3, #1
 801ad4a:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f
  for (i = 0; i < rp0->Sample_Count; i++) {
 801ad4e:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 801ad52:	3301      	adds	r3, #1
 801ad54:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118
 801ad58:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 801ad5c:	7adb      	ldrb	r3, [r3, #11]
 801ad5e:	461a      	mov	r2, r3
 801ad60:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 801ad64:	4293      	cmp	r3, r2
 801ad66:	dbc4      	blt.n	801acf2 <hci_le_connectionless_iq_report_event_process+0x34>
  }
  hci_le_connectionless_iq_report_event(rp0->Sync_Handle,
 801ad68:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 801ad6c:	881b      	ldrh	r3, [r3, #0]
 801ad6e:	b29e      	uxth	r6, r3
 801ad70:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 801ad74:	f893 c002 	ldrb.w	ip, [r3, #2]
 801ad78:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 801ad7c:	f9b3 3003 	ldrsh.w	r3, [r3, #3]
 801ad80:	fa0f fe83 	sxth.w	lr, r3
 801ad84:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 801ad88:	f893 8005 	ldrb.w	r8, [r3, #5]
 801ad8c:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 801ad90:	799b      	ldrb	r3, [r3, #6]
 801ad92:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 801ad96:	79d2      	ldrb	r2, [r2, #7]
 801ad98:	f8d7 1110 	ldr.w	r1, [r7, #272]	@ 0x110
 801ad9c:	7a09      	ldrb	r1, [r1, #8]
 801ad9e:	f8d7 0110 	ldr.w	r0, [r7, #272]	@ 0x110
 801ada2:	f8b0 0009 	ldrh.w	r0, [r0, #9]
 801ada6:	b280      	uxth	r0, r0
 801ada8:	f8d7 4110 	ldr.w	r4, [r7, #272]	@ 0x110
 801adac:	7ae4      	ldrb	r4, [r4, #11]
 801adae:	f107 050c 	add.w	r5, r7, #12
 801adb2:	9505      	str	r5, [sp, #20]
 801adb4:	9404      	str	r4, [sp, #16]
 801adb6:	9003      	str	r0, [sp, #12]
 801adb8:	9102      	str	r1, [sp, #8]
 801adba:	9201      	str	r2, [sp, #4]
 801adbc:	9300      	str	r3, [sp, #0]
 801adbe:	4643      	mov	r3, r8
 801adc0:	4672      	mov	r2, lr
 801adc2:	4661      	mov	r1, ip
 801adc4:	4630      	mov	r0, r6
 801adc6:	f000 fce1 	bl	801b78c <hci_le_connectionless_iq_report_event>
                                        rp0->Packet_Status,
                                        rp0->Periodic_Event_Counter,
                                        rp0->Sample_Count,
                                        Samples);

  return status;
 801adca:	f897 3117 	ldrb.w	r3, [r7, #279]	@ 0x117
}
 801adce:	4618      	mov	r0, r3
 801add0:	f507 7790 	add.w	r7, r7, #288	@ 0x120
 801add4:	46bd      	mov	sp, r7
 801add6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0801adda <hci_le_connection_iq_report_event_process>:
 * @param Samples See @ref Samples_t
 * @retval None
 */

tBleStatus hci_le_connection_iq_report_event_process(uint8_t *buffer_in)
{
 801adda:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 801adde:	b0d1      	sub	sp, #324	@ 0x144
 801ade0:	af08      	add	r7, sp, #32
 801ade2:	f507 7390 	add.w	r3, r7, #288	@ 0x120
 801ade6:	f5a3 738e 	sub.w	r3, r3, #284	@ 0x11c
 801adea:	6018      	str	r0, [r3, #0]
  tBleStatus status = BLE_STATUS_SUCCESS;
 801adec:	2300      	movs	r3, #0
 801adee:	f887 3117 	strb.w	r3, [r7, #279]	@ 0x117
  /* Input params */
  hci_le_connection_iq_report_event_rp0 *rp0 = (hci_le_connection_iq_report_event_rp0 *)buffer_in;
 801adf2:	f507 7390 	add.w	r3, r7, #288	@ 0x120
 801adf6:	f5a3 738e 	sub.w	r3, r3, #284	@ 0x11c
 801adfa:	681b      	ldr	r3, [r3, #0]
 801adfc:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110
  uint8_t size = 13;
 801ae00:	230d      	movs	r3, #13
 801ae02:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f
  int i;
  Samples_t Samples[HCI_MAX_PAYLOAD_SIZE/sizeof(Samples_t)];
  for (i = 0; i < rp0->Sample_Count; i++) {
 801ae06:	2300      	movs	r3, #0
 801ae08:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118
 801ae0c:	e032      	b.n	801ae74 <hci_le_connection_iq_report_event_process+0x9a>
    Samples[i].I_Sample = rp0->Samples[i].I_Sample;
 801ae0e:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 801ae12:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 801ae16:	3304      	adds	r3, #4
 801ae18:	005b      	lsls	r3, r3, #1
 801ae1a:	4413      	add	r3, r2
 801ae1c:	f993 1005 	ldrsb.w	r1, [r3, #5]
 801ae20:	f507 7390 	add.w	r3, r7, #288	@ 0x120
 801ae24:	f5a3 738a 	sub.w	r3, r3, #276	@ 0x114
 801ae28:	f8d7 2118 	ldr.w	r2, [r7, #280]	@ 0x118
 801ae2c:	f803 1012 	strb.w	r1, [r3, r2, lsl #1]
    size += 1;
 801ae30:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 801ae34:	3301      	adds	r3, #1
 801ae36:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f
    Samples[i].Q_Sample = rp0->Samples[i].Q_Sample;
 801ae3a:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 801ae3e:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 801ae42:	3304      	adds	r3, #4
 801ae44:	005b      	lsls	r3, r3, #1
 801ae46:	4413      	add	r3, r2
 801ae48:	f993 1006 	ldrsb.w	r1, [r3, #6]
 801ae4c:	f507 7390 	add.w	r3, r7, #288	@ 0x120
 801ae50:	f5a3 728a 	sub.w	r2, r3, #276	@ 0x114
 801ae54:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 801ae58:	005b      	lsls	r3, r3, #1
 801ae5a:	4413      	add	r3, r2
 801ae5c:	460a      	mov	r2, r1
 801ae5e:	705a      	strb	r2, [r3, #1]
    size += 1;
 801ae60:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 801ae64:	3301      	adds	r3, #1
 801ae66:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f
  for (i = 0; i < rp0->Sample_Count; i++) {
 801ae6a:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 801ae6e:	3301      	adds	r3, #1
 801ae70:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118
 801ae74:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 801ae78:	7b1b      	ldrb	r3, [r3, #12]
 801ae7a:	461a      	mov	r2, r3
 801ae7c:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 801ae80:	4293      	cmp	r3, r2
 801ae82:	dbc4      	blt.n	801ae0e <hci_le_connection_iq_report_event_process+0x34>
  }
  hci_le_connection_iq_report_event(rp0->Connection_Handle,
 801ae84:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 801ae88:	881b      	ldrh	r3, [r3, #0]
 801ae8a:	fa1f fc83 	uxth.w	ip, r3
 801ae8e:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 801ae92:	f893 e002 	ldrb.w	lr, [r3, #2]
 801ae96:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 801ae9a:	f893 8003 	ldrb.w	r8, [r3, #3]
 801ae9e:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 801aea2:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801aea6:	fa0f f983 	sxth.w	r9, r3
 801aeaa:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 801aeae:	799b      	ldrb	r3, [r3, #6]
 801aeb0:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 801aeb4:	79d2      	ldrb	r2, [r2, #7]
 801aeb6:	f8d7 1110 	ldr.w	r1, [r7, #272]	@ 0x110
 801aeba:	7a09      	ldrb	r1, [r1, #8]
 801aebc:	f8d7 0110 	ldr.w	r0, [r7, #272]	@ 0x110
 801aec0:	7a40      	ldrb	r0, [r0, #9]
 801aec2:	f8d7 4110 	ldr.w	r4, [r7, #272]	@ 0x110
 801aec6:	8964      	ldrh	r4, [r4, #10]
 801aec8:	b2a4      	uxth	r4, r4
 801aeca:	f8d7 5110 	ldr.w	r5, [r7, #272]	@ 0x110
 801aece:	7b2d      	ldrb	r5, [r5, #12]
 801aed0:	f107 060c 	add.w	r6, r7, #12
 801aed4:	9606      	str	r6, [sp, #24]
 801aed6:	9505      	str	r5, [sp, #20]
 801aed8:	9404      	str	r4, [sp, #16]
 801aeda:	9003      	str	r0, [sp, #12]
 801aedc:	9102      	str	r1, [sp, #8]
 801aede:	9201      	str	r2, [sp, #4]
 801aee0:	9300      	str	r3, [sp, #0]
 801aee2:	464b      	mov	r3, r9
 801aee4:	4642      	mov	r2, r8
 801aee6:	4671      	mov	r1, lr
 801aee8:	4660      	mov	r0, ip
 801aeea:	f000 fc67 	bl	801b7bc <hci_le_connection_iq_report_event>
                                    rp0->Packet_Status,
                                    rp0->Connection_Event_Counter,
                                    rp0->Sample_Count,
                                    Samples);

  return status;
 801aeee:	f897 3117 	ldrb.w	r3, [r7, #279]	@ 0x117
}
 801aef2:	4618      	mov	r0, r3
 801aef4:	f507 7792 	add.w	r7, r7, #292	@ 0x124
 801aef8:	46bd      	mov	sp, r7
 801aefa:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

0801aefe <hci_le_cte_request_failed_event_process>:
 *        - 0x0000 ... 0x0EFF
 * @retval None
 */

tBleStatus hci_le_cte_request_failed_event_process(uint8_t *buffer_in)
{
 801aefe:	b580      	push	{r7, lr}
 801af00:	b084      	sub	sp, #16
 801af02:	af00      	add	r7, sp, #0
 801af04:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 801af06:	2300      	movs	r3, #0
 801af08:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  hci_le_cte_request_failed_event_rp0 *rp0 = (hci_le_cte_request_failed_event_rp0 *)buffer_in;
 801af0a:	687b      	ldr	r3, [r7, #4]
 801af0c:	60bb      	str	r3, [r7, #8]
  hci_le_cte_request_failed_event(rp0->Status,
 801af0e:	68bb      	ldr	r3, [r7, #8]
 801af10:	781a      	ldrb	r2, [r3, #0]
 801af12:	68bb      	ldr	r3, [r7, #8]
 801af14:	f8b3 3001 	ldrh.w	r3, [r3, #1]
 801af18:	b29b      	uxth	r3, r3
 801af1a:	4619      	mov	r1, r3
 801af1c:	4610      	mov	r0, r2
 801af1e:	f000 fc65 	bl	801b7ec <hci_le_cte_request_failed_event>
                                  rp0->Connection_Handle);

  return status;
 801af22:	7bfb      	ldrb	r3, [r7, #15]
}
 801af24:	4618      	mov	r0, r3
 801af26:	3710      	adds	r7, #16
 801af28:	46bd      	mov	sp, r7
 801af2a:	bd80      	pop	{r7, pc}

0801af2c <hci_le_periodic_advertising_sync_transfer_received_event_process>:
 *        - 0x07: 20 ppm
 * @retval None
 */

tBleStatus hci_le_periodic_advertising_sync_transfer_received_event_process(uint8_t *buffer_in)
{
 801af2c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801af30:	b08a      	sub	sp, #40	@ 0x28
 801af32:	af06      	add	r7, sp, #24
 801af34:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 801af36:	2300      	movs	r3, #0
 801af38:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  hci_le_periodic_advertising_sync_transfer_received_event_rp0 *rp0 = (hci_le_periodic_advertising_sync_transfer_received_event_rp0 *)buffer_in;
 801af3a:	687b      	ldr	r3, [r7, #4]
 801af3c:	60bb      	str	r3, [r7, #8]
  hci_le_periodic_advertising_sync_transfer_received_event(rp0->Status,
 801af3e:	68bb      	ldr	r3, [r7, #8]
 801af40:	781e      	ldrb	r6, [r3, #0]
 801af42:	68bb      	ldr	r3, [r7, #8]
 801af44:	f8b3 3001 	ldrh.w	r3, [r3, #1]
 801af48:	fa1f fc83 	uxth.w	ip, r3
 801af4c:	68bb      	ldr	r3, [r7, #8]
 801af4e:	f8b3 3003 	ldrh.w	r3, [r3, #3]
 801af52:	fa1f fe83 	uxth.w	lr, r3
 801af56:	68bb      	ldr	r3, [r7, #8]
 801af58:	f8b3 3005 	ldrh.w	r3, [r3, #5]
 801af5c:	fa1f f883 	uxth.w	r8, r3
 801af60:	68bb      	ldr	r3, [r7, #8]
 801af62:	79db      	ldrb	r3, [r3, #7]
 801af64:	68ba      	ldr	r2, [r7, #8]
 801af66:	7a12      	ldrb	r2, [r2, #8]
                                                           rp0->Connection_Handle,
                                                           rp0->Service_data,
                                                           rp0->Sync_Handle,
                                                           rp0->Advertising_SID,
                                                           rp0->Advertiser_Address_Type,
                                                           rp0->Advertiser_Address,
 801af68:	68b9      	ldr	r1, [r7, #8]
 801af6a:	3109      	adds	r1, #9
  hci_le_periodic_advertising_sync_transfer_received_event(rp0->Status,
 801af6c:	68b8      	ldr	r0, [r7, #8]
 801af6e:	7bc0      	ldrb	r0, [r0, #15]
 801af70:	68bc      	ldr	r4, [r7, #8]
 801af72:	8a24      	ldrh	r4, [r4, #16]
 801af74:	b2a4      	uxth	r4, r4
 801af76:	68bd      	ldr	r5, [r7, #8]
 801af78:	7cad      	ldrb	r5, [r5, #18]
 801af7a:	9505      	str	r5, [sp, #20]
 801af7c:	9404      	str	r4, [sp, #16]
 801af7e:	9003      	str	r0, [sp, #12]
 801af80:	9102      	str	r1, [sp, #8]
 801af82:	9201      	str	r2, [sp, #4]
 801af84:	9300      	str	r3, [sp, #0]
 801af86:	4643      	mov	r3, r8
 801af88:	4672      	mov	r2, lr
 801af8a:	4661      	mov	r1, ip
 801af8c:	4630      	mov	r0, r6
 801af8e:	f000 fc3f 	bl	801b810 <hci_le_periodic_advertising_sync_transfer_received_event>
                                                           rp0->Advertiser_PHY,
                                                           rp0->Periodic_Advertising_Interval,
                                                           rp0->Advertiser_Clock_Accuracy);

  return status;
 801af92:	7bfb      	ldrb	r3, [r7, #15]
}
 801af94:	4618      	mov	r0, r3
 801af96:	3710      	adds	r7, #16
 801af98:	46bd      	mov	sp, r7
 801af9a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0801af9e <hci_le_path_loss_threshold_event_process>:
 *        - 0x02: HIGH_ZONE
 * @retval None
 */

tBleStatus hci_le_path_loss_threshold_event_process(uint8_t *buffer_in)
{
 801af9e:	b580      	push	{r7, lr}
 801afa0:	b084      	sub	sp, #16
 801afa2:	af00      	add	r7, sp, #0
 801afa4:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 801afa6:	2300      	movs	r3, #0
 801afa8:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  hci_le_path_loss_threshold_event_rp0 *rp0 = (hci_le_path_loss_threshold_event_rp0 *)buffer_in;
 801afaa:	687b      	ldr	r3, [r7, #4]
 801afac:	60bb      	str	r3, [r7, #8]
  hci_le_path_loss_threshold_event(rp0->Connection_Handle,
 801afae:	68bb      	ldr	r3, [r7, #8]
 801afb0:	881b      	ldrh	r3, [r3, #0]
 801afb2:	b298      	uxth	r0, r3
 801afb4:	68bb      	ldr	r3, [r7, #8]
 801afb6:	7899      	ldrb	r1, [r3, #2]
 801afb8:	68bb      	ldr	r3, [r7, #8]
 801afba:	78db      	ldrb	r3, [r3, #3]
 801afbc:	461a      	mov	r2, r3
 801afbe:	f000 fc3f 	bl	801b840 <hci_le_path_loss_threshold_event>
                                   rp0->Current_Path_Loss,
                                   rp0->Zone_Entered);

  return status;
 801afc2:	7bfb      	ldrb	r3, [r7, #15]
}
 801afc4:	4618      	mov	r0, r3
 801afc6:	3710      	adds	r7, #16
 801afc8:	46bd      	mov	sp, r7
 801afca:	bd80      	pop	{r7, pc}

0801afcc <hci_le_transmit_power_reporting_event_process>:
 *        - 0 ... 126
 * @retval None
 */

tBleStatus hci_le_transmit_power_reporting_event_process(uint8_t *buffer_in)
{
 801afcc:	b5f0      	push	{r4, r5, r6, r7, lr}
 801afce:	b089      	sub	sp, #36	@ 0x24
 801afd0:	af04      	add	r7, sp, #16
 801afd2:	6078      	str	r0, [r7, #4]
  tBleStatus status = BLE_STATUS_SUCCESS;
 801afd4:	2300      	movs	r3, #0
 801afd6:	73fb      	strb	r3, [r7, #15]
  /* Input params */
  hci_le_transmit_power_reporting_event_rp0 *rp0 = (hci_le_transmit_power_reporting_event_rp0 *)buffer_in;
 801afd8:	687b      	ldr	r3, [r7, #4]
 801afda:	60bb      	str	r3, [r7, #8]
  hci_le_transmit_power_reporting_event(rp0->Status,
 801afdc:	68bb      	ldr	r3, [r7, #8]
 801afde:	7818      	ldrb	r0, [r3, #0]
 801afe0:	68bb      	ldr	r3, [r7, #8]
 801afe2:	f8b3 3001 	ldrh.w	r3, [r3, #1]
 801afe6:	b29c      	uxth	r4, r3
 801afe8:	68bb      	ldr	r3, [r7, #8]
 801afea:	78dd      	ldrb	r5, [r3, #3]
 801afec:	68bb      	ldr	r3, [r7, #8]
 801afee:	791e      	ldrb	r6, [r3, #4]
 801aff0:	68bb      	ldr	r3, [r7, #8]
 801aff2:	f993 3005 	ldrsb.w	r3, [r3, #5]
 801aff6:	68ba      	ldr	r2, [r7, #8]
 801aff8:	7992      	ldrb	r2, [r2, #6]
 801affa:	68b9      	ldr	r1, [r7, #8]
 801affc:	f991 1007 	ldrsb.w	r1, [r1, #7]
 801b000:	9102      	str	r1, [sp, #8]
 801b002:	9201      	str	r2, [sp, #4]
 801b004:	9300      	str	r3, [sp, #0]
 801b006:	4633      	mov	r3, r6
 801b008:	462a      	mov	r2, r5
 801b00a:	4621      	mov	r1, r4
 801b00c:	f000 fc2a 	bl	801b864 <hci_le_transmit_power_reporting_event>
                                        rp0->PHY,
                                        rp0->Transmit_Power_Level,
                                        rp0->Transmit_Power_Level_Flag,
                                        rp0->Delta);

  return status;
 801b010:	7bfb      	ldrb	r3, [r7, #15]
}
 801b012:	4618      	mov	r0, r3
 801b014:	3714      	adds	r7, #20
 801b016:	46bd      	mov	sp, r7
 801b018:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

0801b01c <hci_read_remote_version_information_complete_event>:
WEAK_FUNCTION(void hci_read_remote_version_information_complete_event(uint8_t Status,
                                                                      uint16_t Connection_Handle,
                                                                      uint8_t Version,
                                                                      uint16_t Manufacturer_Name,
                                                                      uint16_t Subversion))
{
 801b01c:	b590      	push	{r4, r7, lr}
 801b01e:	b083      	sub	sp, #12
 801b020:	af00      	add	r7, sp, #0
 801b022:	4604      	mov	r4, r0
 801b024:	4608      	mov	r0, r1
 801b026:	4611      	mov	r1, r2
 801b028:	461a      	mov	r2, r3
 801b02a:	4623      	mov	r3, r4
 801b02c:	71fb      	strb	r3, [r7, #7]
 801b02e:	4603      	mov	r3, r0
 801b030:	80bb      	strh	r3, [r7, #4]
 801b032:	460b      	mov	r3, r1
 801b034:	71bb      	strb	r3, [r7, #6]
 801b036:	4613      	mov	r3, r2
 801b038:	807b      	strh	r3, [r7, #2]
  /* NOTE : This function Should not be modified, when needed,
            the callback could be implemented in the user file
   */
  BLUENRG_PRINTF("hci_read_remote_version_information_complete_event\r\n");
 801b03a:	4803      	ldr	r0, [pc, #12]	@ (801b048 <hci_read_remote_version_information_complete_event+0x2c>)
 801b03c:	f008 fef6 	bl	8023e2c <puts>
}
 801b040:	bf00      	nop
 801b042:	370c      	adds	r7, #12
 801b044:	46bd      	mov	sp, r7
 801b046:	bd90      	pop	{r4, r7, pc}
 801b048:	08027ed8 	.word	0x08027ed8

0801b04c <hci_number_of_completed_packets_event>:
  * @param Handle_Packets_Pair_Entry See @ref Handle_Packets_Pair_Entry_t
  * @retval None
*/
WEAK_FUNCTION(void hci_number_of_completed_packets_event(uint8_t Number_of_Handles,
                                                         Handle_Packets_Pair_Entry_t Handle_Packets_Pair_Entry[]))
{
 801b04c:	b580      	push	{r7, lr}
 801b04e:	b082      	sub	sp, #8
 801b050:	af00      	add	r7, sp, #0
 801b052:	4603      	mov	r3, r0
 801b054:	6039      	str	r1, [r7, #0]
 801b056:	71fb      	strb	r3, [r7, #7]
  /* NOTE : This function Should not be modified, when needed,
            the callback could be implemented in the user file
   */
  BLUENRG_PRINTF("hci_number_of_completed_packets_event\r\n");
 801b058:	4803      	ldr	r0, [pc, #12]	@ (801b068 <hci_number_of_completed_packets_event+0x1c>)
 801b05a:	f008 fee7 	bl	8023e2c <puts>
}
 801b05e:	bf00      	nop
 801b060:	3708      	adds	r7, #8
 801b062:	46bd      	mov	sp, r7
 801b064:	bd80      	pop	{r7, pc}
 801b066:	bf00      	nop
 801b068:	08027f28 	.word	0x08027f28

0801b06c <hci_data_buffer_overflow_event>:
  * Values:
  - 0x01: ACL Buffer Overflow
  * @retval None
*/
WEAK_FUNCTION(void hci_data_buffer_overflow_event(uint8_t Link_Type))
{
 801b06c:	b580      	push	{r7, lr}
 801b06e:	b082      	sub	sp, #8
 801b070:	af00      	add	r7, sp, #0
 801b072:	4603      	mov	r3, r0
 801b074:	71fb      	strb	r3, [r7, #7]
  /* NOTE : This function Should not be modified, when needed,
            the callback could be implemented in the user file
   */
  BLUENRG_PRINTF("hci_data_buffer_overflow_event\r\n");
 801b076:	4803      	ldr	r0, [pc, #12]	@ (801b084 <hci_data_buffer_overflow_event+0x18>)
 801b078:	f008 fed8 	bl	8023e2c <puts>
}
 801b07c:	bf00      	nop
 801b07e:	3708      	adds	r7, #8
 801b080:	46bd      	mov	sp, r7
 801b082:	bd80      	pop	{r7, pc}
 801b084:	08027f50 	.word	0x08027f50

0801b088 <hci_encryption_key_refresh_complete_event>:
  - 0x0000 ... 0x0EFF
  * @retval None
*/
WEAK_FUNCTION(void hci_encryption_key_refresh_complete_event(uint8_t Status,
                                                             uint16_t Connection_Handle))
{
 801b088:	b580      	push	{r7, lr}
 801b08a:	b082      	sub	sp, #8
 801b08c:	af00      	add	r7, sp, #0
 801b08e:	4603      	mov	r3, r0
 801b090:	460a      	mov	r2, r1
 801b092:	71fb      	strb	r3, [r7, #7]
 801b094:	4613      	mov	r3, r2
 801b096:	80bb      	strh	r3, [r7, #4]
  /* NOTE : This function Should not be modified, when needed,
            the callback could be implemented in the user file
   */
  BLUENRG_PRINTF("hci_encryption_key_refresh_complete_event\r\n");
 801b098:	4803      	ldr	r0, [pc, #12]	@ (801b0a8 <hci_encryption_key_refresh_complete_event+0x20>)
 801b09a:	f008 fec7 	bl	8023e2c <puts>
}
 801b09e:	bf00      	nop
 801b0a0:	3708      	adds	r7, #8
 801b0a2:	46bd      	mov	sp, r7
 801b0a4:	bd80      	pop	{r7, pc}
 801b0a6:	bf00      	nop
 801b0a8:	08027f70 	.word	0x08027f70

0801b0ac <hci_authenticated_payload_timeout_expired_event>:
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @retval None
 */
WEAK_FUNCTION(void hci_authenticated_payload_timeout_expired_event(uint16_t onnection_Handle))
{
 801b0ac:	b580      	push	{r7, lr}
 801b0ae:	b082      	sub	sp, #8
 801b0b0:	af00      	add	r7, sp, #0
 801b0b2:	4603      	mov	r3, r0
 801b0b4:	80fb      	strh	r3, [r7, #6]
  /* NOTE : This function Should not be modified, when needed,
            the callback could be implemented in the user file
   */
  BLUENRG_PRINTF("hci_authenticated_payload_timeout_expired_event\r\n");
 801b0b6:	4803      	ldr	r0, [pc, #12]	@ (801b0c4 <hci_authenticated_payload_timeout_expired_event+0x18>)
 801b0b8:	f008 feb8 	bl	8023e2c <puts>
}
 801b0bc:	bf00      	nop
 801b0be:	3708      	adds	r7, #8
 801b0c0:	46bd      	mov	sp, r7
 801b0c2:	bd80      	pop	{r7, pc}
 801b0c4:	08027f9c 	.word	0x08027f9c

0801b0c8 <hci_le_read_remote_used_features_complete_event>:
  * @retval None
*/
WEAK_FUNCTION(void hci_le_read_remote_used_features_complete_event(uint8_t Status,
                                                                   uint16_t Connection_Handle,
                                                                   uint8_t LE_Features[8]))
{
 801b0c8:	b580      	push	{r7, lr}
 801b0ca:	b082      	sub	sp, #8
 801b0cc:	af00      	add	r7, sp, #0
 801b0ce:	4603      	mov	r3, r0
 801b0d0:	603a      	str	r2, [r7, #0]
 801b0d2:	71fb      	strb	r3, [r7, #7]
 801b0d4:	460b      	mov	r3, r1
 801b0d6:	80bb      	strh	r3, [r7, #4]
  /* NOTE : This function Should not be modified, when needed,
            the callback could be implemented in the user file
   */
  BLUENRG_PRINTF("hci_le_read_remote_used_features_complete_event\r\n");
 801b0d8:	4803      	ldr	r0, [pc, #12]	@ (801b0e8 <hci_le_read_remote_used_features_complete_event+0x20>)
 801b0da:	f008 fea7 	bl	8023e2c <puts>
}
 801b0de:	bf00      	nop
 801b0e0:	3708      	adds	r7, #8
 801b0e2:	46bd      	mov	sp, r7
 801b0e4:	bd80      	pop	{r7, pc}
 801b0e6:	bf00      	nop
 801b0e8:	08028044 	.word	0x08028044

0801b0ec <hci_le_long_term_key_request_event>:
  * @retval None
*/
WEAK_FUNCTION(void hci_le_long_term_key_request_event(uint16_t Connection_Handle,
                                                      uint8_t Random_Number[8],
                                                      uint16_t Encrypted_Diversifier))
{
 801b0ec:	b580      	push	{r7, lr}
 801b0ee:	b082      	sub	sp, #8
 801b0f0:	af00      	add	r7, sp, #0
 801b0f2:	4603      	mov	r3, r0
 801b0f4:	6039      	str	r1, [r7, #0]
 801b0f6:	80fb      	strh	r3, [r7, #6]
 801b0f8:	4613      	mov	r3, r2
 801b0fa:	80bb      	strh	r3, [r7, #4]
  /* NOTE : This function Should not be modified, when needed,
            the callback could be implemented in the user file
   */
  BLUENRG_PRINTF("hci_le_long_term_key_request_event\r\n");
 801b0fc:	4803      	ldr	r0, [pc, #12]	@ (801b10c <hci_le_long_term_key_request_event+0x20>)
 801b0fe:	f008 fe95 	bl	8023e2c <puts>
}
 801b102:	bf00      	nop
 801b104:	3708      	adds	r7, #8
 801b106:	46bd      	mov	sp, r7
 801b108:	bd80      	pop	{r7, pc}
 801b10a:	bf00      	nop
 801b10c:	08028078 	.word	0x08028078

0801b110 <hci_le_read_local_p256_public_key_complete_event>:
  * @param Local_P256_Public_Key Local P-256 public key.
  * @retval None
*/
WEAK_FUNCTION(void hci_le_read_local_p256_public_key_complete_event(uint8_t Status,
                                                                    uint8_t Local_P256_Public_Key[64]))
{
 801b110:	b580      	push	{r7, lr}
 801b112:	b082      	sub	sp, #8
 801b114:	af00      	add	r7, sp, #0
 801b116:	4603      	mov	r3, r0
 801b118:	6039      	str	r1, [r7, #0]
 801b11a:	71fb      	strb	r3, [r7, #7]
  /* NOTE : This function Should not be modified, when needed,
            the callback could be implemented in the user file
   */
  BLUENRG_PRINTF("hci_le_read_local_p256_public_key_complete_event\r\n");
 801b11c:	4803      	ldr	r0, [pc, #12]	@ (801b12c <hci_le_read_local_p256_public_key_complete_event+0x1c>)
 801b11e:	f008 fe85 	bl	8023e2c <puts>
}
 801b122:	bf00      	nop
 801b124:	3708      	adds	r7, #8
 801b126:	46bd      	mov	sp, r7
 801b128:	bd80      	pop	{r7, pc}
 801b12a:	bf00      	nop
 801b12c:	080280c0 	.word	0x080280c0

0801b130 <hci_le_generate_dhkey_complete_event>:
  * @param DHKey Diffie Hellman Key
  * @retval None
*/
WEAK_FUNCTION(void hci_le_generate_dhkey_complete_event(uint8_t Status,
                                                        uint8_t DHKey[32]))
{
 801b130:	b580      	push	{r7, lr}
 801b132:	b082      	sub	sp, #8
 801b134:	af00      	add	r7, sp, #0
 801b136:	4603      	mov	r3, r0
 801b138:	6039      	str	r1, [r7, #0]
 801b13a:	71fb      	strb	r3, [r7, #7]
  /* NOTE : This function Should not be modified, when needed,
            the callback could be implemented in the user file
   */
  BLUENRG_PRINTF("hci_le_generate_dhkey_complete_event\r\n");
 801b13c:	4803      	ldr	r0, [pc, #12]	@ (801b14c <hci_le_generate_dhkey_complete_event+0x1c>)
 801b13e:	f008 fe75 	bl	8023e2c <puts>
}
 801b142:	bf00      	nop
 801b144:	3708      	adds	r7, #8
 801b146:	46bd      	mov	sp, r7
 801b148:	bd80      	pop	{r7, pc}
 801b14a:	bf00      	nop
 801b14c:	080280f4 	.word	0x080280f4

0801b150 <hci_le_direct_advertising_report_event>:
  * @param Direct_Advertising_Report See @ref Direct_Advertising_Report_t
  * @retval None
*/
WEAK_FUNCTION(void hci_le_direct_advertising_report_event(uint8_t Num_Reports,
                                                          Direct_Advertising_Report_t Direct_Advertising_Report[]))
{
 801b150:	b580      	push	{r7, lr}
 801b152:	b082      	sub	sp, #8
 801b154:	af00      	add	r7, sp, #0
 801b156:	4603      	mov	r3, r0
 801b158:	6039      	str	r1, [r7, #0]
 801b15a:	71fb      	strb	r3, [r7, #7]
  /* NOTE : This function Should not be modified, when needed,
            the callback could be implemented in the user file
   */
  BLUENRG_PRINTF("hci_le_direct_advertising_report_event\r\n");
 801b15c:	4803      	ldr	r0, [pc, #12]	@ (801b16c <hci_le_direct_advertising_report_event+0x1c>)
 801b15e:	f008 fe65 	bl	8023e2c <puts>
}
 801b162:	bf00      	nop
 801b164:	3708      	adds	r7, #8
 801b166:	46bd      	mov	sp, r7
 801b168:	bd80      	pop	{r7, pc}
 801b16a:	bf00      	nop
 801b16c:	08028148 	.word	0x08028148

0801b170 <aci_gap_limited_discoverable_event>:
  * @brief This event is generated by the controller when the limited discoverable mode ends due to
timeout. The timeout is 180 seconds.
  * @retval None
*/
WEAK_FUNCTION(void aci_gap_limited_discoverable_event(void))
{
 801b170:	b580      	push	{r7, lr}
 801b172:	af00      	add	r7, sp, #0
  /* NOTE : This function Should not be modified, when needed,
            the callback could be implemented in the user file
   */
  BLUENRG_PRINTF("aci_gap_limited_discoverable_event\r\n");
 801b174:	4802      	ldr	r0, [pc, #8]	@ (801b180 <aci_gap_limited_discoverable_event+0x10>)
 801b176:	f008 fe59 	bl	8023e2c <puts>
}
 801b17a:	bf00      	nop
 801b17c:	bd80      	pop	{r7, pc}
 801b17e:	bf00      	nop
 801b180:	08028170 	.word	0x08028170

0801b184 <aci_gap_slave_security_initiated_event>:
/**
  * @brief This event is generated when the slave security request is successfully sent to the master.
  * @retval None
*/
WEAK_FUNCTION(void aci_gap_slave_security_initiated_event(void))
{
 801b184:	b580      	push	{r7, lr}
 801b186:	af00      	add	r7, sp, #0
  /* NOTE : This function Should not be modified, when needed,
            the callback could be implemented in the user file
   */
  BLUENRG_PRINTF("aci_gap_slave_security_initiated_event\r\n");
 801b188:	4802      	ldr	r0, [pc, #8]	@ (801b194 <aci_gap_slave_security_initiated_event+0x10>)
 801b18a:	f008 fe4f 	bl	8023e2c <puts>
}
 801b18e:	bf00      	nop
 801b190:	bd80      	pop	{r7, pc}
 801b192:	bf00      	nop
 801b194:	080281f4 	.word	0x080281f4

0801b198 <aci_gap_proc_complete_event>:
*/
WEAK_FUNCTION(void aci_gap_proc_complete_event(uint8_t Procedure_Code,
                                               uint8_t Status,
                                               uint8_t Data_Length,
                                               uint8_t Data[]))
{
 801b198:	b580      	push	{r7, lr}
 801b19a:	b082      	sub	sp, #8
 801b19c:	af00      	add	r7, sp, #0
 801b19e:	603b      	str	r3, [r7, #0]
 801b1a0:	4603      	mov	r3, r0
 801b1a2:	71fb      	strb	r3, [r7, #7]
 801b1a4:	460b      	mov	r3, r1
 801b1a6:	71bb      	strb	r3, [r7, #6]
 801b1a8:	4613      	mov	r3, r2
 801b1aa:	717b      	strb	r3, [r7, #5]
  /* NOTE : This function Should not be modified, when needed,
            the callback could be implemented in the user file
   */
  BLUENRG_PRINTF("aci_gap_proc_complete_event\r\n");
 801b1ac:	4803      	ldr	r0, [pc, #12]	@ (801b1bc <aci_gap_proc_complete_event+0x24>)
 801b1ae:	f008 fe3d 	bl	8023e2c <puts>
}
 801b1b2:	bf00      	nop
 801b1b4:	3708      	adds	r7, #8
 801b1b6:	46bd      	mov	sp, r7
 801b1b8:	bd80      	pop	{r7, pc}
 801b1ba:	bf00      	nop
 801b1bc:	08028238 	.word	0x08028238

0801b1c0 <aci_gap_addr_not_resolved_event>:
  * @param Connection_Handle Connection handle for which the private address could not be
resolved with any of the stored IRK's.
  * @retval None
*/
WEAK_FUNCTION(void aci_gap_addr_not_resolved_event(uint16_t Connection_Handle))
{
 801b1c0:	b580      	push	{r7, lr}
 801b1c2:	b082      	sub	sp, #8
 801b1c4:	af00      	add	r7, sp, #0
 801b1c6:	4603      	mov	r3, r0
 801b1c8:	80fb      	strh	r3, [r7, #6]
  /* NOTE : This function Should not be modified, when needed,
            the callback could be implemented in the user file
   */
  BLUENRG_PRINTF("aci_gap_addr_not_resolved_event\r\n");
 801b1ca:	4803      	ldr	r0, [pc, #12]	@ (801b1d8 <aci_gap_addr_not_resolved_event+0x18>)
 801b1cc:	f008 fe2e 	bl	8023e2c <puts>
}
 801b1d0:	bf00      	nop
 801b1d2:	3708      	adds	r7, #8
 801b1d4:	46bd      	mov	sp, r7
 801b1d6:	bd80      	pop	{r7, pc}
 801b1d8:	08028258 	.word	0x08028258

0801b1dc <aci_gap_keypress_notification_event>:
  * @param Notification_Type Type of Keypress input notified/signaled by peer device (having Keyboard only I/O capabilities
  * @retval None
*/
WEAK_FUNCTION(void aci_gap_keypress_notification_event(uint16_t Connection_Handle,
                                                       uint8_t Notification_Type))
{
 801b1dc:	b580      	push	{r7, lr}
 801b1de:	b082      	sub	sp, #8
 801b1e0:	af00      	add	r7, sp, #0
 801b1e2:	4603      	mov	r3, r0
 801b1e4:	460a      	mov	r2, r1
 801b1e6:	80fb      	strh	r3, [r7, #6]
 801b1e8:	4613      	mov	r3, r2
 801b1ea:	717b      	strb	r3, [r7, #5]
  /* NOTE : This function Should not be modified, when needed,
            the callback could be implemented in the user file
   */
  BLUENRG_PRINTF("aci_gap_keypress_notification_event\r\n");
 801b1ec:	4803      	ldr	r0, [pc, #12]	@ (801b1fc <aci_gap_keypress_notification_event+0x20>)
 801b1ee:	f008 fe1d 	bl	8023e2c <puts>
}
 801b1f2:	bf00      	nop
 801b1f4:	3708      	adds	r7, #8
 801b1f6:	46bd      	mov	sp, r7
 801b1f8:	bd80      	pop	{r7, pc}
 801b1fa:	bf00      	nop
 801b1fc:	080282a4 	.word	0x080282a4

0801b200 <aci_l2cap_proc_timeout_event>:
  * @retval None
*/
WEAK_FUNCTION(void aci_l2cap_proc_timeout_event(uint16_t Connection_Handle,
                                                uint8_t Data_Length,
                                                uint8_t Data[]))
{
 801b200:	b580      	push	{r7, lr}
 801b202:	b082      	sub	sp, #8
 801b204:	af00      	add	r7, sp, #0
 801b206:	4603      	mov	r3, r0
 801b208:	603a      	str	r2, [r7, #0]
 801b20a:	80fb      	strh	r3, [r7, #6]
 801b20c:	460b      	mov	r3, r1
 801b20e:	717b      	strb	r3, [r7, #5]
  /* NOTE : This function Should not be modified, when needed,
            the callback could be implemented in the user file
   */
  BLUENRG_PRINTF("aci_l2cap_proc_timeout_event\r\n");
 801b210:	4803      	ldr	r0, [pc, #12]	@ (801b220 <aci_l2cap_proc_timeout_event+0x20>)
 801b212:	f008 fe0b 	bl	8023e2c <puts>
}
 801b216:	bf00      	nop
 801b218:	3708      	adds	r7, #8
 801b21a:	46bd      	mov	sp, r7
 801b21c:	bd80      	pop	{r7, pc}
 801b21e:	bf00      	nop
 801b220:	080285b4 	.word	0x080285b4

0801b224 <aci_l2cap_connection_update_req_event>:
                                                         uint16_t L2CAP_Length,
                                                         uint16_t Interval_Min,
                                                         uint16_t Interval_Max,
                                                         uint16_t Slave_Latency,
                                                         uint16_t Timeout_Multiplier))
{
 801b224:	b590      	push	{r4, r7, lr}
 801b226:	b083      	sub	sp, #12
 801b228:	af00      	add	r7, sp, #0
 801b22a:	4604      	mov	r4, r0
 801b22c:	4608      	mov	r0, r1
 801b22e:	4611      	mov	r1, r2
 801b230:	461a      	mov	r2, r3
 801b232:	4623      	mov	r3, r4
 801b234:	80fb      	strh	r3, [r7, #6]
 801b236:	4603      	mov	r3, r0
 801b238:	717b      	strb	r3, [r7, #5]
 801b23a:	460b      	mov	r3, r1
 801b23c:	807b      	strh	r3, [r7, #2]
 801b23e:	4613      	mov	r3, r2
 801b240:	803b      	strh	r3, [r7, #0]
  /* NOTE : This function Should not be modified, when needed,
            the callback could be implemented in the user file
   */
  BLUENRG_PRINTF("aci_l2cap_connection_update_req_event\r\n");
 801b242:	4803      	ldr	r0, [pc, #12]	@ (801b250 <aci_l2cap_connection_update_req_event+0x2c>)
 801b244:	f008 fdf2 	bl	8023e2c <puts>
}
 801b248:	bf00      	nop
 801b24a:	370c      	adds	r7, #12
 801b24c:	46bd      	mov	sp, r7
 801b24e:	bd90      	pop	{r4, r7, pc}
 801b250:	080285d4 	.word	0x080285d4

0801b254 <aci_l2cap_command_reject_event>:
WEAK_FUNCTION(void aci_l2cap_command_reject_event(uint16_t Connection_Handle,
                                                  uint8_t Identifier,
                                                  uint16_t Reason,
                                                  uint8_t Data_Length,
                                                  uint8_t Data[]))
{
 801b254:	b590      	push	{r4, r7, lr}
 801b256:	b083      	sub	sp, #12
 801b258:	af00      	add	r7, sp, #0
 801b25a:	4604      	mov	r4, r0
 801b25c:	4608      	mov	r0, r1
 801b25e:	4611      	mov	r1, r2
 801b260:	461a      	mov	r2, r3
 801b262:	4623      	mov	r3, r4
 801b264:	80fb      	strh	r3, [r7, #6]
 801b266:	4603      	mov	r3, r0
 801b268:	717b      	strb	r3, [r7, #5]
 801b26a:	460b      	mov	r3, r1
 801b26c:	807b      	strh	r3, [r7, #2]
 801b26e:	4613      	mov	r3, r2
 801b270:	713b      	strb	r3, [r7, #4]
  /* NOTE : This function Should not be modified, when needed,
            the callback could be implemented in the user file
   */
  BLUENRG_PRINTF("aci_l2cap_command_reject_event\r\n");
 801b272:	4803      	ldr	r0, [pc, #12]	@ (801b280 <aci_l2cap_command_reject_event+0x2c>)
 801b274:	f008 fdda 	bl	8023e2c <puts>
}
 801b278:	bf00      	nop
 801b27a:	370c      	adds	r7, #12
 801b27c:	46bd      	mov	sp, r7
 801b27e:	bd90      	pop	{r4, r7, pc}
 801b280:	080285fc 	.word	0x080285fc

0801b284 <aci_blue_initialized_event>:
  - 0x08: System reset due to crash
  - 0x09: System reset due to ECC error
  * @retval None
*/
WEAK_FUNCTION(void aci_blue_initialized_event(uint8_t Reason_Code))
{
 801b284:	b580      	push	{r7, lr}
 801b286:	b082      	sub	sp, #8
 801b288:	af00      	add	r7, sp, #0
 801b28a:	4603      	mov	r3, r0
 801b28c:	71fb      	strb	r3, [r7, #7]
  /* NOTE : This function Should not be modified, when needed,
            the callback could be implemented in the user file
   */
  BLUENRG_PRINTF("aci_blue_initialized_event Reason_Code=%x\r\n",Reason_Code);
 801b28e:	79fb      	ldrb	r3, [r7, #7]
 801b290:	4619      	mov	r1, r3
 801b292:	4803      	ldr	r0, [pc, #12]	@ (801b2a0 <aci_blue_initialized_event+0x1c>)
 801b294:	f008 fd62 	bl	8023d5c <iprintf>
}
 801b298:	bf00      	nop
 801b29a:	3708      	adds	r7, #8
 801b29c:	46bd      	mov	sp, r7
 801b29e:	bd80      	pop	{r7, pc}
 801b2a0:	0802861c 	.word	0x0802861c

0801b2a4 <aci_blue_events_lost_event>:
  - 0x0040000000000000: ACI_GAP_NUMERIC_COMPARISON_VALUE_EVENT
  - 0x0080000000000000: ACI_GAP_KEYPRESS_NOTIFICATION_EVENT
  * @retval None
*/
WEAK_FUNCTION(void aci_blue_events_lost_event(uint8_t Lost_Events[8]))
{
 801b2a4:	b580      	push	{r7, lr}
 801b2a6:	b082      	sub	sp, #8
 801b2a8:	af00      	add	r7, sp, #0
 801b2aa:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when needed,
            the callback could be implemented in the user file
   */
  BLUENRG_PRINTF("aci_blue_events_lost_event\r\n");
 801b2ac:	4803      	ldr	r0, [pc, #12]	@ (801b2bc <aci_blue_events_lost_event+0x18>)
 801b2ae:	f008 fdbd 	bl	8023e2c <puts>
}
 801b2b2:	bf00      	nop
 801b2b4:	3708      	adds	r7, #8
 801b2b6:	46bd      	mov	sp, r7
 801b2b8:	bd80      	pop	{r7, pc}
 801b2ba:	bf00      	nop
 801b2bc:	08028648 	.word	0x08028648

0801b2c0 <aci_blue_crash_info_event>:
                                             uint32_t LR,
                                             uint32_t PC,
                                             uint32_t xPSR,
                                             uint8_t Debug_Data_Length,
                                             uint8_t Debug_Data[]))
{
 801b2c0:	b580      	push	{r7, lr}
 801b2c2:	b084      	sub	sp, #16
 801b2c4:	af00      	add	r7, sp, #0
 801b2c6:	60b9      	str	r1, [r7, #8]
 801b2c8:	607a      	str	r2, [r7, #4]
 801b2ca:	603b      	str	r3, [r7, #0]
 801b2cc:	4603      	mov	r3, r0
 801b2ce:	73fb      	strb	r3, [r7, #15]
  /* NOTE : This function Should not be modified, when needed,
            the callback could be implemented in the user file
   */
  BLUENRG_PRINTF("aci_blue_crash_info_event\r\n");
 801b2d0:	4803      	ldr	r0, [pc, #12]	@ (801b2e0 <aci_blue_crash_info_event+0x20>)
 801b2d2:	f008 fdab 	bl	8023e2c <puts>
}
 801b2d6:	bf00      	nop
 801b2d8:	3710      	adds	r7, #16
 801b2da:	46bd      	mov	sp, r7
 801b2dc:	bd80      	pop	{r7, pc}
 801b2de:	bf00      	nop
 801b2e0:	08028664 	.word	0x08028664

0801b2e4 <aci_hal_end_of_radio_activity_event>:
  * @retval None
*/
WEAK_FUNCTION(void aci_hal_end_of_radio_activity_event(uint8_t Last_State,
                                                       uint8_t Next_State,
                                                       uint32_t Next_State_SysTime))
{
 801b2e4:	b580      	push	{r7, lr}
 801b2e6:	b082      	sub	sp, #8
 801b2e8:	af00      	add	r7, sp, #0
 801b2ea:	4603      	mov	r3, r0
 801b2ec:	603a      	str	r2, [r7, #0]
 801b2ee:	71fb      	strb	r3, [r7, #7]
 801b2f0:	460b      	mov	r3, r1
 801b2f2:	71bb      	strb	r3, [r7, #6]
  /* NOTE : This function Should not be modified, when needed,
            the callback could be implemented in the user file
   */
  BLUENRG_PRINTF("aci_hal_end_of_radio_activity_event\r\n");
 801b2f4:	4803      	ldr	r0, [pc, #12]	@ (801b304 <aci_hal_end_of_radio_activity_event+0x20>)
 801b2f6:	f008 fd99 	bl	8023e2c <puts>
}
 801b2fa:	bf00      	nop
 801b2fc:	3708      	adds	r7, #8
 801b2fe:	46bd      	mov	sp, r7
 801b300:	bd80      	pop	{r7, pc}
 801b302:	bf00      	nop
 801b304:	08028680 	.word	0x08028680

0801b308 <aci_hal_scan_req_report_event>:
  * @retval None
*/
WEAK_FUNCTION(void aci_hal_scan_req_report_event(int8_t RSSI,
                                                 uint8_t Peer_Address_Type,
                                                 uint8_t Peer_Address[6]))
{
 801b308:	b580      	push	{r7, lr}
 801b30a:	b082      	sub	sp, #8
 801b30c:	af00      	add	r7, sp, #0
 801b30e:	4603      	mov	r3, r0
 801b310:	603a      	str	r2, [r7, #0]
 801b312:	71fb      	strb	r3, [r7, #7]
 801b314:	460b      	mov	r3, r1
 801b316:	71bb      	strb	r3, [r7, #6]
  /* NOTE : This function Should not be modified, when needed,
            the callback could be implemented in the user file
   */
  BLUENRG_PRINTF("aci_hal_scan_req_report_event\r\n");
 801b318:	4803      	ldr	r0, [pc, #12]	@ (801b328 <aci_hal_scan_req_report_event+0x20>)
 801b31a:	f008 fd87 	bl	8023e2c <puts>
}
 801b31e:	bf00      	nop
 801b320:	3708      	adds	r7, #8
 801b322:	46bd      	mov	sp, r7
 801b324:	bd80      	pop	{r7, pc}
 801b326:	bf00      	nop
 801b328:	080286a8 	.word	0x080286a8

0801b32c <aci_hal_fw_error_event>:
  * @retval None
*/
WEAK_FUNCTION(void aci_hal_fw_error_event(uint8_t FW_Error_Type,
                                          uint8_t Data_Length,
                                          uint8_t Data[]))
{
 801b32c:	b580      	push	{r7, lr}
 801b32e:	b082      	sub	sp, #8
 801b330:	af00      	add	r7, sp, #0
 801b332:	4603      	mov	r3, r0
 801b334:	603a      	str	r2, [r7, #0]
 801b336:	71fb      	strb	r3, [r7, #7]
 801b338:	460b      	mov	r3, r1
 801b33a:	71bb      	strb	r3, [r7, #6]
  /* NOTE : This function Should not be modified, when needed,
            the callback could be implemented in the user file
   */
  BLUENRG_PRINTF("aci_hal_fw_error_event\r\n");
 801b33c:	4803      	ldr	r0, [pc, #12]	@ (801b34c <aci_hal_fw_error_event+0x20>)
 801b33e:	f008 fd75 	bl	8023e2c <puts>
}
 801b342:	bf00      	nop
 801b344:	3708      	adds	r7, #8
 801b346:	46bd      	mov	sp, r7
 801b348:	bd80      	pop	{r7, pc}
 801b34a:	bf00      	nop
 801b34c:	080286c8 	.word	0x080286c8

0801b350 <aci_hal_le_test_end_event>:
 *        specified with aci_hal_transmitter_test_packets() has been reached.
 * @param Number_Of_Packets The number of test packets actually transmitted.
 * @retval None
 */
WEAK_FUNCTION(void aci_hal_le_test_end_event(uint16_t Number_Of_Packets))
{
 801b350:	b580      	push	{r7, lr}
 801b352:	b082      	sub	sp, #8
 801b354:	af00      	add	r7, sp, #0
 801b356:	4603      	mov	r3, r0
 801b358:	80fb      	strh	r3, [r7, #6]
  /* NOTE : This function Should not be modified, when needed,
            the callback could be implemented in the user file
   */
  BLUENRG_PRINTF("aci_hal_le_test_end_event\r\n");
 801b35a:	4803      	ldr	r0, [pc, #12]	@ (801b368 <aci_hal_le_test_end_event+0x18>)
 801b35c:	f008 fd66 	bl	8023e2c <puts>
}
 801b360:	bf00      	nop
 801b362:	3708      	adds	r7, #8
 801b364:	46bd      	mov	sp, r7
 801b366:	bd80      	pop	{r7, pc}
 801b368:	080286e0 	.word	0x080286e0

0801b36c <aci_l2cap_cfc_connection_event>:
                                                  uint16_t CID,
                                                  uint16_t Remote_CID,
                                                  uint16_t Peer_MTU,
                                                  uint16_t Peer_MPS,
                                                  uint16_t Initial_Credits))
{
 801b36c:	b590      	push	{r4, r7, lr}
 801b36e:	b083      	sub	sp, #12
 801b370:	af00      	add	r7, sp, #0
 801b372:	4604      	mov	r4, r0
 801b374:	4608      	mov	r0, r1
 801b376:	4611      	mov	r1, r2
 801b378:	461a      	mov	r2, r3
 801b37a:	4623      	mov	r3, r4
 801b37c:	80fb      	strh	r3, [r7, #6]
 801b37e:	4603      	mov	r3, r0
 801b380:	717b      	strb	r3, [r7, #5]
 801b382:	460b      	mov	r3, r1
 801b384:	807b      	strh	r3, [r7, #2]
 801b386:	4613      	mov	r3, r2
 801b388:	713b      	strb	r3, [r7, #4]
  /* NOTE : This function Should not be modified, when needed,
            the callback could be implemented in the user file
   */
  BLUENRG_PRINTF("aci_l2cap_cfc_connection_event\r\n");
 801b38a:	4803      	ldr	r0, [pc, #12]	@ (801b398 <aci_l2cap_cfc_connection_event+0x2c>)
 801b38c:	f008 fd4e 	bl	8023e2c <puts>
}
 801b390:	bf00      	nop
 801b392:	370c      	adds	r7, #12
 801b394:	46bd      	mov	sp, r7
 801b396:	bd90      	pop	{r4, r7, pc}
 801b398:	080286fc 	.word	0x080286fc

0801b39c <aci_l2cap_disconnection_complete_event>:
 * @param CID The local channel endpoint that identifies the L2CAP channel.
 * @retval None
 */
WEAK_FUNCTION(void aci_l2cap_disconnection_complete_event(uint16_t Connection_Handle,
                                                          uint16_t CID))
{
 801b39c:	b580      	push	{r7, lr}
 801b39e:	b082      	sub	sp, #8
 801b3a0:	af00      	add	r7, sp, #0
 801b3a2:	4603      	mov	r3, r0
 801b3a4:	460a      	mov	r2, r1
 801b3a6:	80fb      	strh	r3, [r7, #6]
 801b3a8:	4613      	mov	r3, r2
 801b3aa:	80bb      	strh	r3, [r7, #4]
  /* NOTE : This function Should not be modified, when needed,
            the callback could be implemented in the user file
   */
  BLUENRG_PRINTF("aci_l2cap_disconnection_complete_event\r\n");
 801b3ac:	4803      	ldr	r0, [pc, #12]	@ (801b3bc <aci_l2cap_disconnection_complete_event+0x20>)
 801b3ae:	f008 fd3d 	bl	8023e2c <puts>
}
 801b3b2:	bf00      	nop
 801b3b4:	3708      	adds	r7, #8
 801b3b6:	46bd      	mov	sp, r7
 801b3b8:	bd80      	pop	{r7, pc}
 801b3ba:	bf00      	nop
 801b3bc:	0802871c 	.word	0x0802871c

0801b3c0 <aci_l2cap_flow_control_credit_event>:
 */
WEAK_FUNCTION(void aci_l2cap_flow_control_credit_event(uint16_t Connection_Handle,
                                                       uint16_t CID,
                                                       uint16_t TX_Credits,
                                                       uint16_t TX_Credit_Balance))
{
 801b3c0:	b590      	push	{r4, r7, lr}
 801b3c2:	b083      	sub	sp, #12
 801b3c4:	af00      	add	r7, sp, #0
 801b3c6:	4604      	mov	r4, r0
 801b3c8:	4608      	mov	r0, r1
 801b3ca:	4611      	mov	r1, r2
 801b3cc:	461a      	mov	r2, r3
 801b3ce:	4623      	mov	r3, r4
 801b3d0:	80fb      	strh	r3, [r7, #6]
 801b3d2:	4603      	mov	r3, r0
 801b3d4:	80bb      	strh	r3, [r7, #4]
 801b3d6:	460b      	mov	r3, r1
 801b3d8:	807b      	strh	r3, [r7, #2]
 801b3da:	4613      	mov	r3, r2
 801b3dc:	803b      	strh	r3, [r7, #0]
  /* NOTE : This function Should not be modified, when needed,
            the callback could be implemented in the user file
   */
  BLUENRG_PRINTF("aci_l2cap_flow_control_credit_event\r\n");
 801b3de:	4803      	ldr	r0, [pc, #12]	@ (801b3ec <aci_l2cap_flow_control_credit_event+0x2c>)
 801b3e0:	f008 fd24 	bl	8023e2c <puts>
}
 801b3e4:	bf00      	nop
 801b3e6:	370c      	adds	r7, #12
 801b3e8:	46bd      	mov	sp, r7
 801b3ea:	bd90      	pop	{r4, r7, pc}
 801b3ec:	08028744 	.word	0x08028744

0801b3f0 <aci_l2cap_sdu_data_tx_nwk_event>:
 */
WEAK_FUNCTION(void aci_l2cap_sdu_data_tx_nwk_event(uint16_t Connection_Handle,
                                                  uint16_t CID,
                                                  uint16_t SDU_Length,
                                                  uint16_t TX_Credit_Balance))
{
 801b3f0:	b590      	push	{r4, r7, lr}
 801b3f2:	b083      	sub	sp, #12
 801b3f4:	af00      	add	r7, sp, #0
 801b3f6:	4604      	mov	r4, r0
 801b3f8:	4608      	mov	r0, r1
 801b3fa:	4611      	mov	r1, r2
 801b3fc:	461a      	mov	r2, r3
 801b3fe:	4623      	mov	r3, r4
 801b400:	80fb      	strh	r3, [r7, #6]
 801b402:	4603      	mov	r3, r0
 801b404:	80bb      	strh	r3, [r7, #4]
 801b406:	460b      	mov	r3, r1
 801b408:	807b      	strh	r3, [r7, #2]
 801b40a:	4613      	mov	r3, r2
 801b40c:	803b      	strh	r3, [r7, #0]
  /* NOTE : This function Should not be modified, when needed,
            the callback could be implemented in the user file
   */
  BLUENRG_PRINTF("aci_l2cap_sdu_data_tx_nwk_event\r\n");
 801b40e:	4803      	ldr	r0, [pc, #12]	@ (801b41c <aci_l2cap_sdu_data_tx_nwk_event+0x2c>)
 801b410:	f008 fd0c 	bl	8023e2c <puts>
}
 801b414:	bf00      	nop
 801b416:	370c      	adds	r7, #12
 801b418:	46bd      	mov	sp, r7
 801b41a:	bd90      	pop	{r4, r7, pc}
 801b41c:	0802876c 	.word	0x0802876c

0801b420 <aci_l2cap_sdu_data_rx_nwk_event>:
WEAK_FUNCTION(void aci_l2cap_sdu_data_rx_nwk_event(uint16_t Connection_Handle,
                                                   uint16_t CID,
                                                   uint16_t RX_Credit_Balance,
                                                   uint16_t SDU_Length,
                                                   uint8_t SDU_Data[]))
{
 801b420:	b590      	push	{r4, r7, lr}
 801b422:	b083      	sub	sp, #12
 801b424:	af00      	add	r7, sp, #0
 801b426:	4604      	mov	r4, r0
 801b428:	4608      	mov	r0, r1
 801b42a:	4611      	mov	r1, r2
 801b42c:	461a      	mov	r2, r3
 801b42e:	4623      	mov	r3, r4
 801b430:	80fb      	strh	r3, [r7, #6]
 801b432:	4603      	mov	r3, r0
 801b434:	80bb      	strh	r3, [r7, #4]
 801b436:	460b      	mov	r3, r1
 801b438:	807b      	strh	r3, [r7, #2]
 801b43a:	4613      	mov	r3, r2
 801b43c:	803b      	strh	r3, [r7, #0]
  /* NOTE : This function Should not be modified, when needed,
            the callback could be implemented in the user file
   */
  BLUENRG_PRINTF("aci_l2cap_sdu_data_rx_nwk_event\r\n");
 801b43e:	4803      	ldr	r0, [pc, #12]	@ (801b44c <aci_l2cap_sdu_data_rx_nwk_event+0x2c>)
 801b440:	f008 fcf4 	bl	8023e2c <puts>
}
 801b444:	bf00      	nop
 801b446:	370c      	adds	r7, #12
 801b448:	46bd      	mov	sp, r7
 801b44a:	bd90      	pop	{r4, r7, pc}
 801b44c:	08028790 	.word	0x08028790

0801b450 <aci_att_clt_find_info_resp_event>:
 */
WEAK_FUNCTION(void aci_att_clt_find_info_resp_event(uint16_t Connection_Handle,
                                                    uint8_t Format,
                                                    uint16_t Event_Data_Length,
                                                    uint8_t Handle_UUID_Pair[]))
{
 801b450:	b580      	push	{r7, lr}
 801b452:	b084      	sub	sp, #16
 801b454:	af00      	add	r7, sp, #0
 801b456:	607b      	str	r3, [r7, #4]
 801b458:	4603      	mov	r3, r0
 801b45a:	81fb      	strh	r3, [r7, #14]
 801b45c:	460b      	mov	r3, r1
 801b45e:	737b      	strb	r3, [r7, #13]
 801b460:	4613      	mov	r3, r2
 801b462:	817b      	strh	r3, [r7, #10]
  /* NOTE : This function Should not be modified, when needed,
            the callback could be implemented in the user file
   */
  BLUENRG_PRINTF("aci_att_clt_find_info_resp_event\r\n");
 801b464:	4803      	ldr	r0, [pc, #12]	@ (801b474 <aci_att_clt_find_info_resp_event+0x24>)
 801b466:	f008 fce1 	bl	8023e2c <puts>
}
 801b46a:	bf00      	nop
 801b46c:	3710      	adds	r7, #16
 801b46e:	46bd      	mov	sp, r7
 801b470:	bd80      	pop	{r7, pc}
 801b472:	bf00      	nop
 801b474:	080287dc 	.word	0x080287dc

0801b478 <aci_att_clt_find_by_type_value_resp_event>:
 * @retval None
 */
WEAK_FUNCTION(void aci_att_clt_find_by_type_value_resp_event(uint16_t Connection_Handle,
                                                             uint8_t Num_of_Handle_Pair,
                                                             Attribute_Group_Handle_Pair_t* Attribute_Group_Handle_Pair))
{
 801b478:	b580      	push	{r7, lr}
 801b47a:	b082      	sub	sp, #8
 801b47c:	af00      	add	r7, sp, #0
 801b47e:	4603      	mov	r3, r0
 801b480:	603a      	str	r2, [r7, #0]
 801b482:	80fb      	strh	r3, [r7, #6]
 801b484:	460b      	mov	r3, r1
 801b486:	717b      	strb	r3, [r7, #5]
  /* NOTE : This function Should not be modified, when needed,
            the callback could be implemented in the user file
   */
  BLUENRG_PRINTF("aci_att_clt_find_by_type_value_resp_event\r\n");
 801b488:	4803      	ldr	r0, [pc, #12]	@ (801b498 <aci_att_clt_find_by_type_value_resp_event+0x20>)
 801b48a:	f008 fccf 	bl	8023e2c <puts>
}
 801b48e:	bf00      	nop
 801b490:	3708      	adds	r7, #8
 801b492:	46bd      	mov	sp, r7
 801b494:	bd80      	pop	{r7, pc}
 801b496:	bf00      	nop
 801b498:	08028800 	.word	0x08028800

0801b49c <aci_att_clt_read_by_type_resp_event>:
 */
WEAK_FUNCTION(void aci_att_clt_read_by_type_resp_event(uint16_t Connection_Handle,
                                                       uint8_t Handle_Value_Pair_Length,
                                                       uint16_t Data_Length,
                                                       uint8_t Handle_Value_Pair_Data[]))
{
 801b49c:	b580      	push	{r7, lr}
 801b49e:	b084      	sub	sp, #16
 801b4a0:	af00      	add	r7, sp, #0
 801b4a2:	607b      	str	r3, [r7, #4]
 801b4a4:	4603      	mov	r3, r0
 801b4a6:	81fb      	strh	r3, [r7, #14]
 801b4a8:	460b      	mov	r3, r1
 801b4aa:	737b      	strb	r3, [r7, #13]
 801b4ac:	4613      	mov	r3, r2
 801b4ae:	817b      	strh	r3, [r7, #10]
  /* NOTE : This function Should not be modified, when needed,
            the callback could be implemented in the user file
   */
  BLUENRG_PRINTF("aci_att_clt_read_by_type_resp_event\r\n");
 801b4b0:	4803      	ldr	r0, [pc, #12]	@ (801b4c0 <aci_att_clt_read_by_type_resp_event+0x24>)
 801b4b2:	f008 fcbb 	bl	8023e2c <puts>
}
 801b4b6:	bf00      	nop
 801b4b8:	3710      	adds	r7, #16
 801b4ba:	46bd      	mov	sp, r7
 801b4bc:	bd80      	pop	{r7, pc}
 801b4be:	bf00      	nop
 801b4c0:	0802882c 	.word	0x0802882c

0801b4c4 <aci_att_clt_read_resp_event>:
 * @retval None
 */
WEAK_FUNCTION(void aci_att_clt_read_resp_event(uint16_t Connection_Handle,
                                               uint16_t Event_Data_Length,
                                               uint8_t Attribute_Value[]))
{
 801b4c4:	b580      	push	{r7, lr}
 801b4c6:	b082      	sub	sp, #8
 801b4c8:	af00      	add	r7, sp, #0
 801b4ca:	4603      	mov	r3, r0
 801b4cc:	603a      	str	r2, [r7, #0]
 801b4ce:	80fb      	strh	r3, [r7, #6]
 801b4d0:	460b      	mov	r3, r1
 801b4d2:	80bb      	strh	r3, [r7, #4]
  /* NOTE : This function Should not be modified, when needed,
            the callback could be implemented in the user file
   */
  BLUENRG_PRINTF("aci_att_clt_read_resp_event\r\n");
 801b4d4:	4803      	ldr	r0, [pc, #12]	@ (801b4e4 <aci_att_clt_read_resp_event+0x20>)
 801b4d6:	f008 fca9 	bl	8023e2c <puts>
}
 801b4da:	bf00      	nop
 801b4dc:	3708      	adds	r7, #8
 801b4de:	46bd      	mov	sp, r7
 801b4e0:	bd80      	pop	{r7, pc}
 801b4e2:	bf00      	nop
 801b4e4:	08028854 	.word	0x08028854

0801b4e8 <aci_att_clt_read_blob_resp_event>:
 * @retval None
 */
WEAK_FUNCTION(void aci_att_clt_read_blob_resp_event(uint16_t Connection_Handle,
                                                    uint16_t Event_Data_Length,
                                                    uint8_t Attribute_Value[]))
{
 801b4e8:	b580      	push	{r7, lr}
 801b4ea:	b082      	sub	sp, #8
 801b4ec:	af00      	add	r7, sp, #0
 801b4ee:	4603      	mov	r3, r0
 801b4f0:	603a      	str	r2, [r7, #0]
 801b4f2:	80fb      	strh	r3, [r7, #6]
 801b4f4:	460b      	mov	r3, r1
 801b4f6:	80bb      	strh	r3, [r7, #4]
  /* NOTE : This function Should not be modified, when needed,
            the callback could be implemented in the user file
   */
  BLUENRG_PRINTF("aci_att_clt_read_blob_resp_event\r\n");
 801b4f8:	4803      	ldr	r0, [pc, #12]	@ (801b508 <aci_att_clt_read_blob_resp_event+0x20>)
 801b4fa:	f008 fc97 	bl	8023e2c <puts>
}
 801b4fe:	bf00      	nop
 801b500:	3708      	adds	r7, #8
 801b502:	46bd      	mov	sp, r7
 801b504:	bd80      	pop	{r7, pc}
 801b506:	bf00      	nop
 801b508:	08028874 	.word	0x08028874

0801b50c <aci_att_clt_read_multiple_resp_event>:
 * @retval None
 */
WEAK_FUNCTION(void aci_att_clt_read_multiple_resp_event(uint16_t Connection_Handle,
                                                        uint16_t Event_Data_Length,
                                                        uint8_t Set_Of_Values[]))
{
 801b50c:	b580      	push	{r7, lr}
 801b50e:	b082      	sub	sp, #8
 801b510:	af00      	add	r7, sp, #0
 801b512:	4603      	mov	r3, r0
 801b514:	603a      	str	r2, [r7, #0]
 801b516:	80fb      	strh	r3, [r7, #6]
 801b518:	460b      	mov	r3, r1
 801b51a:	80bb      	strh	r3, [r7, #4]
  /* NOTE : This function Should not be modified, when needed,
            the callback could be implemented in the user file
   */
  BLUENRG_PRINTF("aci_att_clt_read_multiple_resp_event\r\n");
 801b51c:	4803      	ldr	r0, [pc, #12]	@ (801b52c <aci_att_clt_read_multiple_resp_event+0x20>)
 801b51e:	f008 fc85 	bl	8023e2c <puts>
}
 801b522:	bf00      	nop
 801b524:	3708      	adds	r7, #8
 801b526:	46bd      	mov	sp, r7
 801b528:	bd80      	pop	{r7, pc}
 801b52a:	bf00      	nop
 801b52c:	08028898 	.word	0x08028898

0801b530 <aci_att_clt_read_by_group_type_resp_event>:
 */
WEAK_FUNCTION(void aci_att_clt_read_by_group_type_resp_event(uint16_t Connection_Handle,
                                                             uint8_t Attribute_Data_Length,
                                                             uint16_t Data_Length,
                                                             uint8_t Attribute_Data_List[]))
{
 801b530:	b580      	push	{r7, lr}
 801b532:	b084      	sub	sp, #16
 801b534:	af00      	add	r7, sp, #0
 801b536:	607b      	str	r3, [r7, #4]
 801b538:	4603      	mov	r3, r0
 801b53a:	81fb      	strh	r3, [r7, #14]
 801b53c:	460b      	mov	r3, r1
 801b53e:	737b      	strb	r3, [r7, #13]
 801b540:	4613      	mov	r3, r2
 801b542:	817b      	strh	r3, [r7, #10]
  /* NOTE : This function Should not be modified, when needed,
            the callback could be implemented in the user file
   */
  BLUENRG_PRINTF("aci_att_clt_read_by_group_type_resp_event\r\n");
 801b544:	4803      	ldr	r0, [pc, #12]	@ (801b554 <aci_att_clt_read_by_group_type_resp_event+0x24>)
 801b546:	f008 fc71 	bl	8023e2c <puts>
}
 801b54a:	bf00      	nop
 801b54c:	3710      	adds	r7, #16
 801b54e:	46bd      	mov	sp, r7
 801b550:	bd80      	pop	{r7, pc}
 801b552:	bf00      	nop
 801b554:	080288c0 	.word	0x080288c0

0801b558 <aci_att_clt_prepare_write_resp_event>:
WEAK_FUNCTION(void aci_att_clt_prepare_write_resp_event(uint16_t Connection_Handle,
                                                        uint16_t Attribute_Handle,
                                                        uint16_t Offset,
                                                        uint16_t Part_Attribute_Value_Length,
                                                        uint8_t Part_Attribute_Value[]))
{
 801b558:	b590      	push	{r4, r7, lr}
 801b55a:	b083      	sub	sp, #12
 801b55c:	af00      	add	r7, sp, #0
 801b55e:	4604      	mov	r4, r0
 801b560:	4608      	mov	r0, r1
 801b562:	4611      	mov	r1, r2
 801b564:	461a      	mov	r2, r3
 801b566:	4623      	mov	r3, r4
 801b568:	80fb      	strh	r3, [r7, #6]
 801b56a:	4603      	mov	r3, r0
 801b56c:	80bb      	strh	r3, [r7, #4]
 801b56e:	460b      	mov	r3, r1
 801b570:	807b      	strh	r3, [r7, #2]
 801b572:	4613      	mov	r3, r2
 801b574:	803b      	strh	r3, [r7, #0]
  /* NOTE : This function Should not be modified, when needed,
            the callback could be implemented in the user file
   */
  BLUENRG_PRINTF("aci_att_clt_prepare_write_resp_event\r\n");
 801b576:	4803      	ldr	r0, [pc, #12]	@ (801b584 <aci_att_clt_prepare_write_resp_event+0x2c>)
 801b578:	f008 fc58 	bl	8023e2c <puts>
}
 801b57c:	bf00      	nop
 801b57e:	370c      	adds	r7, #12
 801b580:	46bd      	mov	sp, r7
 801b582:	bd90      	pop	{r4, r7, pc}
 801b584:	080288ec 	.word	0x080288ec

0801b588 <aci_att_clt_exec_write_resp_event>:
 *        aci_gatt_clt_write_long().
 * @param Connection_Handle Connection handle related to the response
 * @retval None
 */
WEAK_FUNCTION(void aci_att_clt_exec_write_resp_event(uint16_t Connection_Handle))
{
 801b588:	b580      	push	{r7, lr}
 801b58a:	b082      	sub	sp, #8
 801b58c:	af00      	add	r7, sp, #0
 801b58e:	4603      	mov	r3, r0
 801b590:	80fb      	strh	r3, [r7, #6]
  /* NOTE : This function Should not be modified, when needed,
            the callback could be implemented in the user file
   */
  BLUENRG_PRINTF("aci_att_clt_exec_write_resp_event\r\n");
 801b592:	4803      	ldr	r0, [pc, #12]	@ (801b5a0 <aci_att_clt_exec_write_resp_event+0x18>)
 801b594:	f008 fc4a 	bl	8023e2c <puts>
}
 801b598:	bf00      	nop
 801b59a:	3708      	adds	r7, #8
 801b59c:	46bd      	mov	sp, r7
 801b59e:	bd80      	pop	{r7, pc}
 801b5a0:	08028914 	.word	0x08028914

0801b5a4 <aci_gatt_clt_notification_event>:
 */
WEAK_FUNCTION(void aci_gatt_clt_notification_event(uint16_t Connection_Handle,
                                                   uint16_t Attribute_Handle,
                                                   uint16_t Attribute_Value_Length,
                                                   uint8_t Attribute_Value[]))
{
 801b5a4:	b580      	push	{r7, lr}
 801b5a6:	b084      	sub	sp, #16
 801b5a8:	af00      	add	r7, sp, #0
 801b5aa:	607b      	str	r3, [r7, #4]
 801b5ac:	4603      	mov	r3, r0
 801b5ae:	81fb      	strh	r3, [r7, #14]
 801b5b0:	460b      	mov	r3, r1
 801b5b2:	81bb      	strh	r3, [r7, #12]
 801b5b4:	4613      	mov	r3, r2
 801b5b6:	817b      	strh	r3, [r7, #10]
  /* NOTE : This function Should not be modified, when needed,
            the callback could be implemented in the user file
   */
  BLUENRG_PRINTF("aci_gatt_clt_notification_event\r\n");
 801b5b8:	4803      	ldr	r0, [pc, #12]	@ (801b5c8 <aci_gatt_clt_notification_event+0x24>)
 801b5ba:	f008 fc37 	bl	8023e2c <puts>
}
 801b5be:	bf00      	nop
 801b5c0:	3710      	adds	r7, #16
 801b5c2:	46bd      	mov	sp, r7
 801b5c4:	bd80      	pop	{r7, pc}
 801b5c6:	bf00      	nop
 801b5c8:	08028958 	.word	0x08028958

0801b5cc <aci_gatt_clt_error_resp_event>:
 */
WEAK_FUNCTION(void aci_gatt_clt_error_resp_event(uint16_t Connection_Handle,
                                                 uint8_t Req_Opcode,
                                                 uint16_t Attribute_Handle,
                                                 uint8_t Error_Code))
{
 801b5cc:	b590      	push	{r4, r7, lr}
 801b5ce:	b083      	sub	sp, #12
 801b5d0:	af00      	add	r7, sp, #0
 801b5d2:	4604      	mov	r4, r0
 801b5d4:	4608      	mov	r0, r1
 801b5d6:	4611      	mov	r1, r2
 801b5d8:	461a      	mov	r2, r3
 801b5da:	4623      	mov	r3, r4
 801b5dc:	80fb      	strh	r3, [r7, #6]
 801b5de:	4603      	mov	r3, r0
 801b5e0:	717b      	strb	r3, [r7, #5]
 801b5e2:	460b      	mov	r3, r1
 801b5e4:	807b      	strh	r3, [r7, #2]
 801b5e6:	4613      	mov	r3, r2
 801b5e8:	713b      	strb	r3, [r7, #4]
  /* NOTE : This function Should not be modified, when needed,
            the callback could be implemented in the user file
   */
  BLUENRG_PRINTF("aci_gatt_clt_error_resp_event\r\n");
 801b5ea:	4803      	ldr	r0, [pc, #12]	@ (801b5f8 <aci_gatt_clt_error_resp_event+0x2c>)
 801b5ec:	f008 fc1e 	bl	8023e2c <puts>
}
 801b5f0:	bf00      	nop
 801b5f2:	370c      	adds	r7, #12
 801b5f4:	46bd      	mov	sp, r7
 801b5f6:	bd90      	pop	{r4, r7, pc}
 801b5f8:	080289a0 	.word	0x080289a0

0801b5fc <aci_gatt_clt_disc_read_char_by_uuid_resp_event>:
 */
WEAK_FUNCTION(void aci_gatt_clt_disc_read_char_by_uuid_resp_event(uint16_t Connection_Handle,
                                                                  uint16_t Attribute_Handle,
                                                                  uint8_t Attribute_Value_Length,
                                                                  uint8_t Attribute_Value[]))
{
 801b5fc:	b580      	push	{r7, lr}
 801b5fe:	b084      	sub	sp, #16
 801b600:	af00      	add	r7, sp, #0
 801b602:	607b      	str	r3, [r7, #4]
 801b604:	4603      	mov	r3, r0
 801b606:	81fb      	strh	r3, [r7, #14]
 801b608:	460b      	mov	r3, r1
 801b60a:	81bb      	strh	r3, [r7, #12]
 801b60c:	4613      	mov	r3, r2
 801b60e:	72fb      	strb	r3, [r7, #11]
  /* NOTE : This function Should not be modified, when needed,
            the callback could be implemented in the user file
   */
  BLUENRG_PRINTF("aci_gatt_clt_disc_read_char_by_uuid_resp_event\r\n");
 801b610:	4803      	ldr	r0, [pc, #12]	@ (801b620 <aci_gatt_clt_disc_read_char_by_uuid_resp_event+0x24>)
 801b612:	f008 fc0b 	bl	8023e2c <puts>
}
 801b616:	bf00      	nop
 801b618:	3710      	adds	r7, #16
 801b61a:	46bd      	mov	sp, r7
 801b61c:	bd80      	pop	{r7, pc}
 801b61e:	bf00      	nop
 801b620:	080289c0 	.word	0x080289c0

0801b624 <aci_gatt_srv_confirmation_event>:
 *        previously sent indication.
 * @param Connection_Handle Connection handle related to the event.
 * @retval None
 */
WEAK_FUNCTION(void aci_gatt_srv_confirmation_event(uint16_t Connection_Handle))
{
 801b624:	b580      	push	{r7, lr}
 801b626:	b082      	sub	sp, #8
 801b628:	af00      	add	r7, sp, #0
 801b62a:	4603      	mov	r3, r0
 801b62c:	80fb      	strh	r3, [r7, #6]
  /* NOTE : This function Should not be modified, when needed,
            the callback could be implemented in the user file
   */
  BLUENRG_PRINTF("aci_gatt_srv_confirmation_event\r\n");
 801b62e:	4803      	ldr	r0, [pc, #12]	@ (801b63c <aci_gatt_srv_confirmation_event+0x18>)
 801b630:	f008 fbfc 	bl	8023e2c <puts>
}
 801b634:	bf00      	nop
 801b636:	3708      	adds	r7, #8
 801b638:	46bd      	mov	sp, r7
 801b63a:	bd80      	pop	{r7, pc}
 801b63c:	080289f0 	.word	0x080289f0

0801b640 <aci_att_srv_exec_write_req_event>:
 *        - 0x01: EXECUTE
 * @retval None
 */
WEAK_FUNCTION(void aci_att_srv_exec_write_req_event(uint16_t Connection_Handle,
                                                    uint8_t Flags))
{
 801b640:	b580      	push	{r7, lr}
 801b642:	b082      	sub	sp, #8
 801b644:	af00      	add	r7, sp, #0
 801b646:	4603      	mov	r3, r0
 801b648:	460a      	mov	r2, r1
 801b64a:	80fb      	strh	r3, [r7, #6]
 801b64c:	4613      	mov	r3, r2
 801b64e:	717b      	strb	r3, [r7, #5]
  /* NOTE : This function Should not be modified, when needed,
            the callback could be implemented in the user file
   */
  BLUENRG_PRINTF("aci_att_srv_exec_write_req_event\r\n");
 801b650:	4803      	ldr	r0, [pc, #12]	@ (801b660 <aci_att_srv_exec_write_req_event+0x20>)
 801b652:	f008 fbeb 	bl	8023e2c <puts>
}
 801b656:	bf00      	nop
 801b658:	3708      	adds	r7, #8
 801b65a:	46bd      	mov	sp, r7
 801b65c:	bd80      	pop	{r7, pc}
 801b65e:	bf00      	nop
 801b660:	08028a14 	.word	0x08028a14

0801b664 <hci_le_extended_advertising_report_event>:
 * @param Extended_Advertising_Report See @ref Extended_Advertising_Report_t
 * @retval None
 */
WEAK_FUNCTION(void hci_le_extended_advertising_report_event(uint8_t Num_Reports,
                                                            Extended_Advertising_Report_t Extended_Advertising_Report[]))
{
 801b664:	b580      	push	{r7, lr}
 801b666:	b082      	sub	sp, #8
 801b668:	af00      	add	r7, sp, #0
 801b66a:	4603      	mov	r3, r0
 801b66c:	6039      	str	r1, [r7, #0]
 801b66e:	71fb      	strb	r3, [r7, #7]
  /* NOTE : This function Should not be modified, when needed,
            the callback could be implemented in the user file
   */
  BLUENRG_PRINTF("hci_le_extended_advertising_report_event\r\n");
 801b670:	4803      	ldr	r0, [pc, #12]	@ (801b680 <hci_le_extended_advertising_report_event+0x1c>)
 801b672:	f008 fbdb 	bl	8023e2c <puts>
}
 801b676:	bf00      	nop
 801b678:	3708      	adds	r7, #8
 801b67a:	46bd      	mov	sp, r7
 801b67c:	bd80      	pop	{r7, pc}
 801b67e:	bf00      	nop
 801b680:	08028a80 	.word	0x08028a80

0801b684 <hci_le_periodic_advertising_sync_established_event>:
                                                                      uint8_t Advertiser_Address_Type,
                                                                      uint8_t Advertiser_Address[6],
                                                                      uint8_t Advertiser_PHY,
                                                                      uint16_t Periodic_Advertising_Interval,
                                                                      uint8_t Advertiser_Clock_Accuracy))
{
 801b684:	b590      	push	{r4, r7, lr}
 801b686:	b083      	sub	sp, #12
 801b688:	af00      	add	r7, sp, #0
 801b68a:	4604      	mov	r4, r0
 801b68c:	4608      	mov	r0, r1
 801b68e:	4611      	mov	r1, r2
 801b690:	461a      	mov	r2, r3
 801b692:	4623      	mov	r3, r4
 801b694:	71fb      	strb	r3, [r7, #7]
 801b696:	4603      	mov	r3, r0
 801b698:	80bb      	strh	r3, [r7, #4]
 801b69a:	460b      	mov	r3, r1
 801b69c:	71bb      	strb	r3, [r7, #6]
 801b69e:	4613      	mov	r3, r2
 801b6a0:	70fb      	strb	r3, [r7, #3]
  /* NOTE : This function Should not be modified, when needed,
            the callback could be implemented in the user file
   */
  BLUENRG_PRINTF("hci_le_periodic_advertising_sync_established_event\r\n");
 801b6a2:	4803      	ldr	r0, [pc, #12]	@ (801b6b0 <hci_le_periodic_advertising_sync_established_event+0x2c>)
 801b6a4:	f008 fbc2 	bl	8023e2c <puts>
}
 801b6a8:	bf00      	nop
 801b6aa:	370c      	adds	r7, #12
 801b6ac:	46bd      	mov	sp, r7
 801b6ae:	bd90      	pop	{r4, r7, pc}
 801b6b0:	08028aac 	.word	0x08028aac

0801b6b4 <hci_le_periodic_advertising_report_event>:
                                                            int8_t RSSI,
                                                            uint8_t CTE_Type,
                                                            uint8_t Data_Status,
                                                            uint8_t Data_Length,
                                                            uint8_t Data[]))
{
 801b6b4:	b590      	push	{r4, r7, lr}
 801b6b6:	b083      	sub	sp, #12
 801b6b8:	af00      	add	r7, sp, #0
 801b6ba:	4604      	mov	r4, r0
 801b6bc:	4608      	mov	r0, r1
 801b6be:	4611      	mov	r1, r2
 801b6c0:	461a      	mov	r2, r3
 801b6c2:	4623      	mov	r3, r4
 801b6c4:	80fb      	strh	r3, [r7, #6]
 801b6c6:	4603      	mov	r3, r0
 801b6c8:	717b      	strb	r3, [r7, #5]
 801b6ca:	460b      	mov	r3, r1
 801b6cc:	713b      	strb	r3, [r7, #4]
 801b6ce:	4613      	mov	r3, r2
 801b6d0:	70fb      	strb	r3, [r7, #3]
  /* NOTE : This function Should not be modified, when needed,
            the callback could be implemented in the user file
   */
  BLUENRG_PRINTF("hci_le_periodic_advertising_report_event\r\n");
 801b6d2:	4803      	ldr	r0, [pc, #12]	@ (801b6e0 <hci_le_periodic_advertising_report_event+0x2c>)
 801b6d4:	f008 fbaa 	bl	8023e2c <puts>
}
 801b6d8:	bf00      	nop
 801b6da:	370c      	adds	r7, #12
 801b6dc:	46bd      	mov	sp, r7
 801b6de:	bd90      	pop	{r4, r7, pc}
 801b6e0:	08028ae0 	.word	0x08028ae0

0801b6e4 <hci_le_periodic_advertising_sync_lost_event>:
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @retval None
 */
WEAK_FUNCTION(void hci_le_periodic_advertising_sync_lost_event(uint16_t Sync_Handle))
{
 801b6e4:	b580      	push	{r7, lr}
 801b6e6:	b082      	sub	sp, #8
 801b6e8:	af00      	add	r7, sp, #0
 801b6ea:	4603      	mov	r3, r0
 801b6ec:	80fb      	strh	r3, [r7, #6]
  /* NOTE : This function Should not be modified, when needed,
            the callback could be implemented in the user file
   */
  BLUENRG_PRINTF("hci_le_periodic_advertising_sync_lost_event\r\n");
 801b6ee:	4803      	ldr	r0, [pc, #12]	@ (801b6fc <hci_le_periodic_advertising_sync_lost_event+0x18>)
 801b6f0:	f008 fb9c 	bl	8023e2c <puts>
}
 801b6f4:	bf00      	nop
 801b6f6:	3708      	adds	r7, #8
 801b6f8:	46bd      	mov	sp, r7
 801b6fa:	bd80      	pop	{r7, pc}
 801b6fc:	08028b0c 	.word	0x08028b0c

0801b700 <hci_le_scan_timeout_event>:
 *        the duration has expired. This event shall only be generated if
 *        scanning was enabled using the LE Set Extended Scan Enable command.
 * @retval None
 */
WEAK_FUNCTION(void hci_le_scan_timeout_event(void))
{
 801b700:	b580      	push	{r7, lr}
 801b702:	af00      	add	r7, sp, #0
  /* NOTE : This function Should not be modified, when needed,
            the callback could be implemented in the user file
   */
  BLUENRG_PRINTF("hci_le_scan_timeout_event\r\n");
 801b704:	4802      	ldr	r0, [pc, #8]	@ (801b710 <hci_le_scan_timeout_event+0x10>)
 801b706:	f008 fb91 	bl	8023e2c <puts>
}
 801b70a:	bf00      	nop
 801b70c:	bd80      	pop	{r7, pc}
 801b70e:	bf00      	nop
 801b710:	08028b3c 	.word	0x08028b3c

0801b714 <hci_le_advertising_set_terminated_event>:
 */
WEAK_FUNCTION(void hci_le_advertising_set_terminated_event(uint8_t Status,
                                                           uint8_t Advertising_Handle,
                                                           uint16_t Connection_Handle,
                                                           uint8_t Num_Completed_Extended_Advertising_Events))
{
 801b714:	b590      	push	{r4, r7, lr}
 801b716:	b083      	sub	sp, #12
 801b718:	af00      	add	r7, sp, #0
 801b71a:	4604      	mov	r4, r0
 801b71c:	4608      	mov	r0, r1
 801b71e:	4611      	mov	r1, r2
 801b720:	461a      	mov	r2, r3
 801b722:	4623      	mov	r3, r4
 801b724:	71fb      	strb	r3, [r7, #7]
 801b726:	4603      	mov	r3, r0
 801b728:	71bb      	strb	r3, [r7, #6]
 801b72a:	460b      	mov	r3, r1
 801b72c:	80bb      	strh	r3, [r7, #4]
 801b72e:	4613      	mov	r3, r2
 801b730:	70fb      	strb	r3, [r7, #3]
  /* NOTE : This function Should not be modified, when needed,
            the callback could be implemented in the user file
   */
  BLUENRG_PRINTF("hci_le_advertising_set_terminated_event\r\n");
 801b732:	4803      	ldr	r0, [pc, #12]	@ (801b740 <hci_le_advertising_set_terminated_event+0x2c>)
 801b734:	f008 fb7a 	bl	8023e2c <puts>
}
 801b738:	bf00      	nop
 801b73a:	370c      	adds	r7, #12
 801b73c:	46bd      	mov	sp, r7
 801b73e:	bd90      	pop	{r4, r7, pc}
 801b740:	08028b58 	.word	0x08028b58

0801b744 <hci_le_scan_request_received_event>:
 * @retval None
 */
WEAK_FUNCTION(void hci_le_scan_request_received_event(uint8_t Advertising_Handle,
                                                      uint8_t Scanner_Address_Type,
                                                      uint8_t Scanner_Address[6]))
{
 801b744:	b580      	push	{r7, lr}
 801b746:	b082      	sub	sp, #8
 801b748:	af00      	add	r7, sp, #0
 801b74a:	4603      	mov	r3, r0
 801b74c:	603a      	str	r2, [r7, #0]
 801b74e:	71fb      	strb	r3, [r7, #7]
 801b750:	460b      	mov	r3, r1
 801b752:	71bb      	strb	r3, [r7, #6]
  /* NOTE : This function Should not be modified, when needed,
            the callback could be implemented in the user file
   */
  BLUENRG_PRINTF("hci_le_scan_request_received_event\r\n");
 801b754:	4803      	ldr	r0, [pc, #12]	@ (801b764 <hci_le_scan_request_received_event+0x20>)
 801b756:	f008 fb69 	bl	8023e2c <puts>
}
 801b75a:	bf00      	nop
 801b75c:	3708      	adds	r7, #8
 801b75e:	46bd      	mov	sp, r7
 801b760:	bd80      	pop	{r7, pc}
 801b762:	bf00      	nop
 801b764:	08028b84 	.word	0x08028b84

0801b768 <hci_le_channel_selection_algorithm_event>:
 *        - 0x02 ... 0xFF: Reserved for future use
 * @retval None
 */
WEAK_FUNCTION(void hci_le_channel_selection_algorithm_event(uint16_t Connection_Handle,
                                                            uint8_t Channel_Selection_Algorithm))
{
 801b768:	b580      	push	{r7, lr}
 801b76a:	b082      	sub	sp, #8
 801b76c:	af00      	add	r7, sp, #0
 801b76e:	4603      	mov	r3, r0
 801b770:	460a      	mov	r2, r1
 801b772:	80fb      	strh	r3, [r7, #6]
 801b774:	4613      	mov	r3, r2
 801b776:	717b      	strb	r3, [r7, #5]
  /* NOTE : This function Should not be modified, when needed,
            the callback could be implemented in the user file
   */
  BLUENRG_PRINTF("hci_le_channel_selection_algorithm_event\r\n");
 801b778:	4803      	ldr	r0, [pc, #12]	@ (801b788 <hci_le_channel_selection_algorithm_event+0x20>)
 801b77a:	f008 fb57 	bl	8023e2c <puts>
}
 801b77e:	bf00      	nop
 801b780:	3708      	adds	r7, #8
 801b782:	46bd      	mov	sp, r7
 801b784:	bd80      	pop	{r7, pc}
 801b786:	bf00      	nop
 801b788:	08028ba8 	.word	0x08028ba8

0801b78c <hci_le_connectionless_iq_report_event>:
                                           uint8_t Slot_Durations,
                                           uint8_t Packet_Status,
                                           uint16_t Periodic_Event_Counter,
                                           uint8_t Sample_Count,
                                           Samples_t Samples[]))
{
 801b78c:	b590      	push	{r4, r7, lr}
 801b78e:	b083      	sub	sp, #12
 801b790:	af00      	add	r7, sp, #0
 801b792:	4604      	mov	r4, r0
 801b794:	4608      	mov	r0, r1
 801b796:	4611      	mov	r1, r2
 801b798:	461a      	mov	r2, r3
 801b79a:	4623      	mov	r3, r4
 801b79c:	80fb      	strh	r3, [r7, #6]
 801b79e:	4603      	mov	r3, r0
 801b7a0:	717b      	strb	r3, [r7, #5]
 801b7a2:	460b      	mov	r3, r1
 801b7a4:	807b      	strh	r3, [r7, #2]
 801b7a6:	4613      	mov	r3, r2
 801b7a8:	713b      	strb	r3, [r7, #4]
  /* NOTE : This function Should not be modified, when needed,
            the callback could be implemented in the user file
   */
  BLUENRG_PRINTF("hci_le_connectionless_iq_report_event\r\n");
 801b7aa:	4803      	ldr	r0, [pc, #12]	@ (801b7b8 <hci_le_connectionless_iq_report_event+0x2c>)
 801b7ac:	f008 fb3e 	bl	8023e2c <puts>
}
 801b7b0:	bf00      	nop
 801b7b2:	370c      	adds	r7, #12
 801b7b4:	46bd      	mov	sp, r7
 801b7b6:	bd90      	pop	{r4, r7, pc}
 801b7b8:	08028bd4 	.word	0x08028bd4

0801b7bc <hci_le_connection_iq_report_event>:
                                       uint8_t Slot_Durations,
                                       uint8_t Packet_Status,
                                       uint16_t Connection_Event_Counter,
                                       uint8_t Sample_Count,
                                       Samples_t Samples[]))
{
 801b7bc:	b590      	push	{r4, r7, lr}
 801b7be:	b083      	sub	sp, #12
 801b7c0:	af00      	add	r7, sp, #0
 801b7c2:	4604      	mov	r4, r0
 801b7c4:	4608      	mov	r0, r1
 801b7c6:	4611      	mov	r1, r2
 801b7c8:	461a      	mov	r2, r3
 801b7ca:	4623      	mov	r3, r4
 801b7cc:	80fb      	strh	r3, [r7, #6]
 801b7ce:	4603      	mov	r3, r0
 801b7d0:	717b      	strb	r3, [r7, #5]
 801b7d2:	460b      	mov	r3, r1
 801b7d4:	713b      	strb	r3, [r7, #4]
 801b7d6:	4613      	mov	r3, r2
 801b7d8:	807b      	strh	r3, [r7, #2]
  /* NOTE : This function Should not be modified, when needed,
            the callback could be implemented in the user file
   */
  BLUENRG_PRINTF("hci_le_connection_iq_report_event\r\n");
 801b7da:	4803      	ldr	r0, [pc, #12]	@ (801b7e8 <hci_le_connection_iq_report_event+0x2c>)
 801b7dc:	f008 fb26 	bl	8023e2c <puts>
}
 801b7e0:	bf00      	nop
 801b7e2:	370c      	adds	r7, #12
 801b7e4:	46bd      	mov	sp, r7
 801b7e6:	bd90      	pop	{r4, r7, pc}
 801b7e8:	08028bfc 	.word	0x08028bfc

0801b7ec <hci_le_cte_request_failed_event>:
 *        - 0x0000 ... 0x0EFF
 * @retval None
 */
WEAK_FUNCTION(void hci_le_cte_request_failed_event(uint8_t Status,
                                                   uint16_t Connection_Handle))
{
 801b7ec:	b580      	push	{r7, lr}
 801b7ee:	b082      	sub	sp, #8
 801b7f0:	af00      	add	r7, sp, #0
 801b7f2:	4603      	mov	r3, r0
 801b7f4:	460a      	mov	r2, r1
 801b7f6:	71fb      	strb	r3, [r7, #7]
 801b7f8:	4613      	mov	r3, r2
 801b7fa:	80bb      	strh	r3, [r7, #4]
  /* NOTE : This function Should not be modified, when needed,
            the callback could be implemented in the user file
   */
  BLUENRG_PRINTF("hci_le_cte_request_failed_event\r\n");
 801b7fc:	4803      	ldr	r0, [pc, #12]	@ (801b80c <hci_le_cte_request_failed_event+0x20>)
 801b7fe:	f008 fb15 	bl	8023e2c <puts>
}
 801b802:	bf00      	nop
 801b804:	3708      	adds	r7, #8
 801b806:	46bd      	mov	sp, r7
 801b808:	bd80      	pop	{r7, pc}
 801b80a:	bf00      	nop
 801b80c:	08028c20 	.word	0x08028c20

0801b810 <hci_le_periodic_advertising_sync_transfer_received_event>:
                                                                            uint8_t Advertiser_Address_Type,
                                                                            uint8_t Advertiser_Address[6],
                                                                            uint8_t Advertiser_PHY,
                                                                            uint16_t Periodic_Advertising_Interval,
                                                                            uint8_t Advertiser_Clock_Accuracy))
{
 801b810:	b590      	push	{r4, r7, lr}
 801b812:	b083      	sub	sp, #12
 801b814:	af00      	add	r7, sp, #0
 801b816:	4604      	mov	r4, r0
 801b818:	4608      	mov	r0, r1
 801b81a:	4611      	mov	r1, r2
 801b81c:	461a      	mov	r2, r3
 801b81e:	4623      	mov	r3, r4
 801b820:	71fb      	strb	r3, [r7, #7]
 801b822:	4603      	mov	r3, r0
 801b824:	80bb      	strh	r3, [r7, #4]
 801b826:	460b      	mov	r3, r1
 801b828:	807b      	strh	r3, [r7, #2]
 801b82a:	4613      	mov	r3, r2
 801b82c:	803b      	strh	r3, [r7, #0]
  /* NOTE : This function Should not be modified, when needed,
            the callback could be implemented in the user file
   */
  BLUENRG_PRINTF("hci_le_periodic_advertising_sync_transfer_received_event\r\n");
 801b82e:	4803      	ldr	r0, [pc, #12]	@ (801b83c <hci_le_periodic_advertising_sync_transfer_received_event+0x2c>)
 801b830:	f008 fafc 	bl	8023e2c <puts>
}
 801b834:	bf00      	nop
 801b836:	370c      	adds	r7, #12
 801b838:	46bd      	mov	sp, r7
 801b83a:	bd90      	pop	{r4, r7, pc}
 801b83c:	08028c44 	.word	0x08028c44

0801b840 <hci_le_path_loss_threshold_event>:
 * @retval None
 */
WEAK_FUNCTION(void hci_le_path_loss_threshold_event(uint16_t Connection_Handle,
                                                    uint8_t Current_Path_Loss,
                                                    uint8_t Zone_Entered))
{
 801b840:	b580      	push	{r7, lr}
 801b842:	b082      	sub	sp, #8
 801b844:	af00      	add	r7, sp, #0
 801b846:	4603      	mov	r3, r0
 801b848:	80fb      	strh	r3, [r7, #6]
 801b84a:	460b      	mov	r3, r1
 801b84c:	717b      	strb	r3, [r7, #5]
 801b84e:	4613      	mov	r3, r2
 801b850:	713b      	strb	r3, [r7, #4]
  /* NOTE : This function Should not be modified, when needed,
            the callback could be implemented in the user file
   */
  BLUENRG_PRINTF("hci_le_path_loss_threshold_event\r\n");
 801b852:	4803      	ldr	r0, [pc, #12]	@ (801b860 <hci_le_path_loss_threshold_event+0x20>)
 801b854:	f008 faea 	bl	8023e2c <puts>
}
 801b858:	bf00      	nop
 801b85a:	3708      	adds	r7, #8
 801b85c:	46bd      	mov	sp, r7
 801b85e:	bd80      	pop	{r7, pc}
 801b860:	08028c80 	.word	0x08028c80

0801b864 <hci_le_transmit_power_reporting_event>:
                                                         uint8_t Reason,
                                                         uint8_t PHY,
                                                         int8_t Transmit_Power_Level,
                                                         uint8_t Transmit_Power_Level_Flag,
                                                         int8_t Delta))
{
 801b864:	b590      	push	{r4, r7, lr}
 801b866:	b083      	sub	sp, #12
 801b868:	af00      	add	r7, sp, #0
 801b86a:	4604      	mov	r4, r0
 801b86c:	4608      	mov	r0, r1
 801b86e:	4611      	mov	r1, r2
 801b870:	461a      	mov	r2, r3
 801b872:	4623      	mov	r3, r4
 801b874:	71fb      	strb	r3, [r7, #7]
 801b876:	4603      	mov	r3, r0
 801b878:	80bb      	strh	r3, [r7, #4]
 801b87a:	460b      	mov	r3, r1
 801b87c:	71bb      	strb	r3, [r7, #6]
 801b87e:	4613      	mov	r3, r2
 801b880:	70fb      	strb	r3, [r7, #3]
  /* NOTE : This function Should not be modified, when needed,
            the callback could be implemented in the user file
   */
  BLUENRG_PRINTF("hci_le_transmit_power_reporting_event\r\n");
 801b882:	4803      	ldr	r0, [pc, #12]	@ (801b890 <hci_le_transmit_power_reporting_event+0x2c>)
 801b884:	f008 fad2 	bl	8023e2c <puts>
}
 801b888:	bf00      	nop
 801b88a:	370c      	adds	r7, #12
 801b88c:	46bd      	mov	sp, r7
 801b88e:	bd90      	pop	{r4, r7, pc}
 801b890:	08028ca4 	.word	0x08028ca4

0801b894 <hci_reset>:
    return status;
  }
  return BLE_STATUS_SUCCESS;
}
tBleStatus hci_reset(void)
{
 801b894:	b580      	push	{r7, lr}
 801b896:	b088      	sub	sp, #32
 801b898:	af00      	add	r7, sp, #0
  struct hci_request rq;
  tBleStatus status = 0;
 801b89a:	2300      	movs	r3, #0
 801b89c:	70fb      	strb	r3, [r7, #3]
  BLUENRG_memset(&rq, 0, sizeof(rq));
 801b89e:	1d3b      	adds	r3, r7, #4
 801b8a0:	221c      	movs	r2, #28
 801b8a2:	2100      	movs	r1, #0
 801b8a4:	4618      	mov	r0, r3
 801b8a6:	f008 fbdd 	bl	8024064 <memset>
  rq.ogf = 0x03;
 801b8aa:	2303      	movs	r3, #3
 801b8ac:	80fb      	strh	r3, [r7, #6]
  rq.ocf = 0x003;
 801b8ae:	2303      	movs	r3, #3
 801b8b0:	813b      	strh	r3, [r7, #8]
  rq.rparam = &status;
 801b8b2:	1cfb      	adds	r3, r7, #3
 801b8b4:	61bb      	str	r3, [r7, #24]
  rq.rlen = 1;
 801b8b6:	2301      	movs	r3, #1
 801b8b8:	61fb      	str	r3, [r7, #28]
  if (hci_send_req(&rq, FALSE) < 0)
 801b8ba:	1d3b      	adds	r3, r7, #4
 801b8bc:	2100      	movs	r1, #0
 801b8be:	4618      	mov	r0, r3
 801b8c0:	f000 fb16 	bl	801bef0 <hci_send_req>
 801b8c4:	4603      	mov	r3, r0
 801b8c6:	2b00      	cmp	r3, #0
 801b8c8:	da01      	bge.n	801b8ce <hci_reset+0x3a>
    return BLE_STATUS_TIMEOUT;
 801b8ca:	23ff      	movs	r3, #255	@ 0xff
 801b8cc:	e005      	b.n	801b8da <hci_reset+0x46>
  if (status) {
 801b8ce:	78fb      	ldrb	r3, [r7, #3]
 801b8d0:	2b00      	cmp	r3, #0
 801b8d2:	d001      	beq.n	801b8d8 <hci_reset+0x44>
    return status;
 801b8d4:	78fb      	ldrb	r3, [r7, #3]
 801b8d6:	e000      	b.n	801b8da <hci_reset+0x46>
  }
  return BLE_STATUS_SUCCESS;
 801b8d8:	2300      	movs	r3, #0
}
 801b8da:	4618      	mov	r0, r3
 801b8dc:	3720      	adds	r7, #32
 801b8de:	46bd      	mov	sp, r7
 801b8e0:	bd80      	pop	{r7, pc}

0801b8e2 <hci_read_local_version_information>:
tBleStatus hci_read_local_version_information(uint8_t *HCI_Version,
                                              uint16_t *HCI_Revision,
                                              uint8_t *LMP_PAL_Version,
                                              uint16_t *Manufacturer_Name,
                                              uint16_t *LMP_PAL_Subversion)
{
 801b8e2:	b580      	push	{r7, lr}
 801b8e4:	b08e      	sub	sp, #56	@ 0x38
 801b8e6:	af00      	add	r7, sp, #0
 801b8e8:	60f8      	str	r0, [r7, #12]
 801b8ea:	60b9      	str	r1, [r7, #8]
 801b8ec:	607a      	str	r2, [r7, #4]
 801b8ee:	603b      	str	r3, [r7, #0]
  struct hci_request rq;
  hci_read_local_version_information_rp0 resp;
  BLUENRG_memset(&resp, 0, sizeof(resp));
 801b8f0:	f107 0310 	add.w	r3, r7, #16
 801b8f4:	2209      	movs	r2, #9
 801b8f6:	2100      	movs	r1, #0
 801b8f8:	4618      	mov	r0, r3
 801b8fa:	f008 fbb3 	bl	8024064 <memset>
  BLUENRG_memset(&rq, 0, sizeof(rq));
 801b8fe:	f107 031c 	add.w	r3, r7, #28
 801b902:	221c      	movs	r2, #28
 801b904:	2100      	movs	r1, #0
 801b906:	4618      	mov	r0, r3
 801b908:	f008 fbac 	bl	8024064 <memset>
  rq.ogf = 0x04;
 801b90c:	2304      	movs	r3, #4
 801b90e:	83fb      	strh	r3, [r7, #30]
  rq.ocf = 0x001;
 801b910:	2301      	movs	r3, #1
 801b912:	843b      	strh	r3, [r7, #32]
  rq.rparam = &resp;
 801b914:	f107 0310 	add.w	r3, r7, #16
 801b918:	633b      	str	r3, [r7, #48]	@ 0x30
  rq.rlen = sizeof(resp);
 801b91a:	2309      	movs	r3, #9
 801b91c:	637b      	str	r3, [r7, #52]	@ 0x34
  if (hci_send_req(&rq, FALSE) < 0)
 801b91e:	f107 031c 	add.w	r3, r7, #28
 801b922:	2100      	movs	r1, #0
 801b924:	4618      	mov	r0, r3
 801b926:	f000 fae3 	bl	801bef0 <hci_send_req>
 801b92a:	4603      	mov	r3, r0
 801b92c:	2b00      	cmp	r3, #0
 801b92e:	da01      	bge.n	801b934 <hci_read_local_version_information+0x52>
    return BLE_STATUS_TIMEOUT;
 801b930:	23ff      	movs	r3, #255	@ 0xff
 801b932:	e018      	b.n	801b966 <hci_read_local_version_information+0x84>
  if (resp.Status) {
 801b934:	7c3b      	ldrb	r3, [r7, #16]
 801b936:	2b00      	cmp	r3, #0
 801b938:	d001      	beq.n	801b93e <hci_read_local_version_information+0x5c>
    return resp.Status;
 801b93a:	7c3b      	ldrb	r3, [r7, #16]
 801b93c:	e013      	b.n	801b966 <hci_read_local_version_information+0x84>
  }
  *HCI_Version = btoh(resp.HCI_Version, 1);
 801b93e:	7c7a      	ldrb	r2, [r7, #17]
 801b940:	68fb      	ldr	r3, [r7, #12]
 801b942:	701a      	strb	r2, [r3, #0]
  *HCI_Revision = btoh(resp.HCI_Revision, 2);
 801b944:	8a7a      	ldrh	r2, [r7, #18]
 801b946:	68bb      	ldr	r3, [r7, #8]
 801b948:	801a      	strh	r2, [r3, #0]
  *LMP_PAL_Version = btoh(resp.LMP_PAL_Version, 1);
 801b94a:	7d3a      	ldrb	r2, [r7, #20]
 801b94c:	687b      	ldr	r3, [r7, #4]
 801b94e:	701a      	strb	r2, [r3, #0]
  *Manufacturer_Name = btoh(resp.Manufacturer_Name, 2);
 801b950:	f8b7 3015 	ldrh.w	r3, [r7, #21]
 801b954:	b29a      	uxth	r2, r3
 801b956:	683b      	ldr	r3, [r7, #0]
 801b958:	801a      	strh	r2, [r3, #0]
  *LMP_PAL_Subversion = btoh(resp.LMP_PAL_Subversion, 2);
 801b95a:	f8b7 3017 	ldrh.w	r3, [r7, #23]
 801b95e:	b29a      	uxth	r2, r3
 801b960:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801b962:	801a      	strh	r2, [r3, #0]
  return BLE_STATUS_SUCCESS;
 801b964:	2300      	movs	r3, #0
}
 801b966:	4618      	mov	r0, r3
 801b968:	3738      	adds	r7, #56	@ 0x38
 801b96a:	46bd      	mov	sp, r7
 801b96c:	bd80      	pop	{r7, pc}

0801b96e <hci_le_set_scan_parameters>:
tBleStatus hci_le_set_scan_parameters(uint8_t LE_Scan_Type,
                                      uint16_t LE_Scan_Interval,
                                      uint16_t LE_Scan_Window,
                                      uint8_t Own_Address_Type,
                                      uint8_t Scanning_Filter_Policy)
{
 801b96e:	b5b0      	push	{r4, r5, r7, lr}
 801b970:	b0ce      	sub	sp, #312	@ 0x138
 801b972:	af00      	add	r7, sp, #0
 801b974:	4605      	mov	r5, r0
 801b976:	460c      	mov	r4, r1
 801b978:	4610      	mov	r0, r2
 801b97a:	4619      	mov	r1, r3
 801b97c:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 801b980:	f2a3 1331 	subw	r3, r3, #305	@ 0x131
 801b984:	462a      	mov	r2, r5
 801b986:	701a      	strb	r2, [r3, #0]
 801b988:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 801b98c:	f5a3 739a 	sub.w	r3, r3, #308	@ 0x134
 801b990:	4622      	mov	r2, r4
 801b992:	801a      	strh	r2, [r3, #0]
 801b994:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 801b998:	f5a3 739b 	sub.w	r3, r3, #310	@ 0x136
 801b99c:	4602      	mov	r2, r0
 801b99e:	801a      	strh	r2, [r3, #0]
 801b9a0:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 801b9a4:	f5a3 7399 	sub.w	r3, r3, #306	@ 0x132
 801b9a8:	460a      	mov	r2, r1
 801b9aa:	701a      	strb	r2, [r3, #0]
  struct hci_request rq;
  uint8_t cmd_buffer[258];
  hci_le_set_scan_parameters_cp0 *cp0 = (hci_le_set_scan_parameters_cp0*)(cmd_buffer);
 801b9ac:	f107 0310 	add.w	r3, r7, #16
 801b9b0:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
  tBleStatus status = 0;
 801b9b4:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 801b9b8:	f2a3 1329 	subw	r3, r3, #297	@ 0x129
 801b9bc:	2200      	movs	r2, #0
 801b9be:	701a      	strb	r2, [r3, #0]
  uint8_t index_input = 0;
 801b9c0:	2300      	movs	r3, #0
 801b9c2:	f887 3133 	strb.w	r3, [r7, #307]	@ 0x133
  cp0->LE_Scan_Type = htob(LE_Scan_Type, 1);
 801b9c6:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 801b9ca:	f507 729c 	add.w	r2, r7, #312	@ 0x138
 801b9ce:	f2a2 1231 	subw	r2, r2, #305	@ 0x131
 801b9d2:	7812      	ldrb	r2, [r2, #0]
 801b9d4:	701a      	strb	r2, [r3, #0]
  index_input += 1;
 801b9d6:	f897 3133 	ldrb.w	r3, [r7, #307]	@ 0x133
 801b9da:	3301      	adds	r3, #1
 801b9dc:	f887 3133 	strb.w	r3, [r7, #307]	@ 0x133
  cp0->LE_Scan_Interval = htob(LE_Scan_Interval, 2);
 801b9e0:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 801b9e4:	f507 729c 	add.w	r2, r7, #312	@ 0x138
 801b9e8:	f5a2 729a 	sub.w	r2, r2, #308	@ 0x134
 801b9ec:	8812      	ldrh	r2, [r2, #0]
 801b9ee:	f8a3 2001 	strh.w	r2, [r3, #1]
  index_input += 2;
 801b9f2:	f897 3133 	ldrb.w	r3, [r7, #307]	@ 0x133
 801b9f6:	3302      	adds	r3, #2
 801b9f8:	f887 3133 	strb.w	r3, [r7, #307]	@ 0x133
  cp0->LE_Scan_Window = htob(LE_Scan_Window, 2);
 801b9fc:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 801ba00:	f507 729c 	add.w	r2, r7, #312	@ 0x138
 801ba04:	f5a2 729b 	sub.w	r2, r2, #310	@ 0x136
 801ba08:	8812      	ldrh	r2, [r2, #0]
 801ba0a:	f8a3 2003 	strh.w	r2, [r3, #3]
  index_input += 2;
 801ba0e:	f897 3133 	ldrb.w	r3, [r7, #307]	@ 0x133
 801ba12:	3302      	adds	r3, #2
 801ba14:	f887 3133 	strb.w	r3, [r7, #307]	@ 0x133
  cp0->Own_Address_Type = htob(Own_Address_Type, 1);
 801ba18:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 801ba1c:	f507 729c 	add.w	r2, r7, #312	@ 0x138
 801ba20:	f5a2 7299 	sub.w	r2, r2, #306	@ 0x132
 801ba24:	7812      	ldrb	r2, [r2, #0]
 801ba26:	715a      	strb	r2, [r3, #5]
  index_input += 1;
 801ba28:	f897 3133 	ldrb.w	r3, [r7, #307]	@ 0x133
 801ba2c:	3301      	adds	r3, #1
 801ba2e:	f887 3133 	strb.w	r3, [r7, #307]	@ 0x133
  cp0->Scanning_Filter_Policy = htob(Scanning_Filter_Policy, 1);
 801ba32:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 801ba36:	f897 2148 	ldrb.w	r2, [r7, #328]	@ 0x148
 801ba3a:	719a      	strb	r2, [r3, #6]
  index_input += 1;
 801ba3c:	f897 3133 	ldrb.w	r3, [r7, #307]	@ 0x133
 801ba40:	3301      	adds	r3, #1
 801ba42:	f887 3133 	strb.w	r3, [r7, #307]	@ 0x133
  BLUENRG_memset(&rq, 0, sizeof(rq));
 801ba46:	f507 738a 	add.w	r3, r7, #276	@ 0x114
 801ba4a:	221c      	movs	r2, #28
 801ba4c:	2100      	movs	r1, #0
 801ba4e:	4618      	mov	r0, r3
 801ba50:	f008 fb08 	bl	8024064 <memset>
  rq.ogf = 0x08;
 801ba54:	2308      	movs	r3, #8
 801ba56:	f8a7 3116 	strh.w	r3, [r7, #278]	@ 0x116
  rq.ocf = 0x00b;
 801ba5a:	230b      	movs	r3, #11
 801ba5c:	f8a7 3118 	strh.w	r3, [r7, #280]	@ 0x118
  rq.cparam = cmd_buffer;
 801ba60:	f107 0310 	add.w	r3, r7, #16
 801ba64:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
  rq.clen = index_input;
 801ba68:	f897 3133 	ldrb.w	r3, [r7, #307]	@ 0x133
 801ba6c:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
  rq.rparam = &status;
 801ba70:	f107 030f 	add.w	r3, r7, #15
 801ba74:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128
  rq.rlen = 1;
 801ba78:	2301      	movs	r3, #1
 801ba7a:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
  if (hci_send_req(&rq, FALSE) < 0)
 801ba7e:	f507 738a 	add.w	r3, r7, #276	@ 0x114
 801ba82:	2100      	movs	r1, #0
 801ba84:	4618      	mov	r0, r3
 801ba86:	f000 fa33 	bl	801bef0 <hci_send_req>
 801ba8a:	4603      	mov	r3, r0
 801ba8c:	2b00      	cmp	r3, #0
 801ba8e:	da01      	bge.n	801ba94 <hci_le_set_scan_parameters+0x126>
    return BLE_STATUS_TIMEOUT;
 801ba90:	23ff      	movs	r3, #255	@ 0xff
 801ba92:	e00d      	b.n	801bab0 <hci_le_set_scan_parameters+0x142>
  if (status) {
 801ba94:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 801ba98:	f2a3 1329 	subw	r3, r3, #297	@ 0x129
 801ba9c:	781b      	ldrb	r3, [r3, #0]
 801ba9e:	2b00      	cmp	r3, #0
 801baa0:	d005      	beq.n	801baae <hci_le_set_scan_parameters+0x140>
    return status;
 801baa2:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 801baa6:	f2a3 1329 	subw	r3, r3, #297	@ 0x129
 801baaa:	781b      	ldrb	r3, [r3, #0]
 801baac:	e000      	b.n	801bab0 <hci_le_set_scan_parameters+0x142>
  }
  return BLE_STATUS_SUCCESS;
 801baae:	2300      	movs	r3, #0
}
 801bab0:	4618      	mov	r0, r3
 801bab2:	f507 779c 	add.w	r7, r7, #312	@ 0x138
 801bab6:	46bd      	mov	sp, r7
 801bab8:	bdb0      	pop	{r4, r5, r7, pc}

0801baba <hci_le_set_scan_enable>:
tBleStatus hci_le_set_scan_enable(uint8_t LE_Scan_Enable,
                                  uint8_t Filter_Duplicates)
{
 801baba:	b580      	push	{r7, lr}
 801babc:	b0ce      	sub	sp, #312	@ 0x138
 801babe:	af00      	add	r7, sp, #0
 801bac0:	4602      	mov	r2, r0
 801bac2:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 801bac6:	f2a3 1331 	subw	r3, r3, #305	@ 0x131
 801baca:	701a      	strb	r2, [r3, #0]
 801bacc:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 801bad0:	f5a3 7399 	sub.w	r3, r3, #306	@ 0x132
 801bad4:	460a      	mov	r2, r1
 801bad6:	701a      	strb	r2, [r3, #0]
  struct hci_request rq;
  uint8_t cmd_buffer[258];
  hci_le_set_scan_enable_cp0 *cp0 = (hci_le_set_scan_enable_cp0*)(cmd_buffer);
 801bad8:	f107 0310 	add.w	r3, r7, #16
 801badc:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
  tBleStatus status = 0;
 801bae0:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 801bae4:	f2a3 1329 	subw	r3, r3, #297	@ 0x129
 801bae8:	2200      	movs	r2, #0
 801baea:	701a      	strb	r2, [r3, #0]
  uint8_t index_input = 0;
 801baec:	2300      	movs	r3, #0
 801baee:	f887 3133 	strb.w	r3, [r7, #307]	@ 0x133
  cp0->LE_Scan_Enable = htob(LE_Scan_Enable, 1);
 801baf2:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 801baf6:	f507 729c 	add.w	r2, r7, #312	@ 0x138
 801bafa:	f2a2 1231 	subw	r2, r2, #305	@ 0x131
 801bafe:	7812      	ldrb	r2, [r2, #0]
 801bb00:	701a      	strb	r2, [r3, #0]
  index_input += 1;
 801bb02:	f897 3133 	ldrb.w	r3, [r7, #307]	@ 0x133
 801bb06:	3301      	adds	r3, #1
 801bb08:	f887 3133 	strb.w	r3, [r7, #307]	@ 0x133
  cp0->Filter_Duplicates = htob(Filter_Duplicates, 1);
 801bb0c:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 801bb10:	f507 729c 	add.w	r2, r7, #312	@ 0x138
 801bb14:	f5a2 7299 	sub.w	r2, r2, #306	@ 0x132
 801bb18:	7812      	ldrb	r2, [r2, #0]
 801bb1a:	705a      	strb	r2, [r3, #1]
  index_input += 1;
 801bb1c:	f897 3133 	ldrb.w	r3, [r7, #307]	@ 0x133
 801bb20:	3301      	adds	r3, #1
 801bb22:	f887 3133 	strb.w	r3, [r7, #307]	@ 0x133
  BLUENRG_memset(&rq, 0, sizeof(rq));
 801bb26:	f507 738a 	add.w	r3, r7, #276	@ 0x114
 801bb2a:	221c      	movs	r2, #28
 801bb2c:	2100      	movs	r1, #0
 801bb2e:	4618      	mov	r0, r3
 801bb30:	f008 fa98 	bl	8024064 <memset>
  rq.ogf = 0x08;
 801bb34:	2308      	movs	r3, #8
 801bb36:	f8a7 3116 	strh.w	r3, [r7, #278]	@ 0x116
  rq.ocf = 0x00c;
 801bb3a:	230c      	movs	r3, #12
 801bb3c:	f8a7 3118 	strh.w	r3, [r7, #280]	@ 0x118
  rq.cparam = cmd_buffer;
 801bb40:	f107 0310 	add.w	r3, r7, #16
 801bb44:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
  rq.clen = index_input;
 801bb48:	f897 3133 	ldrb.w	r3, [r7, #307]	@ 0x133
 801bb4c:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
  rq.rparam = &status;
 801bb50:	f107 030f 	add.w	r3, r7, #15
 801bb54:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128
  rq.rlen = 1;
 801bb58:	2301      	movs	r3, #1
 801bb5a:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
  if (hci_send_req(&rq, FALSE) < 0)
 801bb5e:	f507 738a 	add.w	r3, r7, #276	@ 0x114
 801bb62:	2100      	movs	r1, #0
 801bb64:	4618      	mov	r0, r3
 801bb66:	f000 f9c3 	bl	801bef0 <hci_send_req>
 801bb6a:	4603      	mov	r3, r0
 801bb6c:	2b00      	cmp	r3, #0
 801bb6e:	da01      	bge.n	801bb74 <hci_le_set_scan_enable+0xba>
    return BLE_STATUS_TIMEOUT;
 801bb70:	23ff      	movs	r3, #255	@ 0xff
 801bb72:	e00d      	b.n	801bb90 <hci_le_set_scan_enable+0xd6>
  if (status) {
 801bb74:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 801bb78:	f2a3 1329 	subw	r3, r3, #297	@ 0x129
 801bb7c:	781b      	ldrb	r3, [r3, #0]
 801bb7e:	2b00      	cmp	r3, #0
 801bb80:	d005      	beq.n	801bb8e <hci_le_set_scan_enable+0xd4>
    return status;
 801bb82:	f507 739c 	add.w	r3, r7, #312	@ 0x138
 801bb86:	f2a3 1329 	subw	r3, r3, #297	@ 0x129
 801bb8a:	781b      	ldrb	r3, [r3, #0]
 801bb8c:	e000      	b.n	801bb90 <hci_le_set_scan_enable+0xd6>
  }
  return BLE_STATUS_SUCCESS;
 801bb8e:	2300      	movs	r3, #0
}
 801bb90:	4618      	mov	r0, r3
 801bb92:	f507 779c 	add.w	r7, r7, #312	@ 0x138
 801bb96:	46bd      	mov	sp, r7
 801bb98:	bd80      	pop	{r7, pc}

0801bb9a <verify_packet>:
  *
  * @param  hciReadPacket The HCI data packet
  * @retval 0: valid packet, 1: incorrect packet, 2: wrong length (packet truncated or too long)
  */
static int verify_packet(const tHciDataPacket * hciReadPacket)
{ 
 801bb9a:	b480      	push	{r7}
 801bb9c:	b087      	sub	sp, #28
 801bb9e:	af00      	add	r7, sp, #0
 801bba0:	6078      	str	r0, [r7, #4]
  const uint8_t *hci_pckt = hciReadPacket->dataBuff;
 801bba2:	687b      	ldr	r3, [r7, #4]
 801bba4:	3308      	adds	r3, #8
 801bba6:	617b      	str	r3, [r7, #20]
  uint16_t payload_len;
  
  if(hci_pckt[HCI_TYPE_OFFSET] == HCI_EVENT_PKT){
 801bba8:	697b      	ldr	r3, [r7, #20]
 801bbaa:	781b      	ldrb	r3, [r3, #0]
 801bbac:	2b04      	cmp	r3, #4
 801bbae:	d110      	bne.n	801bbd2 <verify_packet+0x38>
    hci_event_hdr *hdr = (hci_event_hdr *)(hci_pckt+HCI_TYPE_SIZE);
 801bbb0:	697b      	ldr	r3, [r7, #20]
 801bbb2:	3301      	adds	r3, #1
 801bbb4:	60bb      	str	r3, [r7, #8]
    payload_len = hdr->plen;
 801bbb6:	68bb      	ldr	r3, [r7, #8]
 801bbb8:	785b      	ldrb	r3, [r3, #1]
 801bbba:	81fb      	strh	r3, [r7, #14]
    if(payload_len != hciReadPacket->data_len - (HCI_TYPE_SIZE+HCI_EVENT_HDR_SIZE))
 801bbbc:	89fa      	ldrh	r2, [r7, #14]
 801bbbe:	687b      	ldr	r3, [r7, #4]
 801bbc0:	f8b3 310c 	ldrh.w	r3, [r3, #268]	@ 0x10c
 801bbc4:	3b03      	subs	r3, #3
 801bbc6:	429a      	cmp	r2, r3
 801bbc8:	d001      	beq.n	801bbce <verify_packet+0x34>
      return 2; /* Wrong length (packet truncated or too long). */
 801bbca:	2302      	movs	r3, #2
 801bbcc:	e01a      	b.n	801bc04 <verify_packet+0x6a>
    return 0;
 801bbce:	2300      	movs	r3, #0
 801bbd0:	e018      	b.n	801bc04 <verify_packet+0x6a>
  }
  
  if(hci_pckt[HCI_TYPE_OFFSET] == HCI_EVENT_EXT_PKT){
 801bbd2:	697b      	ldr	r3, [r7, #20]
 801bbd4:	781b      	ldrb	r3, [r3, #0]
 801bbd6:	2b82      	cmp	r3, #130	@ 0x82
 801bbd8:	d113      	bne.n	801bc02 <verify_packet+0x68>
    hci_event_ext_hdr *hdr = (hci_event_ext_hdr *)(hci_pckt+HCI_TYPE_SIZE);
 801bbda:	697b      	ldr	r3, [r7, #20]
 801bbdc:	3301      	adds	r3, #1
 801bbde:	613b      	str	r3, [r7, #16]
    payload_len = hdr->plen;
 801bbe0:	693b      	ldr	r3, [r7, #16]
 801bbe2:	785a      	ldrb	r2, [r3, #1]
 801bbe4:	789b      	ldrb	r3, [r3, #2]
 801bbe6:	021b      	lsls	r3, r3, #8
 801bbe8:	4313      	orrs	r3, r2
 801bbea:	81fb      	strh	r3, [r7, #14]
    if(payload_len != hciReadPacket->data_len - (HCI_TYPE_SIZE+HCI_EVENT_EXT_HDR_SIZE))
 801bbec:	89fa      	ldrh	r2, [r7, #14]
 801bbee:	687b      	ldr	r3, [r7, #4]
 801bbf0:	f8b3 310c 	ldrh.w	r3, [r3, #268]	@ 0x10c
 801bbf4:	3b04      	subs	r3, #4
 801bbf6:	429a      	cmp	r2, r3
 801bbf8:	d001      	beq.n	801bbfe <verify_packet+0x64>
      return 2; /* Wrong length (packet truncated or too long). */
 801bbfa:	2302      	movs	r3, #2
 801bbfc:	e002      	b.n	801bc04 <verify_packet+0x6a>
    return 0;
 801bbfe:	2300      	movs	r3, #0
 801bc00:	e000      	b.n	801bc04 <verify_packet+0x6a>
  }
  
  return 1; /* Incorrect type. */
 801bc02:	2301      	movs	r3, #1
  
}
 801bc04:	4618      	mov	r0, r3
 801bc06:	371c      	adds	r7, #28
 801bc08:	46bd      	mov	sp, r7
 801bc0a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801bc0e:	4770      	bx	lr

0801bc10 <send_cmd>:
  * @param  param The HCI command parameters
  * @param  param If extended aci packet
  * @retval None
  */
static void send_cmd(uint16_t ogf, uint16_t ocf, uint8_t plen, void *param, uint8_t ext_aci)
{
 801bc10:	b590      	push	{r4, r7, lr}
 801bc12:	b0c9      	sub	sp, #292	@ 0x124
 801bc14:	af00      	add	r7, sp, #0
 801bc16:	4604      	mov	r4, r0
 801bc18:	4608      	mov	r0, r1
 801bc1a:	4611      	mov	r1, r2
 801bc1c:	f507 7290 	add.w	r2, r7, #288	@ 0x120
 801bc20:	f5a2 728e 	sub.w	r2, r2, #284	@ 0x11c
 801bc24:	6013      	str	r3, [r2, #0]
 801bc26:	f507 7390 	add.w	r3, r7, #288	@ 0x120
 801bc2a:	f5a3 7389 	sub.w	r3, r3, #274	@ 0x112
 801bc2e:	4622      	mov	r2, r4
 801bc30:	801a      	strh	r2, [r3, #0]
 801bc32:	f507 7390 	add.w	r3, r7, #288	@ 0x120
 801bc36:	f5a3 738a 	sub.w	r3, r3, #276	@ 0x114
 801bc3a:	4602      	mov	r2, r0
 801bc3c:	801a      	strh	r2, [r3, #0]
 801bc3e:	f507 7390 	add.w	r3, r7, #288	@ 0x120
 801bc42:	f2a3 1315 	subw	r3, r3, #277	@ 0x115
 801bc46:	460a      	mov	r2, r1
 801bc48:	701a      	strb	r2, [r3, #0]
  uint8_t payload[HCI_MAX_PAYLOAD_SIZE];
  
  if (!ext_aci) {
 801bc4a:	f897 3130 	ldrb.w	r3, [r7, #304]	@ 0x130
 801bc4e:	2b00      	cmp	r3, #0
 801bc50:	d156      	bne.n	801bd00 <send_cmd+0xf0>
    hci_cmd_hdr hc;
    hc.opcode = htobs(cmd_opcode_pack(ogf, ocf));
 801bc52:	f507 7390 	add.w	r3, r7, #288	@ 0x120
 801bc56:	f5a3 738a 	sub.w	r3, r3, #276	@ 0x114
 801bc5a:	f9b3 3000 	ldrsh.w	r3, [r3]
 801bc5e:	f3c3 0309 	ubfx	r3, r3, #0, #10
 801bc62:	b21a      	sxth	r2, r3
 801bc64:	f507 7390 	add.w	r3, r7, #288	@ 0x120
 801bc68:	f5a3 7389 	sub.w	r3, r3, #274	@ 0x112
 801bc6c:	f9b3 3000 	ldrsh.w	r3, [r3]
 801bc70:	029b      	lsls	r3, r3, #10
 801bc72:	b21b      	sxth	r3, r3
 801bc74:	4313      	orrs	r3, r2
 801bc76:	b21b      	sxth	r3, r3
 801bc78:	b29a      	uxth	r2, r3
 801bc7a:	f507 7390 	add.w	r3, r7, #288	@ 0x120
 801bc7e:	f5a3 7384 	sub.w	r3, r3, #264	@ 0x108
 801bc82:	801a      	strh	r2, [r3, #0]
    hc.plen = plen;
 801bc84:	f507 7390 	add.w	r3, r7, #288	@ 0x120
 801bc88:	f5a3 7384 	sub.w	r3, r3, #264	@ 0x108
 801bc8c:	f507 7290 	add.w	r2, r7, #288	@ 0x120
 801bc90:	f2a2 1215 	subw	r2, r2, #277	@ 0x115
 801bc94:	7812      	ldrb	r2, [r2, #0]
 801bc96:	709a      	strb	r2, [r3, #2]
    payload[0] = HCI_COMMAND_PKT;
 801bc98:	f507 7390 	add.w	r3, r7, #288	@ 0x120
 801bc9c:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
 801bca0:	2201      	movs	r2, #1
 801bca2:	701a      	strb	r2, [r3, #0]
    BLUENRG_memcpy(payload + 1, &hc, sizeof(hc));
 801bca4:	f107 031c 	add.w	r3, r7, #28
 801bca8:	3301      	adds	r3, #1
 801bcaa:	f507 7290 	add.w	r2, r7, #288	@ 0x120
 801bcae:	f5a2 7284 	sub.w	r2, r2, #264	@ 0x108
 801bcb2:	8811      	ldrh	r1, [r2, #0]
 801bcb4:	7892      	ldrb	r2, [r2, #2]
 801bcb6:	8019      	strh	r1, [r3, #0]
 801bcb8:	709a      	strb	r2, [r3, #2]
    BLUENRG_memcpy(payload + HCI_TYPE_SIZE + HCI_COMMAND_HDR_SIZE, param, plen);
 801bcba:	f107 031c 	add.w	r3, r7, #28
 801bcbe:	3304      	adds	r3, #4
 801bcc0:	f507 7290 	add.w	r2, r7, #288	@ 0x120
 801bcc4:	f2a2 1215 	subw	r2, r2, #277	@ 0x115
 801bcc8:	7812      	ldrb	r2, [r2, #0]
 801bcca:	f507 7190 	add.w	r1, r7, #288	@ 0x120
 801bcce:	f5a1 718e 	sub.w	r1, r1, #284	@ 0x11c
 801bcd2:	6809      	ldr	r1, [r1, #0]
 801bcd4:	4618      	mov	r0, r3
 801bcd6:	f008 fa8a 	bl	80241ee <memcpy>
    if (hciContext.io.Send)
 801bcda:	4b36      	ldr	r3, [pc, #216]	@ (801bdb4 <send_cmd+0x1a4>)
 801bcdc:	691b      	ldr	r3, [r3, #16]
 801bcde:	2b00      	cmp	r3, #0
 801bce0:	d063      	beq.n	801bdaa <send_cmd+0x19a>
    {
      hciContext.io.Send (payload, HCI_TYPE_SIZE + HCI_COMMAND_HDR_SIZE + plen);
 801bce2:	4b34      	ldr	r3, [pc, #208]	@ (801bdb4 <send_cmd+0x1a4>)
 801bce4:	691b      	ldr	r3, [r3, #16]
 801bce6:	f507 7290 	add.w	r2, r7, #288	@ 0x120
 801bcea:	f2a2 1215 	subw	r2, r2, #277	@ 0x115
 801bcee:	7812      	ldrb	r2, [r2, #0]
 801bcf0:	b292      	uxth	r2, r2
 801bcf2:	3204      	adds	r2, #4
 801bcf4:	b291      	uxth	r1, r2
 801bcf6:	f107 021c 	add.w	r2, r7, #28
 801bcfa:	4610      	mov	r0, r2
 801bcfc:	4798      	blx	r3
    {
      hciContext.io.Send (payload, HCI_TYPE_SIZE + HCI_COMMAND_EXT_HDR_SIZE + plen);
    }
  }

}
 801bcfe:	e054      	b.n	801bdaa <send_cmd+0x19a>
    hc.opcode = htobs(cmd_opcode_pack(ogf, ocf));
 801bd00:	f507 7390 	add.w	r3, r7, #288	@ 0x120
 801bd04:	f5a3 738a 	sub.w	r3, r3, #276	@ 0x114
 801bd08:	f9b3 3000 	ldrsh.w	r3, [r3]
 801bd0c:	f3c3 0309 	ubfx	r3, r3, #0, #10
 801bd10:	b21a      	sxth	r2, r3
 801bd12:	f507 7390 	add.w	r3, r7, #288	@ 0x120
 801bd16:	f5a3 7389 	sub.w	r3, r3, #274	@ 0x112
 801bd1a:	f9b3 3000 	ldrsh.w	r3, [r3]
 801bd1e:	029b      	lsls	r3, r3, #10
 801bd20:	b21b      	sxth	r3, r3
 801bd22:	4313      	orrs	r3, r2
 801bd24:	b21b      	sxth	r3, r3
 801bd26:	b29a      	uxth	r2, r3
 801bd28:	f507 7390 	add.w	r3, r7, #288	@ 0x120
 801bd2c:	f5a3 7386 	sub.w	r3, r3, #268	@ 0x10c
 801bd30:	801a      	strh	r2, [r3, #0]
    hc.plen = plen;
 801bd32:	f507 7390 	add.w	r3, r7, #288	@ 0x120
 801bd36:	f2a3 1315 	subw	r3, r3, #277	@ 0x115
 801bd3a:	781b      	ldrb	r3, [r3, #0]
 801bd3c:	b29a      	uxth	r2, r3
 801bd3e:	f507 7390 	add.w	r3, r7, #288	@ 0x120
 801bd42:	f5a3 7386 	sub.w	r3, r3, #268	@ 0x10c
 801bd46:	805a      	strh	r2, [r3, #2]
    payload[0] = HCI_COMMAND_EXT_PKT;
 801bd48:	f507 7390 	add.w	r3, r7, #288	@ 0x120
 801bd4c:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
 801bd50:	2281      	movs	r2, #129	@ 0x81
 801bd52:	701a      	strb	r2, [r3, #0]
    BLUENRG_memcpy(payload + 1, &hc, sizeof(hc));
 801bd54:	f107 031c 	add.w	r3, r7, #28
 801bd58:	3301      	adds	r3, #1
 801bd5a:	f507 7290 	add.w	r2, r7, #288	@ 0x120
 801bd5e:	f5a2 7286 	sub.w	r2, r2, #268	@ 0x10c
 801bd62:	6812      	ldr	r2, [r2, #0]
 801bd64:	601a      	str	r2, [r3, #0]
    BLUENRG_memcpy(payload + HCI_TYPE_SIZE + HCI_COMMAND_EXT_HDR_SIZE, param, plen); 
 801bd66:	f107 031c 	add.w	r3, r7, #28
 801bd6a:	3305      	adds	r3, #5
 801bd6c:	f507 7290 	add.w	r2, r7, #288	@ 0x120
 801bd70:	f2a2 1215 	subw	r2, r2, #277	@ 0x115
 801bd74:	7812      	ldrb	r2, [r2, #0]
 801bd76:	f507 7190 	add.w	r1, r7, #288	@ 0x120
 801bd7a:	f5a1 718e 	sub.w	r1, r1, #284	@ 0x11c
 801bd7e:	6809      	ldr	r1, [r1, #0]
 801bd80:	4618      	mov	r0, r3
 801bd82:	f008 fa34 	bl	80241ee <memcpy>
    if (hciContext.io.Send)
 801bd86:	4b0b      	ldr	r3, [pc, #44]	@ (801bdb4 <send_cmd+0x1a4>)
 801bd88:	691b      	ldr	r3, [r3, #16]
 801bd8a:	2b00      	cmp	r3, #0
 801bd8c:	d00d      	beq.n	801bdaa <send_cmd+0x19a>
      hciContext.io.Send (payload, HCI_TYPE_SIZE + HCI_COMMAND_EXT_HDR_SIZE + plen);
 801bd8e:	4b09      	ldr	r3, [pc, #36]	@ (801bdb4 <send_cmd+0x1a4>)
 801bd90:	691b      	ldr	r3, [r3, #16]
 801bd92:	f507 7290 	add.w	r2, r7, #288	@ 0x120
 801bd96:	f2a2 1215 	subw	r2, r2, #277	@ 0x115
 801bd9a:	7812      	ldrb	r2, [r2, #0]
 801bd9c:	b292      	uxth	r2, r2
 801bd9e:	3205      	adds	r2, #5
 801bda0:	b291      	uxth	r1, r2
 801bda2:	f107 021c 	add.w	r2, r7, #28
 801bda6:	4610      	mov	r0, r2
 801bda8:	4798      	blx	r3
}
 801bdaa:	bf00      	nop
 801bdac:	f507 7792 	add.w	r7, r7, #292	@ 0x124
 801bdb0:	46bd      	mov	sp, r7
 801bdb2:	bd90      	pop	{r4, r7, pc}
 801bdb4:	2000188c 	.word	0x2000188c

0801bdb8 <move_list>:
  * @param  dest_list
  * @param  src_list
  * @retval None
  */
static void move_list(tListNode * dest_list, tListNode * src_list)
{
 801bdb8:	b580      	push	{r7, lr}
 801bdba:	b084      	sub	sp, #16
 801bdbc:	af00      	add	r7, sp, #0
 801bdbe:	6078      	str	r0, [r7, #4]
 801bdc0:	6039      	str	r1, [r7, #0]
  pListNode tmp_node;
  
  while (!list_is_empty(src_list))
 801bdc2:	e00a      	b.n	801bdda <move_list+0x22>
  {
    list_remove_tail(src_list, &tmp_node);
 801bdc4:	f107 030c 	add.w	r3, r7, #12
 801bdc8:	4619      	mov	r1, r3
 801bdca:	6838      	ldr	r0, [r7, #0]
 801bdcc:	f000 faee 	bl	801c3ac <list_remove_tail>
    list_insert_head(dest_list, tmp_node);
 801bdd0:	68fb      	ldr	r3, [r7, #12]
 801bdd2:	4619      	mov	r1, r3
 801bdd4:	6878      	ldr	r0, [r7, #4]
 801bdd6:	f000 fa55 	bl	801c284 <list_insert_head>
  while (!list_is_empty(src_list))
 801bdda:	6838      	ldr	r0, [r7, #0]
 801bddc:	f000 fa30 	bl	801c240 <list_is_empty>
 801bde0:	4603      	mov	r3, r0
 801bde2:	2b00      	cmp	r3, #0
 801bde4:	d0ee      	beq.n	801bdc4 <move_list+0xc>
  }
}
 801bde6:	bf00      	nop
 801bde8:	bf00      	nop
 801bdea:	3710      	adds	r7, #16
 801bdec:	46bd      	mov	sp, r7
 801bdee:	bd80      	pop	{r7, pc}

0801bdf0 <free_event_list>:
  *
  * @param  None
  * @retval None
  */
static void free_event_list(void)
{
 801bdf0:	b580      	push	{r7, lr}
 801bdf2:	b082      	sub	sp, #8
 801bdf4:	af00      	add	r7, sp, #0
  tHciDataPacket * pckt;

  while(list_get_size(&hciReadPktPool) < HCI_READ_PACKET_NUM_MAX/2){
 801bdf6:	e009      	b.n	801be0c <free_event_list+0x1c>
    list_remove_head(&hciReadPktRxQueue, (tListNode **)&pckt);    
 801bdf8:	1d3b      	adds	r3, r7, #4
 801bdfa:	4619      	mov	r1, r3
 801bdfc:	4809      	ldr	r0, [pc, #36]	@ (801be24 <free_event_list+0x34>)
 801bdfe:	f000 faae 	bl	801c35e <list_remove_head>
    list_insert_tail(&hciReadPktPool, (tListNode *)pckt);
 801be02:	687b      	ldr	r3, [r7, #4]
 801be04:	4619      	mov	r1, r3
 801be06:	4808      	ldr	r0, [pc, #32]	@ (801be28 <free_event_list+0x38>)
 801be08:	f000 fa62 	bl	801c2d0 <list_insert_tail>
  while(list_get_size(&hciReadPktPool) < HCI_READ_PACKET_NUM_MAX/2){
 801be0c:	4806      	ldr	r0, [pc, #24]	@ (801be28 <free_event_list+0x38>)
 801be0e:	f000 faf4 	bl	801c3fa <list_get_size>
 801be12:	4603      	mov	r3, r0
 801be14:	2b04      	cmp	r3, #4
 801be16:	ddef      	ble.n	801bdf8 <free_event_list+0x8>
  }
}
 801be18:	bf00      	nop
 801be1a:	bf00      	nop
 801be1c:	3708      	adds	r7, #8
 801be1e:	46bd      	mov	sp, r7
 801be20:	bd80      	pop	{r7, pc}
 801be22:	bf00      	nop
 801be24:	20000de4 	.word	0x20000de4
 801be28:	20000ddc 	.word	0x20000ddc

0801be2c <hci_init>:

/********************** HCI Transport layer functions *****************************/

void hci_init(void(* UserEvtRx)(void* pData), void* pConf)
{
 801be2c:	b580      	push	{r7, lr}
 801be2e:	b084      	sub	sp, #16
 801be30:	af00      	add	r7, sp, #0
 801be32:	6078      	str	r0, [r7, #4]
 801be34:	6039      	str	r1, [r7, #0]
  uint8_t index;

  if(UserEvtRx != NULL)
 801be36:	687b      	ldr	r3, [r7, #4]
 801be38:	2b00      	cmp	r3, #0
 801be3a:	d002      	beq.n	801be42 <hci_init+0x16>
  {
    hciContext.UserEvtRx = UserEvtRx;
 801be3c:	4a18      	ldr	r2, [pc, #96]	@ (801bea0 <hci_init+0x74>)
 801be3e:	687b      	ldr	r3, [r7, #4]
 801be40:	61d3      	str	r3, [r2, #28]
  }
  
  /* Initialize list heads of ready and free hci data packet queues */
  list_init_head(&hciReadPktPool);
 801be42:	4818      	ldr	r0, [pc, #96]	@ (801bea4 <hci_init+0x78>)
 801be44:	f000 f9ec 	bl	801c220 <list_init_head>
  list_init_head(&hciReadPktRxQueue);
 801be48:	4817      	ldr	r0, [pc, #92]	@ (801bea8 <hci_init+0x7c>)
 801be4a:	f000 f9e9 	bl	801c220 <list_init_head>

  /* Initialize TL BLE layer */
  hci_tl_lowlevel_init();
 801be4e:	f7e8 ff29 	bl	8004ca4 <hci_tl_lowlevel_init>

  /* Initialize the queue of free hci data packets */
  for (index = 0; index < HCI_READ_PACKET_NUM_MAX; index++)
 801be52:	2300      	movs	r3, #0
 801be54:	73fb      	strb	r3, [r7, #15]
 801be56:	e00d      	b.n	801be74 <hci_init+0x48>
  {
    list_insert_tail(&hciReadPktPool, (tListNode *)&hciReadPacketBuffer[index]);
 801be58:	7bfa      	ldrb	r2, [r7, #15]
 801be5a:	4613      	mov	r3, r2
 801be5c:	011b      	lsls	r3, r3, #4
 801be5e:	4413      	add	r3, r2
 801be60:	011b      	lsls	r3, r3, #4
 801be62:	4a12      	ldr	r2, [pc, #72]	@ (801beac <hci_init+0x80>)
 801be64:	4413      	add	r3, r2
 801be66:	4619      	mov	r1, r3
 801be68:	480e      	ldr	r0, [pc, #56]	@ (801bea4 <hci_init+0x78>)
 801be6a:	f000 fa31 	bl	801c2d0 <list_insert_tail>
  for (index = 0; index < HCI_READ_PACKET_NUM_MAX; index++)
 801be6e:	7bfb      	ldrb	r3, [r7, #15]
 801be70:	3301      	adds	r3, #1
 801be72:	73fb      	strb	r3, [r7, #15]
 801be74:	7bfb      	ldrb	r3, [r7, #15]
 801be76:	2b09      	cmp	r3, #9
 801be78:	d9ee      	bls.n	801be58 <hci_init+0x2c>
  } 
  
  /* Initialize low level driver */
  if (hciContext.io.Init) {
 801be7a:	4b09      	ldr	r3, [pc, #36]	@ (801bea0 <hci_init+0x74>)
 801be7c:	681b      	ldr	r3, [r3, #0]
 801be7e:	2b00      	cmp	r3, #0
 801be80:	d003      	beq.n	801be8a <hci_init+0x5e>
    hciContext.io.Init(NULL);
 801be82:	4b07      	ldr	r3, [pc, #28]	@ (801bea0 <hci_init+0x74>)
 801be84:	681b      	ldr	r3, [r3, #0]
 801be86:	2000      	movs	r0, #0
 801be88:	4798      	blx	r3
  } 
    
  if (hciContext.io.Reset){
 801be8a:	4b05      	ldr	r3, [pc, #20]	@ (801bea0 <hci_init+0x74>)
 801be8c:	689b      	ldr	r3, [r3, #8]
 801be8e:	2b00      	cmp	r3, #0
 801be90:	d002      	beq.n	801be98 <hci_init+0x6c>
    hciContext.io.Reset();
 801be92:	4b03      	ldr	r3, [pc, #12]	@ (801bea0 <hci_init+0x74>)
 801be94:	689b      	ldr	r3, [r3, #8]
 801be96:	4798      	blx	r3
  }
}
 801be98:	bf00      	nop
 801be9a:	3710      	adds	r7, #16
 801be9c:	46bd      	mov	sp, r7
 801be9e:	bd80      	pop	{r7, pc}
 801bea0:	2000188c 	.word	0x2000188c
 801bea4:	20000ddc 	.word	0x20000ddc
 801bea8:	20000de4 	.word	0x20000de4
 801beac:	20000dec 	.word	0x20000dec

0801beb0 <hci_register_io_bus>:

void hci_register_io_bus(tHciIO* fops)
{
 801beb0:	b480      	push	{r7}
 801beb2:	b083      	sub	sp, #12
 801beb4:	af00      	add	r7, sp, #0
 801beb6:	6078      	str	r0, [r7, #4]
  /* Register bus function */
  hciContext.io.Init    = fops->Init; 
 801beb8:	687b      	ldr	r3, [r7, #4]
 801beba:	681b      	ldr	r3, [r3, #0]
 801bebc:	4a0b      	ldr	r2, [pc, #44]	@ (801beec <hci_register_io_bus+0x3c>)
 801bebe:	6013      	str	r3, [r2, #0]
  hciContext.io.Receive = fops->Receive;  
 801bec0:	687b      	ldr	r3, [r7, #4]
 801bec2:	68db      	ldr	r3, [r3, #12]
 801bec4:	4a09      	ldr	r2, [pc, #36]	@ (801beec <hci_register_io_bus+0x3c>)
 801bec6:	60d3      	str	r3, [r2, #12]
  hciContext.io.Send    = fops->Send;
 801bec8:	687b      	ldr	r3, [r7, #4]
 801beca:	691b      	ldr	r3, [r3, #16]
 801becc:	4a07      	ldr	r2, [pc, #28]	@ (801beec <hci_register_io_bus+0x3c>)
 801bece:	6113      	str	r3, [r2, #16]
  hciContext.io.GetTick = fops->GetTick;
 801bed0:	687b      	ldr	r3, [r7, #4]
 801bed2:	699b      	ldr	r3, [r3, #24]
 801bed4:	4a05      	ldr	r2, [pc, #20]	@ (801beec <hci_register_io_bus+0x3c>)
 801bed6:	6193      	str	r3, [r2, #24]
  hciContext.io.Reset   = fops->Reset;
 801bed8:	687b      	ldr	r3, [r7, #4]
 801beda:	689b      	ldr	r3, [r3, #8]
 801bedc:	4a03      	ldr	r2, [pc, #12]	@ (801beec <hci_register_io_bus+0x3c>)
 801bede:	6093      	str	r3, [r2, #8]
}
 801bee0:	bf00      	nop
 801bee2:	370c      	adds	r7, #12
 801bee4:	46bd      	mov	sp, r7
 801bee6:	f85d 7b04 	ldr.w	r7, [sp], #4
 801beea:	4770      	bx	lr
 801beec:	2000188c 	.word	0x2000188c

0801bef0 <hci_send_req>:

int hci_send_req(struct hci_request* r, BOOL async)
{
 801bef0:	b590      	push	{r4, r7, lr}
 801bef2:	b091      	sub	sp, #68	@ 0x44
 801bef4:	af02      	add	r7, sp, #8
 801bef6:	6078      	str	r0, [r7, #4]
 801bef8:	460b      	mov	r3, r1
 801befa:	70fb      	strb	r3, [r7, #3]
  uint8_t *ptr;
  uint16_t opcode = htobs(cmd_opcode_pack(r->ogf, r->ocf));
 801befc:	687b      	ldr	r3, [r7, #4]
 801befe:	889b      	ldrh	r3, [r3, #4]
 801bf00:	b21b      	sxth	r3, r3
 801bf02:	f3c3 0309 	ubfx	r3, r3, #0, #10
 801bf06:	b21a      	sxth	r2, r3
 801bf08:	687b      	ldr	r3, [r7, #4]
 801bf0a:	885b      	ldrh	r3, [r3, #2]
 801bf0c:	b21b      	sxth	r3, r3
 801bf0e:	029b      	lsls	r3, r3, #10
 801bf10:	b21b      	sxth	r3, r3
 801bf12:	4313      	orrs	r3, r2
 801bf14:	b21b      	sxth	r3, r3
 801bf16:	86fb      	strh	r3, [r7, #54]	@ 0x36
  hci_event_pckt *event_pckt;
  hci_spi_pckt *hci_hdr;

  tHciDataPacket * hciReadPacket = NULL;
 801bf18:	2300      	movs	r3, #0
 801bf1a:	613b      	str	r3, [r7, #16]
  tListNode hciTempQueue;
  
  list_init_head(&hciTempQueue);
 801bf1c:	f107 0308 	add.w	r3, r7, #8
 801bf20:	4618      	mov	r0, r3
 801bf22:	f000 f97d 	bl	801c220 <list_init_head>

  free_event_list();
 801bf26:	f7ff ff63 	bl	801bdf0 <free_event_list>
  
  send_cmd(r->ogf, r->ocf, r->clen, r->cparam, r->ext_aci);
 801bf2a:	687b      	ldr	r3, [r7, #4]
 801bf2c:	8858      	ldrh	r0, [r3, #2]
 801bf2e:	687b      	ldr	r3, [r7, #4]
 801bf30:	8899      	ldrh	r1, [r3, #4]
 801bf32:	687b      	ldr	r3, [r7, #4]
 801bf34:	691b      	ldr	r3, [r3, #16]
 801bf36:	b2da      	uxtb	r2, r3
 801bf38:	687b      	ldr	r3, [r7, #4]
 801bf3a:	68dc      	ldr	r4, [r3, #12]
 801bf3c:	687b      	ldr	r3, [r7, #4]
 801bf3e:	781b      	ldrb	r3, [r3, #0]
 801bf40:	9300      	str	r3, [sp, #0]
 801bf42:	4623      	mov	r3, r4
 801bf44:	f7ff fe64 	bl	801bc10 <send_cmd>
  
  if (async)
 801bf48:	78fb      	ldrb	r3, [r7, #3]
 801bf4a:	2b00      	cmp	r3, #0
 801bf4c:	d001      	beq.n	801bf52 <hci_send_req+0x62>
  {
    return 0;
 801bf4e:	2300      	movs	r3, #0
 801bf50:	e0e2      	b.n	801c118 <hci_send_req+0x228>
    evt_cmd_complete  *cc;
    evt_cmd_status    *cs;
    evt_le_meta_event *me;
    uint32_t len;
    
    uint32_t tickstart = HAL_GetTick();
 801bf52:	f7f1 fd85 	bl	800da60 <HAL_GetTick>
 801bf56:	6338      	str	r0, [r7, #48]	@ 0x30
      
    while (1)
    {
      if ((HAL_GetTick() - tickstart) > HCI_DEFAULT_TIMEOUT_MS)
 801bf58:	f7f1 fd82 	bl	800da60 <HAL_GetTick>
 801bf5c:	4602      	mov	r2, r0
 801bf5e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801bf60:	1ad3      	subs	r3, r2, r3
 801bf62:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 801bf66:	f200 80b3 	bhi.w	801c0d0 <hci_send_req+0x1e0>
      {
        goto failed;
      }
      
      if (!list_is_empty(&hciReadPktRxQueue)) 
 801bf6a:	486d      	ldr	r0, [pc, #436]	@ (801c120 <hci_send_req+0x230>)
 801bf6c:	f000 f968 	bl	801c240 <list_is_empty>
 801bf70:	4603      	mov	r3, r0
 801bf72:	2b00      	cmp	r3, #0
 801bf74:	d000      	beq.n	801bf78 <hci_send_req+0x88>
      if ((HAL_GetTick() - tickstart) > HCI_DEFAULT_TIMEOUT_MS)
 801bf76:	e7ef      	b.n	801bf58 <hci_send_req+0x68>
      {
        break;
 801bf78:	bf00      	nop
      }
    }
    
    /* Extract packet from HCI event queue. */
    list_remove_head(&hciReadPktRxQueue, (tListNode **)&hciReadPacket);    
 801bf7a:	f107 0310 	add.w	r3, r7, #16
 801bf7e:	4619      	mov	r1, r3
 801bf80:	4867      	ldr	r0, [pc, #412]	@ (801c120 <hci_send_req+0x230>)
 801bf82:	f000 f9ec 	bl	801c35e <list_remove_head>
    
    hci_hdr = (void *)hciReadPacket->dataBuff;
 801bf86:	693b      	ldr	r3, [r7, #16]
 801bf88:	3308      	adds	r3, #8
 801bf8a:	62fb      	str	r3, [r7, #44]	@ 0x2c

    if (hci_hdr->type == HCI_EVENT_PKT)
 801bf8c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801bf8e:	781b      	ldrb	r3, [r3, #0]
 801bf90:	2b04      	cmp	r3, #4
 801bf92:	d17f      	bne.n	801c094 <hci_send_req+0x1a4>
    {
      event_pckt = (void *)(hci_hdr->data);
 801bf94:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801bf96:	3301      	adds	r3, #1
 801bf98:	62bb      	str	r3, [r7, #40]	@ 0x28
    
      ptr = hciReadPacket->dataBuff + (1 + HCI_EVENT_HDR_SIZE);
 801bf9a:	693b      	ldr	r3, [r7, #16]
 801bf9c:	3308      	adds	r3, #8
 801bf9e:	3303      	adds	r3, #3
 801bfa0:	627b      	str	r3, [r7, #36]	@ 0x24
      len = hciReadPacket->data_len - (1 + HCI_EVENT_HDR_SIZE);
 801bfa2:	693b      	ldr	r3, [r7, #16]
 801bfa4:	f8b3 310c 	ldrh.w	r3, [r3, #268]	@ 0x10c
 801bfa8:	3b03      	subs	r3, #3
 801bfaa:	623b      	str	r3, [r7, #32]
    
      switch (event_pckt->evt) 
 801bfac:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801bfae:	781b      	ldrb	r3, [r3, #0]
 801bfb0:	2b3e      	cmp	r3, #62	@ 0x3e
 801bfb2:	d04c      	beq.n	801c04e <hci_send_req+0x15e>
 801bfb4:	2b3e      	cmp	r3, #62	@ 0x3e
 801bfb6:	dc68      	bgt.n	801c08a <hci_send_req+0x19a>
 801bfb8:	2b10      	cmp	r3, #16
 801bfba:	f000 808b 	beq.w	801c0d4 <hci_send_req+0x1e4>
 801bfbe:	2b10      	cmp	r3, #16
 801bfc0:	dc63      	bgt.n	801c08a <hci_send_req+0x19a>
 801bfc2:	2b0e      	cmp	r3, #14
 801bfc4:	d023      	beq.n	801c00e <hci_send_req+0x11e>
 801bfc6:	2b0f      	cmp	r3, #15
 801bfc8:	d15f      	bne.n	801c08a <hci_send_req+0x19a>
      {      
      case EVT_CMD_STATUS:
        cs = (void *) ptr;
 801bfca:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801bfcc:	61bb      	str	r3, [r7, #24]
        
        if (cs->opcode != opcode)
 801bfce:	69bb      	ldr	r3, [r7, #24]
 801bfd0:	885b      	ldrh	r3, [r3, #2]
 801bfd2:	b29b      	uxth	r3, r3
 801bfd4:	8efa      	ldrh	r2, [r7, #54]	@ 0x36
 801bfd6:	429a      	cmp	r2, r3
 801bfd8:	d17e      	bne.n	801c0d8 <hci_send_req+0x1e8>
          goto failed;
        
        if (r->event != EVT_CMD_STATUS) {
 801bfda:	687b      	ldr	r3, [r7, #4]
 801bfdc:	689b      	ldr	r3, [r3, #8]
 801bfde:	2b0f      	cmp	r3, #15
 801bfe0:	d004      	beq.n	801bfec <hci_send_req+0xfc>
          if (cs->status) {
 801bfe2:	69bb      	ldr	r3, [r7, #24]
 801bfe4:	781b      	ldrb	r3, [r3, #0]
 801bfe6:	2b00      	cmp	r3, #0
 801bfe8:	d051      	beq.n	801c08e <hci_send_req+0x19e>
            goto failed;
 801bfea:	e078      	b.n	801c0de <hci_send_req+0x1ee>
          }
          break;
        }

        r->rlen = MIN(len, r->rlen);
 801bfec:	687b      	ldr	r3, [r7, #4]
 801bfee:	699a      	ldr	r2, [r3, #24]
 801bff0:	6a3b      	ldr	r3, [r7, #32]
 801bff2:	429a      	cmp	r2, r3
 801bff4:	bf28      	it	cs
 801bff6:	461a      	movcs	r2, r3
 801bff8:	687b      	ldr	r3, [r7, #4]
 801bffa:	619a      	str	r2, [r3, #24]
        BLUENRG_memcpy(r->rparam, ptr, r->rlen);
 801bffc:	687b      	ldr	r3, [r7, #4]
 801bffe:	6958      	ldr	r0, [r3, #20]
 801c000:	687b      	ldr	r3, [r7, #4]
 801c002:	699b      	ldr	r3, [r3, #24]
 801c004:	461a      	mov	r2, r3
 801c006:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 801c008:	f008 f8f1 	bl	80241ee <memcpy>
        goto done;
 801c00c:	e078      	b.n	801c100 <hci_send_req+0x210>
      
      case EVT_CMD_COMPLETE:
        cc = (void *) ptr;
 801c00e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801c010:	617b      	str	r3, [r7, #20]
      
        if (cc->opcode != opcode)
 801c012:	697b      	ldr	r3, [r7, #20]
 801c014:	f8b3 3001 	ldrh.w	r3, [r3, #1]
 801c018:	b29b      	uxth	r3, r3
 801c01a:	8efa      	ldrh	r2, [r7, #54]	@ 0x36
 801c01c:	429a      	cmp	r2, r3
 801c01e:	d15d      	bne.n	801c0dc <hci_send_req+0x1ec>
          goto failed;
      
        ptr += EVT_CMD_COMPLETE_SIZE;
 801c020:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801c022:	3303      	adds	r3, #3
 801c024:	627b      	str	r3, [r7, #36]	@ 0x24
        len -= EVT_CMD_COMPLETE_SIZE;
 801c026:	6a3b      	ldr	r3, [r7, #32]
 801c028:	3b03      	subs	r3, #3
 801c02a:	623b      	str	r3, [r7, #32]
      
        r->rlen = MIN(len, r->rlen);
 801c02c:	687b      	ldr	r3, [r7, #4]
 801c02e:	699a      	ldr	r2, [r3, #24]
 801c030:	6a3b      	ldr	r3, [r7, #32]
 801c032:	429a      	cmp	r2, r3
 801c034:	bf28      	it	cs
 801c036:	461a      	movcs	r2, r3
 801c038:	687b      	ldr	r3, [r7, #4]
 801c03a:	619a      	str	r2, [r3, #24]
        BLUENRG_memcpy(r->rparam, ptr, r->rlen);
 801c03c:	687b      	ldr	r3, [r7, #4]
 801c03e:	6958      	ldr	r0, [r3, #20]
 801c040:	687b      	ldr	r3, [r7, #4]
 801c042:	699b      	ldr	r3, [r3, #24]
 801c044:	461a      	mov	r2, r3
 801c046:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 801c048:	f008 f8d1 	bl	80241ee <memcpy>
        goto done;
 801c04c:	e058      	b.n	801c100 <hci_send_req+0x210>
      
      case EVT_LE_META_EVENT:
        me = (void *) ptr;
 801c04e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801c050:	61fb      	str	r3, [r7, #28]
      
        if (me->subevent != r->event)
 801c052:	69fb      	ldr	r3, [r7, #28]
 801c054:	781b      	ldrb	r3, [r3, #0]
 801c056:	461a      	mov	r2, r3
 801c058:	687b      	ldr	r3, [r7, #4]
 801c05a:	689b      	ldr	r3, [r3, #8]
 801c05c:	429a      	cmp	r2, r3
 801c05e:	d118      	bne.n	801c092 <hci_send_req+0x1a2>
          break;
      
        len -= 1;
 801c060:	6a3b      	ldr	r3, [r7, #32]
 801c062:	3b01      	subs	r3, #1
 801c064:	623b      	str	r3, [r7, #32]
        r->rlen = MIN(len, r->rlen);
 801c066:	687b      	ldr	r3, [r7, #4]
 801c068:	699a      	ldr	r2, [r3, #24]
 801c06a:	6a3b      	ldr	r3, [r7, #32]
 801c06c:	429a      	cmp	r2, r3
 801c06e:	bf28      	it	cs
 801c070:	461a      	movcs	r2, r3
 801c072:	687b      	ldr	r3, [r7, #4]
 801c074:	619a      	str	r2, [r3, #24]
        BLUENRG_memcpy(r->rparam, me->data, r->rlen);
 801c076:	687b      	ldr	r3, [r7, #4]
 801c078:	6958      	ldr	r0, [r3, #20]
 801c07a:	69fb      	ldr	r3, [r7, #28]
 801c07c:	1c59      	adds	r1, r3, #1
 801c07e:	687b      	ldr	r3, [r7, #4]
 801c080:	699b      	ldr	r3, [r3, #24]
 801c082:	461a      	mov	r2, r3
 801c084:	f008 f8b3 	bl	80241ee <memcpy>
        goto done;
 801c088:	e03a      	b.n	801c100 <hci_send_req+0x210>
      
      case EVT_HARDWARE_ERROR:            
        goto failed;
      
      default:      
        break;
 801c08a:	bf00      	nop
 801c08c:	e002      	b.n	801c094 <hci_send_req+0x1a4>
          break;
 801c08e:	bf00      	nop
 801c090:	e000      	b.n	801c094 <hci_send_req+0x1a4>
          break;
 801c092:	bf00      	nop
    
    /* If there are no more packets to be processed, be sure there is at list one
       packet in the pool to process the expected event.
       If no free packets are available, discard the processed event and insert it
       into the pool. */
    if (list_is_empty(&hciReadPktPool) && list_is_empty(&hciReadPktRxQueue)) {
 801c094:	4823      	ldr	r0, [pc, #140]	@ (801c124 <hci_send_req+0x234>)
 801c096:	f000 f8d3 	bl	801c240 <list_is_empty>
 801c09a:	4603      	mov	r3, r0
 801c09c:	2b00      	cmp	r3, #0
 801c09e:	d00d      	beq.n	801c0bc <hci_send_req+0x1cc>
 801c0a0:	481f      	ldr	r0, [pc, #124]	@ (801c120 <hci_send_req+0x230>)
 801c0a2:	f000 f8cd 	bl	801c240 <list_is_empty>
 801c0a6:	4603      	mov	r3, r0
 801c0a8:	2b00      	cmp	r3, #0
 801c0aa:	d007      	beq.n	801c0bc <hci_send_req+0x1cc>
      list_insert_tail(&hciReadPktPool, (tListNode *)hciReadPacket);
 801c0ac:	693b      	ldr	r3, [r7, #16]
 801c0ae:	4619      	mov	r1, r3
 801c0b0:	481c      	ldr	r0, [pc, #112]	@ (801c124 <hci_send_req+0x234>)
 801c0b2:	f000 f90d 	bl	801c2d0 <list_insert_tail>
      hciReadPacket=NULL;
 801c0b6:	2300      	movs	r3, #0
 801c0b8:	613b      	str	r3, [r7, #16]
 801c0ba:	e008      	b.n	801c0ce <hci_send_req+0x1de>
    else {
      /* Insert the packet in a different queue. These packets will be
      inserted back in the main queue just before exiting from send_req(), so that
      these events can be processed by the application.
    */
    list_insert_tail(&hciTempQueue, (tListNode *)hciReadPacket);
 801c0bc:	693a      	ldr	r2, [r7, #16]
 801c0be:	f107 0308 	add.w	r3, r7, #8
 801c0c2:	4611      	mov	r1, r2
 801c0c4:	4618      	mov	r0, r3
 801c0c6:	f000 f903 	bl	801c2d0 <list_insert_tail>
      hciReadPacket=NULL;
 801c0ca:	2300      	movs	r3, #0
 801c0cc:	613b      	str	r3, [r7, #16]
  {
 801c0ce:	e740      	b.n	801bf52 <hci_send_req+0x62>
        goto failed;
 801c0d0:	bf00      	nop
 801c0d2:	e004      	b.n	801c0de <hci_send_req+0x1ee>
        goto failed;
 801c0d4:	bf00      	nop
 801c0d6:	e002      	b.n	801c0de <hci_send_req+0x1ee>
          goto failed;
 801c0d8:	bf00      	nop
 801c0da:	e000      	b.n	801c0de <hci_send_req+0x1ee>
          goto failed;
 801c0dc:	bf00      	nop
    }
  }
  
failed: 
  if (hciReadPacket!=NULL) {
 801c0de:	693b      	ldr	r3, [r7, #16]
 801c0e0:	2b00      	cmp	r3, #0
 801c0e2:	d004      	beq.n	801c0ee <hci_send_req+0x1fe>
    list_insert_head(&hciReadPktPool, (tListNode *)hciReadPacket);
 801c0e4:	693b      	ldr	r3, [r7, #16]
 801c0e6:	4619      	mov	r1, r3
 801c0e8:	480e      	ldr	r0, [pc, #56]	@ (801c124 <hci_send_req+0x234>)
 801c0ea:	f000 f8cb 	bl	801c284 <list_insert_head>
  }
  move_list(&hciReadPktRxQueue, &hciTempQueue);
 801c0ee:	f107 0308 	add.w	r3, r7, #8
 801c0f2:	4619      	mov	r1, r3
 801c0f4:	480a      	ldr	r0, [pc, #40]	@ (801c120 <hci_send_req+0x230>)
 801c0f6:	f7ff fe5f 	bl	801bdb8 <move_list>

  return -1;
 801c0fa:	f04f 33ff 	mov.w	r3, #4294967295
 801c0fe:	e00b      	b.n	801c118 <hci_send_req+0x228>
  
done:
  /* Insert the packet back into the pool.*/
  list_insert_head(&hciReadPktPool, (tListNode *)hciReadPacket); 
 801c100:	693b      	ldr	r3, [r7, #16]
 801c102:	4619      	mov	r1, r3
 801c104:	4807      	ldr	r0, [pc, #28]	@ (801c124 <hci_send_req+0x234>)
 801c106:	f000 f8bd 	bl	801c284 <list_insert_head>
  move_list(&hciReadPktRxQueue, &hciTempQueue);
 801c10a:	f107 0308 	add.w	r3, r7, #8
 801c10e:	4619      	mov	r1, r3
 801c110:	4803      	ldr	r0, [pc, #12]	@ (801c120 <hci_send_req+0x230>)
 801c112:	f7ff fe51 	bl	801bdb8 <move_list>

  return 0;
 801c116:	2300      	movs	r3, #0
}
 801c118:	4618      	mov	r0, r3
 801c11a:	373c      	adds	r7, #60	@ 0x3c
 801c11c:	46bd      	mov	sp, r7
 801c11e:	bd90      	pop	{r4, r7, pc}
 801c120:	20000de4 	.word	0x20000de4
 801c124:	20000ddc 	.word	0x20000ddc

0801c128 <hci_user_evt_proc>:

void hci_user_evt_proc(void)
{
 801c128:	b580      	push	{r7, lr}
 801c12a:	b082      	sub	sp, #8
 801c12c:	af00      	add	r7, sp, #0
  tHciDataPacket * hciReadPacket = NULL;
 801c12e:	2300      	movs	r3, #0
 801c130:	607b      	str	r3, [r7, #4]
     
  /* process any pending events read */
  while (list_is_empty(&hciReadPktRxQueue) == FALSE)
 801c132:	e013      	b.n	801c15c <hci_user_evt_proc+0x34>
  {
    list_remove_head (&hciReadPktRxQueue, (tListNode **)&hciReadPacket);
 801c134:	1d3b      	adds	r3, r7, #4
 801c136:	4619      	mov	r1, r3
 801c138:	480e      	ldr	r0, [pc, #56]	@ (801c174 <hci_user_evt_proc+0x4c>)
 801c13a:	f000 f910 	bl	801c35e <list_remove_head>

    if (hciContext.UserEvtRx != NULL)
 801c13e:	4b0e      	ldr	r3, [pc, #56]	@ (801c178 <hci_user_evt_proc+0x50>)
 801c140:	69db      	ldr	r3, [r3, #28]
 801c142:	2b00      	cmp	r3, #0
 801c144:	d005      	beq.n	801c152 <hci_user_evt_proc+0x2a>
    {
      hciContext.UserEvtRx(hciReadPacket->dataBuff);
 801c146:	4b0c      	ldr	r3, [pc, #48]	@ (801c178 <hci_user_evt_proc+0x50>)
 801c148:	69db      	ldr	r3, [r3, #28]
 801c14a:	687a      	ldr	r2, [r7, #4]
 801c14c:	3208      	adds	r2, #8
 801c14e:	4610      	mov	r0, r2
 801c150:	4798      	blx	r3
    }

    list_insert_tail(&hciReadPktPool, (tListNode *)hciReadPacket);
 801c152:	687b      	ldr	r3, [r7, #4]
 801c154:	4619      	mov	r1, r3
 801c156:	4809      	ldr	r0, [pc, #36]	@ (801c17c <hci_user_evt_proc+0x54>)
 801c158:	f000 f8ba 	bl	801c2d0 <list_insert_tail>
  while (list_is_empty(&hciReadPktRxQueue) == FALSE)
 801c15c:	4805      	ldr	r0, [pc, #20]	@ (801c174 <hci_user_evt_proc+0x4c>)
 801c15e:	f000 f86f 	bl	801c240 <list_is_empty>
 801c162:	4603      	mov	r3, r0
 801c164:	2b00      	cmp	r3, #0
 801c166:	d0e5      	beq.n	801c134 <hci_user_evt_proc+0xc>
  }
}
 801c168:	bf00      	nop
 801c16a:	bf00      	nop
 801c16c:	3708      	adds	r7, #8
 801c16e:	46bd      	mov	sp, r7
 801c170:	bd80      	pop	{r7, pc}
 801c172:	bf00      	nop
 801c174:	20000de4 	.word	0x20000de4
 801c178:	2000188c 	.word	0x2000188c
 801c17c:	20000ddc 	.word	0x20000ddc

0801c180 <hci_notify_asynch_evt>:

int32_t hci_notify_asynch_evt(void* pdata)
{
 801c180:	b580      	push	{r7, lr}
 801c182:	b086      	sub	sp, #24
 801c184:	af00      	add	r7, sp, #0
 801c186:	6078      	str	r0, [r7, #4]
  tHciDataPacket * hciReadPacket = NULL;
 801c188:	2300      	movs	r3, #0
 801c18a:	60fb      	str	r3, [r7, #12]
  uint16_t data_len;
  
  int32_t ret = 0;
 801c18c:	2300      	movs	r3, #0
 801c18e:	617b      	str	r3, [r7, #20]
  
  if (list_is_empty (&hciReadPktPool) == FALSE)
 801c190:	4820      	ldr	r0, [pc, #128]	@ (801c214 <hci_notify_asynch_evt+0x94>)
 801c192:	f000 f855 	bl	801c240 <list_is_empty>
 801c196:	4603      	mov	r3, r0
 801c198:	2b00      	cmp	r3, #0
 801c19a:	d133      	bne.n	801c204 <hci_notify_asynch_evt+0x84>
  {
    /* Queuing a packet to read */
    list_remove_head (&hciReadPktPool, (tListNode **)&hciReadPacket);
 801c19c:	f107 030c 	add.w	r3, r7, #12
 801c1a0:	4619      	mov	r1, r3
 801c1a2:	481c      	ldr	r0, [pc, #112]	@ (801c214 <hci_notify_asynch_evt+0x94>)
 801c1a4:	f000 f8db 	bl	801c35e <list_remove_head>
    
    if (hciContext.io.Receive)
 801c1a8:	4b1b      	ldr	r3, [pc, #108]	@ (801c218 <hci_notify_asynch_evt+0x98>)
 801c1aa:	68db      	ldr	r3, [r3, #12]
 801c1ac:	2b00      	cmp	r3, #0
 801c1ae:	d02b      	beq.n	801c208 <hci_notify_asynch_evt+0x88>
    {
      data_len = hciContext.io.Receive(hciReadPacket->dataBuff, HCI_READ_PACKET_SIZE);
 801c1b0:	4b19      	ldr	r3, [pc, #100]	@ (801c218 <hci_notify_asynch_evt+0x98>)
 801c1b2:	68db      	ldr	r3, [r3, #12]
 801c1b4:	68fa      	ldr	r2, [r7, #12]
 801c1b6:	3208      	adds	r2, #8
 801c1b8:	f44f 7182 	mov.w	r1, #260	@ 0x104
 801c1bc:	4610      	mov	r0, r2
 801c1be:	4798      	blx	r3
 801c1c0:	4603      	mov	r3, r0
 801c1c2:	827b      	strh	r3, [r7, #18]
      if (data_len > 0)
 801c1c4:	8a7b      	ldrh	r3, [r7, #18]
 801c1c6:	2b00      	cmp	r3, #0
 801c1c8:	d016      	beq.n	801c1f8 <hci_notify_asynch_evt+0x78>
      {                    
        hciReadPacket->data_len = data_len;
 801c1ca:	68fb      	ldr	r3, [r7, #12]
 801c1cc:	8a7a      	ldrh	r2, [r7, #18]
 801c1ce:	f8a3 210c 	strh.w	r2, [r3, #268]	@ 0x10c
        if (verify_packet(hciReadPacket) == 0)
 801c1d2:	68fb      	ldr	r3, [r7, #12]
 801c1d4:	4618      	mov	r0, r3
 801c1d6:	f7ff fce0 	bl	801bb9a <verify_packet>
 801c1da:	4603      	mov	r3, r0
 801c1dc:	2b00      	cmp	r3, #0
 801c1de:	d105      	bne.n	801c1ec <hci_notify_asynch_evt+0x6c>
          list_insert_tail(&hciReadPktRxQueue, (tListNode *)hciReadPacket);
 801c1e0:	68fb      	ldr	r3, [r7, #12]
 801c1e2:	4619      	mov	r1, r3
 801c1e4:	480d      	ldr	r0, [pc, #52]	@ (801c21c <hci_notify_asynch_evt+0x9c>)
 801c1e6:	f000 f873 	bl	801c2d0 <list_insert_tail>
 801c1ea:	e00d      	b.n	801c208 <hci_notify_asynch_evt+0x88>
        else
          list_insert_head(&hciReadPktPool, (tListNode *)hciReadPacket);          
 801c1ec:	68fb      	ldr	r3, [r7, #12]
 801c1ee:	4619      	mov	r1, r3
 801c1f0:	4808      	ldr	r0, [pc, #32]	@ (801c214 <hci_notify_asynch_evt+0x94>)
 801c1f2:	f000 f847 	bl	801c284 <list_insert_head>
 801c1f6:	e007      	b.n	801c208 <hci_notify_asynch_evt+0x88>
      }
      else 
      {
        /* Insert the packet back into the pool*/
        list_insert_head(&hciReadPktPool, (tListNode *)hciReadPacket);
 801c1f8:	68fb      	ldr	r3, [r7, #12]
 801c1fa:	4619      	mov	r1, r3
 801c1fc:	4805      	ldr	r0, [pc, #20]	@ (801c214 <hci_notify_asynch_evt+0x94>)
 801c1fe:	f000 f841 	bl	801c284 <list_insert_head>
 801c202:	e001      	b.n	801c208 <hci_notify_asynch_evt+0x88>
      }
    }
  }
  else 
  {
    ret = 1;
 801c204:	2301      	movs	r3, #1
 801c206:	617b      	str	r3, [r7, #20]
  }
  return ret;
 801c208:	697b      	ldr	r3, [r7, #20]
  
}
 801c20a:	4618      	mov	r0, r3
 801c20c:	3718      	adds	r7, #24
 801c20e:	46bd      	mov	sp, r7
 801c210:	bd80      	pop	{r7, pc}
 801c212:	bf00      	nop
 801c214:	20000ddc 	.word	0x20000ddc
 801c218:	2000188c 	.word	0x2000188c
 801c21c:	20000de4 	.word	0x20000de4

0801c220 <list_init_head>:

/******************************************************************************
 * Function Definitions 
******************************************************************************/
void list_init_head (tListNode * listHead)
{
 801c220:	b480      	push	{r7}
 801c222:	b083      	sub	sp, #12
 801c224:	af00      	add	r7, sp, #0
 801c226:	6078      	str	r0, [r7, #4]
  listHead->next = listHead;
 801c228:	687b      	ldr	r3, [r7, #4]
 801c22a:	687a      	ldr	r2, [r7, #4]
 801c22c:	601a      	str	r2, [r3, #0]
  listHead->prev = listHead;	
 801c22e:	687b      	ldr	r3, [r7, #4]
 801c230:	687a      	ldr	r2, [r7, #4]
 801c232:	605a      	str	r2, [r3, #4]
}
 801c234:	bf00      	nop
 801c236:	370c      	adds	r7, #12
 801c238:	46bd      	mov	sp, r7
 801c23a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c23e:	4770      	bx	lr

0801c240 <list_is_empty>:

uint8_t list_is_empty (tListNode * listHead)
{
 801c240:	b480      	push	{r7}
 801c242:	b087      	sub	sp, #28
 801c244:	af00      	add	r7, sp, #0
 801c246:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 801c248:	f3ef 8310 	mrs	r3, PRIMASK
 801c24c:	60fb      	str	r3, [r7, #12]
  return(result);
 801c24e:	68fb      	ldr	r3, [r7, #12]
  uint8_t return_value;
  
  uint32_t uwPRIMASK_Bit;
  uwPRIMASK_Bit = __get_PRIMASK();  /**< backup PRIMASK bit */
 801c250:	613b      	str	r3, [r7, #16]
  __ASM volatile ("cpsid i" : : : "memory");
 801c252:	b672      	cpsid	i
}
 801c254:	bf00      	nop
  __disable_irq();                  /**< Disable all interrupts by setting PRIMASK bit on Cortex*/
   
  if(listHead->next == listHead)
 801c256:	687b      	ldr	r3, [r7, #4]
 801c258:	681b      	ldr	r3, [r3, #0]
 801c25a:	687a      	ldr	r2, [r7, #4]
 801c25c:	429a      	cmp	r2, r3
 801c25e:	d102      	bne.n	801c266 <list_is_empty+0x26>
  {
    return_value = 1;
 801c260:	2301      	movs	r3, #1
 801c262:	75fb      	strb	r3, [r7, #23]
 801c264:	e001      	b.n	801c26a <list_is_empty+0x2a>
  }
  else
  {
    return_value = 0;
 801c266:	2300      	movs	r3, #0
 801c268:	75fb      	strb	r3, [r7, #23]
 801c26a:	693b      	ldr	r3, [r7, #16]
 801c26c:	60bb      	str	r3, [r7, #8]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 801c26e:	68bb      	ldr	r3, [r7, #8]
 801c270:	f383 8810 	msr	PRIMASK, r3
}
 801c274:	bf00      	nop
  }
  
  __set_PRIMASK(uwPRIMASK_Bit);     /**< Restore PRIMASK bit*/
  
  return return_value;
 801c276:	7dfb      	ldrb	r3, [r7, #23]
}
 801c278:	4618      	mov	r0, r3
 801c27a:	371c      	adds	r7, #28
 801c27c:	46bd      	mov	sp, r7
 801c27e:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c282:	4770      	bx	lr

0801c284 <list_insert_head>:

void list_insert_head (tListNode * listHead, tListNode * node)
{
 801c284:	b480      	push	{r7}
 801c286:	b087      	sub	sp, #28
 801c288:	af00      	add	r7, sp, #0
 801c28a:	6078      	str	r0, [r7, #4]
 801c28c:	6039      	str	r1, [r7, #0]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 801c28e:	f3ef 8310 	mrs	r3, PRIMASK
 801c292:	60fb      	str	r3, [r7, #12]
  return(result);
 801c294:	68fb      	ldr	r3, [r7, #12]
  uint32_t uwPRIMASK_Bit;
  uwPRIMASK_Bit = __get_PRIMASK();  /**< backup PRIMASK bit */
 801c296:	617b      	str	r3, [r7, #20]
  __ASM volatile ("cpsid i" : : : "memory");
 801c298:	b672      	cpsid	i
}
 801c29a:	bf00      	nop
  __disable_irq();                  /**< Disable all interrupts by setting PRIMASK bit on Cortex*/
  
  node->next = listHead->next;
 801c29c:	687b      	ldr	r3, [r7, #4]
 801c29e:	681a      	ldr	r2, [r3, #0]
 801c2a0:	683b      	ldr	r3, [r7, #0]
 801c2a2:	601a      	str	r2, [r3, #0]
  node->prev = listHead;
 801c2a4:	683b      	ldr	r3, [r7, #0]
 801c2a6:	687a      	ldr	r2, [r7, #4]
 801c2a8:	605a      	str	r2, [r3, #4]
  listHead->next = node;
 801c2aa:	687b      	ldr	r3, [r7, #4]
 801c2ac:	683a      	ldr	r2, [r7, #0]
 801c2ae:	601a      	str	r2, [r3, #0]
  (node->next)->prev = node;
 801c2b0:	683b      	ldr	r3, [r7, #0]
 801c2b2:	681b      	ldr	r3, [r3, #0]
 801c2b4:	683a      	ldr	r2, [r7, #0]
 801c2b6:	605a      	str	r2, [r3, #4]
 801c2b8:	697b      	ldr	r3, [r7, #20]
 801c2ba:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 801c2bc:	693b      	ldr	r3, [r7, #16]
 801c2be:	f383 8810 	msr	PRIMASK, r3
}
 801c2c2:	bf00      	nop
  
  __set_PRIMASK(uwPRIMASK_Bit);     /**< Restore PRIMASK bit*/
}
 801c2c4:	bf00      	nop
 801c2c6:	371c      	adds	r7, #28
 801c2c8:	46bd      	mov	sp, r7
 801c2ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c2ce:	4770      	bx	lr

0801c2d0 <list_insert_tail>:

void list_insert_tail (tListNode * listHead, tListNode * node)
{
 801c2d0:	b480      	push	{r7}
 801c2d2:	b087      	sub	sp, #28
 801c2d4:	af00      	add	r7, sp, #0
 801c2d6:	6078      	str	r0, [r7, #4]
 801c2d8:	6039      	str	r1, [r7, #0]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 801c2da:	f3ef 8310 	mrs	r3, PRIMASK
 801c2de:	60fb      	str	r3, [r7, #12]
  return(result);
 801c2e0:	68fb      	ldr	r3, [r7, #12]
  uint32_t uwPRIMASK_Bit;
  uwPRIMASK_Bit = __get_PRIMASK();  /**< backup PRIMASK bit */
 801c2e2:	617b      	str	r3, [r7, #20]
  __ASM volatile ("cpsid i" : : : "memory");
 801c2e4:	b672      	cpsid	i
}
 801c2e6:	bf00      	nop
  __disable_irq();                  /**< Disable all interrupts by setting PRIMASK bit on Cortex*/
  
  node->next = listHead;
 801c2e8:	683b      	ldr	r3, [r7, #0]
 801c2ea:	687a      	ldr	r2, [r7, #4]
 801c2ec:	601a      	str	r2, [r3, #0]
  node->prev = listHead->prev;
 801c2ee:	687b      	ldr	r3, [r7, #4]
 801c2f0:	685a      	ldr	r2, [r3, #4]
 801c2f2:	683b      	ldr	r3, [r7, #0]
 801c2f4:	605a      	str	r2, [r3, #4]
  listHead->prev = node;
 801c2f6:	687b      	ldr	r3, [r7, #4]
 801c2f8:	683a      	ldr	r2, [r7, #0]
 801c2fa:	605a      	str	r2, [r3, #4]
  (node->prev)->next = node;
 801c2fc:	683b      	ldr	r3, [r7, #0]
 801c2fe:	685b      	ldr	r3, [r3, #4]
 801c300:	683a      	ldr	r2, [r7, #0]
 801c302:	601a      	str	r2, [r3, #0]
 801c304:	697b      	ldr	r3, [r7, #20]
 801c306:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 801c308:	693b      	ldr	r3, [r7, #16]
 801c30a:	f383 8810 	msr	PRIMASK, r3
}
 801c30e:	bf00      	nop
  
  __set_PRIMASK(uwPRIMASK_Bit);     /**< Restore PRIMASK bit*/
}
 801c310:	bf00      	nop
 801c312:	371c      	adds	r7, #28
 801c314:	46bd      	mov	sp, r7
 801c316:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c31a:	4770      	bx	lr

0801c31c <list_remove_node>:

void list_remove_node (tListNode * node)
{
 801c31c:	b480      	push	{r7}
 801c31e:	b087      	sub	sp, #28
 801c320:	af00      	add	r7, sp, #0
 801c322:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 801c324:	f3ef 8310 	mrs	r3, PRIMASK
 801c328:	60fb      	str	r3, [r7, #12]
  return(result);
 801c32a:	68fb      	ldr	r3, [r7, #12]
  uint32_t uwPRIMASK_Bit;
  uwPRIMASK_Bit = __get_PRIMASK();  /**< backup PRIMASK bit */
 801c32c:	617b      	str	r3, [r7, #20]
  __ASM volatile ("cpsid i" : : : "memory");
 801c32e:	b672      	cpsid	i
}
 801c330:	bf00      	nop
  __disable_irq();                  /**< Disable all interrupts by setting PRIMASK bit on Cortex*/
  
  (node->prev)->next = node->next;
 801c332:	687b      	ldr	r3, [r7, #4]
 801c334:	685b      	ldr	r3, [r3, #4]
 801c336:	687a      	ldr	r2, [r7, #4]
 801c338:	6812      	ldr	r2, [r2, #0]
 801c33a:	601a      	str	r2, [r3, #0]
  (node->next)->prev = node->prev;
 801c33c:	687b      	ldr	r3, [r7, #4]
 801c33e:	681b      	ldr	r3, [r3, #0]
 801c340:	687a      	ldr	r2, [r7, #4]
 801c342:	6852      	ldr	r2, [r2, #4]
 801c344:	605a      	str	r2, [r3, #4]
 801c346:	697b      	ldr	r3, [r7, #20]
 801c348:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 801c34a:	693b      	ldr	r3, [r7, #16]
 801c34c:	f383 8810 	msr	PRIMASK, r3
}
 801c350:	bf00      	nop
  
  __set_PRIMASK(uwPRIMASK_Bit);     /**< Restore PRIMASK bit*/
}
 801c352:	bf00      	nop
 801c354:	371c      	adds	r7, #28
 801c356:	46bd      	mov	sp, r7
 801c358:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c35c:	4770      	bx	lr

0801c35e <list_remove_head>:

void list_remove_head (tListNode * listHead, tListNode ** node )
{
 801c35e:	b580      	push	{r7, lr}
 801c360:	b086      	sub	sp, #24
 801c362:	af00      	add	r7, sp, #0
 801c364:	6078      	str	r0, [r7, #4]
 801c366:	6039      	str	r1, [r7, #0]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 801c368:	f3ef 8310 	mrs	r3, PRIMASK
 801c36c:	60fb      	str	r3, [r7, #12]
  return(result);
 801c36e:	68fb      	ldr	r3, [r7, #12]
  uint32_t uwPRIMASK_Bit;
  uwPRIMASK_Bit = __get_PRIMASK();  /**< backup PRIMASK bit */
 801c370:	617b      	str	r3, [r7, #20]
  __ASM volatile ("cpsid i" : : : "memory");
 801c372:	b672      	cpsid	i
}
 801c374:	bf00      	nop
  __disable_irq();                  /**< Disable all interrupts by setting PRIMASK bit on Cortex*/
  
  *node = listHead->next;
 801c376:	687b      	ldr	r3, [r7, #4]
 801c378:	681a      	ldr	r2, [r3, #0]
 801c37a:	683b      	ldr	r3, [r7, #0]
 801c37c:	601a      	str	r2, [r3, #0]
  list_remove_node (listHead->next);
 801c37e:	687b      	ldr	r3, [r7, #4]
 801c380:	681b      	ldr	r3, [r3, #0]
 801c382:	4618      	mov	r0, r3
 801c384:	f7ff ffca 	bl	801c31c <list_remove_node>
  (*node)->next = NULL;
 801c388:	683b      	ldr	r3, [r7, #0]
 801c38a:	681b      	ldr	r3, [r3, #0]
 801c38c:	2200      	movs	r2, #0
 801c38e:	601a      	str	r2, [r3, #0]
  (*node)->prev = NULL;
 801c390:	683b      	ldr	r3, [r7, #0]
 801c392:	681b      	ldr	r3, [r3, #0]
 801c394:	2200      	movs	r2, #0
 801c396:	605a      	str	r2, [r3, #4]
 801c398:	697b      	ldr	r3, [r7, #20]
 801c39a:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 801c39c:	693b      	ldr	r3, [r7, #16]
 801c39e:	f383 8810 	msr	PRIMASK, r3
}
 801c3a2:	bf00      	nop
  
  __set_PRIMASK(uwPRIMASK_Bit);     /**< Restore PRIMASK bit*/
}
 801c3a4:	bf00      	nop
 801c3a6:	3718      	adds	r7, #24
 801c3a8:	46bd      	mov	sp, r7
 801c3aa:	bd80      	pop	{r7, pc}

0801c3ac <list_remove_tail>:

void list_remove_tail (tListNode * listHead, tListNode ** node )
{
 801c3ac:	b580      	push	{r7, lr}
 801c3ae:	b086      	sub	sp, #24
 801c3b0:	af00      	add	r7, sp, #0
 801c3b2:	6078      	str	r0, [r7, #4]
 801c3b4:	6039      	str	r1, [r7, #0]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 801c3b6:	f3ef 8310 	mrs	r3, PRIMASK
 801c3ba:	60fb      	str	r3, [r7, #12]
  return(result);
 801c3bc:	68fb      	ldr	r3, [r7, #12]
  uint32_t uwPRIMASK_Bit;
  uwPRIMASK_Bit = __get_PRIMASK();  /**< backup PRIMASK bit */
 801c3be:	617b      	str	r3, [r7, #20]
  __ASM volatile ("cpsid i" : : : "memory");
 801c3c0:	b672      	cpsid	i
}
 801c3c2:	bf00      	nop
  __disable_irq();                  /**< Disable all interrupts by setting PRIMASK bit on Cortex*/
  
  *node = listHead->prev;
 801c3c4:	687b      	ldr	r3, [r7, #4]
 801c3c6:	685a      	ldr	r2, [r3, #4]
 801c3c8:	683b      	ldr	r3, [r7, #0]
 801c3ca:	601a      	str	r2, [r3, #0]
  list_remove_node (listHead->prev);
 801c3cc:	687b      	ldr	r3, [r7, #4]
 801c3ce:	685b      	ldr	r3, [r3, #4]
 801c3d0:	4618      	mov	r0, r3
 801c3d2:	f7ff ffa3 	bl	801c31c <list_remove_node>
  (*node)->next = NULL;
 801c3d6:	683b      	ldr	r3, [r7, #0]
 801c3d8:	681b      	ldr	r3, [r3, #0]
 801c3da:	2200      	movs	r2, #0
 801c3dc:	601a      	str	r2, [r3, #0]
  (*node)->prev = NULL;
 801c3de:	683b      	ldr	r3, [r7, #0]
 801c3e0:	681b      	ldr	r3, [r3, #0]
 801c3e2:	2200      	movs	r2, #0
 801c3e4:	605a      	str	r2, [r3, #4]
 801c3e6:	697b      	ldr	r3, [r7, #20]
 801c3e8:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 801c3ea:	693b      	ldr	r3, [r7, #16]
 801c3ec:	f383 8810 	msr	PRIMASK, r3
}
 801c3f0:	bf00      	nop
  
  __set_PRIMASK(uwPRIMASK_Bit);     /**< Restore PRIMASK bit*/
}
 801c3f2:	bf00      	nop
 801c3f4:	3718      	adds	r7, #24
 801c3f6:	46bd      	mov	sp, r7
 801c3f8:	bd80      	pop	{r7, pc}

0801c3fa <list_get_size>:
  
  __set_PRIMASK(uwPRIMASK_Bit);     /**< Restore PRIMASK bit*/
}

int list_get_size (tListNode * listHead)
{
 801c3fa:	b480      	push	{r7}
 801c3fc:	b089      	sub	sp, #36	@ 0x24
 801c3fe:	af00      	add	r7, sp, #0
 801c400:	6078      	str	r0, [r7, #4]
  int size = 0;
 801c402:	2300      	movs	r3, #0
 801c404:	61fb      	str	r3, [r7, #28]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 801c406:	f3ef 8310 	mrs	r3, PRIMASK
 801c40a:	613b      	str	r3, [r7, #16]
  return(result);
 801c40c:	693b      	ldr	r3, [r7, #16]
  tListNode * temp;

  uint32_t uwPRIMASK_Bit;
  uwPRIMASK_Bit = __get_PRIMASK();  /**< backup PRIMASK bit */
 801c40e:	617b      	str	r3, [r7, #20]
  __ASM volatile ("cpsid i" : : : "memory");
 801c410:	b672      	cpsid	i
}
 801c412:	bf00      	nop
  __disable_irq();                  /**< Disable all interrupts by setting PRIMASK bit on Cortex*/

  temp = listHead->next;
 801c414:	687b      	ldr	r3, [r7, #4]
 801c416:	681b      	ldr	r3, [r3, #0]
 801c418:	61bb      	str	r3, [r7, #24]
  while (temp != listHead)
 801c41a:	e005      	b.n	801c428 <list_get_size+0x2e>
  {
    size++;
 801c41c:	69fb      	ldr	r3, [r7, #28]
 801c41e:	3301      	adds	r3, #1
 801c420:	61fb      	str	r3, [r7, #28]
    temp = temp->next;		
 801c422:	69bb      	ldr	r3, [r7, #24]
 801c424:	681b      	ldr	r3, [r3, #0]
 801c426:	61bb      	str	r3, [r7, #24]
  while (temp != listHead)
 801c428:	69ba      	ldr	r2, [r7, #24]
 801c42a:	687b      	ldr	r3, [r7, #4]
 801c42c:	429a      	cmp	r2, r3
 801c42e:	d1f5      	bne.n	801c41c <list_get_size+0x22>
 801c430:	697b      	ldr	r3, [r7, #20]
 801c432:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 801c434:	68fb      	ldr	r3, [r7, #12]
 801c436:	f383 8810 	msr	PRIMASK, r3
}
 801c43a:	bf00      	nop
  }
  
  __set_PRIMASK(uwPRIMASK_Bit);     /**< Restore PRIMASK bit*/
  
  return (size);
 801c43c:	69fb      	ldr	r3, [r7, #28]
}
 801c43e:	4618      	mov	r0, r3
 801c440:	3724      	adds	r7, #36	@ 0x24
 801c442:	46bd      	mov	sp, r7
 801c444:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c448:	4770      	bx	lr

0801c44a <IPnPLComponentGetKey>:
};

// Inline functions definition
// ***************************
static inline char *IPnPLComponentGetKey(IPnPLComponent_t *_this)
{
 801c44a:	b580      	push	{r7, lr}
 801c44c:	b082      	sub	sp, #8
 801c44e:	af00      	add	r7, sp, #0
 801c450:	6078      	str	r0, [r7, #4]
  return _this->vptr->PnPLComponentGetKey(_this);
 801c452:	687b      	ldr	r3, [r7, #4]
 801c454:	681b      	ldr	r3, [r3, #0]
 801c456:	681b      	ldr	r3, [r3, #0]
 801c458:	6878      	ldr	r0, [r7, #4]
 801c45a:	4798      	blx	r3
 801c45c:	4603      	mov	r3, r0
}
 801c45e:	4618      	mov	r0, r3
 801c460:	3708      	adds	r7, #8
 801c462:	46bd      	mov	sp, r7
 801c464:	bd80      	pop	{r7, pc}

0801c466 <IPnPLComponentGetNCommands>:

static inline uint8_t IPnPLComponentGetNCommands(IPnPLComponent_t *_this)
{
 801c466:	b580      	push	{r7, lr}
 801c468:	b082      	sub	sp, #8
 801c46a:	af00      	add	r7, sp, #0
 801c46c:	6078      	str	r0, [r7, #4]
  return _this->vptr->PnPLComponentGetNCommands(_this);
 801c46e:	687b      	ldr	r3, [r7, #4]
 801c470:	681b      	ldr	r3, [r3, #0]
 801c472:	685b      	ldr	r3, [r3, #4]
 801c474:	6878      	ldr	r0, [r7, #4]
 801c476:	4798      	blx	r3
 801c478:	4603      	mov	r3, r0
}
 801c47a:	4618      	mov	r0, r3
 801c47c:	3708      	adds	r7, #8
 801c47e:	46bd      	mov	sp, r7
 801c480:	bd80      	pop	{r7, pc}

0801c482 <IPnPLComponentGetCommandKey>:

static inline char *IPnPLComponentGetCommandKey(IPnPLComponent_t *_this, uint8_t id)
{
 801c482:	b580      	push	{r7, lr}
 801c484:	b082      	sub	sp, #8
 801c486:	af00      	add	r7, sp, #0
 801c488:	6078      	str	r0, [r7, #4]
 801c48a:	460b      	mov	r3, r1
 801c48c:	70fb      	strb	r3, [r7, #3]
  return _this->vptr->PnPLComponentGetCommandsKey(_this, id);
 801c48e:	687b      	ldr	r3, [r7, #4]
 801c490:	681b      	ldr	r3, [r3, #0]
 801c492:	689b      	ldr	r3, [r3, #8]
 801c494:	78fa      	ldrb	r2, [r7, #3]
 801c496:	4611      	mov	r1, r2
 801c498:	6878      	ldr	r0, [r7, #4]
 801c49a:	4798      	blx	r3
 801c49c:	4603      	mov	r3, r0
}
 801c49e:	4618      	mov	r0, r3
 801c4a0:	3708      	adds	r7, #8
 801c4a2:	46bd      	mov	sp, r7
 801c4a4:	bd80      	pop	{r7, pc}

0801c4a6 <IPnPLComponentGetStatus>:

static inline uint8_t IPnPLComponentGetStatus(IPnPLComponent_t *_this, char **serializedJSON, uint32_t *size,
                                              uint8_t pretty)
{
 801c4a6:	b590      	push	{r4, r7, lr}
 801c4a8:	b085      	sub	sp, #20
 801c4aa:	af00      	add	r7, sp, #0
 801c4ac:	60f8      	str	r0, [r7, #12]
 801c4ae:	60b9      	str	r1, [r7, #8]
 801c4b0:	607a      	str	r2, [r7, #4]
 801c4b2:	70fb      	strb	r3, [r7, #3]
  return _this->vptr->PnPLComponentGetStatus(_this, serializedJSON, size, pretty);
 801c4b4:	68fb      	ldr	r3, [r7, #12]
 801c4b6:	681b      	ldr	r3, [r3, #0]
 801c4b8:	68dc      	ldr	r4, [r3, #12]
 801c4ba:	78fb      	ldrb	r3, [r7, #3]
 801c4bc:	687a      	ldr	r2, [r7, #4]
 801c4be:	68b9      	ldr	r1, [r7, #8]
 801c4c0:	68f8      	ldr	r0, [r7, #12]
 801c4c2:	47a0      	blx	r4
 801c4c4:	4603      	mov	r3, r0
}
 801c4c6:	4618      	mov	r0, r3
 801c4c8:	3714      	adds	r7, #20
 801c4ca:	46bd      	mov	sp, r7
 801c4cc:	bd90      	pop	{r4, r7, pc}

0801c4ce <IPnPLComponentSetProperty>:
  {
    return _this->vptr->PnPLCommandExecuteFunction(_this, serializedJSON, response, size, pretty);
  }
#else
  static inline uint8_t IPnPLComponentSetProperty(IPnPLComponent_t *_this, char *serializedJSON)
  {
 801c4ce:	b580      	push	{r7, lr}
 801c4d0:	b082      	sub	sp, #8
 801c4d2:	af00      	add	r7, sp, #0
 801c4d4:	6078      	str	r0, [r7, #4]
 801c4d6:	6039      	str	r1, [r7, #0]
    return _this->vptr->PnPLComponentSetProperty(_this, serializedJSON);
 801c4d8:	687b      	ldr	r3, [r7, #4]
 801c4da:	681b      	ldr	r3, [r3, #0]
 801c4dc:	691b      	ldr	r3, [r3, #16]
 801c4de:	6839      	ldr	r1, [r7, #0]
 801c4e0:	6878      	ldr	r0, [r7, #4]
 801c4e2:	4798      	blx	r3
 801c4e4:	4603      	mov	r3, r0
  }
 801c4e6:	4618      	mov	r0, r3
 801c4e8:	3708      	adds	r7, #8
 801c4ea:	46bd      	mov	sp, r7
 801c4ec:	bd80      	pop	{r7, pc}

0801c4ee <IPnPLCommandExecuteFunction>:

  static inline uint8_t IPnPLCommandExecuteFunction(IPnPLComponent_t *_this, char *serializedJSON)
  {
 801c4ee:	b580      	push	{r7, lr}
 801c4f0:	b082      	sub	sp, #8
 801c4f2:	af00      	add	r7, sp, #0
 801c4f4:	6078      	str	r0, [r7, #4]
 801c4f6:	6039      	str	r1, [r7, #0]
    return _this->vptr->PnPLCommandExecuteFunction(_this, serializedJSON);
 801c4f8:	687b      	ldr	r3, [r7, #4]
 801c4fa:	681b      	ldr	r3, [r3, #0]
 801c4fc:	695b      	ldr	r3, [r3, #20]
 801c4fe:	6839      	ldr	r1, [r7, #0]
 801c500:	6878      	ldr	r0, [r7, #4]
 801c502:	4798      	blx	r3
 801c504:	4603      	mov	r3, r0
  }
 801c506:	4618      	mov	r0, r3
 801c508:	3708      	adds	r7, #8
 801c50a:	46bd      	mov	sp, r7
 801c50c:	bd80      	pop	{r7, pc}
	...

0801c510 <PnPLSetFWID>:
}

#ifndef FW_ID
/* Set FW Unique ID */
void PnPLSetFWID(uint8_t id)
{
 801c510:	b480      	push	{r7}
 801c512:	b083      	sub	sp, #12
 801c514:	af00      	add	r7, sp, #0
 801c516:	4603      	mov	r3, r0
 801c518:	71fb      	strb	r3, [r7, #7]
  fw_id = id;
 801c51a:	4a04      	ldr	r2, [pc, #16]	@ (801c52c <PnPLSetFWID+0x1c>)
 801c51c:	79fb      	ldrb	r3, [r7, #7]
 801c51e:	7013      	strb	r3, [r2, #0]
}
 801c520:	bf00      	nop
 801c522:	370c      	adds	r7, #12
 801c524:	46bd      	mov	sp, r7
 801c526:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c52a:	4770      	bx	lr
 801c52c:	20001925 	.word	0x20001925

0801c530 <PnPLSetBOARDID>:
#endif

#ifndef BOARD_ID
/* Set BOARD Unique ID */
void PnPLSetBOARDID(uint8_t id)
{
 801c530:	b480      	push	{r7}
 801c532:	b083      	sub	sp, #12
 801c534:	af00      	add	r7, sp, #0
 801c536:	4603      	mov	r3, r0
 801c538:	71fb      	strb	r3, [r7, #7]
  board_id = id;
 801c53a:	4a04      	ldr	r2, [pc, #16]	@ (801c54c <PnPLSetBOARDID+0x1c>)
 801c53c:	79fb      	ldrb	r3, [r7, #7]
 801c53e:	7013      	strb	r3, [r2, #0]
}
 801c540:	bf00      	nop
 801c542:	370c      	adds	r7, #12
 801c544:	46bd      	mov	sp, r7
 801c546:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c54a:	4770      	bx	lr
 801c54c:	20001926 	.word	0x20001926

0801c550 <pnpl_malloc>:

#ifdef pnpl_free
#error "pnpl_free already defined! Check your PnPLCompManager_Conf.h and remove it if present. Use PnPLSetAllocationFunctions() defined in this file to set your memory allocation functions."
#endif

void *pnpl_malloc(size_t size){
 801c550:	b580      	push	{r7, lr}
 801c552:	b082      	sub	sp, #8
 801c554:	af00      	add	r7, sp, #0
 801c556:	6078      	str	r0, [r7, #4]
  return prv_pnpl_malloc(size);
 801c558:	4b04      	ldr	r3, [pc, #16]	@ (801c56c <pnpl_malloc+0x1c>)
 801c55a:	681b      	ldr	r3, [r3, #0]
 801c55c:	6878      	ldr	r0, [r7, #4]
 801c55e:	4798      	blx	r3
 801c560:	4603      	mov	r3, r0
}
 801c562:	4618      	mov	r0, r3
 801c564:	3708      	adds	r7, #8
 801c566:	46bd      	mov	sp, r7
 801c568:	bd80      	pop	{r7, pc}
 801c56a:	bf00      	nop
 801c56c:	20000208 	.word	0x20000208

0801c570 <PnPLGetUniqueID>:
}

/* Unique ID is directly derived from STM32 UID and converted to string
string needs to be 25bytes 24+\0  */
static void PnPLGetUniqueID(char *id)
{
 801c570:	b580      	push	{r7, lr}
 801c572:	b088      	sub	sp, #32
 801c574:	af02      	add	r7, sp, #8
 801c576:	6078      	str	r0, [r7, #4]
  uint32_t stm32_UID[3];

  stm32_UID[0] = (uint32_t)(READ_REG(*((uint32_t *)UID_BASE)));
 801c578:	4b0a      	ldr	r3, [pc, #40]	@ (801c5a4 <PnPLGetUniqueID+0x34>)
 801c57a:	681b      	ldr	r3, [r3, #0]
 801c57c:	60fb      	str	r3, [r7, #12]
  stm32_UID[1] = (uint32_t)(READ_REG(*((uint32_t *)(UID_BASE + 4U))));
 801c57e:	4b0a      	ldr	r3, [pc, #40]	@ (801c5a8 <PnPLGetUniqueID+0x38>)
 801c580:	681b      	ldr	r3, [r3, #0]
 801c582:	613b      	str	r3, [r7, #16]
  stm32_UID[2] = (uint32_t)(READ_REG(*((uint32_t *)(UID_BASE + 8U))));
 801c584:	4b09      	ldr	r3, [pc, #36]	@ (801c5ac <PnPLGetUniqueID+0x3c>)
 801c586:	681b      	ldr	r3, [r3, #0]
 801c588:	617b      	str	r3, [r7, #20]

  (void)sprintf(id, "%08lX%08lX%08lX", (unsigned long)stm32_UID[0], (unsigned long)stm32_UID[1],
 801c58a:	68fa      	ldr	r2, [r7, #12]
 801c58c:	6939      	ldr	r1, [r7, #16]
                (unsigned long)stm32_UID[2]);
 801c58e:	697b      	ldr	r3, [r7, #20]
  (void)sprintf(id, "%08lX%08lX%08lX", (unsigned long)stm32_UID[0], (unsigned long)stm32_UID[1],
 801c590:	9300      	str	r3, [sp, #0]
 801c592:	460b      	mov	r3, r1
 801c594:	4906      	ldr	r1, [pc, #24]	@ (801c5b0 <PnPLGetUniqueID+0x40>)
 801c596:	6878      	ldr	r0, [r7, #4]
 801c598:	f007 fc50 	bl	8023e3c <siprintf>
}
 801c59c:	bf00      	nop
 801c59e:	3718      	adds	r7, #24
 801c5a0:	46bd      	mov	sp, r7
 801c5a2:	bd80      	pop	{r7, pc}
 801c5a4:	0bfa0700 	.word	0x0bfa0700
 801c5a8:	0bfa0704 	.word	0x0bfa0704
 801c5ac:	0bfa0708 	.word	0x0bfa0708
 801c5b0:	08028ccc 	.word	0x08028ccc

0801c5b4 <PnPLAddComponent>:

  (void)strcpy(uuid, global_uuid);
}

uint8_t PnPLAddComponent(IPnPLComponent_t *pComponent)
{
 801c5b4:	b480      	push	{r7}
 801c5b6:	b085      	sub	sp, #20
 801c5b8:	af00      	add	r7, sp, #0
 801c5ba:	6078      	str	r0, [r7, #4]
  uint8_t id = 0;
 801c5bc:	2300      	movs	r3, #0
 801c5be:	73fb      	strb	r3, [r7, #15]
  uint16_t ii;
  bool add_ok = false;
 801c5c0:	2300      	movs	r3, #0
 801c5c2:	72fb      	strb	r3, [r7, #11]

  for (ii = 0; ii <= spPnPLObj.n_components; ii++)
 801c5c4:	2300      	movs	r3, #0
 801c5c6:	81bb      	strh	r3, [r7, #12]
 801c5c8:	e011      	b.n	801c5ee <PnPLAddComponent+0x3a>
  {
    if (spPnPLObj.Components[ii] == NULL)
 801c5ca:	89bb      	ldrh	r3, [r7, #12]
 801c5cc:	4a14      	ldr	r2, [pc, #80]	@ (801c620 <PnPLAddComponent+0x6c>)
 801c5ce:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801c5d2:	2b00      	cmp	r3, #0
 801c5d4:	d108      	bne.n	801c5e8 <PnPLAddComponent+0x34>
    {
      spPnPLObj.Components[ii] = pComponent;
 801c5d6:	89bb      	ldrh	r3, [r7, #12]
 801c5d8:	4911      	ldr	r1, [pc, #68]	@ (801c620 <PnPLAddComponent+0x6c>)
 801c5da:	687a      	ldr	r2, [r7, #4]
 801c5dc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
      add_ok = true;
 801c5e0:	2301      	movs	r3, #1
 801c5e2:	72fb      	strb	r3, [r7, #11]
      id = (uint8_t)ii;
 801c5e4:	89bb      	ldrh	r3, [r7, #12]
 801c5e6:	73fb      	strb	r3, [r7, #15]
  for (ii = 0; ii <= spPnPLObj.n_components; ii++)
 801c5e8:	89bb      	ldrh	r3, [r7, #12]
 801c5ea:	3301      	adds	r3, #1
 801c5ec:	81bb      	strh	r3, [r7, #12]
 801c5ee:	4b0c      	ldr	r3, [pc, #48]	@ (801c620 <PnPLAddComponent+0x6c>)
 801c5f0:	f8b3 3050 	ldrh.w	r3, [r3, #80]	@ 0x50
 801c5f4:	89ba      	ldrh	r2, [r7, #12]
 801c5f6:	429a      	cmp	r2, r3
 801c5f8:	d9e7      	bls.n	801c5ca <PnPLAddComponent+0x16>
    }
  }

  if (add_ok)
 801c5fa:	7afb      	ldrb	r3, [r7, #11]
 801c5fc:	2b00      	cmp	r3, #0
 801c5fe:	d007      	beq.n	801c610 <PnPLAddComponent+0x5c>
  {
    spPnPLObj.n_components++;
 801c600:	4b07      	ldr	r3, [pc, #28]	@ (801c620 <PnPLAddComponent+0x6c>)
 801c602:	f8b3 3050 	ldrh.w	r3, [r3, #80]	@ 0x50
 801c606:	3301      	adds	r3, #1
 801c608:	b29a      	uxth	r2, r3
 801c60a:	4b05      	ldr	r3, [pc, #20]	@ (801c620 <PnPLAddComponent+0x6c>)
 801c60c:	f8a3 2050 	strh.w	r2, [r3, #80]	@ 0x50
  }

  return id;
 801c610:	7bfb      	ldrb	r3, [r7, #15]
}
 801c612:	4618      	mov	r0, r3
 801c614:	3714      	adds	r7, #20
 801c616:	46bd      	mov	sp, r7
 801c618:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c61c:	4770      	bx	lr
 801c61e:	bf00      	nop
 801c620:	200018ac 	.word	0x200018ac

0801c624 <PnPLGetNComponents>:

uint16_t PnPLGetNComponents(void)
{
 801c624:	b480      	push	{r7}
 801c626:	af00      	add	r7, sp, #0
  return spPnPLObj.n_components;
 801c628:	4b03      	ldr	r3, [pc, #12]	@ (801c638 <PnPLGetNComponents+0x14>)
 801c62a:	f8b3 3050 	ldrh.w	r3, [r3, #80]	@ 0x50
}
 801c62e:	4618      	mov	r0, r3
 801c630:	46bd      	mov	sp, r7
 801c632:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c636:	4770      	bx	lr
 801c638:	200018ac 	.word	0x200018ac

0801c63c <PnPLGetPresentationJSON>:
  return ret;
}


uint8_t PnPLGetPresentationJSON(char **serializedJSON, uint32_t *size)
{
 801c63c:	b580      	push	{r7, lr}
 801c63e:	b084      	sub	sp, #16
 801c640:	af00      	add	r7, sp, #0
 801c642:	6078      	str	r0, [r7, #4]
 801c644:	6039      	str	r1, [r7, #0]
  JSON_Value *tempJSON;
  JSON_Object *JSON_GetPresentation;

  tempJSON = json_value_init_object();
 801c646:	f005 f8a7 	bl	8021798 <json_value_init_object>
 801c64a:	60f8      	str	r0, [r7, #12]
  JSON_GetPresentation = json_value_get_object(tempJSON);
 801c64c:	68f8      	ldr	r0, [r7, #12]
 801c64e:	f004 ffde 	bl	802160e <json_value_get_object>
 801c652:	60b8      	str	r0, [r7, #8]

#ifndef BOARD_ID
  (void)json_object_dotset_number(JSON_GetPresentation, "board_id", (float)board_id);
 801c654:	4b19      	ldr	r3, [pc, #100]	@ (801c6bc <PnPLGetPresentationJSON+0x80>)
 801c656:	781b      	ldrb	r3, [r3, #0]
 801c658:	ee07 3a90 	vmov	s15, r3
 801c65c:	eef8 7a67 	vcvt.f32.u32	s15, s15
 801c660:	ee17 0a90 	vmov	r0, s15
 801c664:	f7e3 ff7e 	bl	8000564 <__aeabi_f2d>
 801c668:	4602      	mov	r2, r0
 801c66a:	460b      	mov	r3, r1
 801c66c:	4914      	ldr	r1, [pc, #80]	@ (801c6c0 <PnPLGetPresentationJSON+0x84>)
 801c66e:	68b8      	ldr	r0, [r7, #8]
 801c670:	f005 fc61 	bl	8021f36 <json_object_dotset_number>
#else
  (void)json_object_dotset_number(JSON_GetPresentation, "board_id", (float)BOARD_ID);
#endif

#ifndef FW_ID
  (void)json_object_dotset_number(JSON_GetPresentation, "fw_id", (float)fw_id);
 801c674:	4b13      	ldr	r3, [pc, #76]	@ (801c6c4 <PnPLGetPresentationJSON+0x88>)
 801c676:	781b      	ldrb	r3, [r3, #0]
 801c678:	ee07 3a90 	vmov	s15, r3
 801c67c:	eef8 7a67 	vcvt.f32.u32	s15, s15
 801c680:	ee17 0a90 	vmov	r0, s15
 801c684:	f7e3 ff6e 	bl	8000564 <__aeabi_f2d>
 801c688:	4602      	mov	r2, r0
 801c68a:	460b      	mov	r3, r1
 801c68c:	490e      	ldr	r1, [pc, #56]	@ (801c6c8 <PnPLGetPresentationJSON+0x8c>)
 801c68e:	68b8      	ldr	r0, [r7, #8]
 801c690:	f005 fc51 	bl	8021f36 <json_object_dotset_number>
#else
  (void)json_object_dotset_number(JSON_GetPresentation, "fw_id", (float)FW_ID);
#endif

  *serializedJSON = json_serialize_to_string(tempJSON);
 801c694:	68f8      	ldr	r0, [r7, #12]
 801c696:	f005 f9f3 	bl	8021a80 <json_serialize_to_string>
 801c69a:	4602      	mov	r2, r0
 801c69c:	687b      	ldr	r3, [r7, #4]
 801c69e:	601a      	str	r2, [r3, #0]
  *size = json_serialization_size(tempJSON);
 801c6a0:	68f8      	ldr	r0, [r7, #12]
 801c6a2:	f005 f9a9 	bl	80219f8 <json_serialization_size>
 801c6a6:	4602      	mov	r2, r0
 801c6a8:	683b      	ldr	r3, [r7, #0]
 801c6aa:	601a      	str	r2, [r3, #0]

  json_value_free(tempJSON);
 801c6ac:	68f8      	ldr	r0, [r7, #12]
 801c6ae:	f005 f845 	bl	802173c <json_value_free>
  return PNPL_NO_ERROR_CODE;
 801c6b2:	2300      	movs	r3, #0
}
 801c6b4:	4618      	mov	r0, r3
 801c6b6:	3710      	adds	r7, #16
 801c6b8:	46bd      	mov	sp, r7
 801c6ba:	bd80      	pop	{r7, pc}
 801c6bc:	20001926 	.word	0x20001926
 801c6c0:	08028d08 	.word	0x08028d08
 801c6c4:	20001925 	.word	0x20001925
 801c6c8:	08028d14 	.word	0x08028d14

0801c6cc <PnPLGetDeviceStatusJSON>:

uint8_t PnPLGetDeviceStatusJSON(char **serializedJSON, uint32_t *size, uint8_t pretty)
{
 801c6cc:	b590      	push	{r4, r7, lr}
 801c6ce:	b097      	sub	sp, #92	@ 0x5c
 801c6d0:	af00      	add	r7, sp, #0
 801c6d2:	60f8      	str	r0, [r7, #12]
 801c6d4:	60b9      	str	r1, [r7, #8]
 801c6d6:	4613      	mov	r3, r2
 801c6d8:	71fb      	strb	r3, [r7, #7]
  JSON_Array *JSON_ComponentArray;

  uint32_t sz_comp;
  char *ser_comp;

  tempJSON = json_value_init_object();
 801c6da:	f005 f85d 	bl	8021798 <json_value_init_object>
 801c6de:	6538      	str	r0, [r7, #80]	@ 0x50
  JSON_DeviceConfig = json_value_get_object(tempJSON);
 801c6e0:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 801c6e2:	f004 ff94 	bl	802160e <json_value_get_object>
 801c6e6:	64f8      	str	r0, [r7, #76]	@ 0x4c
      ]

      [*1]: [Backward compatibility guaranteed] If this field is not present, then PnPL responses are not used.
  */

  (void)json_object_dotset_string(JSON_DeviceConfig, "schema_version", "2.1.0");
 801c6e8:	4a5d      	ldr	r2, [pc, #372]	@ (801c860 <PnPLGetDeviceStatusJSON+0x194>)
 801c6ea:	495e      	ldr	r1, [pc, #376]	@ (801c864 <PnPLGetDeviceStatusJSON+0x198>)
 801c6ec:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 801c6ee:	f005 fbff 	bl	8021ef0 <json_object_dotset_string>
  (void)json_object_dotset_string(JSON_DeviceConfig, "uuid", global_uuid);
 801c6f2:	4a5d      	ldr	r2, [pc, #372]	@ (801c868 <PnPLGetDeviceStatusJSON+0x19c>)
 801c6f4:	495d      	ldr	r1, [pc, #372]	@ (801c86c <PnPLGetDeviceStatusJSON+0x1a0>)
 801c6f6:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 801c6f8:	f005 fbfa 	bl	8021ef0 <json_object_dotset_string>

  tempJSONDevice = json_value_init_object();
 801c6fc:	f005 f84c 	bl	8021798 <json_value_init_object>
 801c700:	64b8      	str	r0, [r7, #72]	@ 0x48
  JSON_Device = json_value_get_object(tempJSONDevice);
 801c702:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 801c704:	f004 ff83 	bl	802160e <json_value_get_object>
 801c708:	6478      	str	r0, [r7, #68]	@ 0x44

  (void)json_object_set_value(JSON_DeviceConfig, "devices", json_value_init_array());
 801c70a:	f005 f871 	bl	80217f0 <json_value_init_array>
 801c70e:	4603      	mov	r3, r0
 801c710:	461a      	mov	r2, r3
 801c712:	4957      	ldr	r1, [pc, #348]	@ (801c870 <PnPLGetDeviceStatusJSON+0x1a4>)
 801c714:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 801c716:	f005 fa84 	bl	8021c22 <json_object_set_value>
  JSON_DeviceArray = json_object_dotget_array(JSON_DeviceConfig, "devices");
 801c71a:	4955      	ldr	r1, [pc, #340]	@ (801c870 <PnPLGetDeviceStatusJSON+0x1a4>)
 801c71c:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 801c71e:	f004 fe85 	bl	802142c <json_object_dotget_array>
 801c722:	6438      	str	r0, [r7, #64]	@ 0x40
  (void)json_array_append_value(JSON_DeviceArray, tempJSONDevice);
 801c724:	6cb9      	ldr	r1, [r7, #72]	@ 0x48
 801c726:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 801c728:	f005 fa60 	bl	8021bec <json_array_append_value>

#ifndef BOARD_ID
  (void)json_object_dotset_number(JSON_Device, "board_id", (float)board_id);
 801c72c:	4b51      	ldr	r3, [pc, #324]	@ (801c874 <PnPLGetDeviceStatusJSON+0x1a8>)
 801c72e:	781b      	ldrb	r3, [r3, #0]
 801c730:	ee07 3a90 	vmov	s15, r3
 801c734:	eef8 7a67 	vcvt.f32.u32	s15, s15
 801c738:	ee17 0a90 	vmov	r0, s15
 801c73c:	f7e3 ff12 	bl	8000564 <__aeabi_f2d>
 801c740:	4602      	mov	r2, r0
 801c742:	460b      	mov	r3, r1
 801c744:	494c      	ldr	r1, [pc, #304]	@ (801c878 <PnPLGetDeviceStatusJSON+0x1ac>)
 801c746:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 801c748:	f005 fbf5 	bl	8021f36 <json_object_dotset_number>
#else
  (void)json_object_dotset_number(JSON_Device, "board_id", (float)BOARD_ID);
#endif

#ifndef FW_ID
  (void)json_object_dotset_number(JSON_Device, "fw_id", (float)fw_id);
 801c74c:	4b4b      	ldr	r3, [pc, #300]	@ (801c87c <PnPLGetDeviceStatusJSON+0x1b0>)
 801c74e:	781b      	ldrb	r3, [r3, #0]
 801c750:	ee07 3a90 	vmov	s15, r3
 801c754:	eef8 7a67 	vcvt.f32.u32	s15, s15
 801c758:	ee17 0a90 	vmov	r0, s15
 801c75c:	f7e3 ff02 	bl	8000564 <__aeabi_f2d>
 801c760:	4602      	mov	r2, r0
 801c762:	460b      	mov	r3, r1
 801c764:	4946      	ldr	r1, [pc, #280]	@ (801c880 <PnPLGetDeviceStatusJSON+0x1b4>)
 801c766:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 801c768:	f005 fbe5 	bl	8021f36 <json_object_dotset_number>
#else
  (void)json_object_dotset_number(JSON_Device, "fw_id", (float)FW_ID);
#endif

  (void)json_object_dotset_number(JSON_Device, "protocol_id", 2); /* 0: BLE, 1: serial, 2:libusb */
 801c76c:	f04f 0200 	mov.w	r2, #0
 801c770:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 801c774:	4943      	ldr	r1, [pc, #268]	@ (801c884 <PnPLGetDeviceStatusJSON+0x1b8>)
 801c776:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 801c778:	f005 fbdd 	bl	8021f36 <json_object_dotset_number>

  PnPLGetUniqueID(serial_number);
 801c77c:	f107 0318 	add.w	r3, r7, #24
 801c780:	4618      	mov	r0, r3
 801c782:	f7ff fef5 	bl	801c570 <PnPLGetUniqueID>
  (void)json_object_dotset_string(JSON_Device, "sn", serial_number);
 801c786:	f107 0318 	add.w	r3, r7, #24
 801c78a:	461a      	mov	r2, r3
 801c78c:	493e      	ldr	r1, [pc, #248]	@ (801c888 <PnPLGetDeviceStatusJSON+0x1bc>)
 801c78e:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 801c790:	f005 fbae 	bl	8021ef0 <json_object_dotset_string>

#ifdef PNPL_RESPONSES
  (void)json_object_dotset_boolean(JSON_Device, "pnpl_responses", true);
#else
  (void)json_object_dotset_boolean(JSON_Device, "pnpl_responses", false);
 801c794:	2200      	movs	r2, #0
 801c796:	493d      	ldr	r1, [pc, #244]	@ (801c88c <PnPLGetDeviceStatusJSON+0x1c0>)
 801c798:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 801c79a:	f005 fbf1 	bl	8021f80 <json_object_dotset_boolean>
#endif

  (void)json_object_set_value(JSON_Device, "components", json_value_init_array());
 801c79e:	f005 f827 	bl	80217f0 <json_value_init_array>
 801c7a2:	4603      	mov	r3, r0
 801c7a4:	461a      	mov	r2, r3
 801c7a6:	493a      	ldr	r1, [pc, #232]	@ (801c890 <PnPLGetDeviceStatusJSON+0x1c4>)
 801c7a8:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 801c7aa:	f005 fa3a 	bl	8021c22 <json_object_set_value>
  JSON_ComponentArray = json_object_dotget_array(JSON_Device, "components");
 801c7ae:	4938      	ldr	r1, [pc, #224]	@ (801c890 <PnPLGetDeviceStatusJSON+0x1c4>)
 801c7b0:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 801c7b2:	f004 fe3b 	bl	802142c <json_object_dotget_array>
 801c7b6:	63f8      	str	r0, [r7, #60]	@ 0x3c

  for (uint8_t i = 0; i < PnPLGetNComponents(); i++)
 801c7b8:	2300      	movs	r3, #0
 801c7ba:	f887 3057 	strb.w	r3, [r7, #87]	@ 0x57
 801c7be:	e023      	b.n	801c808 <PnPLGetDeviceStatusJSON+0x13c>
  {
    IPnPLComponent_t *p_obj = spPnPLObj.Components[i];
 801c7c0:	f897 3057 	ldrb.w	r3, [r7, #87]	@ 0x57
 801c7c4:	4a33      	ldr	r2, [pc, #204]	@ (801c894 <PnPLGetDeviceStatusJSON+0x1c8>)
 801c7c6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801c7ca:	63bb      	str	r3, [r7, #56]	@ 0x38
    sz_comp = 0;
 801c7cc:	2300      	movs	r3, #0
 801c7ce:	617b      	str	r3, [r7, #20]
    ser_comp = NULL;
 801c7d0:	2300      	movs	r3, #0
 801c7d2:	613b      	str	r3, [r7, #16]
    (void)IPnPLComponentGetStatus(p_obj, &ser_comp, &sz_comp, 0);
 801c7d4:	f107 0214 	add.w	r2, r7, #20
 801c7d8:	f107 0110 	add.w	r1, r7, #16
 801c7dc:	2300      	movs	r3, #0
 801c7de:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 801c7e0:	f7ff fe61 	bl	801c4a6 <IPnPLComponentGetStatus>
    tempJSON1 = json_parse_string(ser_comp);
 801c7e4:	693b      	ldr	r3, [r7, #16]
 801c7e6:	4618      	mov	r0, r3
 801c7e8:	f004 fd5a 	bl	80212a0 <json_parse_string>
 801c7ec:	6378      	str	r0, [r7, #52]	@ 0x34
    (void)json_array_append_value(JSON_ComponentArray, tempJSON1);
 801c7ee:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 801c7f0:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 801c7f2:	f005 f9fb 	bl	8021bec <json_array_append_value>
    json_free_serialized_string(ser_comp);
 801c7f6:	693b      	ldr	r3, [r7, #16]
 801c7f8:	4618      	mov	r0, r3
 801c7fa:	f005 f9e9 	bl	8021bd0 <json_free_serialized_string>
  for (uint8_t i = 0; i < PnPLGetNComponents(); i++)
 801c7fe:	f897 3057 	ldrb.w	r3, [r7, #87]	@ 0x57
 801c802:	3301      	adds	r3, #1
 801c804:	f887 3057 	strb.w	r3, [r7, #87]	@ 0x57
 801c808:	f897 3057 	ldrb.w	r3, [r7, #87]	@ 0x57
 801c80c:	b29c      	uxth	r4, r3
 801c80e:	f7ff ff09 	bl	801c624 <PnPLGetNComponents>
 801c812:	4603      	mov	r3, r0
 801c814:	429c      	cmp	r4, r3
 801c816:	d3d3      	bcc.n	801c7c0 <PnPLGetDeviceStatusJSON+0xf4>
  }

  /* convert to a json string and write to file */
  if (pretty == 1u)
 801c818:	79fb      	ldrb	r3, [r7, #7]
 801c81a:	2b01      	cmp	r3, #1
 801c81c:	d10c      	bne.n	801c838 <PnPLGetDeviceStatusJSON+0x16c>
  {
    *serializedJSON = json_serialize_to_string_pretty(tempJSON);
 801c81e:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 801c820:	f005 f9a4 	bl	8021b6c <json_serialize_to_string_pretty>
 801c824:	4602      	mov	r2, r0
 801c826:	68fb      	ldr	r3, [r7, #12]
 801c828:	601a      	str	r2, [r3, #0]
    *size = json_serialization_size_pretty(tempJSON);
 801c82a:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 801c82c:	f005 f95a 	bl	8021ae4 <json_serialization_size_pretty>
 801c830:	4602      	mov	r2, r0
 801c832:	68bb      	ldr	r3, [r7, #8]
 801c834:	601a      	str	r2, [r3, #0]
 801c836:	e00b      	b.n	801c850 <PnPLGetDeviceStatusJSON+0x184>
  }
  else
  {
    *serializedJSON = json_serialize_to_string(tempJSON);
 801c838:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 801c83a:	f005 f921 	bl	8021a80 <json_serialize_to_string>
 801c83e:	4602      	mov	r2, r0
 801c840:	68fb      	ldr	r3, [r7, #12]
 801c842:	601a      	str	r2, [r3, #0]
    *size = json_serialization_size(tempJSON);
 801c844:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 801c846:	f005 f8d7 	bl	80219f8 <json_serialization_size>
 801c84a:	4602      	mov	r2, r0
 801c84c:	68bb      	ldr	r3, [r7, #8]
 801c84e:	601a      	str	r2, [r3, #0]
  }

  json_value_free(tempJSON);
 801c850:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 801c852:	f004 ff73 	bl	802173c <json_value_free>
  return PNPL_NO_ERROR_CODE;
 801c856:	2300      	movs	r3, #0
}
 801c858:	4618      	mov	r0, r3
 801c85a:	375c      	adds	r7, #92	@ 0x5c
 801c85c:	46bd      	mov	sp, r7
 801c85e:	bd90      	pop	{r4, r7, pc}
 801c860:	08028d1c 	.word	0x08028d1c
 801c864:	08028d24 	.word	0x08028d24
 801c868:	20001900 	.word	0x20001900
 801c86c:	08028d34 	.word	0x08028d34
 801c870:	08028d3c 	.word	0x08028d3c
 801c874:	20001926 	.word	0x20001926
 801c878:	08028d08 	.word	0x08028d08
 801c87c:	20001925 	.word	0x20001925
 801c880:	08028d14 	.word	0x08028d14
 801c884:	08028d44 	.word	0x08028d44
 801c888:	08028d50 	.word	0x08028d50
 801c88c:	08028d54 	.word	0x08028d54
 801c890:	08028d64 	.word	0x08028d64
 801c894:	200018ac 	.word	0x200018ac

0801c898 <PnPLUpdateDeviceStatusFromJSON>:
  return PNPL_NO_ERROR_CODE;
}


uint8_t PnPLUpdateDeviceStatusFromJSON(char *serializedJSON)
{
 801c898:	b590      	push	{r4, r7, lr}
 801c89a:	b0a9      	sub	sp, #164	@ 0xa4
 801c89c:	af00      	add	r7, sp, #0
 801c89e:	6078      	str	r0, [r7, #4]

  JSON_Array *JSON_components, *JSON_devices;
  JSON_Object *component, *device;
  JSON_Value *component_value;

  JSON_Value *tempJSON = json_parse_string(serializedJSON);
 801c8a0:	6878      	ldr	r0, [r7, #4]
 801c8a2:	f004 fcfd 	bl	80212a0 <json_parse_string>
 801c8a6:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
  JSON_Object *JSON_ParseHandler = json_value_get_object(tempJSON);
 801c8aa:	f8d7 008c 	ldr.w	r0, [r7, #140]	@ 0x8c
 801c8ae:	f004 feae 	bl	802160e <json_value_get_object>
 801c8b2:	f8c7 0088 	str.w	r0, [r7, #136]	@ 0x88
  uint32_t components_number;

  if (json_object_has_value(JSON_ParseHandler, "devices") == 1)
 801c8b6:	494c      	ldr	r1, [pc, #304]	@ (801c9e8 <PnPLUpdateDeviceStatusFromJSON+0x150>)
 801c8b8:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801c8bc:	f004 fe20 	bl	8021500 <json_object_has_value>
 801c8c0:	4603      	mov	r3, r0
 801c8c2:	2b01      	cmp	r3, #1
 801c8c4:	d11b      	bne.n	801c8fe <PnPLUpdateDeviceStatusFromJSON+0x66>
  {
    JSON_devices = json_object_get_array(JSON_ParseHandler, "devices");
 801c8c6:	4948      	ldr	r1, [pc, #288]	@ (801c9e8 <PnPLUpdateDeviceStatusFromJSON+0x150>)
 801c8c8:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801c8cc:	f004 fd4b 	bl	8021366 <json_object_get_array>
 801c8d0:	f8c7 0084 	str.w	r0, [r7, #132]	@ 0x84
    device = json_array_get_object(JSON_devices, 0);
 801c8d4:	2100      	movs	r1, #0
 801c8d6:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 801c8da:	f004 fe52 	bl	8021582 <json_array_get_object>
 801c8de:	f8c7 0080 	str.w	r0, [r7, #128]	@ 0x80
    JSON_components = json_object_get_array(device, "components");
 801c8e2:	4942      	ldr	r1, [pc, #264]	@ (801c9ec <PnPLUpdateDeviceStatusFromJSON+0x154>)
 801c8e4:	f8d7 0080 	ldr.w	r0, [r7, #128]	@ 0x80
 801c8e8:	f004 fd3d 	bl	8021366 <json_object_get_array>
 801c8ec:	f8c7 009c 	str.w	r0, [r7, #156]	@ 0x9c
    components_number = json_array_get_count(JSON_components);
 801c8f0:	f8d7 009c 	ldr.w	r0, [r7, #156]	@ 0x9c
 801c8f4:	f004 fe57 	bl	80215a6 <json_array_get_count>
 801c8f8:	f8c7 0098 	str.w	r0, [r7, #152]	@ 0x98
 801c8fc:	e00c      	b.n	801c918 <PnPLUpdateDeviceStatusFromJSON+0x80>
  }
  else
  {
    /* old status version (without "device" key) */
    JSON_components = json_object_get_array(JSON_ParseHandler, "");
 801c8fe:	493c      	ldr	r1, [pc, #240]	@ (801c9f0 <PnPLUpdateDeviceStatusFromJSON+0x158>)
 801c900:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
 801c904:	f004 fd2f 	bl	8021366 <json_object_get_array>
 801c908:	f8c7 009c 	str.w	r0, [r7, #156]	@ 0x9c
    components_number = json_array_get_count(JSON_components);
 801c90c:	f8d7 009c 	ldr.w	r0, [r7, #156]	@ 0x9c
 801c910:	f004 fe49 	bl	80215a6 <json_array_get_count>
 801c914:	f8c7 0098 	str.w	r0, [r7, #152]	@ 0x98
  }

  for (uint32_t i = 0; i < components_number; i++)
 801c918:	2300      	movs	r3, #0
 801c91a:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
 801c91e:	e053      	b.n	801c9c8 <PnPLUpdateDeviceStatusFromJSON+0x130>
  {
    component = json_array_get_object(JSON_components, i);
 801c920:	f8d7 1094 	ldr.w	r1, [r7, #148]	@ 0x94
 801c924:	f8d7 009c 	ldr.w	r0, [r7, #156]	@ 0x9c
 801c928:	f004 fe2b 	bl	8021582 <json_array_get_object>
 801c92c:	67f8      	str	r0, [r7, #124]	@ 0x7c
    (void)strcpy(componentName, json_object_get_name(component, 0));
 801c92e:	2100      	movs	r1, #0
 801c930:	6ff8      	ldr	r0, [r7, #124]	@ 0x7c
 801c932:	f004 fd9e 	bl	8021472 <json_object_get_name>
 801c936:	4602      	mov	r2, r0
 801c938:	f107 0350 	add.w	r3, r7, #80	@ 0x50
 801c93c:	4611      	mov	r1, r2
 801c93e:	4618      	mov	r0, r3
 801c940:	f007 fc3f 	bl	80241c2 <strcpy>
    for (uint8_t j = 0; j < PnPLGetNComponents(); j++)
 801c944:	2300      	movs	r3, #0
 801c946:	f887 3093 	strb.w	r3, [r7, #147]	@ 0x93
 801c94a:	e030      	b.n	801c9ae <PnPLUpdateDeviceStatusFromJSON+0x116>
    {
      IPnPLComponent_t *p_obj = (IPnPLComponent_t *)(spPnPLObj.Components[j]);
 801c94c:	f897 3093 	ldrb.w	r3, [r7, #147]	@ 0x93
 801c950:	4a28      	ldr	r2, [pc, #160]	@ (801c9f4 <PnPLUpdateDeviceStatusFromJSON+0x15c>)
 801c952:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801c956:	67bb      	str	r3, [r7, #120]	@ 0x78
      if (strcmp(componentName, IPnPLComponentGetKey(p_obj)) == 0)
 801c958:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 801c95a:	f7ff fd76 	bl	801c44a <IPnPLComponentGetKey>
 801c95e:	4602      	mov	r2, r0
 801c960:	f107 0350 	add.w	r3, r7, #80	@ 0x50
 801c964:	4611      	mov	r1, r2
 801c966:	4618      	mov	r0, r3
 801c968:	f7e3 fc86 	bl	8000278 <strcmp>
 801c96c:	4603      	mov	r3, r0
 801c96e:	2b00      	cmp	r3, #0
 801c970:	d118      	bne.n	801c9a4 <PnPLUpdateDeviceStatusFromJSON+0x10c>
      {
        component_value = json_object_get_value(component, componentName);
 801c972:	f107 0350 	add.w	r3, r7, #80	@ 0x50
 801c976:	4619      	mov	r1, r3
 801c978:	6ff8      	ldr	r0, [r7, #124]	@ 0x7c
 801c97a:	f004 fcb5 	bl	80212e8 <json_object_get_value>
 801c97e:	6778      	str	r0, [r7, #116]	@ 0x74
        char *comp_string = json_serialize_to_string(json_value_get_parent(component_value));
 801c980:	6f78      	ldr	r0, [r7, #116]	@ 0x74
 801c982:	f004 feca 	bl	802171a <json_value_get_parent>
 801c986:	4603      	mov	r3, r0
 801c988:	4618      	mov	r0, r3
 801c98a:	f005 f879 	bl	8021a80 <json_serialize_to_string>
 801c98e:	6738      	str	r0, [r7, #112]	@ 0x70

        PnPLCommand_t pnpl_command;
        (void)PnPLParseCommand(comp_string, &pnpl_command);
 801c990:	f107 0308 	add.w	r3, r7, #8
 801c994:	4619      	mov	r1, r3
 801c996:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801c998:	f000 f93e 	bl	801cc18 <PnPLParseCommand>

        json_free_serialized_string(comp_string);
 801c99c:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801c99e:	f005 f917 	bl	8021bd0 <json_free_serialized_string>
        break;
 801c9a2:	e00c      	b.n	801c9be <PnPLUpdateDeviceStatusFromJSON+0x126>
    for (uint8_t j = 0; j < PnPLGetNComponents(); j++)
 801c9a4:	f897 3093 	ldrb.w	r3, [r7, #147]	@ 0x93
 801c9a8:	3301      	adds	r3, #1
 801c9aa:	f887 3093 	strb.w	r3, [r7, #147]	@ 0x93
 801c9ae:	f897 3093 	ldrb.w	r3, [r7, #147]	@ 0x93
 801c9b2:	b29c      	uxth	r4, r3
 801c9b4:	f7ff fe36 	bl	801c624 <PnPLGetNComponents>
 801c9b8:	4603      	mov	r3, r0
 801c9ba:	429c      	cmp	r4, r3
 801c9bc:	d3c6      	bcc.n	801c94c <PnPLUpdateDeviceStatusFromJSON+0xb4>
  for (uint32_t i = 0; i < components_number; i++)
 801c9be:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 801c9c2:	3301      	adds	r3, #1
 801c9c4:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
 801c9c8:	f8d7 2094 	ldr.w	r2, [r7, #148]	@ 0x94
 801c9cc:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
 801c9d0:	429a      	cmp	r2, r3
 801c9d2:	d3a5      	bcc.n	801c920 <PnPLUpdateDeviceStatusFromJSON+0x88>
      }
    }
  }

  json_value_free(tempJSON);
 801c9d4:	f8d7 008c 	ldr.w	r0, [r7, #140]	@ 0x8c
 801c9d8:	f004 feb0 	bl	802173c <json_value_free>
  return PNPL_NO_ERROR_CODE;
 801c9dc:	2300      	movs	r3, #0
}
 801c9de:	4618      	mov	r0, r3
 801c9e0:	37a4      	adds	r7, #164	@ 0xa4
 801c9e2:	46bd      	mov	sp, r7
 801c9e4:	bd90      	pop	{r4, r7, pc}
 801c9e6:	bf00      	nop
 801c9e8:	08028d3c 	.word	0x08028d3c
 801c9ec:	08028d64 	.word	0x08028d64
 801c9f0:	08028d70 	.word	0x08028d70
 801c9f4:	200018ac 	.word	0x200018ac

0801c9f8 <extract_PnPL_cmd_data>:

static uint8_t extract_PnPL_cmd_data(char *commandString, uint8_t *commandType, char *componentName)
{
 801c9f8:	b590      	push	{r4, r7, lr}
 801c9fa:	b08d      	sub	sp, #52	@ 0x34
 801c9fc:	af00      	add	r7, sp, #0
 801c9fe:	60f8      	str	r0, [r7, #12]
 801ca00:	60b9      	str	r1, [r7, #8]
 801ca02:	607a      	str	r2, [r7, #4]
  JSON_Value *tempJSON = json_parse_string(commandString);
 801ca04:	68f8      	ldr	r0, [r7, #12]
 801ca06:	f004 fc4b 	bl	80212a0 <json_parse_string>
 801ca0a:	62b8      	str	r0, [r7, #40]	@ 0x28
  if (tempJSON != NULL)
 801ca0c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801ca0e:	2b00      	cmp	r3, #0
 801ca10:	f000 80ea 	beq.w	801cbe8 <extract_PnPL_cmd_data+0x1f0>
  {
    JSON_Object *tempJSONObject = json_value_get_object(tempJSON);
 801ca14:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 801ca16:	f004 fdfa 	bl	802160e <json_value_get_object>
 801ca1a:	6278      	str	r0, [r7, #36]	@ 0x24
    (void)strcpy(componentName, json_object_get_name(tempJSONObject, 0));
 801ca1c:	2100      	movs	r1, #0
 801ca1e:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 801ca20:	f004 fd27 	bl	8021472 <json_object_get_name>
 801ca24:	4603      	mov	r3, r0
 801ca26:	4619      	mov	r1, r3
 801ca28:	6878      	ldr	r0, [r7, #4]
 801ca2a:	f007 fbca 	bl	80241c2 <strcpy>
    for (uint8_t i = 0; i < PnPLGetNComponents(); i++)
 801ca2e:	2300      	movs	r3, #0
 801ca30:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
 801ca34:	e049      	b.n	801caca <extract_PnPL_cmd_data+0xd2>
    {
      IPnPLComponent_t *p_obj = (IPnPLComponent_t *)(spPnPLObj.Components[i]);
 801ca36:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 801ca3a:	4a6f      	ldr	r2, [pc, #444]	@ (801cbf8 <extract_PnPL_cmd_data+0x200>)
 801ca3c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801ca40:	61bb      	str	r3, [r7, #24]
      if (strcmp(IPnPLComponentGetKey(p_obj), componentName) == 0)
 801ca42:	69b8      	ldr	r0, [r7, #24]
 801ca44:	f7ff fd01 	bl	801c44a <IPnPLComponentGetKey>
 801ca48:	4603      	mov	r3, r0
 801ca4a:	6879      	ldr	r1, [r7, #4]
 801ca4c:	4618      	mov	r0, r3
 801ca4e:	f7e3 fc13 	bl	8000278 <strcmp>
 801ca52:	4603      	mov	r3, r0
 801ca54:	2b00      	cmp	r3, #0
 801ca56:	d107      	bne.n	801ca68 <extract_PnPL_cmd_data+0x70>
      {
        /* Check if extracted string is a component added to the current FW */
        *commandType = PNPL_CMD_SET;
 801ca58:	68bb      	ldr	r3, [r7, #8]
 801ca5a:	2220      	movs	r2, #32
 801ca5c:	701a      	strb	r2, [r3, #0]
        json_value_free(tempJSON);
 801ca5e:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 801ca60:	f004 fe6c 	bl	802173c <json_value_free>
        return PNPL_NO_ERROR_CODE;
 801ca64:	2300      	movs	r3, #0
 801ca66:	e0c3      	b.n	801cbf0 <extract_PnPL_cmd_data+0x1f8>
      }
      /* in case of control commands */
      uint8_t nOfCommands = IPnPLComponentGetNCommands(p_obj);
 801ca68:	69b8      	ldr	r0, [r7, #24]
 801ca6a:	f7ff fcfc 	bl	801c466 <IPnPLComponentGetNCommands>
 801ca6e:	4603      	mov	r3, r0
 801ca70:	75fb      	strb	r3, [r7, #23]
      if (nOfCommands > 0u)
 801ca72:	7dfb      	ldrb	r3, [r7, #23]
 801ca74:	2b00      	cmp	r3, #0
 801ca76:	d023      	beq.n	801cac0 <extract_PnPL_cmd_data+0xc8>
      {
        for (uint8_t j = 0; j < nOfCommands; j++)
 801ca78:	2300      	movs	r3, #0
 801ca7a:	f887 302e 	strb.w	r3, [r7, #46]	@ 0x2e
 801ca7e:	e01a      	b.n	801cab6 <extract_PnPL_cmd_data+0xbe>
        {
          if (strcmp(IPnPLComponentGetCommandKey(p_obj, j), componentName) == 0)
 801ca80:	f897 302e 	ldrb.w	r3, [r7, #46]	@ 0x2e
 801ca84:	4619      	mov	r1, r3
 801ca86:	69b8      	ldr	r0, [r7, #24]
 801ca88:	f7ff fcfb 	bl	801c482 <IPnPLComponentGetCommandKey>
 801ca8c:	4603      	mov	r3, r0
 801ca8e:	6879      	ldr	r1, [r7, #4]
 801ca90:	4618      	mov	r0, r3
 801ca92:	f7e3 fbf1 	bl	8000278 <strcmp>
 801ca96:	4603      	mov	r3, r0
 801ca98:	2b00      	cmp	r3, #0
 801ca9a:	d107      	bne.n	801caac <extract_PnPL_cmd_data+0xb4>
          {
            *commandType = PNPL_CMD_SET;
 801ca9c:	68bb      	ldr	r3, [r7, #8]
 801ca9e:	2220      	movs	r2, #32
 801caa0:	701a      	strb	r2, [r3, #0]
            json_value_free(tempJSON);
 801caa2:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 801caa4:	f004 fe4a 	bl	802173c <json_value_free>
            return PNPL_NO_ERROR_CODE;
 801caa8:	2300      	movs	r3, #0
 801caaa:	e0a1      	b.n	801cbf0 <extract_PnPL_cmd_data+0x1f8>
        for (uint8_t j = 0; j < nOfCommands; j++)
 801caac:	f897 302e 	ldrb.w	r3, [r7, #46]	@ 0x2e
 801cab0:	3301      	adds	r3, #1
 801cab2:	f887 302e 	strb.w	r3, [r7, #46]	@ 0x2e
 801cab6:	f897 202e 	ldrb.w	r2, [r7, #46]	@ 0x2e
 801caba:	7dfb      	ldrb	r3, [r7, #23]
 801cabc:	429a      	cmp	r2, r3
 801cabe:	d3df      	bcc.n	801ca80 <extract_PnPL_cmd_data+0x88>
    for (uint8_t i = 0; i < PnPLGetNComponents(); i++)
 801cac0:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 801cac4:	3301      	adds	r3, #1
 801cac6:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
 801caca:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 801cace:	b29c      	uxth	r4, r3
 801cad0:	f7ff fda8 	bl	801c624 <PnPLGetNComponents>
 801cad4:	4603      	mov	r3, r0
 801cad6:	429c      	cmp	r4, r3
 801cad8:	d3ad      	bcc.n	801ca36 <extract_PnPL_cmd_data+0x3e>
          }
        }
      }
    }

    if (strcmp(componentName, "get_status") == 0)
 801cada:	4948      	ldr	r1, [pc, #288]	@ (801cbfc <extract_PnPL_cmd_data+0x204>)
 801cadc:	6878      	ldr	r0, [r7, #4]
 801cade:	f7e3 fbcb 	bl	8000278 <strcmp>
 801cae2:	4603      	mov	r3, r0
 801cae4:	2b00      	cmp	r3, #0
 801cae6:	d110      	bne.n	801cb0a <extract_PnPL_cmd_data+0x112>
    {
      *commandType = PNPL_CMD_GET;
 801cae8:	68bb      	ldr	r3, [r7, #8]
 801caea:	2210      	movs	r2, #16
 801caec:	701a      	strb	r2, [r3, #0]
      (void)strcpy(componentName, json_object_get_string(tempJSONObject, "get_status"));
 801caee:	4943      	ldr	r1, [pc, #268]	@ (801cbfc <extract_PnPL_cmd_data+0x204>)
 801caf0:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 801caf2:	f004 fc14 	bl	802131e <json_object_get_string>
 801caf6:	4603      	mov	r3, r0
 801caf8:	4619      	mov	r1, r3
 801cafa:	6878      	ldr	r0, [r7, #4]
 801cafc:	f007 fb61 	bl	80241c2 <strcpy>
      json_value_free(tempJSON);
 801cb00:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 801cb02:	f004 fe1b 	bl	802173c <json_value_free>
      return PNPL_NO_ERROR_CODE;
 801cb06:	2300      	movs	r3, #0
 801cb08:	e072      	b.n	801cbf0 <extract_PnPL_cmd_data+0x1f8>
    }
    else if (strcmp(componentName, "update_device_status") == 0)
 801cb0a:	493d      	ldr	r1, [pc, #244]	@ (801cc00 <extract_PnPL_cmd_data+0x208>)
 801cb0c:	6878      	ldr	r0, [r7, #4]
 801cb0e:	f7e3 fbb3 	bl	8000278 <strcmp>
 801cb12:	4603      	mov	r3, r0
 801cb14:	2b00      	cmp	r3, #0
 801cb16:	d114      	bne.n	801cb42 <extract_PnPL_cmd_data+0x14a>
    {
      *commandType = PNPL_CMD_UPDATE_DEVICE;
 801cb18:	68bb      	ldr	r3, [r7, #8]
 801cb1a:	2221      	movs	r2, #33	@ 0x21
 801cb1c:	701a      	strb	r2, [r3, #0]
      JSON_Value *tempJSONValue = json_object_get_value(tempJSONObject, "update_device_status");
 801cb1e:	4938      	ldr	r1, [pc, #224]	@ (801cc00 <extract_PnPL_cmd_data+0x208>)
 801cb20:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 801cb22:	f004 fbe1 	bl	80212e8 <json_object_get_value>
 801cb26:	61f8      	str	r0, [r7, #28]
      (void)strcpy(commandString, json_serialize_to_string(tempJSONValue));
 801cb28:	69f8      	ldr	r0, [r7, #28]
 801cb2a:	f004 ffa9 	bl	8021a80 <json_serialize_to_string>
 801cb2e:	4603      	mov	r3, r0
 801cb30:	4619      	mov	r1, r3
 801cb32:	68f8      	ldr	r0, [r7, #12]
 801cb34:	f007 fb45 	bl	80241c2 <strcpy>
      json_value_free(tempJSONValue);
 801cb38:	69f8      	ldr	r0, [r7, #28]
 801cb3a:	f004 fdff 	bl	802173c <json_value_free>
      return PNPL_NO_ERROR_CODE;
 801cb3e:	2300      	movs	r3, #0
 801cb40:	e056      	b.n	801cbf0 <extract_PnPL_cmd_data+0x1f8>
    }
    else if (strcmp(componentName, "system_config") == 0)
 801cb42:	4930      	ldr	r1, [pc, #192]	@ (801cc04 <extract_PnPL_cmd_data+0x20c>)
 801cb44:	6878      	ldr	r0, [r7, #4]
 801cb46:	f7e3 fb97 	bl	8000278 <strcmp>
 801cb4a:	4603      	mov	r3, r0
 801cb4c:	2b00      	cmp	r3, #0
 801cb4e:	d115      	bne.n	801cb7c <extract_PnPL_cmd_data+0x184>
    {
      *commandType = PNPL_CMD_SYSTEM_CONFIG;
 801cb50:	68bb      	ldr	r3, [r7, #8]
 801cb52:	2240      	movs	r2, #64	@ 0x40
 801cb54:	701a      	strb	r2, [r3, #0]
      JSON_Object *tempJSONObject2 = json_object_get_object(tempJSONObject, "system_config");
 801cb56:	492b      	ldr	r1, [pc, #172]	@ (801cc04 <extract_PnPL_cmd_data+0x20c>)
 801cb58:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 801cb5a:	f004 fbf2 	bl	8021342 <json_object_get_object>
 801cb5e:	6238      	str	r0, [r7, #32]
      (void)strcpy(componentName, json_object_get_string(tempJSONObject2, "comp_name"));
 801cb60:	4929      	ldr	r1, [pc, #164]	@ (801cc08 <extract_PnPL_cmd_data+0x210>)
 801cb62:	6a38      	ldr	r0, [r7, #32]
 801cb64:	f004 fbdb 	bl	802131e <json_object_get_string>
 801cb68:	4603      	mov	r3, r0
 801cb6a:	4619      	mov	r1, r3
 801cb6c:	6878      	ldr	r0, [r7, #4]
 801cb6e:	f007 fb28 	bl	80241c2 <strcpy>
      json_value_free(tempJSON);
 801cb72:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 801cb74:	f004 fde2 	bl	802173c <json_value_free>
      return PNPL_NO_ERROR_CODE;
 801cb78:	2300      	movs	r3, #0
 801cb7a:	e039      	b.n	801cbf0 <extract_PnPL_cmd_data+0x1f8>
    }
    else if (strcmp(componentName, "system_info") == 0)/* NOTE Used for OLD get_presentation command */
 801cb7c:	4923      	ldr	r1, [pc, #140]	@ (801cc0c <extract_PnPL_cmd_data+0x214>)
 801cb7e:	6878      	ldr	r0, [r7, #4]
 801cb80:	f7e3 fb7a 	bl	8000278 <strcmp>
 801cb84:	4603      	mov	r3, r0
 801cb86:	2b00      	cmp	r3, #0
 801cb88:	d10a      	bne.n	801cba0 <extract_PnPL_cmd_data+0x1a8>
    {
      *commandType = PNPL_CMD_SYSTEM_INFO;
 801cb8a:	68bb      	ldr	r3, [r7, #8]
 801cb8c:	2250      	movs	r2, #80	@ 0x50
 801cb8e:	701a      	strb	r2, [r3, #0]
      (void)strcpy(componentName, "");
 801cb90:	687b      	ldr	r3, [r7, #4]
 801cb92:	2200      	movs	r2, #0
 801cb94:	701a      	strb	r2, [r3, #0]
      json_value_free(tempJSON);
 801cb96:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 801cb98:	f004 fdd0 	bl	802173c <json_value_free>
      return PNPL_NO_ERROR_CODE;
 801cb9c:	2300      	movs	r3, #0
 801cb9e:	e027      	b.n	801cbf0 <extract_PnPL_cmd_data+0x1f8>
    }
    else if (strcmp(componentName, "get_presentation") == 0)/* NOTE New get_presentation command */
 801cba0:	491b      	ldr	r1, [pc, #108]	@ (801cc10 <extract_PnPL_cmd_data+0x218>)
 801cba2:	6878      	ldr	r0, [r7, #4]
 801cba4:	f7e3 fb68 	bl	8000278 <strcmp>
 801cba8:	4603      	mov	r3, r0
 801cbaa:	2b00      	cmp	r3, #0
 801cbac:	d10a      	bne.n	801cbc4 <extract_PnPL_cmd_data+0x1cc>
    {
      *commandType = PNPL_CMD_SYSTEM_INFO;
 801cbae:	68bb      	ldr	r3, [r7, #8]
 801cbb0:	2250      	movs	r2, #80	@ 0x50
 801cbb2:	701a      	strb	r2, [r3, #0]
      (void)strcpy(componentName, "");
 801cbb4:	687b      	ldr	r3, [r7, #4]
 801cbb6:	2200      	movs	r2, #0
 801cbb8:	701a      	strb	r2, [r3, #0]
      json_value_free(tempJSON);
 801cbba:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 801cbbc:	f004 fdbe 	bl	802173c <json_value_free>
      return PNPL_NO_ERROR_CODE;
 801cbc0:	2300      	movs	r3, #0
 801cbc2:	e015      	b.n	801cbf0 <extract_PnPL_cmd_data+0x1f8>
    }
    else if (strcmp(componentName, "get_identity") == 0)/* NOTE New get_identity command (Asked from SW-Platform) */
 801cbc4:	4913      	ldr	r1, [pc, #76]	@ (801cc14 <extract_PnPL_cmd_data+0x21c>)
 801cbc6:	6878      	ldr	r0, [r7, #4]
 801cbc8:	f7e3 fb56 	bl	8000278 <strcmp>
 801cbcc:	4603      	mov	r3, r0
 801cbce:	2b00      	cmp	r3, #0
 801cbd0:	d10a      	bne.n	801cbe8 <extract_PnPL_cmd_data+0x1f0>
    {
      *commandType = PNPL_CMD_SYSTEM_INFO;
 801cbd2:	68bb      	ldr	r3, [r7, #8]
 801cbd4:	2250      	movs	r2, #80	@ 0x50
 801cbd6:	701a      	strb	r2, [r3, #0]
      (void)strcpy(componentName, "");
 801cbd8:	687b      	ldr	r3, [r7, #4]
 801cbda:	2200      	movs	r2, #0
 801cbdc:	701a      	strb	r2, [r3, #0]
      json_value_free(tempJSON);
 801cbde:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 801cbe0:	f004 fdac 	bl	802173c <json_value_free>
      return PNPL_NO_ERROR_CODE;
 801cbe4:	2300      	movs	r3, #0
 801cbe6:	e003      	b.n	801cbf0 <extract_PnPL_cmd_data+0x1f8>
    else
    {
      /* nothing to do */
    }
  }
  json_value_free(tempJSON);
 801cbe8:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 801cbea:	f004 fda7 	bl	802173c <json_value_free>
  /* Not JSON command! */
  return PNPL_BASE_ERROR_CODE;
 801cbee:	2301      	movs	r3, #1
}
 801cbf0:	4618      	mov	r0, r3
 801cbf2:	3734      	adds	r7, #52	@ 0x34
 801cbf4:	46bd      	mov	sp, r7
 801cbf6:	bd90      	pop	{r4, r7, pc}
 801cbf8:	200018ac 	.word	0x200018ac
 801cbfc:	08028d74 	.word	0x08028d74
 801cc00:	08028d80 	.word	0x08028d80
 801cc04:	08028d98 	.word	0x08028d98
 801cc08:	08028da8 	.word	0x08028da8
 801cc0c:	08028db4 	.word	0x08028db4
 801cc10:	08028dc0 	.word	0x08028dc0
 801cc14:	08028dd4 	.word	0x08028dd4

0801cc18 <PnPLParseCommand>:

uint8_t PnPLParseCommand(char *commandString, PnPLCommand_t *command)
{
 801cc18:	b590      	push	{r4, r7, lr}
 801cc1a:	b099      	sub	sp, #100	@ 0x64
 801cc1c:	af00      	add	r7, sp, #0
 801cc1e:	6078      	str	r0, [r7, #4]
 801cc20:	6039      	str	r1, [r7, #0]
  uint8_t commandType = 0;
 801cc22:	2300      	movs	r3, #0
 801cc24:	f887 304f 	strb.w	r3, [r7, #79]	@ 0x4f
  char componentName[2 *
                     COMP_KEY_MAX_LENGTH]; /* 2* because this could be a comp or a comm key. If comm_key this is in the form (comp_key*comm_key) */
  uint8_t ret = extract_PnPL_cmd_data(commandString, &commandType, componentName);
 801cc28:	f107 020c 	add.w	r2, r7, #12
 801cc2c:	f107 034f 	add.w	r3, r7, #79	@ 0x4f
 801cc30:	4619      	mov	r1, r3
 801cc32:	6878      	ldr	r0, [r7, #4]
 801cc34:	f7ff fee0 	bl	801c9f8 <extract_PnPL_cmd_data>
 801cc38:	4603      	mov	r3, r0
 801cc3a:	f887 305c 	strb.w	r3, [r7, #92]	@ 0x5c

  command->comm_type = commandType;
 801cc3e:	f897 204f 	ldrb.w	r2, [r7, #79]	@ 0x4f
 801cc42:	683b      	ldr	r3, [r7, #0]
 801cc44:	701a      	strb	r2, [r3, #0]
  (void)strcpy(command->comp_name, componentName);
 801cc46:	683b      	ldr	r3, [r7, #0]
 801cc48:	3301      	adds	r3, #1
 801cc4a:	f107 020c 	add.w	r2, r7, #12
 801cc4e:	4611      	mov	r1, r2
 801cc50:	4618      	mov	r0, r3
 801cc52:	f007 fab6 	bl	80241c2 <strcpy>

  if (ret == PNPL_NO_ERROR_CODE)
 801cc56:	f897 305c 	ldrb.w	r3, [r7, #92]	@ 0x5c
 801cc5a:	2b00      	cmp	r3, #0
 801cc5c:	f040 808d 	bne.w	801cd7a <PnPLParseCommand+0x162>
  {
    if (commandType == PNPL_CMD_SET)
 801cc60:	f897 304f 	ldrb.w	r3, [r7, #79]	@ 0x4f
 801cc64:	2b20      	cmp	r3, #32
 801cc66:	d154      	bne.n	801cd12 <PnPLParseCommand+0xfa>
    {
      /* Select right parse/update function */
      for (uint8_t i = 0; i < PnPLGetNComponents(); i++)
 801cc68:	2300      	movs	r3, #0
 801cc6a:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
 801cc6e:	e048      	b.n	801cd02 <PnPLParseCommand+0xea>
      {
        IPnPLComponent_t *p_obj = (IPnPLComponent_t *)(spPnPLObj.Components[i]);
 801cc70:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
 801cc74:	4a45      	ldr	r2, [pc, #276]	@ (801cd8c <PnPLParseCommand+0x174>)
 801cc76:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801cc7a:	65bb      	str	r3, [r7, #88]	@ 0x58
        if (strcmp(componentName, IPnPLComponentGetKey(p_obj)) == 0)
 801cc7c:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 801cc7e:	f7ff fbe4 	bl	801c44a <IPnPLComponentGetKey>
 801cc82:	4602      	mov	r2, r0
 801cc84:	f107 030c 	add.w	r3, r7, #12
 801cc88:	4611      	mov	r1, r2
 801cc8a:	4618      	mov	r0, r3
 801cc8c:	f7e3 faf4 	bl	8000278 <strcmp>
 801cc90:	4603      	mov	r3, r0
 801cc92:	2b00      	cmp	r3, #0
 801cc94:	d103      	bne.n	801cc9e <PnPLParseCommand+0x86>
            strcpy(command->response, set_response);
            pnpl_free(set_response);
          }
          /* SET Response*/
#else
          (void)IPnPLComponentSetProperty(p_obj, commandString);
 801cc96:	6879      	ldr	r1, [r7, #4]
 801cc98:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 801cc9a:	f7ff fc18 	bl	801c4ce <IPnPLComponentSetProperty>
#endif
        }
        uint8_t nOfCommands = IPnPLComponentGetNCommands(p_obj); // 0 if none
 801cc9e:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 801cca0:	f7ff fbe1 	bl	801c466 <IPnPLComponentGetNCommands>
 801cca4:	4603      	mov	r3, r0
 801cca6:	f887 3057 	strb.w	r3, [r7, #87]	@ 0x57
        if (nOfCommands > 0u)
 801ccaa:	f897 3057 	ldrb.w	r3, [r7, #87]	@ 0x57
 801ccae:	2b00      	cmp	r3, #0
 801ccb0:	d022      	beq.n	801ccf8 <PnPLParseCommand+0xe0>
        {
          for (uint8_t j = 0; j < nOfCommands; j++)
 801ccb2:	2300      	movs	r3, #0
 801ccb4:	f887 305e 	strb.w	r3, [r7, #94]	@ 0x5e
 801ccb8:	e018      	b.n	801ccec <PnPLParseCommand+0xd4>
          {
            if (strcmp(IPnPLComponentGetCommandKey(p_obj, j), componentName) == 0)
 801ccba:	f897 305e 	ldrb.w	r3, [r7, #94]	@ 0x5e
 801ccbe:	4619      	mov	r1, r3
 801ccc0:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 801ccc2:	f7ff fbde 	bl	801c482 <IPnPLComponentGetCommandKey>
 801ccc6:	4602      	mov	r2, r0
 801ccc8:	f107 030c 	add.w	r3, r7, #12
 801cccc:	4619      	mov	r1, r3
 801ccce:	4610      	mov	r0, r2
 801ccd0:	f7e3 fad2 	bl	8000278 <strcmp>
 801ccd4:	4603      	mov	r3, r0
 801ccd6:	2b00      	cmp	r3, #0
 801ccd8:	d103      	bne.n	801cce2 <PnPLParseCommand+0xca>
                strcpy(command->response, cmd_response);
                pnpl_free(cmd_response);
              }
              /* CMD Response*/
#else
              (void)IPnPLCommandExecuteFunction(p_obj, commandString);
 801ccda:	6879      	ldr	r1, [r7, #4]
 801ccdc:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 801ccde:	f7ff fc06 	bl	801c4ee <IPnPLCommandExecuteFunction>
          for (uint8_t j = 0; j < nOfCommands; j++)
 801cce2:	f897 305e 	ldrb.w	r3, [r7, #94]	@ 0x5e
 801cce6:	3301      	adds	r3, #1
 801cce8:	f887 305e 	strb.w	r3, [r7, #94]	@ 0x5e
 801ccec:	f897 205e 	ldrb.w	r2, [r7, #94]	@ 0x5e
 801ccf0:	f897 3057 	ldrb.w	r3, [r7, #87]	@ 0x57
 801ccf4:	429a      	cmp	r2, r3
 801ccf6:	d3e0      	bcc.n	801ccba <PnPLParseCommand+0xa2>
      for (uint8_t i = 0; i < PnPLGetNComponents(); i++)
 801ccf8:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
 801ccfc:	3301      	adds	r3, #1
 801ccfe:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
 801cd02:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
 801cd06:	b29c      	uxth	r4, r3
 801cd08:	f7ff fc8c 	bl	801c624 <PnPLGetNComponents>
 801cd0c:	4603      	mov	r3, r0
 801cd0e:	429c      	cmp	r4, r3
 801cd10:	d3ae      	bcc.n	801cc70 <PnPLParseCommand+0x58>
            }
          }
        }
      }
    }
    if (commandType == PNPL_CMD_SYSTEM_CONFIG)
 801cd12:	f897 304f 	ldrb.w	r3, [r7, #79]	@ 0x4f
 801cd16:	2b40      	cmp	r3, #64	@ 0x40
 801cd18:	d127      	bne.n	801cd6a <PnPLParseCommand+0x152>
    {
      for (uint8_t i = 0; i < PnPLGetNComponents(); i++)
 801cd1a:	2300      	movs	r3, #0
 801cd1c:	f887 305d 	strb.w	r3, [r7, #93]	@ 0x5d
 801cd20:	e01b      	b.n	801cd5a <PnPLParseCommand+0x142>
      {
        IPnPLComponent_t *p_obj = (IPnPLComponent_t *)(spPnPLObj.Components[i]);
 801cd22:	f897 305d 	ldrb.w	r3, [r7, #93]	@ 0x5d
 801cd26:	4a19      	ldr	r2, [pc, #100]	@ (801cd8c <PnPLParseCommand+0x174>)
 801cd28:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801cd2c:	653b      	str	r3, [r7, #80]	@ 0x50
        if (strcmp(componentName, IPnPLComponentGetKey(p_obj)) == 0)
 801cd2e:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 801cd30:	f7ff fb8b 	bl	801c44a <IPnPLComponentGetKey>
 801cd34:	4602      	mov	r2, r0
 801cd36:	f107 030c 	add.w	r3, r7, #12
 801cd3a:	4611      	mov	r1, r2
 801cd3c:	4618      	mov	r0, r3
 801cd3e:	f7e3 fa9b 	bl	8000278 <strcmp>
 801cd42:	4603      	mov	r3, r0
 801cd44:	2b00      	cmp	r3, #0
 801cd46:	d103      	bne.n	801cd50 <PnPLParseCommand+0x138>
            strcpy(command->response, set_response);
            pnpl_free(set_response);
          }
          /* SET Response*/
#else
          (void)IPnPLComponentSetProperty(p_obj, commandString);
 801cd48:	6879      	ldr	r1, [r7, #4]
 801cd4a:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 801cd4c:	f7ff fbbf 	bl	801c4ce <IPnPLComponentSetProperty>
      for (uint8_t i = 0; i < PnPLGetNComponents(); i++)
 801cd50:	f897 305d 	ldrb.w	r3, [r7, #93]	@ 0x5d
 801cd54:	3301      	adds	r3, #1
 801cd56:	f887 305d 	strb.w	r3, [r7, #93]	@ 0x5d
 801cd5a:	f897 305d 	ldrb.w	r3, [r7, #93]	@ 0x5d
 801cd5e:	b29c      	uxth	r4, r3
 801cd60:	f7ff fc60 	bl	801c624 <PnPLGetNComponents>
 801cd64:	4603      	mov	r3, r0
 801cd66:	429c      	cmp	r4, r3
 801cd68:	d3db      	bcc.n	801cd22 <PnPLParseCommand+0x10a>
#endif
        }
      }
    }
    if (commandType == PNPL_CMD_UPDATE_DEVICE)
 801cd6a:	f897 304f 	ldrb.w	r3, [r7, #79]	@ 0x4f
 801cd6e:	2b21      	cmp	r3, #33	@ 0x21
 801cd70:	d106      	bne.n	801cd80 <PnPLParseCommand+0x168>
    {
      (void)PnPLUpdateDeviceStatusFromJSON(commandString);
 801cd72:	6878      	ldr	r0, [r7, #4]
 801cd74:	f7ff fd90 	bl	801c898 <PnPLUpdateDeviceStatusFromJSON>
 801cd78:	e002      	b.n	801cd80 <PnPLParseCommand+0x168>
    }
  }
  else
  {
    command->comm_type = PNPL_CMD_ERROR;
 801cd7a:	683b      	ldr	r3, [r7, #0]
 801cd7c:	2270      	movs	r2, #112	@ 0x70
 801cd7e:	701a      	strb	r2, [r3, #0]
  }
  return ret;
 801cd80:	f897 305c 	ldrb.w	r3, [r7, #92]	@ 0x5c
}
 801cd84:	4618      	mov	r0, r3
 801cd86:	3764      	adds	r7, #100	@ 0x64
 801cd88:	46bd      	mov	sp, r7
 801cd8a:	bd90      	pop	{r4, r7, pc}
 801cd8c:	200018ac 	.word	0x200018ac

0801cd90 <PnPLSerializeResponse>:

uint8_t PnPLSerializeResponse(PnPLCommand_t *command, char **SerializedJSON, uint32_t *size, uint8_t pretty)
{
 801cd90:	b5b0      	push	{r4, r5, r7, lr}
 801cd92:	b088      	sub	sp, #32
 801cd94:	af00      	add	r7, sp, #0
 801cd96:	60f8      	str	r0, [r7, #12]
 801cd98:	60b9      	str	r1, [r7, #8]
 801cd9a:	607a      	str	r2, [r7, #4]
 801cd9c:	70fb      	strb	r3, [r7, #3]
  uint8_t ret = PNPL_NO_ERROR_CODE;
 801cd9e:	2300      	movs	r3, #0
 801cda0:	77fb      	strb	r3, [r7, #31]

  if (command->comm_type == PNPL_CMD_SYSTEM_INFO)
 801cda2:	68fb      	ldr	r3, [r7, #12]
 801cda4:	781b      	ldrb	r3, [r3, #0]
 801cda6:	2b50      	cmp	r3, #80	@ 0x50
 801cda8:	d104      	bne.n	801cdb4 <PnPLSerializeResponse+0x24>
  {
    (void)PnPLGetPresentationJSON(SerializedJSON, size);
 801cdaa:	6879      	ldr	r1, [r7, #4]
 801cdac:	68b8      	ldr	r0, [r7, #8]
 801cdae:	f7ff fc45 	bl	801c63c <PnPLGetPresentationJSON>
 801cdb2:	e07e      	b.n	801ceb2 <PnPLSerializeResponse+0x122>
  }
  else if (command->comm_type == PNPL_CMD_GET)
 801cdb4:	68fb      	ldr	r3, [r7, #12]
 801cdb6:	781b      	ldrb	r3, [r3, #0]
 801cdb8:	2b10      	cmp	r3, #16
 801cdba:	d15f      	bne.n	801ce7c <PnPLSerializeResponse+0xec>
  {
    uint16_t comp_found = 0;
 801cdbc:	2300      	movs	r3, #0
 801cdbe:	83bb      	strh	r3, [r7, #28]
    if (strcmp(command->comp_name, "all") == 0)
 801cdc0:	68fb      	ldr	r3, [r7, #12]
 801cdc2:	3301      	adds	r3, #1
 801cdc4:	493d      	ldr	r1, [pc, #244]	@ (801cebc <PnPLSerializeResponse+0x12c>)
 801cdc6:	4618      	mov	r0, r3
 801cdc8:	f7e3 fa56 	bl	8000278 <strcmp>
 801cdcc:	4603      	mov	r3, r0
 801cdce:	2b00      	cmp	r3, #0
 801cdd0:	d10a      	bne.n	801cde8 <PnPLSerializeResponse+0x58>
    {
      (void)PnPLGetDeviceStatusJSON(SerializedJSON, size, pretty);
 801cdd2:	78fb      	ldrb	r3, [r7, #3]
 801cdd4:	461a      	mov	r2, r3
 801cdd6:	6879      	ldr	r1, [r7, #4]
 801cdd8:	68b8      	ldr	r0, [r7, #8]
 801cdda:	f7ff fc77 	bl	801c6cc <PnPLGetDeviceStatusJSON>
      comp_found = PnPLGetNComponents();
 801cdde:	f7ff fc21 	bl	801c624 <PnPLGetNComponents>
 801cde2:	4603      	mov	r3, r0
 801cde4:	83bb      	strh	r3, [r7, #28]
 801cde6:	e02c      	b.n	801ce42 <PnPLSerializeResponse+0xb2>
    }
    else
    {
      for (uint8_t i = 0; i < PnPLGetNComponents(); i++)
 801cde8:	2300      	movs	r3, #0
 801cdea:	76fb      	strb	r3, [r7, #27]
 801cdec:	e020      	b.n	801ce30 <PnPLSerializeResponse+0xa0>
      {
        IPnPLComponent_t *p_obj = (IPnPLComponent_t *)(spPnPLObj.Components[i]);
 801cdee:	7efb      	ldrb	r3, [r7, #27]
 801cdf0:	4a33      	ldr	r2, [pc, #204]	@ (801cec0 <PnPLSerializeResponse+0x130>)
 801cdf2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801cdf6:	617b      	str	r3, [r7, #20]
        if (strcmp(command->comp_name, IPnPLComponentGetKey(p_obj)) == 0)
 801cdf8:	68fb      	ldr	r3, [r7, #12]
 801cdfa:	1c5c      	adds	r4, r3, #1
 801cdfc:	6978      	ldr	r0, [r7, #20]
 801cdfe:	f7ff fb24 	bl	801c44a <IPnPLComponentGetKey>
 801ce02:	4603      	mov	r3, r0
 801ce04:	4619      	mov	r1, r3
 801ce06:	4620      	mov	r0, r4
 801ce08:	f7e3 fa36 	bl	8000278 <strcmp>
 801ce0c:	4603      	mov	r3, r0
 801ce0e:	2b00      	cmp	r3, #0
 801ce10:	d10b      	bne.n	801ce2a <PnPLSerializeResponse+0x9a>
        {
          if (IPnPLComponentGetStatus(p_obj, SerializedJSON, size, pretty) == 0u)
 801ce12:	78fb      	ldrb	r3, [r7, #3]
 801ce14:	687a      	ldr	r2, [r7, #4]
 801ce16:	68b9      	ldr	r1, [r7, #8]
 801ce18:	6978      	ldr	r0, [r7, #20]
 801ce1a:	f7ff fb44 	bl	801c4a6 <IPnPLComponentGetStatus>
 801ce1e:	4603      	mov	r3, r0
 801ce20:	2b00      	cmp	r3, #0
 801ce22:	d10d      	bne.n	801ce40 <PnPLSerializeResponse+0xb0>
          {
            comp_found = 1;
 801ce24:	2301      	movs	r3, #1
 801ce26:	83bb      	strh	r3, [r7, #28]
          }
          break;
 801ce28:	e00a      	b.n	801ce40 <PnPLSerializeResponse+0xb0>
      for (uint8_t i = 0; i < PnPLGetNComponents(); i++)
 801ce2a:	7efb      	ldrb	r3, [r7, #27]
 801ce2c:	3301      	adds	r3, #1
 801ce2e:	76fb      	strb	r3, [r7, #27]
 801ce30:	7efb      	ldrb	r3, [r7, #27]
 801ce32:	b29c      	uxth	r4, r3
 801ce34:	f7ff fbf6 	bl	801c624 <PnPLGetNComponents>
 801ce38:	4603      	mov	r3, r0
 801ce3a:	429c      	cmp	r4, r3
 801ce3c:	d3d7      	bcc.n	801cdee <PnPLSerializeResponse+0x5e>
 801ce3e:	e000      	b.n	801ce42 <PnPLSerializeResponse+0xb2>
          break;
 801ce40:	bf00      	nop
        }
      }
    }
    if (comp_found == 0u)
 801ce42:	8bbb      	ldrh	r3, [r7, #28]
 801ce44:	2b00      	cmp	r3, #0
 801ce46:	d134      	bne.n	801ceb2 <PnPLSerializeResponse+0x122>
    {
      *size = 18;
 801ce48:	687b      	ldr	r3, [r7, #4]
 801ce4a:	2212      	movs	r2, #18
 801ce4c:	601a      	str	r2, [r3, #0]
      *SerializedJSON = (char*)pnpl_malloc(*size);
 801ce4e:	687b      	ldr	r3, [r7, #4]
 801ce50:	681b      	ldr	r3, [r3, #0]
 801ce52:	4618      	mov	r0, r3
 801ce54:	f7ff fb7c 	bl	801c550 <pnpl_malloc>
 801ce58:	4602      	mov	r2, r0
 801ce5a:	68bb      	ldr	r3, [r7, #8]
 801ce5c:	601a      	str	r2, [r3, #0]
      (void)strcpy(*SerializedJSON, "{\"PnPL_Error\":\"\"}\0");
 801ce5e:	68bb      	ldr	r3, [r7, #8]
 801ce60:	681b      	ldr	r3, [r3, #0]
 801ce62:	4a18      	ldr	r2, [pc, #96]	@ (801cec4 <PnPLSerializeResponse+0x134>)
 801ce64:	461d      	mov	r5, r3
 801ce66:	4614      	mov	r4, r2
 801ce68:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801ce6a:	6028      	str	r0, [r5, #0]
 801ce6c:	6069      	str	r1, [r5, #4]
 801ce6e:	60aa      	str	r2, [r5, #8]
 801ce70:	60eb      	str	r3, [r5, #12]
 801ce72:	8823      	ldrh	r3, [r4, #0]
 801ce74:	822b      	strh	r3, [r5, #16]
      ret = PNPL_BASE_ERROR_CODE;
 801ce76:	2301      	movs	r3, #1
 801ce78:	77fb      	strb	r3, [r7, #31]
 801ce7a:	e01a      	b.n	801ceb2 <PnPLSerializeResponse+0x122>
    *SerializedJSON = (char*)pnpl_malloc(*size);
    (void)strcpy(*SerializedJSON, command->response);
    pnpl_free(command->response);
  }
#endif
  else if (command->comm_type == PNPL_CMD_ERROR)
 801ce7c:	68fb      	ldr	r3, [r7, #12]
 801ce7e:	781b      	ldrb	r3, [r3, #0]
 801ce80:	2b70      	cmp	r3, #112	@ 0x70
 801ce82:	d116      	bne.n	801ceb2 <PnPLSerializeResponse+0x122>
  {
    *size = 18;
 801ce84:	687b      	ldr	r3, [r7, #4]
 801ce86:	2212      	movs	r2, #18
 801ce88:	601a      	str	r2, [r3, #0]
    *SerializedJSON = (char*)pnpl_malloc(*size);
 801ce8a:	687b      	ldr	r3, [r7, #4]
 801ce8c:	681b      	ldr	r3, [r3, #0]
 801ce8e:	4618      	mov	r0, r3
 801ce90:	f7ff fb5e 	bl	801c550 <pnpl_malloc>
 801ce94:	4602      	mov	r2, r0
 801ce96:	68bb      	ldr	r3, [r7, #8]
 801ce98:	601a      	str	r2, [r3, #0]
    (void)strcpy(*SerializedJSON, "{\"PnPL_Error\":\"\"}\0");
 801ce9a:	68bb      	ldr	r3, [r7, #8]
 801ce9c:	681b      	ldr	r3, [r3, #0]
 801ce9e:	4a09      	ldr	r2, [pc, #36]	@ (801cec4 <PnPLSerializeResponse+0x134>)
 801cea0:	461d      	mov	r5, r3
 801cea2:	4614      	mov	r4, r2
 801cea4:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801cea6:	6028      	str	r0, [r5, #0]
 801cea8:	6069      	str	r1, [r5, #4]
 801ceaa:	60aa      	str	r2, [r5, #8]
 801ceac:	60eb      	str	r3, [r5, #12]
 801ceae:	8823      	ldrh	r3, [r4, #0]
 801ceb0:	822b      	strh	r3, [r5, #16]
  }
  else
  {
    /* nothing to do */
  }
  return ret;
 801ceb2:	7ffb      	ldrb	r3, [r7, #31]
}
 801ceb4:	4618      	mov	r0, r3
 801ceb6:	3720      	adds	r7, #32
 801ceb8:	46bd      	mov	sp, r7
 801ceba:	bdb0      	pop	{r4, r5, r7, pc}
 801cebc:	08028de4 	.word	0x08028de4
 801cec0:	200018ac 	.word	0x200018ac
 801cec4:	08028de8 	.word	0x08028de8

0801cec8 <BLE_InitBatteryService>:
  * @brief  Init battery info service
  * @param  None
  * @retval BleCharTypeDef* BleCharPointer: Data structure pointer for battery info service
  */
BleCharTypeDef *BLE_InitBatteryService(void)
{
 801cec8:	b580      	push	{r7, lr}
 801ceca:	b082      	sub	sp, #8
 801cecc:	af00      	add	r7, sp, #0
  /* Data structure pointer for BLE service */
  BleCharTypeDef *BleCharPointer;

  /* Init data structure pointer for battery info service */
  BleCharPointer = &BleCharBattery;
 801cece:	4b2b      	ldr	r3, [pc, #172]	@ (801cf7c <BLE_InitBatteryService+0xb4>)
 801ced0:	607b      	str	r3, [r7, #4]
  memset(BleCharPointer, 0, sizeof(BleCharTypeDef));
 801ced2:	222c      	movs	r2, #44	@ 0x2c
 801ced4:	2100      	movs	r1, #0
 801ced6:	6878      	ldr	r0, [r7, #4]
 801ced8:	f007 f8c4 	bl	8024064 <memset>
  BleCharPointer->AttrMod_Request_CB = AttrMod_Request_Battery;
 801cedc:	687b      	ldr	r3, [r7, #4]
 801cede:	4a28      	ldr	r2, [pc, #160]	@ (801cf80 <BLE_InitBatteryService+0xb8>)
 801cee0:	621a      	str	r2, [r3, #32]
  COPY_BATTERY_CHAR_UUID((BleCharPointer->uuid));
 801cee2:	687b      	ldr	r3, [r7, #4]
 801cee4:	221b      	movs	r2, #27
 801cee6:	701a      	strb	r2, [r3, #0]
 801cee8:	687b      	ldr	r3, [r7, #4]
 801ceea:	22c5      	movs	r2, #197	@ 0xc5
 801ceec:	705a      	strb	r2, [r3, #1]
 801ceee:	687b      	ldr	r3, [r7, #4]
 801cef0:	22d5      	movs	r2, #213	@ 0xd5
 801cef2:	709a      	strb	r2, [r3, #2]
 801cef4:	687b      	ldr	r3, [r7, #4]
 801cef6:	22a5      	movs	r2, #165	@ 0xa5
 801cef8:	70da      	strb	r2, [r3, #3]
 801cefa:	687b      	ldr	r3, [r7, #4]
 801cefc:	2202      	movs	r2, #2
 801cefe:	711a      	strb	r2, [r3, #4]
 801cf00:	687b      	ldr	r3, [r7, #4]
 801cf02:	2200      	movs	r2, #0
 801cf04:	715a      	strb	r2, [r3, #5]
 801cf06:	687b      	ldr	r3, [r7, #4]
 801cf08:	2236      	movs	r2, #54	@ 0x36
 801cf0a:	719a      	strb	r2, [r3, #6]
 801cf0c:	687b      	ldr	r3, [r7, #4]
 801cf0e:	22ac      	movs	r2, #172	@ 0xac
 801cf10:	71da      	strb	r2, [r3, #7]
 801cf12:	687b      	ldr	r3, [r7, #4]
 801cf14:	22e1      	movs	r2, #225	@ 0xe1
 801cf16:	721a      	strb	r2, [r3, #8]
 801cf18:	687b      	ldr	r3, [r7, #4]
 801cf1a:	2211      	movs	r2, #17
 801cf1c:	725a      	strb	r2, [r3, #9]
 801cf1e:	687b      	ldr	r3, [r7, #4]
 801cf20:	2201      	movs	r2, #1
 801cf22:	729a      	strb	r2, [r3, #10]
 801cf24:	687b      	ldr	r3, [r7, #4]
 801cf26:	2200      	movs	r2, #0
 801cf28:	72da      	strb	r2, [r3, #11]
 801cf2a:	687b      	ldr	r3, [r7, #4]
 801cf2c:	2200      	movs	r2, #0
 801cf2e:	731a      	strb	r2, [r3, #12]
 801cf30:	687b      	ldr	r3, [r7, #4]
 801cf32:	2200      	movs	r2, #0
 801cf34:	735a      	strb	r2, [r3, #13]
 801cf36:	687b      	ldr	r3, [r7, #4]
 801cf38:	2202      	movs	r2, #2
 801cf3a:	739a      	strb	r2, [r3, #14]
 801cf3c:	687b      	ldr	r3, [r7, #4]
 801cf3e:	2200      	movs	r2, #0
 801cf40:	73da      	strb	r2, [r3, #15]
  BleCharPointer->Char_UUID_Type = UUID_TYPE_128;
 801cf42:	687b      	ldr	r3, [r7, #4]
 801cf44:	2202      	movs	r2, #2
 801cf46:	741a      	strb	r2, [r3, #16]
  BleCharPointer->Char_Value_Length = 2 + 2 + 2 + 2 + 1;
 801cf48:	687b      	ldr	r3, [r7, #4]
 801cf4a:	2209      	movs	r2, #9
 801cf4c:	825a      	strh	r2, [r3, #18]
  BleCharPointer->Char_Properties = CHAR_PROP_NOTIFY;
 801cf4e:	687b      	ldr	r3, [r7, #4]
 801cf50:	2210      	movs	r2, #16
 801cf52:	751a      	strb	r2, [r3, #20]
  BleCharPointer->Security_Permissions = ATTR_PERMISSION_NONE;
 801cf54:	687b      	ldr	r3, [r7, #4]
 801cf56:	2200      	movs	r2, #0
 801cf58:	755a      	strb	r2, [r3, #21]
  BleCharPointer->GATT_Evt_Mask = GATT_NOTIFY_READ_REQ_AND_WAIT_FOR_APPL_RESP;
 801cf5a:	687b      	ldr	r3, [r7, #4]
 801cf5c:	2204      	movs	r2, #4
 801cf5e:	759a      	strb	r2, [r3, #22]
  BleCharPointer->Enc_Key_Size = 16;
 801cf60:	687b      	ldr	r3, [r7, #4]
 801cf62:	2210      	movs	r2, #16
 801cf64:	75da      	strb	r2, [r3, #23]
  BleCharPointer->Is_Variable = 0;
 801cf66:	687b      	ldr	r3, [r7, #4]
 801cf68:	2200      	movs	r2, #0
 801cf6a:	761a      	strb	r2, [r3, #24]

  BLE_MANAGER_PRINTF("BLE Battery features ok\r\n");
 801cf6c:	4805      	ldr	r0, [pc, #20]	@ (801cf84 <BLE_InitBatteryService+0xbc>)
 801cf6e:	f006 ff5d 	bl	8023e2c <puts>

  return BleCharPointer;
 801cf72:	687b      	ldr	r3, [r7, #4]
}
 801cf74:	4618      	mov	r0, r3
 801cf76:	3708      	adds	r7, #8
 801cf78:	46bd      	mov	sp, r7
 801cf7a:	bd80      	pop	{r7, pc}
 801cf7c:	2000192c 	.word	0x2000192c
 801cf80:	0801cf89 	.word	0x0801cf89
 801cf84:	08028e00 	.word	0x08028e00

0801cf88 <AttrMod_Request_Battery>:
  * @param  uint8_t *att_data attribute data
  * @retval None
  */
static void AttrMod_Request_Battery(void *VoidCharPointer, uint16_t attr_handle, uint16_t Offset, uint8_t data_length,
                                    uint8_t *att_data)
{
 801cf88:	b580      	push	{r7, lr}
 801cf8a:	b084      	sub	sp, #16
 801cf8c:	af00      	add	r7, sp, #0
 801cf8e:	60f8      	str	r0, [r7, #12]
 801cf90:	4608      	mov	r0, r1
 801cf92:	4611      	mov	r1, r2
 801cf94:	461a      	mov	r2, r3
 801cf96:	4603      	mov	r3, r0
 801cf98:	817b      	strh	r3, [r7, #10]
 801cf9a:	460b      	mov	r3, r1
 801cf9c:	813b      	strh	r3, [r7, #8]
 801cf9e:	4613      	mov	r3, r2
 801cfa0:	71fb      	strb	r3, [r7, #7]
  if (CustomNotifyEventBattery != NULL)
 801cfa2:	4b0c      	ldr	r3, [pc, #48]	@ (801cfd4 <AttrMod_Request_Battery+0x4c>)
 801cfa4:	681b      	ldr	r3, [r3, #0]
 801cfa6:	2b00      	cmp	r3, #0
 801cfa8:	d010      	beq.n	801cfcc <AttrMod_Request_Battery+0x44>
  {
    if (att_data[0] == 01U)
 801cfaa:	69bb      	ldr	r3, [r7, #24]
 801cfac:	781b      	ldrb	r3, [r3, #0]
 801cfae:	2b01      	cmp	r3, #1
 801cfb0:	d104      	bne.n	801cfbc <AttrMod_Request_Battery+0x34>
    {
      CustomNotifyEventBattery(BLE_NOTIFY_SUB);
 801cfb2:	4b08      	ldr	r3, [pc, #32]	@ (801cfd4 <AttrMod_Request_Battery+0x4c>)
 801cfb4:	681b      	ldr	r3, [r3, #0]
 801cfb6:	2001      	movs	r0, #1
 801cfb8:	4798      	blx	r3
  else
  {
    BLE_MANAGER_PRINTF("--->Bat=%s", (att_data[0] == 01U) ? " ON\r\n" : " OFF\r\n");
  }
#endif /* BLE_DEBUG_LEVEL>1 */
}
 801cfba:	e007      	b.n	801cfcc <AttrMod_Request_Battery+0x44>
    else if (att_data[0] == 0U)
 801cfbc:	69bb      	ldr	r3, [r7, #24]
 801cfbe:	781b      	ldrb	r3, [r3, #0]
 801cfc0:	2b00      	cmp	r3, #0
 801cfc2:	d103      	bne.n	801cfcc <AttrMod_Request_Battery+0x44>
      CustomNotifyEventBattery(BLE_NOTIFY_UNSUB);
 801cfc4:	4b03      	ldr	r3, [pc, #12]	@ (801cfd4 <AttrMod_Request_Battery+0x4c>)
 801cfc6:	681b      	ldr	r3, [r3, #0]
 801cfc8:	2002      	movs	r0, #2
 801cfca:	4798      	blx	r3
}
 801cfcc:	bf00      	nop
 801cfce:	3710      	adds	r7, #16
 801cfd0:	46bd      	mov	sp, r7
 801cfd2:	bd80      	pop	{r7, pc}
 801cfd4:	20001928 	.word	0x20001928

0801cfd8 <BLE_InitEnvService>:
  *                                 1 for enabling only one BLE temperature feature
  *                                 2 for enabling two BLE temperatures feature
  * @retval BleCharTypeDef* BleCharPointer: Data structure pointer for environmental info service
  */
BleCharTypeDef *BLE_InitEnvService(uint8_t PressEnable, uint8_t HumEnable, uint8_t NumTempEnabled)
{
 801cfd8:	b580      	push	{r7, lr}
 801cfda:	b084      	sub	sp, #16
 801cfdc:	af00      	add	r7, sp, #0
 801cfde:	4603      	mov	r3, r0
 801cfe0:	71fb      	strb	r3, [r7, #7]
 801cfe2:	460b      	mov	r3, r1
 801cfe4:	71bb      	strb	r3, [r7, #6]
 801cfe6:	4613      	mov	r3, r2
 801cfe8:	717b      	strb	r3, [r7, #5]
  /* Data structure pointer for BLE service */
  BleCharTypeDef *BleCharPointer = NULL;
 801cfea:	2300      	movs	r3, #0
 801cfec:	60fb      	str	r3, [r7, #12]
  EnvironmentalCharSize = 2;
 801cfee:	4b5f      	ldr	r3, [pc, #380]	@ (801d16c <BLE_InitEnvService+0x194>)
 801cff0:	2202      	movs	r2, #2
 801cff2:	701a      	strb	r2, [r3, #0]

  /* Init data structure for identify environmental info services enabled */
  EnvFeaturesEnabled.PressureIsEnable = PressEnable;
 801cff4:	4a5e      	ldr	r2, [pc, #376]	@ (801d170 <BLE_InitEnvService+0x198>)
 801cff6:	79fb      	ldrb	r3, [r7, #7]
 801cff8:	7013      	strb	r3, [r2, #0]
  EnvFeaturesEnabled.HumidityIsEnable = HumEnable;
 801cffa:	4a5d      	ldr	r2, [pc, #372]	@ (801d170 <BLE_InitEnvService+0x198>)
 801cffc:	79bb      	ldrb	r3, [r7, #6]
 801cffe:	7053      	strb	r3, [r2, #1]
  EnvFeaturesEnabled.NumberTemperaturesEnabled = NumTempEnabled;
 801d000:	4a5b      	ldr	r2, [pc, #364]	@ (801d170 <BLE_InitEnvService+0x198>)
 801d002:	797b      	ldrb	r3, [r7, #5]
 801d004:	7093      	strb	r3, [r2, #2]

  if ((PressEnable == 1U) ||
 801d006:	79fb      	ldrb	r3, [r7, #7]
 801d008:	2b01      	cmp	r3, #1
 801d00a:	d006      	beq.n	801d01a <BLE_InitEnvService+0x42>
 801d00c:	79bb      	ldrb	r3, [r7, #6]
 801d00e:	2b01      	cmp	r3, #1
 801d010:	d003      	beq.n	801d01a <BLE_InitEnvService+0x42>
      (HumEnable == 1U)   ||
 801d012:	797b      	ldrb	r3, [r7, #5]
 801d014:	2b00      	cmp	r3, #0
 801d016:	f000 80a0 	beq.w	801d15a <BLE_InitEnvService+0x182>
      (NumTempEnabled > 0U))
  {
    /* Init data structure pointer for environmental info service */
    BleCharPointer = &BleCharEnv;
 801d01a:	4b56      	ldr	r3, [pc, #344]	@ (801d174 <BLE_InitEnvService+0x19c>)
 801d01c:	60fb      	str	r3, [r7, #12]
    memset(BleCharPointer, 0, sizeof(BleCharTypeDef));
 801d01e:	222c      	movs	r2, #44	@ 0x2c
 801d020:	2100      	movs	r1, #0
 801d022:	68f8      	ldr	r0, [r7, #12]
 801d024:	f007 f81e 	bl	8024064 <memset>
    BleCharPointer->AttrMod_Request_CB = AttrMod_Request_Env;
 801d028:	68fb      	ldr	r3, [r7, #12]
 801d02a:	4a53      	ldr	r2, [pc, #332]	@ (801d178 <BLE_InitEnvService+0x1a0>)
 801d02c:	621a      	str	r2, [r3, #32]
    BleCharPointer->Read_Request_CB = Read_Request_Env;
 801d02e:	68fb      	ldr	r3, [r7, #12]
 801d030:	4a52      	ldr	r2, [pc, #328]	@ (801d17c <BLE_InitEnvService+0x1a4>)
 801d032:	625a      	str	r2, [r3, #36]	@ 0x24
    COPY_ENVIRONMENTAL_CHAR_UUID((BleCharPointer->uuid));
 801d034:	68fb      	ldr	r3, [r7, #12]
 801d036:	221b      	movs	r2, #27
 801d038:	701a      	strb	r2, [r3, #0]
 801d03a:	68fb      	ldr	r3, [r7, #12]
 801d03c:	22c5      	movs	r2, #197	@ 0xc5
 801d03e:	705a      	strb	r2, [r3, #1]
 801d040:	68fb      	ldr	r3, [r7, #12]
 801d042:	22d5      	movs	r2, #213	@ 0xd5
 801d044:	709a      	strb	r2, [r3, #2]
 801d046:	68fb      	ldr	r3, [r7, #12]
 801d048:	22a5      	movs	r2, #165	@ 0xa5
 801d04a:	70da      	strb	r2, [r3, #3]
 801d04c:	68fb      	ldr	r3, [r7, #12]
 801d04e:	2202      	movs	r2, #2
 801d050:	711a      	strb	r2, [r3, #4]
 801d052:	68fb      	ldr	r3, [r7, #12]
 801d054:	2200      	movs	r2, #0
 801d056:	715a      	strb	r2, [r3, #5]
 801d058:	68fb      	ldr	r3, [r7, #12]
 801d05a:	2236      	movs	r2, #54	@ 0x36
 801d05c:	719a      	strb	r2, [r3, #6]
 801d05e:	68fb      	ldr	r3, [r7, #12]
 801d060:	22ac      	movs	r2, #172	@ 0xac
 801d062:	71da      	strb	r2, [r3, #7]
 801d064:	68fb      	ldr	r3, [r7, #12]
 801d066:	22e1      	movs	r2, #225	@ 0xe1
 801d068:	721a      	strb	r2, [r3, #8]
 801d06a:	68fb      	ldr	r3, [r7, #12]
 801d06c:	2211      	movs	r2, #17
 801d06e:	725a      	strb	r2, [r3, #9]
 801d070:	68fb      	ldr	r3, [r7, #12]
 801d072:	2201      	movs	r2, #1
 801d074:	729a      	strb	r2, [r3, #10]
 801d076:	68fb      	ldr	r3, [r7, #12]
 801d078:	2200      	movs	r2, #0
 801d07a:	72da      	strb	r2, [r3, #11]
 801d07c:	68fb      	ldr	r3, [r7, #12]
 801d07e:	2200      	movs	r2, #0
 801d080:	731a      	strb	r2, [r3, #12]
 801d082:	68fb      	ldr	r3, [r7, #12]
 801d084:	2200      	movs	r2, #0
 801d086:	735a      	strb	r2, [r3, #13]
 801d088:	68fb      	ldr	r3, [r7, #12]
 801d08a:	2200      	movs	r2, #0
 801d08c:	739a      	strb	r2, [r3, #14]
 801d08e:	68fb      	ldr	r3, [r7, #12]
 801d090:	2200      	movs	r2, #0
 801d092:	73da      	strb	r2, [r3, #15]

    /* Enables BLE Pressure feature */
    if (PressEnable == 1U)
 801d094:	79fb      	ldrb	r3, [r7, #7]
 801d096:	2b01      	cmp	r3, #1
 801d098:	d10c      	bne.n	801d0b4 <BLE_InitEnvService+0xdc>
    {
      BleCharPointer->uuid[14] |= 0x10U;
 801d09a:	68fb      	ldr	r3, [r7, #12]
 801d09c:	7b9b      	ldrb	r3, [r3, #14]
 801d09e:	f043 0310 	orr.w	r3, r3, #16
 801d0a2:	b2da      	uxtb	r2, r3
 801d0a4:	68fb      	ldr	r3, [r7, #12]
 801d0a6:	739a      	strb	r2, [r3, #14]
      EnvironmentalCharSize += 4U;
 801d0a8:	4b30      	ldr	r3, [pc, #192]	@ (801d16c <BLE_InitEnvService+0x194>)
 801d0aa:	781b      	ldrb	r3, [r3, #0]
 801d0ac:	3304      	adds	r3, #4
 801d0ae:	b2da      	uxtb	r2, r3
 801d0b0:	4b2e      	ldr	r3, [pc, #184]	@ (801d16c <BLE_InitEnvService+0x194>)
 801d0b2:	701a      	strb	r2, [r3, #0]
      BLE_MANAGER_PRINTF("\t--> Pressure feature enabled\r\n");
#endif /* BLE_DEBUG_LEVEL>1 */
    }

    /* Enables BLE Humidity feature */
    if (HumEnable == 1U)
 801d0b4:	79bb      	ldrb	r3, [r7, #6]
 801d0b6:	2b01      	cmp	r3, #1
 801d0b8:	d10c      	bne.n	801d0d4 <BLE_InitEnvService+0xfc>
    {
      BleCharPointer->uuid[14] |= 0x08U;
 801d0ba:	68fb      	ldr	r3, [r7, #12]
 801d0bc:	7b9b      	ldrb	r3, [r3, #14]
 801d0be:	f043 0308 	orr.w	r3, r3, #8
 801d0c2:	b2da      	uxtb	r2, r3
 801d0c4:	68fb      	ldr	r3, [r7, #12]
 801d0c6:	739a      	strb	r2, [r3, #14]
      EnvironmentalCharSize += 2U;
 801d0c8:	4b28      	ldr	r3, [pc, #160]	@ (801d16c <BLE_InitEnvService+0x194>)
 801d0ca:	781b      	ldrb	r3, [r3, #0]
 801d0cc:	3302      	adds	r3, #2
 801d0ce:	b2da      	uxtb	r2, r3
 801d0d0:	4b26      	ldr	r3, [pc, #152]	@ (801d16c <BLE_InitEnvService+0x194>)
 801d0d2:	701a      	strb	r2, [r3, #0]
#if (BLE_DEBUG_LEVEL>1)
      BLE_MANAGER_PRINTF("\t--> Humidity feature enabled\r\n");
#endif /* BLE_DEBUG_LEVEL>1 */
    }

    if (NumTempEnabled == 1U)
 801d0d4:	797b      	ldrb	r3, [r7, #5]
 801d0d6:	2b01      	cmp	r3, #1
 801d0d8:	d10d      	bne.n	801d0f6 <BLE_InitEnvService+0x11e>
    {
      /* Enables only one BLE temperature feature */
      BleCharPointer->uuid[14] |= 0x04U;
 801d0da:	68fb      	ldr	r3, [r7, #12]
 801d0dc:	7b9b      	ldrb	r3, [r3, #14]
 801d0de:	f043 0304 	orr.w	r3, r3, #4
 801d0e2:	b2da      	uxtb	r2, r3
 801d0e4:	68fb      	ldr	r3, [r7, #12]
 801d0e6:	739a      	strb	r2, [r3, #14]
      EnvironmentalCharSize += 2U;
 801d0e8:	4b20      	ldr	r3, [pc, #128]	@ (801d16c <BLE_InitEnvService+0x194>)
 801d0ea:	781b      	ldrb	r3, [r3, #0]
 801d0ec:	3302      	adds	r3, #2
 801d0ee:	b2da      	uxtb	r2, r3
 801d0f0:	4b1e      	ldr	r3, [pc, #120]	@ (801d16c <BLE_InitEnvService+0x194>)
 801d0f2:	701a      	strb	r2, [r3, #0]
 801d0f4:	e00f      	b.n	801d116 <BLE_InitEnvService+0x13e>
#if (BLE_DEBUG_LEVEL>1)
      BLE_MANAGER_PRINTF("\t--> Only one temperature feature enabled\r\n");
#endif /* BLE_DEBUG_LEVEL>1 */
    }
    else if (NumTempEnabled == 2U)
 801d0f6:	797b      	ldrb	r3, [r7, #5]
 801d0f8:	2b02      	cmp	r3, #2
 801d0fa:	d10c      	bne.n	801d116 <BLE_InitEnvService+0x13e>
    {
      /* Enables two BLE temperatures feature */
      BleCharPointer->uuid[14] |= 0x05U;
 801d0fc:	68fb      	ldr	r3, [r7, #12]
 801d0fe:	7b9b      	ldrb	r3, [r3, #14]
 801d100:	f043 0305 	orr.w	r3, r3, #5
 801d104:	b2da      	uxtb	r2, r3
 801d106:	68fb      	ldr	r3, [r7, #12]
 801d108:	739a      	strb	r2, [r3, #14]
      EnvironmentalCharSize += 4U;
 801d10a:	4b18      	ldr	r3, [pc, #96]	@ (801d16c <BLE_InitEnvService+0x194>)
 801d10c:	781b      	ldrb	r3, [r3, #0]
 801d10e:	3304      	adds	r3, #4
 801d110:	b2da      	uxtb	r2, r3
 801d112:	4b16      	ldr	r3, [pc, #88]	@ (801d16c <BLE_InitEnvService+0x194>)
 801d114:	701a      	strb	r2, [r3, #0]
#if (BLE_DEBUG_LEVEL>1)
      BLE_MANAGER_PRINTF("\t--> Two temperatures features enabled\r\n");
#endif /* BLE_DEBUG_LEVEL>1 */
    }

    BleCharPointer->Char_UUID_Type = UUID_TYPE_128;
 801d116:	68fb      	ldr	r3, [r7, #12]
 801d118:	2202      	movs	r2, #2
 801d11a:	741a      	strb	r2, [r3, #16]
    BleCharPointer->Char_Value_Length = EnvironmentalCharSize;
 801d11c:	4b13      	ldr	r3, [pc, #76]	@ (801d16c <BLE_InitEnvService+0x194>)
 801d11e:	781b      	ldrb	r3, [r3, #0]
 801d120:	461a      	mov	r2, r3
 801d122:	68fb      	ldr	r3, [r7, #12]
 801d124:	825a      	strh	r2, [r3, #18]
    BleCharPointer->Char_Properties = ((uint8_t)(CHAR_PROP_NOTIFY)) | ((uint8_t)(CHAR_PROP_READ));
 801d126:	68fb      	ldr	r3, [r7, #12]
 801d128:	2212      	movs	r2, #18
 801d12a:	751a      	strb	r2, [r3, #20]
    BleCharPointer->Security_Permissions = ATTR_PERMISSION_NONE;
 801d12c:	68fb      	ldr	r3, [r7, #12]
 801d12e:	2200      	movs	r2, #0
 801d130:	755a      	strb	r2, [r3, #21]
    BleCharPointer->GATT_Evt_Mask = GATT_NOTIFY_READ_REQ_AND_WAIT_FOR_APPL_RESP;
 801d132:	68fb      	ldr	r3, [r7, #12]
 801d134:	2204      	movs	r2, #4
 801d136:	759a      	strb	r2, [r3, #22]
    BleCharPointer->Enc_Key_Size = 16;
 801d138:	68fb      	ldr	r3, [r7, #12]
 801d13a:	2210      	movs	r2, #16
 801d13c:	75da      	strb	r2, [r3, #23]
    BleCharPointer->Is_Variable = 0;
 801d13e:	68fb      	ldr	r3, [r7, #12]
 801d140:	2200      	movs	r2, #0
 801d142:	761a      	strb	r2, [r3, #24]

    if (CustomReadRequestEnv == NULL)
 801d144:	4b0e      	ldr	r3, [pc, #56]	@ (801d180 <BLE_InitEnvService+0x1a8>)
 801d146:	681b      	ldr	r3, [r3, #0]
 801d148:	2b00      	cmp	r3, #0
 801d14a:	d102      	bne.n	801d152 <BLE_InitEnvService+0x17a>
    {
      BLE_MANAGER_PRINTF("Warning: Read request environmental function not defined\r\n");
 801d14c:	480d      	ldr	r0, [pc, #52]	@ (801d184 <BLE_InitEnvService+0x1ac>)
 801d14e:	f006 fe6d 	bl	8023e2c <puts>
    }

    BLE_MANAGER_PRINTF("BLE Environmental features ok\r\n");
 801d152:	480d      	ldr	r0, [pc, #52]	@ (801d188 <BLE_InitEnvService+0x1b0>)
 801d154:	f006 fe6a 	bl	8023e2c <puts>
 801d158:	e002      	b.n	801d160 <BLE_InitEnvService+0x188>
  }
  else
  {
    BLE_MANAGER_PRINTF(" ERROR: None environmental features is enabled\r\n");
 801d15a:	480c      	ldr	r0, [pc, #48]	@ (801d18c <BLE_InitEnvService+0x1b4>)
 801d15c:	f006 fe66 	bl	8023e2c <puts>
  }

  return BleCharPointer;
 801d160:	68fb      	ldr	r3, [r7, #12]
}
 801d162:	4618      	mov	r0, r3
 801d164:	3710      	adds	r7, #16
 801d166:	46bd      	mov	sp, r7
 801d168:	bd80      	pop	{r7, pc}
 801d16a:	bf00      	nop
 801d16c:	20001990 	.word	0x20001990
 801d170:	20001960 	.word	0x20001960
 801d174:	20001964 	.word	0x20001964
 801d178:	0801d191 	.word	0x0801d191
 801d17c:	0801d1e1 	.word	0x0801d1e1
 801d180:	20001958 	.word	0x20001958
 801d184:	08028e54 	.word	0x08028e54
 801d188:	08028e90 	.word	0x08028e90
 801d18c:	08028eb0 	.word	0x08028eb0

0801d190 <AttrMod_Request_Env>:
  * @param  uint8_t *att_data attribute data
  * @retval None
  */
static void AttrMod_Request_Env(void *VoidCharPointer, uint16_t attr_handle, uint16_t Offset, uint8_t data_length,
                                uint8_t *att_data)
{
 801d190:	b580      	push	{r7, lr}
 801d192:	b084      	sub	sp, #16
 801d194:	af00      	add	r7, sp, #0
 801d196:	60f8      	str	r0, [r7, #12]
 801d198:	4608      	mov	r0, r1
 801d19a:	4611      	mov	r1, r2
 801d19c:	461a      	mov	r2, r3
 801d19e:	4603      	mov	r3, r0
 801d1a0:	817b      	strh	r3, [r7, #10]
 801d1a2:	460b      	mov	r3, r1
 801d1a4:	813b      	strh	r3, [r7, #8]
 801d1a6:	4613      	mov	r3, r2
 801d1a8:	71fb      	strb	r3, [r7, #7]
  if (CustomNotifyEventEnv != NULL)
 801d1aa:	4b0c      	ldr	r3, [pc, #48]	@ (801d1dc <AttrMod_Request_Env+0x4c>)
 801d1ac:	681b      	ldr	r3, [r3, #0]
 801d1ae:	2b00      	cmp	r3, #0
 801d1b0:	d010      	beq.n	801d1d4 <AttrMod_Request_Env+0x44>
  {
    if (att_data[0] == 01U)
 801d1b2:	69bb      	ldr	r3, [r7, #24]
 801d1b4:	781b      	ldrb	r3, [r3, #0]
 801d1b6:	2b01      	cmp	r3, #1
 801d1b8:	d104      	bne.n	801d1c4 <AttrMod_Request_Env+0x34>
    {
      CustomNotifyEventEnv(BLE_NOTIFY_SUB);
 801d1ba:	4b08      	ldr	r3, [pc, #32]	@ (801d1dc <AttrMod_Request_Env+0x4c>)
 801d1bc:	681b      	ldr	r3, [r3, #0]
 801d1be:	2001      	movs	r0, #1
 801d1c0:	4798      	blx	r3
  else
  {
    BLE_MANAGER_PRINTF("--->Env=%s", (att_data[0] == 01U) ? " ON\r\n" : " OFF\r\n");
  }
#endif /* BLE_DEBUG_LEVEL>1 */
}
 801d1c2:	e007      	b.n	801d1d4 <AttrMod_Request_Env+0x44>
    else if (att_data[0] == 0U)
 801d1c4:	69bb      	ldr	r3, [r7, #24]
 801d1c6:	781b      	ldrb	r3, [r3, #0]
 801d1c8:	2b00      	cmp	r3, #0
 801d1ca:	d103      	bne.n	801d1d4 <AttrMod_Request_Env+0x44>
      CustomNotifyEventEnv(BLE_NOTIFY_UNSUB);
 801d1cc:	4b03      	ldr	r3, [pc, #12]	@ (801d1dc <AttrMod_Request_Env+0x4c>)
 801d1ce:	681b      	ldr	r3, [r3, #0]
 801d1d0:	2002      	movs	r0, #2
 801d1d2:	4798      	blx	r3
}
 801d1d4:	bf00      	nop
 801d1d6:	3710      	adds	r7, #16
 801d1d8:	46bd      	mov	sp, r7
 801d1da:	bd80      	pop	{r7, pc}
 801d1dc:	2000195c 	.word	0x2000195c

0801d1e0 <Read_Request_Env>:
                             uint16_t Connection_Handle,
                             uint8_t Operation_Type,
                             uint16_t Attr_Val_Offset,
                             uint8_t Data_Length,
                             uint8_t Data[])
{
 801d1e0:	b590      	push	{r4, r7, lr}
 801d1e2:	b091      	sub	sp, #68	@ 0x44
 801d1e4:	af04      	add	r7, sp, #16
 801d1e6:	60f8      	str	r0, [r7, #12]
 801d1e8:	4608      	mov	r0, r1
 801d1ea:	4611      	mov	r1, r2
 801d1ec:	461a      	mov	r2, r3
 801d1ee:	4603      	mov	r3, r0
 801d1f0:	817b      	strh	r3, [r7, #10]
 801d1f2:	460b      	mov	r3, r1
 801d1f4:	813b      	strh	r3, [r7, #8]
 801d1f6:	4613      	mov	r3, r2
 801d1f8:	71fb      	strb	r3, [r7, #7]
  tBleStatus ret;
  if (CustomReadRequestEnv != NULL)
 801d1fa:	4b7d      	ldr	r3, [pc, #500]	@ (801d3f0 <Read_Request_Env+0x210>)
 801d1fc:	681b      	ldr	r3, [r3, #0]
 801d1fe:	2b00      	cmp	r3, #0
 801d200:	f000 80d1 	beq.w	801d3a6 <Read_Request_Env+0x1c6>
    int16_t Temp1;
    int16_t Temp2;
    uint8_t BuffPos;
    uint8_t buff[2 + 4/*Press*/ + 2/*Hum*/ + 2/*Temp1*/ + 2/*Temp2*/];

    CustomReadRequestEnv(&Press, &Hum, &Temp1, &Temp2);
 801d204:	4b7a      	ldr	r3, [pc, #488]	@ (801d3f0 <Read_Request_Env+0x210>)
 801d206:	681c      	ldr	r4, [r3, #0]
 801d208:	f107 0322 	add.w	r3, r7, #34	@ 0x22
 801d20c:	f107 0224 	add.w	r2, r7, #36	@ 0x24
 801d210:	f107 0126 	add.w	r1, r7, #38	@ 0x26
 801d214:	f107 0028 	add.w	r0, r7, #40	@ 0x28
 801d218:	47a0      	blx	r4

    /* Time Stamp */
    STORE_LE_16(buff, (HAL_GetTick() / 10));
 801d21a:	f7f0 fc21 	bl	800da60 <HAL_GetTick>
 801d21e:	4603      	mov	r3, r0
 801d220:	4a74      	ldr	r2, [pc, #464]	@ (801d3f4 <Read_Request_Env+0x214>)
 801d222:	fba2 2303 	umull	r2, r3, r2, r3
 801d226:	08db      	lsrs	r3, r3, #3
 801d228:	b2db      	uxtb	r3, r3
 801d22a:	753b      	strb	r3, [r7, #20]
 801d22c:	f7f0 fc18 	bl	800da60 <HAL_GetTick>
 801d230:	4603      	mov	r3, r0
 801d232:	4a70      	ldr	r2, [pc, #448]	@ (801d3f4 <Read_Request_Env+0x214>)
 801d234:	fba2 2303 	umull	r2, r3, r2, r3
 801d238:	08db      	lsrs	r3, r3, #3
 801d23a:	0a1b      	lsrs	r3, r3, #8
 801d23c:	b2db      	uxtb	r3, r3
 801d23e:	757b      	strb	r3, [r7, #21]
    BuffPos = 2;
 801d240:	2302      	movs	r3, #2
 801d242:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f

    if (EnvFeaturesEnabled.PressureIsEnable == 1U)
 801d246:	4b6c      	ldr	r3, [pc, #432]	@ (801d3f8 <Read_Request_Env+0x218>)
 801d248:	781b      	ldrb	r3, [r3, #0]
 801d24a:	2b01      	cmp	r3, #1
 801d24c:	d12a      	bne.n	801d2a4 <Read_Request_Env+0xc4>
    {
      STORE_LE_32((buff + BuffPos), ((uint32_t)Press));
 801d24e:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 801d250:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 801d254:	f107 0214 	add.w	r2, r7, #20
 801d258:	4413      	add	r3, r2
 801d25a:	b2ca      	uxtb	r2, r1
 801d25c:	701a      	strb	r2, [r3, #0]
 801d25e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801d260:	0a19      	lsrs	r1, r3, #8
 801d262:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 801d266:	3301      	adds	r3, #1
 801d268:	f107 0214 	add.w	r2, r7, #20
 801d26c:	4413      	add	r3, r2
 801d26e:	b2ca      	uxtb	r2, r1
 801d270:	701a      	strb	r2, [r3, #0]
 801d272:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801d274:	0c19      	lsrs	r1, r3, #16
 801d276:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 801d27a:	3302      	adds	r3, #2
 801d27c:	f107 0214 	add.w	r2, r7, #20
 801d280:	4413      	add	r3, r2
 801d282:	b2ca      	uxtb	r2, r1
 801d284:	701a      	strb	r2, [r3, #0]
 801d286:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801d288:	0e19      	lsrs	r1, r3, #24
 801d28a:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 801d28e:	3303      	adds	r3, #3
 801d290:	f107 0214 	add.w	r2, r7, #20
 801d294:	4413      	add	r3, r2
 801d296:	b2ca      	uxtb	r2, r1
 801d298:	701a      	strb	r2, [r3, #0]
      BuffPos += 4U;
 801d29a:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 801d29e:	3304      	adds	r3, #4
 801d2a0:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
    }

    if (EnvFeaturesEnabled.HumidityIsEnable == 1U)
 801d2a4:	4b54      	ldr	r3, [pc, #336]	@ (801d3f8 <Read_Request_Env+0x218>)
 801d2a6:	785b      	ldrb	r3, [r3, #1]
 801d2a8:	2b01      	cmp	r3, #1
 801d2aa:	d117      	bne.n	801d2dc <Read_Request_Env+0xfc>
    {
      STORE_LE_16((buff + BuffPos), Hum);
 801d2ac:	8cf9      	ldrh	r1, [r7, #38]	@ 0x26
 801d2ae:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 801d2b2:	f107 0214 	add.w	r2, r7, #20
 801d2b6:	4413      	add	r3, r2
 801d2b8:	b2ca      	uxtb	r2, r1
 801d2ba:	701a      	strb	r2, [r3, #0]
 801d2bc:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 801d2be:	0a1b      	lsrs	r3, r3, #8
 801d2c0:	b299      	uxth	r1, r3
 801d2c2:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 801d2c6:	3301      	adds	r3, #1
 801d2c8:	f107 0214 	add.w	r2, r7, #20
 801d2cc:	4413      	add	r3, r2
 801d2ce:	b2ca      	uxtb	r2, r1
 801d2d0:	701a      	strb	r2, [r3, #0]
      BuffPos += 2U;
 801d2d2:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 801d2d6:	3302      	adds	r3, #2
 801d2d8:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
    }

    if (EnvFeaturesEnabled.NumberTemperaturesEnabled >= 1U)
 801d2dc:	4b46      	ldr	r3, [pc, #280]	@ (801d3f8 <Read_Request_Env+0x218>)
 801d2de:	789b      	ldrb	r3, [r3, #2]
 801d2e0:	2b00      	cmp	r3, #0
 801d2e2:	d01a      	beq.n	801d31a <Read_Request_Env+0x13a>
    {
      STORE_LE_16((buff + BuffPos), ((uint16_t)Temp1));
 801d2e4:	f9b7 1024 	ldrsh.w	r1, [r7, #36]	@ 0x24
 801d2e8:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 801d2ec:	f107 0214 	add.w	r2, r7, #20
 801d2f0:	4413      	add	r3, r2
 801d2f2:	b2ca      	uxtb	r2, r1
 801d2f4:	701a      	strb	r2, [r3, #0]
 801d2f6:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	@ 0x24
 801d2fa:	b29b      	uxth	r3, r3
 801d2fc:	0a1b      	lsrs	r3, r3, #8
 801d2fe:	b299      	uxth	r1, r3
 801d300:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 801d304:	3301      	adds	r3, #1
 801d306:	f107 0214 	add.w	r2, r7, #20
 801d30a:	4413      	add	r3, r2
 801d30c:	b2ca      	uxtb	r2, r1
 801d30e:	701a      	strb	r2, [r3, #0]
      BuffPos += 2U;
 801d310:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 801d314:	3302      	adds	r3, #2
 801d316:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
    }

    if (EnvFeaturesEnabled.NumberTemperaturesEnabled == 2U)
 801d31a:	4b37      	ldr	r3, [pc, #220]	@ (801d3f8 <Read_Request_Env+0x218>)
 801d31c:	789b      	ldrb	r3, [r3, #2]
 801d31e:	2b02      	cmp	r3, #2
 801d320:	d11a      	bne.n	801d358 <Read_Request_Env+0x178>
    {
      STORE_LE_16((buff + BuffPos), ((uint16_t)Temp2));
 801d322:	f9b7 1022 	ldrsh.w	r1, [r7, #34]	@ 0x22
 801d326:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 801d32a:	f107 0214 	add.w	r2, r7, #20
 801d32e:	4413      	add	r3, r2
 801d330:	b2ca      	uxtb	r2, r1
 801d332:	701a      	strb	r2, [r3, #0]
 801d334:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	@ 0x22
 801d338:	b29b      	uxth	r3, r3
 801d33a:	0a1b      	lsrs	r3, r3, #8
 801d33c:	b299      	uxth	r1, r3
 801d33e:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 801d342:	3301      	adds	r3, #1
 801d344:	f107 0214 	add.w	r2, r7, #20
 801d348:	4413      	add	r3, r2
 801d34a:	b2ca      	uxtb	r2, r1
 801d34c:	701a      	strb	r2, [r3, #0]
      BuffPos += 2U;
 801d34e:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 801d352:	3302      	adds	r3, #2
 801d354:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
    }

    ret = aci_gatt_srv_write_handle_value_nwk(handle, 0, EnvironmentalCharSize, buff);
 801d358:	4b28      	ldr	r3, [pc, #160]	@ (801d3fc <Read_Request_Env+0x21c>)
 801d35a:	781b      	ldrb	r3, [r3, #0]
 801d35c:	461a      	mov	r2, r3
 801d35e:	f107 0314 	add.w	r3, r7, #20
 801d362:	8978      	ldrh	r0, [r7, #10]
 801d364:	2100      	movs	r1, #0
 801d366:	f7fb fe6b 	bl	8019040 <aci_gatt_srv_write_handle_value_nwk>
 801d36a:	4603      	mov	r3, r0
 801d36c:	f887 302e 	strb.w	r3, [r7, #46]	@ 0x2e
    if (ret != (tBleStatus)BLE_STATUS_SUCCESS)
 801d370:	f897 302e 	ldrb.w	r3, [r7, #46]	@ 0x2e
 801d374:	2b00      	cmp	r3, #0
 801d376:	d019      	beq.n	801d3ac <Read_Request_Env+0x1cc>
    {
      if (BLE_StdErr_Service == BLE_SERV_ENABLE)
 801d378:	4b21      	ldr	r3, [pc, #132]	@ (801d400 <Read_Request_Env+0x220>)
 801d37a:	781b      	ldrb	r3, [r3, #0]
 801d37c:	2b01      	cmp	r3, #1
 801d37e:	d10e      	bne.n	801d39e <Read_Request_Env+0x1be>
      {
        BytesToWrite = (uint8_t)sprintf((char *)BufferToWrite, "Error Updating Environmental Char\n");
 801d380:	4920      	ldr	r1, [pc, #128]	@ (801d404 <Read_Request_Env+0x224>)
 801d382:	4821      	ldr	r0, [pc, #132]	@ (801d408 <Read_Request_Env+0x228>)
 801d384:	f006 fd5a 	bl	8023e3c <siprintf>
 801d388:	4603      	mov	r3, r0
 801d38a:	b2da      	uxtb	r2, r3
 801d38c:	4b1f      	ldr	r3, [pc, #124]	@ (801d40c <Read_Request_Env+0x22c>)
 801d38e:	701a      	strb	r2, [r3, #0]
        Stderr_Update(BufferToWrite, BytesToWrite);
 801d390:	4b1e      	ldr	r3, [pc, #120]	@ (801d40c <Read_Request_Env+0x22c>)
 801d392:	781b      	ldrb	r3, [r3, #0]
 801d394:	4619      	mov	r1, r3
 801d396:	481c      	ldr	r0, [pc, #112]	@ (801d408 <Read_Request_Env+0x228>)
 801d398:	f000 fad6 	bl	801d948 <Stderr_Update>
 801d39c:	e006      	b.n	801d3ac <Read_Request_Env+0x1cc>
      }
      else
      {
        BLE_MANAGER_PRINTF("Error: Updating Environmental Char\r\n");
 801d39e:	481c      	ldr	r0, [pc, #112]	@ (801d410 <Read_Request_Env+0x230>)
 801d3a0:	f006 fd44 	bl	8023e2c <puts>
 801d3a4:	e002      	b.n	801d3ac <Read_Request_Env+0x1cc>
      }
    }
  }
  else
  {
    BLE_MANAGER_PRINTF("\r\n\nRead request environmental function not defined\r\n\n");
 801d3a6:	481b      	ldr	r0, [pc, #108]	@ (801d414 <Read_Request_Env+0x234>)
 801d3a8:	f006 fd40 	bl	8023e2c <puts>
  }

  ret = aci_gatt_srv_authorize_resp_nwk(Connection_Handle, handle,
 801d3ac:	f897 3044 	ldrb.w	r3, [r7, #68]	@ 0x44
 801d3b0:	b29b      	uxth	r3, r3
 801d3b2:	79fc      	ldrb	r4, [r7, #7]
 801d3b4:	8979      	ldrh	r1, [r7, #10]
 801d3b6:	8938      	ldrh	r0, [r7, #8]
 801d3b8:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 801d3ba:	9202      	str	r2, [sp, #8]
 801d3bc:	9301      	str	r3, [sp, #4]
 801d3be:	f8b7 3040 	ldrh.w	r3, [r7, #64]	@ 0x40
 801d3c2:	9300      	str	r3, [sp, #0]
 801d3c4:	2300      	movs	r3, #0
 801d3c6:	4622      	mov	r2, r4
 801d3c8:	f7fc f863 	bl	8019492 <aci_gatt_srv_authorize_resp_nwk>
 801d3cc:	4603      	mov	r3, r0
 801d3ce:	f887 302e 	strb.w	r3, [r7, #46]	@ 0x2e
                                        Operation_Type, 0, Attr_Val_Offset,
                                        Data_Length, Data);
  if (ret != BLE_STATUS_SUCCESS)
 801d3d2:	f897 302e 	ldrb.w	r3, [r7, #46]	@ 0x2e
 801d3d6:	2b00      	cmp	r3, #0
 801d3d8:	d005      	beq.n	801d3e6 <Read_Request_Env+0x206>
  {
    BLE_MANAGER_PRINTF("aci_gatt_srv_authorize_resp_nwk() failed: 0x%02x\r\n", ret);
 801d3da:	f897 302e 	ldrb.w	r3, [r7, #46]	@ 0x2e
 801d3de:	4619      	mov	r1, r3
 801d3e0:	480d      	ldr	r0, [pc, #52]	@ (801d418 <Read_Request_Env+0x238>)
 801d3e2:	f006 fcbb 	bl	8023d5c <iprintf>
  }
}
 801d3e6:	bf00      	nop
 801d3e8:	3734      	adds	r7, #52	@ 0x34
 801d3ea:	46bd      	mov	sp, r7
 801d3ec:	bd90      	pop	{r4, r7, pc}
 801d3ee:	bf00      	nop
 801d3f0:	20001958 	.word	0x20001958
 801d3f4:	cccccccd 	.word	0xcccccccd
 801d3f8:	20001960 	.word	0x20001960
 801d3fc:	20001990 	.word	0x20001990
 801d400:	20001a06 	.word	0x20001a06
 801d404:	08028ee0 	.word	0x08028ee0
 801d408:	20001a08 	.word	0x20001a08
 801d40c:	20001b08 	.word	0x20001b08
 801d410:	08028f04 	.word	0x08028f04
 801d414:	08028f28 	.word	0x08028f28
 801d418:	08028f60 	.word	0x08028f60

0801d41c <BLE_InitInertialService>:
  * @param  uint8_t GyroEnable:  1 for enabling the BLE gyroscope feature, 0 otherwise.
  * @param  uint8_t MagEnabled:  1 for esabling the BLE magnetometer feature, 0 otherwise.
  * @retval BleCharTypeDef* BleCharPointer: Data structure pointer for environmental info service
  */
BleCharTypeDef *BLE_InitInertialService(uint8_t AccEnable, uint8_t GyroEnable, uint8_t MagEnabled)
{
 801d41c:	b580      	push	{r7, lr}
 801d41e:	b084      	sub	sp, #16
 801d420:	af00      	add	r7, sp, #0
 801d422:	4603      	mov	r3, r0
 801d424:	71fb      	strb	r3, [r7, #7]
 801d426:	460b      	mov	r3, r1
 801d428:	71bb      	strb	r3, [r7, #6]
 801d42a:	4613      	mov	r3, r2
 801d42c:	717b      	strb	r3, [r7, #5]
  /* Data structure pointer for BLE service */
  BleCharTypeDef *BleCharPointer = NULL;
 801d42e:	2300      	movs	r3, #0
 801d430:	60fb      	str	r3, [r7, #12]
  InertialCharSize = 2;
 801d432:	4b51      	ldr	r3, [pc, #324]	@ (801d578 <BLE_InitInertialService+0x15c>)
 801d434:	2202      	movs	r2, #2
 801d436:	701a      	strb	r2, [r3, #0]

  /* Init data structure for identify environmental info services enabled */
  InertialFeaturesEnabled.AccIsEnable = AccEnable;
 801d438:	4a50      	ldr	r2, [pc, #320]	@ (801d57c <BLE_InitInertialService+0x160>)
 801d43a:	79fb      	ldrb	r3, [r7, #7]
 801d43c:	7013      	strb	r3, [r2, #0]
  InertialFeaturesEnabled.GyroIsEnable = GyroEnable;
 801d43e:	4a4f      	ldr	r2, [pc, #316]	@ (801d57c <BLE_InitInertialService+0x160>)
 801d440:	79bb      	ldrb	r3, [r7, #6]
 801d442:	7053      	strb	r3, [r2, #1]
  InertialFeaturesEnabled.MagIsEnabled = MagEnabled;
 801d444:	4a4d      	ldr	r2, [pc, #308]	@ (801d57c <BLE_InitInertialService+0x160>)
 801d446:	797b      	ldrb	r3, [r7, #5]
 801d448:	7093      	strb	r3, [r2, #2]

  if ((AccEnable == 1U) ||
 801d44a:	79fb      	ldrb	r3, [r7, #7]
 801d44c:	2b01      	cmp	r3, #1
 801d44e:	d006      	beq.n	801d45e <BLE_InitInertialService+0x42>
 801d450:	79bb      	ldrb	r3, [r7, #6]
 801d452:	2b01      	cmp	r3, #1
 801d454:	d003      	beq.n	801d45e <BLE_InitInertialService+0x42>
      (GyroEnable == 1U)   ||
 801d456:	797b      	ldrb	r3, [r7, #5]
 801d458:	2b01      	cmp	r3, #1
 801d45a:	f040 8085 	bne.w	801d568 <BLE_InitInertialService+0x14c>
      (MagEnabled == 1U))
  {
    /* Init data structure pointer for inertial info service */
    BleCharPointer = &BleCharInertial;
 801d45e:	4b48      	ldr	r3, [pc, #288]	@ (801d580 <BLE_InitInertialService+0x164>)
 801d460:	60fb      	str	r3, [r7, #12]
    memset(BleCharPointer, 0, sizeof(BleCharTypeDef));
 801d462:	222c      	movs	r2, #44	@ 0x2c
 801d464:	2100      	movs	r1, #0
 801d466:	68f8      	ldr	r0, [r7, #12]
 801d468:	f006 fdfc 	bl	8024064 <memset>
    BleCharPointer->AttrMod_Request_CB = AttrMod_Request_Inertial;
 801d46c:	68fb      	ldr	r3, [r7, #12]
 801d46e:	4a45      	ldr	r2, [pc, #276]	@ (801d584 <BLE_InitInertialService+0x168>)
 801d470:	621a      	str	r2, [r3, #32]
    COPY_INERTIAL_CHAR_UUID((BleCharPointer->uuid));
 801d472:	68fb      	ldr	r3, [r7, #12]
 801d474:	221b      	movs	r2, #27
 801d476:	701a      	strb	r2, [r3, #0]
 801d478:	68fb      	ldr	r3, [r7, #12]
 801d47a:	22c5      	movs	r2, #197	@ 0xc5
 801d47c:	705a      	strb	r2, [r3, #1]
 801d47e:	68fb      	ldr	r3, [r7, #12]
 801d480:	22d5      	movs	r2, #213	@ 0xd5
 801d482:	709a      	strb	r2, [r3, #2]
 801d484:	68fb      	ldr	r3, [r7, #12]
 801d486:	22a5      	movs	r2, #165	@ 0xa5
 801d488:	70da      	strb	r2, [r3, #3]
 801d48a:	68fb      	ldr	r3, [r7, #12]
 801d48c:	2202      	movs	r2, #2
 801d48e:	711a      	strb	r2, [r3, #4]
 801d490:	68fb      	ldr	r3, [r7, #12]
 801d492:	2200      	movs	r2, #0
 801d494:	715a      	strb	r2, [r3, #5]
 801d496:	68fb      	ldr	r3, [r7, #12]
 801d498:	2236      	movs	r2, #54	@ 0x36
 801d49a:	719a      	strb	r2, [r3, #6]
 801d49c:	68fb      	ldr	r3, [r7, #12]
 801d49e:	22ac      	movs	r2, #172	@ 0xac
 801d4a0:	71da      	strb	r2, [r3, #7]
 801d4a2:	68fb      	ldr	r3, [r7, #12]
 801d4a4:	22e1      	movs	r2, #225	@ 0xe1
 801d4a6:	721a      	strb	r2, [r3, #8]
 801d4a8:	68fb      	ldr	r3, [r7, #12]
 801d4aa:	2211      	movs	r2, #17
 801d4ac:	725a      	strb	r2, [r3, #9]
 801d4ae:	68fb      	ldr	r3, [r7, #12]
 801d4b0:	2201      	movs	r2, #1
 801d4b2:	729a      	strb	r2, [r3, #10]
 801d4b4:	68fb      	ldr	r3, [r7, #12]
 801d4b6:	2200      	movs	r2, #0
 801d4b8:	72da      	strb	r2, [r3, #11]
 801d4ba:	68fb      	ldr	r3, [r7, #12]
 801d4bc:	2200      	movs	r2, #0
 801d4be:	731a      	strb	r2, [r3, #12]
 801d4c0:	68fb      	ldr	r3, [r7, #12]
 801d4c2:	2200      	movs	r2, #0
 801d4c4:	735a      	strb	r2, [r3, #13]
 801d4c6:	68fb      	ldr	r3, [r7, #12]
 801d4c8:	2200      	movs	r2, #0
 801d4ca:	739a      	strb	r2, [r3, #14]
 801d4cc:	68fb      	ldr	r3, [r7, #12]
 801d4ce:	2200      	movs	r2, #0
 801d4d0:	73da      	strb	r2, [r3, #15]

    /* Enables BLE accelerometer feature */
    if (AccEnable == 1U)
 801d4d2:	79fb      	ldrb	r3, [r7, #7]
 801d4d4:	2b01      	cmp	r3, #1
 801d4d6:	d10c      	bne.n	801d4f2 <BLE_InitInertialService+0xd6>
    {
      BleCharPointer->uuid[14] |= 0x80U;
 801d4d8:	68fb      	ldr	r3, [r7, #12]
 801d4da:	7b9b      	ldrb	r3, [r3, #14]
 801d4dc:	f063 037f 	orn	r3, r3, #127	@ 0x7f
 801d4e0:	b2da      	uxtb	r2, r3
 801d4e2:	68fb      	ldr	r3, [r7, #12]
 801d4e4:	739a      	strb	r2, [r3, #14]
      InertialCharSize += 3U * 2U;
 801d4e6:	4b24      	ldr	r3, [pc, #144]	@ (801d578 <BLE_InitInertialService+0x15c>)
 801d4e8:	781b      	ldrb	r3, [r3, #0]
 801d4ea:	3306      	adds	r3, #6
 801d4ec:	b2da      	uxtb	r2, r3
 801d4ee:	4b22      	ldr	r3, [pc, #136]	@ (801d578 <BLE_InitInertialService+0x15c>)
 801d4f0:	701a      	strb	r2, [r3, #0]
      BLE_MANAGER_PRINTF("\t--> Accelerometer feature enabled\r\n");
#endif /* (BLE_DEBUG_LEVEL>1) */
    }

    /* Enables BLE gyroscope feature */
    if (GyroEnable == 1U)
 801d4f2:	79bb      	ldrb	r3, [r7, #6]
 801d4f4:	2b01      	cmp	r3, #1
 801d4f6:	d10c      	bne.n	801d512 <BLE_InitInertialService+0xf6>
    {
      BleCharPointer->uuid[14] |= 0x40U;
 801d4f8:	68fb      	ldr	r3, [r7, #12]
 801d4fa:	7b9b      	ldrb	r3, [r3, #14]
 801d4fc:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 801d500:	b2da      	uxtb	r2, r3
 801d502:	68fb      	ldr	r3, [r7, #12]
 801d504:	739a      	strb	r2, [r3, #14]
      InertialCharSize += 3U * 2U;
 801d506:	4b1c      	ldr	r3, [pc, #112]	@ (801d578 <BLE_InitInertialService+0x15c>)
 801d508:	781b      	ldrb	r3, [r3, #0]
 801d50a:	3306      	adds	r3, #6
 801d50c:	b2da      	uxtb	r2, r3
 801d50e:	4b1a      	ldr	r3, [pc, #104]	@ (801d578 <BLE_InitInertialService+0x15c>)
 801d510:	701a      	strb	r2, [r3, #0]
      BLE_MANAGER_PRINTF("\t--> Gyroscope feature enabled\r\n");
#endif /* (BLE_DEBUG_LEVEL>1) */
    }

    /* Enables BLE magnetometer feature */
    if (MagEnabled == 1U)
 801d512:	797b      	ldrb	r3, [r7, #5]
 801d514:	2b01      	cmp	r3, #1
 801d516:	d10c      	bne.n	801d532 <BLE_InitInertialService+0x116>
    {
      BleCharPointer->uuid[14] |= 0x20U;
 801d518:	68fb      	ldr	r3, [r7, #12]
 801d51a:	7b9b      	ldrb	r3, [r3, #14]
 801d51c:	f043 0320 	orr.w	r3, r3, #32
 801d520:	b2da      	uxtb	r2, r3
 801d522:	68fb      	ldr	r3, [r7, #12]
 801d524:	739a      	strb	r2, [r3, #14]
      InertialCharSize += 3U * 2U;
 801d526:	4b14      	ldr	r3, [pc, #80]	@ (801d578 <BLE_InitInertialService+0x15c>)
 801d528:	781b      	ldrb	r3, [r3, #0]
 801d52a:	3306      	adds	r3, #6
 801d52c:	b2da      	uxtb	r2, r3
 801d52e:	4b12      	ldr	r3, [pc, #72]	@ (801d578 <BLE_InitInertialService+0x15c>)
 801d530:	701a      	strb	r2, [r3, #0]
#if (BLE_DEBUG_LEVEL>1)
      BLE_MANAGER_PRINTF("\t--> Magnetometer feature enabled\r\n");
#endif /* (BLE_DEBUG_LEVEL>1) */
    }

    BleCharPointer->Char_UUID_Type = UUID_TYPE_128;
 801d532:	68fb      	ldr	r3, [r7, #12]
 801d534:	2202      	movs	r2, #2
 801d536:	741a      	strb	r2, [r3, #16]
    BleCharPointer->Char_Value_Length = InertialCharSize;
 801d538:	4b0f      	ldr	r3, [pc, #60]	@ (801d578 <BLE_InitInertialService+0x15c>)
 801d53a:	781b      	ldrb	r3, [r3, #0]
 801d53c:	461a      	mov	r2, r3
 801d53e:	68fb      	ldr	r3, [r7, #12]
 801d540:	825a      	strh	r2, [r3, #18]
    BleCharPointer->Char_Properties = CHAR_PROP_NOTIFY;
 801d542:	68fb      	ldr	r3, [r7, #12]
 801d544:	2210      	movs	r2, #16
 801d546:	751a      	strb	r2, [r3, #20]
    BleCharPointer->Security_Permissions = ATTR_PERMISSION_NONE;
 801d548:	68fb      	ldr	r3, [r7, #12]
 801d54a:	2200      	movs	r2, #0
 801d54c:	755a      	strb	r2, [r3, #21]
    BleCharPointer->GATT_Evt_Mask = GATT_NOTIFY_READ_REQ_AND_WAIT_FOR_APPL_RESP;
 801d54e:	68fb      	ldr	r3, [r7, #12]
 801d550:	2204      	movs	r2, #4
 801d552:	759a      	strb	r2, [r3, #22]
    BleCharPointer->Enc_Key_Size = 16;
 801d554:	68fb      	ldr	r3, [r7, #12]
 801d556:	2210      	movs	r2, #16
 801d558:	75da      	strb	r2, [r3, #23]
    BleCharPointer->Is_Variable = 0;
 801d55a:	68fb      	ldr	r3, [r7, #12]
 801d55c:	2200      	movs	r2, #0
 801d55e:	761a      	strb	r2, [r3, #24]

    BLE_MANAGER_PRINTF("BLE Inertial features ok\r\n");
 801d560:	4809      	ldr	r0, [pc, #36]	@ (801d588 <BLE_InitInertialService+0x16c>)
 801d562:	f006 fc63 	bl	8023e2c <puts>
 801d566:	e002      	b.n	801d56e <BLE_InitInertialService+0x152>
  }
  else
  {
    BLE_MANAGER_PRINTF(" ERROR: None inertial features is enabled\r\n");
 801d568:	4808      	ldr	r0, [pc, #32]	@ (801d58c <BLE_InitInertialService+0x170>)
 801d56a:	f006 fc5f 	bl	8023e2c <puts>
  }

  return BleCharPointer;
 801d56e:	68fb      	ldr	r3, [r7, #12]
}
 801d570:	4618      	mov	r0, r3
 801d572:	3710      	adds	r7, #16
 801d574:	46bd      	mov	sp, r7
 801d576:	bd80      	pop	{r7, pc}
 801d578:	200019c8 	.word	0x200019c8
 801d57c:	20001998 	.word	0x20001998
 801d580:	2000199c 	.word	0x2000199c
 801d584:	0801d591 	.word	0x0801d591
 801d588:	08028f94 	.word	0x08028f94
 801d58c:	08028fb0 	.word	0x08028fb0

0801d590 <AttrMod_Request_Inertial>:
  * @param  uint8_t *att_data attribute data
  * @retval None
  */
static void AttrMod_Request_Inertial(void *VoidCharPointer, uint16_t attr_handle, uint16_t Offset, uint8_t data_length,
                                     uint8_t *att_data)
{
 801d590:	b580      	push	{r7, lr}
 801d592:	b084      	sub	sp, #16
 801d594:	af00      	add	r7, sp, #0
 801d596:	60f8      	str	r0, [r7, #12]
 801d598:	4608      	mov	r0, r1
 801d59a:	4611      	mov	r1, r2
 801d59c:	461a      	mov	r2, r3
 801d59e:	4603      	mov	r3, r0
 801d5a0:	817b      	strh	r3, [r7, #10]
 801d5a2:	460b      	mov	r3, r1
 801d5a4:	813b      	strh	r3, [r7, #8]
 801d5a6:	4613      	mov	r3, r2
 801d5a8:	71fb      	strb	r3, [r7, #7]
  if (CustomNotifyEventInertial != NULL)
 801d5aa:	4b0c      	ldr	r3, [pc, #48]	@ (801d5dc <AttrMod_Request_Inertial+0x4c>)
 801d5ac:	681b      	ldr	r3, [r3, #0]
 801d5ae:	2b00      	cmp	r3, #0
 801d5b0:	d010      	beq.n	801d5d4 <AttrMod_Request_Inertial+0x44>
  {
    if (att_data[0] == 01U)
 801d5b2:	69bb      	ldr	r3, [r7, #24]
 801d5b4:	781b      	ldrb	r3, [r3, #0]
 801d5b6:	2b01      	cmp	r3, #1
 801d5b8:	d104      	bne.n	801d5c4 <AttrMod_Request_Inertial+0x34>
    {
      CustomNotifyEventInertial(BLE_NOTIFY_SUB);
 801d5ba:	4b08      	ldr	r3, [pc, #32]	@ (801d5dc <AttrMod_Request_Inertial+0x4c>)
 801d5bc:	681b      	ldr	r3, [r3, #0]
 801d5be:	2001      	movs	r0, #1
 801d5c0:	4798      	blx	r3
  else
  {
    BLE_MANAGER_PRINTF("--->Acc/Gyro/Mag=%s", (att_data[0] == 01U) ? " ON\r\n" : " OFF\r\n");
  }
#endif /* (BLE_DEBUG_LEVEL>1) */
}
 801d5c2:	e007      	b.n	801d5d4 <AttrMod_Request_Inertial+0x44>
    else if (att_data[0] == 0U)
 801d5c4:	69bb      	ldr	r3, [r7, #24]
 801d5c6:	781b      	ldrb	r3, [r3, #0]
 801d5c8:	2b00      	cmp	r3, #0
 801d5ca:	d103      	bne.n	801d5d4 <AttrMod_Request_Inertial+0x44>
      CustomNotifyEventInertial(BLE_NOTIFY_UNSUB);
 801d5cc:	4b03      	ldr	r3, [pc, #12]	@ (801d5dc <AttrMod_Request_Inertial+0x4c>)
 801d5ce:	681b      	ldr	r3, [r3, #0]
 801d5d0:	2002      	movs	r0, #2
 801d5d2:	4798      	blx	r3
}
 801d5d4:	bf00      	nop
 801d5d6:	3710      	adds	r7, #16
 801d5d8:	46bd      	mov	sp, r7
 801d5da:	bd80      	pop	{r7, pc}
 801d5dc:	20001994 	.word	0x20001994

0801d5e0 <BLE_InitPnPLikeService>:
  * @brief  Init PnPLike info service
  * @param  None
  * @retval BleCharTypeDef* BleCharPointer: Data structure pointer for PnPLike info service
  */
BleCharTypeDef *BLE_InitPnPLikeService(void)
{
 801d5e0:	b580      	push	{r7, lr}
 801d5e2:	b082      	sub	sp, #8
 801d5e4:	af00      	add	r7, sp, #0
  /* Data structure pointer for BLE service */
  BleCharTypeDef *BleCharPointer;

  /* Init data structure pointer for PnPLike info service */
  BleCharPointer = &BleCharPnPLike;
 801d5e6:	4b31      	ldr	r3, [pc, #196]	@ (801d6ac <BLE_InitPnPLikeService+0xcc>)
 801d5e8:	607b      	str	r3, [r7, #4]
  memset(BleCharPointer, 0, sizeof(BleCharTypeDef));
 801d5ea:	222c      	movs	r2, #44	@ 0x2c
 801d5ec:	2100      	movs	r1, #0
 801d5ee:	6878      	ldr	r0, [r7, #4]
 801d5f0:	f006 fd38 	bl	8024064 <memset>
  BleCharPointer->AttrMod_Request_CB = AttrMod_Request_PnPLike;
 801d5f4:	687b      	ldr	r3, [r7, #4]
 801d5f6:	4a2e      	ldr	r2, [pc, #184]	@ (801d6b0 <BLE_InitPnPLikeService+0xd0>)
 801d5f8:	621a      	str	r2, [r3, #32]
  BleCharPointer->Write_Request_CB = Write_Request_PnPLike;
 801d5fa:	687b      	ldr	r3, [r7, #4]
 801d5fc:	4a2d      	ldr	r2, [pc, #180]	@ (801d6b4 <BLE_InitPnPLikeService+0xd4>)
 801d5fe:	629a      	str	r2, [r3, #40]	@ 0x28
  COPY_PNPLIKE_CHAR_UUID((BleCharPointer->uuid));
 801d600:	687b      	ldr	r3, [r7, #4]
 801d602:	221b      	movs	r2, #27
 801d604:	701a      	strb	r2, [r3, #0]
 801d606:	687b      	ldr	r3, [r7, #4]
 801d608:	22c5      	movs	r2, #197	@ 0xc5
 801d60a:	705a      	strb	r2, [r3, #1]
 801d60c:	687b      	ldr	r3, [r7, #4]
 801d60e:	22d5      	movs	r2, #213	@ 0xd5
 801d610:	709a      	strb	r2, [r3, #2]
 801d612:	687b      	ldr	r3, [r7, #4]
 801d614:	22a5      	movs	r2, #165	@ 0xa5
 801d616:	70da      	strb	r2, [r3, #3]
 801d618:	687b      	ldr	r3, [r7, #4]
 801d61a:	2202      	movs	r2, #2
 801d61c:	711a      	strb	r2, [r3, #4]
 801d61e:	687b      	ldr	r3, [r7, #4]
 801d620:	2200      	movs	r2, #0
 801d622:	715a      	strb	r2, [r3, #5]
 801d624:	687b      	ldr	r3, [r7, #4]
 801d626:	2236      	movs	r2, #54	@ 0x36
 801d628:	719a      	strb	r2, [r3, #6]
 801d62a:	687b      	ldr	r3, [r7, #4]
 801d62c:	22ac      	movs	r2, #172	@ 0xac
 801d62e:	71da      	strb	r2, [r3, #7]
 801d630:	687b      	ldr	r3, [r7, #4]
 801d632:	22e1      	movs	r2, #225	@ 0xe1
 801d634:	721a      	strb	r2, [r3, #8]
 801d636:	687b      	ldr	r3, [r7, #4]
 801d638:	2211      	movs	r2, #17
 801d63a:	725a      	strb	r2, [r3, #9]
 801d63c:	687b      	ldr	r3, [r7, #4]
 801d63e:	2202      	movs	r2, #2
 801d640:	729a      	strb	r2, [r3, #10]
 801d642:	687b      	ldr	r3, [r7, #4]
 801d644:	2200      	movs	r2, #0
 801d646:	72da      	strb	r2, [r3, #11]
 801d648:	687b      	ldr	r3, [r7, #4]
 801d64a:	221b      	movs	r2, #27
 801d64c:	731a      	strb	r2, [r3, #12]
 801d64e:	687b      	ldr	r3, [r7, #4]
 801d650:	2200      	movs	r2, #0
 801d652:	735a      	strb	r2, [r3, #13]
 801d654:	687b      	ldr	r3, [r7, #4]
 801d656:	2200      	movs	r2, #0
 801d658:	739a      	strb	r2, [r3, #14]
 801d65a:	687b      	ldr	r3, [r7, #4]
 801d65c:	2200      	movs	r2, #0
 801d65e:	73da      	strb	r2, [r3, #15]
  BleCharPointer->Char_UUID_Type = UUID_TYPE_128;
 801d660:	687b      	ldr	r3, [r7, #4]
 801d662:	2202      	movs	r2, #2
 801d664:	741a      	strb	r2, [r3, #16]
  BleCharPointer->Char_Value_Length = PnPLikeContentMaxCharLength;
 801d666:	4b14      	ldr	r3, [pc, #80]	@ (801d6b8 <BLE_InitPnPLikeService+0xd8>)
 801d668:	881a      	ldrh	r2, [r3, #0]
 801d66a:	687b      	ldr	r3, [r7, #4]
 801d66c:	825a      	strh	r2, [r3, #18]
  BleCharPointer->Char_Properties = ((uint8_t)CHAR_PROP_NOTIFY) | ((uint8_t)CHAR_PROP_WRITE_WITHOUT_RESP);
 801d66e:	687b      	ldr	r3, [r7, #4]
 801d670:	2214      	movs	r2, #20
 801d672:	751a      	strb	r2, [r3, #20]
  BleCharPointer->Security_Permissions = ATTR_PERMISSION_NONE;
 801d674:	687b      	ldr	r3, [r7, #4]
 801d676:	2200      	movs	r2, #0
 801d678:	755a      	strb	r2, [r3, #21]
  BleCharPointer->GATT_Evt_Mask = GATT_NOTIFY_ATTRIBUTE_WRITE;
 801d67a:	687b      	ldr	r3, [r7, #4]
 801d67c:	2201      	movs	r2, #1
 801d67e:	759a      	strb	r2, [r3, #22]
  BleCharPointer->Enc_Key_Size = 16;
 801d680:	687b      	ldr	r3, [r7, #4]
 801d682:	2210      	movs	r2, #16
 801d684:	75da      	strb	r2, [r3, #23]
  BleCharPointer->Is_Variable = 1;
 801d686:	687b      	ldr	r3, [r7, #4]
 801d688:	2201      	movs	r2, #1
 801d68a:	761a      	strb	r2, [r3, #24]

  if (CustomWriteRequestPnPLike == NULL)
 801d68c:	4b0b      	ldr	r3, [pc, #44]	@ (801d6bc <BLE_InitPnPLikeService+0xdc>)
 801d68e:	681b      	ldr	r3, [r3, #0]
 801d690:	2b00      	cmp	r3, #0
 801d692:	d102      	bne.n	801d69a <BLE_InitPnPLikeService+0xba>
  {
    BLE_MANAGER_PRINTF("Error: Write request PnPLike function not defined\r\n");
 801d694:	480a      	ldr	r0, [pc, #40]	@ (801d6c0 <BLE_InitPnPLikeService+0xe0>)
 801d696:	f006 fbc9 	bl	8023e2c <puts>
  }

  BLE_MANAGER_PRINTF("BLE PnPLike features ok\r\n");
 801d69a:	480a      	ldr	r0, [pc, #40]	@ (801d6c4 <BLE_InitPnPLikeService+0xe4>)
 801d69c:	f006 fbc6 	bl	8023e2c <puts>

  return BleCharPointer;
 801d6a0:	687b      	ldr	r3, [r7, #4]
}
 801d6a2:	4618      	mov	r0, r3
 801d6a4:	3708      	adds	r7, #8
 801d6a6:	46bd      	mov	sp, r7
 801d6a8:	bd80      	pop	{r7, pc}
 801d6aa:	bf00      	nop
 801d6ac:	200019d4 	.word	0x200019d4
 801d6b0:	0801d6c9 	.word	0x0801d6c9
 801d6b4:	0801d719 	.word	0x0801d719
 801d6b8:	2000020c 	.word	0x2000020c
 801d6bc:	200019d0 	.word	0x200019d0
 801d6c0:	0802902c 	.word	0x0802902c
 801d6c4:	08029060 	.word	0x08029060

0801d6c8 <AttrMod_Request_PnPLike>:
  * @param  uint8_t *att_data attribute data
  * @retval None
  */
static void AttrMod_Request_PnPLike(void *VoidCharPointer, uint16_t attr_handle, uint16_t Offset, uint8_t data_length,
                                    uint8_t *att_data)
{
 801d6c8:	b580      	push	{r7, lr}
 801d6ca:	b084      	sub	sp, #16
 801d6cc:	af00      	add	r7, sp, #0
 801d6ce:	60f8      	str	r0, [r7, #12]
 801d6d0:	4608      	mov	r0, r1
 801d6d2:	4611      	mov	r1, r2
 801d6d4:	461a      	mov	r2, r3
 801d6d6:	4603      	mov	r3, r0
 801d6d8:	817b      	strh	r3, [r7, #10]
 801d6da:	460b      	mov	r3, r1
 801d6dc:	813b      	strh	r3, [r7, #8]
 801d6de:	4613      	mov	r3, r2
 801d6e0:	71fb      	strb	r3, [r7, #7]
  if (CustomNotifyEventPnPLike != NULL)
 801d6e2:	4b0c      	ldr	r3, [pc, #48]	@ (801d714 <AttrMod_Request_PnPLike+0x4c>)
 801d6e4:	681b      	ldr	r3, [r3, #0]
 801d6e6:	2b00      	cmp	r3, #0
 801d6e8:	d010      	beq.n	801d70c <AttrMod_Request_PnPLike+0x44>
  {
    if (att_data[0] == 01U)
 801d6ea:	69bb      	ldr	r3, [r7, #24]
 801d6ec:	781b      	ldrb	r3, [r3, #0]
 801d6ee:	2b01      	cmp	r3, #1
 801d6f0:	d104      	bne.n	801d6fc <AttrMod_Request_PnPLike+0x34>
    {
      CustomNotifyEventPnPLike(BLE_NOTIFY_SUB);
 801d6f2:	4b08      	ldr	r3, [pc, #32]	@ (801d714 <AttrMod_Request_PnPLike+0x4c>)
 801d6f4:	681b      	ldr	r3, [r3, #0]
 801d6f6:	2001      	movs	r0, #1
 801d6f8:	4798      	blx	r3
  else
  {
    BLE_MANAGER_PRINTF("--->PnPLike=%s", (att_data[0] == BLE_NOTIFY_SUB) ? " ON\r\n" : " OFF\r\n");
  }
#endif /* (BLE_DEBUG_LEVEL>1) */
}
 801d6fa:	e007      	b.n	801d70c <AttrMod_Request_PnPLike+0x44>
    else if (att_data[0] == 0U)
 801d6fc:	69bb      	ldr	r3, [r7, #24]
 801d6fe:	781b      	ldrb	r3, [r3, #0]
 801d700:	2b00      	cmp	r3, #0
 801d702:	d103      	bne.n	801d70c <AttrMod_Request_PnPLike+0x44>
      CustomNotifyEventPnPLike(BLE_NOTIFY_UNSUB);
 801d704:	4b03      	ldr	r3, [pc, #12]	@ (801d714 <AttrMod_Request_PnPLike+0x4c>)
 801d706:	681b      	ldr	r3, [r3, #0]
 801d708:	2002      	movs	r0, #2
 801d70a:	4798      	blx	r3
}
 801d70c:	bf00      	nop
 801d70e:	3710      	adds	r7, #16
 801d710:	46bd      	mov	sp, r7
 801d712:	bd80      	pop	{r7, pc}
 801d714:	200019cc 	.word	0x200019cc

0801d718 <Write_Request_PnPLike>:
  * @param  uint16_t handle Handle of the attribute
  * @retval None
  */
static void Write_Request_PnPLike(void *BleCharPointer, uint16_t handle, uint16_t Offset, uint8_t data_length,
                                  uint8_t *att_data)
{
 801d718:	b580      	push	{r7, lr}
 801d71a:	b086      	sub	sp, #24
 801d71c:	af00      	add	r7, sp, #0
 801d71e:	60f8      	str	r0, [r7, #12]
 801d720:	4608      	mov	r0, r1
 801d722:	4611      	mov	r1, r2
 801d724:	461a      	mov	r2, r3
 801d726:	4603      	mov	r3, r0
 801d728:	817b      	strh	r3, [r7, #10]
 801d72a:	460b      	mov	r3, r1
 801d72c:	813b      	strh	r3, [r7, #8]
 801d72e:	4613      	mov	r3, r2
 801d730:	71fb      	strb	r3, [r7, #7]
  uint32_t CommandBufLen = 0;
 801d732:	2300      	movs	r3, #0
 801d734:	617b      	str	r3, [r7, #20]

  if (CustomWriteRequestPnPLike != NULL)
 801d736:	4b11      	ldr	r3, [pc, #68]	@ (801d77c <Write_Request_PnPLike+0x64>)
 801d738:	681b      	ldr	r3, [r3, #0]
 801d73a:	2b00      	cmp	r3, #0
 801d73c:	d019      	beq.n	801d772 <Write_Request_PnPLike+0x5a>
  {
    CommandBufLen = BLE_Command_TP_Parse(&ble_command_buffer, att_data, data_length);
 801d73e:	79fb      	ldrb	r3, [r7, #7]
 801d740:	461a      	mov	r2, r3
 801d742:	6a39      	ldr	r1, [r7, #32]
 801d744:	480e      	ldr	r0, [pc, #56]	@ (801d780 <Write_Request_PnPLike+0x68>)
 801d746:	f000 fa23 	bl	801db90 <BLE_Command_TP_Parse>
 801d74a:	6178      	str	r0, [r7, #20]

    if (CommandBufLen > 0U)
 801d74c:	697b      	ldr	r3, [r7, #20]
 801d74e:	2b00      	cmp	r3, #0
 801d750:	d00f      	beq.n	801d772 <Write_Request_PnPLike+0x5a>
    {
      CustomWriteRequestPnPLike(ble_command_buffer, CommandBufLen);
 801d752:	4b0a      	ldr	r3, [pc, #40]	@ (801d77c <Write_Request_PnPLike+0x64>)
 801d754:	681b      	ldr	r3, [r3, #0]
 801d756:	4a0a      	ldr	r2, [pc, #40]	@ (801d780 <Write_Request_PnPLike+0x68>)
 801d758:	6812      	ldr	r2, [r2, #0]
 801d75a:	6979      	ldr	r1, [r7, #20]
 801d75c:	b2c9      	uxtb	r1, r1
 801d75e:	4610      	mov	r0, r2
 801d760:	4798      	blx	r3

#if (BLE_DEBUG_LEVEL>1)
      BLE_MANAGER_PRINTF("\r\n%.*s\r\n", CommandBufLen,ble_command_buffer);
#endif /* (BLE_DEBUG_LEVEL>1) */

      BLE_FREE_FUNCTION(ble_command_buffer);
 801d762:	4b07      	ldr	r3, [pc, #28]	@ (801d780 <Write_Request_PnPLike+0x68>)
 801d764:	681b      	ldr	r3, [r3, #0]
 801d766:	4618      	mov	r0, r3
 801d768:	f004 fc36 	bl	8021fd8 <free>
      ble_command_buffer = NULL;
 801d76c:	4b04      	ldr	r3, [pc, #16]	@ (801d780 <Write_Request_PnPLike+0x68>)
 801d76e:	2200      	movs	r2, #0
 801d770:	601a      	str	r2, [r3, #0]
  {
#if (BLE_DEBUG_LEVEL>1)
    BLE_MANAGER_PRINTF("\r\nWrite request PnPLike function not defined\r\n");
#endif /* (BLE_DEBUG_LEVEL>1) */
  }
}
 801d772:	bf00      	nop
 801d774:	3718      	adds	r7, #24
 801d776:	46bd      	mov	sp, r7
 801d778:	bd80      	pop	{r7, pc}
 801d77a:	bf00      	nop
 801d77c:	200019d0 	.word	0x200019d0
 801d780:	20001a00 	.word	0x20001a00

0801d784 <BLE_PnPLikeSetMaxCharLength>:
  * @brief  PnPLike Set Max Char Length
  * @param  uint16_t MaxCharLength
  * @retval none
  */
void BLE_PnPLikeSetMaxCharLength(uint16_t MaxCharLength)
{
 801d784:	b480      	push	{r7}
 801d786:	b083      	sub	sp, #12
 801d788:	af00      	add	r7, sp, #0
 801d78a:	4603      	mov	r3, r0
 801d78c:	80fb      	strh	r3, [r7, #6]
  PnPLikeContentMaxCharLength = MaxCharLength;
 801d78e:	4a04      	ldr	r2, [pc, #16]	@ (801d7a0 <BLE_PnPLikeSetMaxCharLength+0x1c>)
 801d790:	88fb      	ldrh	r3, [r7, #6]
 801d792:	8013      	strh	r3, [r2, #0]
}
 801d794:	bf00      	nop
 801d796:	370c      	adds	r7, #12
 801d798:	46bd      	mov	sp, r7
 801d79a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801d79e:	4770      	bx	lr
 801d7a0:	2000020c 	.word	0x2000020c

0801d7a4 <BLE_PnPLikeGetMaxCharLength>:
  * @brief  PnPLike Get Max Char Length
  * @param  None
  * @retval uint16_t MaxCharLength
  */
uint16_t BLE_PnPLikeGetMaxCharLength(void)
{
 801d7a4:	b480      	push	{r7}
 801d7a6:	af00      	add	r7, sp, #0
  return PnPLikeContentMaxCharLength;
 801d7a8:	4b03      	ldr	r3, [pc, #12]	@ (801d7b8 <BLE_PnPLikeGetMaxCharLength+0x14>)
 801d7aa:	881b      	ldrh	r3, [r3, #0]
}
 801d7ac:	4618      	mov	r0, r3
 801d7ae:	46bd      	mov	sp, r7
 801d7b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 801d7b4:	4770      	bx	lr
 801d7b6:	bf00      	nop
 801d7b8:	2000020c 	.word	0x2000020c

0801d7bc <UpdateTermStdOut>:
  * @param  uint8_t *data string to write
  * @param  uint8_t length length of string to write
  * @retval tBleStatus      Status
  */
static tBleStatus UpdateTermStdOut(uint8_t *data, uint8_t length)
{
 801d7bc:	b580      	push	{r7, lr}
 801d7be:	b082      	sub	sp, #8
 801d7c0:	af00      	add	r7, sp, #0
 801d7c2:	6078      	str	r0, [r7, #4]
 801d7c4:	460b      	mov	r3, r1
 801d7c6:	70fb      	strb	r3, [r7, #3]
  if (ACI_GATT_UPDATE_CHAR_VALUE(&BleCharStdOut, 0, length, data) != (tBleStatus)BLE_STATUS_SUCCESS)
 801d7c8:	78fa      	ldrb	r2, [r7, #3]
 801d7ca:	687b      	ldr	r3, [r7, #4]
 801d7cc:	2100      	movs	r1, #0
 801d7ce:	4808      	ldr	r0, [pc, #32]	@ (801d7f0 <UpdateTermStdOut+0x34>)
 801d7d0:	f000 f86e 	bl	801d8b0 <safe_aci_gatt_update_char_value>
 801d7d4:	4603      	mov	r3, r0
 801d7d6:	2b00      	cmp	r3, #0
 801d7d8:	d004      	beq.n	801d7e4 <UpdateTermStdOut+0x28>
  {
    BLE_MANAGER_PRINTF("Error: Updating Stdout Char\r\n");
 801d7da:	4806      	ldr	r0, [pc, #24]	@ (801d7f4 <UpdateTermStdOut+0x38>)
 801d7dc:	f006 fb26 	bl	8023e2c <puts>
    return BLE_STATUS_ERROR;
 801d7e0:	2386      	movs	r3, #134	@ 0x86
 801d7e2:	e000      	b.n	801d7e6 <UpdateTermStdOut+0x2a>
  }
  return BLE_STATUS_SUCCESS;
 801d7e4:	2300      	movs	r3, #0
}
 801d7e6:	4618      	mov	r0, r3
 801d7e8:	3708      	adds	r7, #8
 801d7ea:	46bd      	mov	sp, r7
 801d7ec:	bd80      	pop	{r7, pc}
 801d7ee:	bf00      	nop
 801d7f0:	20001db0 	.word	0x20001db0
 801d7f4:	0802913c 	.word	0x0802913c

0801d7f8 <UpdateTermStdErr>:
  * @param  uint8_t *data string to write
  * @param  uint8_t length length of string to write
  * @retval tBleStatus      Status
  */
static tBleStatus UpdateTermStdErr(uint8_t *data, uint8_t length)
{
 801d7f8:	b580      	push	{r7, lr}
 801d7fa:	b082      	sub	sp, #8
 801d7fc:	af00      	add	r7, sp, #0
 801d7fe:	6078      	str	r0, [r7, #4]
 801d800:	460b      	mov	r3, r1
 801d802:	70fb      	strb	r3, [r7, #3]
  if (ACI_GATT_UPDATE_CHAR_VALUE(&BleCharStdErr, 0, length, data) != (tBleStatus)BLE_STATUS_SUCCESS)
 801d804:	78fa      	ldrb	r2, [r7, #3]
 801d806:	687b      	ldr	r3, [r7, #4]
 801d808:	2100      	movs	r1, #0
 801d80a:	4808      	ldr	r0, [pc, #32]	@ (801d82c <UpdateTermStdErr+0x34>)
 801d80c:	f000 f850 	bl	801d8b0 <safe_aci_gatt_update_char_value>
 801d810:	4603      	mov	r3, r0
 801d812:	2b00      	cmp	r3, #0
 801d814:	d004      	beq.n	801d820 <UpdateTermStdErr+0x28>
  {
    BLE_MANAGER_PRINTF("Error: Updating Stdout Char\r\n");
 801d816:	4806      	ldr	r0, [pc, #24]	@ (801d830 <UpdateTermStdErr+0x38>)
 801d818:	f006 fb08 	bl	8023e2c <puts>
    return BLE_STATUS_ERROR;
 801d81c:	2386      	movs	r3, #134	@ 0x86
 801d81e:	e000      	b.n	801d822 <UpdateTermStdErr+0x2a>
  }
  return BLE_STATUS_SUCCESS;
 801d820:	2300      	movs	r3, #0
}
 801d822:	4618      	mov	r0, r3
 801d824:	3708      	adds	r7, #8
 801d826:	46bd      	mov	sp, r7
 801d828:	bd80      	pop	{r7, pc}
 801d82a:	bf00      	nop
 801d82c:	20001ddc 	.word	0x20001ddc
 801d830:	0802913c 	.word	0x0802913c

0801d834 <GenericClearCustomCommandsList>:
  * @param  BLE_ExtCustomCommand_t **LocLastCustomCommand Pointer to last Custom Command
  * @retval None
  */
void GenericClearCustomCommandsList(BLE_ExtCustomCommand_t **LocCustomCommands,
                                    BLE_ExtCustomCommand_t **LocLastCustomCommand)
{
 801d834:	b580      	push	{r7, lr}
 801d836:	b082      	sub	sp, #8
 801d838:	af00      	add	r7, sp, #0
 801d83a:	6078      	str	r0, [r7, #4]
 801d83c:	6039      	str	r1, [r7, #0]
  if ((*LocCustomCommands) != NULL)
 801d83e:	687b      	ldr	r3, [r7, #4]
 801d840:	681b      	ldr	r3, [r3, #0]
 801d842:	2b00      	cmp	r3, #0
 801d844:	d016      	beq.n	801d874 <GenericClearCustomCommandsList+0x40>
  {
    if ((*LocCustomCommands)->NextCommand != NULL)
 801d846:	687b      	ldr	r3, [r7, #4]
 801d848:	681b      	ldr	r3, [r3, #0]
 801d84a:	689b      	ldr	r3, [r3, #8]
 801d84c:	2b00      	cmp	r3, #0
 801d84e:	d005      	beq.n	801d85c <GenericClearCustomCommandsList+0x28>
    {
      ClearSingleCommand((BLE_ExtCustomCommand_t *)(*LocCustomCommands)->NextCommand);
 801d850:	687b      	ldr	r3, [r7, #4]
 801d852:	681b      	ldr	r3, [r3, #0]
 801d854:	689b      	ldr	r3, [r3, #8]
 801d856:	4618      	mov	r0, r3
 801d858:	f000 f810 	bl	801d87c <ClearSingleCommand>
    }
    BLE_FREE_FUNCTION((*LocCustomCommands));
 801d85c:	687b      	ldr	r3, [r7, #4]
 801d85e:	681b      	ldr	r3, [r3, #0]
 801d860:	4618      	mov	r0, r3
 801d862:	f004 fbb9 	bl	8021fd8 <free>
    *LocLastCustomCommand = *LocCustomCommands = NULL;
 801d866:	687b      	ldr	r3, [r7, #4]
 801d868:	2200      	movs	r2, #0
 801d86a:	601a      	str	r2, [r3, #0]
 801d86c:	687b      	ldr	r3, [r7, #4]
 801d86e:	681a      	ldr	r2, [r3, #0]
 801d870:	683b      	ldr	r3, [r7, #0]
 801d872:	601a      	str	r2, [r3, #0]
  }
}
 801d874:	bf00      	nop
 801d876:	3708      	adds	r7, #8
 801d878:	46bd      	mov	sp, r7
 801d87a:	bd80      	pop	{r7, pc}

0801d87c <ClearSingleCommand>:
  * @brief  Clear One Single Custom Command
  * @param  BLE_ExtCustomCommand_t *NextCommand Pointer to the next Custom Commands
  * @retval None
  */
static void ClearSingleCommand(BLE_ExtCustomCommand_t *Command)
{
 801d87c:	b580      	push	{r7, lr}
 801d87e:	b082      	sub	sp, #8
 801d880:	af00      	add	r7, sp, #0
 801d882:	6078      	str	r0, [r7, #4]
  if (Command->NextCommand != NULL)
 801d884:	687b      	ldr	r3, [r7, #4]
 801d886:	689b      	ldr	r3, [r3, #8]
 801d888:	2b00      	cmp	r3, #0
 801d88a:	d004      	beq.n	801d896 <ClearSingleCommand+0x1a>
  {
    ClearSingleCommand((BLE_ExtCustomCommand_t *)Command->NextCommand);
 801d88c:	687b      	ldr	r3, [r7, #4]
 801d88e:	689b      	ldr	r3, [r3, #8]
 801d890:	4618      	mov	r0, r3
 801d892:	f7ff fff3 	bl	801d87c <ClearSingleCommand>
  }
#if (BLE_DEBUG_LEVEL>1)
  BLE_MANAGER_PRINTF("Deleting Custom Command<%s>\r\n", Command->CommandName);
#endif /* (BLE_DEBUG_LEVEL>1) */
  BLE_FREE_FUNCTION(Command->CommandName);
 801d896:	687b      	ldr	r3, [r7, #4]
 801d898:	681b      	ldr	r3, [r3, #0]
 801d89a:	4618      	mov	r0, r3
 801d89c:	f004 fb9c 	bl	8021fd8 <free>
  BLE_FREE_FUNCTION(Command);
 801d8a0:	6878      	ldr	r0, [r7, #4]
 801d8a2:	f004 fb99 	bl	8021fd8 <free>
}
 801d8a6:	bf00      	nop
 801d8a8:	3708      	adds	r7, #8
 801d8aa:	46bd      	mov	sp, r7
 801d8ac:	bd80      	pop	{r7, pc}
	...

0801d8b0 <safe_aci_gatt_update_char_value>:
*/
tBleStatus safe_aci_gatt_update_char_value(BleCharTypeDef *BleCharPointer,
                                           uint8_t charValOffset,
                                           uint8_t charValueLen,
                                           uint8_t *charValue)
{
 801d8b0:	b580      	push	{r7, lr}
 801d8b2:	b088      	sub	sp, #32
 801d8b4:	af02      	add	r7, sp, #8
 801d8b6:	60f8      	str	r0, [r7, #12]
 801d8b8:	607b      	str	r3, [r7, #4]
 801d8ba:	460b      	mov	r3, r1
 801d8bc:	72fb      	strb	r3, [r7, #11]
 801d8be:	4613      	mov	r3, r2
 801d8c0:	72bb      	strb	r3, [r7, #10]
  tBleStatus ret = BLE_STATUS_INSUFFICIENT_RESOURCES;
 801d8c2:	2388      	movs	r3, #136	@ 0x88
 801d8c4:	75fb      	strb	r3, [r7, #23]
  if (breath == 0)
 801d8c6:	4b11      	ldr	r3, [pc, #68]	@ (801d90c <safe_aci_gatt_update_char_value+0x5c>)
 801d8c8:	681b      	ldr	r3, [r3, #0]
 801d8ca:	2b00      	cmp	r3, #0
 801d8cc:	d118      	bne.n	801d900 <safe_aci_gatt_update_char_value+0x50>
                                     BleCharPointer->attr_handle,
                                     charValOffset,
                                     charValueLen,
                                     charValue);
#else /* (BLUE_CORE != BLUENRG_LP) */
    ret = aci_gatt_srv_notify(connection_handle,
 801d8ce:	4b10      	ldr	r3, [pc, #64]	@ (801d910 <safe_aci_gatt_update_char_value+0x60>)
 801d8d0:	8818      	ldrh	r0, [r3, #0]
                              BleCharPointer->attr_handle + 1,
 801d8d2:	68fb      	ldr	r3, [r7, #12]
 801d8d4:	8b5b      	ldrh	r3, [r3, #26]
    ret = aci_gatt_srv_notify(connection_handle,
 801d8d6:	3301      	adds	r3, #1
 801d8d8:	b299      	uxth	r1, r3
 801d8da:	7abb      	ldrb	r3, [r7, #10]
 801d8dc:	b29a      	uxth	r2, r3
 801d8de:	687b      	ldr	r3, [r7, #4]
 801d8e0:	9300      	str	r3, [sp, #0]
 801d8e2:	4613      	mov	r3, r2
 801d8e4:	2200      	movs	r2, #0
 801d8e6:	f7fb fd1c 	bl	8019322 <aci_gatt_srv_notify>
 801d8ea:	4603      	mov	r3, r0
 801d8ec:	75fb      	strb	r3, [r7, #23]
                              GATT_NOTIFICATION,
                              charValueLen,
                              charValue);
#endif /* (BLUE_CORE != BLUENRG_LP) */

    if (ret != (tBleStatus)BLE_STATUS_SUCCESS)
 801d8ee:	7dfb      	ldrb	r3, [r7, #23]
 801d8f0:	2b00      	cmp	r3, #0
 801d8f2:	d005      	beq.n	801d900 <safe_aci_gatt_update_char_value+0x50>
    {
#if (BLE_DEBUG_LEVEL>2)
      BLE_MANAGER_PRINTF("Error: Updating Char handle=%x ret=%x\r\n", BleCharPointer->attr_handle, ret);
#endif /* (BLE_DEBUG_LEVEL>2) */
      if (ret == (tBleStatus)BLE_STATUS_INSUFFICIENT_RESOURCES)
 801d8f4:	7dfb      	ldrb	r3, [r7, #23]
 801d8f6:	2b88      	cmp	r3, #136	@ 0x88
 801d8f8:	d102      	bne.n	801d900 <safe_aci_gatt_update_char_value+0x50>
      {
#if (BLE_DEBUG_LEVEL>2)
        BLE_MANAGER_PRINTF("Char handle=%x insufficient resources\r\n", BleCharPointer->attr_handle);
#endif /* (BLE_DEBUG_LEVEL>2) */
        breath = 1;
 801d8fa:	4b04      	ldr	r3, [pc, #16]	@ (801d90c <safe_aci_gatt_update_char_value+0x5c>)
 801d8fc:	2201      	movs	r2, #1
 801d8fe:	601a      	str	r2, [r3, #0]
      }
    }
  }
  return ret;
 801d900:	7dfb      	ldrb	r3, [r7, #23]
}
 801d902:	4618      	mov	r0, r3
 801d904:	3718      	adds	r7, #24
 801d906:	46bd      	mov	sp, r7
 801d908:	bd80      	pop	{r7, pc}
 801d90a:	bf00      	nop
 801d90c:	20001e94 	.word	0x20001e94
 801d910:	20001dac 	.word	0x20001dac

0801d914 <aci_gatt_tx_pool_available_event>:
  * @param Available_Buffers Not used.
  * @retval None
  */
void aci_gatt_tx_pool_available_event(uint16_t Connection_Handle,
                                      uint16_t Available_Buffers)
{
 801d914:	b580      	push	{r7, lr}
 801d916:	b082      	sub	sp, #8
 801d918:	af00      	add	r7, sp, #0
 801d91a:	4603      	mov	r3, r0
 801d91c:	460a      	mov	r2, r1
 801d91e:	80fb      	strh	r3, [r7, #6]
 801d920:	4613      	mov	r3, r2
 801d922:	80bb      	strh	r3, [r7, #4]
#if (BLE_DEBUG_LEVEL>1)
  BLE_MANAGER_PRINTF("aci_gatt_tx_pool_available_event\r\n");
#endif /* (BLE_DEBUG_LEVEL>1) */

#ifdef ACC_BLUENRG_CONGESTION
  breath = 0;
 801d924:	4b06      	ldr	r3, [pc, #24]	@ (801d940 <aci_gatt_tx_pool_available_event+0x2c>)
 801d926:	2200      	movs	r2, #0
 801d928:	601a      	str	r2, [r3, #0]
#endif /* ACC_BLUENRG_CONGESTION */

  if (CustomAciGattTxPoolAvailableEvent != NULL)
 801d92a:	4b06      	ldr	r3, [pc, #24]	@ (801d944 <aci_gatt_tx_pool_available_event+0x30>)
 801d92c:	681b      	ldr	r3, [r3, #0]
 801d92e:	2b00      	cmp	r3, #0
 801d930:	d002      	beq.n	801d938 <aci_gatt_tx_pool_available_event+0x24>
  {
    CustomAciGattTxPoolAvailableEvent();
 801d932:	4b04      	ldr	r3, [pc, #16]	@ (801d944 <aci_gatt_tx_pool_available_event+0x30>)
 801d934:	681b      	ldr	r3, [r3, #0]
 801d936:	4798      	blx	r3
  }
}
 801d938:	bf00      	nop
 801d93a:	3708      	adds	r7, #8
 801d93c:	46bd      	mov	sp, r7
 801d93e:	bd80      	pop	{r7, pc}
 801d940:	20001e94 	.word	0x20001e94
 801d944:	20001b4c 	.word	0x20001b4c

0801d948 <Stderr_Update>:
  * @param  uint8_t *data string to write
  * @param  uint8_t length length of string to write
  * @retval tBleStatus      Status
  */
tBleStatus Stderr_Update(uint8_t *data, uint8_t length)
{
 801d948:	b580      	push	{r7, lr}
 801d94a:	b084      	sub	sp, #16
 801d94c:	af00      	add	r7, sp, #0
 801d94e:	6078      	str	r0, [r7, #4]
 801d950:	460b      	mov	r3, r1
 801d952:	70fb      	strb	r3, [r7, #3]
  uint8_t Offset;
  uint8_t DataToSend;
  /* Split the code in Chunks */
  /* First Chunk */
  DataToSend = (length > MaxBleCharStdErrLen) ?  MaxBleCharStdErrLen : length;
 801d954:	4b28      	ldr	r3, [pc, #160]	@ (801d9f8 <Stderr_Update+0xb0>)
 801d956:	781b      	ldrb	r3, [r3, #0]
 801d958:	78fa      	ldrb	r2, [r7, #3]
 801d95a:	4293      	cmp	r3, r2
 801d95c:	bf28      	it	cs
 801d95e:	4613      	movcs	r3, r2
 801d960:	73bb      	strb	r3, [r7, #14]

  /* keep a copy */
  memcpy(LastStderrBuffer, data, DataToSend);
 801d962:	7bbb      	ldrb	r3, [r7, #14]
 801d964:	461a      	mov	r2, r3
 801d966:	6879      	ldr	r1, [r7, #4]
 801d968:	4824      	ldr	r0, [pc, #144]	@ (801d9fc <Stderr_Update+0xb4>)
 801d96a:	f006 fc40 	bl	80241ee <memcpy>
  LastStderrLen = DataToSend;
 801d96e:	4a24      	ldr	r2, [pc, #144]	@ (801da00 <Stderr_Update+0xb8>)
 801d970:	7bbb      	ldrb	r3, [r7, #14]
 801d972:	7013      	strb	r3, [r2, #0]

  if (UpdateTermStdErr(data, DataToSend) != (tBleStatus)BLE_STATUS_SUCCESS)
 801d974:	7bbb      	ldrb	r3, [r7, #14]
 801d976:	4619      	mov	r1, r3
 801d978:	6878      	ldr	r0, [r7, #4]
 801d97a:	f7ff ff3d 	bl	801d7f8 <UpdateTermStdErr>
 801d97e:	4603      	mov	r3, r0
 801d980:	2b00      	cmp	r3, #0
 801d982:	d001      	beq.n	801d988 <Stderr_Update+0x40>
  {
    return BLE_STATUS_ERROR;
 801d984:	2386      	movs	r3, #134	@ 0x86
 801d986:	e033      	b.n	801d9f0 <Stderr_Update+0xa8>
  }

  /* Following Chunks if necessary */
  Offset = MaxBleCharStdErrLen;
 801d988:	4b1b      	ldr	r3, [pc, #108]	@ (801d9f8 <Stderr_Update+0xb0>)
 801d98a:	781b      	ldrb	r3, [r3, #0]
 801d98c:	73fb      	strb	r3, [r7, #15]
  for (; Offset < length; Offset += MaxBleCharStdErrLen)
 801d98e:	e02a      	b.n	801d9e6 <Stderr_Update+0x9e>
  {
    /* Add a Delay respect previous chunk */
    BLE_MANAGER_DELAY(20);
 801d990:	2014      	movs	r0, #20
 801d992:	f7e6 ff33 	bl	80047fc <HAL_Delay>

    DataToSend = (length - Offset);
 801d996:	78fa      	ldrb	r2, [r7, #3]
 801d998:	7bfb      	ldrb	r3, [r7, #15]
 801d99a:	1ad3      	subs	r3, r2, r3
 801d99c:	73bb      	strb	r3, [r7, #14]
    DataToSend = (DataToSend > MaxBleCharStdErrLen) ?  MaxBleCharStdErrLen : DataToSend;
 801d99e:	4b16      	ldr	r3, [pc, #88]	@ (801d9f8 <Stderr_Update+0xb0>)
 801d9a0:	781b      	ldrb	r3, [r3, #0]
 801d9a2:	7bba      	ldrb	r2, [r7, #14]
 801d9a4:	4293      	cmp	r3, r2
 801d9a6:	bf28      	it	cs
 801d9a8:	4613      	movcs	r3, r2
 801d9aa:	73bb      	strb	r3, [r7, #14]

    /* keep a copy */
    memcpy(LastStderrBuffer, data + Offset, DataToSend);
 801d9ac:	7bfb      	ldrb	r3, [r7, #15]
 801d9ae:	687a      	ldr	r2, [r7, #4]
 801d9b0:	4413      	add	r3, r2
 801d9b2:	7bba      	ldrb	r2, [r7, #14]
 801d9b4:	4619      	mov	r1, r3
 801d9b6:	4811      	ldr	r0, [pc, #68]	@ (801d9fc <Stderr_Update+0xb4>)
 801d9b8:	f006 fc19 	bl	80241ee <memcpy>
    LastStderrLen = DataToSend;
 801d9bc:	4a10      	ldr	r2, [pc, #64]	@ (801da00 <Stderr_Update+0xb8>)
 801d9be:	7bbb      	ldrb	r3, [r7, #14]
 801d9c0:	7013      	strb	r3, [r2, #0]

    if (UpdateTermStdErr(data + Offset, DataToSend) != (tBleStatus)BLE_STATUS_SUCCESS)
 801d9c2:	7bfb      	ldrb	r3, [r7, #15]
 801d9c4:	687a      	ldr	r2, [r7, #4]
 801d9c6:	4413      	add	r3, r2
 801d9c8:	7bba      	ldrb	r2, [r7, #14]
 801d9ca:	4611      	mov	r1, r2
 801d9cc:	4618      	mov	r0, r3
 801d9ce:	f7ff ff13 	bl	801d7f8 <UpdateTermStdErr>
 801d9d2:	4603      	mov	r3, r0
 801d9d4:	2b00      	cmp	r3, #0
 801d9d6:	d001      	beq.n	801d9dc <Stderr_Update+0x94>
    {
      return BLE_STATUS_ERROR;
 801d9d8:	2386      	movs	r3, #134	@ 0x86
 801d9da:	e009      	b.n	801d9f0 <Stderr_Update+0xa8>
  for (; Offset < length; Offset += MaxBleCharStdErrLen)
 801d9dc:	4b06      	ldr	r3, [pc, #24]	@ (801d9f8 <Stderr_Update+0xb0>)
 801d9de:	781a      	ldrb	r2, [r3, #0]
 801d9e0:	7bfb      	ldrb	r3, [r7, #15]
 801d9e2:	4413      	add	r3, r2
 801d9e4:	73fb      	strb	r3, [r7, #15]
 801d9e6:	7bfa      	ldrb	r2, [r7, #15]
 801d9e8:	78fb      	ldrb	r3, [r7, #3]
 801d9ea:	429a      	cmp	r2, r3
 801d9ec:	d3d0      	bcc.n	801d990 <Stderr_Update+0x48>
    }
  }
  return BLE_STATUS_SUCCESS;
 801d9ee:	2300      	movs	r3, #0
}
 801d9f0:	4618      	mov	r0, r3
 801d9f2:	3710      	adds	r7, #16
 801d9f4:	46bd      	mov	sp, r7
 801d9f6:	bd80      	pop	{r7, pc}
 801d9f8:	20001daf 	.word	0x20001daf
 801d9fc:	20001bb4 	.word	0x20001bb4
 801da00:	20001ca8 	.word	0x20001ca8

0801da04 <Term_Update>:
  * @param  uint8_t *data string to write
  * @param  uint8_t length length of string to write
  * @retval tBleStatus      Status
  */
tBleStatus Term_Update(uint8_t *data, uint8_t length)
{
 801da04:	b580      	push	{r7, lr}
 801da06:	b084      	sub	sp, #16
 801da08:	af00      	add	r7, sp, #0
 801da0a:	6078      	str	r0, [r7, #4]
 801da0c:	460b      	mov	r3, r1
 801da0e:	70fb      	strb	r3, [r7, #3]
  uint8_t   Offset;
  uint8_t   DataToSend;

  /* Split the code in Chunks */
  /* First Chunk */
  DataToSend = (length > MaxBleCharStdOutLen) ?  MaxBleCharStdOutLen : length;
 801da10:	4b28      	ldr	r3, [pc, #160]	@ (801dab4 <Term_Update+0xb0>)
 801da12:	781b      	ldrb	r3, [r3, #0]
 801da14:	78fa      	ldrb	r2, [r7, #3]
 801da16:	4293      	cmp	r3, r2
 801da18:	bf28      	it	cs
 801da1a:	4613      	movcs	r3, r2
 801da1c:	73bb      	strb	r3, [r7, #14]

  /* keep a copy */
  memcpy(LastTermBuffer, data, DataToSend);
 801da1e:	7bbb      	ldrb	r3, [r7, #14]
 801da20:	461a      	mov	r2, r3
 801da22:	6879      	ldr	r1, [r7, #4]
 801da24:	4824      	ldr	r0, [pc, #144]	@ (801dab8 <Term_Update+0xb4>)
 801da26:	f006 fbe2 	bl	80241ee <memcpy>
  LastTermLen = DataToSend;
 801da2a:	4a24      	ldr	r2, [pc, #144]	@ (801dabc <Term_Update+0xb8>)
 801da2c:	7bbb      	ldrb	r3, [r7, #14]
 801da2e:	7013      	strb	r3, [r2, #0]

  if (UpdateTermStdOut(data, DataToSend) != (tBleStatus)BLE_STATUS_SUCCESS)
 801da30:	7bbb      	ldrb	r3, [r7, #14]
 801da32:	4619      	mov	r1, r3
 801da34:	6878      	ldr	r0, [r7, #4]
 801da36:	f7ff fec1 	bl	801d7bc <UpdateTermStdOut>
 801da3a:	4603      	mov	r3, r0
 801da3c:	2b00      	cmp	r3, #0
 801da3e:	d001      	beq.n	801da44 <Term_Update+0x40>
  {
    return BLE_STATUS_ERROR;
 801da40:	2386      	movs	r3, #134	@ 0x86
 801da42:	e033      	b.n	801daac <Term_Update+0xa8>
  }

  /* Following Chunks if necessary */
  Offset = MaxBleCharStdOutLen;
 801da44:	4b1b      	ldr	r3, [pc, #108]	@ (801dab4 <Term_Update+0xb0>)
 801da46:	781b      	ldrb	r3, [r3, #0]
 801da48:	73fb      	strb	r3, [r7, #15]
  for (; Offset < length; Offset += MaxBleCharStdOutLen)
 801da4a:	e02a      	b.n	801daa2 <Term_Update+0x9e>
  {

    /* Add a Delay respect previous chunk */
    BLE_MANAGER_DELAY(20);
 801da4c:	2014      	movs	r0, #20
 801da4e:	f7e6 fed5 	bl	80047fc <HAL_Delay>

    DataToSend = (length - Offset);
 801da52:	78fa      	ldrb	r2, [r7, #3]
 801da54:	7bfb      	ldrb	r3, [r7, #15]
 801da56:	1ad3      	subs	r3, r2, r3
 801da58:	73bb      	strb	r3, [r7, #14]
    DataToSend = (DataToSend > MaxBleCharStdOutLen) ?  MaxBleCharStdOutLen : DataToSend;
 801da5a:	4b16      	ldr	r3, [pc, #88]	@ (801dab4 <Term_Update+0xb0>)
 801da5c:	781b      	ldrb	r3, [r3, #0]
 801da5e:	7bba      	ldrb	r2, [r7, #14]
 801da60:	4293      	cmp	r3, r2
 801da62:	bf28      	it	cs
 801da64:	4613      	movcs	r3, r2
 801da66:	73bb      	strb	r3, [r7, #14]

    /* keep a copy */
    memcpy(LastTermBuffer, data + Offset, DataToSend);
 801da68:	7bfb      	ldrb	r3, [r7, #15]
 801da6a:	687a      	ldr	r2, [r7, #4]
 801da6c:	4413      	add	r3, r2
 801da6e:	7bba      	ldrb	r2, [r7, #14]
 801da70:	4619      	mov	r1, r3
 801da72:	4811      	ldr	r0, [pc, #68]	@ (801dab8 <Term_Update+0xb4>)
 801da74:	f006 fbbb 	bl	80241ee <memcpy>
    LastTermLen = DataToSend;
 801da78:	4a10      	ldr	r2, [pc, #64]	@ (801dabc <Term_Update+0xb8>)
 801da7a:	7bbb      	ldrb	r3, [r7, #14]
 801da7c:	7013      	strb	r3, [r2, #0]

    if (UpdateTermStdOut(data + Offset, DataToSend) != (tBleStatus)BLE_STATUS_SUCCESS)
 801da7e:	7bfb      	ldrb	r3, [r7, #15]
 801da80:	687a      	ldr	r2, [r7, #4]
 801da82:	4413      	add	r3, r2
 801da84:	7bba      	ldrb	r2, [r7, #14]
 801da86:	4611      	mov	r1, r2
 801da88:	4618      	mov	r0, r3
 801da8a:	f7ff fe97 	bl	801d7bc <UpdateTermStdOut>
 801da8e:	4603      	mov	r3, r0
 801da90:	2b00      	cmp	r3, #0
 801da92:	d001      	beq.n	801da98 <Term_Update+0x94>
    {
      return BLE_STATUS_ERROR;
 801da94:	2386      	movs	r3, #134	@ 0x86
 801da96:	e009      	b.n	801daac <Term_Update+0xa8>
  for (; Offset < length; Offset += MaxBleCharStdOutLen)
 801da98:	4b06      	ldr	r3, [pc, #24]	@ (801dab4 <Term_Update+0xb0>)
 801da9a:	781a      	ldrb	r2, [r3, #0]
 801da9c:	7bfb      	ldrb	r3, [r7, #15]
 801da9e:	4413      	add	r3, r2
 801daa0:	73fb      	strb	r3, [r7, #15]
 801daa2:	7bfa      	ldrb	r2, [r7, #15]
 801daa4:	78fb      	ldrb	r3, [r7, #3]
 801daa6:	429a      	cmp	r2, r3
 801daa8:	d3d0      	bcc.n	801da4c <Term_Update+0x48>
    }
  }
  return BLE_STATUS_SUCCESS;
 801daaa:	2300      	movs	r3, #0
}
 801daac:	4618      	mov	r0, r3
 801daae:	3710      	adds	r7, #16
 801dab0:	46bd      	mov	sp, r7
 801dab2:	bd80      	pop	{r7, pc}
 801dab4:	20001dae 	.word	0x20001dae
 801dab8:	20001cac 	.word	0x20001cac
 801dabc:	20001dab 	.word	0x20001dab

0801dac0 <BleManagerAddChar>:
  * @brief  Added BLE service
  * @param  BleCharTypeDef *BleChar: Data structure pointer for BLE service
  * @retval 1 in case of success
  */
int32_t BleManagerAddChar(BleCharTypeDef *BleChar)
{
 801dac0:	b480      	push	{r7}
 801dac2:	b085      	sub	sp, #20
 801dac4:	af00      	add	r7, sp, #0
 801dac6:	6078      	str	r0, [r7, #4]
  int32_t retValue = 0;
 801dac8:	2300      	movs	r3, #0
 801daca:	60fb      	str	r3, [r7, #12]

  if (BleChar != NULL)
 801dacc:	687b      	ldr	r3, [r7, #4]
 801dace:	2b00      	cmp	r3, #0
 801dad0:	d012      	beq.n	801daf8 <BleManagerAddChar+0x38>
  {
    if (UsedBleChars < (uint8_t)BLE_MANAGER_MAX_ALLOCABLE_CHARS)
 801dad2:	4b0d      	ldr	r3, [pc, #52]	@ (801db08 <BleManagerAddChar+0x48>)
 801dad4:	781b      	ldrb	r3, [r3, #0]
 801dad6:	2b1f      	cmp	r3, #31
 801dad8:	d80e      	bhi.n	801daf8 <BleManagerAddChar+0x38>
    {
      BleCharsArray[UsedBleChars] = BleChar;
 801dada:	4b0b      	ldr	r3, [pc, #44]	@ (801db08 <BleManagerAddChar+0x48>)
 801dadc:	781b      	ldrb	r3, [r3, #0]
 801dade:	4619      	mov	r1, r3
 801dae0:	4a0a      	ldr	r2, [pc, #40]	@ (801db0c <BleManagerAddChar+0x4c>)
 801dae2:	687b      	ldr	r3, [r7, #4]
 801dae4:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
      UsedBleChars++;
 801dae8:	4b07      	ldr	r3, [pc, #28]	@ (801db08 <BleManagerAddChar+0x48>)
 801daea:	781b      	ldrb	r3, [r3, #0]
 801daec:	3301      	adds	r3, #1
 801daee:	b2da      	uxtb	r2, r3
 801daf0:	4b05      	ldr	r3, [pc, #20]	@ (801db08 <BleManagerAddChar+0x48>)
 801daf2:	701a      	strb	r2, [r3, #0]
      retValue = 1;
 801daf4:	2301      	movs	r3, #1
 801daf6:	60fb      	str	r3, [r7, #12]
    }
  }

  return retValue;
 801daf8:	68fb      	ldr	r3, [r7, #12]
}
 801dafa:	4618      	mov	r0, r3
 801dafc:	3714      	adds	r7, #20
 801dafe:	46bd      	mov	sp, r7
 801db00:	f85d 7b04 	ldr.w	r7, [sp], #4
 801db04:	4770      	bx	lr
 801db06:	bf00      	nop
 801db08:	20001e88 	.word	0x20001e88
 801db0c:	20001e08 	.word	0x20001e08

0801db10 <getBlueNRGVersion>:
  * @param  Hardware version
  * @param  Firmware version
  * @retval Status
  */
uint8_t getBlueNRGVersion(uint8_t *hwVersion, uint16_t *fwVersion)
{
 801db10:	b590      	push	{r4, r7, lr}
 801db12:	b089      	sub	sp, #36	@ 0x24
 801db14:	af02      	add	r7, sp, #8
 801db16:	6078      	str	r0, [r7, #4]
 801db18:	6039      	str	r1, [r7, #0]
  uint8_t lmp_pal_version;
  uint16_t hci_revision;
  uint16_t manufacturer_name;
  uint16_t lmp_pal_subversion;

  status = hci_read_local_version_information(&hci_version, &hci_revision, &lmp_pal_version,
 801db1a:	f107 0410 	add.w	r4, r7, #16
 801db1e:	f107 0215 	add.w	r2, r7, #21
 801db22:	f107 0112 	add.w	r1, r7, #18
 801db26:	f107 0016 	add.w	r0, r7, #22
 801db2a:	f107 030e 	add.w	r3, r7, #14
 801db2e:	9300      	str	r3, [sp, #0]
 801db30:	4623      	mov	r3, r4
 801db32:	f7fd fed6 	bl	801b8e2 <hci_read_local_version_information>
 801db36:	4603      	mov	r3, r0
 801db38:	75fb      	strb	r3, [r7, #23]
                                              &manufacturer_name, &lmp_pal_subversion);

  if (status == BLE_STATUS_SUCCESS)
 801db3a:	7dfb      	ldrb	r3, [r7, #23]
 801db3c:	2b00      	cmp	r3, #0
 801db3e:	d121      	bne.n	801db84 <getBlueNRGVersion+0x74>
  {
    *hwVersion = (uint8_t)(hci_revision >> 8);
 801db40:	8a7b      	ldrh	r3, [r7, #18]
 801db42:	0a1b      	lsrs	r3, r3, #8
 801db44:	b29b      	uxth	r3, r3
 801db46:	b2da      	uxtb	r2, r3
 801db48:	687b      	ldr	r3, [r7, #4]
 801db4a:	701a      	strb	r2, [r3, #0]
    *fwVersion = (hci_revision & 0xFFU) << 8;              /* Major Version Number */
 801db4c:	8a7b      	ldrh	r3, [r7, #18]
 801db4e:	021b      	lsls	r3, r3, #8
 801db50:	b29a      	uxth	r2, r3
 801db52:	683b      	ldr	r3, [r7, #0]
 801db54:	801a      	strh	r2, [r3, #0]
    *fwVersion |= ((lmp_pal_subversion >> 4) & 0xFU) << 4; /* Minor Version Number */
 801db56:	683b      	ldr	r3, [r7, #0]
 801db58:	881a      	ldrh	r2, [r3, #0]
 801db5a:	89fb      	ldrh	r3, [r7, #14]
 801db5c:	091b      	lsrs	r3, r3, #4
 801db5e:	b29b      	uxth	r3, r3
 801db60:	011b      	lsls	r3, r3, #4
 801db62:	b29b      	uxth	r3, r3
 801db64:	b2db      	uxtb	r3, r3
 801db66:	b29b      	uxth	r3, r3
 801db68:	4313      	orrs	r3, r2
 801db6a:	b29a      	uxth	r2, r3
 801db6c:	683b      	ldr	r3, [r7, #0]
 801db6e:	801a      	strh	r2, [r3, #0]
    *fwVersion |= lmp_pal_subversion & 0xFU;               /* Patch Version Number */
 801db70:	683b      	ldr	r3, [r7, #0]
 801db72:	881a      	ldrh	r2, [r3, #0]
 801db74:	89fb      	ldrh	r3, [r7, #14]
 801db76:	f003 030f 	and.w	r3, r3, #15
 801db7a:	b29b      	uxth	r3, r3
 801db7c:	4313      	orrs	r3, r2
 801db7e:	b29a      	uxth	r2, r3
 801db80:	683b      	ldr	r3, [r7, #0]
 801db82:	801a      	strh	r2, [r3, #0]
  }
  return status;
 801db84:	7dfb      	ldrb	r3, [r7, #23]
}
 801db86:	4618      	mov	r0, r3
 801db88:	371c      	adds	r7, #28
 801db8a:	46bd      	mov	sp, r7
 801db8c:	bd90      	pop	{r4, r7, pc}
	...

0801db90 <BLE_Command_TP_Parse>:
  * @param  buffer_in: pointer to the input data.
  * @param  len: buffer in length
  * @retval Buffer out length.
  */
uint32_t BLE_Command_TP_Parse(uint8_t **buffer_out, uint8_t *buffer_in, uint32_t len)
{
 801db90:	b580      	push	{r7, lr}
 801db92:	b08a      	sub	sp, #40	@ 0x28
 801db94:	af00      	add	r7, sp, #0
 801db96:	60f8      	str	r0, [r7, #12]
 801db98:	60b9      	str	r1, [r7, #8]
 801db9a:	607a      	str	r2, [r7, #4]
  uint32_t buff_out_len = 0;
 801db9c:	2300      	movs	r3, #0
 801db9e:	627b      	str	r3, [r7, #36]	@ 0x24
  BLE_COMM_TP_Packet_Typedef packet_type;

  packet_type = (BLE_COMM_TP_Packet_Typedef) buffer_in[0];
 801dba0:	68bb      	ldr	r3, [r7, #8]
 801dba2:	781b      	ldrb	r3, [r3, #0]
 801dba4:	f887 3023 	strb.w	r3, [r7, #35]	@ 0x23

  switch (StatusBLEParse)
 801dba8:	4b91      	ldr	r3, [pc, #580]	@ (801ddf0 <BLE_Command_TP_Parse+0x260>)
 801dbaa:	781b      	ldrb	r3, [r3, #0]
 801dbac:	2b00      	cmp	r3, #0
 801dbae:	d003      	beq.n	801dbb8 <BLE_Command_TP_Parse+0x28>
 801dbb0:	2b01      	cmp	r3, #1
 801dbb2:	f000 80d3 	beq.w	801dd5c <BLE_Command_TP_Parse+0x1cc>
 801dbb6:	e115      	b.n	801dde4 <BLE_Command_TP_Parse+0x254>
  {
    case BLE_COMM_TP_WAIT_START:
      if (packet_type == BLE_COMM_TP_START_PACKET)
 801dbb8:	f897 3023 	ldrb.w	r3, [r7, #35]	@ 0x23
 801dbbc:	2b00      	cmp	r3, #0
 801dbbe:	d138      	bne.n	801dc32 <BLE_Command_TP_Parse+0xa2>
      {
        /*First part of an BLE Command packet*/
        /*packet is enqueued*/
        uint32_t message_length = buffer_in[1];
 801dbc0:	68bb      	ldr	r3, [r7, #8]
 801dbc2:	3301      	adds	r3, #1
 801dbc4:	781b      	ldrb	r3, [r3, #0]
 801dbc6:	617b      	str	r3, [r7, #20]
        message_length = message_length << 8;
 801dbc8:	697b      	ldr	r3, [r7, #20]
 801dbca:	021b      	lsls	r3, r3, #8
 801dbcc:	617b      	str	r3, [r7, #20]
        message_length |= buffer_in[2];
 801dbce:	68bb      	ldr	r3, [r7, #8]
 801dbd0:	3302      	adds	r3, #2
 801dbd2:	781b      	ldrb	r3, [r3, #0]
 801dbd4:	461a      	mov	r2, r3
 801dbd6:	697b      	ldr	r3, [r7, #20]
 801dbd8:	4313      	orrs	r3, r2
 801dbda:	617b      	str	r3, [r7, #20]
                {
                  BLE_FREE_FUNCTION(*buffer_out);
                }
        */

        *buffer_out = (uint8_t *)BLE_MALLOC_FUNCTION((message_length) * sizeof(uint8_t));
 801dbdc:	6978      	ldr	r0, [r7, #20]
 801dbde:	f004 f9f3 	bl	8021fc8 <malloc>
 801dbe2:	4603      	mov	r3, r0
 801dbe4:	461a      	mov	r2, r3
 801dbe6:	68fb      	ldr	r3, [r7, #12]
 801dbe8:	601a      	str	r2, [r3, #0]

        if (*buffer_out == NULL)
 801dbea:	68fb      	ldr	r3, [r7, #12]
 801dbec:	681b      	ldr	r3, [r3, #0]
 801dbee:	2b00      	cmp	r3, #0
 801dbf0:	d106      	bne.n	801dc00 <BLE_Command_TP_Parse+0x70>
        {
          BLE_MANAGER_PRINTF("Error: Mem alloc error [%ld]: %d@%s\r\n", message_length, __LINE__, __FILE__);
 801dbf2:	4b80      	ldr	r3, [pc, #512]	@ (801ddf4 <BLE_Command_TP_Parse+0x264>)
 801dbf4:	f640 62e2 	movw	r2, #3810	@ 0xee2
 801dbf8:	6979      	ldr	r1, [r7, #20]
 801dbfa:	487f      	ldr	r0, [pc, #508]	@ (801ddf8 <BLE_Command_TP_Parse+0x268>)
 801dbfc:	f006 f8ae 	bl	8023d5c <iprintf>
        }

        memcpy(*buffer_out + TotLenBLEParse, (uint8_t *) &buffer_in[3], (len - 3U));
 801dc00:	68fb      	ldr	r3, [r7, #12]
 801dc02:	681a      	ldr	r2, [r3, #0]
 801dc04:	4b7d      	ldr	r3, [pc, #500]	@ (801ddfc <BLE_Command_TP_Parse+0x26c>)
 801dc06:	681b      	ldr	r3, [r3, #0]
 801dc08:	18d0      	adds	r0, r2, r3
 801dc0a:	68bb      	ldr	r3, [r7, #8]
 801dc0c:	1cd9      	adds	r1, r3, #3
 801dc0e:	687b      	ldr	r3, [r7, #4]
 801dc10:	3b03      	subs	r3, #3
 801dc12:	461a      	mov	r2, r3
 801dc14:	f006 faeb 	bl	80241ee <memcpy>


        TotLenBLEParse += len - 3U;
 801dc18:	4b78      	ldr	r3, [pc, #480]	@ (801ddfc <BLE_Command_TP_Parse+0x26c>)
 801dc1a:	681a      	ldr	r2, [r3, #0]
 801dc1c:	687b      	ldr	r3, [r7, #4]
 801dc1e:	4413      	add	r3, r2
 801dc20:	3b03      	subs	r3, #3
 801dc22:	4a76      	ldr	r2, [pc, #472]	@ (801ddfc <BLE_Command_TP_Parse+0x26c>)
 801dc24:	6013      	str	r3, [r2, #0]
        StatusBLEParse = BLE_COMM_TP_WAIT_END;
 801dc26:	4b72      	ldr	r3, [pc, #456]	@ (801ddf0 <BLE_Command_TP_Parse+0x260>)
 801dc28:	2201      	movs	r2, #1
 801dc2a:	701a      	strb	r2, [r3, #0]
        buff_out_len = 0;
 801dc2c:	2300      	movs	r3, #0
 801dc2e:	627b      	str	r3, [r7, #36]	@ 0x24
      else
      {
        /* Error */
        buff_out_len = 0;
      }
      break;
 801dc30:	e0d8      	b.n	801dde4 <BLE_Command_TP_Parse+0x254>
      else if (packet_type == BLE_COMM_TP_START_LONG_PACKET)
 801dc32:	f897 3023 	ldrb.w	r3, [r7, #35]	@ 0x23
 801dc36:	2b10      	cmp	r3, #16
 801dc38:	d14c      	bne.n	801dcd4 <BLE_Command_TP_Parse+0x144>
        uint32_t message_length = buffer_in[1];
 801dc3a:	68bb      	ldr	r3, [r7, #8]
 801dc3c:	3301      	adds	r3, #1
 801dc3e:	781b      	ldrb	r3, [r3, #0]
 801dc40:	61bb      	str	r3, [r7, #24]
        message_length = message_length << 8;
 801dc42:	69bb      	ldr	r3, [r7, #24]
 801dc44:	021b      	lsls	r3, r3, #8
 801dc46:	61bb      	str	r3, [r7, #24]
        message_length |= buffer_in[2];
 801dc48:	68bb      	ldr	r3, [r7, #8]
 801dc4a:	3302      	adds	r3, #2
 801dc4c:	781b      	ldrb	r3, [r3, #0]
 801dc4e:	461a      	mov	r2, r3
 801dc50:	69bb      	ldr	r3, [r7, #24]
 801dc52:	4313      	orrs	r3, r2
 801dc54:	61bb      	str	r3, [r7, #24]
        message_length = message_length << 8;
 801dc56:	69bb      	ldr	r3, [r7, #24]
 801dc58:	021b      	lsls	r3, r3, #8
 801dc5a:	61bb      	str	r3, [r7, #24]
        message_length |= buffer_in[3];
 801dc5c:	68bb      	ldr	r3, [r7, #8]
 801dc5e:	3303      	adds	r3, #3
 801dc60:	781b      	ldrb	r3, [r3, #0]
 801dc62:	461a      	mov	r2, r3
 801dc64:	69bb      	ldr	r3, [r7, #24]
 801dc66:	4313      	orrs	r3, r2
 801dc68:	61bb      	str	r3, [r7, #24]
        message_length = message_length << 8;
 801dc6a:	69bb      	ldr	r3, [r7, #24]
 801dc6c:	021b      	lsls	r3, r3, #8
 801dc6e:	61bb      	str	r3, [r7, #24]
        message_length |= buffer_in[4];
 801dc70:	68bb      	ldr	r3, [r7, #8]
 801dc72:	3304      	adds	r3, #4
 801dc74:	781b      	ldrb	r3, [r3, #0]
 801dc76:	461a      	mov	r2, r3
 801dc78:	69bb      	ldr	r3, [r7, #24]
 801dc7a:	4313      	orrs	r3, r2
 801dc7c:	61bb      	str	r3, [r7, #24]
        *buffer_out = (uint8_t *)BLE_MALLOC_FUNCTION((message_length) * sizeof(uint8_t));
 801dc7e:	69b8      	ldr	r0, [r7, #24]
 801dc80:	f004 f9a2 	bl	8021fc8 <malloc>
 801dc84:	4603      	mov	r3, r0
 801dc86:	461a      	mov	r2, r3
 801dc88:	68fb      	ldr	r3, [r7, #12]
 801dc8a:	601a      	str	r2, [r3, #0]
        if (*buffer_out == NULL)
 801dc8c:	68fb      	ldr	r3, [r7, #12]
 801dc8e:	681b      	ldr	r3, [r3, #0]
 801dc90:	2b00      	cmp	r3, #0
 801dc92:	d106      	bne.n	801dca2 <BLE_Command_TP_Parse+0x112>
          BLE_MANAGER_PRINTF("Error: Mem alloc error [%ld]: %d@%s\r\n", message_length, __LINE__, __FILE__);
 801dc94:	4b57      	ldr	r3, [pc, #348]	@ (801ddf4 <BLE_Command_TP_Parse+0x264>)
 801dc96:	f640 7205 	movw	r2, #3845	@ 0xf05
 801dc9a:	69b9      	ldr	r1, [r7, #24]
 801dc9c:	4856      	ldr	r0, [pc, #344]	@ (801ddf8 <BLE_Command_TP_Parse+0x268>)
 801dc9e:	f006 f85d 	bl	8023d5c <iprintf>
        memcpy(*buffer_out + TotLenBLEParse, (uint8_t *) &buffer_in[5], (len - 5U));
 801dca2:	68fb      	ldr	r3, [r7, #12]
 801dca4:	681a      	ldr	r2, [r3, #0]
 801dca6:	4b55      	ldr	r3, [pc, #340]	@ (801ddfc <BLE_Command_TP_Parse+0x26c>)
 801dca8:	681b      	ldr	r3, [r3, #0]
 801dcaa:	18d0      	adds	r0, r2, r3
 801dcac:	68bb      	ldr	r3, [r7, #8]
 801dcae:	1d59      	adds	r1, r3, #5
 801dcb0:	687b      	ldr	r3, [r7, #4]
 801dcb2:	3b05      	subs	r3, #5
 801dcb4:	461a      	mov	r2, r3
 801dcb6:	f006 fa9a 	bl	80241ee <memcpy>
        TotLenBLEParse += len - 5U;
 801dcba:	4b50      	ldr	r3, [pc, #320]	@ (801ddfc <BLE_Command_TP_Parse+0x26c>)
 801dcbc:	681a      	ldr	r2, [r3, #0]
 801dcbe:	687b      	ldr	r3, [r7, #4]
 801dcc0:	4413      	add	r3, r2
 801dcc2:	3b05      	subs	r3, #5
 801dcc4:	4a4d      	ldr	r2, [pc, #308]	@ (801ddfc <BLE_Command_TP_Parse+0x26c>)
 801dcc6:	6013      	str	r3, [r2, #0]
        StatusBLEParse = BLE_COMM_TP_WAIT_END;
 801dcc8:	4b49      	ldr	r3, [pc, #292]	@ (801ddf0 <BLE_Command_TP_Parse+0x260>)
 801dcca:	2201      	movs	r2, #1
 801dccc:	701a      	strb	r2, [r3, #0]
        buff_out_len = 0;
 801dcce:	2300      	movs	r3, #0
 801dcd0:	627b      	str	r3, [r7, #36]	@ 0x24
      break;
 801dcd2:	e087      	b.n	801dde4 <BLE_Command_TP_Parse+0x254>
      else if (packet_type == BLE_COMM_TP_START_END_PACKET)
 801dcd4:	f897 3023 	ldrb.w	r3, [r7, #35]	@ 0x23
 801dcd8:	2b20      	cmp	r3, #32
 801dcda:	d13c      	bne.n	801dd56 <BLE_Command_TP_Parse+0x1c6>
        uint32_t message_length = buffer_in[1];
 801dcdc:	68bb      	ldr	r3, [r7, #8]
 801dcde:	3301      	adds	r3, #1
 801dce0:	781b      	ldrb	r3, [r3, #0]
 801dce2:	61fb      	str	r3, [r7, #28]
        message_length = message_length << 8;
 801dce4:	69fb      	ldr	r3, [r7, #28]
 801dce6:	021b      	lsls	r3, r3, #8
 801dce8:	61fb      	str	r3, [r7, #28]
        message_length |= buffer_in[2];
 801dcea:	68bb      	ldr	r3, [r7, #8]
 801dcec:	3302      	adds	r3, #2
 801dcee:	781b      	ldrb	r3, [r3, #0]
 801dcf0:	461a      	mov	r2, r3
 801dcf2:	69fb      	ldr	r3, [r7, #28]
 801dcf4:	4313      	orrs	r3, r2
 801dcf6:	61fb      	str	r3, [r7, #28]
        *buffer_out = (uint8_t *)BLE_MALLOC_FUNCTION((message_length) * sizeof(uint8_t));
 801dcf8:	69f8      	ldr	r0, [r7, #28]
 801dcfa:	f004 f965 	bl	8021fc8 <malloc>
 801dcfe:	4603      	mov	r3, r0
 801dd00:	461a      	mov	r2, r3
 801dd02:	68fb      	ldr	r3, [r7, #12]
 801dd04:	601a      	str	r2, [r3, #0]
        if (*buffer_out == NULL)
 801dd06:	68fb      	ldr	r3, [r7, #12]
 801dd08:	681b      	ldr	r3, [r3, #0]
 801dd0a:	2b00      	cmp	r3, #0
 801dd0c:	d106      	bne.n	801dd1c <BLE_Command_TP_Parse+0x18c>
          BLE_MANAGER_PRINTF("Error: Mem alloc error [%ld]: %d@%s\r\n", message_length, __LINE__, __FILE__);
 801dd0e:	4b39      	ldr	r3, [pc, #228]	@ (801ddf4 <BLE_Command_TP_Parse+0x264>)
 801dd10:	f640 721a 	movw	r2, #3866	@ 0xf1a
 801dd14:	69f9      	ldr	r1, [r7, #28]
 801dd16:	4838      	ldr	r0, [pc, #224]	@ (801ddf8 <BLE_Command_TP_Parse+0x268>)
 801dd18:	f006 f820 	bl	8023d5c <iprintf>
        memcpy(*buffer_out + TotLenBLEParse, (uint8_t *) &buffer_in[3], (len - 3U));
 801dd1c:	68fb      	ldr	r3, [r7, #12]
 801dd1e:	681a      	ldr	r2, [r3, #0]
 801dd20:	4b36      	ldr	r3, [pc, #216]	@ (801ddfc <BLE_Command_TP_Parse+0x26c>)
 801dd22:	681b      	ldr	r3, [r3, #0]
 801dd24:	18d0      	adds	r0, r2, r3
 801dd26:	68bb      	ldr	r3, [r7, #8]
 801dd28:	1cd9      	adds	r1, r3, #3
 801dd2a:	687b      	ldr	r3, [r7, #4]
 801dd2c:	3b03      	subs	r3, #3
 801dd2e:	461a      	mov	r2, r3
 801dd30:	f006 fa5d 	bl	80241ee <memcpy>
        TotLenBLEParse += len - 3U;
 801dd34:	4b31      	ldr	r3, [pc, #196]	@ (801ddfc <BLE_Command_TP_Parse+0x26c>)
 801dd36:	681a      	ldr	r2, [r3, #0]
 801dd38:	687b      	ldr	r3, [r7, #4]
 801dd3a:	4413      	add	r3, r2
 801dd3c:	3b03      	subs	r3, #3
 801dd3e:	4a2f      	ldr	r2, [pc, #188]	@ (801ddfc <BLE_Command_TP_Parse+0x26c>)
 801dd40:	6013      	str	r3, [r2, #0]
        buff_out_len = TotLenBLEParse;
 801dd42:	4b2e      	ldr	r3, [pc, #184]	@ (801ddfc <BLE_Command_TP_Parse+0x26c>)
 801dd44:	681b      	ldr	r3, [r3, #0]
 801dd46:	627b      	str	r3, [r7, #36]	@ 0x24
        TotLenBLEParse = 0;
 801dd48:	4b2c      	ldr	r3, [pc, #176]	@ (801ddfc <BLE_Command_TP_Parse+0x26c>)
 801dd4a:	2200      	movs	r2, #0
 801dd4c:	601a      	str	r2, [r3, #0]
        StatusBLEParse = BLE_COMM_TP_WAIT_START;
 801dd4e:	4b28      	ldr	r3, [pc, #160]	@ (801ddf0 <BLE_Command_TP_Parse+0x260>)
 801dd50:	2200      	movs	r2, #0
 801dd52:	701a      	strb	r2, [r3, #0]
      break;
 801dd54:	e046      	b.n	801dde4 <BLE_Command_TP_Parse+0x254>
        buff_out_len = 0;
 801dd56:	2300      	movs	r3, #0
 801dd58:	627b      	str	r3, [r7, #36]	@ 0x24
      break;
 801dd5a:	e043      	b.n	801dde4 <BLE_Command_TP_Parse+0x254>
    case BLE_COMM_TP_WAIT_END:
      if (packet_type == BLE_COMM_TP_MIDDLE_PACKET)
 801dd5c:	f897 3023 	ldrb.w	r3, [r7, #35]	@ 0x23
 801dd60:	2b40      	cmp	r3, #64	@ 0x40
 801dd62:	d115      	bne.n	801dd90 <BLE_Command_TP_Parse+0x200>
      {
        /*Central part of an BLE Command packet*/
        /*packet is enqueued*/

        memcpy(*buffer_out + TotLenBLEParse, (uint8_t *) &buffer_in[1], (len - 1U));
 801dd64:	68fb      	ldr	r3, [r7, #12]
 801dd66:	681a      	ldr	r2, [r3, #0]
 801dd68:	4b24      	ldr	r3, [pc, #144]	@ (801ddfc <BLE_Command_TP_Parse+0x26c>)
 801dd6a:	681b      	ldr	r3, [r3, #0]
 801dd6c:	18d0      	adds	r0, r2, r3
 801dd6e:	68bb      	ldr	r3, [r7, #8]
 801dd70:	1c59      	adds	r1, r3, #1
 801dd72:	687b      	ldr	r3, [r7, #4]
 801dd74:	3b01      	subs	r3, #1
 801dd76:	461a      	mov	r2, r3
 801dd78:	f006 fa39 	bl	80241ee <memcpy>

        TotLenBLEParse += len - 1U;
 801dd7c:	4b1f      	ldr	r3, [pc, #124]	@ (801ddfc <BLE_Command_TP_Parse+0x26c>)
 801dd7e:	681a      	ldr	r2, [r3, #0]
 801dd80:	687b      	ldr	r3, [r7, #4]
 801dd82:	4413      	add	r3, r2
 801dd84:	3b01      	subs	r3, #1
 801dd86:	4a1d      	ldr	r2, [pc, #116]	@ (801ddfc <BLE_Command_TP_Parse+0x26c>)
 801dd88:	6013      	str	r3, [r2, #0]

        buff_out_len = 0;
 801dd8a:	2300      	movs	r3, #0
 801dd8c:	627b      	str	r3, [r7, #36]	@ 0x24
        /*total length set to zero*/
        TotLenBLEParse = 0;

        buff_out_len = 0; /* error */
      }
      break;
 801dd8e:	e028      	b.n	801dde2 <BLE_Command_TP_Parse+0x252>
      else if (packet_type == BLE_COMM_TP_END_PACKET)
 801dd90:	f897 3023 	ldrb.w	r3, [r7, #35]	@ 0x23
 801dd94:	2b80      	cmp	r3, #128	@ 0x80
 801dd96:	d11c      	bne.n	801ddd2 <BLE_Command_TP_Parse+0x242>
        memcpy(*buffer_out + TotLenBLEParse, (uint8_t *) &buffer_in[1], (len - 1U));
 801dd98:	68fb      	ldr	r3, [r7, #12]
 801dd9a:	681a      	ldr	r2, [r3, #0]
 801dd9c:	4b17      	ldr	r3, [pc, #92]	@ (801ddfc <BLE_Command_TP_Parse+0x26c>)
 801dd9e:	681b      	ldr	r3, [r3, #0]
 801dda0:	18d0      	adds	r0, r2, r3
 801dda2:	68bb      	ldr	r3, [r7, #8]
 801dda4:	1c59      	adds	r1, r3, #1
 801dda6:	687b      	ldr	r3, [r7, #4]
 801dda8:	3b01      	subs	r3, #1
 801ddaa:	461a      	mov	r2, r3
 801ddac:	f006 fa1f 	bl	80241ee <memcpy>
        TotLenBLEParse += len - 1U;
 801ddb0:	4b12      	ldr	r3, [pc, #72]	@ (801ddfc <BLE_Command_TP_Parse+0x26c>)
 801ddb2:	681a      	ldr	r2, [r3, #0]
 801ddb4:	687b      	ldr	r3, [r7, #4]
 801ddb6:	4413      	add	r3, r2
 801ddb8:	3b01      	subs	r3, #1
 801ddba:	4a10      	ldr	r2, [pc, #64]	@ (801ddfc <BLE_Command_TP_Parse+0x26c>)
 801ddbc:	6013      	str	r3, [r2, #0]
        buff_out_len = TotLenBLEParse;
 801ddbe:	4b0f      	ldr	r3, [pc, #60]	@ (801ddfc <BLE_Command_TP_Parse+0x26c>)
 801ddc0:	681b      	ldr	r3, [r3, #0]
 801ddc2:	627b      	str	r3, [r7, #36]	@ 0x24
        TotLenBLEParse = 0;
 801ddc4:	4b0d      	ldr	r3, [pc, #52]	@ (801ddfc <BLE_Command_TP_Parse+0x26c>)
 801ddc6:	2200      	movs	r2, #0
 801ddc8:	601a      	str	r2, [r3, #0]
        StatusBLEParse = BLE_COMM_TP_WAIT_START;
 801ddca:	4b09      	ldr	r3, [pc, #36]	@ (801ddf0 <BLE_Command_TP_Parse+0x260>)
 801ddcc:	2200      	movs	r2, #0
 801ddce:	701a      	strb	r2, [r3, #0]
      break;
 801ddd0:	e007      	b.n	801dde2 <BLE_Command_TP_Parse+0x252>
        StatusBLEParse = BLE_COMM_TP_WAIT_START;
 801ddd2:	4b07      	ldr	r3, [pc, #28]	@ (801ddf0 <BLE_Command_TP_Parse+0x260>)
 801ddd4:	2200      	movs	r2, #0
 801ddd6:	701a      	strb	r2, [r3, #0]
        TotLenBLEParse = 0;
 801ddd8:	4b08      	ldr	r3, [pc, #32]	@ (801ddfc <BLE_Command_TP_Parse+0x26c>)
 801ddda:	2200      	movs	r2, #0
 801dddc:	601a      	str	r2, [r3, #0]
        buff_out_len = 0; /* error */
 801ddde:	2300      	movs	r3, #0
 801dde0:	627b      	str	r3, [r7, #36]	@ 0x24
      break;
 801dde2:	bf00      	nop
  }
  return buff_out_len;
 801dde4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 801dde6:	4618      	mov	r0, r3
 801dde8:	3728      	adds	r7, #40	@ 0x28
 801ddea:	46bd      	mov	sp, r7
 801ddec:	bd80      	pop	{r7, pc}
 801ddee:	bf00      	nop
 801ddf0:	20001e90 	.word	0x20001e90
 801ddf4:	08029404 	.word	0x08029404
 801ddf8:	08029c9c 	.word	0x08029c9c
 801ddfc:	20001e8c 	.word	0x20001e8c

0801de00 <BLE_Command_TP_Encapsulate>:
  * @param  len: buffer in length
  * @param  BytePacketSize: Packet Size in Bytes
  * @retval Buffer out length.
  */
uint32_t BLE_Command_TP_Encapsulate(uint8_t *buffer_out, uint8_t *buffer_in, uint32_t len, uint32_t BytePacketSize)
{
 801de00:	b580      	push	{r7, lr}
 801de02:	b08a      	sub	sp, #40	@ 0x28
 801de04:	af00      	add	r7, sp, #0
 801de06:	60f8      	str	r0, [r7, #12]
 801de08:	60b9      	str	r1, [r7, #8]
 801de0a:	607a      	str	r2, [r7, #4]
 801de0c:	603b      	str	r3, [r7, #0]
  uint32_t size = 0;
 801de0e:	2300      	movs	r3, #0
 801de10:	61bb      	str	r3, [r7, #24]
  uint32_t tot_size = 0;
 801de12:	2300      	movs	r3, #0
 801de14:	627b      	str	r3, [r7, #36]	@ 0x24
  uint32_t counter = 0;
 801de16:	2300      	movs	r3, #0
 801de18:	623b      	str	r3, [r7, #32]
  BLE_COMM_TP_Packet_Typedef packet_type = BLE_COMM_TP_START_PACKET;
 801de1a:	2300      	movs	r3, #0
 801de1c:	77fb      	strb	r3, [r7, #31]
  uint32_t BytePacketSizeMinus1 = BytePacketSize - 1U;
 801de1e:	683b      	ldr	r3, [r7, #0]
 801de20:	3b01      	subs	r3, #1
 801de22:	617b      	str	r3, [r7, #20]

  /* One byte header is added to each BLE packet */
  while (counter < len)
 801de24:	e062      	b.n	801deec <BLE_Command_TP_Encapsulate+0xec>
  {
    size = MIN(BytePacketSizeMinus1, (len - counter));
 801de26:	687a      	ldr	r2, [r7, #4]
 801de28:	6a3b      	ldr	r3, [r7, #32]
 801de2a:	1ad3      	subs	r3, r2, r3
 801de2c:	697a      	ldr	r2, [r7, #20]
 801de2e:	4293      	cmp	r3, r2
 801de30:	bf28      	it	cs
 801de32:	4613      	movcs	r3, r2
 801de34:	61bb      	str	r3, [r7, #24]

    if ((len - counter) <= BytePacketSizeMinus1)
 801de36:	687a      	ldr	r2, [r7, #4]
 801de38:	6a3b      	ldr	r3, [r7, #32]
 801de3a:	1ad3      	subs	r3, r2, r3
 801de3c:	697a      	ldr	r2, [r7, #20]
 801de3e:	429a      	cmp	r2, r3
 801de40:	d307      	bcc.n	801de52 <BLE_Command_TP_Encapsulate+0x52>
    {
      if (counter == 0U)
 801de42:	6a3b      	ldr	r3, [r7, #32]
 801de44:	2b00      	cmp	r3, #0
 801de46:	d102      	bne.n	801de4e <BLE_Command_TP_Encapsulate+0x4e>
      {
        packet_type = BLE_COMM_TP_START_END_PACKET;
 801de48:	2320      	movs	r3, #32
 801de4a:	77fb      	strb	r3, [r7, #31]
 801de4c:	e001      	b.n	801de52 <BLE_Command_TP_Encapsulate+0x52>
      }
      else
      {
        packet_type = BLE_COMM_TP_END_PACKET;
 801de4e:	2380      	movs	r3, #128	@ 0x80
 801de50:	77fb      	strb	r3, [r7, #31]
      }
    }

    switch (packet_type)
 801de52:	7ffb      	ldrb	r3, [r7, #31]
 801de54:	2b80      	cmp	r3, #128	@ 0x80
 801de56:	d02c      	beq.n	801deb2 <BLE_Command_TP_Encapsulate+0xb2>
 801de58:	2b80      	cmp	r3, #128	@ 0x80
 801de5a:	dc35      	bgt.n	801dec8 <BLE_Command_TP_Encapsulate+0xc8>
 801de5c:	2b40      	cmp	r3, #64	@ 0x40
 801de5e:	d01f      	beq.n	801dea0 <BLE_Command_TP_Encapsulate+0xa0>
 801de60:	2b40      	cmp	r3, #64	@ 0x40
 801de62:	dc31      	bgt.n	801dec8 <BLE_Command_TP_Encapsulate+0xc8>
 801de64:	2b20      	cmp	r3, #32
 801de66:	d010      	beq.n	801de8a <BLE_Command_TP_Encapsulate+0x8a>
 801de68:	2b20      	cmp	r3, #32
 801de6a:	dc2d      	bgt.n	801dec8 <BLE_Command_TP_Encapsulate+0xc8>
 801de6c:	2b00      	cmp	r3, #0
 801de6e:	d001      	beq.n	801de74 <BLE_Command_TP_Encapsulate+0x74>
 801de70:	2b10      	cmp	r3, #16
      buffer_out[tot_size] = ((uint8_t)(BLE_COMM_TP_END_PACKET));
      tot_size++;
      packet_type = BLE_COMM_TP_START_PACKET;
      break;
    case BLE_COMM_TP_START_LONG_PACKET:
      break;
 801de72:	e029      	b.n	801dec8 <BLE_Command_TP_Encapsulate+0xc8>
      buffer_out[tot_size] = ((uint8_t)(BLE_COMM_TP_START_PACKET));
 801de74:	68fa      	ldr	r2, [r7, #12]
 801de76:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801de78:	4413      	add	r3, r2
 801de7a:	2200      	movs	r2, #0
 801de7c:	701a      	strb	r2, [r3, #0]
      tot_size++;
 801de7e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801de80:	3301      	adds	r3, #1
 801de82:	627b      	str	r3, [r7, #36]	@ 0x24
      packet_type = BLE_COMM_TP_MIDDLE_PACKET;
 801de84:	2340      	movs	r3, #64	@ 0x40
 801de86:	77fb      	strb	r3, [r7, #31]
      break;
 801de88:	e01e      	b.n	801dec8 <BLE_Command_TP_Encapsulate+0xc8>
      buffer_out[tot_size] = ((uint8_t)(BLE_COMM_TP_START_END_PACKET));
 801de8a:	68fa      	ldr	r2, [r7, #12]
 801de8c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801de8e:	4413      	add	r3, r2
 801de90:	2220      	movs	r2, #32
 801de92:	701a      	strb	r2, [r3, #0]
      tot_size++;
 801de94:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801de96:	3301      	adds	r3, #1
 801de98:	627b      	str	r3, [r7, #36]	@ 0x24
      packet_type = BLE_COMM_TP_START_PACKET;
 801de9a:	2300      	movs	r3, #0
 801de9c:	77fb      	strb	r3, [r7, #31]
      break;
 801de9e:	e013      	b.n	801dec8 <BLE_Command_TP_Encapsulate+0xc8>
      buffer_out[tot_size] = ((uint8_t)(BLE_COMM_TP_MIDDLE_PACKET));
 801dea0:	68fa      	ldr	r2, [r7, #12]
 801dea2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801dea4:	4413      	add	r3, r2
 801dea6:	2240      	movs	r2, #64	@ 0x40
 801dea8:	701a      	strb	r2, [r3, #0]
      tot_size++;
 801deaa:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801deac:	3301      	adds	r3, #1
 801deae:	627b      	str	r3, [r7, #36]	@ 0x24
      break;
 801deb0:	e00a      	b.n	801dec8 <BLE_Command_TP_Encapsulate+0xc8>
      buffer_out[tot_size] = ((uint8_t)(BLE_COMM_TP_END_PACKET));
 801deb2:	68fa      	ldr	r2, [r7, #12]
 801deb4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801deb6:	4413      	add	r3, r2
 801deb8:	2280      	movs	r2, #128	@ 0x80
 801deba:	701a      	strb	r2, [r3, #0]
      tot_size++;
 801debc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801debe:	3301      	adds	r3, #1
 801dec0:	627b      	str	r3, [r7, #36]	@ 0x24
      packet_type = BLE_COMM_TP_START_PACKET;
 801dec2:	2300      	movs	r3, #0
 801dec4:	77fb      	strb	r3, [r7, #31]
      break;
 801dec6:	bf00      	nop
    }

    /*Input data is incapsulated*/
    memcpy((uint8_t *) &buffer_out[tot_size], (uint8_t *) &buffer_in[counter], size);
 801dec8:	68fa      	ldr	r2, [r7, #12]
 801deca:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801decc:	18d0      	adds	r0, r2, r3
 801dece:	68ba      	ldr	r2, [r7, #8]
 801ded0:	6a3b      	ldr	r3, [r7, #32]
 801ded2:	4413      	add	r3, r2
 801ded4:	69ba      	ldr	r2, [r7, #24]
 801ded6:	4619      	mov	r1, r3
 801ded8:	f006 f989 	bl	80241ee <memcpy>

    /*length variables update*/
    counter += size;
 801dedc:	6a3a      	ldr	r2, [r7, #32]
 801dede:	69bb      	ldr	r3, [r7, #24]
 801dee0:	4413      	add	r3, r2
 801dee2:	623b      	str	r3, [r7, #32]
    tot_size += size;
 801dee4:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801dee6:	69bb      	ldr	r3, [r7, #24]
 801dee8:	4413      	add	r3, r2
 801deea:	627b      	str	r3, [r7, #36]	@ 0x24
  while (counter < len)
 801deec:	6a3a      	ldr	r2, [r7, #32]
 801deee:	687b      	ldr	r3, [r7, #4]
 801def0:	429a      	cmp	r2, r3
 801def2:	d398      	bcc.n	801de26 <BLE_Command_TP_Encapsulate+0x26>
  }
  return tot_size;
 801def4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 801def6:	4618      	mov	r0, r3
 801def8:	3728      	adds	r7, #40	@ 0x28
 801defa:	46bd      	mov	sp, r7
 801defc:	bd80      	pop	{r7, pc}
	...

0801df00 <hci_le_connection_complete_event>:
                                      uint8_t Peer_Address[6],
                                      uint16_t Conn_Interval,
                                      uint16_t Conn_Latency,
                                      uint16_t Supervision_Timeout,
                                      uint8_t Master_Clock_Accuracy)
{
 801df00:	b5b0      	push	{r4, r5, r7, lr}
 801df02:	b088      	sub	sp, #32
 801df04:	af04      	add	r7, sp, #16
 801df06:	4604      	mov	r4, r0
 801df08:	4608      	mov	r0, r1
 801df0a:	4611      	mov	r1, r2
 801df0c:	461a      	mov	r2, r3
 801df0e:	4623      	mov	r3, r4
 801df10:	71fb      	strb	r3, [r7, #7]
 801df12:	4603      	mov	r3, r0
 801df14:	80bb      	strh	r3, [r7, #4]
 801df16:	460b      	mov	r3, r1
 801df18:	71bb      	strb	r3, [r7, #6]
 801df1a:	4613      	mov	r3, r2
 801df1c:	70fb      	strb	r3, [r7, #3]
  connection_handle = Connection_Handle;
 801df1e:	4a28      	ldr	r2, [pc, #160]	@ (801dfc0 <hci_le_connection_complete_event+0xc0>)
 801df20:	88bb      	ldrh	r3, [r7, #4]
 801df22:	8013      	strh	r3, [r2, #0]

  BLE_MANAGER_PRINTF(">>>>>>CONNECTED %x:%x:%x:%x:%x:%x\r\n", Peer_Address[5], Peer_Address[4], Peer_Address[3],
 801df24:	6a3b      	ldr	r3, [r7, #32]
 801df26:	3305      	adds	r3, #5
 801df28:	781b      	ldrb	r3, [r3, #0]
 801df2a:	4618      	mov	r0, r3
 801df2c:	6a3b      	ldr	r3, [r7, #32]
 801df2e:	3304      	adds	r3, #4
 801df30:	781b      	ldrb	r3, [r3, #0]
 801df32:	461c      	mov	r4, r3
 801df34:	6a3b      	ldr	r3, [r7, #32]
 801df36:	3303      	adds	r3, #3
 801df38:	781b      	ldrb	r3, [r3, #0]
 801df3a:	461d      	mov	r5, r3
 801df3c:	6a3b      	ldr	r3, [r7, #32]
 801df3e:	3302      	adds	r3, #2
 801df40:	781b      	ldrb	r3, [r3, #0]
 801df42:	461a      	mov	r2, r3
 801df44:	6a3b      	ldr	r3, [r7, #32]
 801df46:	3301      	adds	r3, #1
 801df48:	781b      	ldrb	r3, [r3, #0]
 801df4a:	4619      	mov	r1, r3
 801df4c:	6a3b      	ldr	r3, [r7, #32]
 801df4e:	781b      	ldrb	r3, [r3, #0]
 801df50:	9302      	str	r3, [sp, #8]
 801df52:	9101      	str	r1, [sp, #4]
 801df54:	9200      	str	r2, [sp, #0]
 801df56:	462b      	mov	r3, r5
 801df58:	4622      	mov	r2, r4
 801df5a:	4601      	mov	r1, r0
 801df5c:	4819      	ldr	r0, [pc, #100]	@ (801dfc4 <hci_le_connection_complete_event+0xc4>)
 801df5e:	f005 fefd 	bl	8023d5c <iprintf>
                     Peer_Address[2], Peer_Address[1], Peer_Address[0]);

#if (BLUE_CORE != BLUENRG_MS)
  if (BLE_StackValue.EnableSecureConnection)
 801df62:	4b19      	ldr	r3, [pc, #100]	@ (801dfc8 <hci_le_connection_complete_event+0xc8>)
 801df64:	7d5b      	ldrb	r3, [r3, #21]
 801df66:	2b00      	cmp	r3, #0
 801df68:	d017      	beq.n	801df9a <hci_le_connection_complete_event+0x9a>
  {
    tBleStatus RetStatus;
    /* Check if the device is already bonded */
    RetStatus = aci_gap_is_device_bonded(Peer_Address_Type, Peer_Address);
 801df6a:	78fb      	ldrb	r3, [r7, #3]
 801df6c:	6a39      	ldr	r1, [r7, #32]
 801df6e:	4618      	mov	r0, r3
 801df70:	f7fa fef1 	bl	8018d56 <aci_gap_is_device_bonded>
 801df74:	4603      	mov	r3, r0
 801df76:	73fb      	strb	r3, [r7, #15]
    if (RetStatus != (tBleStatus)BLE_STATUS_SUCCESS)
 801df78:	7bfb      	ldrb	r3, [r7, #15]
 801df7a:	2b00      	cmp	r3, #0
 801df7c:	d00d      	beq.n	801df9a <hci_le_connection_complete_event+0x9a>
    {
      /* Send a slave security request to the master */
      RetStatus = aci_gap_slave_security_req(Connection_Handle);
 801df7e:	88bb      	ldrh	r3, [r7, #4]
 801df80:	4618      	mov	r0, r3
 801df82:	f7fa fd0c 	bl	801899e <aci_gap_slave_security_req>
 801df86:	4603      	mov	r3, r0
 801df88:	73fb      	strb	r3, [r7, #15]
      if (RetStatus != (tBleStatus)BLE_STATUS_SUCCESS)
 801df8a:	7bfb      	ldrb	r3, [r7, #15]
 801df8c:	2b00      	cmp	r3, #0
 801df8e:	d004      	beq.n	801df9a <hci_le_connection_complete_event+0x9a>
      {
        BLE_MANAGER_PRINTF("Error: GAP Slave secury request failed %d\r\n", RetStatus);
 801df90:	7bfb      	ldrb	r3, [r7, #15]
 801df92:	4619      	mov	r1, r3
 801df94:	480d      	ldr	r0, [pc, #52]	@ (801dfcc <hci_le_connection_complete_event+0xcc>)
 801df96:	f005 fee1 	bl	8023d5c <iprintf>

  /* Start one Exchange configuration for understaning the maximum ATT_MTU */
#if (BLUE_CORE != BLUENRG_LP)
  aci_gatt_exchange_config(connection_handle);
#else /* (BLUE_CORE != BLUENRG_LP) */
  aci_gatt_clt_exchange_config(Connection_Handle);
 801df9a:	88bb      	ldrh	r3, [r7, #4]
 801df9c:	4618      	mov	r0, r3
 801df9e:	f7fb f8f9 	bl	8019194 <aci_gatt_clt_exchange_config>
#endif /* (BLUE_CORE != BLUENRG_LP) */

  if (CustomConnectionCompleted != NULL)
 801dfa2:	4b0b      	ldr	r3, [pc, #44]	@ (801dfd0 <hci_le_connection_complete_event+0xd0>)
 801dfa4:	681b      	ldr	r3, [r3, #0]
 801dfa6:	2b00      	cmp	r3, #0
 801dfa8:	d006      	beq.n	801dfb8 <hci_le_connection_complete_event+0xb8>
#if (BLUE_CORE == BLUENRG_MS)
    CustomConnectionCompleted(connection_handle, Peer_Address);
#elif (BLUE_CORE == BLUE_WB)
    CustomConnectionCompleted(connection_handle);
#else /* (BLUE_CORE == BLUENRG_MS) */
    CustomConnectionCompleted(connection_handle, Peer_Address_Type, Peer_Address);
 801dfaa:	4b09      	ldr	r3, [pc, #36]	@ (801dfd0 <hci_le_connection_complete_event+0xd0>)
 801dfac:	681b      	ldr	r3, [r3, #0]
 801dfae:	4a04      	ldr	r2, [pc, #16]	@ (801dfc0 <hci_le_connection_complete_event+0xc0>)
 801dfb0:	8810      	ldrh	r0, [r2, #0]
 801dfb2:	78f9      	ldrb	r1, [r7, #3]
 801dfb4:	6a3a      	ldr	r2, [r7, #32]
 801dfb6:	4798      	blx	r3
#endif /* (BLUE_CORE == BLUENRG_MS) */
  }

}/* end hci_le_connection_complete_event() */
 801dfb8:	bf00      	nop
 801dfba:	3710      	adds	r7, #16
 801dfbc:	46bd      	mov	sp, r7
 801dfbe:	bdb0      	pop	{r4, r5, r7, pc}
 801dfc0:	20001dac 	.word	0x20001dac
 801dfc4:	08029cc4 	.word	0x08029cc4
 801dfc8:	20001b0c 	.word	0x20001b0c
 801dfcc:	08029ce8 	.word	0x08029ce8
 801dfd0:	20001b44 	.word	0x20001b44

0801dfd4 <hci_disconnection_complete_event>:
  * Return         : See file bluenrg1_events.h
  *******************************************************************************/
void hci_disconnection_complete_event(uint8_t Status,
                                      uint16_t Connection_Handle,
                                      uint8_t Reason)
{
 801dfd4:	b580      	push	{r7, lr}
 801dfd6:	b082      	sub	sp, #8
 801dfd8:	af00      	add	r7, sp, #0
 801dfda:	4603      	mov	r3, r0
 801dfdc:	71fb      	strb	r3, [r7, #7]
 801dfde:	460b      	mov	r3, r1
 801dfe0:	80bb      	strh	r3, [r7, #4]
 801dfe2:	4613      	mov	r3, r2
 801dfe4:	71bb      	strb	r3, [r7, #6]
  /* No Device Connected */
  connection_handle = 0;
 801dfe6:	4b0d      	ldr	r3, [pc, #52]	@ (801e01c <hci_disconnection_complete_event+0x48>)
 801dfe8:	2200      	movs	r2, #0
 801dfea:	801a      	strh	r2, [r3, #0]
  
  /* Reset the BLE Parse State */
  TotLenBLEParse = 0;
 801dfec:	4b0c      	ldr	r3, [pc, #48]	@ (801e020 <hci_disconnection_complete_event+0x4c>)
 801dfee:	2200      	movs	r2, #0
 801dff0:	601a      	str	r2, [r3, #0]
  StatusBLEParse = BLE_COMM_TP_WAIT_START;
 801dff2:	4b0c      	ldr	r3, [pc, #48]	@ (801e024 <hci_disconnection_complete_event+0x50>)
 801dff4:	2200      	movs	r2, #0
 801dff6:	701a      	strb	r2, [r3, #0]

  BLE_MANAGER_PRINTF("<<<<<<DISCONNECTED\r\n");
 801dff8:	480b      	ldr	r0, [pc, #44]	@ (801e028 <hci_disconnection_complete_event+0x54>)
 801dffa:	f005 ff17 	bl	8023e2c <puts>

  /* Make the device connectable again. */
  set_connectable = TRUE;
 801dffe:	4b0b      	ldr	r3, [pc, #44]	@ (801e02c <hci_disconnection_complete_event+0x58>)
 801e000:	2201      	movs	r2, #1
 801e002:	701a      	strb	r2, [r3, #0]

  if (CustomDisconnectionCompleted != NULL)
 801e004:	4b0a      	ldr	r3, [pc, #40]	@ (801e030 <hci_disconnection_complete_event+0x5c>)
 801e006:	681b      	ldr	r3, [r3, #0]
 801e008:	2b00      	cmp	r3, #0
 801e00a:	d002      	beq.n	801e012 <hci_disconnection_complete_event+0x3e>
  {
    CustomDisconnectionCompleted();
 801e00c:	4b08      	ldr	r3, [pc, #32]	@ (801e030 <hci_disconnection_complete_event+0x5c>)
 801e00e:	681b      	ldr	r3, [r3, #0]
 801e010:	4798      	blx	r3
  }

}/* end hci_disconnection_complete_event() */
 801e012:	bf00      	nop
 801e014:	3708      	adds	r7, #8
 801e016:	46bd      	mov	sp, r7
 801e018:	bd80      	pop	{r7, pc}
 801e01a:	bf00      	nop
 801e01c:	20001dac 	.word	0x20001dac
 801e020:	20001e8c 	.word	0x20001e8c
 801e024:	20001e90 	.word	0x20001e90
 801e028:	08029d14 	.word	0x08029d14
 801e02c:	20001b09 	.word	0x20001b09
 801e030:	20001b48 	.word	0x20001b48

0801e034 <aci_gatt_srv_authorize_nwk_event>:
                                      uint16_t Attr_Handle,
                                      uint8_t Operation_Type,
                                      uint16_t Attr_Val_Offset,
                                      uint8_t Data_Length,
                                      uint8_t Data[])
{
 801e034:	b5b0      	push	{r4, r5, r7, lr}
 801e036:	b088      	sub	sp, #32
 801e038:	af04      	add	r7, sp, #16
 801e03a:	4604      	mov	r4, r0
 801e03c:	4608      	mov	r0, r1
 801e03e:	4611      	mov	r1, r2
 801e040:	461a      	mov	r2, r3
 801e042:	4623      	mov	r3, r4
 801e044:	80fb      	strh	r3, [r7, #6]
 801e046:	4603      	mov	r3, r0
 801e048:	80bb      	strh	r3, [r7, #4]
 801e04a:	460b      	mov	r3, r1
 801e04c:	70fb      	strb	r3, [r7, #3]
 801e04e:	4613      	mov	r3, r2
 801e050:	803b      	strh	r3, [r7, #0]
  if (Operation_Type == 0) /* Read */
 801e052:	78fb      	ldrb	r3, [r7, #3]
 801e054:	2b00      	cmp	r3, #0
 801e056:	d134      	bne.n	801e0c2 <aci_gatt_srv_authorize_nwk_event+0x8e>
  {
    uint32_t FoundHandle = 0;
 801e058:	2300      	movs	r3, #0
 801e05a:	60bb      	str	r3, [r7, #8]
    uint8_t RegisteredHandle;

    /* Search inside all the registered handles */
    for (RegisteredHandle = 0; ((RegisteredHandle < UsedBleChars) && (FoundHandle == 0U)); RegisteredHandle++)
 801e05c:	2300      	movs	r3, #0
 801e05e:	73fb      	strb	r3, [r7, #15]
 801e060:	e027      	b.n	801e0b2 <aci_gatt_srv_authorize_nwk_event+0x7e>
    {
      if (BleCharsArray[RegisteredHandle]->Read_Request_CB != NULL)
 801e062:	7bfb      	ldrb	r3, [r7, #15]
 801e064:	4a19      	ldr	r2, [pc, #100]	@ (801e0cc <aci_gatt_srv_authorize_nwk_event+0x98>)
 801e066:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801e06a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801e06c:	2b00      	cmp	r3, #0
 801e06e:	d01d      	beq.n	801e0ac <aci_gatt_srv_authorize_nwk_event+0x78>
      {
        if (Attr_Handle == (BleCharsArray[RegisteredHandle]->attr_handle + 1U))
 801e070:	88ba      	ldrh	r2, [r7, #4]
 801e072:	7bfb      	ldrb	r3, [r7, #15]
 801e074:	4915      	ldr	r1, [pc, #84]	@ (801e0cc <aci_gatt_srv_authorize_nwk_event+0x98>)
 801e076:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801e07a:	8b5b      	ldrh	r3, [r3, #26]
 801e07c:	3301      	adds	r3, #1
 801e07e:	429a      	cmp	r2, r3
 801e080:	d114      	bne.n	801e0ac <aci_gatt_srv_authorize_nwk_event+0x78>
        {
          BleCharsArray[RegisteredHandle]->Read_Request_CB(BleCharsArray[RegisteredHandle],
 801e082:	7bfb      	ldrb	r3, [r7, #15]
 801e084:	4a11      	ldr	r2, [pc, #68]	@ (801e0cc <aci_gatt_srv_authorize_nwk_event+0x98>)
 801e086:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801e08a:	6a5c      	ldr	r4, [r3, #36]	@ 0x24
 801e08c:	7bfb      	ldrb	r3, [r7, #15]
 801e08e:	4a0f      	ldr	r2, [pc, #60]	@ (801e0cc <aci_gatt_srv_authorize_nwk_event+0x98>)
 801e090:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 801e094:	78fd      	ldrb	r5, [r7, #3]
 801e096:	88fa      	ldrh	r2, [r7, #6]
 801e098:	88b9      	ldrh	r1, [r7, #4]
 801e09a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801e09c:	9302      	str	r3, [sp, #8]
 801e09e:	f897 3020 	ldrb.w	r3, [r7, #32]
 801e0a2:	9301      	str	r3, [sp, #4]
 801e0a4:	883b      	ldrh	r3, [r7, #0]
 801e0a6:	9300      	str	r3, [sp, #0]
 801e0a8:	462b      	mov	r3, r5
 801e0aa:	47a0      	blx	r4
    for (RegisteredHandle = 0; ((RegisteredHandle < UsedBleChars) && (FoundHandle == 0U)); RegisteredHandle++)
 801e0ac:	7bfb      	ldrb	r3, [r7, #15]
 801e0ae:	3301      	adds	r3, #1
 801e0b0:	73fb      	strb	r3, [r7, #15]
 801e0b2:	4b07      	ldr	r3, [pc, #28]	@ (801e0d0 <aci_gatt_srv_authorize_nwk_event+0x9c>)
 801e0b4:	781b      	ldrb	r3, [r3, #0]
 801e0b6:	7bfa      	ldrb	r2, [r7, #15]
 801e0b8:	429a      	cmp	r2, r3
 801e0ba:	d202      	bcs.n	801e0c2 <aci_gatt_srv_authorize_nwk_event+0x8e>
 801e0bc:	68bb      	ldr	r3, [r7, #8]
 801e0be:	2b00      	cmp	r3, #0
 801e0c0:	d0cf      	beq.n	801e062 <aci_gatt_srv_authorize_nwk_event+0x2e>
                                                           Data_Length, Data);
        }
      }
    }
  }
}
 801e0c2:	bf00      	nop
 801e0c4:	3710      	adds	r7, #16
 801e0c6:	46bd      	mov	sp, r7
 801e0c8:	bdb0      	pop	{r4, r5, r7, pc}
 801e0ca:	bf00      	nop
 801e0cc:	20001e08 	.word	0x20001e08
 801e0d0:	20001e88 	.word	0x20001e88

0801e0d4 <aci_gatt_attribute_modified_event>:
void aci_gatt_attribute_modified_event(uint16_t Connection_Handle,
                                       uint16_t Attr_Handle,
                                       uint16_t Offset,
                                       uint16_t Attr_Data_Length,
                                       uint8_t Attr_Data[])
{
 801e0d4:	b5b0      	push	{r4, r5, r7, lr}
 801e0d6:	b088      	sub	sp, #32
 801e0d8:	af02      	add	r7, sp, #8
 801e0da:	4604      	mov	r4, r0
 801e0dc:	4608      	mov	r0, r1
 801e0de:	4611      	mov	r1, r2
 801e0e0:	461a      	mov	r2, r3
 801e0e2:	4623      	mov	r3, r4
 801e0e4:	80fb      	strh	r3, [r7, #6]
 801e0e6:	4603      	mov	r3, r0
 801e0e8:	80bb      	strh	r3, [r7, #4]
 801e0ea:	460b      	mov	r3, r1
 801e0ec:	807b      	strh	r3, [r7, #2]
 801e0ee:	4613      	mov	r3, r2
 801e0f0:	803b      	strh	r3, [r7, #0]
  uint32_t FoundHandle = 0;
 801e0f2:	2300      	movs	r3, #0
 801e0f4:	617b      	str	r3, [r7, #20]
  uint8_t RegisteredHandle;

  if (Attr_Handle == ((uint16_t)(0x0002 + 2)))
 801e0f6:	88bb      	ldrh	r3, [r7, #4]
 801e0f8:	2b04      	cmp	r3, #4
 801e0fa:	d127      	bne.n	801e14c <aci_gatt_attribute_modified_event+0x78>
  {
    BLE_MANAGER_PRINTF("Notification on Service Change Characteristic\r\n");
 801e0fc:	484e      	ldr	r0, [pc, #312]	@ (801e238 <aci_gatt_attribute_modified_event+0x164>)
 801e0fe:	f005 fe95 	bl	8023e2c <puts>
    FoundHandle = 1;
 801e102:	2301      	movs	r3, #1
 801e104:	617b      	str	r3, [r7, #20]
    if (BLE_StackValue.ForceRescan)
 801e106:	4b4d      	ldr	r3, [pc, #308]	@ (801e23c <aci_gatt_attribute_modified_event+0x168>)
 801e108:	7f5b      	ldrb	r3, [r3, #29]
 801e10a:	2b00      	cmp	r3, #0
 801e10c:	d01e      	beq.n	801e14c <aci_gatt_attribute_modified_event+0x78>
    {
      /* Force one UUID rescan */
      tBleStatus ret = BLE_STATUS_INSUFFICIENT_RESOURCES;
 801e10e:	2388      	movs	r3, #136	@ 0x88
 801e110:	74bb      	strb	r3, [r7, #18]
      uint8_t buff[4];

      /* Delete all the Handles from 0x0001 to 0xFFFF */
      STORE_LE_16(buff, 0x0001U);
 801e112:	2301      	movs	r3, #1
 801e114:	733b      	strb	r3, [r7, #12]
 801e116:	2300      	movs	r3, #0
 801e118:	737b      	strb	r3, [r7, #13]
      STORE_LE_16(buff + 2, 0xFFFFU);
 801e11a:	23ff      	movs	r3, #255	@ 0xff
 801e11c:	73bb      	strb	r3, [r7, #14]
 801e11e:	23ff      	movs	r3, #255	@ 0xff
 801e120:	73fb      	strb	r3, [r7, #15]

#if (BLUE_CORE != BLUENRG_LP)
      ret = aci_gatt_update_char_value(0x0001, 0x0002, 0, 4, buff);
#else /* (BLUE_CORE != BLUENRG_LP) */
      ret = aci_gatt_srv_notify(Connection_Handle, 0x0002 + 1, GATT_INDICATION, 4, buff);
 801e122:	88f8      	ldrh	r0, [r7, #6]
 801e124:	f107 030c 	add.w	r3, r7, #12
 801e128:	9300      	str	r3, [sp, #0]
 801e12a:	2304      	movs	r3, #4
 801e12c:	2202      	movs	r2, #2
 801e12e:	2103      	movs	r1, #3
 801e130:	f7fb f8f7 	bl	8019322 <aci_gatt_srv_notify>
 801e134:	4603      	mov	r3, r0
 801e136:	74bb      	strb	r3, [r7, #18]
#endif /* (BLUE_CORE != BLUENRG_LP) */

      if (ret == (tBleStatus)BLE_STATUS_SUCCESS)
 801e138:	7cbb      	ldrb	r3, [r7, #18]
 801e13a:	2b00      	cmp	r3, #0
 801e13c:	d103      	bne.n	801e146 <aci_gatt_attribute_modified_event+0x72>
      {
        BLE_MANAGER_PRINTF("\r\nUUID Rescan Forced\r\n");
 801e13e:	4840      	ldr	r0, [pc, #256]	@ (801e240 <aci_gatt_attribute_modified_event+0x16c>)
 801e140:	f005 fe74 	bl	8023e2c <puts>
 801e144:	e002      	b.n	801e14c <aci_gatt_attribute_modified_event+0x78>
      }
      else
      {
        BLE_MANAGER_PRINTF("\r\nError: Problem forcing UUID Rescan\r\n");
 801e146:	483f      	ldr	r0, [pc, #252]	@ (801e244 <aci_gatt_attribute_modified_event+0x170>)
 801e148:	f005 fe70 	bl	8023e2c <puts>
      }
    }
  }

  /* Search inside all the registered handles */
  for (RegisteredHandle = 0; ((RegisteredHandle < UsedBleChars) && (FoundHandle == 0U)); RegisteredHandle++)
 801e14c:	2300      	movs	r3, #0
 801e14e:	74fb      	strb	r3, [r7, #19]
 801e150:	e04b      	b.n	801e1ea <aci_gatt_attribute_modified_event+0x116>
  {
    /* Notification */
    if (BleCharsArray[RegisteredHandle]->AttrMod_Request_CB != NULL)
 801e152:	7cfb      	ldrb	r3, [r7, #19]
 801e154:	4a3c      	ldr	r2, [pc, #240]	@ (801e248 <aci_gatt_attribute_modified_event+0x174>)
 801e156:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801e15a:	6a1b      	ldr	r3, [r3, #32]
 801e15c:	2b00      	cmp	r3, #0
 801e15e:	d01b      	beq.n	801e198 <aci_gatt_attribute_modified_event+0xc4>
    {
      if (Attr_Handle == (BleCharsArray[RegisteredHandle]->attr_handle + 2U))
 801e160:	88ba      	ldrh	r2, [r7, #4]
 801e162:	7cfb      	ldrb	r3, [r7, #19]
 801e164:	4938      	ldr	r1, [pc, #224]	@ (801e248 <aci_gatt_attribute_modified_event+0x174>)
 801e166:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801e16a:	8b5b      	ldrh	r3, [r3, #26]
 801e16c:	3302      	adds	r3, #2
 801e16e:	429a      	cmp	r2, r3
 801e170:	d112      	bne.n	801e198 <aci_gatt_attribute_modified_event+0xc4>
      {
        FoundHandle = 1U;
 801e172:	2301      	movs	r3, #1
 801e174:	617b      	str	r3, [r7, #20]
        BleCharsArray[RegisteredHandle]->AttrMod_Request_CB(BleCharsArray[RegisteredHandle], Attr_Handle, Offset,
 801e176:	7cfb      	ldrb	r3, [r7, #19]
 801e178:	4a33      	ldr	r2, [pc, #204]	@ (801e248 <aci_gatt_attribute_modified_event+0x174>)
 801e17a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801e17e:	6a1c      	ldr	r4, [r3, #32]
 801e180:	7cfb      	ldrb	r3, [r7, #19]
 801e182:	4a31      	ldr	r2, [pc, #196]	@ (801e248 <aci_gatt_attribute_modified_event+0x174>)
 801e184:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 801e188:	883b      	ldrh	r3, [r7, #0]
 801e18a:	b2dd      	uxtb	r5, r3
 801e18c:	887a      	ldrh	r2, [r7, #2]
 801e18e:	88b9      	ldrh	r1, [r7, #4]
 801e190:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801e192:	9300      	str	r3, [sp, #0]
 801e194:	462b      	mov	r3, r5
 801e196:	47a0      	blx	r4
                                                            Attr_Data_Length, Attr_Data);
      }
    }

    /* Write */
    if (FoundHandle == 0U)
 801e198:	697b      	ldr	r3, [r7, #20]
 801e19a:	2b00      	cmp	r3, #0
 801e19c:	d122      	bne.n	801e1e4 <aci_gatt_attribute_modified_event+0x110>
    {
      if (BleCharsArray[RegisteredHandle]->Write_Request_CB != NULL)
 801e19e:	7cfb      	ldrb	r3, [r7, #19]
 801e1a0:	4a29      	ldr	r2, [pc, #164]	@ (801e248 <aci_gatt_attribute_modified_event+0x174>)
 801e1a2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801e1a6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 801e1a8:	2b00      	cmp	r3, #0
 801e1aa:	d01b      	beq.n	801e1e4 <aci_gatt_attribute_modified_event+0x110>
      {
        if (Attr_Handle == (BleCharsArray[RegisteredHandle]->attr_handle + 1U))
 801e1ac:	88ba      	ldrh	r2, [r7, #4]
 801e1ae:	7cfb      	ldrb	r3, [r7, #19]
 801e1b0:	4925      	ldr	r1, [pc, #148]	@ (801e248 <aci_gatt_attribute_modified_event+0x174>)
 801e1b2:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801e1b6:	8b5b      	ldrh	r3, [r3, #26]
 801e1b8:	3301      	adds	r3, #1
 801e1ba:	429a      	cmp	r2, r3
 801e1bc:	d112      	bne.n	801e1e4 <aci_gatt_attribute_modified_event+0x110>
        {
          FoundHandle = 1U;
 801e1be:	2301      	movs	r3, #1
 801e1c0:	617b      	str	r3, [r7, #20]
          BleCharsArray[RegisteredHandle]->Write_Request_CB(BleCharsArray[RegisteredHandle], Attr_Handle, Offset,
 801e1c2:	7cfb      	ldrb	r3, [r7, #19]
 801e1c4:	4a20      	ldr	r2, [pc, #128]	@ (801e248 <aci_gatt_attribute_modified_event+0x174>)
 801e1c6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801e1ca:	6a9c      	ldr	r4, [r3, #40]	@ 0x28
 801e1cc:	7cfb      	ldrb	r3, [r7, #19]
 801e1ce:	4a1e      	ldr	r2, [pc, #120]	@ (801e248 <aci_gatt_attribute_modified_event+0x174>)
 801e1d0:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 801e1d4:	883b      	ldrh	r3, [r7, #0]
 801e1d6:	b2dd      	uxtb	r5, r3
 801e1d8:	887a      	ldrh	r2, [r7, #2]
 801e1da:	88b9      	ldrh	r1, [r7, #4]
 801e1dc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801e1de:	9300      	str	r3, [sp, #0]
 801e1e0:	462b      	mov	r3, r5
 801e1e2:	47a0      	blx	r4
  for (RegisteredHandle = 0; ((RegisteredHandle < UsedBleChars) && (FoundHandle == 0U)); RegisteredHandle++)
 801e1e4:	7cfb      	ldrb	r3, [r7, #19]
 801e1e6:	3301      	adds	r3, #1
 801e1e8:	74fb      	strb	r3, [r7, #19]
 801e1ea:	4b18      	ldr	r3, [pc, #96]	@ (801e24c <aci_gatt_attribute_modified_event+0x178>)
 801e1ec:	781b      	ldrb	r3, [r3, #0]
 801e1ee:	7cfa      	ldrb	r2, [r7, #19]
 801e1f0:	429a      	cmp	r2, r3
 801e1f2:	d202      	bcs.n	801e1fa <aci_gatt_attribute_modified_event+0x126>
 801e1f4:	697b      	ldr	r3, [r7, #20]
 801e1f6:	2b00      	cmp	r3, #0
 801e1f8:	d0ab      	beq.n	801e152 <aci_gatt_attribute_modified_event+0x7e>
        }
      }
    }
  }

  if (FoundHandle == 0U)
 801e1fa:	697b      	ldr	r3, [r7, #20]
 801e1fc:	2b00      	cmp	r3, #0
 801e1fe:	d117      	bne.n	801e230 <aci_gatt_attribute_modified_event+0x15c>
  {
    if (BLE_StdErr_Service == BLE_SERV_ENABLE)
 801e200:	4b13      	ldr	r3, [pc, #76]	@ (801e250 <aci_gatt_attribute_modified_event+0x17c>)
 801e202:	781b      	ldrb	r3, [r3, #0]
 801e204:	2b01      	cmp	r3, #1
 801e206:	d10e      	bne.n	801e226 <aci_gatt_attribute_modified_event+0x152>
    {
      BytesToWrite = (uint8_t)sprintf((char *)BufferToWrite, "Notification UNKNOWN handle\n");
 801e208:	4912      	ldr	r1, [pc, #72]	@ (801e254 <aci_gatt_attribute_modified_event+0x180>)
 801e20a:	4813      	ldr	r0, [pc, #76]	@ (801e258 <aci_gatt_attribute_modified_event+0x184>)
 801e20c:	f005 fe16 	bl	8023e3c <siprintf>
 801e210:	4603      	mov	r3, r0
 801e212:	b2da      	uxtb	r2, r3
 801e214:	4b11      	ldr	r3, [pc, #68]	@ (801e25c <aci_gatt_attribute_modified_event+0x188>)
 801e216:	701a      	strb	r2, [r3, #0]
      Stderr_Update(BufferToWrite, BytesToWrite);
 801e218:	4b10      	ldr	r3, [pc, #64]	@ (801e25c <aci_gatt_attribute_modified_event+0x188>)
 801e21a:	781b      	ldrb	r3, [r3, #0]
 801e21c:	4619      	mov	r1, r3
 801e21e:	480e      	ldr	r0, [pc, #56]	@ (801e258 <aci_gatt_attribute_modified_event+0x184>)
 801e220:	f7ff fb92 	bl	801d948 <Stderr_Update>
    else
    {
      BLE_MANAGER_PRINTF("Notification UNKNOWN handle =%d\r\n", Attr_Handle);
    }
  }
}
 801e224:	e004      	b.n	801e230 <aci_gatt_attribute_modified_event+0x15c>
      BLE_MANAGER_PRINTF("Notification UNKNOWN handle =%d\r\n", Attr_Handle);
 801e226:	88bb      	ldrh	r3, [r7, #4]
 801e228:	4619      	mov	r1, r3
 801e22a:	480d      	ldr	r0, [pc, #52]	@ (801e260 <aci_gatt_attribute_modified_event+0x18c>)
 801e22c:	f005 fd96 	bl	8023d5c <iprintf>
}
 801e230:	bf00      	nop
 801e232:	3718      	adds	r7, #24
 801e234:	46bd      	mov	sp, r7
 801e236:	bdb0      	pop	{r4, r5, r7, pc}
 801e238:	08029d28 	.word	0x08029d28
 801e23c:	20001b0c 	.word	0x20001b0c
 801e240:	08029d58 	.word	0x08029d58
 801e244:	08029d70 	.word	0x08029d70
 801e248:	20001e08 	.word	0x20001e08
 801e24c:	20001e88 	.word	0x20001e88
 801e250:	20001a06 	.word	0x20001a06
 801e254:	08029d98 	.word	0x08029d98
 801e258:	20001a08 	.word	0x20001a08
 801e25c:	20001b08 	.word	0x20001b08
 801e260:	08029db8 	.word	0x08029db8

0801e264 <hci_le_enhanced_connection_complete_event>:
                                               uint8_t Peer_Resolvable_Private_Address[6],
                                               uint16_t Conn_Interval,
                                               uint16_t Conn_Latency,
                                               uint16_t Supervision_Timeout,
                                               uint8_t Master_Clock_Accuracy)
{
 801e264:	b590      	push	{r4, r7, lr}
 801e266:	b089      	sub	sp, #36	@ 0x24
 801e268:	af06      	add	r7, sp, #24
 801e26a:	4604      	mov	r4, r0
 801e26c:	4608      	mov	r0, r1
 801e26e:	4611      	mov	r1, r2
 801e270:	461a      	mov	r2, r3
 801e272:	4623      	mov	r3, r4
 801e274:	71fb      	strb	r3, [r7, #7]
 801e276:	4603      	mov	r3, r0
 801e278:	80bb      	strh	r3, [r7, #4]
 801e27a:	460b      	mov	r3, r1
 801e27c:	71bb      	strb	r3, [r7, #6]
 801e27e:	4613      	mov	r3, r2
 801e280:	70fb      	strb	r3, [r7, #3]

  hci_le_connection_complete_event(Status,
 801e282:	78fc      	ldrb	r4, [r7, #3]
 801e284:	79ba      	ldrb	r2, [r7, #6]
 801e286:	88b9      	ldrh	r1, [r7, #4]
 801e288:	79f8      	ldrb	r0, [r7, #7]
 801e28a:	f897 3030 	ldrb.w	r3, [r7, #48]	@ 0x30
 801e28e:	9304      	str	r3, [sp, #16]
 801e290:	8dbb      	ldrh	r3, [r7, #44]	@ 0x2c
 801e292:	9303      	str	r3, [sp, #12]
 801e294:	8d3b      	ldrh	r3, [r7, #40]	@ 0x28
 801e296:	9302      	str	r3, [sp, #8]
 801e298:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 801e29a:	9301      	str	r3, [sp, #4]
 801e29c:	69bb      	ldr	r3, [r7, #24]
 801e29e:	9300      	str	r3, [sp, #0]
 801e2a0:	4623      	mov	r3, r4
 801e2a2:	f7ff fe2d 	bl	801df00 <hci_le_connection_complete_event>
                                   Peer_Address,
                                   Conn_Interval,
                                   Conn_Latency,
                                   Supervision_Timeout,
                                   Master_Clock_Accuracy);
}
 801e2a6:	bf00      	nop
 801e2a8:	370c      	adds	r7, #12
 801e2aa:	46bd      	mov	sp, r7
 801e2ac:	bd90      	pop	{r4, r7, pc}

0801e2ae <aci_gatt_srv_attribute_modified_event>:
  */
void aci_gatt_srv_attribute_modified_event(uint16_t Connection_Handle,
                                           uint16_t Attr_Handle,
                                           uint16_t Attr_Data_Length,
                                           uint8_t Attr_Data[])
{
 801e2ae:	b580      	push	{r7, lr}
 801e2b0:	b086      	sub	sp, #24
 801e2b2:	af02      	add	r7, sp, #8
 801e2b4:	607b      	str	r3, [r7, #4]
 801e2b6:	4603      	mov	r3, r0
 801e2b8:	81fb      	strh	r3, [r7, #14]
 801e2ba:	460b      	mov	r3, r1
 801e2bc:	81bb      	strh	r3, [r7, #12]
 801e2be:	4613      	mov	r3, r2
 801e2c0:	817b      	strh	r3, [r7, #10]
  aci_gatt_attribute_modified_event(Connection_Handle,
 801e2c2:	897a      	ldrh	r2, [r7, #10]
 801e2c4:	89b9      	ldrh	r1, [r7, #12]
 801e2c6:	89f8      	ldrh	r0, [r7, #14]
 801e2c8:	687b      	ldr	r3, [r7, #4]
 801e2ca:	9300      	str	r3, [sp, #0]
 801e2cc:	4613      	mov	r3, r2
 801e2ce:	2200      	movs	r2, #0
 801e2d0:	f7ff ff00 	bl	801e0d4 <aci_gatt_attribute_modified_event>
                                    Attr_Handle,
                                    0,
                                    Attr_Data_Length,
                                    Attr_Data);
}
 801e2d4:	bf00      	nop
 801e2d6:	3710      	adds	r7, #16
 801e2d8:	46bd      	mov	sp, r7
 801e2da:	bd80      	pop	{r7, pc}

0801e2dc <aci_att_exchange_mtu_resp_event>:
  * Output         : See file bluenrg1_events.h
  * Return         : See file bluenrg1_events.h
  *******************************************************************************/
void aci_att_exchange_mtu_resp_event(uint16_t Connection_Handle,
                                     uint16_t Server_RX_MTU)
{
 801e2dc:	b580      	push	{r7, lr}
 801e2de:	b082      	sub	sp, #8
 801e2e0:	af00      	add	r7, sp, #0
 801e2e2:	4603      	mov	r3, r0
 801e2e4:	460a      	mov	r2, r1
 801e2e6:	80fb      	strh	r3, [r7, #6]
 801e2e8:	4613      	mov	r3, r2
 801e2ea:	80bb      	strh	r3, [r7, #4]
  if ((Server_RX_MTU - 3U) < MaxBleCharStdOutLen)
 801e2ec:	88bb      	ldrh	r3, [r7, #4]
 801e2ee:	3b03      	subs	r3, #3
 801e2f0:	4a11      	ldr	r2, [pc, #68]	@ (801e338 <aci_att_exchange_mtu_resp_event+0x5c>)
 801e2f2:	7812      	ldrb	r2, [r2, #0]
 801e2f4:	4293      	cmp	r3, r2
 801e2f6:	d205      	bcs.n	801e304 <aci_att_exchange_mtu_resp_event+0x28>
  {
    MaxBleCharStdOutLen = (uint8_t)(Server_RX_MTU - 3U);
 801e2f8:	88bb      	ldrh	r3, [r7, #4]
 801e2fa:	b2db      	uxtb	r3, r3
 801e2fc:	3b03      	subs	r3, #3
 801e2fe:	b2da      	uxtb	r2, r3
 801e300:	4b0d      	ldr	r3, [pc, #52]	@ (801e338 <aci_att_exchange_mtu_resp_event+0x5c>)
 801e302:	701a      	strb	r2, [r3, #0]
  }

  if ((Server_RX_MTU - 3U) < MaxBleCharStdErrLen)
 801e304:	88bb      	ldrh	r3, [r7, #4]
 801e306:	3b03      	subs	r3, #3
 801e308:	4a0c      	ldr	r2, [pc, #48]	@ (801e33c <aci_att_exchange_mtu_resp_event+0x60>)
 801e30a:	7812      	ldrb	r2, [r2, #0]
 801e30c:	4293      	cmp	r3, r2
 801e30e:	d205      	bcs.n	801e31c <aci_att_exchange_mtu_resp_event+0x40>
  {
    MaxBleCharStdErrLen = (uint8_t)(Server_RX_MTU - 3U);
 801e310:	88bb      	ldrh	r3, [r7, #4]
 801e312:	b2db      	uxtb	r3, r3
 801e314:	3b03      	subs	r3, #3
 801e316:	b2da      	uxtb	r2, r3
 801e318:	4b08      	ldr	r3, [pc, #32]	@ (801e33c <aci_att_exchange_mtu_resp_event+0x60>)
 801e31a:	701a      	strb	r2, [r3, #0]

#if (BLE_DEBUG_LEVEL>2)
  BLE_MANAGER_PRINTF("aci_att_exchange_mtu_resp_event Server_RX_MTU=%d\r\n", Server_RX_MTU);
#endif /* (BLE_DEBUG_LEVEL>2) */

  if (CustomMTUExchangeRespEvent != NULL)
 801e31c:	4b08      	ldr	r3, [pc, #32]	@ (801e340 <aci_att_exchange_mtu_resp_event+0x64>)
 801e31e:	681b      	ldr	r3, [r3, #0]
 801e320:	2b00      	cmp	r3, #0
 801e322:	d005      	beq.n	801e330 <aci_att_exchange_mtu_resp_event+0x54>
  {
    CustomMTUExchangeRespEvent(Server_RX_MTU - 3U);
 801e324:	4b06      	ldr	r3, [pc, #24]	@ (801e340 <aci_att_exchange_mtu_resp_event+0x64>)
 801e326:	681b      	ldr	r3, [r3, #0]
 801e328:	88ba      	ldrh	r2, [r7, #4]
 801e32a:	3a03      	subs	r2, #3
 801e32c:	4610      	mov	r0, r2
 801e32e:	4798      	blx	r3
  }
}
 801e330:	bf00      	nop
 801e332:	3708      	adds	r7, #8
 801e334:	46bd      	mov	sp, r7
 801e336:	bd80      	pop	{r7, pc}
 801e338:	20001dae 	.word	0x20001dae
 801e33c:	20001daf 	.word	0x20001daf
 801e340:	20001b3c 	.word	0x20001b3c

0801e344 <aci_gap_pass_key_req_event>:

void aci_gap_pass_key_req_event(uint16_t Connection_Handle)
{
 801e344:	b580      	push	{r7, lr}
 801e346:	b084      	sub	sp, #16
 801e348:	af00      	add	r7, sp, #0
 801e34a:	4603      	mov	r3, r0
 801e34c:	80fb      	strh	r3, [r7, #6]
  tBleStatus status;
#if (BLE_DEBUG_LEVEL>2)
  BLE_MANAGER_PRINTF("aci_gap_pass_key_req_event [Requested PassWd=%ld]\r\n", BLE_StackValue.SecurePIN);
#endif /* (BLE_DEBUG_LEVEL>2) */
  status = aci_gap_pass_key_resp(connection_handle, BLE_StackValue.SecurePIN);
 801e34e:	4b0b      	ldr	r3, [pc, #44]	@ (801e37c <aci_gap_pass_key_req_event+0x38>)
 801e350:	881b      	ldrh	r3, [r3, #0]
 801e352:	4a0b      	ldr	r2, [pc, #44]	@ (801e380 <aci_gap_pass_key_req_event+0x3c>)
 801e354:	6992      	ldr	r2, [r2, #24]
 801e356:	4611      	mov	r1, r2
 801e358:	4618      	mov	r0, r3
 801e35a:	f7fa f9ef 	bl	801873c <aci_gap_pass_key_resp>
 801e35e:	4603      	mov	r3, r0
 801e360:	73fb      	strb	r3, [r7, #15]
  if (status != (uint8_t)BLE_STATUS_SUCCESS)
 801e362:	7bfb      	ldrb	r3, [r7, #15]
 801e364:	2b00      	cmp	r3, #0
 801e366:	d004      	beq.n	801e372 <aci_gap_pass_key_req_event+0x2e>
  {
    BLE_MANAGER_PRINTF("Error: aci_gap_pass_key_resp failed:0x%02x\r\n", status);
 801e368:	7bfb      	ldrb	r3, [r7, #15]
 801e36a:	4619      	mov	r1, r3
 801e36c:	4805      	ldr	r0, [pc, #20]	@ (801e384 <aci_gap_pass_key_req_event+0x40>)
 801e36e:	f005 fcf5 	bl	8023d5c <iprintf>
  {
    BLE_MANAGER_PRINTF("aci_gap_pass_key_resp OK\r\n");
#endif /* (BLE_DEBUG_LEVEL>1) */
  }

}
 801e372:	bf00      	nop
 801e374:	3710      	adds	r7, #16
 801e376:	46bd      	mov	sp, r7
 801e378:	bd80      	pop	{r7, pc}
 801e37a:	bf00      	nop
 801e37c:	20001dac 	.word	0x20001dac
 801e380:	20001b0c 	.word	0x20001b0c
 801e384:	08029ddc 	.word	0x08029ddc

0801e388 <aci_gap_pairing_complete_event>:
  *         timeout has occurred so that the upper layer can decide to disconnect the link.
  * @param  See file bluenrg_lp_events.h
  * @retval See file bluenrg_lp_events.h
  */
void aci_gap_pairing_complete_event(uint16_t ConnectionHandle, uint8_t status, uint8_t reason)
{
 801e388:	b5b0      	push	{r4, r5, r7, lr}
 801e38a:	b096      	sub	sp, #88	@ 0x58
 801e38c:	af00      	add	r7, sp, #0
 801e38e:	4603      	mov	r3, r0
 801e390:	80fb      	strh	r3, [r7, #6]
 801e392:	460b      	mov	r3, r1
 801e394:	717b      	strb	r3, [r7, #5]
 801e396:	4613      	mov	r3, r2
 801e398:	713b      	strb	r3, [r7, #4]
  char *StatusString[] =
 801e39a:	4b34      	ldr	r3, [pc, #208]	@ (801e46c <aci_gap_pairing_complete_event+0xe4>)
 801e39c:	f107 0440 	add.w	r4, r7, #64	@ 0x40
 801e3a0:	461d      	mov	r5, r3
 801e3a2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801e3a4:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801e3a6:	e895 0003 	ldmia.w	r5, {r0, r1}
 801e3aa:	e884 0003 	stmia.w	r4, {r0, r1}
    /* 0x03 */ "Encryption failed, LTK missing on local device",
    /* 0x04 */ "Encryption failed, LTK missing on peer device",
    /* 0x05 */ "Encryption not supported by remote device"
  };

  char *ReasonString[] =
 801e3ae:	4b30      	ldr	r3, [pc, #192]	@ (801e470 <aci_gap_pairing_complete_event+0xe8>)
 801e3b0:	f107 040c 	add.w	r4, r7, #12
 801e3b4:	461d      	mov	r5, r3
 801e3b6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801e3b8:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801e3ba:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801e3bc:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801e3be:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801e3c0:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801e3c2:	682b      	ldr	r3, [r5, #0]
 801e3c4:	6023      	str	r3, [r4, #0]
    /* 0x0A */ "SM_INVALID_PARAMS",
    /* 0x0B */ "SMP_SC_DHKEY_CHECK_FAILED",
    /* 0x0C */ "SMP_SC_NUMCOMPARISON_FAILED"
  };

  switch (status)
 801e3c6:	797b      	ldrb	r3, [r7, #5]
 801e3c8:	2b05      	cmp	r3, #5
 801e3ca:	d841      	bhi.n	801e450 <aci_gap_pairing_complete_event+0xc8>
 801e3cc:	a201      	add	r2, pc, #4	@ (adr r2, 801e3d4 <aci_gap_pairing_complete_event+0x4c>)
 801e3ce:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801e3d2:	bf00      	nop
 801e3d4:	0801e3ed 	.word	0x0801e3ed
 801e3d8:	0801e42f 	.word	0x0801e42f
 801e3dc:	0801e40d 	.word	0x0801e40d
 801e3e0:	0801e42f 	.word	0x0801e42f
 801e3e4:	0801e42f 	.word	0x0801e42f
 801e3e8:	0801e42f 	.word	0x0801e42f
  {
    case 0x00: /* Success */
      BLE_MANAGER_PRINTF("aci_gap_pairing_complete_event %s\r\n", StatusString[status]);
 801e3ec:	797b      	ldrb	r3, [r7, #5]
 801e3ee:	009b      	lsls	r3, r3, #2
 801e3f0:	3358      	adds	r3, #88	@ 0x58
 801e3f2:	443b      	add	r3, r7
 801e3f4:	f853 3c18 	ldr.w	r3, [r3, #-24]
 801e3f8:	4619      	mov	r1, r3
 801e3fa:	481e      	ldr	r0, [pc, #120]	@ (801e474 <aci_gap_pairing_complete_event+0xec>)
 801e3fc:	f005 fcae 	bl	8023d5c <iprintf>
#if (BLUE_CORE != BLUENRG_MS)
      UpdateWhiteList();
 801e400:	f000 f956 	bl	801e6b0 <UpdateWhiteList>
#endif /* (BLUE_CORE != BLUENRG_MS) */
      BLE_MANAGER_DELAY(100);
 801e404:	2064      	movs	r0, #100	@ 0x64
 801e406:	f7e6 f9f9 	bl	80047fc <HAL_Delay>
      break;
 801e40a:	e021      	b.n	801e450 <aci_gap_pairing_complete_event+0xc8>
    case 0x02: /* Pairing Failed */
      BLE_MANAGER_PRINTF("aci_gap_pairing_complete_event failed:\r\n\tstatus= %s\r\n\treason= %s\r\n",
 801e40c:	797b      	ldrb	r3, [r7, #5]
 801e40e:	009b      	lsls	r3, r3, #2
 801e410:	3358      	adds	r3, #88	@ 0x58
 801e412:	443b      	add	r3, r7
 801e414:	f853 1c18 	ldr.w	r1, [r3, #-24]
 801e418:	793b      	ldrb	r3, [r7, #4]
 801e41a:	009b      	lsls	r3, r3, #2
 801e41c:	3358      	adds	r3, #88	@ 0x58
 801e41e:	443b      	add	r3, r7
 801e420:	f853 3c4c 	ldr.w	r3, [r3, #-76]
 801e424:	461a      	mov	r2, r3
 801e426:	4814      	ldr	r0, [pc, #80]	@ (801e478 <aci_gap_pairing_complete_event+0xf0>)
 801e428:	f005 fc98 	bl	8023d5c <iprintf>
       0x1A: Unsupported Remote Feature
       0x3B: Unacceptable Connection Parameters
      */
      aci_gap_terminate(ConnectionHandle, 0x05);
#endif /* 0 */
      break;
 801e42c:	e010      	b.n	801e450 <aci_gap_pairing_complete_event+0xc8>
    case 0x01: /* Timeout */
    case 0x03: /* Encryption failed, LTK missing on local device */
    case 0x04: /* Encryption failed, LTK missing on peer device */
    case 0x05: /* Encryption not supported by remote device */
      BLE_MANAGER_PRINTF("aci_gap_pairing_complete_event failed:\r\n\tstatus= %s\r\n\treason= %s\r\n",
 801e42e:	797b      	ldrb	r3, [r7, #5]
 801e430:	009b      	lsls	r3, r3, #2
 801e432:	3358      	adds	r3, #88	@ 0x58
 801e434:	443b      	add	r3, r7
 801e436:	f853 1c18 	ldr.w	r1, [r3, #-24]
 801e43a:	793b      	ldrb	r3, [r7, #4]
 801e43c:	009b      	lsls	r3, r3, #2
 801e43e:	3358      	adds	r3, #88	@ 0x58
 801e440:	443b      	add	r3, r7
 801e442:	f853 3c4c 	ldr.w	r3, [r3, #-76]
 801e446:	461a      	mov	r2, r3
 801e448:	480b      	ldr	r0, [pc, #44]	@ (801e478 <aci_gap_pairing_complete_event+0xf0>)
 801e44a:	f005 fc87 	bl	8023d5c <iprintf>
                         StatusString[status],
                         ReasonString[reason]);
      break;
 801e44e:	bf00      	nop
  }

  UNUSED(StatusString);
  UNUSED(ReasonString);

  if (CustomPairingCompleted != NULL)
 801e450:	4b0a      	ldr	r3, [pc, #40]	@ (801e47c <aci_gap_pairing_complete_event+0xf4>)
 801e452:	681b      	ldr	r3, [r3, #0]
 801e454:	2b00      	cmp	r3, #0
 801e456:	d004      	beq.n	801e462 <aci_gap_pairing_complete_event+0xda>
  {
    CustomPairingCompleted(status);
 801e458:	4b08      	ldr	r3, [pc, #32]	@ (801e47c <aci_gap_pairing_complete_event+0xf4>)
 801e45a:	681b      	ldr	r3, [r3, #0]
 801e45c:	797a      	ldrb	r2, [r7, #5]
 801e45e:	4610      	mov	r0, r2
 801e460:	4798      	blx	r3
  }
}
 801e462:	bf00      	nop
 801e464:	3758      	adds	r7, #88	@ 0x58
 801e466:	46bd      	mov	sp, r7
 801e468:	bdb0      	pop	{r4, r5, r7, pc}
 801e46a:	bf00      	nop
 801e46c:	08029f20 	.word	0x08029f20
 801e470:	0802a058 	.word	0x0802a058
 801e474:	08029e0c 	.word	0x08029e0c
 801e478:	08029e30 	.word	0x08029e30
 801e47c:	20001b38 	.word	0x20001b38

0801e480 <aci_l2cap_connection_update_resp_event>:
  * Output         : See file bluenrg1_events.h
  * Return         : See file bluenrg1_events.h
  *******************************************************************************/
void aci_l2cap_connection_update_resp_event(uint16_t Connection_Handle,
                                            uint16_t Result)
{
 801e480:	b480      	push	{r7}
 801e482:	b083      	sub	sp, #12
 801e484:	af00      	add	r7, sp, #0
 801e486:	4603      	mov	r3, r0
 801e488:	460a      	mov	r2, r1
 801e48a:	80fb      	strh	r3, [r7, #6]
 801e48c:	4613      	mov	r3, r2
 801e48e:	80bb      	strh	r3, [r7, #4]
#if (BLE_DEBUG_LEVEL>2)
  BLE_MANAGER_PRINTF("aci_l2cap_connection_update_resp_event Result=%d\r\n", Result);
#endif /* (BLE_DEBUG_LEVEL>2) */
}
 801e490:	bf00      	nop
 801e492:	370c      	adds	r7, #12
 801e494:	46bd      	mov	sp, r7
 801e496:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e49a:	4770      	bx	lr

0801e49c <hci_le_connection_update_complete_event>:
void hci_le_connection_update_complete_event(uint8_t Status,
                                             uint16_t Connection_Handle,
                                             uint16_t Conn_Interval,
                                             uint16_t Conn_Latency,
                                             uint16_t Supervision_Timeout)
{
 801e49c:	b490      	push	{r4, r7}
 801e49e:	b082      	sub	sp, #8
 801e4a0:	af00      	add	r7, sp, #0
 801e4a2:	4604      	mov	r4, r0
 801e4a4:	4608      	mov	r0, r1
 801e4a6:	4611      	mov	r1, r2
 801e4a8:	461a      	mov	r2, r3
 801e4aa:	4623      	mov	r3, r4
 801e4ac:	71fb      	strb	r3, [r7, #7]
 801e4ae:	4603      	mov	r3, r0
 801e4b0:	80bb      	strh	r3, [r7, #4]
 801e4b2:	460b      	mov	r3, r1
 801e4b4:	807b      	strh	r3, [r7, #2]
 801e4b6:	4613      	mov	r3, r2
 801e4b8:	803b      	strh	r3, [r7, #0]
  BLE_MANAGER_PRINTF("\tStatus=%d\r\n", Status);
  BLE_MANAGER_PRINTF("\tConn_Interval=%d\r\n", Conn_Interval);
  BLE_MANAGER_PRINTF("\tConn_Latency=%d\r\n", Conn_Latency);
  BLE_MANAGER_PRINTF("\tSupervision_Timeout=%d\r\n", Supervision_Timeout);
#endif /* (BLE_DEBUG_LEVEL>2) */
}
 801e4ba:	bf00      	nop
 801e4bc:	3708      	adds	r7, #8
 801e4be:	46bd      	mov	sp, r7
 801e4c0:	bc90      	pop	{r4, r7}
 801e4c2:	4770      	bx	lr

0801e4c4 <hci_le_data_length_change_event>:
void hci_le_data_length_change_event(uint16_t Connection_Handle,
                                     uint16_t MaxTxOctets,
                                     uint16_t MaxTxTime,
                                     uint16_t MaxRxOctets,
                                     uint16_t MaxRxTime)
{
 801e4c4:	b590      	push	{r4, r7, lr}
 801e4c6:	b087      	sub	sp, #28
 801e4c8:	af00      	add	r7, sp, #0
 801e4ca:	4604      	mov	r4, r0
 801e4cc:	4608      	mov	r0, r1
 801e4ce:	4611      	mov	r1, r2
 801e4d0:	461a      	mov	r2, r3
 801e4d2:	4623      	mov	r3, r4
 801e4d4:	80fb      	strh	r3, [r7, #6]
 801e4d6:	4603      	mov	r3, r0
 801e4d8:	80bb      	strh	r3, [r7, #4]
 801e4da:	460b      	mov	r3, r1
 801e4dc:	807b      	strh	r3, [r7, #2]
 801e4de:	4613      	mov	r3, r2
 801e4e0:	803b      	strh	r3, [r7, #0]
#if (BLUE_CORE == BLUENRG_LP)
  tBleStatus RetStatus;
  int32_t MaxRetryNumber=10;
 801e4e2:	230a      	movs	r3, #10
 801e4e4:	613b      	str	r3, [r7, #16]
  int32_t RetryNumber = 0;
 801e4e6:	2300      	movs	r3, #0
 801e4e8:	617b      	str	r3, [r7, #20]
  BLE_MANAGER_PRINTF("hci_le_data_length_change_event\r\n");
#endif /* (BLE_DEBUG_LEVEL>2) */

#if (BLUE_CORE == BLUENRG_LP)
  do {
    BLE_MANAGER_DELAY(200);
 801e4ea:	20c8      	movs	r0, #200	@ 0xc8
 801e4ec:	f7e6 f986 	bl	80047fc <HAL_Delay>
    RetStatus = aci_gatt_clt_exchange_config(Connection_Handle);
 801e4f0:	88fb      	ldrh	r3, [r7, #6]
 801e4f2:	4618      	mov	r0, r3
 801e4f4:	f7fa fe4e 	bl	8019194 <aci_gatt_clt_exchange_config>
 801e4f8:	4603      	mov	r3, r0
 801e4fa:	73fb      	strb	r3, [r7, #15]
    if( RetStatus !=BLE_STATUS_SUCCESS) {
 801e4fc:	7bfb      	ldrb	r3, [r7, #15]
 801e4fe:	2b00      	cmp	r3, #0
 801e500:	d008      	beq.n	801e514 <hci_le_data_length_change_event+0x50>
      BLE_MANAGER_PRINTF("Error: ACI GATT Exchange Config Failed (0x%x)\r\n", RetStatus);
 801e502:	7bfb      	ldrb	r3, [r7, #15]
 801e504:	4619      	mov	r1, r3
 801e506:	4810      	ldr	r0, [pc, #64]	@ (801e548 <hci_le_data_length_change_event+0x84>)
 801e508:	f005 fc28 	bl	8023d5c <iprintf>
      RetryNumber++;
 801e50c:	697b      	ldr	r3, [r7, #20]
 801e50e:	3301      	adds	r3, #1
 801e510:	617b      	str	r3, [r7, #20]
 801e512:	e002      	b.n	801e51a <hci_le_data_length_change_event+0x56>
    } 
    else 
    {
      BLE_MANAGER_PRINTF("ACI GATT Exchange Config Done\r\n");
 801e514:	480d      	ldr	r0, [pc, #52]	@ (801e54c <hci_le_data_length_change_event+0x88>)
 801e516:	f005 fc89 	bl	8023e2c <puts>
    }
  } while ((RetStatus != BLE_STATUS_SUCCESS) & (RetryNumber<MaxRetryNumber));
 801e51a:	7bfb      	ldrb	r3, [r7, #15]
 801e51c:	2b00      	cmp	r3, #0
 801e51e:	bf14      	ite	ne
 801e520:	2301      	movne	r3, #1
 801e522:	2300      	moveq	r3, #0
 801e524:	b2da      	uxtb	r2, r3
 801e526:	6979      	ldr	r1, [r7, #20]
 801e528:	693b      	ldr	r3, [r7, #16]
 801e52a:	4299      	cmp	r1, r3
 801e52c:	bfb4      	ite	lt
 801e52e:	2301      	movlt	r3, #1
 801e530:	2300      	movge	r3, #0
 801e532:	b2db      	uxtb	r3, r3
 801e534:	4013      	ands	r3, r2
 801e536:	b2db      	uxtb	r3, r3
 801e538:	2b00      	cmp	r3, #0
 801e53a:	d1d6      	bne.n	801e4ea <hci_le_data_length_change_event+0x26>
  
#endif /* (BLUE_CORE == BLUENRG_LP) */
}
 801e53c:	bf00      	nop
 801e53e:	bf00      	nop
 801e540:	371c      	adds	r7, #28
 801e542:	46bd      	mov	sp, r7
 801e544:	bd90      	pop	{r4, r7, pc}
 801e546:	bf00      	nop
 801e548:	0802a0c0 	.word	0x0802a0c0
 801e54c:	0802a0f0 	.word	0x0802a0f0

0801e550 <aci_gatt_clt_proc_complete_event>:
  - 0xFB: Flash write failed
  - 0xFC: Flash erase failed
*/

void aci_gatt_clt_proc_complete_event(uint16_t Connection_Handle, uint8_t Error_Code)
{
 801e550:	b580      	push	{r7, lr}
 801e552:	b082      	sub	sp, #8
 801e554:	af00      	add	r7, sp, #0
 801e556:	4603      	mov	r3, r0
 801e558:	460a      	mov	r2, r1
 801e55a:	80fb      	strh	r3, [r7, #6]
 801e55c:	4613      	mov	r3, r2
 801e55e:	717b      	strb	r3, [r7, #5]
  if (Error_Code != 0x0)
 801e560:	797b      	ldrb	r3, [r7, #5]
 801e562:	2b00      	cmp	r3, #0
 801e564:	d005      	beq.n	801e572 <aci_gatt_clt_proc_complete_event+0x22>
  {
    BLE_MANAGER_PRINTF("aci_gatt_clt_proc_complete_event Error_Code=0x%x\r\n", Error_Code);
 801e566:	797b      	ldrb	r3, [r7, #5]
 801e568:	4619      	mov	r1, r3
 801e56a:	4805      	ldr	r0, [pc, #20]	@ (801e580 <aci_gatt_clt_proc_complete_event+0x30>)
 801e56c:	f005 fbf6 	bl	8023d5c <iprintf>
  }
  else
  {
    BLE_MANAGER_PRINTF("aci_gatt_clt_proc_complete_event Ok\r\n");
  }
}
 801e570:	e002      	b.n	801e578 <aci_gatt_clt_proc_complete_event+0x28>
    BLE_MANAGER_PRINTF("aci_gatt_clt_proc_complete_event Ok\r\n");
 801e572:	4804      	ldr	r0, [pc, #16]	@ (801e584 <aci_gatt_clt_proc_complete_event+0x34>)
 801e574:	f005 fc5a 	bl	8023e2c <puts>
}
 801e578:	bf00      	nop
 801e57a:	3708      	adds	r7, #8
 801e57c:	46bd      	mov	sp, r7
 801e57e:	bd80      	pop	{r7, pc}
 801e580:	0802a110 	.word	0x0802a110
 801e584:	0802a144 	.word	0x0802a144

0801e588 <hci_le_phy_update_complete_event>:
  */
void hci_le_phy_update_complete_event(uint8_t Status,
                                      uint16_t Connection_Handle,
                                      uint8_t TX_PHY,
                                      uint8_t RX_PHY)
{
 801e588:	b590      	push	{r4, r7, lr}
 801e58a:	b083      	sub	sp, #12
 801e58c:	af00      	add	r7, sp, #0
 801e58e:	4604      	mov	r4, r0
 801e590:	4608      	mov	r0, r1
 801e592:	4611      	mov	r1, r2
 801e594:	461a      	mov	r2, r3
 801e596:	4623      	mov	r3, r4
 801e598:	71fb      	strb	r3, [r7, #7]
 801e59a:	4603      	mov	r3, r0
 801e59c:	80bb      	strh	r3, [r7, #4]
 801e59e:	460b      	mov	r3, r1
 801e5a0:	71bb      	strb	r3, [r7, #6]
 801e5a2:	4613      	mov	r3, r2
 801e5a4:	70fb      	strb	r3, [r7, #3]

  BLE_MANAGER_PRINTF("hci_le_phy_update_complete_event Status=0x%x\r\n", Status);
 801e5a6:	79fb      	ldrb	r3, [r7, #7]
 801e5a8:	4619      	mov	r1, r3
 801e5aa:	4808      	ldr	r0, [pc, #32]	@ (801e5cc <hci_le_phy_update_complete_event+0x44>)
 801e5ac:	f005 fbd6 	bl	8023d5c <iprintf>
  BLE_MANAGER_PRINTF("\tTX_PHY=0x%x\r\n", TX_PHY);
 801e5b0:	79bb      	ldrb	r3, [r7, #6]
 801e5b2:	4619      	mov	r1, r3
 801e5b4:	4806      	ldr	r0, [pc, #24]	@ (801e5d0 <hci_le_phy_update_complete_event+0x48>)
 801e5b6:	f005 fbd1 	bl	8023d5c <iprintf>
  BLE_MANAGER_PRINTF("\tRX_PHY=0x%x\r\n", RX_PHY);
 801e5ba:	78fb      	ldrb	r3, [r7, #3]
 801e5bc:	4619      	mov	r1, r3
 801e5be:	4805      	ldr	r0, [pc, #20]	@ (801e5d4 <hci_le_phy_update_complete_event+0x4c>)
 801e5c0:	f005 fbcc 	bl	8023d5c <iprintf>
}
 801e5c4:	bf00      	nop
 801e5c6:	370c      	adds	r7, #12
 801e5c8:	46bd      	mov	sp, r7
 801e5ca:	bd90      	pop	{r4, r7, pc}
 801e5cc:	0802a16c 	.word	0x0802a16c
 801e5d0:	0802a19c 	.word	0x0802a19c
 801e5d4:	0802a1ac 	.word	0x0802a1ac

0801e5d8 <aci_gatt_clt_indication_event>:
  */
void aci_gatt_clt_indication_event(uint16_t Connection_Handle,
                                   uint16_t Attribute_Handle,
                                   uint16_t Attribute_Value_Length,
                                   uint8_t Attribute_Value[])
{
 801e5d8:	b580      	push	{r7, lr}
 801e5da:	b086      	sub	sp, #24
 801e5dc:	af00      	add	r7, sp, #0
 801e5de:	607b      	str	r3, [r7, #4]
 801e5e0:	4603      	mov	r3, r0
 801e5e2:	81fb      	strh	r3, [r7, #14]
 801e5e4:	460b      	mov	r3, r1
 801e5e6:	81bb      	strh	r3, [r7, #12]
 801e5e8:	4613      	mov	r3, r2
 801e5ea:	817b      	strh	r3, [r7, #10]
  * In our case we don't need to do nothing when we receive this indication,
  * except it's confirmation
  */
#ifdef BLE_MANAGER_DEBUG

  BLE_MANAGER_PRINTF("aci_gatt_clt_indication_event:\r\n");
 801e5ec:	480b      	ldr	r0, [pc, #44]	@ (801e61c <aci_gatt_clt_indication_event+0x44>)
 801e5ee:	f005 fc1d 	bl	8023e2c <puts>
    StopHandle  = (((uint16_t) Attribute_Value[3]) << 8);
    StopHandle = StopHandle | ((uint16_t)Attribute_Value[2]);
    BLE_MANAGER_PRINTF("\tFrom Handles =0x%x to 0x%x\r\n", StartHandle, StopHandle);
  }
#endif /* (BLE_DEBUG_LEVEL>2) */
  BLE_MANAGER_PRINTF("Nothing to do except send confirmation\r\n");
 801e5f2:	480b      	ldr	r0, [pc, #44]	@ (801e620 <aci_gatt_clt_indication_event+0x48>)
 801e5f4:	f005 fc1a 	bl	8023e2c <puts>
#endif /* BLE_MANAGER_DEBUG */

  RetStatus = aci_gatt_clt_confirm_indication(Connection_Handle);
 801e5f8:	89fb      	ldrh	r3, [r7, #14]
 801e5fa:	4618      	mov	r0, r3
 801e5fc:	f7fa fe2f 	bl	801925e <aci_gatt_clt_confirm_indication>
 801e600:	4603      	mov	r3, r0
 801e602:	75fb      	strb	r3, [r7, #23]

  if (RetStatus != BLE_STATUS_SUCCESS)
 801e604:	7dfb      	ldrb	r3, [r7, #23]
 801e606:	2b00      	cmp	r3, #0
 801e608:	d004      	beq.n	801e614 <aci_gatt_clt_indication_event+0x3c>
  {
    BLE_MANAGER_PRINTF("Error: aci_gatt_clt_indication_event failed %d\r\n", RetStatus);
 801e60a:	7dfb      	ldrb	r3, [r7, #23]
 801e60c:	4619      	mov	r1, r3
 801e60e:	4805      	ldr	r0, [pc, #20]	@ (801e624 <aci_gatt_clt_indication_event+0x4c>)
 801e610:	f005 fba4 	bl	8023d5c <iprintf>
  else
  {
    BLE_MANAGER_PRINTF("aci_gatt_confirm_indication Done\r\n");
#endif /* (BLE_DEBUG_LEVEL>2) */
  }
}
 801e614:	bf00      	nop
 801e616:	3718      	adds	r7, #24
 801e618:	46bd      	mov	sp, r7
 801e61a:	bd80      	pop	{r7, pc}
 801e61c:	0802a1bc 	.word	0x0802a1bc
 801e620:	0802a1dc 	.word	0x0802a1dc
 801e624:	0802a204 	.word	0x0802a204

0801e628 <aci_gatt_proc_timeout_event>:
  *             in non volatile memory.
  * @param Connection_Handle Connection handle on which the GATT procedure has timed out
  * @retval None
  */
void aci_gatt_proc_timeout_event(uint16_t Connection_Handle)
{
 801e628:	b580      	push	{r7, lr}
 801e62a:	b082      	sub	sp, #8
 801e62c:	af00      	add	r7, sp, #0
 801e62e:	4603      	mov	r3, r0
 801e630:	80fb      	strh	r3, [r7, #6]
  BLE_MANAGER_PRINTF("\r\n-------->aci_gatt_proc_timeout_event<--------\r\n");
 801e632:	4809      	ldr	r0, [pc, #36]	@ (801e658 <aci_gatt_proc_timeout_event+0x30>)
 801e634:	f005 fbfa 	bl	8023e2c <puts>

  /* ... it is important to leave an 100 ms blank window before sending the @ref aci_gap_terminate...*/
  BLE_MANAGER_DELAY(500);
 801e638:	f44f 70fa 	mov.w	r0, #500	@ 0x1f4
 801e63c:	f7e6 f8de 	bl	80047fc <HAL_Delay>
   0x14: Remote Device Terminated Connection due to Low Resources
   0x15: Remote Device Terminated Connection due to Power Off
   0x1A: Unsupported Remote Feature
   0x3B: Unacceptable Connection Parameters
  */
  BLE_MANAGER_PRINTF("Issue one aci_gap_terminate\r\n");
 801e640:	4806      	ldr	r0, [pc, #24]	@ (801e65c <aci_gatt_proc_timeout_event+0x34>)
 801e642:	f005 fbf3 	bl	8023e2c <puts>
  aci_gap_terminate(Connection_Handle, 0x13);
 801e646:	88fb      	ldrh	r3, [r7, #6]
 801e648:	2113      	movs	r1, #19
 801e64a:	4618      	mov	r0, r3
 801e64c:	f7fa fa0b 	bl	8018a66 <aci_gap_terminate>
}
 801e650:	bf00      	nop
 801e652:	3708      	adds	r7, #8
 801e654:	46bd      	mov	sp, r7
 801e656:	bd80      	pop	{r7, pc}
 801e658:	0802a238 	.word	0x0802a238
 801e65c:	0802a26c 	.word	0x0802a26c

0801e660 <hci_hardware_error_event>:
  *        - 0x02: Timer overrun error
  *        - 0x03: Internal queue overflow error
  * @retval None
  */
void hci_hardware_error_event(uint8_t Hardware_Code)
{
 801e660:	b580      	push	{r7, lr}
 801e662:	b082      	sub	sp, #8
 801e664:	af00      	add	r7, sp, #0
 801e666:	4603      	mov	r3, r0
 801e668:	71fb      	strb	r3, [r7, #7]
  if (CustomHardwareErrorEventHandler != NULL)
 801e66a:	4b0a      	ldr	r3, [pc, #40]	@ (801e694 <hci_hardware_error_event+0x34>)
 801e66c:	681b      	ldr	r3, [r3, #0]
 801e66e:	2b00      	cmp	r3, #0
 801e670:	d005      	beq.n	801e67e <hci_hardware_error_event+0x1e>
  {
    CustomHardwareErrorEventHandler(Hardware_Code);
 801e672:	4b08      	ldr	r3, [pc, #32]	@ (801e694 <hci_hardware_error_event+0x34>)
 801e674:	681b      	ldr	r3, [r3, #0]
 801e676:	79fa      	ldrb	r2, [r7, #7]
 801e678:	4610      	mov	r0, r2
 801e67a:	4798      	blx	r3
#endif /* 0 */
#endif /* (BLE_DEBUG_LEVEL>2) */
    BLE_MANAGER_DELAY(1000);
    HAL_NVIC_SystemReset();
  }
}
 801e67c:	e005      	b.n	801e68a <hci_hardware_error_event+0x2a>
    BLE_MANAGER_DELAY(1000);
 801e67e:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
 801e682:	f7e6 f8bb 	bl	80047fc <HAL_Delay>
    HAL_NVIC_SystemReset();
 801e686:	f7ef fb2a 	bl	800dcde <HAL_NVIC_SystemReset>
}
 801e68a:	bf00      	nop
 801e68c:	3708      	adds	r7, #8
 801e68e:	46bd      	mov	sp, r7
 801e690:	bd80      	pop	{r7, pc}
 801e692:	bf00      	nop
 801e694:	20001b50 	.word	0x20001b50

0801e698 <aci_gap_bond_lost_event>:
  * Input          : See file bluenrg1_events.h
  * Output         : See file bluenrg1_events.h
  * Return         : See file bluenrg1_events.h
  *******************************************************************************/
void aci_gap_bond_lost_event(void)
{
 801e698:	b580      	push	{r7, lr}
 801e69a:	af00      	add	r7, sp, #0
  aci_gap_allow_rebond(connection_handle);
 801e69c:	4b03      	ldr	r3, [pc, #12]	@ (801e6ac <aci_gap_bond_lost_event+0x14>)
 801e69e:	881b      	ldrh	r3, [r3, #0]
 801e6a0:	4618      	mov	r0, r3
 801e6a2:	f7fa fa57 	bl	8018b54 <aci_gap_allow_rebond>
#if (BLE_DEBUG_LEVEL>2)
  BLE_MANAGER_PRINTF("aci_gap_allow_rebond()\r\n");
#endif /* (BLE_DEBUG_LEVEL>2) */
}
 801e6a6:	bf00      	nop
 801e6a8:	bd80      	pop	{r7, pc}
 801e6aa:	bf00      	nop
 801e6ac:	20001dac 	.word	0x20001dac

0801e6b0 <UpdateWhiteList>:
  * @brief  This function Updates the White list for BLE Connection
  * @param None
  * @retval None
  */
static void UpdateWhiteList(void)
{
 801e6b0:	b580      	push	{r7, lr}
 801e6b2:	b086      	sub	sp, #24
 801e6b4:	af00      	add	r7, sp, #0
  Bonded_Device_Entry_t BondedDeviceEntry[BLE_MANAGER_MAX_BONDED_DEVICES];

#if (BLUE_CORE != BLUENRG_LP)
  RetStatus =  aci_gap_get_bonded_devices(&NumOfAddresses, BondedDeviceEntry);
#else /* (BLUE_CORE != BLUENRG_LP) */
  RetStatus =  aci_gap_get_bonded_devices(0, BLE_MANAGER_MAX_BONDED_DEVICES, &NumOfAddresses, BondedDeviceEntry);
 801e6b6:	463b      	mov	r3, r7
 801e6b8:	f107 0216 	add.w	r2, r7, #22
 801e6bc:	2103      	movs	r1, #3
 801e6be:	2000      	movs	r0, #0
 801e6c0:	f7fa faa9 	bl	8018c16 <aci_gap_get_bonded_devices>
 801e6c4:	4603      	mov	r3, r0
 801e6c6:	75fb      	strb	r3, [r7, #23]
#endif /* (BLUE_CORE != BLUENRG_LP) */

  if (RetStatus == BLE_STATUS_SUCCESS)
 801e6c8:	7dfb      	ldrb	r3, [r7, #23]
 801e6ca:	2b00      	cmp	r3, #0
 801e6cc:	d10f      	bne.n	801e6ee <UpdateWhiteList+0x3e>
  {
    if (NumOfAddresses > 0U)
 801e6ce:	7dbb      	ldrb	r3, [r7, #22]
 801e6d0:	2b00      	cmp	r3, #0
 801e6d2:	d00c      	beq.n	801e6ee <UpdateWhiteList+0x3e>
#endif /* (BLE_DEBUG_LEVEL>2) */

#if (BLUE_CORE != BLUENRG_LP)
      RetStatus = aci_gap_configure_whitelist();
#else /* (BLUE_CORE != BLUENRG_LP) */
      RetStatus = aci_gap_configure_white_and_resolving_list(0x01 /* White List */);
 801e6d4:	2001      	movs	r0, #1
 801e6d6:	f7fa fc28 	bl	8018f2a <aci_gap_configure_white_and_resolving_list>
 801e6da:	4603      	mov	r3, r0
 801e6dc:	75fb      	strb	r3, [r7, #23]
#endif /* (BLUE_CORE != BLUENRG_LP) */
      if (RetStatus != BLE_STATUS_SUCCESS)
 801e6de:	7dfb      	ldrb	r3, [r7, #23]
 801e6e0:	2b00      	cmp	r3, #0
 801e6e2:	d004      	beq.n	801e6ee <UpdateWhiteList+0x3e>
      {
        BLE_MANAGER_PRINTF("Error: aci_gap_configure_whitelist() failed:0x%02x\r\n", RetStatus);
 801e6e4:	7dfb      	ldrb	r3, [r7, #23]
 801e6e6:	4619      	mov	r1, r3
 801e6e8:	4803      	ldr	r0, [pc, #12]	@ (801e6f8 <UpdateWhiteList+0x48>)
 801e6ea:	f005 fb37 	bl	8023d5c <iprintf>
        BLE_MANAGER_PRINTF("aci_gap_configure_whitelist --> SUCCESS\r\n");
#endif /* (BLE_DEBUG_LEVEL>2) */
      }
    }
  }
}
 801e6ee:	bf00      	nop
 801e6f0:	3718      	adds	r7, #24
 801e6f2:	46bd      	mov	sp, r7
 801e6f4:	bd80      	pop	{r7, pc}
 801e6f6:	bf00      	nop
 801e6f8:	0802a28c 	.word	0x0802a28c

0801e6fc <aci_gap_numeric_comparison_value_event>:
  * Input          : See file bluenrg1_events.h
  * Output         : See file bluenrg1_events.h
  * Return         : See file bluenrg1_events.h
  *******************************************************************************/
void aci_gap_numeric_comparison_value_event(uint16_t Connection_Handle, uint32_t Numeric_Value)
{
 801e6fc:	b580      	push	{r7, lr}
 801e6fe:	b082      	sub	sp, #8
 801e700:	af00      	add	r7, sp, #0
 801e702:	4603      	mov	r3, r0
 801e704:	6039      	str	r1, [r7, #0]
 801e706:	80fb      	strh	r3, [r7, #6]
#if (BLE_DEBUG_LEVEL>2)
  BLE_MANAGER_PRINTF("aci_gap_numeric_comparison_value_event Numeric_Value=%ld\r\n", Numeric_Value);
#endif /* (BLE_DEBUG_LEVEL>2) */

  /* Confirm Yes... without control of Numeric Value received from Master */
  aci_gap_numeric_comparison_value_confirm_yesno(Connection_Handle, 0x01);
 801e708:	88fb      	ldrh	r3, [r7, #6]
 801e70a:	2101      	movs	r1, #1
 801e70c:	4618      	mov	r0, r3
 801e70e:	f7fa fb98 	bl	8018e42 <aci_gap_numeric_comparison_value_confirm_yesno>
}
 801e712:	bf00      	nop
 801e714:	3708      	adds	r7, #8
 801e716:	46bd      	mov	sp, r7
 801e718:	bd80      	pop	{r7, pc}

0801e71a <hci_encryption_change_event>:
  * Input          : See file bluenrg1_events.h
  * Output         : See file bluenrg1_events.h
  * Return         : See file bluenrg1_events.h
  *******************************************************************************/
void hci_encryption_change_event(uint8_t Status, uint16_t Connection_Handle, uint8_t Encryption_Enabled)
{
 801e71a:	b480      	push	{r7}
 801e71c:	b083      	sub	sp, #12
 801e71e:	af00      	add	r7, sp, #0
 801e720:	4603      	mov	r3, r0
 801e722:	71fb      	strb	r3, [r7, #7]
 801e724:	460b      	mov	r3, r1
 801e726:	80bb      	strh	r3, [r7, #4]
 801e728:	4613      	mov	r3, r2
 801e72a:	71bb      	strb	r3, [r7, #6]
#if (BLE_DEBUG_LEVEL>2)
  BLE_MANAGER_PRINTF("hci_encryption_change_event\r\n");
#endif /* (BLE_DEBUG_LEVEL>2) */
}
 801e72c:	bf00      	nop
 801e72e:	370c      	adds	r7, #12
 801e730:	46bd      	mov	sp, r7
 801e732:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e736:	4770      	bx	lr

0801e738 <parson_strndup>:
        escaped = PARSON_FALSE;
        string++;
    }
}

static char * parson_strndup(const char *string, size_t n) {
 801e738:	b580      	push	{r7, lr}
 801e73a:	b084      	sub	sp, #16
 801e73c:	af00      	add	r7, sp, #0
 801e73e:	6078      	str	r0, [r7, #4]
 801e740:	6039      	str	r1, [r7, #0]
    /* We expect the caller has validated that 'n' fits within the input buffer. */
    char *output_string = (char*)parson_malloc(n + 1);
 801e742:	4b0d      	ldr	r3, [pc, #52]	@ (801e778 <parson_strndup+0x40>)
 801e744:	681b      	ldr	r3, [r3, #0]
 801e746:	683a      	ldr	r2, [r7, #0]
 801e748:	3201      	adds	r2, #1
 801e74a:	4610      	mov	r0, r2
 801e74c:	4798      	blx	r3
 801e74e:	60f8      	str	r0, [r7, #12]
    if (!output_string) {
 801e750:	68fb      	ldr	r3, [r7, #12]
 801e752:	2b00      	cmp	r3, #0
 801e754:	d101      	bne.n	801e75a <parson_strndup+0x22>
        return NULL;
 801e756:	2300      	movs	r3, #0
 801e758:	e00a      	b.n	801e770 <parson_strndup+0x38>
    }
    output_string[n] = '\0';
 801e75a:	68fa      	ldr	r2, [r7, #12]
 801e75c:	683b      	ldr	r3, [r7, #0]
 801e75e:	4413      	add	r3, r2
 801e760:	2200      	movs	r2, #0
 801e762:	701a      	strb	r2, [r3, #0]
    memcpy(output_string, string, n);
 801e764:	683a      	ldr	r2, [r7, #0]
 801e766:	6879      	ldr	r1, [r7, #4]
 801e768:	68f8      	ldr	r0, [r7, #12]
 801e76a:	f005 fd40 	bl	80241ee <memcpy>
    return output_string;
 801e76e:	68fb      	ldr	r3, [r7, #12]
}
 801e770:	4618      	mov	r0, r3
 801e772:	3710      	adds	r7, #16
 801e774:	46bd      	mov	sp, r7
 801e776:	bd80      	pop	{r7, pc}
 801e778:	20000210 	.word	0x20000210

0801e77c <parson_strdup>:

static char * parson_strdup(const char *string) {
 801e77c:	b580      	push	{r7, lr}
 801e77e:	b082      	sub	sp, #8
 801e780:	af00      	add	r7, sp, #0
 801e782:	6078      	str	r0, [r7, #4]
    return parson_strndup(string, strlen(string));
 801e784:	6878      	ldr	r0, [r7, #4]
 801e786:	f7e1 fd81 	bl	800028c <strlen>
 801e78a:	4603      	mov	r3, r0
 801e78c:	4619      	mov	r1, r3
 801e78e:	6878      	ldr	r0, [r7, #4]
 801e790:	f7ff ffd2 	bl	801e738 <parson_strndup>
 801e794:	4603      	mov	r3, r0
}
 801e796:	4618      	mov	r0, r3
 801e798:	3708      	adds	r7, #8
 801e79a:	46bd      	mov	sp, r7
 801e79c:	bd80      	pop	{r7, pc}

0801e79e <hex_char_to_int>:

static int hex_char_to_int(char c) {
 801e79e:	b480      	push	{r7}
 801e7a0:	b083      	sub	sp, #12
 801e7a2:	af00      	add	r7, sp, #0
 801e7a4:	4603      	mov	r3, r0
 801e7a6:	71fb      	strb	r3, [r7, #7]
    if (c >= '0' && c <= '9') {
 801e7a8:	79fb      	ldrb	r3, [r7, #7]
 801e7aa:	2b2f      	cmp	r3, #47	@ 0x2f
 801e7ac:	d905      	bls.n	801e7ba <hex_char_to_int+0x1c>
 801e7ae:	79fb      	ldrb	r3, [r7, #7]
 801e7b0:	2b39      	cmp	r3, #57	@ 0x39
 801e7b2:	d802      	bhi.n	801e7ba <hex_char_to_int+0x1c>
        return c - '0';
 801e7b4:	79fb      	ldrb	r3, [r7, #7]
 801e7b6:	3b30      	subs	r3, #48	@ 0x30
 801e7b8:	e013      	b.n	801e7e2 <hex_char_to_int+0x44>
    } else if (c >= 'a' && c <= 'f') {
 801e7ba:	79fb      	ldrb	r3, [r7, #7]
 801e7bc:	2b60      	cmp	r3, #96	@ 0x60
 801e7be:	d905      	bls.n	801e7cc <hex_char_to_int+0x2e>
 801e7c0:	79fb      	ldrb	r3, [r7, #7]
 801e7c2:	2b66      	cmp	r3, #102	@ 0x66
 801e7c4:	d802      	bhi.n	801e7cc <hex_char_to_int+0x2e>
        return c - 'a' + 10;
 801e7c6:	79fb      	ldrb	r3, [r7, #7]
 801e7c8:	3b57      	subs	r3, #87	@ 0x57
 801e7ca:	e00a      	b.n	801e7e2 <hex_char_to_int+0x44>
    } else if (c >= 'A' && c <= 'F') {
 801e7cc:	79fb      	ldrb	r3, [r7, #7]
 801e7ce:	2b40      	cmp	r3, #64	@ 0x40
 801e7d0:	d905      	bls.n	801e7de <hex_char_to_int+0x40>
 801e7d2:	79fb      	ldrb	r3, [r7, #7]
 801e7d4:	2b46      	cmp	r3, #70	@ 0x46
 801e7d6:	d802      	bhi.n	801e7de <hex_char_to_int+0x40>
        return c - 'A' + 10;
 801e7d8:	79fb      	ldrb	r3, [r7, #7]
 801e7da:	3b37      	subs	r3, #55	@ 0x37
 801e7dc:	e001      	b.n	801e7e2 <hex_char_to_int+0x44>
    }
    return -1;
 801e7de:	f04f 33ff 	mov.w	r3, #4294967295
}
 801e7e2:	4618      	mov	r0, r3
 801e7e4:	370c      	adds	r7, #12
 801e7e6:	46bd      	mov	sp, r7
 801e7e8:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e7ec:	4770      	bx	lr

0801e7ee <parse_utf16_hex>:

static JSON_Status parse_utf16_hex(const char *s, unsigned int *result) {
 801e7ee:	b580      	push	{r7, lr}
 801e7f0:	b086      	sub	sp, #24
 801e7f2:	af00      	add	r7, sp, #0
 801e7f4:	6078      	str	r0, [r7, #4]
 801e7f6:	6039      	str	r1, [r7, #0]
    int x1, x2, x3, x4;
    if (s[0] == '\0' || s[1] == '\0' || s[2] == '\0' || s[3] == '\0') {
 801e7f8:	687b      	ldr	r3, [r7, #4]
 801e7fa:	781b      	ldrb	r3, [r3, #0]
 801e7fc:	2b00      	cmp	r3, #0
 801e7fe:	d00e      	beq.n	801e81e <parse_utf16_hex+0x30>
 801e800:	687b      	ldr	r3, [r7, #4]
 801e802:	3301      	adds	r3, #1
 801e804:	781b      	ldrb	r3, [r3, #0]
 801e806:	2b00      	cmp	r3, #0
 801e808:	d009      	beq.n	801e81e <parse_utf16_hex+0x30>
 801e80a:	687b      	ldr	r3, [r7, #4]
 801e80c:	3302      	adds	r3, #2
 801e80e:	781b      	ldrb	r3, [r3, #0]
 801e810:	2b00      	cmp	r3, #0
 801e812:	d004      	beq.n	801e81e <parse_utf16_hex+0x30>
 801e814:	687b      	ldr	r3, [r7, #4]
 801e816:	3303      	adds	r3, #3
 801e818:	781b      	ldrb	r3, [r3, #0]
 801e81a:	2b00      	cmp	r3, #0
 801e81c:	d102      	bne.n	801e824 <parse_utf16_hex+0x36>
        return JSONFailure;
 801e81e:	f04f 33ff 	mov.w	r3, #4294967295
 801e822:	e03b      	b.n	801e89c <parse_utf16_hex+0xae>
    }
    x1 = hex_char_to_int(s[0]);
 801e824:	687b      	ldr	r3, [r7, #4]
 801e826:	781b      	ldrb	r3, [r3, #0]
 801e828:	4618      	mov	r0, r3
 801e82a:	f7ff ffb8 	bl	801e79e <hex_char_to_int>
 801e82e:	6178      	str	r0, [r7, #20]
    x2 = hex_char_to_int(s[1]);
 801e830:	687b      	ldr	r3, [r7, #4]
 801e832:	3301      	adds	r3, #1
 801e834:	781b      	ldrb	r3, [r3, #0]
 801e836:	4618      	mov	r0, r3
 801e838:	f7ff ffb1 	bl	801e79e <hex_char_to_int>
 801e83c:	6138      	str	r0, [r7, #16]
    x3 = hex_char_to_int(s[2]);
 801e83e:	687b      	ldr	r3, [r7, #4]
 801e840:	3302      	adds	r3, #2
 801e842:	781b      	ldrb	r3, [r3, #0]
 801e844:	4618      	mov	r0, r3
 801e846:	f7ff ffaa 	bl	801e79e <hex_char_to_int>
 801e84a:	60f8      	str	r0, [r7, #12]
    x4 = hex_char_to_int(s[3]);
 801e84c:	687b      	ldr	r3, [r7, #4]
 801e84e:	3303      	adds	r3, #3
 801e850:	781b      	ldrb	r3, [r3, #0]
 801e852:	4618      	mov	r0, r3
 801e854:	f7ff ffa3 	bl	801e79e <hex_char_to_int>
 801e858:	60b8      	str	r0, [r7, #8]
    if (x1 == -1 || x2 == -1 || x3 == -1 || x4 == -1) {
 801e85a:	697b      	ldr	r3, [r7, #20]
 801e85c:	f1b3 3fff 	cmp.w	r3, #4294967295
 801e860:	d00b      	beq.n	801e87a <parse_utf16_hex+0x8c>
 801e862:	693b      	ldr	r3, [r7, #16]
 801e864:	f1b3 3fff 	cmp.w	r3, #4294967295
 801e868:	d007      	beq.n	801e87a <parse_utf16_hex+0x8c>
 801e86a:	68fb      	ldr	r3, [r7, #12]
 801e86c:	f1b3 3fff 	cmp.w	r3, #4294967295
 801e870:	d003      	beq.n	801e87a <parse_utf16_hex+0x8c>
 801e872:	68bb      	ldr	r3, [r7, #8]
 801e874:	f1b3 3fff 	cmp.w	r3, #4294967295
 801e878:	d102      	bne.n	801e880 <parse_utf16_hex+0x92>
        return JSONFailure;
 801e87a:	f04f 33ff 	mov.w	r3, #4294967295
 801e87e:	e00d      	b.n	801e89c <parse_utf16_hex+0xae>
    }
    *result = (unsigned int)((x1 << 12) | (x2 << 8) | (x3 << 4) | x4);
 801e880:	697b      	ldr	r3, [r7, #20]
 801e882:	031a      	lsls	r2, r3, #12
 801e884:	693b      	ldr	r3, [r7, #16]
 801e886:	021b      	lsls	r3, r3, #8
 801e888:	431a      	orrs	r2, r3
 801e88a:	68fb      	ldr	r3, [r7, #12]
 801e88c:	011b      	lsls	r3, r3, #4
 801e88e:	431a      	orrs	r2, r3
 801e890:	68bb      	ldr	r3, [r7, #8]
 801e892:	4313      	orrs	r3, r2
 801e894:	461a      	mov	r2, r3
 801e896:	683b      	ldr	r3, [r7, #0]
 801e898:	601a      	str	r2, [r3, #0]
    return JSONSuccess;
 801e89a:	2300      	movs	r3, #0
}
 801e89c:	4618      	mov	r0, r3
 801e89e:	3718      	adds	r7, #24
 801e8a0:	46bd      	mov	sp, r7
 801e8a2:	bd80      	pop	{r7, pc}

0801e8a4 <num_bytes_in_utf8_sequence>:

static int num_bytes_in_utf8_sequence(unsigned char c) {
 801e8a4:	b480      	push	{r7}
 801e8a6:	b083      	sub	sp, #12
 801e8a8:	af00      	add	r7, sp, #0
 801e8aa:	4603      	mov	r3, r0
 801e8ac:	71fb      	strb	r3, [r7, #7]
    if (c == 0xC0 || c == 0xC1 || c > 0xF4 || IS_CONT(c)) {
 801e8ae:	79fb      	ldrb	r3, [r7, #7]
 801e8b0:	2bc0      	cmp	r3, #192	@ 0xc0
 801e8b2:	d00a      	beq.n	801e8ca <num_bytes_in_utf8_sequence+0x26>
 801e8b4:	79fb      	ldrb	r3, [r7, #7]
 801e8b6:	2bc1      	cmp	r3, #193	@ 0xc1
 801e8b8:	d007      	beq.n	801e8ca <num_bytes_in_utf8_sequence+0x26>
 801e8ba:	79fb      	ldrb	r3, [r7, #7]
 801e8bc:	2bf4      	cmp	r3, #244	@ 0xf4
 801e8be:	d804      	bhi.n	801e8ca <num_bytes_in_utf8_sequence+0x26>
 801e8c0:	79fb      	ldrb	r3, [r7, #7]
 801e8c2:	f003 03c0 	and.w	r3, r3, #192	@ 0xc0
 801e8c6:	2b80      	cmp	r3, #128	@ 0x80
 801e8c8:	d101      	bne.n	801e8ce <num_bytes_in_utf8_sequence+0x2a>
        return 0;
 801e8ca:	2300      	movs	r3, #0
 801e8cc:	e01b      	b.n	801e906 <num_bytes_in_utf8_sequence+0x62>
    } else if ((c & 0x80) == 0) {    /* 0xxxxxxx */
 801e8ce:	f997 3007 	ldrsb.w	r3, [r7, #7]
 801e8d2:	2b00      	cmp	r3, #0
 801e8d4:	db01      	blt.n	801e8da <num_bytes_in_utf8_sequence+0x36>
        return 1;
 801e8d6:	2301      	movs	r3, #1
 801e8d8:	e015      	b.n	801e906 <num_bytes_in_utf8_sequence+0x62>
    } else if ((c & 0xE0) == 0xC0) { /* 110xxxxx */
 801e8da:	79fb      	ldrb	r3, [r7, #7]
 801e8dc:	f003 03e0 	and.w	r3, r3, #224	@ 0xe0
 801e8e0:	2bc0      	cmp	r3, #192	@ 0xc0
 801e8e2:	d101      	bne.n	801e8e8 <num_bytes_in_utf8_sequence+0x44>
        return 2;
 801e8e4:	2302      	movs	r3, #2
 801e8e6:	e00e      	b.n	801e906 <num_bytes_in_utf8_sequence+0x62>
    } else if ((c & 0xF0) == 0xE0) { /* 1110xxxx */
 801e8e8:	79fb      	ldrb	r3, [r7, #7]
 801e8ea:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
 801e8ee:	2be0      	cmp	r3, #224	@ 0xe0
 801e8f0:	d101      	bne.n	801e8f6 <num_bytes_in_utf8_sequence+0x52>
        return 3;
 801e8f2:	2303      	movs	r3, #3
 801e8f4:	e007      	b.n	801e906 <num_bytes_in_utf8_sequence+0x62>
    } else if ((c & 0xF8) == 0xF0) { /* 11110xxx */
 801e8f6:	79fb      	ldrb	r3, [r7, #7]
 801e8f8:	f003 03f8 	and.w	r3, r3, #248	@ 0xf8
 801e8fc:	2bf0      	cmp	r3, #240	@ 0xf0
 801e8fe:	d101      	bne.n	801e904 <num_bytes_in_utf8_sequence+0x60>
        return 4;
 801e900:	2304      	movs	r3, #4
 801e902:	e000      	b.n	801e906 <num_bytes_in_utf8_sequence+0x62>
    }
    return 0; /* won't happen */
 801e904:	2300      	movs	r3, #0
}
 801e906:	4618      	mov	r0, r3
 801e908:	370c      	adds	r7, #12
 801e90a:	46bd      	mov	sp, r7
 801e90c:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e910:	4770      	bx	lr

0801e912 <verify_utf8_sequence>:

static JSON_Status verify_utf8_sequence(const unsigned char *string, int *len) {
 801e912:	b580      	push	{r7, lr}
 801e914:	b084      	sub	sp, #16
 801e916:	af00      	add	r7, sp, #0
 801e918:	6078      	str	r0, [r7, #4]
 801e91a:	6039      	str	r1, [r7, #0]
    unsigned int cp = 0;
 801e91c:	2300      	movs	r3, #0
 801e91e:	60fb      	str	r3, [r7, #12]
    *len = num_bytes_in_utf8_sequence(string[0]);
 801e920:	687b      	ldr	r3, [r7, #4]
 801e922:	781b      	ldrb	r3, [r3, #0]
 801e924:	4618      	mov	r0, r3
 801e926:	f7ff ffbd 	bl	801e8a4 <num_bytes_in_utf8_sequence>
 801e92a:	4602      	mov	r2, r0
 801e92c:	683b      	ldr	r3, [r7, #0]
 801e92e:	601a      	str	r2, [r3, #0]

    if (*len == 1) {
 801e930:	683b      	ldr	r3, [r7, #0]
 801e932:	681b      	ldr	r3, [r3, #0]
 801e934:	2b01      	cmp	r3, #1
 801e936:	d103      	bne.n	801e940 <verify_utf8_sequence+0x2e>
        cp = string[0];
 801e938:	687b      	ldr	r3, [r7, #4]
 801e93a:	781b      	ldrb	r3, [r3, #0]
 801e93c:	60fb      	str	r3, [r7, #12]
 801e93e:	e080      	b.n	801ea42 <verify_utf8_sequence+0x130>
    } else if (*len == 2 && IS_CONT(string[1])) {
 801e940:	683b      	ldr	r3, [r7, #0]
 801e942:	681b      	ldr	r3, [r3, #0]
 801e944:	2b02      	cmp	r3, #2
 801e946:	d115      	bne.n	801e974 <verify_utf8_sequence+0x62>
 801e948:	687b      	ldr	r3, [r7, #4]
 801e94a:	3301      	adds	r3, #1
 801e94c:	781b      	ldrb	r3, [r3, #0]
 801e94e:	f003 03c0 	and.w	r3, r3, #192	@ 0xc0
 801e952:	2b80      	cmp	r3, #128	@ 0x80
 801e954:	d10e      	bne.n	801e974 <verify_utf8_sequence+0x62>
        cp = string[0] & 0x1F;
 801e956:	687b      	ldr	r3, [r7, #4]
 801e958:	781b      	ldrb	r3, [r3, #0]
 801e95a:	f003 031f 	and.w	r3, r3, #31
 801e95e:	60fb      	str	r3, [r7, #12]
        cp = (cp << 6) | (string[1] & 0x3F);
 801e960:	68fb      	ldr	r3, [r7, #12]
 801e962:	019a      	lsls	r2, r3, #6
 801e964:	687b      	ldr	r3, [r7, #4]
 801e966:	3301      	adds	r3, #1
 801e968:	781b      	ldrb	r3, [r3, #0]
 801e96a:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 801e96e:	4313      	orrs	r3, r2
 801e970:	60fb      	str	r3, [r7, #12]
 801e972:	e066      	b.n	801ea42 <verify_utf8_sequence+0x130>
    } else if (*len == 3 && IS_CONT(string[1]) && IS_CONT(string[2])) {
 801e974:	683b      	ldr	r3, [r7, #0]
 801e976:	681b      	ldr	r3, [r3, #0]
 801e978:	2b03      	cmp	r3, #3
 801e97a:	d125      	bne.n	801e9c8 <verify_utf8_sequence+0xb6>
 801e97c:	687b      	ldr	r3, [r7, #4]
 801e97e:	3301      	adds	r3, #1
 801e980:	781b      	ldrb	r3, [r3, #0]
 801e982:	f003 03c0 	and.w	r3, r3, #192	@ 0xc0
 801e986:	2b80      	cmp	r3, #128	@ 0x80
 801e988:	d11e      	bne.n	801e9c8 <verify_utf8_sequence+0xb6>
 801e98a:	687b      	ldr	r3, [r7, #4]
 801e98c:	3302      	adds	r3, #2
 801e98e:	781b      	ldrb	r3, [r3, #0]
 801e990:	f003 03c0 	and.w	r3, r3, #192	@ 0xc0
 801e994:	2b80      	cmp	r3, #128	@ 0x80
 801e996:	d117      	bne.n	801e9c8 <verify_utf8_sequence+0xb6>
        cp = ((unsigned char)string[0]) & 0xF;
 801e998:	687b      	ldr	r3, [r7, #4]
 801e99a:	781b      	ldrb	r3, [r3, #0]
 801e99c:	f003 030f 	and.w	r3, r3, #15
 801e9a0:	60fb      	str	r3, [r7, #12]
        cp = (cp << 6) | (string[1] & 0x3F);
 801e9a2:	68fb      	ldr	r3, [r7, #12]
 801e9a4:	019a      	lsls	r2, r3, #6
 801e9a6:	687b      	ldr	r3, [r7, #4]
 801e9a8:	3301      	adds	r3, #1
 801e9aa:	781b      	ldrb	r3, [r3, #0]
 801e9ac:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 801e9b0:	4313      	orrs	r3, r2
 801e9b2:	60fb      	str	r3, [r7, #12]
        cp = (cp << 6) | (string[2] & 0x3F);
 801e9b4:	68fb      	ldr	r3, [r7, #12]
 801e9b6:	019a      	lsls	r2, r3, #6
 801e9b8:	687b      	ldr	r3, [r7, #4]
 801e9ba:	3302      	adds	r3, #2
 801e9bc:	781b      	ldrb	r3, [r3, #0]
 801e9be:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 801e9c2:	4313      	orrs	r3, r2
 801e9c4:	60fb      	str	r3, [r7, #12]
 801e9c6:	e03c      	b.n	801ea42 <verify_utf8_sequence+0x130>
    } else if (*len == 4 && IS_CONT(string[1]) && IS_CONT(string[2]) && IS_CONT(string[3])) {
 801e9c8:	683b      	ldr	r3, [r7, #0]
 801e9ca:	681b      	ldr	r3, [r3, #0]
 801e9cc:	2b04      	cmp	r3, #4
 801e9ce:	d135      	bne.n	801ea3c <verify_utf8_sequence+0x12a>
 801e9d0:	687b      	ldr	r3, [r7, #4]
 801e9d2:	3301      	adds	r3, #1
 801e9d4:	781b      	ldrb	r3, [r3, #0]
 801e9d6:	f003 03c0 	and.w	r3, r3, #192	@ 0xc0
 801e9da:	2b80      	cmp	r3, #128	@ 0x80
 801e9dc:	d12e      	bne.n	801ea3c <verify_utf8_sequence+0x12a>
 801e9de:	687b      	ldr	r3, [r7, #4]
 801e9e0:	3302      	adds	r3, #2
 801e9e2:	781b      	ldrb	r3, [r3, #0]
 801e9e4:	f003 03c0 	and.w	r3, r3, #192	@ 0xc0
 801e9e8:	2b80      	cmp	r3, #128	@ 0x80
 801e9ea:	d127      	bne.n	801ea3c <verify_utf8_sequence+0x12a>
 801e9ec:	687b      	ldr	r3, [r7, #4]
 801e9ee:	3303      	adds	r3, #3
 801e9f0:	781b      	ldrb	r3, [r3, #0]
 801e9f2:	f003 03c0 	and.w	r3, r3, #192	@ 0xc0
 801e9f6:	2b80      	cmp	r3, #128	@ 0x80
 801e9f8:	d120      	bne.n	801ea3c <verify_utf8_sequence+0x12a>
        cp = string[0] & 0x7;
 801e9fa:	687b      	ldr	r3, [r7, #4]
 801e9fc:	781b      	ldrb	r3, [r3, #0]
 801e9fe:	f003 0307 	and.w	r3, r3, #7
 801ea02:	60fb      	str	r3, [r7, #12]
        cp = (cp << 6) | (string[1] & 0x3F);
 801ea04:	68fb      	ldr	r3, [r7, #12]
 801ea06:	019a      	lsls	r2, r3, #6
 801ea08:	687b      	ldr	r3, [r7, #4]
 801ea0a:	3301      	adds	r3, #1
 801ea0c:	781b      	ldrb	r3, [r3, #0]
 801ea0e:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 801ea12:	4313      	orrs	r3, r2
 801ea14:	60fb      	str	r3, [r7, #12]
        cp = (cp << 6) | (string[2] & 0x3F);
 801ea16:	68fb      	ldr	r3, [r7, #12]
 801ea18:	019a      	lsls	r2, r3, #6
 801ea1a:	687b      	ldr	r3, [r7, #4]
 801ea1c:	3302      	adds	r3, #2
 801ea1e:	781b      	ldrb	r3, [r3, #0]
 801ea20:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 801ea24:	4313      	orrs	r3, r2
 801ea26:	60fb      	str	r3, [r7, #12]
        cp = (cp << 6) | (string[3] & 0x3F);
 801ea28:	68fb      	ldr	r3, [r7, #12]
 801ea2a:	019a      	lsls	r2, r3, #6
 801ea2c:	687b      	ldr	r3, [r7, #4]
 801ea2e:	3303      	adds	r3, #3
 801ea30:	781b      	ldrb	r3, [r3, #0]
 801ea32:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 801ea36:	4313      	orrs	r3, r2
 801ea38:	60fb      	str	r3, [r7, #12]
 801ea3a:	e002      	b.n	801ea42 <verify_utf8_sequence+0x130>
    } else {
        return JSONFailure;
 801ea3c:	f04f 33ff 	mov.w	r3, #4294967295
 801ea40:	e02c      	b.n	801ea9c <verify_utf8_sequence+0x18a>
    }

    /* overlong encodings */
    if ((cp < 0x80    && *len > 1) ||
 801ea42:	68fb      	ldr	r3, [r7, #12]
 801ea44:	2b7f      	cmp	r3, #127	@ 0x7f
 801ea46:	d803      	bhi.n	801ea50 <verify_utf8_sequence+0x13e>
 801ea48:	683b      	ldr	r3, [r7, #0]
 801ea4a:	681b      	ldr	r3, [r3, #0]
 801ea4c:	2b01      	cmp	r3, #1
 801ea4e:	dc0f      	bgt.n	801ea70 <verify_utf8_sequence+0x15e>
 801ea50:	68fb      	ldr	r3, [r7, #12]
 801ea52:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 801ea56:	d203      	bcs.n	801ea60 <verify_utf8_sequence+0x14e>
        (cp < 0x800   && *len > 2) ||
 801ea58:	683b      	ldr	r3, [r7, #0]
 801ea5a:	681b      	ldr	r3, [r3, #0]
 801ea5c:	2b02      	cmp	r3, #2
 801ea5e:	dc07      	bgt.n	801ea70 <verify_utf8_sequence+0x15e>
 801ea60:	68fb      	ldr	r3, [r7, #12]
 801ea62:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 801ea66:	d206      	bcs.n	801ea76 <verify_utf8_sequence+0x164>
        (cp < 0x10000 && *len > 3)) {
 801ea68:	683b      	ldr	r3, [r7, #0]
 801ea6a:	681b      	ldr	r3, [r3, #0]
 801ea6c:	2b03      	cmp	r3, #3
 801ea6e:	dd02      	ble.n	801ea76 <verify_utf8_sequence+0x164>
        return JSONFailure;
 801ea70:	f04f 33ff 	mov.w	r3, #4294967295
 801ea74:	e012      	b.n	801ea9c <verify_utf8_sequence+0x18a>
    }

    /* invalid unicode */
    if (cp > 0x10FFFF) {
 801ea76:	68fb      	ldr	r3, [r7, #12]
 801ea78:	f5b3 1f88 	cmp.w	r3, #1114112	@ 0x110000
 801ea7c:	d302      	bcc.n	801ea84 <verify_utf8_sequence+0x172>
        return JSONFailure;
 801ea7e:	f04f 33ff 	mov.w	r3, #4294967295
 801ea82:	e00b      	b.n	801ea9c <verify_utf8_sequence+0x18a>
    }

    /* surrogate halves */
    if (cp >= 0xD800 && cp <= 0xDFFF) {
 801ea84:	68fb      	ldr	r3, [r7, #12]
 801ea86:	f5b3 4f58 	cmp.w	r3, #55296	@ 0xd800
 801ea8a:	d306      	bcc.n	801ea9a <verify_utf8_sequence+0x188>
 801ea8c:	68fb      	ldr	r3, [r7, #12]
 801ea8e:	f5b3 4f60 	cmp.w	r3, #57344	@ 0xe000
 801ea92:	d202      	bcs.n	801ea9a <verify_utf8_sequence+0x188>
        return JSONFailure;
 801ea94:	f04f 33ff 	mov.w	r3, #4294967295
 801ea98:	e000      	b.n	801ea9c <verify_utf8_sequence+0x18a>
    }

    return JSONSuccess;
 801ea9a:	2300      	movs	r3, #0
}
 801ea9c:	4618      	mov	r0, r3
 801ea9e:	3710      	adds	r7, #16
 801eaa0:	46bd      	mov	sp, r7
 801eaa2:	bd80      	pop	{r7, pc}

0801eaa4 <is_valid_utf8>:

static int is_valid_utf8(const char *string, size_t string_len) {
 801eaa4:	b580      	push	{r7, lr}
 801eaa6:	b084      	sub	sp, #16
 801eaa8:	af00      	add	r7, sp, #0
 801eaaa:	6078      	str	r0, [r7, #4]
 801eaac:	6039      	str	r1, [r7, #0]
    int len = 0;
 801eaae:	2300      	movs	r3, #0
 801eab0:	60bb      	str	r3, [r7, #8]
    const char *string_end =  string + string_len;
 801eab2:	687a      	ldr	r2, [r7, #4]
 801eab4:	683b      	ldr	r3, [r7, #0]
 801eab6:	4413      	add	r3, r2
 801eab8:	60fb      	str	r3, [r7, #12]
    while (string < string_end) {
 801eaba:	e00f      	b.n	801eadc <is_valid_utf8+0x38>
        if (verify_utf8_sequence((const unsigned char*)string, &len) != JSONSuccess) {
 801eabc:	f107 0308 	add.w	r3, r7, #8
 801eac0:	4619      	mov	r1, r3
 801eac2:	6878      	ldr	r0, [r7, #4]
 801eac4:	f7ff ff25 	bl	801e912 <verify_utf8_sequence>
 801eac8:	4603      	mov	r3, r0
 801eaca:	2b00      	cmp	r3, #0
 801eacc:	d001      	beq.n	801ead2 <is_valid_utf8+0x2e>
            return PARSON_FALSE;
 801eace:	2300      	movs	r3, #0
 801ead0:	e009      	b.n	801eae6 <is_valid_utf8+0x42>
        }
        string += len;
 801ead2:	68bb      	ldr	r3, [r7, #8]
 801ead4:	461a      	mov	r2, r3
 801ead6:	687b      	ldr	r3, [r7, #4]
 801ead8:	4413      	add	r3, r2
 801eada:	607b      	str	r3, [r7, #4]
    while (string < string_end) {
 801eadc:	687a      	ldr	r2, [r7, #4]
 801eade:	68fb      	ldr	r3, [r7, #12]
 801eae0:	429a      	cmp	r2, r3
 801eae2:	d3eb      	bcc.n	801eabc <is_valid_utf8+0x18>
    }
    return PARSON_TRUE;
 801eae4:	2301      	movs	r3, #1
}
 801eae6:	4618      	mov	r0, r3
 801eae8:	3710      	adds	r7, #16
 801eaea:	46bd      	mov	sp, r7
 801eaec:	bd80      	pop	{r7, pc}
	...

0801eaf0 <is_decimal>:

static parson_bool_t is_decimal(const char *string, size_t length) {
 801eaf0:	b580      	push	{r7, lr}
 801eaf2:	b082      	sub	sp, #8
 801eaf4:	af00      	add	r7, sp, #0
 801eaf6:	6078      	str	r0, [r7, #4]
 801eaf8:	6039      	str	r1, [r7, #0]
    if (length > 1 && string[0] == '0' && string[1] != '.') {
 801eafa:	683b      	ldr	r3, [r7, #0]
 801eafc:	2b01      	cmp	r3, #1
 801eafe:	d90a      	bls.n	801eb16 <is_decimal+0x26>
 801eb00:	687b      	ldr	r3, [r7, #4]
 801eb02:	781b      	ldrb	r3, [r3, #0]
 801eb04:	2b30      	cmp	r3, #48	@ 0x30
 801eb06:	d106      	bne.n	801eb16 <is_decimal+0x26>
 801eb08:	687b      	ldr	r3, [r7, #4]
 801eb0a:	3301      	adds	r3, #1
 801eb0c:	781b      	ldrb	r3, [r3, #0]
 801eb0e:	2b2e      	cmp	r3, #46	@ 0x2e
 801eb10:	d001      	beq.n	801eb16 <is_decimal+0x26>
        return PARSON_FALSE;
 801eb12:	2300      	movs	r3, #0
 801eb14:	e024      	b.n	801eb60 <is_decimal+0x70>
    }
    if (length > 2 && !strncmp(string, "-0", 2) && string[2] != '.') {
 801eb16:	683b      	ldr	r3, [r7, #0]
 801eb18:	2b02      	cmp	r3, #2
 801eb1a:	d91b      	bls.n	801eb54 <is_decimal+0x64>
 801eb1c:	2202      	movs	r2, #2
 801eb1e:	4912      	ldr	r1, [pc, #72]	@ (801eb68 <is_decimal+0x78>)
 801eb20:	6878      	ldr	r0, [r7, #4]
 801eb22:	f005 fab4 	bl	802408e <strncmp>
 801eb26:	4603      	mov	r3, r0
 801eb28:	2b00      	cmp	r3, #0
 801eb2a:	d113      	bne.n	801eb54 <is_decimal+0x64>
 801eb2c:	687b      	ldr	r3, [r7, #4]
 801eb2e:	3302      	adds	r3, #2
 801eb30:	781b      	ldrb	r3, [r3, #0]
 801eb32:	2b2e      	cmp	r3, #46	@ 0x2e
 801eb34:	d00e      	beq.n	801eb54 <is_decimal+0x64>
        return PARSON_FALSE;
 801eb36:	2300      	movs	r3, #0
 801eb38:	e012      	b.n	801eb60 <is_decimal+0x70>
    }
    while (length--) {
        if (strchr("xX", string[length])) {
 801eb3a:	687a      	ldr	r2, [r7, #4]
 801eb3c:	683b      	ldr	r3, [r7, #0]
 801eb3e:	4413      	add	r3, r2
 801eb40:	781b      	ldrb	r3, [r3, #0]
 801eb42:	4619      	mov	r1, r3
 801eb44:	4809      	ldr	r0, [pc, #36]	@ (801eb6c <is_decimal+0x7c>)
 801eb46:	f005 fa95 	bl	8024074 <strchr>
 801eb4a:	4603      	mov	r3, r0
 801eb4c:	2b00      	cmp	r3, #0
 801eb4e:	d001      	beq.n	801eb54 <is_decimal+0x64>
            return PARSON_FALSE;
 801eb50:	2300      	movs	r3, #0
 801eb52:	e005      	b.n	801eb60 <is_decimal+0x70>
    while (length--) {
 801eb54:	683b      	ldr	r3, [r7, #0]
 801eb56:	1e5a      	subs	r2, r3, #1
 801eb58:	603a      	str	r2, [r7, #0]
 801eb5a:	2b00      	cmp	r3, #0
 801eb5c:	d1ed      	bne.n	801eb3a <is_decimal+0x4a>
        }
    }
    return PARSON_TRUE;
 801eb5e:	2301      	movs	r3, #1
}
 801eb60:	4618      	mov	r0, r3
 801eb62:	3708      	adds	r7, #8
 801eb64:	46bd      	mov	sp, r7
 801eb66:	bd80      	pop	{r7, pc}
 801eb68:	0802a2c8 	.word	0x0802a2c8
 801eb6c:	0802a2cc 	.word	0x0802a2cc

0801eb70 <hash_string>:

static unsigned long hash_string(const char *string, size_t n) {
 801eb70:	b480      	push	{r7}
 801eb72:	b087      	sub	sp, #28
 801eb74:	af00      	add	r7, sp, #0
 801eb76:	6078      	str	r0, [r7, #4]
 801eb78:	6039      	str	r1, [r7, #0]
#ifdef PARSON_FORCE_HASH_COLLISIONS
    (void)string;
    (void)n;
    return 0;
#else
    unsigned long hash = 5381;
 801eb7a:	f241 5305 	movw	r3, #5381	@ 0x1505
 801eb7e:	617b      	str	r3, [r7, #20]
    unsigned char c;
    size_t i = 0;
 801eb80:	2300      	movs	r3, #0
 801eb82:	613b      	str	r3, [r7, #16]
    for (i = 0; i < n; i++) {
 801eb84:	2300      	movs	r3, #0
 801eb86:	613b      	str	r3, [r7, #16]
 801eb88:	e011      	b.n	801ebae <hash_string+0x3e>
        c = string[i];
 801eb8a:	687a      	ldr	r2, [r7, #4]
 801eb8c:	693b      	ldr	r3, [r7, #16]
 801eb8e:	4413      	add	r3, r2
 801eb90:	781b      	ldrb	r3, [r3, #0]
 801eb92:	73fb      	strb	r3, [r7, #15]
        if (c == '\0') {
 801eb94:	7bfb      	ldrb	r3, [r7, #15]
 801eb96:	2b00      	cmp	r3, #0
 801eb98:	d00e      	beq.n	801ebb8 <hash_string+0x48>
            break;
        }
        hash = ((hash << 5) + hash) + c; /* hash * 33 + c */
 801eb9a:	697b      	ldr	r3, [r7, #20]
 801eb9c:	015a      	lsls	r2, r3, #5
 801eb9e:	697b      	ldr	r3, [r7, #20]
 801eba0:	441a      	add	r2, r3
 801eba2:	7bfb      	ldrb	r3, [r7, #15]
 801eba4:	4413      	add	r3, r2
 801eba6:	617b      	str	r3, [r7, #20]
    for (i = 0; i < n; i++) {
 801eba8:	693b      	ldr	r3, [r7, #16]
 801ebaa:	3301      	adds	r3, #1
 801ebac:	613b      	str	r3, [r7, #16]
 801ebae:	693a      	ldr	r2, [r7, #16]
 801ebb0:	683b      	ldr	r3, [r7, #0]
 801ebb2:	429a      	cmp	r2, r3
 801ebb4:	d3e9      	bcc.n	801eb8a <hash_string+0x1a>
 801ebb6:	e000      	b.n	801ebba <hash_string+0x4a>
            break;
 801ebb8:	bf00      	nop
    }
    return hash;
 801ebba:	697b      	ldr	r3, [r7, #20]
#endif
}
 801ebbc:	4618      	mov	r0, r3
 801ebbe:	371c      	adds	r7, #28
 801ebc0:	46bd      	mov	sp, r7
 801ebc2:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ebc6:	4770      	bx	lr

0801ebc8 <json_object_make>:

/* JSON Object */
static JSON_Object * json_object_make(JSON_Value *wrapping_value) {
 801ebc8:	b580      	push	{r7, lr}
 801ebca:	b084      	sub	sp, #16
 801ebcc:	af00      	add	r7, sp, #0
 801ebce:	6078      	str	r0, [r7, #4]
    JSON_Status res = JSONFailure;
 801ebd0:	f04f 33ff 	mov.w	r3, #4294967295
 801ebd4:	60fb      	str	r3, [r7, #12]
    JSON_Object *new_obj = (JSON_Object*)parson_malloc(sizeof(JSON_Object));
 801ebd6:	4b10      	ldr	r3, [pc, #64]	@ (801ec18 <json_object_make+0x50>)
 801ebd8:	681b      	ldr	r3, [r3, #0]
 801ebda:	2024      	movs	r0, #36	@ 0x24
 801ebdc:	4798      	blx	r3
 801ebde:	60b8      	str	r0, [r7, #8]
    if (new_obj == NULL) {
 801ebe0:	68bb      	ldr	r3, [r7, #8]
 801ebe2:	2b00      	cmp	r3, #0
 801ebe4:	d101      	bne.n	801ebea <json_object_make+0x22>
        return NULL;
 801ebe6:	2300      	movs	r3, #0
 801ebe8:	e011      	b.n	801ec0e <json_object_make+0x46>
    }
    new_obj->wrapping_value = wrapping_value;
 801ebea:	68bb      	ldr	r3, [r7, #8]
 801ebec:	687a      	ldr	r2, [r7, #4]
 801ebee:	601a      	str	r2, [r3, #0]
    res = json_object_init(new_obj, 0);
 801ebf0:	2100      	movs	r1, #0
 801ebf2:	68b8      	ldr	r0, [r7, #8]
 801ebf4:	f000 f814 	bl	801ec20 <json_object_init>
 801ebf8:	60f8      	str	r0, [r7, #12]
    if (res != JSONSuccess) {
 801ebfa:	68fb      	ldr	r3, [r7, #12]
 801ebfc:	2b00      	cmp	r3, #0
 801ebfe:	d005      	beq.n	801ec0c <json_object_make+0x44>
        parson_free(new_obj);
 801ec00:	4b06      	ldr	r3, [pc, #24]	@ (801ec1c <json_object_make+0x54>)
 801ec02:	681b      	ldr	r3, [r3, #0]
 801ec04:	68b8      	ldr	r0, [r7, #8]
 801ec06:	4798      	blx	r3
        return NULL;
 801ec08:	2300      	movs	r3, #0
 801ec0a:	e000      	b.n	801ec0e <json_object_make+0x46>
    }
    return new_obj;
 801ec0c:	68bb      	ldr	r3, [r7, #8]
}
 801ec0e:	4618      	mov	r0, r3
 801ec10:	3710      	adds	r7, #16
 801ec12:	46bd      	mov	sp, r7
 801ec14:	bd80      	pop	{r7, pc}
 801ec16:	bf00      	nop
 801ec18:	20000210 	.word	0x20000210
 801ec1c:	20000214 	.word	0x20000214

0801ec20 <json_object_init>:

static JSON_Status json_object_init(JSON_Object *object, size_t capacity) {
 801ec20:	b580      	push	{r7, lr}
 801ec22:	b084      	sub	sp, #16
 801ec24:	af00      	add	r7, sp, #0
 801ec26:	6078      	str	r0, [r7, #4]
 801ec28:	6039      	str	r1, [r7, #0]
    unsigned int i = 0;
 801ec2a:	2300      	movs	r3, #0
 801ec2c:	60fb      	str	r3, [r7, #12]

    object->cells = NULL;
 801ec2e:	687b      	ldr	r3, [r7, #4]
 801ec30:	2200      	movs	r2, #0
 801ec32:	605a      	str	r2, [r3, #4]
    object->names = NULL;
 801ec34:	687b      	ldr	r3, [r7, #4]
 801ec36:	2200      	movs	r2, #0
 801ec38:	60da      	str	r2, [r3, #12]
    object->values = NULL;
 801ec3a:	687b      	ldr	r3, [r7, #4]
 801ec3c:	2200      	movs	r2, #0
 801ec3e:	611a      	str	r2, [r3, #16]
    object->cell_ixs = NULL;
 801ec40:	687b      	ldr	r3, [r7, #4]
 801ec42:	2200      	movs	r2, #0
 801ec44:	615a      	str	r2, [r3, #20]
    object->hashes = NULL;
 801ec46:	687b      	ldr	r3, [r7, #4]
 801ec48:	2200      	movs	r2, #0
 801ec4a:	609a      	str	r2, [r3, #8]

    object->count = 0;
 801ec4c:	687b      	ldr	r3, [r7, #4]
 801ec4e:	2200      	movs	r2, #0
 801ec50:	619a      	str	r2, [r3, #24]
    object->cell_capacity = capacity;
 801ec52:	687b      	ldr	r3, [r7, #4]
 801ec54:	683a      	ldr	r2, [r7, #0]
 801ec56:	621a      	str	r2, [r3, #32]
    object->item_capacity = (unsigned int)(capacity * 7/10);
 801ec58:	683a      	ldr	r2, [r7, #0]
 801ec5a:	4613      	mov	r3, r2
 801ec5c:	00db      	lsls	r3, r3, #3
 801ec5e:	1a9b      	subs	r3, r3, r2
 801ec60:	4a45      	ldr	r2, [pc, #276]	@ (801ed78 <json_object_init+0x158>)
 801ec62:	fba2 2303 	umull	r2, r3, r2, r3
 801ec66:	08da      	lsrs	r2, r3, #3
 801ec68:	687b      	ldr	r3, [r7, #4]
 801ec6a:	61da      	str	r2, [r3, #28]

    if (capacity == 0) {
 801ec6c:	683b      	ldr	r3, [r7, #0]
 801ec6e:	2b00      	cmp	r3, #0
 801ec70:	d101      	bne.n	801ec76 <json_object_init+0x56>
        return JSONSuccess;
 801ec72:	2300      	movs	r3, #0
 801ec74:	e07b      	b.n	801ed6e <json_object_init+0x14e>
    }

    object->cells = (size_t*)parson_malloc(object->cell_capacity * sizeof(*object->cells));
 801ec76:	4b41      	ldr	r3, [pc, #260]	@ (801ed7c <json_object_init+0x15c>)
 801ec78:	681b      	ldr	r3, [r3, #0]
 801ec7a:	687a      	ldr	r2, [r7, #4]
 801ec7c:	6a12      	ldr	r2, [r2, #32]
 801ec7e:	0092      	lsls	r2, r2, #2
 801ec80:	4610      	mov	r0, r2
 801ec82:	4798      	blx	r3
 801ec84:	4602      	mov	r2, r0
 801ec86:	687b      	ldr	r3, [r7, #4]
 801ec88:	605a      	str	r2, [r3, #4]
    object->names = (char**)parson_malloc(object->item_capacity * sizeof(*object->names));
 801ec8a:	4b3c      	ldr	r3, [pc, #240]	@ (801ed7c <json_object_init+0x15c>)
 801ec8c:	681b      	ldr	r3, [r3, #0]
 801ec8e:	687a      	ldr	r2, [r7, #4]
 801ec90:	69d2      	ldr	r2, [r2, #28]
 801ec92:	0092      	lsls	r2, r2, #2
 801ec94:	4610      	mov	r0, r2
 801ec96:	4798      	blx	r3
 801ec98:	4602      	mov	r2, r0
 801ec9a:	687b      	ldr	r3, [r7, #4]
 801ec9c:	60da      	str	r2, [r3, #12]
    object->values = (JSON_Value**)parson_malloc(object->item_capacity * sizeof(*object->values));
 801ec9e:	4b37      	ldr	r3, [pc, #220]	@ (801ed7c <json_object_init+0x15c>)
 801eca0:	681b      	ldr	r3, [r3, #0]
 801eca2:	687a      	ldr	r2, [r7, #4]
 801eca4:	69d2      	ldr	r2, [r2, #28]
 801eca6:	0092      	lsls	r2, r2, #2
 801eca8:	4610      	mov	r0, r2
 801ecaa:	4798      	blx	r3
 801ecac:	4602      	mov	r2, r0
 801ecae:	687b      	ldr	r3, [r7, #4]
 801ecb0:	611a      	str	r2, [r3, #16]
    object->cell_ixs = (size_t*)parson_malloc(object->item_capacity * sizeof(*object->cell_ixs));
 801ecb2:	4b32      	ldr	r3, [pc, #200]	@ (801ed7c <json_object_init+0x15c>)
 801ecb4:	681b      	ldr	r3, [r3, #0]
 801ecb6:	687a      	ldr	r2, [r7, #4]
 801ecb8:	69d2      	ldr	r2, [r2, #28]
 801ecba:	0092      	lsls	r2, r2, #2
 801ecbc:	4610      	mov	r0, r2
 801ecbe:	4798      	blx	r3
 801ecc0:	4602      	mov	r2, r0
 801ecc2:	687b      	ldr	r3, [r7, #4]
 801ecc4:	615a      	str	r2, [r3, #20]
    object->hashes = (unsigned long*)parson_malloc(object->item_capacity * sizeof(*object->hashes));
 801ecc6:	4b2d      	ldr	r3, [pc, #180]	@ (801ed7c <json_object_init+0x15c>)
 801ecc8:	681b      	ldr	r3, [r3, #0]
 801ecca:	687a      	ldr	r2, [r7, #4]
 801eccc:	69d2      	ldr	r2, [r2, #28]
 801ecce:	0092      	lsls	r2, r2, #2
 801ecd0:	4610      	mov	r0, r2
 801ecd2:	4798      	blx	r3
 801ecd4:	4602      	mov	r2, r0
 801ecd6:	687b      	ldr	r3, [r7, #4]
 801ecd8:	609a      	str	r2, [r3, #8]
    if (object->cells == NULL
 801ecda:	687b      	ldr	r3, [r7, #4]
 801ecdc:	685b      	ldr	r3, [r3, #4]
 801ecde:	2b00      	cmp	r3, #0
 801ece0:	d024      	beq.n	801ed2c <json_object_init+0x10c>
        || object->names == NULL
 801ece2:	687b      	ldr	r3, [r7, #4]
 801ece4:	68db      	ldr	r3, [r3, #12]
 801ece6:	2b00      	cmp	r3, #0
 801ece8:	d020      	beq.n	801ed2c <json_object_init+0x10c>
        || object->values == NULL
 801ecea:	687b      	ldr	r3, [r7, #4]
 801ecec:	691b      	ldr	r3, [r3, #16]
 801ecee:	2b00      	cmp	r3, #0
 801ecf0:	d01c      	beq.n	801ed2c <json_object_init+0x10c>
        || object->cell_ixs == NULL
 801ecf2:	687b      	ldr	r3, [r7, #4]
 801ecf4:	695b      	ldr	r3, [r3, #20]
 801ecf6:	2b00      	cmp	r3, #0
 801ecf8:	d018      	beq.n	801ed2c <json_object_init+0x10c>
        || object->hashes == NULL) {
 801ecfa:	687b      	ldr	r3, [r7, #4]
 801ecfc:	689b      	ldr	r3, [r3, #8]
 801ecfe:	2b00      	cmp	r3, #0
 801ed00:	d014      	beq.n	801ed2c <json_object_init+0x10c>
        goto error;
    }
    for (i = 0; i < object->cell_capacity; i++) {
 801ed02:	2300      	movs	r3, #0
 801ed04:	60fb      	str	r3, [r7, #12]
 801ed06:	e00a      	b.n	801ed1e <json_object_init+0xfe>
        object->cells[i] = OBJECT_INVALID_IX;
 801ed08:	687b      	ldr	r3, [r7, #4]
 801ed0a:	685a      	ldr	r2, [r3, #4]
 801ed0c:	68fb      	ldr	r3, [r7, #12]
 801ed0e:	009b      	lsls	r3, r3, #2
 801ed10:	4413      	add	r3, r2
 801ed12:	f04f 32ff 	mov.w	r2, #4294967295
 801ed16:	601a      	str	r2, [r3, #0]
    for (i = 0; i < object->cell_capacity; i++) {
 801ed18:	68fb      	ldr	r3, [r7, #12]
 801ed1a:	3301      	adds	r3, #1
 801ed1c:	60fb      	str	r3, [r7, #12]
 801ed1e:	687b      	ldr	r3, [r7, #4]
 801ed20:	6a1b      	ldr	r3, [r3, #32]
 801ed22:	68fa      	ldr	r2, [r7, #12]
 801ed24:	429a      	cmp	r2, r3
 801ed26:	d3ef      	bcc.n	801ed08 <json_object_init+0xe8>
    }
    return JSONSuccess;
 801ed28:	2300      	movs	r3, #0
 801ed2a:	e020      	b.n	801ed6e <json_object_init+0x14e>
        goto error;
 801ed2c:	bf00      	nop
error:
    parson_free(object->cells);
 801ed2e:	4b14      	ldr	r3, [pc, #80]	@ (801ed80 <json_object_init+0x160>)
 801ed30:	681b      	ldr	r3, [r3, #0]
 801ed32:	687a      	ldr	r2, [r7, #4]
 801ed34:	6852      	ldr	r2, [r2, #4]
 801ed36:	4610      	mov	r0, r2
 801ed38:	4798      	blx	r3
    parson_free(object->names);
 801ed3a:	4b11      	ldr	r3, [pc, #68]	@ (801ed80 <json_object_init+0x160>)
 801ed3c:	681b      	ldr	r3, [r3, #0]
 801ed3e:	687a      	ldr	r2, [r7, #4]
 801ed40:	68d2      	ldr	r2, [r2, #12]
 801ed42:	4610      	mov	r0, r2
 801ed44:	4798      	blx	r3
    parson_free(object->values);
 801ed46:	4b0e      	ldr	r3, [pc, #56]	@ (801ed80 <json_object_init+0x160>)
 801ed48:	681b      	ldr	r3, [r3, #0]
 801ed4a:	687a      	ldr	r2, [r7, #4]
 801ed4c:	6912      	ldr	r2, [r2, #16]
 801ed4e:	4610      	mov	r0, r2
 801ed50:	4798      	blx	r3
    parson_free(object->cell_ixs);
 801ed52:	4b0b      	ldr	r3, [pc, #44]	@ (801ed80 <json_object_init+0x160>)
 801ed54:	681b      	ldr	r3, [r3, #0]
 801ed56:	687a      	ldr	r2, [r7, #4]
 801ed58:	6952      	ldr	r2, [r2, #20]
 801ed5a:	4610      	mov	r0, r2
 801ed5c:	4798      	blx	r3
    parson_free(object->hashes);
 801ed5e:	4b08      	ldr	r3, [pc, #32]	@ (801ed80 <json_object_init+0x160>)
 801ed60:	681b      	ldr	r3, [r3, #0]
 801ed62:	687a      	ldr	r2, [r7, #4]
 801ed64:	6892      	ldr	r2, [r2, #8]
 801ed66:	4610      	mov	r0, r2
 801ed68:	4798      	blx	r3
    return JSONFailure;
 801ed6a:	f04f 33ff 	mov.w	r3, #4294967295
}
 801ed6e:	4618      	mov	r0, r3
 801ed70:	3710      	adds	r7, #16
 801ed72:	46bd      	mov	sp, r7
 801ed74:	bd80      	pop	{r7, pc}
 801ed76:	bf00      	nop
 801ed78:	cccccccd 	.word	0xcccccccd
 801ed7c:	20000210 	.word	0x20000210
 801ed80:	20000214 	.word	0x20000214

0801ed84 <json_object_deinit>:

static void json_object_deinit(JSON_Object *object, parson_bool_t free_keys, parson_bool_t free_values) {
 801ed84:	b580      	push	{r7, lr}
 801ed86:	b086      	sub	sp, #24
 801ed88:	af00      	add	r7, sp, #0
 801ed8a:	60f8      	str	r0, [r7, #12]
 801ed8c:	60b9      	str	r1, [r7, #8]
 801ed8e:	607a      	str	r2, [r7, #4]
    unsigned int i = 0;
 801ed90:	2300      	movs	r3, #0
 801ed92:	617b      	str	r3, [r7, #20]
    for (i = 0; i < object->count; i++) {
 801ed94:	2300      	movs	r3, #0
 801ed96:	617b      	str	r3, [r7, #20]
 801ed98:	e01b      	b.n	801edd2 <json_object_deinit+0x4e>
        if (free_keys) {
 801ed9a:	68bb      	ldr	r3, [r7, #8]
 801ed9c:	2b00      	cmp	r3, #0
 801ed9e:	d009      	beq.n	801edb4 <json_object_deinit+0x30>
            parson_free(object->names[i]);
 801eda0:	4b2b      	ldr	r3, [pc, #172]	@ (801ee50 <json_object_deinit+0xcc>)
 801eda2:	681b      	ldr	r3, [r3, #0]
 801eda4:	68fa      	ldr	r2, [r7, #12]
 801eda6:	68d1      	ldr	r1, [r2, #12]
 801eda8:	697a      	ldr	r2, [r7, #20]
 801edaa:	0092      	lsls	r2, r2, #2
 801edac:	440a      	add	r2, r1
 801edae:	6812      	ldr	r2, [r2, #0]
 801edb0:	4610      	mov	r0, r2
 801edb2:	4798      	blx	r3
        }
        if (free_values) {
 801edb4:	687b      	ldr	r3, [r7, #4]
 801edb6:	2b00      	cmp	r3, #0
 801edb8:	d008      	beq.n	801edcc <json_object_deinit+0x48>
            json_value_free(object->values[i]);
 801edba:	68fb      	ldr	r3, [r7, #12]
 801edbc:	691a      	ldr	r2, [r3, #16]
 801edbe:	697b      	ldr	r3, [r7, #20]
 801edc0:	009b      	lsls	r3, r3, #2
 801edc2:	4413      	add	r3, r2
 801edc4:	681b      	ldr	r3, [r3, #0]
 801edc6:	4618      	mov	r0, r3
 801edc8:	f002 fcb8 	bl	802173c <json_value_free>
    for (i = 0; i < object->count; i++) {
 801edcc:	697b      	ldr	r3, [r7, #20]
 801edce:	3301      	adds	r3, #1
 801edd0:	617b      	str	r3, [r7, #20]
 801edd2:	68fb      	ldr	r3, [r7, #12]
 801edd4:	699b      	ldr	r3, [r3, #24]
 801edd6:	697a      	ldr	r2, [r7, #20]
 801edd8:	429a      	cmp	r2, r3
 801edda:	d3de      	bcc.n	801ed9a <json_object_deinit+0x16>
        }
    }

    object->count = 0;
 801eddc:	68fb      	ldr	r3, [r7, #12]
 801edde:	2200      	movs	r2, #0
 801ede0:	619a      	str	r2, [r3, #24]
    object->item_capacity = 0;
 801ede2:	68fb      	ldr	r3, [r7, #12]
 801ede4:	2200      	movs	r2, #0
 801ede6:	61da      	str	r2, [r3, #28]
    object->cell_capacity = 0;
 801ede8:	68fb      	ldr	r3, [r7, #12]
 801edea:	2200      	movs	r2, #0
 801edec:	621a      	str	r2, [r3, #32]

    parson_free(object->cells);
 801edee:	4b18      	ldr	r3, [pc, #96]	@ (801ee50 <json_object_deinit+0xcc>)
 801edf0:	681b      	ldr	r3, [r3, #0]
 801edf2:	68fa      	ldr	r2, [r7, #12]
 801edf4:	6852      	ldr	r2, [r2, #4]
 801edf6:	4610      	mov	r0, r2
 801edf8:	4798      	blx	r3
    parson_free(object->names);
 801edfa:	4b15      	ldr	r3, [pc, #84]	@ (801ee50 <json_object_deinit+0xcc>)
 801edfc:	681b      	ldr	r3, [r3, #0]
 801edfe:	68fa      	ldr	r2, [r7, #12]
 801ee00:	68d2      	ldr	r2, [r2, #12]
 801ee02:	4610      	mov	r0, r2
 801ee04:	4798      	blx	r3
    parson_free(object->values);
 801ee06:	4b12      	ldr	r3, [pc, #72]	@ (801ee50 <json_object_deinit+0xcc>)
 801ee08:	681b      	ldr	r3, [r3, #0]
 801ee0a:	68fa      	ldr	r2, [r7, #12]
 801ee0c:	6912      	ldr	r2, [r2, #16]
 801ee0e:	4610      	mov	r0, r2
 801ee10:	4798      	blx	r3
    parson_free(object->cell_ixs);
 801ee12:	4b0f      	ldr	r3, [pc, #60]	@ (801ee50 <json_object_deinit+0xcc>)
 801ee14:	681b      	ldr	r3, [r3, #0]
 801ee16:	68fa      	ldr	r2, [r7, #12]
 801ee18:	6952      	ldr	r2, [r2, #20]
 801ee1a:	4610      	mov	r0, r2
 801ee1c:	4798      	blx	r3
    parson_free(object->hashes);
 801ee1e:	4b0c      	ldr	r3, [pc, #48]	@ (801ee50 <json_object_deinit+0xcc>)
 801ee20:	681b      	ldr	r3, [r3, #0]
 801ee22:	68fa      	ldr	r2, [r7, #12]
 801ee24:	6892      	ldr	r2, [r2, #8]
 801ee26:	4610      	mov	r0, r2
 801ee28:	4798      	blx	r3

    object->cells = NULL;
 801ee2a:	68fb      	ldr	r3, [r7, #12]
 801ee2c:	2200      	movs	r2, #0
 801ee2e:	605a      	str	r2, [r3, #4]
    object->names = NULL;
 801ee30:	68fb      	ldr	r3, [r7, #12]
 801ee32:	2200      	movs	r2, #0
 801ee34:	60da      	str	r2, [r3, #12]
    object->values = NULL;
 801ee36:	68fb      	ldr	r3, [r7, #12]
 801ee38:	2200      	movs	r2, #0
 801ee3a:	611a      	str	r2, [r3, #16]
    object->cell_ixs = NULL;
 801ee3c:	68fb      	ldr	r3, [r7, #12]
 801ee3e:	2200      	movs	r2, #0
 801ee40:	615a      	str	r2, [r3, #20]
    object->hashes = NULL;
 801ee42:	68fb      	ldr	r3, [r7, #12]
 801ee44:	2200      	movs	r2, #0
 801ee46:	609a      	str	r2, [r3, #8]
}
 801ee48:	bf00      	nop
 801ee4a:	3718      	adds	r7, #24
 801ee4c:	46bd      	mov	sp, r7
 801ee4e:	bd80      	pop	{r7, pc}
 801ee50:	20000214 	.word	0x20000214

0801ee54 <json_object_grow_and_rehash>:

static JSON_Status json_object_grow_and_rehash(JSON_Object *object) {
 801ee54:	b5b0      	push	{r4, r5, r7, lr}
 801ee56:	b092      	sub	sp, #72	@ 0x48
 801ee58:	af00      	add	r7, sp, #0
 801ee5a:	6078      	str	r0, [r7, #4]
    JSON_Value *wrapping_value = NULL;
 801ee5c:	2300      	movs	r3, #0
 801ee5e:	643b      	str	r3, [r7, #64]	@ 0x40
    JSON_Object new_object;
    char *key = NULL;
 801ee60:	2300      	movs	r3, #0
 801ee62:	63fb      	str	r3, [r7, #60]	@ 0x3c
    JSON_Value *value = NULL;
 801ee64:	2300      	movs	r3, #0
 801ee66:	63bb      	str	r3, [r7, #56]	@ 0x38
    unsigned int i = 0;
 801ee68:	2300      	movs	r3, #0
 801ee6a:	647b      	str	r3, [r7, #68]	@ 0x44
    size_t new_capacity = MAX(object->cell_capacity * 2, STARTING_CAPACITY);
 801ee6c:	687b      	ldr	r3, [r7, #4]
 801ee6e:	6a1b      	ldr	r3, [r3, #32]
 801ee70:	005b      	lsls	r3, r3, #1
 801ee72:	2b10      	cmp	r3, #16
 801ee74:	bf38      	it	cc
 801ee76:	2310      	movcc	r3, #16
 801ee78:	637b      	str	r3, [r7, #52]	@ 0x34
    JSON_Status res = json_object_init(&new_object, new_capacity);
 801ee7a:	f107 030c 	add.w	r3, r7, #12
 801ee7e:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 801ee80:	4618      	mov	r0, r3
 801ee82:	f7ff fecd 	bl	801ec20 <json_object_init>
 801ee86:	6338      	str	r0, [r7, #48]	@ 0x30
    if (res != JSONSuccess) {
 801ee88:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801ee8a:	2b00      	cmp	r3, #0
 801ee8c:	d002      	beq.n	801ee94 <json_object_grow_and_rehash+0x40>
        return JSONFailure;
 801ee8e:	f04f 33ff 	mov.w	r3, #4294967295
 801ee92:	e046      	b.n	801ef22 <json_object_grow_and_rehash+0xce>
    }

    wrapping_value = json_object_get_wrapping_value(object);
 801ee94:	6878      	ldr	r0, [r7, #4]
 801ee96:	f002 fb22 	bl	80214de <json_object_get_wrapping_value>
 801ee9a:	6438      	str	r0, [r7, #64]	@ 0x40
    new_object.wrapping_value = wrapping_value;
 801ee9c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801ee9e:	60fb      	str	r3, [r7, #12]

    for (i = 0; i < object->count; i++) {
 801eea0:	2300      	movs	r3, #0
 801eea2:	647b      	str	r3, [r7, #68]	@ 0x44
 801eea4:	e028      	b.n	801eef8 <json_object_grow_and_rehash+0xa4>
        key = object->names[i];
 801eea6:	687b      	ldr	r3, [r7, #4]
 801eea8:	68da      	ldr	r2, [r3, #12]
 801eeaa:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801eeac:	009b      	lsls	r3, r3, #2
 801eeae:	4413      	add	r3, r2
 801eeb0:	681b      	ldr	r3, [r3, #0]
 801eeb2:	63fb      	str	r3, [r7, #60]	@ 0x3c
        value = object->values[i];
 801eeb4:	687b      	ldr	r3, [r7, #4]
 801eeb6:	691a      	ldr	r2, [r3, #16]
 801eeb8:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801eeba:	009b      	lsls	r3, r3, #2
 801eebc:	4413      	add	r3, r2
 801eebe:	681b      	ldr	r3, [r3, #0]
 801eec0:	63bb      	str	r3, [r7, #56]	@ 0x38
        res = json_object_add(&new_object, key, value);
 801eec2:	f107 030c 	add.w	r3, r7, #12
 801eec6:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801eec8:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
 801eeca:	4618      	mov	r0, r3
 801eecc:	f000 f897 	bl	801effe <json_object_add>
 801eed0:	6338      	str	r0, [r7, #48]	@ 0x30
        if (res != JSONSuccess) {
 801eed2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801eed4:	2b00      	cmp	r3, #0
 801eed6:	d009      	beq.n	801eeec <json_object_grow_and_rehash+0x98>
            json_object_deinit(&new_object, PARSON_FALSE, PARSON_FALSE);
 801eed8:	f107 030c 	add.w	r3, r7, #12
 801eedc:	2200      	movs	r2, #0
 801eede:	2100      	movs	r1, #0
 801eee0:	4618      	mov	r0, r3
 801eee2:	f7ff ff4f 	bl	801ed84 <json_object_deinit>
            return JSONFailure;
 801eee6:	f04f 33ff 	mov.w	r3, #4294967295
 801eeea:	e01a      	b.n	801ef22 <json_object_grow_and_rehash+0xce>
        }
        value->parent = wrapping_value;
 801eeec:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801eeee:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 801eef0:	601a      	str	r2, [r3, #0]
    for (i = 0; i < object->count; i++) {
 801eef2:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801eef4:	3301      	adds	r3, #1
 801eef6:	647b      	str	r3, [r7, #68]	@ 0x44
 801eef8:	687b      	ldr	r3, [r7, #4]
 801eefa:	699b      	ldr	r3, [r3, #24]
 801eefc:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 801eefe:	429a      	cmp	r2, r3
 801ef00:	d3d1      	bcc.n	801eea6 <json_object_grow_and_rehash+0x52>
    }
    json_object_deinit(object, PARSON_FALSE, PARSON_FALSE);
 801ef02:	2200      	movs	r2, #0
 801ef04:	2100      	movs	r1, #0
 801ef06:	6878      	ldr	r0, [r7, #4]
 801ef08:	f7ff ff3c 	bl	801ed84 <json_object_deinit>
    *object = new_object;
 801ef0c:	687b      	ldr	r3, [r7, #4]
 801ef0e:	461d      	mov	r5, r3
 801ef10:	f107 040c 	add.w	r4, r7, #12
 801ef14:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801ef16:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 801ef18:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801ef1a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 801ef1c:	6823      	ldr	r3, [r4, #0]
 801ef1e:	602b      	str	r3, [r5, #0]
    return JSONSuccess;
 801ef20:	2300      	movs	r3, #0
}
 801ef22:	4618      	mov	r0, r3
 801ef24:	3748      	adds	r7, #72	@ 0x48
 801ef26:	46bd      	mov	sp, r7
 801ef28:	bdb0      	pop	{r4, r5, r7, pc}

0801ef2a <json_object_get_cell_ix>:

static size_t json_object_get_cell_ix(const JSON_Object *object, const char *key, size_t key_len, unsigned long hash, parson_bool_t *out_found) {
 801ef2a:	b580      	push	{r7, lr}
 801ef2c:	b08c      	sub	sp, #48	@ 0x30
 801ef2e:	af00      	add	r7, sp, #0
 801ef30:	60f8      	str	r0, [r7, #12]
 801ef32:	60b9      	str	r1, [r7, #8]
 801ef34:	607a      	str	r2, [r7, #4]
 801ef36:	603b      	str	r3, [r7, #0]
    size_t cell_ix = hash & (object->cell_capacity - 1);
 801ef38:	68fb      	ldr	r3, [r7, #12]
 801ef3a:	6a1b      	ldr	r3, [r3, #32]
 801ef3c:	3b01      	subs	r3, #1
 801ef3e:	683a      	ldr	r2, [r7, #0]
 801ef40:	4013      	ands	r3, r2
 801ef42:	62bb      	str	r3, [r7, #40]	@ 0x28
    size_t cell = 0;
 801ef44:	2300      	movs	r3, #0
 801ef46:	627b      	str	r3, [r7, #36]	@ 0x24
    size_t ix = 0;
 801ef48:	2300      	movs	r3, #0
 801ef4a:	623b      	str	r3, [r7, #32]
    unsigned int i = 0;
 801ef4c:	2300      	movs	r3, #0
 801ef4e:	62fb      	str	r3, [r7, #44]	@ 0x2c
    unsigned long hash_to_check = 0;
 801ef50:	2300      	movs	r3, #0
 801ef52:	61fb      	str	r3, [r7, #28]
    const char *key_to_check = NULL;
 801ef54:	2300      	movs	r3, #0
 801ef56:	61bb      	str	r3, [r7, #24]
    size_t key_to_check_len = 0;
 801ef58:	2300      	movs	r3, #0
 801ef5a:	617b      	str	r3, [r7, #20]

    *out_found = PARSON_FALSE;
 801ef5c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801ef5e:	2200      	movs	r2, #0
 801ef60:	601a      	str	r2, [r3, #0]

    for (i = 0; i < object->cell_capacity; i++) {
 801ef62:	2300      	movs	r3, #0
 801ef64:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801ef66:	e03f      	b.n	801efe8 <json_object_get_cell_ix+0xbe>
        ix = (cell_ix + i) & (object->cell_capacity - 1);
 801ef68:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801ef6a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801ef6c:	441a      	add	r2, r3
 801ef6e:	68fb      	ldr	r3, [r7, #12]
 801ef70:	6a1b      	ldr	r3, [r3, #32]
 801ef72:	3b01      	subs	r3, #1
 801ef74:	4013      	ands	r3, r2
 801ef76:	623b      	str	r3, [r7, #32]
        cell = object->cells[ix];
 801ef78:	68fb      	ldr	r3, [r7, #12]
 801ef7a:	685a      	ldr	r2, [r3, #4]
 801ef7c:	6a3b      	ldr	r3, [r7, #32]
 801ef7e:	009b      	lsls	r3, r3, #2
 801ef80:	4413      	add	r3, r2
 801ef82:	681b      	ldr	r3, [r3, #0]
 801ef84:	627b      	str	r3, [r7, #36]	@ 0x24
        if (cell == OBJECT_INVALID_IX) {
 801ef86:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801ef88:	f1b3 3fff 	cmp.w	r3, #4294967295
 801ef8c:	d101      	bne.n	801ef92 <json_object_get_cell_ix+0x68>
            return ix;
 801ef8e:	6a3b      	ldr	r3, [r7, #32]
 801ef90:	e031      	b.n	801eff6 <json_object_get_cell_ix+0xcc>
        }
        hash_to_check = object->hashes[cell];
 801ef92:	68fb      	ldr	r3, [r7, #12]
 801ef94:	689a      	ldr	r2, [r3, #8]
 801ef96:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801ef98:	009b      	lsls	r3, r3, #2
 801ef9a:	4413      	add	r3, r2
 801ef9c:	681b      	ldr	r3, [r3, #0]
 801ef9e:	61fb      	str	r3, [r7, #28]
        if (hash != hash_to_check) {
 801efa0:	683a      	ldr	r2, [r7, #0]
 801efa2:	69fb      	ldr	r3, [r7, #28]
 801efa4:	429a      	cmp	r2, r3
 801efa6:	d11b      	bne.n	801efe0 <json_object_get_cell_ix+0xb6>
            continue;
        }
        key_to_check = object->names[cell];
 801efa8:	68fb      	ldr	r3, [r7, #12]
 801efaa:	68da      	ldr	r2, [r3, #12]
 801efac:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801efae:	009b      	lsls	r3, r3, #2
 801efb0:	4413      	add	r3, r2
 801efb2:	681b      	ldr	r3, [r3, #0]
 801efb4:	61bb      	str	r3, [r7, #24]
        key_to_check_len = strlen(key_to_check);
 801efb6:	69b8      	ldr	r0, [r7, #24]
 801efb8:	f7e1 f968 	bl	800028c <strlen>
 801efbc:	6178      	str	r0, [r7, #20]
        if (key_to_check_len == key_len && strncmp(key, key_to_check, key_len) == 0) {
 801efbe:	697a      	ldr	r2, [r7, #20]
 801efc0:	687b      	ldr	r3, [r7, #4]
 801efc2:	429a      	cmp	r2, r3
 801efc4:	d10d      	bne.n	801efe2 <json_object_get_cell_ix+0xb8>
 801efc6:	687a      	ldr	r2, [r7, #4]
 801efc8:	69b9      	ldr	r1, [r7, #24]
 801efca:	68b8      	ldr	r0, [r7, #8]
 801efcc:	f005 f85f 	bl	802408e <strncmp>
 801efd0:	4603      	mov	r3, r0
 801efd2:	2b00      	cmp	r3, #0
 801efd4:	d105      	bne.n	801efe2 <json_object_get_cell_ix+0xb8>
            *out_found = PARSON_TRUE;
 801efd6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801efd8:	2201      	movs	r2, #1
 801efda:	601a      	str	r2, [r3, #0]
            return ix;
 801efdc:	6a3b      	ldr	r3, [r7, #32]
 801efde:	e00a      	b.n	801eff6 <json_object_get_cell_ix+0xcc>
            continue;
 801efe0:	bf00      	nop
    for (i = 0; i < object->cell_capacity; i++) {
 801efe2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801efe4:	3301      	adds	r3, #1
 801efe6:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801efe8:	68fb      	ldr	r3, [r7, #12]
 801efea:	6a1b      	ldr	r3, [r3, #32]
 801efec:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801efee:	429a      	cmp	r2, r3
 801eff0:	d3ba      	bcc.n	801ef68 <json_object_get_cell_ix+0x3e>
        }
    }
    return OBJECT_INVALID_IX;
 801eff2:	f04f 33ff 	mov.w	r3, #4294967295
}
 801eff6:	4618      	mov	r0, r3
 801eff8:	3730      	adds	r7, #48	@ 0x30
 801effa:	46bd      	mov	sp, r7
 801effc:	bd80      	pop	{r7, pc}

0801effe <json_object_add>:

static JSON_Status json_object_add(JSON_Object *object, char *name, JSON_Value *value) {
 801effe:	b580      	push	{r7, lr}
 801f000:	b08a      	sub	sp, #40	@ 0x28
 801f002:	af02      	add	r7, sp, #8
 801f004:	60f8      	str	r0, [r7, #12]
 801f006:	60b9      	str	r1, [r7, #8]
 801f008:	607a      	str	r2, [r7, #4]
    unsigned long hash = 0;
 801f00a:	2300      	movs	r3, #0
 801f00c:	61bb      	str	r3, [r7, #24]
    parson_bool_t found = PARSON_FALSE;
 801f00e:	2300      	movs	r3, #0
 801f010:	613b      	str	r3, [r7, #16]
    size_t cell_ix = 0;
 801f012:	2300      	movs	r3, #0
 801f014:	61fb      	str	r3, [r7, #28]
    JSON_Status res = JSONFailure;
 801f016:	f04f 33ff 	mov.w	r3, #4294967295
 801f01a:	617b      	str	r3, [r7, #20]

    if (!object || !name || !value) {
 801f01c:	68fb      	ldr	r3, [r7, #12]
 801f01e:	2b00      	cmp	r3, #0
 801f020:	d005      	beq.n	801f02e <json_object_add+0x30>
 801f022:	68bb      	ldr	r3, [r7, #8]
 801f024:	2b00      	cmp	r3, #0
 801f026:	d002      	beq.n	801f02e <json_object_add+0x30>
 801f028:	687b      	ldr	r3, [r7, #4]
 801f02a:	2b00      	cmp	r3, #0
 801f02c:	d102      	bne.n	801f034 <json_object_add+0x36>
        return JSONFailure;
 801f02e:	f04f 33ff 	mov.w	r3, #4294967295
 801f032:	e06e      	b.n	801f112 <json_object_add+0x114>
    }

    hash = hash_string(name, strlen(name));
 801f034:	68b8      	ldr	r0, [r7, #8]
 801f036:	f7e1 f929 	bl	800028c <strlen>
 801f03a:	4603      	mov	r3, r0
 801f03c:	4619      	mov	r1, r3
 801f03e:	68b8      	ldr	r0, [r7, #8]
 801f040:	f7ff fd96 	bl	801eb70 <hash_string>
 801f044:	61b8      	str	r0, [r7, #24]
    found = PARSON_FALSE;
 801f046:	2300      	movs	r3, #0
 801f048:	613b      	str	r3, [r7, #16]
    cell_ix = json_object_get_cell_ix(object, name, strlen(name), hash, &found);
 801f04a:	68b8      	ldr	r0, [r7, #8]
 801f04c:	f7e1 f91e 	bl	800028c <strlen>
 801f050:	4602      	mov	r2, r0
 801f052:	f107 0310 	add.w	r3, r7, #16
 801f056:	9300      	str	r3, [sp, #0]
 801f058:	69bb      	ldr	r3, [r7, #24]
 801f05a:	68b9      	ldr	r1, [r7, #8]
 801f05c:	68f8      	ldr	r0, [r7, #12]
 801f05e:	f7ff ff64 	bl	801ef2a <json_object_get_cell_ix>
 801f062:	61f8      	str	r0, [r7, #28]
    if (found) {
 801f064:	693b      	ldr	r3, [r7, #16]
 801f066:	2b00      	cmp	r3, #0
 801f068:	d002      	beq.n	801f070 <json_object_add+0x72>
        return JSONFailure;
 801f06a:	f04f 33ff 	mov.w	r3, #4294967295
 801f06e:	e050      	b.n	801f112 <json_object_add+0x114>
    }

    if (object->count >= object->item_capacity) {
 801f070:	68fb      	ldr	r3, [r7, #12]
 801f072:	699a      	ldr	r2, [r3, #24]
 801f074:	68fb      	ldr	r3, [r7, #12]
 801f076:	69db      	ldr	r3, [r3, #28]
 801f078:	429a      	cmp	r2, r3
 801f07a:	d316      	bcc.n	801f0aa <json_object_add+0xac>
        res = json_object_grow_and_rehash(object);
 801f07c:	68f8      	ldr	r0, [r7, #12]
 801f07e:	f7ff fee9 	bl	801ee54 <json_object_grow_and_rehash>
 801f082:	6178      	str	r0, [r7, #20]
        if (res != JSONSuccess) {
 801f084:	697b      	ldr	r3, [r7, #20]
 801f086:	2b00      	cmp	r3, #0
 801f088:	d002      	beq.n	801f090 <json_object_add+0x92>
            return JSONFailure;
 801f08a:	f04f 33ff 	mov.w	r3, #4294967295
 801f08e:	e040      	b.n	801f112 <json_object_add+0x114>
        }
        cell_ix = json_object_get_cell_ix(object, name, strlen(name), hash, &found);
 801f090:	68b8      	ldr	r0, [r7, #8]
 801f092:	f7e1 f8fb 	bl	800028c <strlen>
 801f096:	4602      	mov	r2, r0
 801f098:	f107 0310 	add.w	r3, r7, #16
 801f09c:	9300      	str	r3, [sp, #0]
 801f09e:	69bb      	ldr	r3, [r7, #24]
 801f0a0:	68b9      	ldr	r1, [r7, #8]
 801f0a2:	68f8      	ldr	r0, [r7, #12]
 801f0a4:	f7ff ff41 	bl	801ef2a <json_object_get_cell_ix>
 801f0a8:	61f8      	str	r0, [r7, #28]
    }

    object->names[object->count] = name;
 801f0aa:	68fb      	ldr	r3, [r7, #12]
 801f0ac:	68da      	ldr	r2, [r3, #12]
 801f0ae:	68fb      	ldr	r3, [r7, #12]
 801f0b0:	699b      	ldr	r3, [r3, #24]
 801f0b2:	009b      	lsls	r3, r3, #2
 801f0b4:	4413      	add	r3, r2
 801f0b6:	68ba      	ldr	r2, [r7, #8]
 801f0b8:	601a      	str	r2, [r3, #0]
    object->cells[cell_ix] = object->count;
 801f0ba:	68fb      	ldr	r3, [r7, #12]
 801f0bc:	685a      	ldr	r2, [r3, #4]
 801f0be:	69fb      	ldr	r3, [r7, #28]
 801f0c0:	009b      	lsls	r3, r3, #2
 801f0c2:	4413      	add	r3, r2
 801f0c4:	68fa      	ldr	r2, [r7, #12]
 801f0c6:	6992      	ldr	r2, [r2, #24]
 801f0c8:	601a      	str	r2, [r3, #0]
    object->values[object->count] = value;
 801f0ca:	68fb      	ldr	r3, [r7, #12]
 801f0cc:	691a      	ldr	r2, [r3, #16]
 801f0ce:	68fb      	ldr	r3, [r7, #12]
 801f0d0:	699b      	ldr	r3, [r3, #24]
 801f0d2:	009b      	lsls	r3, r3, #2
 801f0d4:	4413      	add	r3, r2
 801f0d6:	687a      	ldr	r2, [r7, #4]
 801f0d8:	601a      	str	r2, [r3, #0]
    object->cell_ixs[object->count] = cell_ix;
 801f0da:	68fb      	ldr	r3, [r7, #12]
 801f0dc:	695a      	ldr	r2, [r3, #20]
 801f0de:	68fb      	ldr	r3, [r7, #12]
 801f0e0:	699b      	ldr	r3, [r3, #24]
 801f0e2:	009b      	lsls	r3, r3, #2
 801f0e4:	4413      	add	r3, r2
 801f0e6:	69fa      	ldr	r2, [r7, #28]
 801f0e8:	601a      	str	r2, [r3, #0]
    object->hashes[object->count] = hash;
 801f0ea:	68fb      	ldr	r3, [r7, #12]
 801f0ec:	689a      	ldr	r2, [r3, #8]
 801f0ee:	68fb      	ldr	r3, [r7, #12]
 801f0f0:	699b      	ldr	r3, [r3, #24]
 801f0f2:	009b      	lsls	r3, r3, #2
 801f0f4:	4413      	add	r3, r2
 801f0f6:	69ba      	ldr	r2, [r7, #24]
 801f0f8:	601a      	str	r2, [r3, #0]
    object->count++;
 801f0fa:	68fb      	ldr	r3, [r7, #12]
 801f0fc:	699b      	ldr	r3, [r3, #24]
 801f0fe:	1c5a      	adds	r2, r3, #1
 801f100:	68fb      	ldr	r3, [r7, #12]
 801f102:	619a      	str	r2, [r3, #24]
    value->parent = json_object_get_wrapping_value(object);
 801f104:	68f8      	ldr	r0, [r7, #12]
 801f106:	f002 f9ea 	bl	80214de <json_object_get_wrapping_value>
 801f10a:	4602      	mov	r2, r0
 801f10c:	687b      	ldr	r3, [r7, #4]
 801f10e:	601a      	str	r2, [r3, #0]

    return JSONSuccess;
 801f110:	2300      	movs	r3, #0
}
 801f112:	4618      	mov	r0, r3
 801f114:	3720      	adds	r7, #32
 801f116:	46bd      	mov	sp, r7
 801f118:	bd80      	pop	{r7, pc}

0801f11a <json_object_getn_value>:

static JSON_Value * json_object_getn_value(const JSON_Object *object, const char *name, size_t name_len) {
 801f11a:	b580      	push	{r7, lr}
 801f11c:	b08a      	sub	sp, #40	@ 0x28
 801f11e:	af02      	add	r7, sp, #8
 801f120:	60f8      	str	r0, [r7, #12]
 801f122:	60b9      	str	r1, [r7, #8]
 801f124:	607a      	str	r2, [r7, #4]
    unsigned long hash = 0;
 801f126:	2300      	movs	r3, #0
 801f128:	61fb      	str	r3, [r7, #28]
    parson_bool_t found = PARSON_FALSE;
 801f12a:	2300      	movs	r3, #0
 801f12c:	613b      	str	r3, [r7, #16]
    size_t cell_ix = 0;
 801f12e:	2300      	movs	r3, #0
 801f130:	61bb      	str	r3, [r7, #24]
    size_t item_ix = 0;
 801f132:	2300      	movs	r3, #0
 801f134:	617b      	str	r3, [r7, #20]
    if (!object || !name) {
 801f136:	68fb      	ldr	r3, [r7, #12]
 801f138:	2b00      	cmp	r3, #0
 801f13a:	d002      	beq.n	801f142 <json_object_getn_value+0x28>
 801f13c:	68bb      	ldr	r3, [r7, #8]
 801f13e:	2b00      	cmp	r3, #0
 801f140:	d101      	bne.n	801f146 <json_object_getn_value+0x2c>
        return NULL;
 801f142:	2300      	movs	r3, #0
 801f144:	e022      	b.n	801f18c <json_object_getn_value+0x72>
    }
    hash = hash_string(name, name_len);
 801f146:	6879      	ldr	r1, [r7, #4]
 801f148:	68b8      	ldr	r0, [r7, #8]
 801f14a:	f7ff fd11 	bl	801eb70 <hash_string>
 801f14e:	61f8      	str	r0, [r7, #28]
    found = PARSON_FALSE;
 801f150:	2300      	movs	r3, #0
 801f152:	613b      	str	r3, [r7, #16]
    cell_ix = json_object_get_cell_ix(object, name, name_len, hash, &found);
 801f154:	f107 0310 	add.w	r3, r7, #16
 801f158:	9300      	str	r3, [sp, #0]
 801f15a:	69fb      	ldr	r3, [r7, #28]
 801f15c:	687a      	ldr	r2, [r7, #4]
 801f15e:	68b9      	ldr	r1, [r7, #8]
 801f160:	68f8      	ldr	r0, [r7, #12]
 801f162:	f7ff fee2 	bl	801ef2a <json_object_get_cell_ix>
 801f166:	61b8      	str	r0, [r7, #24]
    if (!found) {
 801f168:	693b      	ldr	r3, [r7, #16]
 801f16a:	2b00      	cmp	r3, #0
 801f16c:	d101      	bne.n	801f172 <json_object_getn_value+0x58>
        return NULL;
 801f16e:	2300      	movs	r3, #0
 801f170:	e00c      	b.n	801f18c <json_object_getn_value+0x72>
    }
    item_ix = object->cells[cell_ix];
 801f172:	68fb      	ldr	r3, [r7, #12]
 801f174:	685a      	ldr	r2, [r3, #4]
 801f176:	69bb      	ldr	r3, [r7, #24]
 801f178:	009b      	lsls	r3, r3, #2
 801f17a:	4413      	add	r3, r2
 801f17c:	681b      	ldr	r3, [r3, #0]
 801f17e:	617b      	str	r3, [r7, #20]
    return object->values[item_ix];
 801f180:	68fb      	ldr	r3, [r7, #12]
 801f182:	691a      	ldr	r2, [r3, #16]
 801f184:	697b      	ldr	r3, [r7, #20]
 801f186:	009b      	lsls	r3, r3, #2
 801f188:	4413      	add	r3, r2
 801f18a:	681b      	ldr	r3, [r3, #0]
}
 801f18c:	4618      	mov	r0, r3
 801f18e:	3720      	adds	r7, #32
 801f190:	46bd      	mov	sp, r7
 801f192:	bd80      	pop	{r7, pc}

0801f194 <json_object_remove_internal>:

static JSON_Status json_object_remove_internal(JSON_Object *object, const char *name, parson_bool_t free_value) {
 801f194:	b580      	push	{r7, lr}
 801f196:	b090      	sub	sp, #64	@ 0x40
 801f198:	af02      	add	r7, sp, #8
 801f19a:	60f8      	str	r0, [r7, #12]
 801f19c:	60b9      	str	r1, [r7, #8]
 801f19e:	607a      	str	r2, [r7, #4]
    unsigned long hash = 0;
 801f1a0:	2300      	movs	r3, #0
 801f1a2:	62bb      	str	r3, [r7, #40]	@ 0x28
    parson_bool_t found = PARSON_FALSE;
 801f1a4:	2300      	movs	r3, #0
 801f1a6:	613b      	str	r3, [r7, #16]
    size_t cell = 0;
 801f1a8:	2300      	movs	r3, #0
 801f1aa:	627b      	str	r3, [r7, #36]	@ 0x24
    size_t item_ix = 0;
 801f1ac:	2300      	movs	r3, #0
 801f1ae:	623b      	str	r3, [r7, #32]
    size_t last_item_ix = 0;
 801f1b0:	2300      	movs	r3, #0
 801f1b2:	61fb      	str	r3, [r7, #28]
    size_t i = 0;
 801f1b4:	2300      	movs	r3, #0
 801f1b6:	637b      	str	r3, [r7, #52]	@ 0x34
    size_t j = 0;
 801f1b8:	2300      	movs	r3, #0
 801f1ba:	633b      	str	r3, [r7, #48]	@ 0x30
    size_t x = 0;
 801f1bc:	2300      	movs	r3, #0
 801f1be:	62fb      	str	r3, [r7, #44]	@ 0x2c
    size_t k = 0;
 801f1c0:	2300      	movs	r3, #0
 801f1c2:	61bb      	str	r3, [r7, #24]
    JSON_Value *val = NULL;
 801f1c4:	2300      	movs	r3, #0
 801f1c6:	617b      	str	r3, [r7, #20]

    if (object == NULL) {
 801f1c8:	68fb      	ldr	r3, [r7, #12]
 801f1ca:	2b00      	cmp	r3, #0
 801f1cc:	d102      	bne.n	801f1d4 <json_object_remove_internal+0x40>
        return JSONFailure;
 801f1ce:	f04f 33ff 	mov.w	r3, #4294967295
 801f1d2:	e0f3      	b.n	801f3bc <json_object_remove_internal+0x228>
    }

    hash = hash_string(name, strlen(name));
 801f1d4:	68b8      	ldr	r0, [r7, #8]
 801f1d6:	f7e1 f859 	bl	800028c <strlen>
 801f1da:	4603      	mov	r3, r0
 801f1dc:	4619      	mov	r1, r3
 801f1de:	68b8      	ldr	r0, [r7, #8]
 801f1e0:	f7ff fcc6 	bl	801eb70 <hash_string>
 801f1e4:	62b8      	str	r0, [r7, #40]	@ 0x28
    found = PARSON_FALSE;
 801f1e6:	2300      	movs	r3, #0
 801f1e8:	613b      	str	r3, [r7, #16]
    cell = json_object_get_cell_ix(object, name, strlen(name), hash, &found);
 801f1ea:	68b8      	ldr	r0, [r7, #8]
 801f1ec:	f7e1 f84e 	bl	800028c <strlen>
 801f1f0:	4602      	mov	r2, r0
 801f1f2:	f107 0310 	add.w	r3, r7, #16
 801f1f6:	9300      	str	r3, [sp, #0]
 801f1f8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801f1fa:	68b9      	ldr	r1, [r7, #8]
 801f1fc:	68f8      	ldr	r0, [r7, #12]
 801f1fe:	f7ff fe94 	bl	801ef2a <json_object_get_cell_ix>
 801f202:	6278      	str	r0, [r7, #36]	@ 0x24
    if (!found) {
 801f204:	693b      	ldr	r3, [r7, #16]
 801f206:	2b00      	cmp	r3, #0
 801f208:	d102      	bne.n	801f210 <json_object_remove_internal+0x7c>
        return JSONFailure;
 801f20a:	f04f 33ff 	mov.w	r3, #4294967295
 801f20e:	e0d5      	b.n	801f3bc <json_object_remove_internal+0x228>
    }

    item_ix = object->cells[cell];
 801f210:	68fb      	ldr	r3, [r7, #12]
 801f212:	685a      	ldr	r2, [r3, #4]
 801f214:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801f216:	009b      	lsls	r3, r3, #2
 801f218:	4413      	add	r3, r2
 801f21a:	681b      	ldr	r3, [r3, #0]
 801f21c:	623b      	str	r3, [r7, #32]
    if (free_value) {
 801f21e:	687b      	ldr	r3, [r7, #4]
 801f220:	2b00      	cmp	r3, #0
 801f222:	d00b      	beq.n	801f23c <json_object_remove_internal+0xa8>
        val = object->values[item_ix];
 801f224:	68fb      	ldr	r3, [r7, #12]
 801f226:	691a      	ldr	r2, [r3, #16]
 801f228:	6a3b      	ldr	r3, [r7, #32]
 801f22a:	009b      	lsls	r3, r3, #2
 801f22c:	4413      	add	r3, r2
 801f22e:	681b      	ldr	r3, [r3, #0]
 801f230:	617b      	str	r3, [r7, #20]
        json_value_free(val);
 801f232:	6978      	ldr	r0, [r7, #20]
 801f234:	f002 fa82 	bl	802173c <json_value_free>
        val = NULL;
 801f238:	2300      	movs	r3, #0
 801f23a:	617b      	str	r3, [r7, #20]
    }

    parson_free(object->names[item_ix]);
 801f23c:	4b61      	ldr	r3, [pc, #388]	@ (801f3c4 <json_object_remove_internal+0x230>)
 801f23e:	681b      	ldr	r3, [r3, #0]
 801f240:	68fa      	ldr	r2, [r7, #12]
 801f242:	68d1      	ldr	r1, [r2, #12]
 801f244:	6a3a      	ldr	r2, [r7, #32]
 801f246:	0092      	lsls	r2, r2, #2
 801f248:	440a      	add	r2, r1
 801f24a:	6812      	ldr	r2, [r2, #0]
 801f24c:	4610      	mov	r0, r2
 801f24e:	4798      	blx	r3
    last_item_ix = object->count - 1;
 801f250:	68fb      	ldr	r3, [r7, #12]
 801f252:	699b      	ldr	r3, [r3, #24]
 801f254:	3b01      	subs	r3, #1
 801f256:	61fb      	str	r3, [r7, #28]
    if (item_ix < last_item_ix) {
 801f258:	6a3a      	ldr	r2, [r7, #32]
 801f25a:	69fb      	ldr	r3, [r7, #28]
 801f25c:	429a      	cmp	r2, r3
 801f25e:	d23b      	bcs.n	801f2d8 <json_object_remove_internal+0x144>
        object->names[item_ix] = object->names[last_item_ix];
 801f260:	68fb      	ldr	r3, [r7, #12]
 801f262:	68da      	ldr	r2, [r3, #12]
 801f264:	69fb      	ldr	r3, [r7, #28]
 801f266:	009b      	lsls	r3, r3, #2
 801f268:	441a      	add	r2, r3
 801f26a:	68fb      	ldr	r3, [r7, #12]
 801f26c:	68d9      	ldr	r1, [r3, #12]
 801f26e:	6a3b      	ldr	r3, [r7, #32]
 801f270:	009b      	lsls	r3, r3, #2
 801f272:	440b      	add	r3, r1
 801f274:	6812      	ldr	r2, [r2, #0]
 801f276:	601a      	str	r2, [r3, #0]
        object->values[item_ix] = object->values[last_item_ix];
 801f278:	68fb      	ldr	r3, [r7, #12]
 801f27a:	691a      	ldr	r2, [r3, #16]
 801f27c:	69fb      	ldr	r3, [r7, #28]
 801f27e:	009b      	lsls	r3, r3, #2
 801f280:	441a      	add	r2, r3
 801f282:	68fb      	ldr	r3, [r7, #12]
 801f284:	6919      	ldr	r1, [r3, #16]
 801f286:	6a3b      	ldr	r3, [r7, #32]
 801f288:	009b      	lsls	r3, r3, #2
 801f28a:	440b      	add	r3, r1
 801f28c:	6812      	ldr	r2, [r2, #0]
 801f28e:	601a      	str	r2, [r3, #0]
        object->cell_ixs[item_ix] = object->cell_ixs[last_item_ix];
 801f290:	68fb      	ldr	r3, [r7, #12]
 801f292:	695a      	ldr	r2, [r3, #20]
 801f294:	69fb      	ldr	r3, [r7, #28]
 801f296:	009b      	lsls	r3, r3, #2
 801f298:	441a      	add	r2, r3
 801f29a:	68fb      	ldr	r3, [r7, #12]
 801f29c:	6959      	ldr	r1, [r3, #20]
 801f29e:	6a3b      	ldr	r3, [r7, #32]
 801f2a0:	009b      	lsls	r3, r3, #2
 801f2a2:	440b      	add	r3, r1
 801f2a4:	6812      	ldr	r2, [r2, #0]
 801f2a6:	601a      	str	r2, [r3, #0]
        object->hashes[item_ix] = object->hashes[last_item_ix];
 801f2a8:	68fb      	ldr	r3, [r7, #12]
 801f2aa:	689a      	ldr	r2, [r3, #8]
 801f2ac:	69fb      	ldr	r3, [r7, #28]
 801f2ae:	009b      	lsls	r3, r3, #2
 801f2b0:	441a      	add	r2, r3
 801f2b2:	68fb      	ldr	r3, [r7, #12]
 801f2b4:	6899      	ldr	r1, [r3, #8]
 801f2b6:	6a3b      	ldr	r3, [r7, #32]
 801f2b8:	009b      	lsls	r3, r3, #2
 801f2ba:	440b      	add	r3, r1
 801f2bc:	6812      	ldr	r2, [r2, #0]
 801f2be:	601a      	str	r2, [r3, #0]
        object->cells[object->cell_ixs[item_ix]] = item_ix;
 801f2c0:	68fb      	ldr	r3, [r7, #12]
 801f2c2:	685a      	ldr	r2, [r3, #4]
 801f2c4:	68fb      	ldr	r3, [r7, #12]
 801f2c6:	6959      	ldr	r1, [r3, #20]
 801f2c8:	6a3b      	ldr	r3, [r7, #32]
 801f2ca:	009b      	lsls	r3, r3, #2
 801f2cc:	440b      	add	r3, r1
 801f2ce:	681b      	ldr	r3, [r3, #0]
 801f2d0:	009b      	lsls	r3, r3, #2
 801f2d2:	4413      	add	r3, r2
 801f2d4:	6a3a      	ldr	r2, [r7, #32]
 801f2d6:	601a      	str	r2, [r3, #0]
    }
    object->count--;
 801f2d8:	68fb      	ldr	r3, [r7, #12]
 801f2da:	699b      	ldr	r3, [r3, #24]
 801f2dc:	1e5a      	subs	r2, r3, #1
 801f2de:	68fb      	ldr	r3, [r7, #12]
 801f2e0:	619a      	str	r2, [r3, #24]

    i = cell;
 801f2e2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801f2e4:	637b      	str	r3, [r7, #52]	@ 0x34
    j = i;
 801f2e6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801f2e8:	633b      	str	r3, [r7, #48]	@ 0x30
    for (x = 0; x < (object->cell_capacity - 1); x++) {
 801f2ea:	2300      	movs	r3, #0
 801f2ec:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801f2ee:	e054      	b.n	801f39a <json_object_remove_internal+0x206>
        j = (j + 1) & (object->cell_capacity - 1);
 801f2f0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801f2f2:	1c5a      	adds	r2, r3, #1
 801f2f4:	68fb      	ldr	r3, [r7, #12]
 801f2f6:	6a1b      	ldr	r3, [r3, #32]
 801f2f8:	3b01      	subs	r3, #1
 801f2fa:	4013      	ands	r3, r2
 801f2fc:	633b      	str	r3, [r7, #48]	@ 0x30
        if (object->cells[j] == OBJECT_INVALID_IX) {
 801f2fe:	68fb      	ldr	r3, [r7, #12]
 801f300:	685a      	ldr	r2, [r3, #4]
 801f302:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801f304:	009b      	lsls	r3, r3, #2
 801f306:	4413      	add	r3, r2
 801f308:	681b      	ldr	r3, [r3, #0]
 801f30a:	f1b3 3fff 	cmp.w	r3, #4294967295
 801f30e:	d04b      	beq.n	801f3a8 <json_object_remove_internal+0x214>
            break;
        }
        k = object->hashes[object->cells[j]] & (object->cell_capacity - 1);
 801f310:	68fb      	ldr	r3, [r7, #12]
 801f312:	689a      	ldr	r2, [r3, #8]
 801f314:	68fb      	ldr	r3, [r7, #12]
 801f316:	6859      	ldr	r1, [r3, #4]
 801f318:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801f31a:	009b      	lsls	r3, r3, #2
 801f31c:	440b      	add	r3, r1
 801f31e:	681b      	ldr	r3, [r3, #0]
 801f320:	009b      	lsls	r3, r3, #2
 801f322:	4413      	add	r3, r2
 801f324:	681a      	ldr	r2, [r3, #0]
 801f326:	68fb      	ldr	r3, [r7, #12]
 801f328:	6a1b      	ldr	r3, [r3, #32]
 801f32a:	3b01      	subs	r3, #1
 801f32c:	4013      	ands	r3, r2
 801f32e:	61bb      	str	r3, [r7, #24]
        if ((j > i && (k <= i || k > j))
 801f330:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801f332:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801f334:	429a      	cmp	r2, r3
 801f336:	d907      	bls.n	801f348 <json_object_remove_internal+0x1b4>
 801f338:	69ba      	ldr	r2, [r7, #24]
 801f33a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801f33c:	429a      	cmp	r2, r3
 801f33e:	d90f      	bls.n	801f360 <json_object_remove_internal+0x1cc>
 801f340:	69ba      	ldr	r2, [r7, #24]
 801f342:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801f344:	429a      	cmp	r2, r3
 801f346:	d80b      	bhi.n	801f360 <json_object_remove_internal+0x1cc>
         || (j < i && (k <= i && k > j))) {
 801f348:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801f34a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801f34c:	429a      	cmp	r2, r3
 801f34e:	d221      	bcs.n	801f394 <json_object_remove_internal+0x200>
 801f350:	69ba      	ldr	r2, [r7, #24]
 801f352:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801f354:	429a      	cmp	r2, r3
 801f356:	d81d      	bhi.n	801f394 <json_object_remove_internal+0x200>
 801f358:	69ba      	ldr	r2, [r7, #24]
 801f35a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801f35c:	429a      	cmp	r2, r3
 801f35e:	d919      	bls.n	801f394 <json_object_remove_internal+0x200>
            object->cell_ixs[object->cells[j]] = i;
 801f360:	68fb      	ldr	r3, [r7, #12]
 801f362:	695a      	ldr	r2, [r3, #20]
 801f364:	68fb      	ldr	r3, [r7, #12]
 801f366:	6859      	ldr	r1, [r3, #4]
 801f368:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801f36a:	009b      	lsls	r3, r3, #2
 801f36c:	440b      	add	r3, r1
 801f36e:	681b      	ldr	r3, [r3, #0]
 801f370:	009b      	lsls	r3, r3, #2
 801f372:	4413      	add	r3, r2
 801f374:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 801f376:	601a      	str	r2, [r3, #0]
            object->cells[i] = object->cells[j];
 801f378:	68fb      	ldr	r3, [r7, #12]
 801f37a:	685a      	ldr	r2, [r3, #4]
 801f37c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801f37e:	009b      	lsls	r3, r3, #2
 801f380:	441a      	add	r2, r3
 801f382:	68fb      	ldr	r3, [r7, #12]
 801f384:	6859      	ldr	r1, [r3, #4]
 801f386:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801f388:	009b      	lsls	r3, r3, #2
 801f38a:	440b      	add	r3, r1
 801f38c:	6812      	ldr	r2, [r2, #0]
 801f38e:	601a      	str	r2, [r3, #0]
            i = j;
 801f390:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801f392:	637b      	str	r3, [r7, #52]	@ 0x34
    for (x = 0; x < (object->cell_capacity - 1); x++) {
 801f394:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801f396:	3301      	adds	r3, #1
 801f398:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801f39a:	68fb      	ldr	r3, [r7, #12]
 801f39c:	6a1b      	ldr	r3, [r3, #32]
 801f39e:	3b01      	subs	r3, #1
 801f3a0:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801f3a2:	429a      	cmp	r2, r3
 801f3a4:	d3a4      	bcc.n	801f2f0 <json_object_remove_internal+0x15c>
 801f3a6:	e000      	b.n	801f3aa <json_object_remove_internal+0x216>
            break;
 801f3a8:	bf00      	nop
        }
    }
    object->cells[i] = OBJECT_INVALID_IX;
 801f3aa:	68fb      	ldr	r3, [r7, #12]
 801f3ac:	685a      	ldr	r2, [r3, #4]
 801f3ae:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801f3b0:	009b      	lsls	r3, r3, #2
 801f3b2:	4413      	add	r3, r2
 801f3b4:	f04f 32ff 	mov.w	r2, #4294967295
 801f3b8:	601a      	str	r2, [r3, #0]
    return JSONSuccess;
 801f3ba:	2300      	movs	r3, #0
}
 801f3bc:	4618      	mov	r0, r3
 801f3be:	3738      	adds	r7, #56	@ 0x38
 801f3c0:	46bd      	mov	sp, r7
 801f3c2:	bd80      	pop	{r7, pc}
 801f3c4:	20000214 	.word	0x20000214

0801f3c8 <json_object_dotremove_internal>:

static JSON_Status json_object_dotremove_internal(JSON_Object *object, const char *name, parson_bool_t free_value) {
 801f3c8:	b580      	push	{r7, lr}
 801f3ca:	b088      	sub	sp, #32
 801f3cc:	af00      	add	r7, sp, #0
 801f3ce:	60f8      	str	r0, [r7, #12]
 801f3d0:	60b9      	str	r1, [r7, #8]
 801f3d2:	607a      	str	r2, [r7, #4]
    JSON_Value *temp_value = NULL;
 801f3d4:	2300      	movs	r3, #0
 801f3d6:	61fb      	str	r3, [r7, #28]
    JSON_Object *temp_object = NULL;
 801f3d8:	2300      	movs	r3, #0
 801f3da:	61bb      	str	r3, [r7, #24]
    const char *dot_pos = strchr(name, '.');
 801f3dc:	212e      	movs	r1, #46	@ 0x2e
 801f3de:	68b8      	ldr	r0, [r7, #8]
 801f3e0:	f004 fe48 	bl	8024074 <strchr>
 801f3e4:	6178      	str	r0, [r7, #20]
    if (!dot_pos) {
 801f3e6:	697b      	ldr	r3, [r7, #20]
 801f3e8:	2b00      	cmp	r3, #0
 801f3ea:	d106      	bne.n	801f3fa <json_object_dotremove_internal+0x32>
        return json_object_remove_internal(object, name, free_value);
 801f3ec:	687a      	ldr	r2, [r7, #4]
 801f3ee:	68b9      	ldr	r1, [r7, #8]
 801f3f0:	68f8      	ldr	r0, [r7, #12]
 801f3f2:	f7ff fecf 	bl	801f194 <json_object_remove_internal>
 801f3f6:	4603      	mov	r3, r0
 801f3f8:	e01d      	b.n	801f436 <json_object_dotremove_internal+0x6e>
    }
    temp_value = json_object_getn_value(object, name, dot_pos - name);
 801f3fa:	697a      	ldr	r2, [r7, #20]
 801f3fc:	68bb      	ldr	r3, [r7, #8]
 801f3fe:	1ad3      	subs	r3, r2, r3
 801f400:	461a      	mov	r2, r3
 801f402:	68b9      	ldr	r1, [r7, #8]
 801f404:	68f8      	ldr	r0, [r7, #12]
 801f406:	f7ff fe88 	bl	801f11a <json_object_getn_value>
 801f40a:	61f8      	str	r0, [r7, #28]
    if (json_value_get_type(temp_value) != JSONObject) {
 801f40c:	69f8      	ldr	r0, [r7, #28]
 801f40e:	f002 f8ec 	bl	80215ea <json_value_get_type>
 801f412:	4603      	mov	r3, r0
 801f414:	2b04      	cmp	r3, #4
 801f416:	d002      	beq.n	801f41e <json_object_dotremove_internal+0x56>
        return JSONFailure;
 801f418:	f04f 33ff 	mov.w	r3, #4294967295
 801f41c:	e00b      	b.n	801f436 <json_object_dotremove_internal+0x6e>
    }
    temp_object = json_value_get_object(temp_value);
 801f41e:	69f8      	ldr	r0, [r7, #28]
 801f420:	f002 f8f5 	bl	802160e <json_value_get_object>
 801f424:	61b8      	str	r0, [r7, #24]
    return json_object_dotremove_internal(temp_object, dot_pos + 1, free_value);
 801f426:	697b      	ldr	r3, [r7, #20]
 801f428:	3301      	adds	r3, #1
 801f42a:	687a      	ldr	r2, [r7, #4]
 801f42c:	4619      	mov	r1, r3
 801f42e:	69b8      	ldr	r0, [r7, #24]
 801f430:	f7ff ffca 	bl	801f3c8 <json_object_dotremove_internal>
 801f434:	4603      	mov	r3, r0
}
 801f436:	4618      	mov	r0, r3
 801f438:	3720      	adds	r7, #32
 801f43a:	46bd      	mov	sp, r7
 801f43c:	bd80      	pop	{r7, pc}
	...

0801f440 <json_object_free>:

static void json_object_free(JSON_Object *object) {
 801f440:	b580      	push	{r7, lr}
 801f442:	b082      	sub	sp, #8
 801f444:	af00      	add	r7, sp, #0
 801f446:	6078      	str	r0, [r7, #4]
    json_object_deinit(object, PARSON_TRUE, PARSON_TRUE);
 801f448:	2201      	movs	r2, #1
 801f44a:	2101      	movs	r1, #1
 801f44c:	6878      	ldr	r0, [r7, #4]
 801f44e:	f7ff fc99 	bl	801ed84 <json_object_deinit>
    parson_free(object);
 801f452:	4b04      	ldr	r3, [pc, #16]	@ (801f464 <json_object_free+0x24>)
 801f454:	681b      	ldr	r3, [r3, #0]
 801f456:	6878      	ldr	r0, [r7, #4]
 801f458:	4798      	blx	r3
}
 801f45a:	bf00      	nop
 801f45c:	3708      	adds	r7, #8
 801f45e:	46bd      	mov	sp, r7
 801f460:	bd80      	pop	{r7, pc}
 801f462:	bf00      	nop
 801f464:	20000214 	.word	0x20000214

0801f468 <json_array_make>:

/* JSON Array */
static JSON_Array * json_array_make(JSON_Value *wrapping_value) {
 801f468:	b580      	push	{r7, lr}
 801f46a:	b084      	sub	sp, #16
 801f46c:	af00      	add	r7, sp, #0
 801f46e:	6078      	str	r0, [r7, #4]
    JSON_Array *new_array = (JSON_Array*)parson_malloc(sizeof(JSON_Array));
 801f470:	4b0d      	ldr	r3, [pc, #52]	@ (801f4a8 <json_array_make+0x40>)
 801f472:	681b      	ldr	r3, [r3, #0]
 801f474:	2010      	movs	r0, #16
 801f476:	4798      	blx	r3
 801f478:	60f8      	str	r0, [r7, #12]
    if (new_array == NULL) {
 801f47a:	68fb      	ldr	r3, [r7, #12]
 801f47c:	2b00      	cmp	r3, #0
 801f47e:	d101      	bne.n	801f484 <json_array_make+0x1c>
        return NULL;
 801f480:	2300      	movs	r3, #0
 801f482:	e00c      	b.n	801f49e <json_array_make+0x36>
    }
    new_array->wrapping_value = wrapping_value;
 801f484:	68fb      	ldr	r3, [r7, #12]
 801f486:	687a      	ldr	r2, [r7, #4]
 801f488:	601a      	str	r2, [r3, #0]
    new_array->items = (JSON_Value**)NULL;
 801f48a:	68fb      	ldr	r3, [r7, #12]
 801f48c:	2200      	movs	r2, #0
 801f48e:	605a      	str	r2, [r3, #4]
    new_array->capacity = 0;
 801f490:	68fb      	ldr	r3, [r7, #12]
 801f492:	2200      	movs	r2, #0
 801f494:	60da      	str	r2, [r3, #12]
    new_array->count = 0;
 801f496:	68fb      	ldr	r3, [r7, #12]
 801f498:	2200      	movs	r2, #0
 801f49a:	609a      	str	r2, [r3, #8]
    return new_array;
 801f49c:	68fb      	ldr	r3, [r7, #12]
}
 801f49e:	4618      	mov	r0, r3
 801f4a0:	3710      	adds	r7, #16
 801f4a2:	46bd      	mov	sp, r7
 801f4a4:	bd80      	pop	{r7, pc}
 801f4a6:	bf00      	nop
 801f4a8:	20000210 	.word	0x20000210

0801f4ac <json_array_add>:

static JSON_Status json_array_add(JSON_Array *array, JSON_Value *value) {
 801f4ac:	b580      	push	{r7, lr}
 801f4ae:	b084      	sub	sp, #16
 801f4b0:	af00      	add	r7, sp, #0
 801f4b2:	6078      	str	r0, [r7, #4]
 801f4b4:	6039      	str	r1, [r7, #0]
    if (array->count >= array->capacity) {
 801f4b6:	687b      	ldr	r3, [r7, #4]
 801f4b8:	689a      	ldr	r2, [r3, #8]
 801f4ba:	687b      	ldr	r3, [r7, #4]
 801f4bc:	68db      	ldr	r3, [r3, #12]
 801f4be:	429a      	cmp	r2, r3
 801f4c0:	d310      	bcc.n	801f4e4 <json_array_add+0x38>
        size_t new_capacity = MAX(array->capacity * 2, STARTING_CAPACITY);
 801f4c2:	687b      	ldr	r3, [r7, #4]
 801f4c4:	68db      	ldr	r3, [r3, #12]
 801f4c6:	005b      	lsls	r3, r3, #1
 801f4c8:	2b10      	cmp	r3, #16
 801f4ca:	bf38      	it	cc
 801f4cc:	2310      	movcc	r3, #16
 801f4ce:	60fb      	str	r3, [r7, #12]
        if (json_array_resize(array, new_capacity) != JSONSuccess) {
 801f4d0:	68f9      	ldr	r1, [r7, #12]
 801f4d2:	6878      	ldr	r0, [r7, #4]
 801f4d4:	f000 f81e 	bl	801f514 <json_array_resize>
 801f4d8:	4603      	mov	r3, r0
 801f4da:	2b00      	cmp	r3, #0
 801f4dc:	d002      	beq.n	801f4e4 <json_array_add+0x38>
            return JSONFailure;
 801f4de:	f04f 33ff 	mov.w	r3, #4294967295
 801f4e2:	e013      	b.n	801f50c <json_array_add+0x60>
        }
    }
    value->parent = json_array_get_wrapping_value(array);
 801f4e4:	6878      	ldr	r0, [r7, #4]
 801f4e6:	f002 f86f 	bl	80215c8 <json_array_get_wrapping_value>
 801f4ea:	4602      	mov	r2, r0
 801f4ec:	683b      	ldr	r3, [r7, #0]
 801f4ee:	601a      	str	r2, [r3, #0]
    array->items[array->count] = value;
 801f4f0:	687b      	ldr	r3, [r7, #4]
 801f4f2:	685a      	ldr	r2, [r3, #4]
 801f4f4:	687b      	ldr	r3, [r7, #4]
 801f4f6:	689b      	ldr	r3, [r3, #8]
 801f4f8:	009b      	lsls	r3, r3, #2
 801f4fa:	4413      	add	r3, r2
 801f4fc:	683a      	ldr	r2, [r7, #0]
 801f4fe:	601a      	str	r2, [r3, #0]
    array->count++;
 801f500:	687b      	ldr	r3, [r7, #4]
 801f502:	689b      	ldr	r3, [r3, #8]
 801f504:	1c5a      	adds	r2, r3, #1
 801f506:	687b      	ldr	r3, [r7, #4]
 801f508:	609a      	str	r2, [r3, #8]
    return JSONSuccess;
 801f50a:	2300      	movs	r3, #0
}
 801f50c:	4618      	mov	r0, r3
 801f50e:	3710      	adds	r7, #16
 801f510:	46bd      	mov	sp, r7
 801f512:	bd80      	pop	{r7, pc}

0801f514 <json_array_resize>:

static JSON_Status json_array_resize(JSON_Array *array, size_t new_capacity) {
 801f514:	b580      	push	{r7, lr}
 801f516:	b084      	sub	sp, #16
 801f518:	af00      	add	r7, sp, #0
 801f51a:	6078      	str	r0, [r7, #4]
 801f51c:	6039      	str	r1, [r7, #0]
    JSON_Value **new_items = NULL;
 801f51e:	2300      	movs	r3, #0
 801f520:	60fb      	str	r3, [r7, #12]
    if (new_capacity == 0) {
 801f522:	683b      	ldr	r3, [r7, #0]
 801f524:	2b00      	cmp	r3, #0
 801f526:	d102      	bne.n	801f52e <json_array_resize+0x1a>
        return JSONFailure;
 801f528:	f04f 33ff 	mov.w	r3, #4294967295
 801f52c:	e02a      	b.n	801f584 <json_array_resize+0x70>
    }
    new_items = (JSON_Value**)parson_malloc(new_capacity * sizeof(JSON_Value*));
 801f52e:	4b17      	ldr	r3, [pc, #92]	@ (801f58c <json_array_resize+0x78>)
 801f530:	681b      	ldr	r3, [r3, #0]
 801f532:	683a      	ldr	r2, [r7, #0]
 801f534:	0092      	lsls	r2, r2, #2
 801f536:	4610      	mov	r0, r2
 801f538:	4798      	blx	r3
 801f53a:	60f8      	str	r0, [r7, #12]
    if (new_items == NULL) {
 801f53c:	68fb      	ldr	r3, [r7, #12]
 801f53e:	2b00      	cmp	r3, #0
 801f540:	d102      	bne.n	801f548 <json_array_resize+0x34>
        return JSONFailure;
 801f542:	f04f 33ff 	mov.w	r3, #4294967295
 801f546:	e01d      	b.n	801f584 <json_array_resize+0x70>
    }
    if (array->items != NULL && array->count > 0) {
 801f548:	687b      	ldr	r3, [r7, #4]
 801f54a:	685b      	ldr	r3, [r3, #4]
 801f54c:	2b00      	cmp	r3, #0
 801f54e:	d00c      	beq.n	801f56a <json_array_resize+0x56>
 801f550:	687b      	ldr	r3, [r7, #4]
 801f552:	689b      	ldr	r3, [r3, #8]
 801f554:	2b00      	cmp	r3, #0
 801f556:	d008      	beq.n	801f56a <json_array_resize+0x56>
        memcpy(new_items, array->items, array->count * sizeof(JSON_Value*));
 801f558:	687b      	ldr	r3, [r7, #4]
 801f55a:	6859      	ldr	r1, [r3, #4]
 801f55c:	687b      	ldr	r3, [r7, #4]
 801f55e:	689b      	ldr	r3, [r3, #8]
 801f560:	009b      	lsls	r3, r3, #2
 801f562:	461a      	mov	r2, r3
 801f564:	68f8      	ldr	r0, [r7, #12]
 801f566:	f004 fe42 	bl	80241ee <memcpy>
    }
    parson_free(array->items);
 801f56a:	4b09      	ldr	r3, [pc, #36]	@ (801f590 <json_array_resize+0x7c>)
 801f56c:	681b      	ldr	r3, [r3, #0]
 801f56e:	687a      	ldr	r2, [r7, #4]
 801f570:	6852      	ldr	r2, [r2, #4]
 801f572:	4610      	mov	r0, r2
 801f574:	4798      	blx	r3
    array->items = new_items;
 801f576:	687b      	ldr	r3, [r7, #4]
 801f578:	68fa      	ldr	r2, [r7, #12]
 801f57a:	605a      	str	r2, [r3, #4]
    array->capacity = new_capacity;
 801f57c:	687b      	ldr	r3, [r7, #4]
 801f57e:	683a      	ldr	r2, [r7, #0]
 801f580:	60da      	str	r2, [r3, #12]
    return JSONSuccess;
 801f582:	2300      	movs	r3, #0
}
 801f584:	4618      	mov	r0, r3
 801f586:	3710      	adds	r7, #16
 801f588:	46bd      	mov	sp, r7
 801f58a:	bd80      	pop	{r7, pc}
 801f58c:	20000210 	.word	0x20000210
 801f590:	20000214 	.word	0x20000214

0801f594 <json_array_free>:

static void json_array_free(JSON_Array *array) {
 801f594:	b580      	push	{r7, lr}
 801f596:	b084      	sub	sp, #16
 801f598:	af00      	add	r7, sp, #0
 801f59a:	6078      	str	r0, [r7, #4]
    size_t i;
    for (i = 0; i < array->count; i++) {
 801f59c:	2300      	movs	r3, #0
 801f59e:	60fb      	str	r3, [r7, #12]
 801f5a0:	e00b      	b.n	801f5ba <json_array_free+0x26>
        json_value_free(array->items[i]);
 801f5a2:	687b      	ldr	r3, [r7, #4]
 801f5a4:	685a      	ldr	r2, [r3, #4]
 801f5a6:	68fb      	ldr	r3, [r7, #12]
 801f5a8:	009b      	lsls	r3, r3, #2
 801f5aa:	4413      	add	r3, r2
 801f5ac:	681b      	ldr	r3, [r3, #0]
 801f5ae:	4618      	mov	r0, r3
 801f5b0:	f002 f8c4 	bl	802173c <json_value_free>
    for (i = 0; i < array->count; i++) {
 801f5b4:	68fb      	ldr	r3, [r7, #12]
 801f5b6:	3301      	adds	r3, #1
 801f5b8:	60fb      	str	r3, [r7, #12]
 801f5ba:	687b      	ldr	r3, [r7, #4]
 801f5bc:	689b      	ldr	r3, [r3, #8]
 801f5be:	68fa      	ldr	r2, [r7, #12]
 801f5c0:	429a      	cmp	r2, r3
 801f5c2:	d3ee      	bcc.n	801f5a2 <json_array_free+0xe>
    }
    parson_free(array->items);
 801f5c4:	4b06      	ldr	r3, [pc, #24]	@ (801f5e0 <json_array_free+0x4c>)
 801f5c6:	681b      	ldr	r3, [r3, #0]
 801f5c8:	687a      	ldr	r2, [r7, #4]
 801f5ca:	6852      	ldr	r2, [r2, #4]
 801f5cc:	4610      	mov	r0, r2
 801f5ce:	4798      	blx	r3
    parson_free(array);
 801f5d0:	4b03      	ldr	r3, [pc, #12]	@ (801f5e0 <json_array_free+0x4c>)
 801f5d2:	681b      	ldr	r3, [r3, #0]
 801f5d4:	6878      	ldr	r0, [r7, #4]
 801f5d6:	4798      	blx	r3
}
 801f5d8:	bf00      	nop
 801f5da:	3710      	adds	r7, #16
 801f5dc:	46bd      	mov	sp, r7
 801f5de:	bd80      	pop	{r7, pc}
 801f5e0:	20000214 	.word	0x20000214

0801f5e4 <json_value_init_string_no_copy>:

/* JSON Value */
static JSON_Value * json_value_init_string_no_copy(char *string, size_t length) {
 801f5e4:	b580      	push	{r7, lr}
 801f5e6:	b084      	sub	sp, #16
 801f5e8:	af00      	add	r7, sp, #0
 801f5ea:	6078      	str	r0, [r7, #4]
 801f5ec:	6039      	str	r1, [r7, #0]
    JSON_Value *new_value = (JSON_Value*)parson_malloc(sizeof(JSON_Value));
 801f5ee:	4b0d      	ldr	r3, [pc, #52]	@ (801f624 <json_value_init_string_no_copy+0x40>)
 801f5f0:	681b      	ldr	r3, [r3, #0]
 801f5f2:	2010      	movs	r0, #16
 801f5f4:	4798      	blx	r3
 801f5f6:	60f8      	str	r0, [r7, #12]
    if (!new_value) {
 801f5f8:	68fb      	ldr	r3, [r7, #12]
 801f5fa:	2b00      	cmp	r3, #0
 801f5fc:	d101      	bne.n	801f602 <json_value_init_string_no_copy+0x1e>
        return NULL;
 801f5fe:	2300      	movs	r3, #0
 801f600:	e00c      	b.n	801f61c <json_value_init_string_no_copy+0x38>
    }
    new_value->parent = NULL;
 801f602:	68fb      	ldr	r3, [r7, #12]
 801f604:	2200      	movs	r2, #0
 801f606:	601a      	str	r2, [r3, #0]
    new_value->type = JSONString;
 801f608:	68fb      	ldr	r3, [r7, #12]
 801f60a:	2202      	movs	r2, #2
 801f60c:	605a      	str	r2, [r3, #4]
    new_value->value.string.chars = string;
 801f60e:	68fb      	ldr	r3, [r7, #12]
 801f610:	687a      	ldr	r2, [r7, #4]
 801f612:	609a      	str	r2, [r3, #8]
    new_value->value.string.length = length;
 801f614:	68fb      	ldr	r3, [r7, #12]
 801f616:	683a      	ldr	r2, [r7, #0]
 801f618:	60da      	str	r2, [r3, #12]
    return new_value;
 801f61a:	68fb      	ldr	r3, [r7, #12]
}
 801f61c:	4618      	mov	r0, r3
 801f61e:	3710      	adds	r7, #16
 801f620:	46bd      	mov	sp, r7
 801f622:	bd80      	pop	{r7, pc}
 801f624:	20000210 	.word	0x20000210

0801f628 <skip_quotes>:

/* Parser */
static JSON_Status skip_quotes(const char **string) {
 801f628:	b480      	push	{r7}
 801f62a:	b083      	sub	sp, #12
 801f62c:	af00      	add	r7, sp, #0
 801f62e:	6078      	str	r0, [r7, #4]
    if (**string != '\"') {
 801f630:	687b      	ldr	r3, [r7, #4]
 801f632:	681b      	ldr	r3, [r3, #0]
 801f634:	781b      	ldrb	r3, [r3, #0]
 801f636:	2b22      	cmp	r3, #34	@ 0x22
 801f638:	d002      	beq.n	801f640 <skip_quotes+0x18>
        return JSONFailure;
 801f63a:	f04f 33ff 	mov.w	r3, #4294967295
 801f63e:	e02f      	b.n	801f6a0 <skip_quotes+0x78>
    }
    SKIP_CHAR(string);
 801f640:	687b      	ldr	r3, [r7, #4]
 801f642:	681b      	ldr	r3, [r3, #0]
 801f644:	1c5a      	adds	r2, r3, #1
 801f646:	687b      	ldr	r3, [r7, #4]
 801f648:	601a      	str	r2, [r3, #0]
    while (**string != '\"') {
 801f64a:	e01e      	b.n	801f68a <skip_quotes+0x62>
        if (**string == '\0') {
 801f64c:	687b      	ldr	r3, [r7, #4]
 801f64e:	681b      	ldr	r3, [r3, #0]
 801f650:	781b      	ldrb	r3, [r3, #0]
 801f652:	2b00      	cmp	r3, #0
 801f654:	d102      	bne.n	801f65c <skip_quotes+0x34>
            return JSONFailure;
 801f656:	f04f 33ff 	mov.w	r3, #4294967295
 801f65a:	e021      	b.n	801f6a0 <skip_quotes+0x78>
        } else if (**string == '\\') {
 801f65c:	687b      	ldr	r3, [r7, #4]
 801f65e:	681b      	ldr	r3, [r3, #0]
 801f660:	781b      	ldrb	r3, [r3, #0]
 801f662:	2b5c      	cmp	r3, #92	@ 0x5c
 801f664:	d10c      	bne.n	801f680 <skip_quotes+0x58>
            SKIP_CHAR(string);
 801f666:	687b      	ldr	r3, [r7, #4]
 801f668:	681b      	ldr	r3, [r3, #0]
 801f66a:	1c5a      	adds	r2, r3, #1
 801f66c:	687b      	ldr	r3, [r7, #4]
 801f66e:	601a      	str	r2, [r3, #0]
            if (**string == '\0') {
 801f670:	687b      	ldr	r3, [r7, #4]
 801f672:	681b      	ldr	r3, [r3, #0]
 801f674:	781b      	ldrb	r3, [r3, #0]
 801f676:	2b00      	cmp	r3, #0
 801f678:	d102      	bne.n	801f680 <skip_quotes+0x58>
                return JSONFailure;
 801f67a:	f04f 33ff 	mov.w	r3, #4294967295
 801f67e:	e00f      	b.n	801f6a0 <skip_quotes+0x78>
            }
        }
        SKIP_CHAR(string);
 801f680:	687b      	ldr	r3, [r7, #4]
 801f682:	681b      	ldr	r3, [r3, #0]
 801f684:	1c5a      	adds	r2, r3, #1
 801f686:	687b      	ldr	r3, [r7, #4]
 801f688:	601a      	str	r2, [r3, #0]
    while (**string != '\"') {
 801f68a:	687b      	ldr	r3, [r7, #4]
 801f68c:	681b      	ldr	r3, [r3, #0]
 801f68e:	781b      	ldrb	r3, [r3, #0]
 801f690:	2b22      	cmp	r3, #34	@ 0x22
 801f692:	d1db      	bne.n	801f64c <skip_quotes+0x24>
    }
    SKIP_CHAR(string);
 801f694:	687b      	ldr	r3, [r7, #4]
 801f696:	681b      	ldr	r3, [r3, #0]
 801f698:	1c5a      	adds	r2, r3, #1
 801f69a:	687b      	ldr	r3, [r7, #4]
 801f69c:	601a      	str	r2, [r3, #0]
    return JSONSuccess;
 801f69e:	2300      	movs	r3, #0
}
 801f6a0:	4618      	mov	r0, r3
 801f6a2:	370c      	adds	r7, #12
 801f6a4:	46bd      	mov	sp, r7
 801f6a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 801f6aa:	4770      	bx	lr

0801f6ac <parse_utf16>:

static JSON_Status parse_utf16(const char **unprocessed, char **processed) {
 801f6ac:	b580      	push	{r7, lr}
 801f6ae:	b088      	sub	sp, #32
 801f6b0:	af00      	add	r7, sp, #0
 801f6b2:	6078      	str	r0, [r7, #4]
 801f6b4:	6039      	str	r1, [r7, #0]
    unsigned int cp, lead, trail;
    char *processed_ptr = *processed;
 801f6b6:	683b      	ldr	r3, [r7, #0]
 801f6b8:	681b      	ldr	r3, [r3, #0]
 801f6ba:	61fb      	str	r3, [r7, #28]
    const char *unprocessed_ptr = *unprocessed;
 801f6bc:	687b      	ldr	r3, [r7, #4]
 801f6be:	681b      	ldr	r3, [r3, #0]
 801f6c0:	61bb      	str	r3, [r7, #24]
    JSON_Status status = JSONFailure;
 801f6c2:	f04f 33ff 	mov.w	r3, #4294967295
 801f6c6:	617b      	str	r3, [r7, #20]
    unprocessed_ptr++; /* skips u */
 801f6c8:	69bb      	ldr	r3, [r7, #24]
 801f6ca:	3301      	adds	r3, #1
 801f6cc:	61bb      	str	r3, [r7, #24]
    status = parse_utf16_hex(unprocessed_ptr, &cp);
 801f6ce:	f107 030c 	add.w	r3, r7, #12
 801f6d2:	4619      	mov	r1, r3
 801f6d4:	69b8      	ldr	r0, [r7, #24]
 801f6d6:	f7ff f88a 	bl	801e7ee <parse_utf16_hex>
 801f6da:	6178      	str	r0, [r7, #20]
    if (status != JSONSuccess) {
 801f6dc:	697b      	ldr	r3, [r7, #20]
 801f6de:	2b00      	cmp	r3, #0
 801f6e0:	d002      	beq.n	801f6e8 <parse_utf16+0x3c>
        return JSONFailure;
 801f6e2:	f04f 33ff 	mov.w	r3, #4294967295
 801f6e6:	e0ce      	b.n	801f886 <parse_utf16+0x1da>
    }
    if (cp < 0x80) {
 801f6e8:	68fb      	ldr	r3, [r7, #12]
 801f6ea:	2b7f      	cmp	r3, #127	@ 0x7f
 801f6ec:	d804      	bhi.n	801f6f8 <parse_utf16+0x4c>
        processed_ptr[0] = (char)cp; /* 0xxxxxxx */
 801f6ee:	68fb      	ldr	r3, [r7, #12]
 801f6f0:	b2da      	uxtb	r2, r3
 801f6f2:	69fb      	ldr	r3, [r7, #28]
 801f6f4:	701a      	strb	r2, [r3, #0]
 801f6f6:	e0bc      	b.n	801f872 <parse_utf16+0x1c6>
    } else if (cp < 0x800) {
 801f6f8:	68fb      	ldr	r3, [r7, #12]
 801f6fa:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 801f6fe:	d219      	bcs.n	801f734 <parse_utf16+0x88>
        processed_ptr[0] = ((cp >> 6) & 0x1F) | 0xC0; /* 110xxxxx */
 801f700:	68fb      	ldr	r3, [r7, #12]
 801f702:	099b      	lsrs	r3, r3, #6
 801f704:	b2db      	uxtb	r3, r3
 801f706:	f003 031f 	and.w	r3, r3, #31
 801f70a:	b2db      	uxtb	r3, r3
 801f70c:	f063 033f 	orn	r3, r3, #63	@ 0x3f
 801f710:	b2da      	uxtb	r2, r3
 801f712:	69fb      	ldr	r3, [r7, #28]
 801f714:	701a      	strb	r2, [r3, #0]
        processed_ptr[1] = ((cp)      & 0x3F) | 0x80; /* 10xxxxxx */
 801f716:	68fb      	ldr	r3, [r7, #12]
 801f718:	b2db      	uxtb	r3, r3
 801f71a:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 801f71e:	b2da      	uxtb	r2, r3
 801f720:	69fb      	ldr	r3, [r7, #28]
 801f722:	3301      	adds	r3, #1
 801f724:	f062 027f 	orn	r2, r2, #127	@ 0x7f
 801f728:	b2d2      	uxtb	r2, r2
 801f72a:	701a      	strb	r2, [r3, #0]
        processed_ptr += 1;
 801f72c:	69fb      	ldr	r3, [r7, #28]
 801f72e:	3301      	adds	r3, #1
 801f730:	61fb      	str	r3, [r7, #28]
 801f732:	e09e      	b.n	801f872 <parse_utf16+0x1c6>
    } else if (cp < 0xD800 || cp > 0xDFFF) {
 801f734:	68fb      	ldr	r3, [r7, #12]
 801f736:	f5b3 4f58 	cmp.w	r3, #55296	@ 0xd800
 801f73a:	d303      	bcc.n	801f744 <parse_utf16+0x98>
 801f73c:	68fb      	ldr	r3, [r7, #12]
 801f73e:	f5b3 4f60 	cmp.w	r3, #57344	@ 0xe000
 801f742:	d325      	bcc.n	801f790 <parse_utf16+0xe4>
        processed_ptr[0] = ((cp >> 12) & 0x0F) | 0xE0; /* 1110xxxx */
 801f744:	68fb      	ldr	r3, [r7, #12]
 801f746:	0b1b      	lsrs	r3, r3, #12
 801f748:	b2db      	uxtb	r3, r3
 801f74a:	f003 030f 	and.w	r3, r3, #15
 801f74e:	b2db      	uxtb	r3, r3
 801f750:	f063 031f 	orn	r3, r3, #31
 801f754:	b2da      	uxtb	r2, r3
 801f756:	69fb      	ldr	r3, [r7, #28]
 801f758:	701a      	strb	r2, [r3, #0]
        processed_ptr[1] = ((cp >> 6)  & 0x3F) | 0x80; /* 10xxxxxx */
 801f75a:	68fb      	ldr	r3, [r7, #12]
 801f75c:	099b      	lsrs	r3, r3, #6
 801f75e:	b2db      	uxtb	r3, r3
 801f760:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 801f764:	b2da      	uxtb	r2, r3
 801f766:	69fb      	ldr	r3, [r7, #28]
 801f768:	3301      	adds	r3, #1
 801f76a:	f062 027f 	orn	r2, r2, #127	@ 0x7f
 801f76e:	b2d2      	uxtb	r2, r2
 801f770:	701a      	strb	r2, [r3, #0]
        processed_ptr[2] = ((cp)       & 0x3F) | 0x80; /* 10xxxxxx */
 801f772:	68fb      	ldr	r3, [r7, #12]
 801f774:	b2db      	uxtb	r3, r3
 801f776:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 801f77a:	b2da      	uxtb	r2, r3
 801f77c:	69fb      	ldr	r3, [r7, #28]
 801f77e:	3302      	adds	r3, #2
 801f780:	f062 027f 	orn	r2, r2, #127	@ 0x7f
 801f784:	b2d2      	uxtb	r2, r2
 801f786:	701a      	strb	r2, [r3, #0]
        processed_ptr += 2;
 801f788:	69fb      	ldr	r3, [r7, #28]
 801f78a:	3302      	adds	r3, #2
 801f78c:	61fb      	str	r3, [r7, #28]
 801f78e:	e070      	b.n	801f872 <parse_utf16+0x1c6>
    } else if (cp >= 0xD800 && cp <= 0xDBFF) { /* lead surrogate (0xD800..0xDBFF) */
 801f790:	68fb      	ldr	r3, [r7, #12]
 801f792:	f5b3 4f58 	cmp.w	r3, #55296	@ 0xd800
 801f796:	d369      	bcc.n	801f86c <parse_utf16+0x1c0>
 801f798:	68fb      	ldr	r3, [r7, #12]
 801f79a:	f5b3 4f5c 	cmp.w	r3, #56320	@ 0xdc00
 801f79e:	d265      	bcs.n	801f86c <parse_utf16+0x1c0>
        lead = cp;
 801f7a0:	68fb      	ldr	r3, [r7, #12]
 801f7a2:	613b      	str	r3, [r7, #16]
        unprocessed_ptr += 4; /* should always be within the buffer, otherwise previous sscanf would fail */
 801f7a4:	69bb      	ldr	r3, [r7, #24]
 801f7a6:	3304      	adds	r3, #4
 801f7a8:	61bb      	str	r3, [r7, #24]
        if (*unprocessed_ptr++ != '\\' || *unprocessed_ptr++ != 'u') {
 801f7aa:	69bb      	ldr	r3, [r7, #24]
 801f7ac:	1c5a      	adds	r2, r3, #1
 801f7ae:	61ba      	str	r2, [r7, #24]
 801f7b0:	781b      	ldrb	r3, [r3, #0]
 801f7b2:	2b5c      	cmp	r3, #92	@ 0x5c
 801f7b4:	d105      	bne.n	801f7c2 <parse_utf16+0x116>
 801f7b6:	69bb      	ldr	r3, [r7, #24]
 801f7b8:	1c5a      	adds	r2, r3, #1
 801f7ba:	61ba      	str	r2, [r7, #24]
 801f7bc:	781b      	ldrb	r3, [r3, #0]
 801f7be:	2b75      	cmp	r3, #117	@ 0x75
 801f7c0:	d002      	beq.n	801f7c8 <parse_utf16+0x11c>
            return JSONFailure;
 801f7c2:	f04f 33ff 	mov.w	r3, #4294967295
 801f7c6:	e05e      	b.n	801f886 <parse_utf16+0x1da>
        }
        status = parse_utf16_hex(unprocessed_ptr, &trail);
 801f7c8:	f107 0308 	add.w	r3, r7, #8
 801f7cc:	4619      	mov	r1, r3
 801f7ce:	69b8      	ldr	r0, [r7, #24]
 801f7d0:	f7ff f80d 	bl	801e7ee <parse_utf16_hex>
 801f7d4:	6178      	str	r0, [r7, #20]
        if (status != JSONSuccess || trail < 0xDC00 || trail > 0xDFFF) { /* valid trail surrogate? (0xDC00..0xDFFF) */
 801f7d6:	697b      	ldr	r3, [r7, #20]
 801f7d8:	2b00      	cmp	r3, #0
 801f7da:	d107      	bne.n	801f7ec <parse_utf16+0x140>
 801f7dc:	68bb      	ldr	r3, [r7, #8]
 801f7de:	f5b3 4f5c 	cmp.w	r3, #56320	@ 0xdc00
 801f7e2:	d303      	bcc.n	801f7ec <parse_utf16+0x140>
 801f7e4:	68bb      	ldr	r3, [r7, #8]
 801f7e6:	f5b3 4f60 	cmp.w	r3, #57344	@ 0xe000
 801f7ea:	d302      	bcc.n	801f7f2 <parse_utf16+0x146>
            return JSONFailure;
 801f7ec:	f04f 33ff 	mov.w	r3, #4294967295
 801f7f0:	e049      	b.n	801f886 <parse_utf16+0x1da>
        }
        cp = ((((lead - 0xD800) & 0x3FF) << 10) | ((trail - 0xDC00) & 0x3FF)) + 0x010000;
 801f7f2:	693b      	ldr	r3, [r7, #16]
 801f7f4:	029a      	lsls	r2, r3, #10
 801f7f6:	4b26      	ldr	r3, [pc, #152]	@ (801f890 <parse_utf16+0x1e4>)
 801f7f8:	4013      	ands	r3, r2
 801f7fa:	68ba      	ldr	r2, [r7, #8]
 801f7fc:	f3c2 0209 	ubfx	r2, r2, #0, #10
 801f800:	4313      	orrs	r3, r2
 801f802:	f503 3380 	add.w	r3, r3, #65536	@ 0x10000
 801f806:	60fb      	str	r3, [r7, #12]
        processed_ptr[0] = (((cp >> 18) & 0x07) | 0xF0); /* 11110xxx */
 801f808:	68fb      	ldr	r3, [r7, #12]
 801f80a:	0c9b      	lsrs	r3, r3, #18
 801f80c:	b2db      	uxtb	r3, r3
 801f80e:	f003 0307 	and.w	r3, r3, #7
 801f812:	b2db      	uxtb	r3, r3
 801f814:	f063 030f 	orn	r3, r3, #15
 801f818:	b2da      	uxtb	r2, r3
 801f81a:	69fb      	ldr	r3, [r7, #28]
 801f81c:	701a      	strb	r2, [r3, #0]
        processed_ptr[1] = (((cp >> 12) & 0x3F) | 0x80); /* 10xxxxxx */
 801f81e:	68fb      	ldr	r3, [r7, #12]
 801f820:	0b1b      	lsrs	r3, r3, #12
 801f822:	b2db      	uxtb	r3, r3
 801f824:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 801f828:	b2da      	uxtb	r2, r3
 801f82a:	69fb      	ldr	r3, [r7, #28]
 801f82c:	3301      	adds	r3, #1
 801f82e:	f062 027f 	orn	r2, r2, #127	@ 0x7f
 801f832:	b2d2      	uxtb	r2, r2
 801f834:	701a      	strb	r2, [r3, #0]
        processed_ptr[2] = (((cp >> 6)  & 0x3F) | 0x80); /* 10xxxxxx */
 801f836:	68fb      	ldr	r3, [r7, #12]
 801f838:	099b      	lsrs	r3, r3, #6
 801f83a:	b2db      	uxtb	r3, r3
 801f83c:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 801f840:	b2da      	uxtb	r2, r3
 801f842:	69fb      	ldr	r3, [r7, #28]
 801f844:	3302      	adds	r3, #2
 801f846:	f062 027f 	orn	r2, r2, #127	@ 0x7f
 801f84a:	b2d2      	uxtb	r2, r2
 801f84c:	701a      	strb	r2, [r3, #0]
        processed_ptr[3] = (((cp)       & 0x3F) | 0x80); /* 10xxxxxx */
 801f84e:	68fb      	ldr	r3, [r7, #12]
 801f850:	b2db      	uxtb	r3, r3
 801f852:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 801f856:	b2da      	uxtb	r2, r3
 801f858:	69fb      	ldr	r3, [r7, #28]
 801f85a:	3303      	adds	r3, #3
 801f85c:	f062 027f 	orn	r2, r2, #127	@ 0x7f
 801f860:	b2d2      	uxtb	r2, r2
 801f862:	701a      	strb	r2, [r3, #0]
        processed_ptr += 3;
 801f864:	69fb      	ldr	r3, [r7, #28]
 801f866:	3303      	adds	r3, #3
 801f868:	61fb      	str	r3, [r7, #28]
 801f86a:	e002      	b.n	801f872 <parse_utf16+0x1c6>
    } else { /* trail surrogate before lead surrogate */
        return JSONFailure;
 801f86c:	f04f 33ff 	mov.w	r3, #4294967295
 801f870:	e009      	b.n	801f886 <parse_utf16+0x1da>
    }
    unprocessed_ptr += 3;
 801f872:	69bb      	ldr	r3, [r7, #24]
 801f874:	3303      	adds	r3, #3
 801f876:	61bb      	str	r3, [r7, #24]
    *processed = processed_ptr;
 801f878:	683b      	ldr	r3, [r7, #0]
 801f87a:	69fa      	ldr	r2, [r7, #28]
 801f87c:	601a      	str	r2, [r3, #0]
    *unprocessed = unprocessed_ptr;
 801f87e:	687b      	ldr	r3, [r7, #4]
 801f880:	69ba      	ldr	r2, [r7, #24]
 801f882:	601a      	str	r2, [r3, #0]
    return JSONSuccess;
 801f884:	2300      	movs	r3, #0
}
 801f886:	4618      	mov	r0, r3
 801f888:	3720      	adds	r7, #32
 801f88a:	46bd      	mov	sp, r7
 801f88c:	bd80      	pop	{r7, pc}
 801f88e:	bf00      	nop
 801f890:	000ffc00 	.word	0x000ffc00

0801f894 <process_string>:


/* Copies and processes passed string up to supplied length.
Example: "\u006Corem ipsum" -> lorem ipsum */
static char* process_string(const char *input, size_t input_len, size_t *output_len) {
 801f894:	b580      	push	{r7, lr}
 801f896:	b08a      	sub	sp, #40	@ 0x28
 801f898:	af00      	add	r7, sp, #0
 801f89a:	60f8      	str	r0, [r7, #12]
 801f89c:	60b9      	str	r1, [r7, #8]
 801f89e:	607a      	str	r2, [r7, #4]
    const char *input_ptr = input;
 801f8a0:	68fb      	ldr	r3, [r7, #12]
 801f8a2:	617b      	str	r3, [r7, #20]
    size_t initial_size = (input_len + 1) * sizeof(char);
 801f8a4:	68bb      	ldr	r3, [r7, #8]
 801f8a6:	3301      	adds	r3, #1
 801f8a8:	627b      	str	r3, [r7, #36]	@ 0x24
    size_t final_size = 0;
 801f8aa:	2300      	movs	r3, #0
 801f8ac:	623b      	str	r3, [r7, #32]
    char *output = NULL, *output_ptr = NULL, *resized_output = NULL;
 801f8ae:	2300      	movs	r3, #0
 801f8b0:	61fb      	str	r3, [r7, #28]
 801f8b2:	2300      	movs	r3, #0
 801f8b4:	613b      	str	r3, [r7, #16]
 801f8b6:	2300      	movs	r3, #0
 801f8b8:	61bb      	str	r3, [r7, #24]
    output = (char*)parson_malloc(initial_size);
 801f8ba:	4b69      	ldr	r3, [pc, #420]	@ (801fa60 <process_string+0x1cc>)
 801f8bc:	681b      	ldr	r3, [r3, #0]
 801f8be:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 801f8c0:	4798      	blx	r3
 801f8c2:	61f8      	str	r0, [r7, #28]
    if (output == NULL) {
 801f8c4:	69fb      	ldr	r3, [r7, #28]
 801f8c6:	2b00      	cmp	r3, #0
 801f8c8:	f000 80b9 	beq.w	801fa3e <process_string+0x1aa>
        goto error;
    }
    output_ptr = output;
 801f8cc:	69fb      	ldr	r3, [r7, #28]
 801f8ce:	613b      	str	r3, [r7, #16]
    while ((*input_ptr != '\0') && (size_t)(input_ptr - input) < input_len) {
 801f8d0:	e08a      	b.n	801f9e8 <process_string+0x154>
        if (*input_ptr == '\\') {
 801f8d2:	697b      	ldr	r3, [r7, #20]
 801f8d4:	781b      	ldrb	r3, [r3, #0]
 801f8d6:	2b5c      	cmp	r3, #92	@ 0x5c
 801f8d8:	d176      	bne.n	801f9c8 <process_string+0x134>
            input_ptr++;
 801f8da:	697b      	ldr	r3, [r7, #20]
 801f8dc:	3301      	adds	r3, #1
 801f8de:	617b      	str	r3, [r7, #20]
            switch (*input_ptr) {
 801f8e0:	697b      	ldr	r3, [r7, #20]
 801f8e2:	781b      	ldrb	r3, [r3, #0]
 801f8e4:	2b75      	cmp	r3, #117	@ 0x75
 801f8e6:	f300 80ac 	bgt.w	801fa42 <process_string+0x1ae>
 801f8ea:	2b5c      	cmp	r3, #92	@ 0x5c
 801f8ec:	da04      	bge.n	801f8f8 <process_string+0x64>
 801f8ee:	2b22      	cmp	r3, #34	@ 0x22
 801f8f0:	d03e      	beq.n	801f970 <process_string+0xdc>
 801f8f2:	2b2f      	cmp	r3, #47	@ 0x2f
 801f8f4:	d044      	beq.n	801f980 <process_string+0xec>
                    if (parse_utf16(&input_ptr, &output_ptr) != JSONSuccess) {
                        goto error;
                    }
                    break;
                default:
                    goto error;
 801f8f6:	e0a4      	b.n	801fa42 <process_string+0x1ae>
            switch (*input_ptr) {
 801f8f8:	3b5c      	subs	r3, #92	@ 0x5c
 801f8fa:	2b19      	cmp	r3, #25
 801f8fc:	f200 80a1 	bhi.w	801fa42 <process_string+0x1ae>
 801f900:	a201      	add	r2, pc, #4	@ (adr r2, 801f908 <process_string+0x74>)
 801f902:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801f906:	bf00      	nop
 801f908:	0801f979 	.word	0x0801f979
 801f90c:	0801fa43 	.word	0x0801fa43
 801f910:	0801fa43 	.word	0x0801fa43
 801f914:	0801fa43 	.word	0x0801fa43
 801f918:	0801fa43 	.word	0x0801fa43
 801f91c:	0801fa43 	.word	0x0801fa43
 801f920:	0801f989 	.word	0x0801f989
 801f924:	0801fa43 	.word	0x0801fa43
 801f928:	0801fa43 	.word	0x0801fa43
 801f92c:	0801fa43 	.word	0x0801fa43
 801f930:	0801f991 	.word	0x0801f991
 801f934:	0801fa43 	.word	0x0801fa43
 801f938:	0801fa43 	.word	0x0801fa43
 801f93c:	0801fa43 	.word	0x0801fa43
 801f940:	0801fa43 	.word	0x0801fa43
 801f944:	0801fa43 	.word	0x0801fa43
 801f948:	0801fa43 	.word	0x0801fa43
 801f94c:	0801fa43 	.word	0x0801fa43
 801f950:	0801f999 	.word	0x0801f999
 801f954:	0801fa43 	.word	0x0801fa43
 801f958:	0801fa43 	.word	0x0801fa43
 801f95c:	0801fa43 	.word	0x0801fa43
 801f960:	0801f9a1 	.word	0x0801f9a1
 801f964:	0801fa43 	.word	0x0801fa43
 801f968:	0801f9a9 	.word	0x0801f9a9
 801f96c:	0801f9b1 	.word	0x0801f9b1
                case '\"': *output_ptr = '\"'; break;
 801f970:	693b      	ldr	r3, [r7, #16]
 801f972:	2222      	movs	r2, #34	@ 0x22
 801f974:	701a      	strb	r2, [r3, #0]
 801f976:	e031      	b.n	801f9dc <process_string+0x148>
                case '\\': *output_ptr = '\\'; break;
 801f978:	693b      	ldr	r3, [r7, #16]
 801f97a:	225c      	movs	r2, #92	@ 0x5c
 801f97c:	701a      	strb	r2, [r3, #0]
 801f97e:	e02d      	b.n	801f9dc <process_string+0x148>
                case '/':  *output_ptr = '/';  break;
 801f980:	693b      	ldr	r3, [r7, #16]
 801f982:	222f      	movs	r2, #47	@ 0x2f
 801f984:	701a      	strb	r2, [r3, #0]
 801f986:	e029      	b.n	801f9dc <process_string+0x148>
                case 'b':  *output_ptr = '\b'; break;
 801f988:	693b      	ldr	r3, [r7, #16]
 801f98a:	2208      	movs	r2, #8
 801f98c:	701a      	strb	r2, [r3, #0]
 801f98e:	e025      	b.n	801f9dc <process_string+0x148>
                case 'f':  *output_ptr = '\f'; break;
 801f990:	693b      	ldr	r3, [r7, #16]
 801f992:	220c      	movs	r2, #12
 801f994:	701a      	strb	r2, [r3, #0]
 801f996:	e021      	b.n	801f9dc <process_string+0x148>
                case 'n':  *output_ptr = '\n'; break;
 801f998:	693b      	ldr	r3, [r7, #16]
 801f99a:	220a      	movs	r2, #10
 801f99c:	701a      	strb	r2, [r3, #0]
 801f99e:	e01d      	b.n	801f9dc <process_string+0x148>
                case 'r':  *output_ptr = '\r'; break;
 801f9a0:	693b      	ldr	r3, [r7, #16]
 801f9a2:	220d      	movs	r2, #13
 801f9a4:	701a      	strb	r2, [r3, #0]
 801f9a6:	e019      	b.n	801f9dc <process_string+0x148>
                case 't':  *output_ptr = '\t'; break;
 801f9a8:	693b      	ldr	r3, [r7, #16]
 801f9aa:	2209      	movs	r2, #9
 801f9ac:	701a      	strb	r2, [r3, #0]
 801f9ae:	e015      	b.n	801f9dc <process_string+0x148>
                    if (parse_utf16(&input_ptr, &output_ptr) != JSONSuccess) {
 801f9b0:	f107 0210 	add.w	r2, r7, #16
 801f9b4:	f107 0314 	add.w	r3, r7, #20
 801f9b8:	4611      	mov	r1, r2
 801f9ba:	4618      	mov	r0, r3
 801f9bc:	f7ff fe76 	bl	801f6ac <parse_utf16>
 801f9c0:	4603      	mov	r3, r0
 801f9c2:	2b00      	cmp	r3, #0
 801f9c4:	d009      	beq.n	801f9da <process_string+0x146>
                        goto error;
 801f9c6:	e041      	b.n	801fa4c <process_string+0x1b8>
            }
        } else if ((unsigned char)*input_ptr < 0x20) {
 801f9c8:	697b      	ldr	r3, [r7, #20]
 801f9ca:	781b      	ldrb	r3, [r3, #0]
 801f9cc:	2b1f      	cmp	r3, #31
 801f9ce:	d93a      	bls.n	801fa46 <process_string+0x1b2>
            goto error; /* 0x00-0x19 are invalid characters for json string (http://www.ietf.org/rfc/rfc4627.txt) */
        } else {
            *output_ptr = *input_ptr;
 801f9d0:	697a      	ldr	r2, [r7, #20]
 801f9d2:	693b      	ldr	r3, [r7, #16]
 801f9d4:	7812      	ldrb	r2, [r2, #0]
 801f9d6:	701a      	strb	r2, [r3, #0]
 801f9d8:	e000      	b.n	801f9dc <process_string+0x148>
                    break;
 801f9da:	bf00      	nop
        }
        output_ptr++;
 801f9dc:	693b      	ldr	r3, [r7, #16]
 801f9de:	3301      	adds	r3, #1
 801f9e0:	613b      	str	r3, [r7, #16]
        input_ptr++;
 801f9e2:	697b      	ldr	r3, [r7, #20]
 801f9e4:	3301      	adds	r3, #1
 801f9e6:	617b      	str	r3, [r7, #20]
    while ((*input_ptr != '\0') && (size_t)(input_ptr - input) < input_len) {
 801f9e8:	697b      	ldr	r3, [r7, #20]
 801f9ea:	781b      	ldrb	r3, [r3, #0]
 801f9ec:	2b00      	cmp	r3, #0
 801f9ee:	d007      	beq.n	801fa00 <process_string+0x16c>
 801f9f0:	697a      	ldr	r2, [r7, #20]
 801f9f2:	68fb      	ldr	r3, [r7, #12]
 801f9f4:	1ad3      	subs	r3, r2, r3
 801f9f6:	461a      	mov	r2, r3
 801f9f8:	68bb      	ldr	r3, [r7, #8]
 801f9fa:	4293      	cmp	r3, r2
 801f9fc:	f63f af69 	bhi.w	801f8d2 <process_string+0x3e>
    }
    *output_ptr = '\0';
 801fa00:	693b      	ldr	r3, [r7, #16]
 801fa02:	2200      	movs	r2, #0
 801fa04:	701a      	strb	r2, [r3, #0]
    /* resize to new length */
    final_size = (size_t)(output_ptr-output) + 1;
 801fa06:	693a      	ldr	r2, [r7, #16]
 801fa08:	69fb      	ldr	r3, [r7, #28]
 801fa0a:	1ad3      	subs	r3, r2, r3
 801fa0c:	3301      	adds	r3, #1
 801fa0e:	623b      	str	r3, [r7, #32]
    /* todo: don't resize if final_size == initial_size */
    resized_output = (char*)parson_malloc(final_size);
 801fa10:	4b13      	ldr	r3, [pc, #76]	@ (801fa60 <process_string+0x1cc>)
 801fa12:	681b      	ldr	r3, [r3, #0]
 801fa14:	6a38      	ldr	r0, [r7, #32]
 801fa16:	4798      	blx	r3
 801fa18:	61b8      	str	r0, [r7, #24]
    if (resized_output == NULL) {
 801fa1a:	69bb      	ldr	r3, [r7, #24]
 801fa1c:	2b00      	cmp	r3, #0
 801fa1e:	d014      	beq.n	801fa4a <process_string+0x1b6>
        goto error;
    }
    memcpy(resized_output, output, final_size);
 801fa20:	6a3a      	ldr	r2, [r7, #32]
 801fa22:	69f9      	ldr	r1, [r7, #28]
 801fa24:	69b8      	ldr	r0, [r7, #24]
 801fa26:	f004 fbe2 	bl	80241ee <memcpy>
    *output_len = final_size - 1;
 801fa2a:	6a3b      	ldr	r3, [r7, #32]
 801fa2c:	1e5a      	subs	r2, r3, #1
 801fa2e:	687b      	ldr	r3, [r7, #4]
 801fa30:	601a      	str	r2, [r3, #0]
    parson_free(output);
 801fa32:	4b0c      	ldr	r3, [pc, #48]	@ (801fa64 <process_string+0x1d0>)
 801fa34:	681b      	ldr	r3, [r3, #0]
 801fa36:	69f8      	ldr	r0, [r7, #28]
 801fa38:	4798      	blx	r3
    return resized_output;
 801fa3a:	69bb      	ldr	r3, [r7, #24]
 801fa3c:	e00b      	b.n	801fa56 <process_string+0x1c2>
        goto error;
 801fa3e:	bf00      	nop
 801fa40:	e004      	b.n	801fa4c <process_string+0x1b8>
                    goto error;
 801fa42:	bf00      	nop
 801fa44:	e002      	b.n	801fa4c <process_string+0x1b8>
            goto error; /* 0x00-0x19 are invalid characters for json string (http://www.ietf.org/rfc/rfc4627.txt) */
 801fa46:	bf00      	nop
 801fa48:	e000      	b.n	801fa4c <process_string+0x1b8>
        goto error;
 801fa4a:	bf00      	nop
error:
    parson_free(output);
 801fa4c:	4b05      	ldr	r3, [pc, #20]	@ (801fa64 <process_string+0x1d0>)
 801fa4e:	681b      	ldr	r3, [r3, #0]
 801fa50:	69f8      	ldr	r0, [r7, #28]
 801fa52:	4798      	blx	r3
    return NULL;
 801fa54:	2300      	movs	r3, #0
}
 801fa56:	4618      	mov	r0, r3
 801fa58:	3728      	adds	r7, #40	@ 0x28
 801fa5a:	46bd      	mov	sp, r7
 801fa5c:	bd80      	pop	{r7, pc}
 801fa5e:	bf00      	nop
 801fa60:	20000210 	.word	0x20000210
 801fa64:	20000214 	.word	0x20000214

0801fa68 <get_quoted_string>:

/* Return processed contents of a string between quotes and
   skips passed argument to a matching quote. */
static char * get_quoted_string(const char **string, size_t *output_string_len) {
 801fa68:	b580      	push	{r7, lr}
 801fa6a:	b086      	sub	sp, #24
 801fa6c:	af00      	add	r7, sp, #0
 801fa6e:	6078      	str	r0, [r7, #4]
 801fa70:	6039      	str	r1, [r7, #0]
    const char *string_start = *string;
 801fa72:	687b      	ldr	r3, [r7, #4]
 801fa74:	681b      	ldr	r3, [r3, #0]
 801fa76:	617b      	str	r3, [r7, #20]
    size_t input_string_len = 0;
 801fa78:	2300      	movs	r3, #0
 801fa7a:	613b      	str	r3, [r7, #16]
    JSON_Status status = skip_quotes(string);
 801fa7c:	6878      	ldr	r0, [r7, #4]
 801fa7e:	f7ff fdd3 	bl	801f628 <skip_quotes>
 801fa82:	60f8      	str	r0, [r7, #12]
    if (status != JSONSuccess) {
 801fa84:	68fb      	ldr	r3, [r7, #12]
 801fa86:	2b00      	cmp	r3, #0
 801fa88:	d001      	beq.n	801fa8e <get_quoted_string+0x26>
        return NULL;
 801fa8a:	2300      	movs	r3, #0
 801fa8c:	e00d      	b.n	801faaa <get_quoted_string+0x42>
    }
    input_string_len = *string - string_start - 2; /* length without quotes */
 801fa8e:	687b      	ldr	r3, [r7, #4]
 801fa90:	681a      	ldr	r2, [r3, #0]
 801fa92:	697b      	ldr	r3, [r7, #20]
 801fa94:	1ad3      	subs	r3, r2, r3
 801fa96:	3b02      	subs	r3, #2
 801fa98:	613b      	str	r3, [r7, #16]
    return process_string(string_start + 1, input_string_len, output_string_len);
 801fa9a:	697b      	ldr	r3, [r7, #20]
 801fa9c:	3301      	adds	r3, #1
 801fa9e:	683a      	ldr	r2, [r7, #0]
 801faa0:	6939      	ldr	r1, [r7, #16]
 801faa2:	4618      	mov	r0, r3
 801faa4:	f7ff fef6 	bl	801f894 <process_string>
 801faa8:	4603      	mov	r3, r0
}
 801faaa:	4618      	mov	r0, r3
 801faac:	3718      	adds	r7, #24
 801faae:	46bd      	mov	sp, r7
 801fab0:	bd80      	pop	{r7, pc}
	...

0801fab4 <parse_value>:

static JSON_Value * parse_value(const char **string, size_t nesting) {
 801fab4:	b580      	push	{r7, lr}
 801fab6:	b082      	sub	sp, #8
 801fab8:	af00      	add	r7, sp, #0
 801faba:	6078      	str	r0, [r7, #4]
 801fabc:	6039      	str	r1, [r7, #0]
    if (nesting > MAX_NESTING) {
 801fabe:	683b      	ldr	r3, [r7, #0]
 801fac0:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 801fac4:	d906      	bls.n	801fad4 <parse_value+0x20>
        return NULL;
 801fac6:	2300      	movs	r3, #0
 801fac8:	e08d      	b.n	801fbe6 <parse_value+0x132>
    }
    SKIP_WHITESPACES(string);
 801faca:	687b      	ldr	r3, [r7, #4]
 801facc:	681b      	ldr	r3, [r3, #0]
 801face:	1c5a      	adds	r2, r3, #1
 801fad0:	687b      	ldr	r3, [r7, #4]
 801fad2:	601a      	str	r2, [r3, #0]
 801fad4:	687b      	ldr	r3, [r7, #4]
 801fad6:	681b      	ldr	r3, [r3, #0]
 801fad8:	781b      	ldrb	r3, [r3, #0]
 801fada:	3301      	adds	r3, #1
 801fadc:	4a44      	ldr	r2, [pc, #272]	@ (801fbf0 <parse_value+0x13c>)
 801fade:	4413      	add	r3, r2
 801fae0:	781b      	ldrb	r3, [r3, #0]
 801fae2:	f003 0308 	and.w	r3, r3, #8
 801fae6:	2b00      	cmp	r3, #0
 801fae8:	d1ef      	bne.n	801faca <parse_value+0x16>
    switch (**string) {
 801faea:	687b      	ldr	r3, [r7, #4]
 801faec:	681b      	ldr	r3, [r3, #0]
 801faee:	781b      	ldrb	r3, [r3, #0]
 801faf0:	2b7b      	cmp	r3, #123	@ 0x7b
 801faf2:	dc77      	bgt.n	801fbe4 <parse_value+0x130>
 801faf4:	2b5b      	cmp	r3, #91	@ 0x5b
 801faf6:	da08      	bge.n	801fb0a <parse_value+0x56>
 801faf8:	2b39      	cmp	r3, #57	@ 0x39
 801fafa:	dc73      	bgt.n	801fbe4 <parse_value+0x130>
 801fafc:	2b30      	cmp	r3, #48	@ 0x30
 801fafe:	da67      	bge.n	801fbd0 <parse_value+0x11c>
 801fb00:	2b22      	cmp	r3, #34	@ 0x22
 801fb02:	d05b      	beq.n	801fbbc <parse_value+0x108>
 801fb04:	2b2d      	cmp	r3, #45	@ 0x2d
 801fb06:	d063      	beq.n	801fbd0 <parse_value+0x11c>
 801fb08:	e06c      	b.n	801fbe4 <parse_value+0x130>
 801fb0a:	3b5b      	subs	r3, #91	@ 0x5b
 801fb0c:	2b20      	cmp	r3, #32
 801fb0e:	d869      	bhi.n	801fbe4 <parse_value+0x130>
 801fb10:	a201      	add	r2, pc, #4	@ (adr r2, 801fb18 <parse_value+0x64>)
 801fb12:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801fb16:	bf00      	nop
 801fb18:	0801fbad 	.word	0x0801fbad
 801fb1c:	0801fbe5 	.word	0x0801fbe5
 801fb20:	0801fbe5 	.word	0x0801fbe5
 801fb24:	0801fbe5 	.word	0x0801fbe5
 801fb28:	0801fbe5 	.word	0x0801fbe5
 801fb2c:	0801fbe5 	.word	0x0801fbe5
 801fb30:	0801fbe5 	.word	0x0801fbe5
 801fb34:	0801fbe5 	.word	0x0801fbe5
 801fb38:	0801fbe5 	.word	0x0801fbe5
 801fb3c:	0801fbe5 	.word	0x0801fbe5
 801fb40:	0801fbe5 	.word	0x0801fbe5
 801fb44:	0801fbc7 	.word	0x0801fbc7
 801fb48:	0801fbe5 	.word	0x0801fbe5
 801fb4c:	0801fbe5 	.word	0x0801fbe5
 801fb50:	0801fbe5 	.word	0x0801fbe5
 801fb54:	0801fbe5 	.word	0x0801fbe5
 801fb58:	0801fbe5 	.word	0x0801fbe5
 801fb5c:	0801fbe5 	.word	0x0801fbe5
 801fb60:	0801fbe5 	.word	0x0801fbe5
 801fb64:	0801fbdb 	.word	0x0801fbdb
 801fb68:	0801fbe5 	.word	0x0801fbe5
 801fb6c:	0801fbe5 	.word	0x0801fbe5
 801fb70:	0801fbe5 	.word	0x0801fbe5
 801fb74:	0801fbe5 	.word	0x0801fbe5
 801fb78:	0801fbe5 	.word	0x0801fbe5
 801fb7c:	0801fbc7 	.word	0x0801fbc7
 801fb80:	0801fbe5 	.word	0x0801fbe5
 801fb84:	0801fbe5 	.word	0x0801fbe5
 801fb88:	0801fbe5 	.word	0x0801fbe5
 801fb8c:	0801fbe5 	.word	0x0801fbe5
 801fb90:	0801fbe5 	.word	0x0801fbe5
 801fb94:	0801fbe5 	.word	0x0801fbe5
 801fb98:	0801fb9d 	.word	0x0801fb9d
        case '{':
            return parse_object_value(string, nesting + 1);
 801fb9c:	683b      	ldr	r3, [r7, #0]
 801fb9e:	3301      	adds	r3, #1
 801fba0:	4619      	mov	r1, r3
 801fba2:	6878      	ldr	r0, [r7, #4]
 801fba4:	f000 f826 	bl	801fbf4 <parse_object_value>
 801fba8:	4603      	mov	r3, r0
 801fbaa:	e01c      	b.n	801fbe6 <parse_value+0x132>
        case '[':
            return parse_array_value(string, nesting + 1);
 801fbac:	683b      	ldr	r3, [r7, #0]
 801fbae:	3301      	adds	r3, #1
 801fbb0:	4619      	mov	r1, r3
 801fbb2:	6878      	ldr	r0, [r7, #4]
 801fbb4:	f000 f934 	bl	801fe20 <parse_array_value>
 801fbb8:	4603      	mov	r3, r0
 801fbba:	e014      	b.n	801fbe6 <parse_value+0x132>
        case '\"':
            return parse_string_value(string);
 801fbbc:	6878      	ldr	r0, [r7, #4]
 801fbbe:	f000 f9f9 	bl	801ffb4 <parse_string_value>
 801fbc2:	4603      	mov	r3, r0
 801fbc4:	e00f      	b.n	801fbe6 <parse_value+0x132>
        case 'f': case 't':
            return parse_boolean_value(string);
 801fbc6:	6878      	ldr	r0, [r7, #4]
 801fbc8:	f000 fa1e 	bl	8020008 <parse_boolean_value>
 801fbcc:	4603      	mov	r3, r0
 801fbce:	e00a      	b.n	801fbe6 <parse_value+0x132>
        case '-':
        case '0': case '1': case '2': case '3': case '4':
        case '5': case '6': case '7': case '8': case '9':
            return parse_number_value(string);
 801fbd0:	6878      	ldr	r0, [r7, #4]
 801fbd2:	f000 fa55 	bl	8020080 <parse_number_value>
 801fbd6:	4603      	mov	r3, r0
 801fbd8:	e005      	b.n	801fbe6 <parse_value+0x132>
        case 'n':
            return parse_null_value(string);
 801fbda:	6878      	ldr	r0, [r7, #4]
 801fbdc:	f000 faae 	bl	802013c <parse_null_value>
 801fbe0:	4603      	mov	r3, r0
 801fbe2:	e000      	b.n	801fbe6 <parse_value+0x132>
        default:
            return NULL;
 801fbe4:	2300      	movs	r3, #0
    }
}
 801fbe6:	4618      	mov	r0, r3
 801fbe8:	3708      	adds	r7, #8
 801fbea:	46bd      	mov	sp, r7
 801fbec:	bd80      	pop	{r7, pc}
 801fbee:	bf00      	nop
 801fbf0:	0802aac0 	.word	0x0802aac0

0801fbf4 <parse_object_value>:

static JSON_Value * parse_object_value(const char **string, size_t nesting) {
 801fbf4:	b580      	push	{r7, lr}
 801fbf6:	b088      	sub	sp, #32
 801fbf8:	af00      	add	r7, sp, #0
 801fbfa:	6078      	str	r0, [r7, #4]
 801fbfc:	6039      	str	r1, [r7, #0]
    JSON_Status status = JSONFailure;
 801fbfe:	f04f 33ff 	mov.w	r3, #4294967295
 801fc02:	61fb      	str	r3, [r7, #28]
    JSON_Value *output_value = NULL, *new_value = NULL;
 801fc04:	2300      	movs	r3, #0
 801fc06:	61bb      	str	r3, [r7, #24]
 801fc08:	2300      	movs	r3, #0
 801fc0a:	617b      	str	r3, [r7, #20]
    JSON_Object *output_object = NULL;
 801fc0c:	2300      	movs	r3, #0
 801fc0e:	613b      	str	r3, [r7, #16]
    char *new_key = NULL;
 801fc10:	2300      	movs	r3, #0
 801fc12:	60fb      	str	r3, [r7, #12]

    output_value = json_value_init_object();
 801fc14:	f001 fdc0 	bl	8021798 <json_value_init_object>
 801fc18:	61b8      	str	r0, [r7, #24]
    if (output_value == NULL) {
 801fc1a:	69bb      	ldr	r3, [r7, #24]
 801fc1c:	2b00      	cmp	r3, #0
 801fc1e:	d101      	bne.n	801fc24 <parse_object_value+0x30>
        return NULL;
 801fc20:	2300      	movs	r3, #0
 801fc22:	e0f5      	b.n	801fe10 <parse_object_value+0x21c>
    }
    if (**string != '{') {
 801fc24:	687b      	ldr	r3, [r7, #4]
 801fc26:	681b      	ldr	r3, [r3, #0]
 801fc28:	781b      	ldrb	r3, [r3, #0]
 801fc2a:	2b7b      	cmp	r3, #123	@ 0x7b
 801fc2c:	d004      	beq.n	801fc38 <parse_object_value+0x44>
        json_value_free(output_value);
 801fc2e:	69b8      	ldr	r0, [r7, #24]
 801fc30:	f001 fd84 	bl	802173c <json_value_free>
        return NULL;
 801fc34:	2300      	movs	r3, #0
 801fc36:	e0eb      	b.n	801fe10 <parse_object_value+0x21c>
    }
    output_object = json_value_get_object(output_value);
 801fc38:	69b8      	ldr	r0, [r7, #24]
 801fc3a:	f001 fce8 	bl	802160e <json_value_get_object>
 801fc3e:	6138      	str	r0, [r7, #16]
    SKIP_CHAR(string);
 801fc40:	687b      	ldr	r3, [r7, #4]
 801fc42:	681b      	ldr	r3, [r3, #0]
 801fc44:	1c5a      	adds	r2, r3, #1
 801fc46:	687b      	ldr	r3, [r7, #4]
 801fc48:	601a      	str	r2, [r3, #0]
    SKIP_WHITESPACES(string);
 801fc4a:	e004      	b.n	801fc56 <parse_object_value+0x62>
 801fc4c:	687b      	ldr	r3, [r7, #4]
 801fc4e:	681b      	ldr	r3, [r3, #0]
 801fc50:	1c5a      	adds	r2, r3, #1
 801fc52:	687b      	ldr	r3, [r7, #4]
 801fc54:	601a      	str	r2, [r3, #0]
 801fc56:	687b      	ldr	r3, [r7, #4]
 801fc58:	681b      	ldr	r3, [r3, #0]
 801fc5a:	781b      	ldrb	r3, [r3, #0]
 801fc5c:	3301      	adds	r3, #1
 801fc5e:	4a6e      	ldr	r2, [pc, #440]	@ (801fe18 <parse_object_value+0x224>)
 801fc60:	4413      	add	r3, r2
 801fc62:	781b      	ldrb	r3, [r3, #0]
 801fc64:	f003 0308 	and.w	r3, r3, #8
 801fc68:	2b00      	cmp	r3, #0
 801fc6a:	d1ef      	bne.n	801fc4c <parse_object_value+0x58>
    if (**string == '}') { /* empty object */
 801fc6c:	687b      	ldr	r3, [r7, #4]
 801fc6e:	681b      	ldr	r3, [r3, #0]
 801fc70:	781b      	ldrb	r3, [r3, #0]
 801fc72:	2b7d      	cmp	r3, #125	@ 0x7d
 801fc74:	f040 80a1 	bne.w	801fdba <parse_object_value+0x1c6>
        SKIP_CHAR(string);
 801fc78:	687b      	ldr	r3, [r7, #4]
 801fc7a:	681b      	ldr	r3, [r3, #0]
 801fc7c:	1c5a      	adds	r2, r3, #1
 801fc7e:	687b      	ldr	r3, [r7, #4]
 801fc80:	601a      	str	r2, [r3, #0]
        return output_value;
 801fc82:	69bb      	ldr	r3, [r7, #24]
 801fc84:	e0c4      	b.n	801fe10 <parse_object_value+0x21c>
    }
    while (**string != '\0') {
        size_t key_len = 0;
 801fc86:	2300      	movs	r3, #0
 801fc88:	60bb      	str	r3, [r7, #8]
        new_key = get_quoted_string(string, &key_len);
 801fc8a:	f107 0308 	add.w	r3, r7, #8
 801fc8e:	4619      	mov	r1, r3
 801fc90:	6878      	ldr	r0, [r7, #4]
 801fc92:	f7ff fee9 	bl	801fa68 <get_quoted_string>
 801fc96:	60f8      	str	r0, [r7, #12]
        /* We do not support key names with embedded \0 chars */
        if (!new_key) {
 801fc98:	68fb      	ldr	r3, [r7, #12]
 801fc9a:	2b00      	cmp	r3, #0
 801fc9c:	d104      	bne.n	801fca8 <parse_object_value+0xb4>
            json_value_free(output_value);
 801fc9e:	69b8      	ldr	r0, [r7, #24]
 801fca0:	f001 fd4c 	bl	802173c <json_value_free>
            return NULL;
 801fca4:	2300      	movs	r3, #0
 801fca6:	e0b3      	b.n	801fe10 <parse_object_value+0x21c>
        }
        if (key_len != strlen(new_key)) {
 801fca8:	68f8      	ldr	r0, [r7, #12]
 801fcaa:	f7e0 faef 	bl	800028c <strlen>
 801fcae:	4602      	mov	r2, r0
 801fcb0:	68bb      	ldr	r3, [r7, #8]
 801fcb2:	429a      	cmp	r2, r3
 801fcb4:	d00d      	beq.n	801fcd2 <parse_object_value+0xde>
            parson_free(new_key);
 801fcb6:	4b59      	ldr	r3, [pc, #356]	@ (801fe1c <parse_object_value+0x228>)
 801fcb8:	681b      	ldr	r3, [r3, #0]
 801fcba:	68f8      	ldr	r0, [r7, #12]
 801fcbc:	4798      	blx	r3
            json_value_free(output_value);
 801fcbe:	69b8      	ldr	r0, [r7, #24]
 801fcc0:	f001 fd3c 	bl	802173c <json_value_free>
            return NULL;
 801fcc4:	2300      	movs	r3, #0
 801fcc6:	e0a3      	b.n	801fe10 <parse_object_value+0x21c>
        }
        SKIP_WHITESPACES(string);
 801fcc8:	687b      	ldr	r3, [r7, #4]
 801fcca:	681b      	ldr	r3, [r3, #0]
 801fccc:	1c5a      	adds	r2, r3, #1
 801fcce:	687b      	ldr	r3, [r7, #4]
 801fcd0:	601a      	str	r2, [r3, #0]
 801fcd2:	687b      	ldr	r3, [r7, #4]
 801fcd4:	681b      	ldr	r3, [r3, #0]
 801fcd6:	781b      	ldrb	r3, [r3, #0]
 801fcd8:	3301      	adds	r3, #1
 801fcda:	4a4f      	ldr	r2, [pc, #316]	@ (801fe18 <parse_object_value+0x224>)
 801fcdc:	4413      	add	r3, r2
 801fcde:	781b      	ldrb	r3, [r3, #0]
 801fce0:	f003 0308 	and.w	r3, r3, #8
 801fce4:	2b00      	cmp	r3, #0
 801fce6:	d1ef      	bne.n	801fcc8 <parse_object_value+0xd4>
        if (**string != ':') {
 801fce8:	687b      	ldr	r3, [r7, #4]
 801fcea:	681b      	ldr	r3, [r3, #0]
 801fcec:	781b      	ldrb	r3, [r3, #0]
 801fcee:	2b3a      	cmp	r3, #58	@ 0x3a
 801fcf0:	d008      	beq.n	801fd04 <parse_object_value+0x110>
            parson_free(new_key);
 801fcf2:	4b4a      	ldr	r3, [pc, #296]	@ (801fe1c <parse_object_value+0x228>)
 801fcf4:	681b      	ldr	r3, [r3, #0]
 801fcf6:	68f8      	ldr	r0, [r7, #12]
 801fcf8:	4798      	blx	r3
            json_value_free(output_value);
 801fcfa:	69b8      	ldr	r0, [r7, #24]
 801fcfc:	f001 fd1e 	bl	802173c <json_value_free>
            return NULL;
 801fd00:	2300      	movs	r3, #0
 801fd02:	e085      	b.n	801fe10 <parse_object_value+0x21c>
        }
        SKIP_CHAR(string);
 801fd04:	687b      	ldr	r3, [r7, #4]
 801fd06:	681b      	ldr	r3, [r3, #0]
 801fd08:	1c5a      	adds	r2, r3, #1
 801fd0a:	687b      	ldr	r3, [r7, #4]
 801fd0c:	601a      	str	r2, [r3, #0]
        new_value = parse_value(string, nesting);
 801fd0e:	6839      	ldr	r1, [r7, #0]
 801fd10:	6878      	ldr	r0, [r7, #4]
 801fd12:	f7ff fecf 	bl	801fab4 <parse_value>
 801fd16:	6178      	str	r0, [r7, #20]
        if (new_value == NULL) {
 801fd18:	697b      	ldr	r3, [r7, #20]
 801fd1a:	2b00      	cmp	r3, #0
 801fd1c:	d108      	bne.n	801fd30 <parse_object_value+0x13c>
            parson_free(new_key);
 801fd1e:	4b3f      	ldr	r3, [pc, #252]	@ (801fe1c <parse_object_value+0x228>)
 801fd20:	681b      	ldr	r3, [r3, #0]
 801fd22:	68f8      	ldr	r0, [r7, #12]
 801fd24:	4798      	blx	r3
            json_value_free(output_value);
 801fd26:	69b8      	ldr	r0, [r7, #24]
 801fd28:	f001 fd08 	bl	802173c <json_value_free>
            return NULL;
 801fd2c:	2300      	movs	r3, #0
 801fd2e:	e06f      	b.n	801fe10 <parse_object_value+0x21c>
        }
        status = json_object_add(output_object, new_key, new_value);
 801fd30:	697a      	ldr	r2, [r7, #20]
 801fd32:	68f9      	ldr	r1, [r7, #12]
 801fd34:	6938      	ldr	r0, [r7, #16]
 801fd36:	f7ff f962 	bl	801effe <json_object_add>
 801fd3a:	61f8      	str	r0, [r7, #28]
        if (status != JSONSuccess) {
 801fd3c:	69fb      	ldr	r3, [r7, #28]
 801fd3e:	2b00      	cmp	r3, #0
 801fd40:	d010      	beq.n	801fd64 <parse_object_value+0x170>
            parson_free(new_key);
 801fd42:	4b36      	ldr	r3, [pc, #216]	@ (801fe1c <parse_object_value+0x228>)
 801fd44:	681b      	ldr	r3, [r3, #0]
 801fd46:	68f8      	ldr	r0, [r7, #12]
 801fd48:	4798      	blx	r3
            json_value_free(new_value);
 801fd4a:	6978      	ldr	r0, [r7, #20]
 801fd4c:	f001 fcf6 	bl	802173c <json_value_free>
            json_value_free(output_value);
 801fd50:	69b8      	ldr	r0, [r7, #24]
 801fd52:	f001 fcf3 	bl	802173c <json_value_free>
            return NULL;
 801fd56:	2300      	movs	r3, #0
 801fd58:	e05a      	b.n	801fe10 <parse_object_value+0x21c>
        }
        SKIP_WHITESPACES(string);
 801fd5a:	687b      	ldr	r3, [r7, #4]
 801fd5c:	681b      	ldr	r3, [r3, #0]
 801fd5e:	1c5a      	adds	r2, r3, #1
 801fd60:	687b      	ldr	r3, [r7, #4]
 801fd62:	601a      	str	r2, [r3, #0]
 801fd64:	687b      	ldr	r3, [r7, #4]
 801fd66:	681b      	ldr	r3, [r3, #0]
 801fd68:	781b      	ldrb	r3, [r3, #0]
 801fd6a:	3301      	adds	r3, #1
 801fd6c:	4a2a      	ldr	r2, [pc, #168]	@ (801fe18 <parse_object_value+0x224>)
 801fd6e:	4413      	add	r3, r2
 801fd70:	781b      	ldrb	r3, [r3, #0]
 801fd72:	f003 0308 	and.w	r3, r3, #8
 801fd76:	2b00      	cmp	r3, #0
 801fd78:	d1ef      	bne.n	801fd5a <parse_object_value+0x166>
        if (**string != ',') {
 801fd7a:	687b      	ldr	r3, [r7, #4]
 801fd7c:	681b      	ldr	r3, [r3, #0]
 801fd7e:	781b      	ldrb	r3, [r3, #0]
 801fd80:	2b2c      	cmp	r3, #44	@ 0x2c
 801fd82:	d121      	bne.n	801fdc8 <parse_object_value+0x1d4>
            break;
        }
        SKIP_CHAR(string);
 801fd84:	687b      	ldr	r3, [r7, #4]
 801fd86:	681b      	ldr	r3, [r3, #0]
 801fd88:	1c5a      	adds	r2, r3, #1
 801fd8a:	687b      	ldr	r3, [r7, #4]
 801fd8c:	601a      	str	r2, [r3, #0]
        SKIP_WHITESPACES(string);
 801fd8e:	e004      	b.n	801fd9a <parse_object_value+0x1a6>
 801fd90:	687b      	ldr	r3, [r7, #4]
 801fd92:	681b      	ldr	r3, [r3, #0]
 801fd94:	1c5a      	adds	r2, r3, #1
 801fd96:	687b      	ldr	r3, [r7, #4]
 801fd98:	601a      	str	r2, [r3, #0]
 801fd9a:	687b      	ldr	r3, [r7, #4]
 801fd9c:	681b      	ldr	r3, [r3, #0]
 801fd9e:	781b      	ldrb	r3, [r3, #0]
 801fda0:	3301      	adds	r3, #1
 801fda2:	4a1d      	ldr	r2, [pc, #116]	@ (801fe18 <parse_object_value+0x224>)
 801fda4:	4413      	add	r3, r2
 801fda6:	781b      	ldrb	r3, [r3, #0]
 801fda8:	f003 0308 	and.w	r3, r3, #8
 801fdac:	2b00      	cmp	r3, #0
 801fdae:	d1ef      	bne.n	801fd90 <parse_object_value+0x19c>
        if (**string == '}') {
 801fdb0:	687b      	ldr	r3, [r7, #4]
 801fdb2:	681b      	ldr	r3, [r3, #0]
 801fdb4:	781b      	ldrb	r3, [r3, #0]
 801fdb6:	2b7d      	cmp	r3, #125	@ 0x7d
 801fdb8:	d008      	beq.n	801fdcc <parse_object_value+0x1d8>
    while (**string != '\0') {
 801fdba:	687b      	ldr	r3, [r7, #4]
 801fdbc:	681b      	ldr	r3, [r3, #0]
 801fdbe:	781b      	ldrb	r3, [r3, #0]
 801fdc0:	2b00      	cmp	r3, #0
 801fdc2:	f47f af60 	bne.w	801fc86 <parse_object_value+0x92>
 801fdc6:	e008      	b.n	801fdda <parse_object_value+0x1e6>
            break;
 801fdc8:	bf00      	nop
 801fdca:	e006      	b.n	801fdda <parse_object_value+0x1e6>
            break;
 801fdcc:	bf00      	nop
        }
    }
    SKIP_WHITESPACES(string);
 801fdce:	e004      	b.n	801fdda <parse_object_value+0x1e6>
 801fdd0:	687b      	ldr	r3, [r7, #4]
 801fdd2:	681b      	ldr	r3, [r3, #0]
 801fdd4:	1c5a      	adds	r2, r3, #1
 801fdd6:	687b      	ldr	r3, [r7, #4]
 801fdd8:	601a      	str	r2, [r3, #0]
 801fdda:	687b      	ldr	r3, [r7, #4]
 801fddc:	681b      	ldr	r3, [r3, #0]
 801fdde:	781b      	ldrb	r3, [r3, #0]
 801fde0:	3301      	adds	r3, #1
 801fde2:	4a0d      	ldr	r2, [pc, #52]	@ (801fe18 <parse_object_value+0x224>)
 801fde4:	4413      	add	r3, r2
 801fde6:	781b      	ldrb	r3, [r3, #0]
 801fde8:	f003 0308 	and.w	r3, r3, #8
 801fdec:	2b00      	cmp	r3, #0
 801fdee:	d1ef      	bne.n	801fdd0 <parse_object_value+0x1dc>
    if (**string != '}') {
 801fdf0:	687b      	ldr	r3, [r7, #4]
 801fdf2:	681b      	ldr	r3, [r3, #0]
 801fdf4:	781b      	ldrb	r3, [r3, #0]
 801fdf6:	2b7d      	cmp	r3, #125	@ 0x7d
 801fdf8:	d004      	beq.n	801fe04 <parse_object_value+0x210>
        json_value_free(output_value);
 801fdfa:	69b8      	ldr	r0, [r7, #24]
 801fdfc:	f001 fc9e 	bl	802173c <json_value_free>
        return NULL;
 801fe00:	2300      	movs	r3, #0
 801fe02:	e005      	b.n	801fe10 <parse_object_value+0x21c>
    }
    SKIP_CHAR(string);
 801fe04:	687b      	ldr	r3, [r7, #4]
 801fe06:	681b      	ldr	r3, [r3, #0]
 801fe08:	1c5a      	adds	r2, r3, #1
 801fe0a:	687b      	ldr	r3, [r7, #4]
 801fe0c:	601a      	str	r2, [r3, #0]
    return output_value;
 801fe0e:	69bb      	ldr	r3, [r7, #24]
}
 801fe10:	4618      	mov	r0, r3
 801fe12:	3720      	adds	r7, #32
 801fe14:	46bd      	mov	sp, r7
 801fe16:	bd80      	pop	{r7, pc}
 801fe18:	0802aac0 	.word	0x0802aac0
 801fe1c:	20000214 	.word	0x20000214

0801fe20 <parse_array_value>:

static JSON_Value * parse_array_value(const char **string, size_t nesting) {
 801fe20:	b580      	push	{r7, lr}
 801fe22:	b086      	sub	sp, #24
 801fe24:	af00      	add	r7, sp, #0
 801fe26:	6078      	str	r0, [r7, #4]
 801fe28:	6039      	str	r1, [r7, #0]
    JSON_Value *output_value = NULL, *new_array_value = NULL;
 801fe2a:	2300      	movs	r3, #0
 801fe2c:	617b      	str	r3, [r7, #20]
 801fe2e:	2300      	movs	r3, #0
 801fe30:	613b      	str	r3, [r7, #16]
    JSON_Array *output_array = NULL;
 801fe32:	2300      	movs	r3, #0
 801fe34:	60fb      	str	r3, [r7, #12]
    output_value = json_value_init_array();
 801fe36:	f001 fcdb 	bl	80217f0 <json_value_init_array>
 801fe3a:	6178      	str	r0, [r7, #20]
    if (output_value == NULL) {
 801fe3c:	697b      	ldr	r3, [r7, #20]
 801fe3e:	2b00      	cmp	r3, #0
 801fe40:	d101      	bne.n	801fe46 <parse_array_value+0x26>
        return NULL;
 801fe42:	2300      	movs	r3, #0
 801fe44:	e0b0      	b.n	801ffa8 <parse_array_value+0x188>
    }
    if (**string != '[') {
 801fe46:	687b      	ldr	r3, [r7, #4]
 801fe48:	681b      	ldr	r3, [r3, #0]
 801fe4a:	781b      	ldrb	r3, [r3, #0]
 801fe4c:	2b5b      	cmp	r3, #91	@ 0x5b
 801fe4e:	d004      	beq.n	801fe5a <parse_array_value+0x3a>
        json_value_free(output_value);
 801fe50:	6978      	ldr	r0, [r7, #20]
 801fe52:	f001 fc73 	bl	802173c <json_value_free>
        return NULL;
 801fe56:	2300      	movs	r3, #0
 801fe58:	e0a6      	b.n	801ffa8 <parse_array_value+0x188>
    }
    output_array = json_value_get_array(output_value);
 801fe5a:	6978      	ldr	r0, [r7, #20]
 801fe5c:	f001 fbe9 	bl	8021632 <json_value_get_array>
 801fe60:	60f8      	str	r0, [r7, #12]
    SKIP_CHAR(string);
 801fe62:	687b      	ldr	r3, [r7, #4]
 801fe64:	681b      	ldr	r3, [r3, #0]
 801fe66:	1c5a      	adds	r2, r3, #1
 801fe68:	687b      	ldr	r3, [r7, #4]
 801fe6a:	601a      	str	r2, [r3, #0]
    SKIP_WHITESPACES(string);
 801fe6c:	e004      	b.n	801fe78 <parse_array_value+0x58>
 801fe6e:	687b      	ldr	r3, [r7, #4]
 801fe70:	681b      	ldr	r3, [r3, #0]
 801fe72:	1c5a      	adds	r2, r3, #1
 801fe74:	687b      	ldr	r3, [r7, #4]
 801fe76:	601a      	str	r2, [r3, #0]
 801fe78:	687b      	ldr	r3, [r7, #4]
 801fe7a:	681b      	ldr	r3, [r3, #0]
 801fe7c:	781b      	ldrb	r3, [r3, #0]
 801fe7e:	3301      	adds	r3, #1
 801fe80:	4a4b      	ldr	r2, [pc, #300]	@ (801ffb0 <parse_array_value+0x190>)
 801fe82:	4413      	add	r3, r2
 801fe84:	781b      	ldrb	r3, [r3, #0]
 801fe86:	f003 0308 	and.w	r3, r3, #8
 801fe8a:	2b00      	cmp	r3, #0
 801fe8c:	d1ef      	bne.n	801fe6e <parse_array_value+0x4e>
    if (**string == ']') { /* empty array */
 801fe8e:	687b      	ldr	r3, [r7, #4]
 801fe90:	681b      	ldr	r3, [r3, #0]
 801fe92:	781b      	ldrb	r3, [r3, #0]
 801fe94:	2b5d      	cmp	r3, #93	@ 0x5d
 801fe96:	d152      	bne.n	801ff3e <parse_array_value+0x11e>
        SKIP_CHAR(string);
 801fe98:	687b      	ldr	r3, [r7, #4]
 801fe9a:	681b      	ldr	r3, [r3, #0]
 801fe9c:	1c5a      	adds	r2, r3, #1
 801fe9e:	687b      	ldr	r3, [r7, #4]
 801fea0:	601a      	str	r2, [r3, #0]
        return output_value;
 801fea2:	697b      	ldr	r3, [r7, #20]
 801fea4:	e080      	b.n	801ffa8 <parse_array_value+0x188>
    }
    while (**string != '\0') {
        new_array_value = parse_value(string, nesting);
 801fea6:	6839      	ldr	r1, [r7, #0]
 801fea8:	6878      	ldr	r0, [r7, #4]
 801feaa:	f7ff fe03 	bl	801fab4 <parse_value>
 801feae:	6138      	str	r0, [r7, #16]
        if (new_array_value == NULL) {
 801feb0:	693b      	ldr	r3, [r7, #16]
 801feb2:	2b00      	cmp	r3, #0
 801feb4:	d104      	bne.n	801fec0 <parse_array_value+0xa0>
            json_value_free(output_value);
 801feb6:	6978      	ldr	r0, [r7, #20]
 801feb8:	f001 fc40 	bl	802173c <json_value_free>
            return NULL;
 801febc:	2300      	movs	r3, #0
 801febe:	e073      	b.n	801ffa8 <parse_array_value+0x188>
        }
        if (json_array_add(output_array, new_array_value) != JSONSuccess) {
 801fec0:	6939      	ldr	r1, [r7, #16]
 801fec2:	68f8      	ldr	r0, [r7, #12]
 801fec4:	f7ff faf2 	bl	801f4ac <json_array_add>
 801fec8:	4603      	mov	r3, r0
 801feca:	2b00      	cmp	r3, #0
 801fecc:	d00c      	beq.n	801fee8 <parse_array_value+0xc8>
            json_value_free(new_array_value);
 801fece:	6938      	ldr	r0, [r7, #16]
 801fed0:	f001 fc34 	bl	802173c <json_value_free>
            json_value_free(output_value);
 801fed4:	6978      	ldr	r0, [r7, #20]
 801fed6:	f001 fc31 	bl	802173c <json_value_free>
            return NULL;
 801feda:	2300      	movs	r3, #0
 801fedc:	e064      	b.n	801ffa8 <parse_array_value+0x188>
        }
        SKIP_WHITESPACES(string);
 801fede:	687b      	ldr	r3, [r7, #4]
 801fee0:	681b      	ldr	r3, [r3, #0]
 801fee2:	1c5a      	adds	r2, r3, #1
 801fee4:	687b      	ldr	r3, [r7, #4]
 801fee6:	601a      	str	r2, [r3, #0]
 801fee8:	687b      	ldr	r3, [r7, #4]
 801feea:	681b      	ldr	r3, [r3, #0]
 801feec:	781b      	ldrb	r3, [r3, #0]
 801feee:	3301      	adds	r3, #1
 801fef0:	4a2f      	ldr	r2, [pc, #188]	@ (801ffb0 <parse_array_value+0x190>)
 801fef2:	4413      	add	r3, r2
 801fef4:	781b      	ldrb	r3, [r3, #0]
 801fef6:	f003 0308 	and.w	r3, r3, #8
 801fefa:	2b00      	cmp	r3, #0
 801fefc:	d1ef      	bne.n	801fede <parse_array_value+0xbe>
        if (**string != ',') {
 801fefe:	687b      	ldr	r3, [r7, #4]
 801ff00:	681b      	ldr	r3, [r3, #0]
 801ff02:	781b      	ldrb	r3, [r3, #0]
 801ff04:	2b2c      	cmp	r3, #44	@ 0x2c
 801ff06:	d120      	bne.n	801ff4a <parse_array_value+0x12a>
            break;
        }
        SKIP_CHAR(string);
 801ff08:	687b      	ldr	r3, [r7, #4]
 801ff0a:	681b      	ldr	r3, [r3, #0]
 801ff0c:	1c5a      	adds	r2, r3, #1
 801ff0e:	687b      	ldr	r3, [r7, #4]
 801ff10:	601a      	str	r2, [r3, #0]
        SKIP_WHITESPACES(string);
 801ff12:	e004      	b.n	801ff1e <parse_array_value+0xfe>
 801ff14:	687b      	ldr	r3, [r7, #4]
 801ff16:	681b      	ldr	r3, [r3, #0]
 801ff18:	1c5a      	adds	r2, r3, #1
 801ff1a:	687b      	ldr	r3, [r7, #4]
 801ff1c:	601a      	str	r2, [r3, #0]
 801ff1e:	687b      	ldr	r3, [r7, #4]
 801ff20:	681b      	ldr	r3, [r3, #0]
 801ff22:	781b      	ldrb	r3, [r3, #0]
 801ff24:	3301      	adds	r3, #1
 801ff26:	4a22      	ldr	r2, [pc, #136]	@ (801ffb0 <parse_array_value+0x190>)
 801ff28:	4413      	add	r3, r2
 801ff2a:	781b      	ldrb	r3, [r3, #0]
 801ff2c:	f003 0308 	and.w	r3, r3, #8
 801ff30:	2b00      	cmp	r3, #0
 801ff32:	d1ef      	bne.n	801ff14 <parse_array_value+0xf4>
        if (**string == ']') {
 801ff34:	687b      	ldr	r3, [r7, #4]
 801ff36:	681b      	ldr	r3, [r3, #0]
 801ff38:	781b      	ldrb	r3, [r3, #0]
 801ff3a:	2b5d      	cmp	r3, #93	@ 0x5d
 801ff3c:	d007      	beq.n	801ff4e <parse_array_value+0x12e>
    while (**string != '\0') {
 801ff3e:	687b      	ldr	r3, [r7, #4]
 801ff40:	681b      	ldr	r3, [r3, #0]
 801ff42:	781b      	ldrb	r3, [r3, #0]
 801ff44:	2b00      	cmp	r3, #0
 801ff46:	d1ae      	bne.n	801fea6 <parse_array_value+0x86>
 801ff48:	e008      	b.n	801ff5c <parse_array_value+0x13c>
            break;
 801ff4a:	bf00      	nop
 801ff4c:	e006      	b.n	801ff5c <parse_array_value+0x13c>
            break;
 801ff4e:	bf00      	nop
        }
    }
    SKIP_WHITESPACES(string);
 801ff50:	e004      	b.n	801ff5c <parse_array_value+0x13c>
 801ff52:	687b      	ldr	r3, [r7, #4]
 801ff54:	681b      	ldr	r3, [r3, #0]
 801ff56:	1c5a      	adds	r2, r3, #1
 801ff58:	687b      	ldr	r3, [r7, #4]
 801ff5a:	601a      	str	r2, [r3, #0]
 801ff5c:	687b      	ldr	r3, [r7, #4]
 801ff5e:	681b      	ldr	r3, [r3, #0]
 801ff60:	781b      	ldrb	r3, [r3, #0]
 801ff62:	3301      	adds	r3, #1
 801ff64:	4a12      	ldr	r2, [pc, #72]	@ (801ffb0 <parse_array_value+0x190>)
 801ff66:	4413      	add	r3, r2
 801ff68:	781b      	ldrb	r3, [r3, #0]
 801ff6a:	f003 0308 	and.w	r3, r3, #8
 801ff6e:	2b00      	cmp	r3, #0
 801ff70:	d1ef      	bne.n	801ff52 <parse_array_value+0x132>
    if (**string != ']' || /* Trim array after parsing is over */
 801ff72:	687b      	ldr	r3, [r7, #4]
 801ff74:	681b      	ldr	r3, [r3, #0]
 801ff76:	781b      	ldrb	r3, [r3, #0]
 801ff78:	2b5d      	cmp	r3, #93	@ 0x5d
 801ff7a:	d10a      	bne.n	801ff92 <parse_array_value+0x172>
        json_array_resize(output_array, json_array_get_count(output_array)) != JSONSuccess) {
 801ff7c:	68f8      	ldr	r0, [r7, #12]
 801ff7e:	f001 fb12 	bl	80215a6 <json_array_get_count>
 801ff82:	4603      	mov	r3, r0
 801ff84:	4619      	mov	r1, r3
 801ff86:	68f8      	ldr	r0, [r7, #12]
 801ff88:	f7ff fac4 	bl	801f514 <json_array_resize>
 801ff8c:	4603      	mov	r3, r0
    if (**string != ']' || /* Trim array after parsing is over */
 801ff8e:	2b00      	cmp	r3, #0
 801ff90:	d004      	beq.n	801ff9c <parse_array_value+0x17c>
            json_value_free(output_value);
 801ff92:	6978      	ldr	r0, [r7, #20]
 801ff94:	f001 fbd2 	bl	802173c <json_value_free>
            return NULL;
 801ff98:	2300      	movs	r3, #0
 801ff9a:	e005      	b.n	801ffa8 <parse_array_value+0x188>
    }
    SKIP_CHAR(string);
 801ff9c:	687b      	ldr	r3, [r7, #4]
 801ff9e:	681b      	ldr	r3, [r3, #0]
 801ffa0:	1c5a      	adds	r2, r3, #1
 801ffa2:	687b      	ldr	r3, [r7, #4]
 801ffa4:	601a      	str	r2, [r3, #0]
    return output_value;
 801ffa6:	697b      	ldr	r3, [r7, #20]
}
 801ffa8:	4618      	mov	r0, r3
 801ffaa:	3718      	adds	r7, #24
 801ffac:	46bd      	mov	sp, r7
 801ffae:	bd80      	pop	{r7, pc}
 801ffb0:	0802aac0 	.word	0x0802aac0

0801ffb4 <parse_string_value>:

static JSON_Value * parse_string_value(const char **string) {
 801ffb4:	b580      	push	{r7, lr}
 801ffb6:	b086      	sub	sp, #24
 801ffb8:	af00      	add	r7, sp, #0
 801ffba:	6078      	str	r0, [r7, #4]
    JSON_Value *value = NULL;
 801ffbc:	2300      	movs	r3, #0
 801ffbe:	617b      	str	r3, [r7, #20]
    size_t new_string_len = 0;
 801ffc0:	2300      	movs	r3, #0
 801ffc2:	60fb      	str	r3, [r7, #12]
    char *new_string = get_quoted_string(string, &new_string_len);
 801ffc4:	f107 030c 	add.w	r3, r7, #12
 801ffc8:	4619      	mov	r1, r3
 801ffca:	6878      	ldr	r0, [r7, #4]
 801ffcc:	f7ff fd4c 	bl	801fa68 <get_quoted_string>
 801ffd0:	6138      	str	r0, [r7, #16]
    if (new_string == NULL) {
 801ffd2:	693b      	ldr	r3, [r7, #16]
 801ffd4:	2b00      	cmp	r3, #0
 801ffd6:	d101      	bne.n	801ffdc <parse_string_value+0x28>
        return NULL;
 801ffd8:	2300      	movs	r3, #0
 801ffda:	e00f      	b.n	801fffc <parse_string_value+0x48>
    }
    value = json_value_init_string_no_copy(new_string, new_string_len);
 801ffdc:	68fb      	ldr	r3, [r7, #12]
 801ffde:	4619      	mov	r1, r3
 801ffe0:	6938      	ldr	r0, [r7, #16]
 801ffe2:	f7ff faff 	bl	801f5e4 <json_value_init_string_no_copy>
 801ffe6:	6178      	str	r0, [r7, #20]
    if (value == NULL) {
 801ffe8:	697b      	ldr	r3, [r7, #20]
 801ffea:	2b00      	cmp	r3, #0
 801ffec:	d105      	bne.n	801fffa <parse_string_value+0x46>
        parson_free(new_string);
 801ffee:	4b05      	ldr	r3, [pc, #20]	@ (8020004 <parse_string_value+0x50>)
 801fff0:	681b      	ldr	r3, [r3, #0]
 801fff2:	6938      	ldr	r0, [r7, #16]
 801fff4:	4798      	blx	r3
        return NULL;
 801fff6:	2300      	movs	r3, #0
 801fff8:	e000      	b.n	801fffc <parse_string_value+0x48>
    }
    return value;
 801fffa:	697b      	ldr	r3, [r7, #20]
}
 801fffc:	4618      	mov	r0, r3
 801fffe:	3718      	adds	r7, #24
 8020000:	46bd      	mov	sp, r7
 8020002:	bd80      	pop	{r7, pc}
 8020004:	20000214 	.word	0x20000214

08020008 <parse_boolean_value>:

static JSON_Value * parse_boolean_value(const char **string) {
 8020008:	b580      	push	{r7, lr}
 802000a:	b084      	sub	sp, #16
 802000c:	af00      	add	r7, sp, #0
 802000e:	6078      	str	r0, [r7, #4]
    size_t true_token_size = SIZEOF_TOKEN("true");
 8020010:	2304      	movs	r3, #4
 8020012:	60fb      	str	r3, [r7, #12]
    size_t false_token_size = SIZEOF_TOKEN("false");
 8020014:	2305      	movs	r3, #5
 8020016:	60bb      	str	r3, [r7, #8]
    if (strncmp("true", *string, true_token_size) == 0) {
 8020018:	687b      	ldr	r3, [r7, #4]
 802001a:	681b      	ldr	r3, [r3, #0]
 802001c:	68fa      	ldr	r2, [r7, #12]
 802001e:	4619      	mov	r1, r3
 8020020:	4815      	ldr	r0, [pc, #84]	@ (8020078 <parse_boolean_value+0x70>)
 8020022:	f004 f834 	bl	802408e <strncmp>
 8020026:	4603      	mov	r3, r0
 8020028:	2b00      	cmp	r3, #0
 802002a:	d10a      	bne.n	8020042 <parse_boolean_value+0x3a>
        *string += true_token_size;
 802002c:	687b      	ldr	r3, [r7, #4]
 802002e:	681a      	ldr	r2, [r3, #0]
 8020030:	68fb      	ldr	r3, [r7, #12]
 8020032:	441a      	add	r2, r3
 8020034:	687b      	ldr	r3, [r7, #4]
 8020036:	601a      	str	r2, [r3, #0]
        return json_value_init_boolean(1);
 8020038:	2001      	movs	r0, #1
 802003a:	f001 fc9f 	bl	802197c <json_value_init_boolean>
 802003e:	4603      	mov	r3, r0
 8020040:	e015      	b.n	802006e <parse_boolean_value+0x66>
    } else if (strncmp("false", *string, false_token_size) == 0) {
 8020042:	687b      	ldr	r3, [r7, #4]
 8020044:	681b      	ldr	r3, [r3, #0]
 8020046:	68ba      	ldr	r2, [r7, #8]
 8020048:	4619      	mov	r1, r3
 802004a:	480c      	ldr	r0, [pc, #48]	@ (802007c <parse_boolean_value+0x74>)
 802004c:	f004 f81f 	bl	802408e <strncmp>
 8020050:	4603      	mov	r3, r0
 8020052:	2b00      	cmp	r3, #0
 8020054:	d10a      	bne.n	802006c <parse_boolean_value+0x64>
        *string += false_token_size;
 8020056:	687b      	ldr	r3, [r7, #4]
 8020058:	681a      	ldr	r2, [r3, #0]
 802005a:	68bb      	ldr	r3, [r7, #8]
 802005c:	441a      	add	r2, r3
 802005e:	687b      	ldr	r3, [r7, #4]
 8020060:	601a      	str	r2, [r3, #0]
        return json_value_init_boolean(0);
 8020062:	2000      	movs	r0, #0
 8020064:	f001 fc8a 	bl	802197c <json_value_init_boolean>
 8020068:	4603      	mov	r3, r0
 802006a:	e000      	b.n	802006e <parse_boolean_value+0x66>
    }
    return NULL;
 802006c:	2300      	movs	r3, #0
}
 802006e:	4618      	mov	r0, r3
 8020070:	3710      	adds	r7, #16
 8020072:	46bd      	mov	sp, r7
 8020074:	bd80      	pop	{r7, pc}
 8020076:	bf00      	nop
 8020078:	0802a2d0 	.word	0x0802a2d0
 802007c:	0802a2d8 	.word	0x0802a2d8

08020080 <parse_number_value>:

static JSON_Value * parse_number_value(const char **string) {
 8020080:	b580      	push	{r7, lr}
 8020082:	b086      	sub	sp, #24
 8020084:	af00      	add	r7, sp, #0
 8020086:	6078      	str	r0, [r7, #4]
    char *end;
    double number = 0;
 8020088:	f04f 0200 	mov.w	r2, #0
 802008c:	f04f 0300 	mov.w	r3, #0
 8020090:	e9c7 2304 	strd	r2, r3, [r7, #16]
    errno = 0;
 8020094:	f004 f868 	bl	8024168 <__errno>
 8020098:	4603      	mov	r3, r0
 802009a:	2200      	movs	r2, #0
 802009c:	601a      	str	r2, [r3, #0]
    number = strtod(*string, &end);
 802009e:	687b      	ldr	r3, [r7, #4]
 80200a0:	681b      	ldr	r3, [r3, #0]
 80200a2:	f107 020c 	add.w	r2, r7, #12
 80200a6:	4611      	mov	r1, r2
 80200a8:	4618      	mov	r0, r3
 80200aa:	f002 fe7b 	bl	8022da4 <strtod>
 80200ae:	e9c7 0104 	strd	r0, r1, [r7, #16]
    if (errno == ERANGE && (number <= -HUGE_VAL || number >= HUGE_VAL)) {
 80200b2:	f004 f859 	bl	8024168 <__errno>
 80200b6:	4603      	mov	r3, r0
 80200b8:	681b      	ldr	r3, [r3, #0]
 80200ba:	2b22      	cmp	r3, #34	@ 0x22
 80200bc:	d116      	bne.n	80200ec <parse_number_value+0x6c>
 80200be:	f04f 32ff 	mov.w	r2, #4294967295
 80200c2:	f46f 1380 	mvn.w	r3, #1048576	@ 0x100000
 80200c6:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 80200ca:	f7e0 fd15 	bl	8000af8 <__aeabi_dcmplt>
 80200ce:	4603      	mov	r3, r0
 80200d0:	2b00      	cmp	r3, #0
 80200d2:	d109      	bne.n	80200e8 <parse_number_value+0x68>
 80200d4:	f04f 32ff 	mov.w	r2, #4294967295
 80200d8:	4b17      	ldr	r3, [pc, #92]	@ (8020138 <parse_number_value+0xb8>)
 80200da:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 80200de:	f7e0 fd29 	bl	8000b34 <__aeabi_dcmpgt>
 80200e2:	4603      	mov	r3, r0
 80200e4:	2b00      	cmp	r3, #0
 80200e6:	d001      	beq.n	80200ec <parse_number_value+0x6c>
        return NULL;
 80200e8:	2300      	movs	r3, #0
 80200ea:	e021      	b.n	8020130 <parse_number_value+0xb0>
    }
    if ((errno && errno != ERANGE) || !is_decimal(*string, end - *string)) {
 80200ec:	f004 f83c 	bl	8024168 <__errno>
 80200f0:	4603      	mov	r3, r0
 80200f2:	681b      	ldr	r3, [r3, #0]
 80200f4:	2b00      	cmp	r3, #0
 80200f6:	d005      	beq.n	8020104 <parse_number_value+0x84>
 80200f8:	f004 f836 	bl	8024168 <__errno>
 80200fc:	4603      	mov	r3, r0
 80200fe:	681b      	ldr	r3, [r3, #0]
 8020100:	2b22      	cmp	r3, #34	@ 0x22
 8020102:	d10b      	bne.n	802011c <parse_number_value+0x9c>
 8020104:	687b      	ldr	r3, [r7, #4]
 8020106:	6818      	ldr	r0, [r3, #0]
 8020108:	68fa      	ldr	r2, [r7, #12]
 802010a:	687b      	ldr	r3, [r7, #4]
 802010c:	681b      	ldr	r3, [r3, #0]
 802010e:	1ad3      	subs	r3, r2, r3
 8020110:	4619      	mov	r1, r3
 8020112:	f7fe fced 	bl	801eaf0 <is_decimal>
 8020116:	4603      	mov	r3, r0
 8020118:	2b00      	cmp	r3, #0
 802011a:	d101      	bne.n	8020120 <parse_number_value+0xa0>
        return NULL;
 802011c:	2300      	movs	r3, #0
 802011e:	e007      	b.n	8020130 <parse_number_value+0xb0>
    }
    *string = end;
 8020120:	68fa      	ldr	r2, [r7, #12]
 8020122:	687b      	ldr	r3, [r7, #4]
 8020124:	601a      	str	r2, [r3, #0]
    return json_value_init_number(number);
 8020126:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 802012a:	f001 fbd5 	bl	80218d8 <json_value_init_number>
 802012e:	4603      	mov	r3, r0
}
 8020130:	4618      	mov	r0, r3
 8020132:	3718      	adds	r7, #24
 8020134:	46bd      	mov	sp, r7
 8020136:	bd80      	pop	{r7, pc}
 8020138:	7fefffff 	.word	0x7fefffff

0802013c <parse_null_value>:

static JSON_Value * parse_null_value(const char **string) {
 802013c:	b580      	push	{r7, lr}
 802013e:	b084      	sub	sp, #16
 8020140:	af00      	add	r7, sp, #0
 8020142:	6078      	str	r0, [r7, #4]
    size_t token_size = SIZEOF_TOKEN("null");
 8020144:	2304      	movs	r3, #4
 8020146:	60fb      	str	r3, [r7, #12]
    if (strncmp("null", *string, token_size) == 0) {
 8020148:	687b      	ldr	r3, [r7, #4]
 802014a:	681b      	ldr	r3, [r3, #0]
 802014c:	68fa      	ldr	r2, [r7, #12]
 802014e:	4619      	mov	r1, r3
 8020150:	480a      	ldr	r0, [pc, #40]	@ (802017c <parse_null_value+0x40>)
 8020152:	f003 ff9c 	bl	802408e <strncmp>
 8020156:	4603      	mov	r3, r0
 8020158:	2b00      	cmp	r3, #0
 802015a:	d109      	bne.n	8020170 <parse_null_value+0x34>
        *string += token_size;
 802015c:	687b      	ldr	r3, [r7, #4]
 802015e:	681a      	ldr	r2, [r3, #0]
 8020160:	68fb      	ldr	r3, [r7, #12]
 8020162:	441a      	add	r2, r3
 8020164:	687b      	ldr	r3, [r7, #4]
 8020166:	601a      	str	r2, [r3, #0]
        return json_value_init_null();
 8020168:	f001 fc2c 	bl	80219c4 <json_value_init_null>
 802016c:	4603      	mov	r3, r0
 802016e:	e000      	b.n	8020172 <parse_null_value+0x36>
    }
    return NULL;
 8020170:	2300      	movs	r3, #0
}
 8020172:	4618      	mov	r0, r3
 8020174:	3710      	adds	r7, #16
 8020176:	46bd      	mov	sp, r7
 8020178:	bd80      	pop	{r7, pc}
 802017a:	bf00      	nop
 802017c:	0802a2e0 	.word	0x0802a2e0

08020180 <json_serialize_to_buffer_r>:
                                    APPEND_STRING(PARSON_INDENT_STR);\
                                }\
                            } while (0)

static int json_serialize_to_buffer_r(const JSON_Value *value, char *buf, int level, parson_bool_t is_pretty, char *num_buf)
{
 8020180:	b580      	push	{r7, lr}
 8020182:	b098      	sub	sp, #96	@ 0x60
 8020184:	af02      	add	r7, sp, #8
 8020186:	60f8      	str	r0, [r7, #12]
 8020188:	60b9      	str	r1, [r7, #8]
 802018a:	607a      	str	r2, [r7, #4]
 802018c:	603b      	str	r3, [r7, #0]
    const char *key = NULL, *string = NULL;
 802018e:	2300      	movs	r3, #0
 8020190:	63bb      	str	r3, [r7, #56]	@ 0x38
 8020192:	2300      	movs	r3, #0
 8020194:	637b      	str	r3, [r7, #52]	@ 0x34
    JSON_Value *temp_value = NULL;
 8020196:	2300      	movs	r3, #0
 8020198:	633b      	str	r3, [r7, #48]	@ 0x30
    JSON_Array *array = NULL;
 802019a:	2300      	movs	r3, #0
 802019c:	62fb      	str	r3, [r7, #44]	@ 0x2c
    JSON_Object *object = NULL;
 802019e:	2300      	movs	r3, #0
 80201a0:	62bb      	str	r3, [r7, #40]	@ 0x28
    size_t i = 0, count = 0;
 80201a2:	2300      	movs	r3, #0
 80201a4:	657b      	str	r3, [r7, #84]	@ 0x54
 80201a6:	2300      	movs	r3, #0
 80201a8:	627b      	str	r3, [r7, #36]	@ 0x24
    double num = 0.0;
 80201aa:	f04f 0200 	mov.w	r2, #0
 80201ae:	f04f 0300 	mov.w	r3, #0
 80201b2:	e9c7 2306 	strd	r2, r3, [r7, #24]
    int written = -1, written_total = 0;
 80201b6:	f04f 33ff 	mov.w	r3, #4294967295
 80201ba:	653b      	str	r3, [r7, #80]	@ 0x50
 80201bc:	2300      	movs	r3, #0
 80201be:	64fb      	str	r3, [r7, #76]	@ 0x4c
    size_t len = 0;
 80201c0:	2300      	movs	r3, #0
 80201c2:	617b      	str	r3, [r7, #20]

    switch (json_value_get_type(value)) {
 80201c4:	68f8      	ldr	r0, [r7, #12]
 80201c6:	f001 fa10 	bl	80215ea <json_value_get_type>
 80201ca:	4603      	mov	r3, r0
 80201cc:	3301      	adds	r3, #1
 80201ce:	2b07      	cmp	r3, #7
 80201d0:	f200 8355 	bhi.w	802087e <json_serialize_to_buffer_r+0x6fe>
 80201d4:	a201      	add	r2, pc, #4	@ (adr r2, 80201dc <json_serialize_to_buffer_r+0x5c>)
 80201d6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80201da:	bf00      	nop
 80201dc:	08020879 	.word	0x08020879
 80201e0:	0802087f 	.word	0x0802087f
 80201e4:	08020845 	.word	0x08020845
 80201e8:	0802070b 	.word	0x0802070b
 80201ec:	080207cb 	.word	0x080207cb
 80201f0:	08020429 	.word	0x08020429
 80201f4:	080201fd 	.word	0x080201fd
 80201f8:	08020759 	.word	0x08020759
        case JSONArray:
            array = json_value_get_array(value);
 80201fc:	68f8      	ldr	r0, [r7, #12]
 80201fe:	f001 fa18 	bl	8021632 <json_value_get_array>
 8020202:	62f8      	str	r0, [r7, #44]	@ 0x2c
            count = json_array_get_count(array);
 8020204:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 8020206:	f001 f9ce 	bl	80215a6 <json_array_get_count>
 802020a:	6278      	str	r0, [r7, #36]	@ 0x24
            APPEND_STRING("[");
 802020c:	2301      	movs	r3, #1
 802020e:	653b      	str	r3, [r7, #80]	@ 0x50
 8020210:	68bb      	ldr	r3, [r7, #8]
 8020212:	2b00      	cmp	r3, #0
 8020214:	d00e      	beq.n	8020234 <json_serialize_to_buffer_r+0xb4>
 8020216:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8020218:	461a      	mov	r2, r3
 802021a:	497e      	ldr	r1, [pc, #504]	@ (8020414 <json_serialize_to_buffer_r+0x294>)
 802021c:	68b8      	ldr	r0, [r7, #8]
 802021e:	f003 ffe6 	bl	80241ee <memcpy>
 8020222:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8020224:	68ba      	ldr	r2, [r7, #8]
 8020226:	4413      	add	r3, r2
 8020228:	2200      	movs	r2, #0
 802022a:	701a      	strb	r2, [r3, #0]
 802022c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 802022e:	68ba      	ldr	r2, [r7, #8]
 8020230:	4413      	add	r3, r2
 8020232:	60bb      	str	r3, [r7, #8]
 8020234:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8020236:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8020238:	4413      	add	r3, r2
 802023a:	64fb      	str	r3, [r7, #76]	@ 0x4c
            if (count > 0 && is_pretty) {
 802023c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802023e:	2b00      	cmp	r3, #0
 8020240:	d01a      	beq.n	8020278 <json_serialize_to_buffer_r+0xf8>
 8020242:	683b      	ldr	r3, [r7, #0]
 8020244:	2b00      	cmp	r3, #0
 8020246:	d017      	beq.n	8020278 <json_serialize_to_buffer_r+0xf8>
                APPEND_STRING("\n");
 8020248:	2301      	movs	r3, #1
 802024a:	653b      	str	r3, [r7, #80]	@ 0x50
 802024c:	68bb      	ldr	r3, [r7, #8]
 802024e:	2b00      	cmp	r3, #0
 8020250:	d00e      	beq.n	8020270 <json_serialize_to_buffer_r+0xf0>
 8020252:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8020254:	461a      	mov	r2, r3
 8020256:	4970      	ldr	r1, [pc, #448]	@ (8020418 <json_serialize_to_buffer_r+0x298>)
 8020258:	68b8      	ldr	r0, [r7, #8]
 802025a:	f003 ffc8 	bl	80241ee <memcpy>
 802025e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8020260:	68ba      	ldr	r2, [r7, #8]
 8020262:	4413      	add	r3, r2
 8020264:	2200      	movs	r2, #0
 8020266:	701a      	strb	r2, [r3, #0]
 8020268:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 802026a:	68ba      	ldr	r2, [r7, #8]
 802026c:	4413      	add	r3, r2
 802026e:	60bb      	str	r3, [r7, #8]
 8020270:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8020272:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8020274:	4413      	add	r3, r2
 8020276:	64fb      	str	r3, [r7, #76]	@ 0x4c
            }
            for (i = 0; i < count; i++) {
 8020278:	2300      	movs	r3, #0
 802027a:	657b      	str	r3, [r7, #84]	@ 0x54
 802027c:	e081      	b.n	8020382 <json_serialize_to_buffer_r+0x202>
                if (is_pretty) {
 802027e:	683b      	ldr	r3, [r7, #0]
 8020280:	2b00      	cmp	r3, #0
 8020282:	d023      	beq.n	80202cc <json_serialize_to_buffer_r+0x14c>
                    APPEND_INDENT(level+1);
 8020284:	2300      	movs	r3, #0
 8020286:	64bb      	str	r3, [r7, #72]	@ 0x48
 8020288:	2300      	movs	r3, #0
 802028a:	64bb      	str	r3, [r7, #72]	@ 0x48
 802028c:	e01a      	b.n	80202c4 <json_serialize_to_buffer_r+0x144>
 802028e:	2304      	movs	r3, #4
 8020290:	653b      	str	r3, [r7, #80]	@ 0x50
 8020292:	68bb      	ldr	r3, [r7, #8]
 8020294:	2b00      	cmp	r3, #0
 8020296:	d00e      	beq.n	80202b6 <json_serialize_to_buffer_r+0x136>
 8020298:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 802029a:	461a      	mov	r2, r3
 802029c:	495f      	ldr	r1, [pc, #380]	@ (802041c <json_serialize_to_buffer_r+0x29c>)
 802029e:	68b8      	ldr	r0, [r7, #8]
 80202a0:	f003 ffa5 	bl	80241ee <memcpy>
 80202a4:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80202a6:	68ba      	ldr	r2, [r7, #8]
 80202a8:	4413      	add	r3, r2
 80202aa:	2200      	movs	r2, #0
 80202ac:	701a      	strb	r2, [r3, #0]
 80202ae:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80202b0:	68ba      	ldr	r2, [r7, #8]
 80202b2:	4413      	add	r3, r2
 80202b4:	60bb      	str	r3, [r7, #8]
 80202b6:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 80202b8:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80202ba:	4413      	add	r3, r2
 80202bc:	64fb      	str	r3, [r7, #76]	@ 0x4c
 80202be:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80202c0:	3301      	adds	r3, #1
 80202c2:	64bb      	str	r3, [r7, #72]	@ 0x48
 80202c4:	687a      	ldr	r2, [r7, #4]
 80202c6:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80202c8:	429a      	cmp	r2, r3
 80202ca:	dae0      	bge.n	802028e <json_serialize_to_buffer_r+0x10e>
                }
                temp_value = json_array_get_value(array, i);
 80202cc:	6d79      	ldr	r1, [r7, #84]	@ 0x54
 80202ce:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 80202d0:	f001 f93c 	bl	802154c <json_array_get_value>
 80202d4:	6338      	str	r0, [r7, #48]	@ 0x30
                written = json_serialize_to_buffer_r(temp_value, buf, level+1, is_pretty, num_buf);
 80202d6:	687b      	ldr	r3, [r7, #4]
 80202d8:	1c5a      	adds	r2, r3, #1
 80202da:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80202dc:	9300      	str	r3, [sp, #0]
 80202de:	683b      	ldr	r3, [r7, #0]
 80202e0:	68b9      	ldr	r1, [r7, #8]
 80202e2:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 80202e4:	f7ff ff4c 	bl	8020180 <json_serialize_to_buffer_r>
 80202e8:	6538      	str	r0, [r7, #80]	@ 0x50
                if (written < 0) {
 80202ea:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80202ec:	2b00      	cmp	r3, #0
 80202ee:	da02      	bge.n	80202f6 <json_serialize_to_buffer_r+0x176>
                    return -1;
 80202f0:	f04f 33ff 	mov.w	r3, #4294967295
 80202f4:	e2c5      	b.n	8020882 <json_serialize_to_buffer_r+0x702>
                }
                if (buf != NULL) {
 80202f6:	68bb      	ldr	r3, [r7, #8]
 80202f8:	2b00      	cmp	r3, #0
 80202fa:	d003      	beq.n	8020304 <json_serialize_to_buffer_r+0x184>
                    buf += written;
 80202fc:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80202fe:	68ba      	ldr	r2, [r7, #8]
 8020300:	4413      	add	r3, r2
 8020302:	60bb      	str	r3, [r7, #8]
                }
                written_total += written;
 8020304:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8020306:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8020308:	4413      	add	r3, r2
 802030a:	64fb      	str	r3, [r7, #76]	@ 0x4c
                if (i < (count - 1)) {
 802030c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802030e:	3b01      	subs	r3, #1
 8020310:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 8020312:	429a      	cmp	r2, r3
 8020314:	d217      	bcs.n	8020346 <json_serialize_to_buffer_r+0x1c6>
                    APPEND_STRING(",");
 8020316:	2301      	movs	r3, #1
 8020318:	653b      	str	r3, [r7, #80]	@ 0x50
 802031a:	68bb      	ldr	r3, [r7, #8]
 802031c:	2b00      	cmp	r3, #0
 802031e:	d00e      	beq.n	802033e <json_serialize_to_buffer_r+0x1be>
 8020320:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8020322:	461a      	mov	r2, r3
 8020324:	493e      	ldr	r1, [pc, #248]	@ (8020420 <json_serialize_to_buffer_r+0x2a0>)
 8020326:	68b8      	ldr	r0, [r7, #8]
 8020328:	f003 ff61 	bl	80241ee <memcpy>
 802032c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 802032e:	68ba      	ldr	r2, [r7, #8]
 8020330:	4413      	add	r3, r2
 8020332:	2200      	movs	r2, #0
 8020334:	701a      	strb	r2, [r3, #0]
 8020336:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8020338:	68ba      	ldr	r2, [r7, #8]
 802033a:	4413      	add	r3, r2
 802033c:	60bb      	str	r3, [r7, #8]
 802033e:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8020340:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8020342:	4413      	add	r3, r2
 8020344:	64fb      	str	r3, [r7, #76]	@ 0x4c
                }
                if (is_pretty) {
 8020346:	683b      	ldr	r3, [r7, #0]
 8020348:	2b00      	cmp	r3, #0
 802034a:	d017      	beq.n	802037c <json_serialize_to_buffer_r+0x1fc>
                    APPEND_STRING("\n");
 802034c:	2301      	movs	r3, #1
 802034e:	653b      	str	r3, [r7, #80]	@ 0x50
 8020350:	68bb      	ldr	r3, [r7, #8]
 8020352:	2b00      	cmp	r3, #0
 8020354:	d00e      	beq.n	8020374 <json_serialize_to_buffer_r+0x1f4>
 8020356:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8020358:	461a      	mov	r2, r3
 802035a:	492f      	ldr	r1, [pc, #188]	@ (8020418 <json_serialize_to_buffer_r+0x298>)
 802035c:	68b8      	ldr	r0, [r7, #8]
 802035e:	f003 ff46 	bl	80241ee <memcpy>
 8020362:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8020364:	68ba      	ldr	r2, [r7, #8]
 8020366:	4413      	add	r3, r2
 8020368:	2200      	movs	r2, #0
 802036a:	701a      	strb	r2, [r3, #0]
 802036c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 802036e:	68ba      	ldr	r2, [r7, #8]
 8020370:	4413      	add	r3, r2
 8020372:	60bb      	str	r3, [r7, #8]
 8020374:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8020376:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8020378:	4413      	add	r3, r2
 802037a:	64fb      	str	r3, [r7, #76]	@ 0x4c
            for (i = 0; i < count; i++) {
 802037c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 802037e:	3301      	adds	r3, #1
 8020380:	657b      	str	r3, [r7, #84]	@ 0x54
 8020382:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 8020384:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8020386:	429a      	cmp	r2, r3
 8020388:	f4ff af79 	bcc.w	802027e <json_serialize_to_buffer_r+0xfe>
                }
            }
            if (count > 0 && is_pretty) {
 802038c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802038e:	2b00      	cmp	r3, #0
 8020390:	d026      	beq.n	80203e0 <json_serialize_to_buffer_r+0x260>
 8020392:	683b      	ldr	r3, [r7, #0]
 8020394:	2b00      	cmp	r3, #0
 8020396:	d023      	beq.n	80203e0 <json_serialize_to_buffer_r+0x260>
                APPEND_INDENT(level);
 8020398:	2300      	movs	r3, #0
 802039a:	647b      	str	r3, [r7, #68]	@ 0x44
 802039c:	2300      	movs	r3, #0
 802039e:	647b      	str	r3, [r7, #68]	@ 0x44
 80203a0:	e01a      	b.n	80203d8 <json_serialize_to_buffer_r+0x258>
 80203a2:	2304      	movs	r3, #4
 80203a4:	653b      	str	r3, [r7, #80]	@ 0x50
 80203a6:	68bb      	ldr	r3, [r7, #8]
 80203a8:	2b00      	cmp	r3, #0
 80203aa:	d00e      	beq.n	80203ca <json_serialize_to_buffer_r+0x24a>
 80203ac:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80203ae:	461a      	mov	r2, r3
 80203b0:	491a      	ldr	r1, [pc, #104]	@ (802041c <json_serialize_to_buffer_r+0x29c>)
 80203b2:	68b8      	ldr	r0, [r7, #8]
 80203b4:	f003 ff1b 	bl	80241ee <memcpy>
 80203b8:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80203ba:	68ba      	ldr	r2, [r7, #8]
 80203bc:	4413      	add	r3, r2
 80203be:	2200      	movs	r2, #0
 80203c0:	701a      	strb	r2, [r3, #0]
 80203c2:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80203c4:	68ba      	ldr	r2, [r7, #8]
 80203c6:	4413      	add	r3, r2
 80203c8:	60bb      	str	r3, [r7, #8]
 80203ca:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 80203cc:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80203ce:	4413      	add	r3, r2
 80203d0:	64fb      	str	r3, [r7, #76]	@ 0x4c
 80203d2:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80203d4:	3301      	adds	r3, #1
 80203d6:	647b      	str	r3, [r7, #68]	@ 0x44
 80203d8:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 80203da:	687b      	ldr	r3, [r7, #4]
 80203dc:	429a      	cmp	r2, r3
 80203de:	dbe0      	blt.n	80203a2 <json_serialize_to_buffer_r+0x222>
            }
            APPEND_STRING("]");
 80203e0:	2301      	movs	r3, #1
 80203e2:	653b      	str	r3, [r7, #80]	@ 0x50
 80203e4:	68bb      	ldr	r3, [r7, #8]
 80203e6:	2b00      	cmp	r3, #0
 80203e8:	d00e      	beq.n	8020408 <json_serialize_to_buffer_r+0x288>
 80203ea:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80203ec:	461a      	mov	r2, r3
 80203ee:	490d      	ldr	r1, [pc, #52]	@ (8020424 <json_serialize_to_buffer_r+0x2a4>)
 80203f0:	68b8      	ldr	r0, [r7, #8]
 80203f2:	f003 fefc 	bl	80241ee <memcpy>
 80203f6:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80203f8:	68ba      	ldr	r2, [r7, #8]
 80203fa:	4413      	add	r3, r2
 80203fc:	2200      	movs	r2, #0
 80203fe:	701a      	strb	r2, [r3, #0]
 8020400:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8020402:	68ba      	ldr	r2, [r7, #8]
 8020404:	4413      	add	r3, r2
 8020406:	60bb      	str	r3, [r7, #8]
 8020408:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 802040a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 802040c:	4413      	add	r3, r2
 802040e:	64fb      	str	r3, [r7, #76]	@ 0x4c
            return written_total;
 8020410:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8020412:	e236      	b.n	8020882 <json_serialize_to_buffer_r+0x702>
 8020414:	0802a2e8 	.word	0x0802a2e8
 8020418:	0802a2ec 	.word	0x0802a2ec
 802041c:	0802a2f0 	.word	0x0802a2f0
 8020420:	0802a2f8 	.word	0x0802a2f8
 8020424:	0802a2fc 	.word	0x0802a2fc
        case JSONObject:
            object = json_value_get_object(value);
 8020428:	68f8      	ldr	r0, [r7, #12]
 802042a:	f001 f8f0 	bl	802160e <json_value_get_object>
 802042e:	62b8      	str	r0, [r7, #40]	@ 0x28
            count  = json_object_get_count(object);
 8020430:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 8020432:	f001 f80d 	bl	8021450 <json_object_get_count>
 8020436:	6278      	str	r0, [r7, #36]	@ 0x24
            APPEND_STRING("{");
 8020438:	2301      	movs	r3, #1
 802043a:	653b      	str	r3, [r7, #80]	@ 0x50
 802043c:	68bb      	ldr	r3, [r7, #8]
 802043e:	2b00      	cmp	r3, #0
 8020440:	d00e      	beq.n	8020460 <json_serialize_to_buffer_r+0x2e0>
 8020442:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8020444:	461a      	mov	r2, r3
 8020446:	498e      	ldr	r1, [pc, #568]	@ (8020680 <json_serialize_to_buffer_r+0x500>)
 8020448:	68b8      	ldr	r0, [r7, #8]
 802044a:	f003 fed0 	bl	80241ee <memcpy>
 802044e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8020450:	68ba      	ldr	r2, [r7, #8]
 8020452:	4413      	add	r3, r2
 8020454:	2200      	movs	r2, #0
 8020456:	701a      	strb	r2, [r3, #0]
 8020458:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 802045a:	68ba      	ldr	r2, [r7, #8]
 802045c:	4413      	add	r3, r2
 802045e:	60bb      	str	r3, [r7, #8]
 8020460:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8020462:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8020464:	4413      	add	r3, r2
 8020466:	64fb      	str	r3, [r7, #76]	@ 0x4c
            if (count > 0 && is_pretty) {
 8020468:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802046a:	2b00      	cmp	r3, #0
 802046c:	d01a      	beq.n	80204a4 <json_serialize_to_buffer_r+0x324>
 802046e:	683b      	ldr	r3, [r7, #0]
 8020470:	2b00      	cmp	r3, #0
 8020472:	d017      	beq.n	80204a4 <json_serialize_to_buffer_r+0x324>
                APPEND_STRING("\n");
 8020474:	2301      	movs	r3, #1
 8020476:	653b      	str	r3, [r7, #80]	@ 0x50
 8020478:	68bb      	ldr	r3, [r7, #8]
 802047a:	2b00      	cmp	r3, #0
 802047c:	d00e      	beq.n	802049c <json_serialize_to_buffer_r+0x31c>
 802047e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8020480:	461a      	mov	r2, r3
 8020482:	4980      	ldr	r1, [pc, #512]	@ (8020684 <json_serialize_to_buffer_r+0x504>)
 8020484:	68b8      	ldr	r0, [r7, #8]
 8020486:	f003 feb2 	bl	80241ee <memcpy>
 802048a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 802048c:	68ba      	ldr	r2, [r7, #8]
 802048e:	4413      	add	r3, r2
 8020490:	2200      	movs	r2, #0
 8020492:	701a      	strb	r2, [r3, #0]
 8020494:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8020496:	68ba      	ldr	r2, [r7, #8]
 8020498:	4413      	add	r3, r2
 802049a:	60bb      	str	r3, [r7, #8]
 802049c:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 802049e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80204a0:	4413      	add	r3, r2
 80204a2:	64fb      	str	r3, [r7, #76]	@ 0x4c
            }
            for (i = 0; i < count; i++) {
 80204a4:	2300      	movs	r3, #0
 80204a6:	657b      	str	r3, [r7, #84]	@ 0x54
 80204a8:	e0da      	b.n	8020660 <json_serialize_to_buffer_r+0x4e0>
                key = json_object_get_name(object, i);
 80204aa:	6d79      	ldr	r1, [r7, #84]	@ 0x54
 80204ac:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 80204ae:	f000 ffe0 	bl	8021472 <json_object_get_name>
 80204b2:	63b8      	str	r0, [r7, #56]	@ 0x38
                if (key == NULL) {
 80204b4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80204b6:	2b00      	cmp	r3, #0
 80204b8:	d102      	bne.n	80204c0 <json_serialize_to_buffer_r+0x340>
                    return -1;
 80204ba:	f04f 33ff 	mov.w	r3, #4294967295
 80204be:	e1e0      	b.n	8020882 <json_serialize_to_buffer_r+0x702>
                }
                if (is_pretty) {
 80204c0:	683b      	ldr	r3, [r7, #0]
 80204c2:	2b00      	cmp	r3, #0
 80204c4:	d023      	beq.n	802050e <json_serialize_to_buffer_r+0x38e>
                    APPEND_INDENT(level+1);
 80204c6:	2300      	movs	r3, #0
 80204c8:	643b      	str	r3, [r7, #64]	@ 0x40
 80204ca:	2300      	movs	r3, #0
 80204cc:	643b      	str	r3, [r7, #64]	@ 0x40
 80204ce:	e01a      	b.n	8020506 <json_serialize_to_buffer_r+0x386>
 80204d0:	2304      	movs	r3, #4
 80204d2:	653b      	str	r3, [r7, #80]	@ 0x50
 80204d4:	68bb      	ldr	r3, [r7, #8]
 80204d6:	2b00      	cmp	r3, #0
 80204d8:	d00e      	beq.n	80204f8 <json_serialize_to_buffer_r+0x378>
 80204da:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80204dc:	461a      	mov	r2, r3
 80204de:	496a      	ldr	r1, [pc, #424]	@ (8020688 <json_serialize_to_buffer_r+0x508>)
 80204e0:	68b8      	ldr	r0, [r7, #8]
 80204e2:	f003 fe84 	bl	80241ee <memcpy>
 80204e6:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80204e8:	68ba      	ldr	r2, [r7, #8]
 80204ea:	4413      	add	r3, r2
 80204ec:	2200      	movs	r2, #0
 80204ee:	701a      	strb	r2, [r3, #0]
 80204f0:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80204f2:	68ba      	ldr	r2, [r7, #8]
 80204f4:	4413      	add	r3, r2
 80204f6:	60bb      	str	r3, [r7, #8]
 80204f8:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 80204fa:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80204fc:	4413      	add	r3, r2
 80204fe:	64fb      	str	r3, [r7, #76]	@ 0x4c
 8020500:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8020502:	3301      	adds	r3, #1
 8020504:	643b      	str	r3, [r7, #64]	@ 0x40
 8020506:	687a      	ldr	r2, [r7, #4]
 8020508:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802050a:	429a      	cmp	r2, r3
 802050c:	dae0      	bge.n	80204d0 <json_serialize_to_buffer_r+0x350>
                }
                /* We do not support key names with embedded \0 chars */
                written = json_serialize_string(key, strlen(key), buf);
 802050e:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 8020510:	f7df febc 	bl	800028c <strlen>
 8020514:	4603      	mov	r3, r0
 8020516:	68ba      	ldr	r2, [r7, #8]
 8020518:	4619      	mov	r1, r3
 802051a:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 802051c:	f000 f9c6 	bl	80208ac <json_serialize_string>
 8020520:	6538      	str	r0, [r7, #80]	@ 0x50
                if (written < 0) {
 8020522:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8020524:	2b00      	cmp	r3, #0
 8020526:	da02      	bge.n	802052e <json_serialize_to_buffer_r+0x3ae>
                    return -1;
 8020528:	f04f 33ff 	mov.w	r3, #4294967295
 802052c:	e1a9      	b.n	8020882 <json_serialize_to_buffer_r+0x702>
                }
                if (buf != NULL) {
 802052e:	68bb      	ldr	r3, [r7, #8]
 8020530:	2b00      	cmp	r3, #0
 8020532:	d003      	beq.n	802053c <json_serialize_to_buffer_r+0x3bc>
                    buf += written;
 8020534:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8020536:	68ba      	ldr	r2, [r7, #8]
 8020538:	4413      	add	r3, r2
 802053a:	60bb      	str	r3, [r7, #8]
                }
                written_total += written;
 802053c:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 802053e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8020540:	4413      	add	r3, r2
 8020542:	64fb      	str	r3, [r7, #76]	@ 0x4c
                APPEND_STRING(":");
 8020544:	2301      	movs	r3, #1
 8020546:	653b      	str	r3, [r7, #80]	@ 0x50
 8020548:	68bb      	ldr	r3, [r7, #8]
 802054a:	2b00      	cmp	r3, #0
 802054c:	d00e      	beq.n	802056c <json_serialize_to_buffer_r+0x3ec>
 802054e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8020550:	461a      	mov	r2, r3
 8020552:	494e      	ldr	r1, [pc, #312]	@ (802068c <json_serialize_to_buffer_r+0x50c>)
 8020554:	68b8      	ldr	r0, [r7, #8]
 8020556:	f003 fe4a 	bl	80241ee <memcpy>
 802055a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 802055c:	68ba      	ldr	r2, [r7, #8]
 802055e:	4413      	add	r3, r2
 8020560:	2200      	movs	r2, #0
 8020562:	701a      	strb	r2, [r3, #0]
 8020564:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8020566:	68ba      	ldr	r2, [r7, #8]
 8020568:	4413      	add	r3, r2
 802056a:	60bb      	str	r3, [r7, #8]
 802056c:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 802056e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8020570:	4413      	add	r3, r2
 8020572:	64fb      	str	r3, [r7, #76]	@ 0x4c
                if (is_pretty) {
 8020574:	683b      	ldr	r3, [r7, #0]
 8020576:	2b00      	cmp	r3, #0
 8020578:	d017      	beq.n	80205aa <json_serialize_to_buffer_r+0x42a>
                    APPEND_STRING(" ");
 802057a:	2301      	movs	r3, #1
 802057c:	653b      	str	r3, [r7, #80]	@ 0x50
 802057e:	68bb      	ldr	r3, [r7, #8]
 8020580:	2b00      	cmp	r3, #0
 8020582:	d00e      	beq.n	80205a2 <json_serialize_to_buffer_r+0x422>
 8020584:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8020586:	461a      	mov	r2, r3
 8020588:	4941      	ldr	r1, [pc, #260]	@ (8020690 <json_serialize_to_buffer_r+0x510>)
 802058a:	68b8      	ldr	r0, [r7, #8]
 802058c:	f003 fe2f 	bl	80241ee <memcpy>
 8020590:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8020592:	68ba      	ldr	r2, [r7, #8]
 8020594:	4413      	add	r3, r2
 8020596:	2200      	movs	r2, #0
 8020598:	701a      	strb	r2, [r3, #0]
 802059a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 802059c:	68ba      	ldr	r2, [r7, #8]
 802059e:	4413      	add	r3, r2
 80205a0:	60bb      	str	r3, [r7, #8]
 80205a2:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 80205a4:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80205a6:	4413      	add	r3, r2
 80205a8:	64fb      	str	r3, [r7, #76]	@ 0x4c
                }
                temp_value = json_object_get_value_at(object, i);
 80205aa:	6d79      	ldr	r1, [r7, #84]	@ 0x54
 80205ac:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 80205ae:	f000 ff7b 	bl	80214a8 <json_object_get_value_at>
 80205b2:	6338      	str	r0, [r7, #48]	@ 0x30
                written = json_serialize_to_buffer_r(temp_value, buf, level+1, is_pretty, num_buf);
 80205b4:	687b      	ldr	r3, [r7, #4]
 80205b6:	1c5a      	adds	r2, r3, #1
 80205b8:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80205ba:	9300      	str	r3, [sp, #0]
 80205bc:	683b      	ldr	r3, [r7, #0]
 80205be:	68b9      	ldr	r1, [r7, #8]
 80205c0:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 80205c2:	f7ff fddd 	bl	8020180 <json_serialize_to_buffer_r>
 80205c6:	6538      	str	r0, [r7, #80]	@ 0x50
                if (written < 0) {
 80205c8:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80205ca:	2b00      	cmp	r3, #0
 80205cc:	da02      	bge.n	80205d4 <json_serialize_to_buffer_r+0x454>
                    return -1;
 80205ce:	f04f 33ff 	mov.w	r3, #4294967295
 80205d2:	e156      	b.n	8020882 <json_serialize_to_buffer_r+0x702>
                }
                if (buf != NULL) {
 80205d4:	68bb      	ldr	r3, [r7, #8]
 80205d6:	2b00      	cmp	r3, #0
 80205d8:	d003      	beq.n	80205e2 <json_serialize_to_buffer_r+0x462>
                    buf += written;
 80205da:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80205dc:	68ba      	ldr	r2, [r7, #8]
 80205de:	4413      	add	r3, r2
 80205e0:	60bb      	str	r3, [r7, #8]
                }
                written_total += written;
 80205e2:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 80205e4:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80205e6:	4413      	add	r3, r2
 80205e8:	64fb      	str	r3, [r7, #76]	@ 0x4c
                if (i < (count - 1)) {
 80205ea:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80205ec:	3b01      	subs	r3, #1
 80205ee:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 80205f0:	429a      	cmp	r2, r3
 80205f2:	d217      	bcs.n	8020624 <json_serialize_to_buffer_r+0x4a4>
                    APPEND_STRING(",");
 80205f4:	2301      	movs	r3, #1
 80205f6:	653b      	str	r3, [r7, #80]	@ 0x50
 80205f8:	68bb      	ldr	r3, [r7, #8]
 80205fa:	2b00      	cmp	r3, #0
 80205fc:	d00e      	beq.n	802061c <json_serialize_to_buffer_r+0x49c>
 80205fe:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8020600:	461a      	mov	r2, r3
 8020602:	4924      	ldr	r1, [pc, #144]	@ (8020694 <json_serialize_to_buffer_r+0x514>)
 8020604:	68b8      	ldr	r0, [r7, #8]
 8020606:	f003 fdf2 	bl	80241ee <memcpy>
 802060a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 802060c:	68ba      	ldr	r2, [r7, #8]
 802060e:	4413      	add	r3, r2
 8020610:	2200      	movs	r2, #0
 8020612:	701a      	strb	r2, [r3, #0]
 8020614:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8020616:	68ba      	ldr	r2, [r7, #8]
 8020618:	4413      	add	r3, r2
 802061a:	60bb      	str	r3, [r7, #8]
 802061c:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 802061e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8020620:	4413      	add	r3, r2
 8020622:	64fb      	str	r3, [r7, #76]	@ 0x4c
                }
                if (is_pretty) {
 8020624:	683b      	ldr	r3, [r7, #0]
 8020626:	2b00      	cmp	r3, #0
 8020628:	d017      	beq.n	802065a <json_serialize_to_buffer_r+0x4da>
                    APPEND_STRING("\n");
 802062a:	2301      	movs	r3, #1
 802062c:	653b      	str	r3, [r7, #80]	@ 0x50
 802062e:	68bb      	ldr	r3, [r7, #8]
 8020630:	2b00      	cmp	r3, #0
 8020632:	d00e      	beq.n	8020652 <json_serialize_to_buffer_r+0x4d2>
 8020634:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8020636:	461a      	mov	r2, r3
 8020638:	4912      	ldr	r1, [pc, #72]	@ (8020684 <json_serialize_to_buffer_r+0x504>)
 802063a:	68b8      	ldr	r0, [r7, #8]
 802063c:	f003 fdd7 	bl	80241ee <memcpy>
 8020640:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8020642:	68ba      	ldr	r2, [r7, #8]
 8020644:	4413      	add	r3, r2
 8020646:	2200      	movs	r2, #0
 8020648:	701a      	strb	r2, [r3, #0]
 802064a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 802064c:	68ba      	ldr	r2, [r7, #8]
 802064e:	4413      	add	r3, r2
 8020650:	60bb      	str	r3, [r7, #8]
 8020652:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8020654:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8020656:	4413      	add	r3, r2
 8020658:	64fb      	str	r3, [r7, #76]	@ 0x4c
            for (i = 0; i < count; i++) {
 802065a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 802065c:	3301      	adds	r3, #1
 802065e:	657b      	str	r3, [r7, #84]	@ 0x54
 8020660:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 8020662:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8020664:	429a      	cmp	r2, r3
 8020666:	f4ff af20 	bcc.w	80204aa <json_serialize_to_buffer_r+0x32a>
                }
            }
            if (count > 0 && is_pretty) {
 802066a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802066c:	2b00      	cmp	r3, #0
 802066e:	d032      	beq.n	80206d6 <json_serialize_to_buffer_r+0x556>
 8020670:	683b      	ldr	r3, [r7, #0]
 8020672:	2b00      	cmp	r3, #0
 8020674:	d02f      	beq.n	80206d6 <json_serialize_to_buffer_r+0x556>
                APPEND_INDENT(level);
 8020676:	2300      	movs	r3, #0
 8020678:	63fb      	str	r3, [r7, #60]	@ 0x3c
 802067a:	2300      	movs	r3, #0
 802067c:	63fb      	str	r3, [r7, #60]	@ 0x3c
 802067e:	e026      	b.n	80206ce <json_serialize_to_buffer_r+0x54e>
 8020680:	0802a300 	.word	0x0802a300
 8020684:	0802a2ec 	.word	0x0802a2ec
 8020688:	0802a2f0 	.word	0x0802a2f0
 802068c:	0802a304 	.word	0x0802a304
 8020690:	0802a308 	.word	0x0802a308
 8020694:	0802a2f8 	.word	0x0802a2f8
 8020698:	2304      	movs	r3, #4
 802069a:	653b      	str	r3, [r7, #80]	@ 0x50
 802069c:	68bb      	ldr	r3, [r7, #8]
 802069e:	2b00      	cmp	r3, #0
 80206a0:	d00e      	beq.n	80206c0 <json_serialize_to_buffer_r+0x540>
 80206a2:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80206a4:	461a      	mov	r2, r3
 80206a6:	4979      	ldr	r1, [pc, #484]	@ (802088c <json_serialize_to_buffer_r+0x70c>)
 80206a8:	68b8      	ldr	r0, [r7, #8]
 80206aa:	f003 fda0 	bl	80241ee <memcpy>
 80206ae:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80206b0:	68ba      	ldr	r2, [r7, #8]
 80206b2:	4413      	add	r3, r2
 80206b4:	2200      	movs	r2, #0
 80206b6:	701a      	strb	r2, [r3, #0]
 80206b8:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80206ba:	68ba      	ldr	r2, [r7, #8]
 80206bc:	4413      	add	r3, r2
 80206be:	60bb      	str	r3, [r7, #8]
 80206c0:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 80206c2:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80206c4:	4413      	add	r3, r2
 80206c6:	64fb      	str	r3, [r7, #76]	@ 0x4c
 80206c8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80206ca:	3301      	adds	r3, #1
 80206cc:	63fb      	str	r3, [r7, #60]	@ 0x3c
 80206ce:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 80206d0:	687b      	ldr	r3, [r7, #4]
 80206d2:	429a      	cmp	r2, r3
 80206d4:	dbe0      	blt.n	8020698 <json_serialize_to_buffer_r+0x518>
            }
            APPEND_STRING("}");
 80206d6:	2301      	movs	r3, #1
 80206d8:	653b      	str	r3, [r7, #80]	@ 0x50
 80206da:	68bb      	ldr	r3, [r7, #8]
 80206dc:	2b00      	cmp	r3, #0
 80206de:	d00e      	beq.n	80206fe <json_serialize_to_buffer_r+0x57e>
 80206e0:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80206e2:	461a      	mov	r2, r3
 80206e4:	496a      	ldr	r1, [pc, #424]	@ (8020890 <json_serialize_to_buffer_r+0x710>)
 80206e6:	68b8      	ldr	r0, [r7, #8]
 80206e8:	f003 fd81 	bl	80241ee <memcpy>
 80206ec:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80206ee:	68ba      	ldr	r2, [r7, #8]
 80206f0:	4413      	add	r3, r2
 80206f2:	2200      	movs	r2, #0
 80206f4:	701a      	strb	r2, [r3, #0]
 80206f6:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80206f8:	68ba      	ldr	r2, [r7, #8]
 80206fa:	4413      	add	r3, r2
 80206fc:	60bb      	str	r3, [r7, #8]
 80206fe:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8020700:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8020702:	4413      	add	r3, r2
 8020704:	64fb      	str	r3, [r7, #76]	@ 0x4c
            return written_total;
 8020706:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8020708:	e0bb      	b.n	8020882 <json_serialize_to_buffer_r+0x702>
        case JSONString:
            string = json_value_get_string(value);
 802070a:	68f8      	ldr	r0, [r7, #12]
 802070c:	f000 ffb5 	bl	802167a <json_value_get_string>
 8020710:	6378      	str	r0, [r7, #52]	@ 0x34
            if (string == NULL) {
 8020712:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8020714:	2b00      	cmp	r3, #0
 8020716:	d102      	bne.n	802071e <json_serialize_to_buffer_r+0x59e>
                return -1;
 8020718:	f04f 33ff 	mov.w	r3, #4294967295
 802071c:	e0b1      	b.n	8020882 <json_serialize_to_buffer_r+0x702>
            }
            len = json_value_get_string_len(value);
 802071e:	68f8      	ldr	r0, [r7, #12]
 8020720:	f000 ffbe 	bl	80216a0 <json_value_get_string_len>
 8020724:	6178      	str	r0, [r7, #20]
            written = json_serialize_string(string, len, buf);
 8020726:	68ba      	ldr	r2, [r7, #8]
 8020728:	6979      	ldr	r1, [r7, #20]
 802072a:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 802072c:	f000 f8be 	bl	80208ac <json_serialize_string>
 8020730:	6538      	str	r0, [r7, #80]	@ 0x50
            if (written < 0) {
 8020732:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8020734:	2b00      	cmp	r3, #0
 8020736:	da02      	bge.n	802073e <json_serialize_to_buffer_r+0x5be>
                return -1;
 8020738:	f04f 33ff 	mov.w	r3, #4294967295
 802073c:	e0a1      	b.n	8020882 <json_serialize_to_buffer_r+0x702>
            }
            if (buf != NULL) {
 802073e:	68bb      	ldr	r3, [r7, #8]
 8020740:	2b00      	cmp	r3, #0
 8020742:	d003      	beq.n	802074c <json_serialize_to_buffer_r+0x5cc>
                buf += written;
 8020744:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8020746:	68ba      	ldr	r2, [r7, #8]
 8020748:	4413      	add	r3, r2
 802074a:	60bb      	str	r3, [r7, #8]
            }
            written_total += written;
 802074c:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 802074e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8020750:	4413      	add	r3, r2
 8020752:	64fb      	str	r3, [r7, #76]	@ 0x4c
            return written_total;
 8020754:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8020756:	e094      	b.n	8020882 <json_serialize_to_buffer_r+0x702>
        case JSONBoolean:
            if (json_value_get_boolean(value)) {
 8020758:	68f8      	ldr	r0, [r7, #12]
 802075a:	f000 ffcb 	bl	80216f4 <json_value_get_boolean>
 802075e:	4603      	mov	r3, r0
 8020760:	2b00      	cmp	r3, #0
 8020762:	d018      	beq.n	8020796 <json_serialize_to_buffer_r+0x616>
                APPEND_STRING("true");
 8020764:	2304      	movs	r3, #4
 8020766:	653b      	str	r3, [r7, #80]	@ 0x50
 8020768:	68bb      	ldr	r3, [r7, #8]
 802076a:	2b00      	cmp	r3, #0
 802076c:	d00e      	beq.n	802078c <json_serialize_to_buffer_r+0x60c>
 802076e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8020770:	461a      	mov	r2, r3
 8020772:	4948      	ldr	r1, [pc, #288]	@ (8020894 <json_serialize_to_buffer_r+0x714>)
 8020774:	68b8      	ldr	r0, [r7, #8]
 8020776:	f003 fd3a 	bl	80241ee <memcpy>
 802077a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 802077c:	68ba      	ldr	r2, [r7, #8]
 802077e:	4413      	add	r3, r2
 8020780:	2200      	movs	r2, #0
 8020782:	701a      	strb	r2, [r3, #0]
 8020784:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8020786:	68ba      	ldr	r2, [r7, #8]
 8020788:	4413      	add	r3, r2
 802078a:	60bb      	str	r3, [r7, #8]
 802078c:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 802078e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8020790:	4413      	add	r3, r2
 8020792:	64fb      	str	r3, [r7, #76]	@ 0x4c
 8020794:	e017      	b.n	80207c6 <json_serialize_to_buffer_r+0x646>
            } else {
                APPEND_STRING("false");
 8020796:	2305      	movs	r3, #5
 8020798:	653b      	str	r3, [r7, #80]	@ 0x50
 802079a:	68bb      	ldr	r3, [r7, #8]
 802079c:	2b00      	cmp	r3, #0
 802079e:	d00e      	beq.n	80207be <json_serialize_to_buffer_r+0x63e>
 80207a0:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80207a2:	461a      	mov	r2, r3
 80207a4:	493c      	ldr	r1, [pc, #240]	@ (8020898 <json_serialize_to_buffer_r+0x718>)
 80207a6:	68b8      	ldr	r0, [r7, #8]
 80207a8:	f003 fd21 	bl	80241ee <memcpy>
 80207ac:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80207ae:	68ba      	ldr	r2, [r7, #8]
 80207b0:	4413      	add	r3, r2
 80207b2:	2200      	movs	r2, #0
 80207b4:	701a      	strb	r2, [r3, #0]
 80207b6:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80207b8:	68ba      	ldr	r2, [r7, #8]
 80207ba:	4413      	add	r3, r2
 80207bc:	60bb      	str	r3, [r7, #8]
 80207be:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 80207c0:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80207c2:	4413      	add	r3, r2
 80207c4:	64fb      	str	r3, [r7, #76]	@ 0x4c
            }
            return written_total;
 80207c6:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80207c8:	e05b      	b.n	8020882 <json_serialize_to_buffer_r+0x702>
        case JSONNumber:
            num = json_value_get_number(value);
 80207ca:	68f8      	ldr	r0, [r7, #12]
 80207cc:	f000 ff7b 	bl	80216c6 <json_value_get_number>
 80207d0:	e9c7 0106 	strd	r0, r1, [r7, #24]
            if (buf != NULL) {
 80207d4:	68bb      	ldr	r3, [r7, #8]
 80207d6:	2b00      	cmp	r3, #0
 80207d8:	d001      	beq.n	80207de <json_serialize_to_buffer_r+0x65e>
                num_buf = buf;
 80207da:	68bb      	ldr	r3, [r7, #8]
 80207dc:	663b      	str	r3, [r7, #96]	@ 0x60
            }
            if (parson_number_serialization_function) {
 80207de:	4b2f      	ldr	r3, [pc, #188]	@ (802089c <json_serialize_to_buffer_r+0x71c>)
 80207e0:	681b      	ldr	r3, [r3, #0]
 80207e2:	2b00      	cmp	r3, #0
 80207e4:	d007      	beq.n	80207f6 <json_serialize_to_buffer_r+0x676>
                written = parson_number_serialization_function(num, num_buf);
 80207e6:	4b2d      	ldr	r3, [pc, #180]	@ (802089c <json_serialize_to_buffer_r+0x71c>)
 80207e8:	681b      	ldr	r3, [r3, #0]
 80207ea:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 80207ec:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 80207f0:	4798      	blx	r3
 80207f2:	6538      	str	r0, [r7, #80]	@ 0x50
 80207f4:	e013      	b.n	802081e <json_serialize_to_buffer_r+0x69e>
            } else if (parson_float_format) {
 80207f6:	4b2a      	ldr	r3, [pc, #168]	@ (80208a0 <json_serialize_to_buffer_r+0x720>)
 80207f8:	681b      	ldr	r3, [r3, #0]
 80207fa:	2b00      	cmp	r3, #0
 80207fc:	d008      	beq.n	8020810 <json_serialize_to_buffer_r+0x690>
                written = sprintf(num_buf, parson_float_format, num);
 80207fe:	4b28      	ldr	r3, [pc, #160]	@ (80208a0 <json_serialize_to_buffer_r+0x720>)
 8020800:	6819      	ldr	r1, [r3, #0]
 8020802:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 8020806:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 8020808:	f003 fb18 	bl	8023e3c <siprintf>
 802080c:	6538      	str	r0, [r7, #80]	@ 0x50
 802080e:	e006      	b.n	802081e <json_serialize_to_buffer_r+0x69e>
            } else {
                written = sprintf(num_buf, PARSON_DEFAULT_FLOAT_FORMAT, num);
 8020810:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 8020814:	4923      	ldr	r1, [pc, #140]	@ (80208a4 <json_serialize_to_buffer_r+0x724>)
 8020816:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 8020818:	f003 fb10 	bl	8023e3c <siprintf>
 802081c:	6538      	str	r0, [r7, #80]	@ 0x50
            }
            if (written < 0) {
 802081e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8020820:	2b00      	cmp	r3, #0
 8020822:	da02      	bge.n	802082a <json_serialize_to_buffer_r+0x6aa>
                return -1;
 8020824:	f04f 33ff 	mov.w	r3, #4294967295
 8020828:	e02b      	b.n	8020882 <json_serialize_to_buffer_r+0x702>
            }
            if (buf != NULL) {
 802082a:	68bb      	ldr	r3, [r7, #8]
 802082c:	2b00      	cmp	r3, #0
 802082e:	d003      	beq.n	8020838 <json_serialize_to_buffer_r+0x6b8>
                buf += written;
 8020830:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8020832:	68ba      	ldr	r2, [r7, #8]
 8020834:	4413      	add	r3, r2
 8020836:	60bb      	str	r3, [r7, #8]
            }
            written_total += written;
 8020838:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 802083a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 802083c:	4413      	add	r3, r2
 802083e:	64fb      	str	r3, [r7, #76]	@ 0x4c
            return written_total;
 8020840:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8020842:	e01e      	b.n	8020882 <json_serialize_to_buffer_r+0x702>
        case JSONNull:
            APPEND_STRING("null");
 8020844:	2304      	movs	r3, #4
 8020846:	653b      	str	r3, [r7, #80]	@ 0x50
 8020848:	68bb      	ldr	r3, [r7, #8]
 802084a:	2b00      	cmp	r3, #0
 802084c:	d00e      	beq.n	802086c <json_serialize_to_buffer_r+0x6ec>
 802084e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8020850:	461a      	mov	r2, r3
 8020852:	4915      	ldr	r1, [pc, #84]	@ (80208a8 <json_serialize_to_buffer_r+0x728>)
 8020854:	68b8      	ldr	r0, [r7, #8]
 8020856:	f003 fcca 	bl	80241ee <memcpy>
 802085a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 802085c:	68ba      	ldr	r2, [r7, #8]
 802085e:	4413      	add	r3, r2
 8020860:	2200      	movs	r2, #0
 8020862:	701a      	strb	r2, [r3, #0]
 8020864:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8020866:	68ba      	ldr	r2, [r7, #8]
 8020868:	4413      	add	r3, r2
 802086a:	60bb      	str	r3, [r7, #8]
 802086c:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 802086e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8020870:	4413      	add	r3, r2
 8020872:	64fb      	str	r3, [r7, #76]	@ 0x4c
            return written_total;
 8020874:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8020876:	e004      	b.n	8020882 <json_serialize_to_buffer_r+0x702>
        case JSONError:
            return -1;
 8020878:	f04f 33ff 	mov.w	r3, #4294967295
 802087c:	e001      	b.n	8020882 <json_serialize_to_buffer_r+0x702>
        default:
            return -1;
 802087e:	f04f 33ff 	mov.w	r3, #4294967295
    }
}
 8020882:	4618      	mov	r0, r3
 8020884:	3758      	adds	r7, #88	@ 0x58
 8020886:	46bd      	mov	sp, r7
 8020888:	bd80      	pop	{r7, pc}
 802088a:	bf00      	nop
 802088c:	0802a2f0 	.word	0x0802a2f0
 8020890:	0802a30c 	.word	0x0802a30c
 8020894:	0802a2d0 	.word	0x0802a2d0
 8020898:	0802a2d8 	.word	0x0802a2d8
 802089c:	20001e9c 	.word	0x20001e9c
 80208a0:	20001e98 	.word	0x20001e98
 80208a4:	0802a310 	.word	0x0802a310
 80208a8:	0802a2e0 	.word	0x0802a2e0

080208ac <json_serialize_string>:

static int json_serialize_string(const char *string, size_t len, char *buf) {
 80208ac:	b580      	push	{r7, lr}
 80208ae:	b088      	sub	sp, #32
 80208b0:	af00      	add	r7, sp, #0
 80208b2:	60f8      	str	r0, [r7, #12]
 80208b4:	60b9      	str	r1, [r7, #8]
 80208b6:	607a      	str	r2, [r7, #4]
    size_t i = 0;
 80208b8:	2300      	movs	r3, #0
 80208ba:	61fb      	str	r3, [r7, #28]
    char c = '\0';
 80208bc:	2300      	movs	r3, #0
 80208be:	75fb      	strb	r3, [r7, #23]
    int written = -1, written_total = 0;
 80208c0:	f04f 33ff 	mov.w	r3, #4294967295
 80208c4:	613b      	str	r3, [r7, #16]
 80208c6:	2300      	movs	r3, #0
 80208c8:	61bb      	str	r3, [r7, #24]
    APPEND_STRING("\"");
 80208ca:	2301      	movs	r3, #1
 80208cc:	613b      	str	r3, [r7, #16]
 80208ce:	687b      	ldr	r3, [r7, #4]
 80208d0:	2b00      	cmp	r3, #0
 80208d2:	d00e      	beq.n	80208f2 <json_serialize_string+0x46>
 80208d4:	693b      	ldr	r3, [r7, #16]
 80208d6:	461a      	mov	r2, r3
 80208d8:	49b8      	ldr	r1, [pc, #736]	@ (8020bbc <json_serialize_string+0x310>)
 80208da:	6878      	ldr	r0, [r7, #4]
 80208dc:	f003 fc87 	bl	80241ee <memcpy>
 80208e0:	693b      	ldr	r3, [r7, #16]
 80208e2:	687a      	ldr	r2, [r7, #4]
 80208e4:	4413      	add	r3, r2
 80208e6:	2200      	movs	r2, #0
 80208e8:	701a      	strb	r2, [r3, #0]
 80208ea:	693b      	ldr	r3, [r7, #16]
 80208ec:	687a      	ldr	r2, [r7, #4]
 80208ee:	4413      	add	r3, r2
 80208f0:	607b      	str	r3, [r7, #4]
 80208f2:	69ba      	ldr	r2, [r7, #24]
 80208f4:	693b      	ldr	r3, [r7, #16]
 80208f6:	4413      	add	r3, r2
 80208f8:	61bb      	str	r3, [r7, #24]
    for (i = 0; i < len; i++) {
 80208fa:	2300      	movs	r3, #0
 80208fc:	61fb      	str	r3, [r7, #28]
 80208fe:	f000 bc9d 	b.w	802123c <json_serialize_string+0x990>
        c = string[i];
 8020902:	68fa      	ldr	r2, [r7, #12]
 8020904:	69fb      	ldr	r3, [r7, #28]
 8020906:	4413      	add	r3, r2
 8020908:	781b      	ldrb	r3, [r3, #0]
 802090a:	75fb      	strb	r3, [r7, #23]
        switch (c) {
 802090c:	7dfb      	ldrb	r3, [r7, #23]
 802090e:	2b5c      	cmp	r3, #92	@ 0x5c
 8020910:	f200 8484 	bhi.w	802121c <json_serialize_string+0x970>
 8020914:	a201      	add	r2, pc, #4	@ (adr r2, 802091c <json_serialize_string+0x70>)
 8020916:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 802091a:	bf00      	nop
 802091c:	08020c0b 	.word	0x08020c0b
 8020920:	08020c3d 	.word	0x08020c3d
 8020924:	08020c6f 	.word	0x08020c6f
 8020928:	08020ca1 	.word	0x08020ca1
 802092c:	08020cd3 	.word	0x08020cd3
 8020930:	08020d05 	.word	0x08020d05
 8020934:	08020d37 	.word	0x08020d37
 8020938:	08020d69 	.word	0x08020d69
 802093c:	08020af5 	.word	0x08020af5
 8020940:	08020bd9 	.word	0x08020bd9
 8020944:	08020b59 	.word	0x08020b59
 8020948:	08020d9b 	.word	0x08020d9b
 802094c:	08020b27 	.word	0x08020b27
 8020950:	08020b8b 	.word	0x08020b8b
 8020954:	08020dcd 	.word	0x08020dcd
 8020958:	08020dff 	.word	0x08020dff
 802095c:	08020e61 	.word	0x08020e61
 8020960:	08020e93 	.word	0x08020e93
 8020964:	08020ec5 	.word	0x08020ec5
 8020968:	08020ef7 	.word	0x08020ef7
 802096c:	08020f29 	.word	0x08020f29
 8020970:	08020f5b 	.word	0x08020f5b
 8020974:	08020f8d 	.word	0x08020f8d
 8020978:	08020fbf 	.word	0x08020fbf
 802097c:	08020ff1 	.word	0x08020ff1
 8020980:	08021023 	.word	0x08021023
 8020984:	08021055 	.word	0x08021055
 8020988:	08021087 	.word	0x08021087
 802098c:	080210e9 	.word	0x080210e9
 8020990:	0802111b 	.word	0x0802111b
 8020994:	0802114d 	.word	0x0802114d
 8020998:	0802117f 	.word	0x0802117f
 802099c:	0802121d 	.word	0x0802121d
 80209a0:	0802121d 	.word	0x0802121d
 80209a4:	08020a91 	.word	0x08020a91
 80209a8:	0802121d 	.word	0x0802121d
 80209ac:	0802121d 	.word	0x0802121d
 80209b0:	0802121d 	.word	0x0802121d
 80209b4:	0802121d 	.word	0x0802121d
 80209b8:	0802121d 	.word	0x0802121d
 80209bc:	0802121d 	.word	0x0802121d
 80209c0:	0802121d 	.word	0x0802121d
 80209c4:	0802121d 	.word	0x0802121d
 80209c8:	0802121d 	.word	0x0802121d
 80209cc:	0802121d 	.word	0x0802121d
 80209d0:	0802121d 	.word	0x0802121d
 80209d4:	0802121d 	.word	0x0802121d
 80209d8:	080211b1 	.word	0x080211b1
 80209dc:	0802121d 	.word	0x0802121d
 80209e0:	0802121d 	.word	0x0802121d
 80209e4:	0802121d 	.word	0x0802121d
 80209e8:	0802121d 	.word	0x0802121d
 80209ec:	0802121d 	.word	0x0802121d
 80209f0:	0802121d 	.word	0x0802121d
 80209f4:	0802121d 	.word	0x0802121d
 80209f8:	0802121d 	.word	0x0802121d
 80209fc:	0802121d 	.word	0x0802121d
 8020a00:	0802121d 	.word	0x0802121d
 8020a04:	0802121d 	.word	0x0802121d
 8020a08:	0802121d 	.word	0x0802121d
 8020a0c:	0802121d 	.word	0x0802121d
 8020a10:	0802121d 	.word	0x0802121d
 8020a14:	0802121d 	.word	0x0802121d
 8020a18:	0802121d 	.word	0x0802121d
 8020a1c:	0802121d 	.word	0x0802121d
 8020a20:	0802121d 	.word	0x0802121d
 8020a24:	0802121d 	.word	0x0802121d
 8020a28:	0802121d 	.word	0x0802121d
 8020a2c:	0802121d 	.word	0x0802121d
 8020a30:	0802121d 	.word	0x0802121d
 8020a34:	0802121d 	.word	0x0802121d
 8020a38:	0802121d 	.word	0x0802121d
 8020a3c:	0802121d 	.word	0x0802121d
 8020a40:	0802121d 	.word	0x0802121d
 8020a44:	0802121d 	.word	0x0802121d
 8020a48:	0802121d 	.word	0x0802121d
 8020a4c:	0802121d 	.word	0x0802121d
 8020a50:	0802121d 	.word	0x0802121d
 8020a54:	0802121d 	.word	0x0802121d
 8020a58:	0802121d 	.word	0x0802121d
 8020a5c:	0802121d 	.word	0x0802121d
 8020a60:	0802121d 	.word	0x0802121d
 8020a64:	0802121d 	.word	0x0802121d
 8020a68:	0802121d 	.word	0x0802121d
 8020a6c:	0802121d 	.word	0x0802121d
 8020a70:	0802121d 	.word	0x0802121d
 8020a74:	0802121d 	.word	0x0802121d
 8020a78:	0802121d 	.word	0x0802121d
 8020a7c:	0802121d 	.word	0x0802121d
 8020a80:	0802121d 	.word	0x0802121d
 8020a84:	0802121d 	.word	0x0802121d
 8020a88:	0802121d 	.word	0x0802121d
 8020a8c:	08020ac3 	.word	0x08020ac3
            case '\"': APPEND_STRING("\\\""); break;
 8020a90:	2302      	movs	r3, #2
 8020a92:	613b      	str	r3, [r7, #16]
 8020a94:	687b      	ldr	r3, [r7, #4]
 8020a96:	2b00      	cmp	r3, #0
 8020a98:	d00e      	beq.n	8020ab8 <json_serialize_string+0x20c>
 8020a9a:	693b      	ldr	r3, [r7, #16]
 8020a9c:	461a      	mov	r2, r3
 8020a9e:	4948      	ldr	r1, [pc, #288]	@ (8020bc0 <json_serialize_string+0x314>)
 8020aa0:	6878      	ldr	r0, [r7, #4]
 8020aa2:	f003 fba4 	bl	80241ee <memcpy>
 8020aa6:	693b      	ldr	r3, [r7, #16]
 8020aa8:	687a      	ldr	r2, [r7, #4]
 8020aaa:	4413      	add	r3, r2
 8020aac:	2200      	movs	r2, #0
 8020aae:	701a      	strb	r2, [r3, #0]
 8020ab0:	693b      	ldr	r3, [r7, #16]
 8020ab2:	687a      	ldr	r2, [r7, #4]
 8020ab4:	4413      	add	r3, r2
 8020ab6:	607b      	str	r3, [r7, #4]
 8020ab8:	69ba      	ldr	r2, [r7, #24]
 8020aba:	693b      	ldr	r3, [r7, #16]
 8020abc:	4413      	add	r3, r2
 8020abe:	61bb      	str	r3, [r7, #24]
 8020ac0:	e3b9      	b.n	8021236 <json_serialize_string+0x98a>
            case '\\': APPEND_STRING("\\\\"); break;
 8020ac2:	2302      	movs	r3, #2
 8020ac4:	613b      	str	r3, [r7, #16]
 8020ac6:	687b      	ldr	r3, [r7, #4]
 8020ac8:	2b00      	cmp	r3, #0
 8020aca:	d00e      	beq.n	8020aea <json_serialize_string+0x23e>
 8020acc:	693b      	ldr	r3, [r7, #16]
 8020ace:	461a      	mov	r2, r3
 8020ad0:	493c      	ldr	r1, [pc, #240]	@ (8020bc4 <json_serialize_string+0x318>)
 8020ad2:	6878      	ldr	r0, [r7, #4]
 8020ad4:	f003 fb8b 	bl	80241ee <memcpy>
 8020ad8:	693b      	ldr	r3, [r7, #16]
 8020ada:	687a      	ldr	r2, [r7, #4]
 8020adc:	4413      	add	r3, r2
 8020ade:	2200      	movs	r2, #0
 8020ae0:	701a      	strb	r2, [r3, #0]
 8020ae2:	693b      	ldr	r3, [r7, #16]
 8020ae4:	687a      	ldr	r2, [r7, #4]
 8020ae6:	4413      	add	r3, r2
 8020ae8:	607b      	str	r3, [r7, #4]
 8020aea:	69ba      	ldr	r2, [r7, #24]
 8020aec:	693b      	ldr	r3, [r7, #16]
 8020aee:	4413      	add	r3, r2
 8020af0:	61bb      	str	r3, [r7, #24]
 8020af2:	e3a0      	b.n	8021236 <json_serialize_string+0x98a>
            case '\b': APPEND_STRING("\\b"); break;
 8020af4:	2302      	movs	r3, #2
 8020af6:	613b      	str	r3, [r7, #16]
 8020af8:	687b      	ldr	r3, [r7, #4]
 8020afa:	2b00      	cmp	r3, #0
 8020afc:	d00e      	beq.n	8020b1c <json_serialize_string+0x270>
 8020afe:	693b      	ldr	r3, [r7, #16]
 8020b00:	461a      	mov	r2, r3
 8020b02:	4931      	ldr	r1, [pc, #196]	@ (8020bc8 <json_serialize_string+0x31c>)
 8020b04:	6878      	ldr	r0, [r7, #4]
 8020b06:	f003 fb72 	bl	80241ee <memcpy>
 8020b0a:	693b      	ldr	r3, [r7, #16]
 8020b0c:	687a      	ldr	r2, [r7, #4]
 8020b0e:	4413      	add	r3, r2
 8020b10:	2200      	movs	r2, #0
 8020b12:	701a      	strb	r2, [r3, #0]
 8020b14:	693b      	ldr	r3, [r7, #16]
 8020b16:	687a      	ldr	r2, [r7, #4]
 8020b18:	4413      	add	r3, r2
 8020b1a:	607b      	str	r3, [r7, #4]
 8020b1c:	69ba      	ldr	r2, [r7, #24]
 8020b1e:	693b      	ldr	r3, [r7, #16]
 8020b20:	4413      	add	r3, r2
 8020b22:	61bb      	str	r3, [r7, #24]
 8020b24:	e387      	b.n	8021236 <json_serialize_string+0x98a>
            case '\f': APPEND_STRING("\\f"); break;
 8020b26:	2302      	movs	r3, #2
 8020b28:	613b      	str	r3, [r7, #16]
 8020b2a:	687b      	ldr	r3, [r7, #4]
 8020b2c:	2b00      	cmp	r3, #0
 8020b2e:	d00e      	beq.n	8020b4e <json_serialize_string+0x2a2>
 8020b30:	693b      	ldr	r3, [r7, #16]
 8020b32:	461a      	mov	r2, r3
 8020b34:	4925      	ldr	r1, [pc, #148]	@ (8020bcc <json_serialize_string+0x320>)
 8020b36:	6878      	ldr	r0, [r7, #4]
 8020b38:	f003 fb59 	bl	80241ee <memcpy>
 8020b3c:	693b      	ldr	r3, [r7, #16]
 8020b3e:	687a      	ldr	r2, [r7, #4]
 8020b40:	4413      	add	r3, r2
 8020b42:	2200      	movs	r2, #0
 8020b44:	701a      	strb	r2, [r3, #0]
 8020b46:	693b      	ldr	r3, [r7, #16]
 8020b48:	687a      	ldr	r2, [r7, #4]
 8020b4a:	4413      	add	r3, r2
 8020b4c:	607b      	str	r3, [r7, #4]
 8020b4e:	69ba      	ldr	r2, [r7, #24]
 8020b50:	693b      	ldr	r3, [r7, #16]
 8020b52:	4413      	add	r3, r2
 8020b54:	61bb      	str	r3, [r7, #24]
 8020b56:	e36e      	b.n	8021236 <json_serialize_string+0x98a>
            case '\n': APPEND_STRING("\\n"); break;
 8020b58:	2302      	movs	r3, #2
 8020b5a:	613b      	str	r3, [r7, #16]
 8020b5c:	687b      	ldr	r3, [r7, #4]
 8020b5e:	2b00      	cmp	r3, #0
 8020b60:	d00e      	beq.n	8020b80 <json_serialize_string+0x2d4>
 8020b62:	693b      	ldr	r3, [r7, #16]
 8020b64:	461a      	mov	r2, r3
 8020b66:	491a      	ldr	r1, [pc, #104]	@ (8020bd0 <json_serialize_string+0x324>)
 8020b68:	6878      	ldr	r0, [r7, #4]
 8020b6a:	f003 fb40 	bl	80241ee <memcpy>
 8020b6e:	693b      	ldr	r3, [r7, #16]
 8020b70:	687a      	ldr	r2, [r7, #4]
 8020b72:	4413      	add	r3, r2
 8020b74:	2200      	movs	r2, #0
 8020b76:	701a      	strb	r2, [r3, #0]
 8020b78:	693b      	ldr	r3, [r7, #16]
 8020b7a:	687a      	ldr	r2, [r7, #4]
 8020b7c:	4413      	add	r3, r2
 8020b7e:	607b      	str	r3, [r7, #4]
 8020b80:	69ba      	ldr	r2, [r7, #24]
 8020b82:	693b      	ldr	r3, [r7, #16]
 8020b84:	4413      	add	r3, r2
 8020b86:	61bb      	str	r3, [r7, #24]
 8020b88:	e355      	b.n	8021236 <json_serialize_string+0x98a>
            case '\r': APPEND_STRING("\\r"); break;
 8020b8a:	2302      	movs	r3, #2
 8020b8c:	613b      	str	r3, [r7, #16]
 8020b8e:	687b      	ldr	r3, [r7, #4]
 8020b90:	2b00      	cmp	r3, #0
 8020b92:	d00e      	beq.n	8020bb2 <json_serialize_string+0x306>
 8020b94:	693b      	ldr	r3, [r7, #16]
 8020b96:	461a      	mov	r2, r3
 8020b98:	490e      	ldr	r1, [pc, #56]	@ (8020bd4 <json_serialize_string+0x328>)
 8020b9a:	6878      	ldr	r0, [r7, #4]
 8020b9c:	f003 fb27 	bl	80241ee <memcpy>
 8020ba0:	693b      	ldr	r3, [r7, #16]
 8020ba2:	687a      	ldr	r2, [r7, #4]
 8020ba4:	4413      	add	r3, r2
 8020ba6:	2200      	movs	r2, #0
 8020ba8:	701a      	strb	r2, [r3, #0]
 8020baa:	693b      	ldr	r3, [r7, #16]
 8020bac:	687a      	ldr	r2, [r7, #4]
 8020bae:	4413      	add	r3, r2
 8020bb0:	607b      	str	r3, [r7, #4]
 8020bb2:	69ba      	ldr	r2, [r7, #24]
 8020bb4:	693b      	ldr	r3, [r7, #16]
 8020bb6:	4413      	add	r3, r2
 8020bb8:	61bb      	str	r3, [r7, #24]
 8020bba:	e33c      	b.n	8021236 <json_serialize_string+0x98a>
 8020bbc:	0802a318 	.word	0x0802a318
 8020bc0:	0802a31c 	.word	0x0802a31c
 8020bc4:	0802a320 	.word	0x0802a320
 8020bc8:	0802a324 	.word	0x0802a324
 8020bcc:	0802a328 	.word	0x0802a328
 8020bd0:	0802a32c 	.word	0x0802a32c
 8020bd4:	0802a330 	.word	0x0802a330
            case '\t': APPEND_STRING("\\t"); break;
 8020bd8:	2302      	movs	r3, #2
 8020bda:	613b      	str	r3, [r7, #16]
 8020bdc:	687b      	ldr	r3, [r7, #4]
 8020bde:	2b00      	cmp	r3, #0
 8020be0:	d00e      	beq.n	8020c00 <json_serialize_string+0x354>
 8020be2:	693b      	ldr	r3, [r7, #16]
 8020be4:	461a      	mov	r2, r3
 8020be6:	4992      	ldr	r1, [pc, #584]	@ (8020e30 <json_serialize_string+0x584>)
 8020be8:	6878      	ldr	r0, [r7, #4]
 8020bea:	f003 fb00 	bl	80241ee <memcpy>
 8020bee:	693b      	ldr	r3, [r7, #16]
 8020bf0:	687a      	ldr	r2, [r7, #4]
 8020bf2:	4413      	add	r3, r2
 8020bf4:	2200      	movs	r2, #0
 8020bf6:	701a      	strb	r2, [r3, #0]
 8020bf8:	693b      	ldr	r3, [r7, #16]
 8020bfa:	687a      	ldr	r2, [r7, #4]
 8020bfc:	4413      	add	r3, r2
 8020bfe:	607b      	str	r3, [r7, #4]
 8020c00:	69ba      	ldr	r2, [r7, #24]
 8020c02:	693b      	ldr	r3, [r7, #16]
 8020c04:	4413      	add	r3, r2
 8020c06:	61bb      	str	r3, [r7, #24]
 8020c08:	e315      	b.n	8021236 <json_serialize_string+0x98a>
            case '\x00': APPEND_STRING("\\u0000"); break;
 8020c0a:	2306      	movs	r3, #6
 8020c0c:	613b      	str	r3, [r7, #16]
 8020c0e:	687b      	ldr	r3, [r7, #4]
 8020c10:	2b00      	cmp	r3, #0
 8020c12:	d00e      	beq.n	8020c32 <json_serialize_string+0x386>
 8020c14:	693b      	ldr	r3, [r7, #16]
 8020c16:	461a      	mov	r2, r3
 8020c18:	4986      	ldr	r1, [pc, #536]	@ (8020e34 <json_serialize_string+0x588>)
 8020c1a:	6878      	ldr	r0, [r7, #4]
 8020c1c:	f003 fae7 	bl	80241ee <memcpy>
 8020c20:	693b      	ldr	r3, [r7, #16]
 8020c22:	687a      	ldr	r2, [r7, #4]
 8020c24:	4413      	add	r3, r2
 8020c26:	2200      	movs	r2, #0
 8020c28:	701a      	strb	r2, [r3, #0]
 8020c2a:	693b      	ldr	r3, [r7, #16]
 8020c2c:	687a      	ldr	r2, [r7, #4]
 8020c2e:	4413      	add	r3, r2
 8020c30:	607b      	str	r3, [r7, #4]
 8020c32:	69ba      	ldr	r2, [r7, #24]
 8020c34:	693b      	ldr	r3, [r7, #16]
 8020c36:	4413      	add	r3, r2
 8020c38:	61bb      	str	r3, [r7, #24]
 8020c3a:	e2fc      	b.n	8021236 <json_serialize_string+0x98a>
            case '\x01': APPEND_STRING("\\u0001"); break;
 8020c3c:	2306      	movs	r3, #6
 8020c3e:	613b      	str	r3, [r7, #16]
 8020c40:	687b      	ldr	r3, [r7, #4]
 8020c42:	2b00      	cmp	r3, #0
 8020c44:	d00e      	beq.n	8020c64 <json_serialize_string+0x3b8>
 8020c46:	693b      	ldr	r3, [r7, #16]
 8020c48:	461a      	mov	r2, r3
 8020c4a:	497b      	ldr	r1, [pc, #492]	@ (8020e38 <json_serialize_string+0x58c>)
 8020c4c:	6878      	ldr	r0, [r7, #4]
 8020c4e:	f003 face 	bl	80241ee <memcpy>
 8020c52:	693b      	ldr	r3, [r7, #16]
 8020c54:	687a      	ldr	r2, [r7, #4]
 8020c56:	4413      	add	r3, r2
 8020c58:	2200      	movs	r2, #0
 8020c5a:	701a      	strb	r2, [r3, #0]
 8020c5c:	693b      	ldr	r3, [r7, #16]
 8020c5e:	687a      	ldr	r2, [r7, #4]
 8020c60:	4413      	add	r3, r2
 8020c62:	607b      	str	r3, [r7, #4]
 8020c64:	69ba      	ldr	r2, [r7, #24]
 8020c66:	693b      	ldr	r3, [r7, #16]
 8020c68:	4413      	add	r3, r2
 8020c6a:	61bb      	str	r3, [r7, #24]
 8020c6c:	e2e3      	b.n	8021236 <json_serialize_string+0x98a>
            case '\x02': APPEND_STRING("\\u0002"); break;
 8020c6e:	2306      	movs	r3, #6
 8020c70:	613b      	str	r3, [r7, #16]
 8020c72:	687b      	ldr	r3, [r7, #4]
 8020c74:	2b00      	cmp	r3, #0
 8020c76:	d00e      	beq.n	8020c96 <json_serialize_string+0x3ea>
 8020c78:	693b      	ldr	r3, [r7, #16]
 8020c7a:	461a      	mov	r2, r3
 8020c7c:	496f      	ldr	r1, [pc, #444]	@ (8020e3c <json_serialize_string+0x590>)
 8020c7e:	6878      	ldr	r0, [r7, #4]
 8020c80:	f003 fab5 	bl	80241ee <memcpy>
 8020c84:	693b      	ldr	r3, [r7, #16]
 8020c86:	687a      	ldr	r2, [r7, #4]
 8020c88:	4413      	add	r3, r2
 8020c8a:	2200      	movs	r2, #0
 8020c8c:	701a      	strb	r2, [r3, #0]
 8020c8e:	693b      	ldr	r3, [r7, #16]
 8020c90:	687a      	ldr	r2, [r7, #4]
 8020c92:	4413      	add	r3, r2
 8020c94:	607b      	str	r3, [r7, #4]
 8020c96:	69ba      	ldr	r2, [r7, #24]
 8020c98:	693b      	ldr	r3, [r7, #16]
 8020c9a:	4413      	add	r3, r2
 8020c9c:	61bb      	str	r3, [r7, #24]
 8020c9e:	e2ca      	b.n	8021236 <json_serialize_string+0x98a>
            case '\x03': APPEND_STRING("\\u0003"); break;
 8020ca0:	2306      	movs	r3, #6
 8020ca2:	613b      	str	r3, [r7, #16]
 8020ca4:	687b      	ldr	r3, [r7, #4]
 8020ca6:	2b00      	cmp	r3, #0
 8020ca8:	d00e      	beq.n	8020cc8 <json_serialize_string+0x41c>
 8020caa:	693b      	ldr	r3, [r7, #16]
 8020cac:	461a      	mov	r2, r3
 8020cae:	4964      	ldr	r1, [pc, #400]	@ (8020e40 <json_serialize_string+0x594>)
 8020cb0:	6878      	ldr	r0, [r7, #4]
 8020cb2:	f003 fa9c 	bl	80241ee <memcpy>
 8020cb6:	693b      	ldr	r3, [r7, #16]
 8020cb8:	687a      	ldr	r2, [r7, #4]
 8020cba:	4413      	add	r3, r2
 8020cbc:	2200      	movs	r2, #0
 8020cbe:	701a      	strb	r2, [r3, #0]
 8020cc0:	693b      	ldr	r3, [r7, #16]
 8020cc2:	687a      	ldr	r2, [r7, #4]
 8020cc4:	4413      	add	r3, r2
 8020cc6:	607b      	str	r3, [r7, #4]
 8020cc8:	69ba      	ldr	r2, [r7, #24]
 8020cca:	693b      	ldr	r3, [r7, #16]
 8020ccc:	4413      	add	r3, r2
 8020cce:	61bb      	str	r3, [r7, #24]
 8020cd0:	e2b1      	b.n	8021236 <json_serialize_string+0x98a>
            case '\x04': APPEND_STRING("\\u0004"); break;
 8020cd2:	2306      	movs	r3, #6
 8020cd4:	613b      	str	r3, [r7, #16]
 8020cd6:	687b      	ldr	r3, [r7, #4]
 8020cd8:	2b00      	cmp	r3, #0
 8020cda:	d00e      	beq.n	8020cfa <json_serialize_string+0x44e>
 8020cdc:	693b      	ldr	r3, [r7, #16]
 8020cde:	461a      	mov	r2, r3
 8020ce0:	4958      	ldr	r1, [pc, #352]	@ (8020e44 <json_serialize_string+0x598>)
 8020ce2:	6878      	ldr	r0, [r7, #4]
 8020ce4:	f003 fa83 	bl	80241ee <memcpy>
 8020ce8:	693b      	ldr	r3, [r7, #16]
 8020cea:	687a      	ldr	r2, [r7, #4]
 8020cec:	4413      	add	r3, r2
 8020cee:	2200      	movs	r2, #0
 8020cf0:	701a      	strb	r2, [r3, #0]
 8020cf2:	693b      	ldr	r3, [r7, #16]
 8020cf4:	687a      	ldr	r2, [r7, #4]
 8020cf6:	4413      	add	r3, r2
 8020cf8:	607b      	str	r3, [r7, #4]
 8020cfa:	69ba      	ldr	r2, [r7, #24]
 8020cfc:	693b      	ldr	r3, [r7, #16]
 8020cfe:	4413      	add	r3, r2
 8020d00:	61bb      	str	r3, [r7, #24]
 8020d02:	e298      	b.n	8021236 <json_serialize_string+0x98a>
            case '\x05': APPEND_STRING("\\u0005"); break;
 8020d04:	2306      	movs	r3, #6
 8020d06:	613b      	str	r3, [r7, #16]
 8020d08:	687b      	ldr	r3, [r7, #4]
 8020d0a:	2b00      	cmp	r3, #0
 8020d0c:	d00e      	beq.n	8020d2c <json_serialize_string+0x480>
 8020d0e:	693b      	ldr	r3, [r7, #16]
 8020d10:	461a      	mov	r2, r3
 8020d12:	494d      	ldr	r1, [pc, #308]	@ (8020e48 <json_serialize_string+0x59c>)
 8020d14:	6878      	ldr	r0, [r7, #4]
 8020d16:	f003 fa6a 	bl	80241ee <memcpy>
 8020d1a:	693b      	ldr	r3, [r7, #16]
 8020d1c:	687a      	ldr	r2, [r7, #4]
 8020d1e:	4413      	add	r3, r2
 8020d20:	2200      	movs	r2, #0
 8020d22:	701a      	strb	r2, [r3, #0]
 8020d24:	693b      	ldr	r3, [r7, #16]
 8020d26:	687a      	ldr	r2, [r7, #4]
 8020d28:	4413      	add	r3, r2
 8020d2a:	607b      	str	r3, [r7, #4]
 8020d2c:	69ba      	ldr	r2, [r7, #24]
 8020d2e:	693b      	ldr	r3, [r7, #16]
 8020d30:	4413      	add	r3, r2
 8020d32:	61bb      	str	r3, [r7, #24]
 8020d34:	e27f      	b.n	8021236 <json_serialize_string+0x98a>
            case '\x06': APPEND_STRING("\\u0006"); break;
 8020d36:	2306      	movs	r3, #6
 8020d38:	613b      	str	r3, [r7, #16]
 8020d3a:	687b      	ldr	r3, [r7, #4]
 8020d3c:	2b00      	cmp	r3, #0
 8020d3e:	d00e      	beq.n	8020d5e <json_serialize_string+0x4b2>
 8020d40:	693b      	ldr	r3, [r7, #16]
 8020d42:	461a      	mov	r2, r3
 8020d44:	4941      	ldr	r1, [pc, #260]	@ (8020e4c <json_serialize_string+0x5a0>)
 8020d46:	6878      	ldr	r0, [r7, #4]
 8020d48:	f003 fa51 	bl	80241ee <memcpy>
 8020d4c:	693b      	ldr	r3, [r7, #16]
 8020d4e:	687a      	ldr	r2, [r7, #4]
 8020d50:	4413      	add	r3, r2
 8020d52:	2200      	movs	r2, #0
 8020d54:	701a      	strb	r2, [r3, #0]
 8020d56:	693b      	ldr	r3, [r7, #16]
 8020d58:	687a      	ldr	r2, [r7, #4]
 8020d5a:	4413      	add	r3, r2
 8020d5c:	607b      	str	r3, [r7, #4]
 8020d5e:	69ba      	ldr	r2, [r7, #24]
 8020d60:	693b      	ldr	r3, [r7, #16]
 8020d62:	4413      	add	r3, r2
 8020d64:	61bb      	str	r3, [r7, #24]
 8020d66:	e266      	b.n	8021236 <json_serialize_string+0x98a>
            case '\x07': APPEND_STRING("\\u0007"); break;
 8020d68:	2306      	movs	r3, #6
 8020d6a:	613b      	str	r3, [r7, #16]
 8020d6c:	687b      	ldr	r3, [r7, #4]
 8020d6e:	2b00      	cmp	r3, #0
 8020d70:	d00e      	beq.n	8020d90 <json_serialize_string+0x4e4>
 8020d72:	693b      	ldr	r3, [r7, #16]
 8020d74:	461a      	mov	r2, r3
 8020d76:	4936      	ldr	r1, [pc, #216]	@ (8020e50 <json_serialize_string+0x5a4>)
 8020d78:	6878      	ldr	r0, [r7, #4]
 8020d7a:	f003 fa38 	bl	80241ee <memcpy>
 8020d7e:	693b      	ldr	r3, [r7, #16]
 8020d80:	687a      	ldr	r2, [r7, #4]
 8020d82:	4413      	add	r3, r2
 8020d84:	2200      	movs	r2, #0
 8020d86:	701a      	strb	r2, [r3, #0]
 8020d88:	693b      	ldr	r3, [r7, #16]
 8020d8a:	687a      	ldr	r2, [r7, #4]
 8020d8c:	4413      	add	r3, r2
 8020d8e:	607b      	str	r3, [r7, #4]
 8020d90:	69ba      	ldr	r2, [r7, #24]
 8020d92:	693b      	ldr	r3, [r7, #16]
 8020d94:	4413      	add	r3, r2
 8020d96:	61bb      	str	r3, [r7, #24]
 8020d98:	e24d      	b.n	8021236 <json_serialize_string+0x98a>
            /* '\x08' duplicate: '\b' */
            /* '\x09' duplicate: '\t' */
            /* '\x0a' duplicate: '\n' */
            case '\x0b': APPEND_STRING("\\u000b"); break;
 8020d9a:	2306      	movs	r3, #6
 8020d9c:	613b      	str	r3, [r7, #16]
 8020d9e:	687b      	ldr	r3, [r7, #4]
 8020da0:	2b00      	cmp	r3, #0
 8020da2:	d00e      	beq.n	8020dc2 <json_serialize_string+0x516>
 8020da4:	693b      	ldr	r3, [r7, #16]
 8020da6:	461a      	mov	r2, r3
 8020da8:	492a      	ldr	r1, [pc, #168]	@ (8020e54 <json_serialize_string+0x5a8>)
 8020daa:	6878      	ldr	r0, [r7, #4]
 8020dac:	f003 fa1f 	bl	80241ee <memcpy>
 8020db0:	693b      	ldr	r3, [r7, #16]
 8020db2:	687a      	ldr	r2, [r7, #4]
 8020db4:	4413      	add	r3, r2
 8020db6:	2200      	movs	r2, #0
 8020db8:	701a      	strb	r2, [r3, #0]
 8020dba:	693b      	ldr	r3, [r7, #16]
 8020dbc:	687a      	ldr	r2, [r7, #4]
 8020dbe:	4413      	add	r3, r2
 8020dc0:	607b      	str	r3, [r7, #4]
 8020dc2:	69ba      	ldr	r2, [r7, #24]
 8020dc4:	693b      	ldr	r3, [r7, #16]
 8020dc6:	4413      	add	r3, r2
 8020dc8:	61bb      	str	r3, [r7, #24]
 8020dca:	e234      	b.n	8021236 <json_serialize_string+0x98a>
            /* '\x0c' duplicate: '\f' */
            /* '\x0d' duplicate: '\r' */
            case '\x0e': APPEND_STRING("\\u000e"); break;
 8020dcc:	2306      	movs	r3, #6
 8020dce:	613b      	str	r3, [r7, #16]
 8020dd0:	687b      	ldr	r3, [r7, #4]
 8020dd2:	2b00      	cmp	r3, #0
 8020dd4:	d00e      	beq.n	8020df4 <json_serialize_string+0x548>
 8020dd6:	693b      	ldr	r3, [r7, #16]
 8020dd8:	461a      	mov	r2, r3
 8020dda:	491f      	ldr	r1, [pc, #124]	@ (8020e58 <json_serialize_string+0x5ac>)
 8020ddc:	6878      	ldr	r0, [r7, #4]
 8020dde:	f003 fa06 	bl	80241ee <memcpy>
 8020de2:	693b      	ldr	r3, [r7, #16]
 8020de4:	687a      	ldr	r2, [r7, #4]
 8020de6:	4413      	add	r3, r2
 8020de8:	2200      	movs	r2, #0
 8020dea:	701a      	strb	r2, [r3, #0]
 8020dec:	693b      	ldr	r3, [r7, #16]
 8020dee:	687a      	ldr	r2, [r7, #4]
 8020df0:	4413      	add	r3, r2
 8020df2:	607b      	str	r3, [r7, #4]
 8020df4:	69ba      	ldr	r2, [r7, #24]
 8020df6:	693b      	ldr	r3, [r7, #16]
 8020df8:	4413      	add	r3, r2
 8020dfa:	61bb      	str	r3, [r7, #24]
 8020dfc:	e21b      	b.n	8021236 <json_serialize_string+0x98a>
            case '\x0f': APPEND_STRING("\\u000f"); break;
 8020dfe:	2306      	movs	r3, #6
 8020e00:	613b      	str	r3, [r7, #16]
 8020e02:	687b      	ldr	r3, [r7, #4]
 8020e04:	2b00      	cmp	r3, #0
 8020e06:	d00e      	beq.n	8020e26 <json_serialize_string+0x57a>
 8020e08:	693b      	ldr	r3, [r7, #16]
 8020e0a:	461a      	mov	r2, r3
 8020e0c:	4913      	ldr	r1, [pc, #76]	@ (8020e5c <json_serialize_string+0x5b0>)
 8020e0e:	6878      	ldr	r0, [r7, #4]
 8020e10:	f003 f9ed 	bl	80241ee <memcpy>
 8020e14:	693b      	ldr	r3, [r7, #16]
 8020e16:	687a      	ldr	r2, [r7, #4]
 8020e18:	4413      	add	r3, r2
 8020e1a:	2200      	movs	r2, #0
 8020e1c:	701a      	strb	r2, [r3, #0]
 8020e1e:	693b      	ldr	r3, [r7, #16]
 8020e20:	687a      	ldr	r2, [r7, #4]
 8020e22:	4413      	add	r3, r2
 8020e24:	607b      	str	r3, [r7, #4]
 8020e26:	69ba      	ldr	r2, [r7, #24]
 8020e28:	693b      	ldr	r3, [r7, #16]
 8020e2a:	4413      	add	r3, r2
 8020e2c:	61bb      	str	r3, [r7, #24]
 8020e2e:	e202      	b.n	8021236 <json_serialize_string+0x98a>
 8020e30:	0802a334 	.word	0x0802a334
 8020e34:	0802a338 	.word	0x0802a338
 8020e38:	0802a340 	.word	0x0802a340
 8020e3c:	0802a348 	.word	0x0802a348
 8020e40:	0802a350 	.word	0x0802a350
 8020e44:	0802a358 	.word	0x0802a358
 8020e48:	0802a360 	.word	0x0802a360
 8020e4c:	0802a368 	.word	0x0802a368
 8020e50:	0802a370 	.word	0x0802a370
 8020e54:	0802a378 	.word	0x0802a378
 8020e58:	0802a380 	.word	0x0802a380
 8020e5c:	0802a388 	.word	0x0802a388
            case '\x10': APPEND_STRING("\\u0010"); break;
 8020e60:	2306      	movs	r3, #6
 8020e62:	613b      	str	r3, [r7, #16]
 8020e64:	687b      	ldr	r3, [r7, #4]
 8020e66:	2b00      	cmp	r3, #0
 8020e68:	d00e      	beq.n	8020e88 <json_serialize_string+0x5dc>
 8020e6a:	693b      	ldr	r3, [r7, #16]
 8020e6c:	461a      	mov	r2, r3
 8020e6e:	4992      	ldr	r1, [pc, #584]	@ (80210b8 <json_serialize_string+0x80c>)
 8020e70:	6878      	ldr	r0, [r7, #4]
 8020e72:	f003 f9bc 	bl	80241ee <memcpy>
 8020e76:	693b      	ldr	r3, [r7, #16]
 8020e78:	687a      	ldr	r2, [r7, #4]
 8020e7a:	4413      	add	r3, r2
 8020e7c:	2200      	movs	r2, #0
 8020e7e:	701a      	strb	r2, [r3, #0]
 8020e80:	693b      	ldr	r3, [r7, #16]
 8020e82:	687a      	ldr	r2, [r7, #4]
 8020e84:	4413      	add	r3, r2
 8020e86:	607b      	str	r3, [r7, #4]
 8020e88:	69ba      	ldr	r2, [r7, #24]
 8020e8a:	693b      	ldr	r3, [r7, #16]
 8020e8c:	4413      	add	r3, r2
 8020e8e:	61bb      	str	r3, [r7, #24]
 8020e90:	e1d1      	b.n	8021236 <json_serialize_string+0x98a>
            case '\x11': APPEND_STRING("\\u0011"); break;
 8020e92:	2306      	movs	r3, #6
 8020e94:	613b      	str	r3, [r7, #16]
 8020e96:	687b      	ldr	r3, [r7, #4]
 8020e98:	2b00      	cmp	r3, #0
 8020e9a:	d00e      	beq.n	8020eba <json_serialize_string+0x60e>
 8020e9c:	693b      	ldr	r3, [r7, #16]
 8020e9e:	461a      	mov	r2, r3
 8020ea0:	4986      	ldr	r1, [pc, #536]	@ (80210bc <json_serialize_string+0x810>)
 8020ea2:	6878      	ldr	r0, [r7, #4]
 8020ea4:	f003 f9a3 	bl	80241ee <memcpy>
 8020ea8:	693b      	ldr	r3, [r7, #16]
 8020eaa:	687a      	ldr	r2, [r7, #4]
 8020eac:	4413      	add	r3, r2
 8020eae:	2200      	movs	r2, #0
 8020eb0:	701a      	strb	r2, [r3, #0]
 8020eb2:	693b      	ldr	r3, [r7, #16]
 8020eb4:	687a      	ldr	r2, [r7, #4]
 8020eb6:	4413      	add	r3, r2
 8020eb8:	607b      	str	r3, [r7, #4]
 8020eba:	69ba      	ldr	r2, [r7, #24]
 8020ebc:	693b      	ldr	r3, [r7, #16]
 8020ebe:	4413      	add	r3, r2
 8020ec0:	61bb      	str	r3, [r7, #24]
 8020ec2:	e1b8      	b.n	8021236 <json_serialize_string+0x98a>
            case '\x12': APPEND_STRING("\\u0012"); break;
 8020ec4:	2306      	movs	r3, #6
 8020ec6:	613b      	str	r3, [r7, #16]
 8020ec8:	687b      	ldr	r3, [r7, #4]
 8020eca:	2b00      	cmp	r3, #0
 8020ecc:	d00e      	beq.n	8020eec <json_serialize_string+0x640>
 8020ece:	693b      	ldr	r3, [r7, #16]
 8020ed0:	461a      	mov	r2, r3
 8020ed2:	497b      	ldr	r1, [pc, #492]	@ (80210c0 <json_serialize_string+0x814>)
 8020ed4:	6878      	ldr	r0, [r7, #4]
 8020ed6:	f003 f98a 	bl	80241ee <memcpy>
 8020eda:	693b      	ldr	r3, [r7, #16]
 8020edc:	687a      	ldr	r2, [r7, #4]
 8020ede:	4413      	add	r3, r2
 8020ee0:	2200      	movs	r2, #0
 8020ee2:	701a      	strb	r2, [r3, #0]
 8020ee4:	693b      	ldr	r3, [r7, #16]
 8020ee6:	687a      	ldr	r2, [r7, #4]
 8020ee8:	4413      	add	r3, r2
 8020eea:	607b      	str	r3, [r7, #4]
 8020eec:	69ba      	ldr	r2, [r7, #24]
 8020eee:	693b      	ldr	r3, [r7, #16]
 8020ef0:	4413      	add	r3, r2
 8020ef2:	61bb      	str	r3, [r7, #24]
 8020ef4:	e19f      	b.n	8021236 <json_serialize_string+0x98a>
            case '\x13': APPEND_STRING("\\u0013"); break;
 8020ef6:	2306      	movs	r3, #6
 8020ef8:	613b      	str	r3, [r7, #16]
 8020efa:	687b      	ldr	r3, [r7, #4]
 8020efc:	2b00      	cmp	r3, #0
 8020efe:	d00e      	beq.n	8020f1e <json_serialize_string+0x672>
 8020f00:	693b      	ldr	r3, [r7, #16]
 8020f02:	461a      	mov	r2, r3
 8020f04:	496f      	ldr	r1, [pc, #444]	@ (80210c4 <json_serialize_string+0x818>)
 8020f06:	6878      	ldr	r0, [r7, #4]
 8020f08:	f003 f971 	bl	80241ee <memcpy>
 8020f0c:	693b      	ldr	r3, [r7, #16]
 8020f0e:	687a      	ldr	r2, [r7, #4]
 8020f10:	4413      	add	r3, r2
 8020f12:	2200      	movs	r2, #0
 8020f14:	701a      	strb	r2, [r3, #0]
 8020f16:	693b      	ldr	r3, [r7, #16]
 8020f18:	687a      	ldr	r2, [r7, #4]
 8020f1a:	4413      	add	r3, r2
 8020f1c:	607b      	str	r3, [r7, #4]
 8020f1e:	69ba      	ldr	r2, [r7, #24]
 8020f20:	693b      	ldr	r3, [r7, #16]
 8020f22:	4413      	add	r3, r2
 8020f24:	61bb      	str	r3, [r7, #24]
 8020f26:	e186      	b.n	8021236 <json_serialize_string+0x98a>
            case '\x14': APPEND_STRING("\\u0014"); break;
 8020f28:	2306      	movs	r3, #6
 8020f2a:	613b      	str	r3, [r7, #16]
 8020f2c:	687b      	ldr	r3, [r7, #4]
 8020f2e:	2b00      	cmp	r3, #0
 8020f30:	d00e      	beq.n	8020f50 <json_serialize_string+0x6a4>
 8020f32:	693b      	ldr	r3, [r7, #16]
 8020f34:	461a      	mov	r2, r3
 8020f36:	4964      	ldr	r1, [pc, #400]	@ (80210c8 <json_serialize_string+0x81c>)
 8020f38:	6878      	ldr	r0, [r7, #4]
 8020f3a:	f003 f958 	bl	80241ee <memcpy>
 8020f3e:	693b      	ldr	r3, [r7, #16]
 8020f40:	687a      	ldr	r2, [r7, #4]
 8020f42:	4413      	add	r3, r2
 8020f44:	2200      	movs	r2, #0
 8020f46:	701a      	strb	r2, [r3, #0]
 8020f48:	693b      	ldr	r3, [r7, #16]
 8020f4a:	687a      	ldr	r2, [r7, #4]
 8020f4c:	4413      	add	r3, r2
 8020f4e:	607b      	str	r3, [r7, #4]
 8020f50:	69ba      	ldr	r2, [r7, #24]
 8020f52:	693b      	ldr	r3, [r7, #16]
 8020f54:	4413      	add	r3, r2
 8020f56:	61bb      	str	r3, [r7, #24]
 8020f58:	e16d      	b.n	8021236 <json_serialize_string+0x98a>
            case '\x15': APPEND_STRING("\\u0015"); break;
 8020f5a:	2306      	movs	r3, #6
 8020f5c:	613b      	str	r3, [r7, #16]
 8020f5e:	687b      	ldr	r3, [r7, #4]
 8020f60:	2b00      	cmp	r3, #0
 8020f62:	d00e      	beq.n	8020f82 <json_serialize_string+0x6d6>
 8020f64:	693b      	ldr	r3, [r7, #16]
 8020f66:	461a      	mov	r2, r3
 8020f68:	4958      	ldr	r1, [pc, #352]	@ (80210cc <json_serialize_string+0x820>)
 8020f6a:	6878      	ldr	r0, [r7, #4]
 8020f6c:	f003 f93f 	bl	80241ee <memcpy>
 8020f70:	693b      	ldr	r3, [r7, #16]
 8020f72:	687a      	ldr	r2, [r7, #4]
 8020f74:	4413      	add	r3, r2
 8020f76:	2200      	movs	r2, #0
 8020f78:	701a      	strb	r2, [r3, #0]
 8020f7a:	693b      	ldr	r3, [r7, #16]
 8020f7c:	687a      	ldr	r2, [r7, #4]
 8020f7e:	4413      	add	r3, r2
 8020f80:	607b      	str	r3, [r7, #4]
 8020f82:	69ba      	ldr	r2, [r7, #24]
 8020f84:	693b      	ldr	r3, [r7, #16]
 8020f86:	4413      	add	r3, r2
 8020f88:	61bb      	str	r3, [r7, #24]
 8020f8a:	e154      	b.n	8021236 <json_serialize_string+0x98a>
            case '\x16': APPEND_STRING("\\u0016"); break;
 8020f8c:	2306      	movs	r3, #6
 8020f8e:	613b      	str	r3, [r7, #16]
 8020f90:	687b      	ldr	r3, [r7, #4]
 8020f92:	2b00      	cmp	r3, #0
 8020f94:	d00e      	beq.n	8020fb4 <json_serialize_string+0x708>
 8020f96:	693b      	ldr	r3, [r7, #16]
 8020f98:	461a      	mov	r2, r3
 8020f9a:	494d      	ldr	r1, [pc, #308]	@ (80210d0 <json_serialize_string+0x824>)
 8020f9c:	6878      	ldr	r0, [r7, #4]
 8020f9e:	f003 f926 	bl	80241ee <memcpy>
 8020fa2:	693b      	ldr	r3, [r7, #16]
 8020fa4:	687a      	ldr	r2, [r7, #4]
 8020fa6:	4413      	add	r3, r2
 8020fa8:	2200      	movs	r2, #0
 8020faa:	701a      	strb	r2, [r3, #0]
 8020fac:	693b      	ldr	r3, [r7, #16]
 8020fae:	687a      	ldr	r2, [r7, #4]
 8020fb0:	4413      	add	r3, r2
 8020fb2:	607b      	str	r3, [r7, #4]
 8020fb4:	69ba      	ldr	r2, [r7, #24]
 8020fb6:	693b      	ldr	r3, [r7, #16]
 8020fb8:	4413      	add	r3, r2
 8020fba:	61bb      	str	r3, [r7, #24]
 8020fbc:	e13b      	b.n	8021236 <json_serialize_string+0x98a>
            case '\x17': APPEND_STRING("\\u0017"); break;
 8020fbe:	2306      	movs	r3, #6
 8020fc0:	613b      	str	r3, [r7, #16]
 8020fc2:	687b      	ldr	r3, [r7, #4]
 8020fc4:	2b00      	cmp	r3, #0
 8020fc6:	d00e      	beq.n	8020fe6 <json_serialize_string+0x73a>
 8020fc8:	693b      	ldr	r3, [r7, #16]
 8020fca:	461a      	mov	r2, r3
 8020fcc:	4941      	ldr	r1, [pc, #260]	@ (80210d4 <json_serialize_string+0x828>)
 8020fce:	6878      	ldr	r0, [r7, #4]
 8020fd0:	f003 f90d 	bl	80241ee <memcpy>
 8020fd4:	693b      	ldr	r3, [r7, #16]
 8020fd6:	687a      	ldr	r2, [r7, #4]
 8020fd8:	4413      	add	r3, r2
 8020fda:	2200      	movs	r2, #0
 8020fdc:	701a      	strb	r2, [r3, #0]
 8020fde:	693b      	ldr	r3, [r7, #16]
 8020fe0:	687a      	ldr	r2, [r7, #4]
 8020fe2:	4413      	add	r3, r2
 8020fe4:	607b      	str	r3, [r7, #4]
 8020fe6:	69ba      	ldr	r2, [r7, #24]
 8020fe8:	693b      	ldr	r3, [r7, #16]
 8020fea:	4413      	add	r3, r2
 8020fec:	61bb      	str	r3, [r7, #24]
 8020fee:	e122      	b.n	8021236 <json_serialize_string+0x98a>
            case '\x18': APPEND_STRING("\\u0018"); break;
 8020ff0:	2306      	movs	r3, #6
 8020ff2:	613b      	str	r3, [r7, #16]
 8020ff4:	687b      	ldr	r3, [r7, #4]
 8020ff6:	2b00      	cmp	r3, #0
 8020ff8:	d00e      	beq.n	8021018 <json_serialize_string+0x76c>
 8020ffa:	693b      	ldr	r3, [r7, #16]
 8020ffc:	461a      	mov	r2, r3
 8020ffe:	4936      	ldr	r1, [pc, #216]	@ (80210d8 <json_serialize_string+0x82c>)
 8021000:	6878      	ldr	r0, [r7, #4]
 8021002:	f003 f8f4 	bl	80241ee <memcpy>
 8021006:	693b      	ldr	r3, [r7, #16]
 8021008:	687a      	ldr	r2, [r7, #4]
 802100a:	4413      	add	r3, r2
 802100c:	2200      	movs	r2, #0
 802100e:	701a      	strb	r2, [r3, #0]
 8021010:	693b      	ldr	r3, [r7, #16]
 8021012:	687a      	ldr	r2, [r7, #4]
 8021014:	4413      	add	r3, r2
 8021016:	607b      	str	r3, [r7, #4]
 8021018:	69ba      	ldr	r2, [r7, #24]
 802101a:	693b      	ldr	r3, [r7, #16]
 802101c:	4413      	add	r3, r2
 802101e:	61bb      	str	r3, [r7, #24]
 8021020:	e109      	b.n	8021236 <json_serialize_string+0x98a>
            case '\x19': APPEND_STRING("\\u0019"); break;
 8021022:	2306      	movs	r3, #6
 8021024:	613b      	str	r3, [r7, #16]
 8021026:	687b      	ldr	r3, [r7, #4]
 8021028:	2b00      	cmp	r3, #0
 802102a:	d00e      	beq.n	802104a <json_serialize_string+0x79e>
 802102c:	693b      	ldr	r3, [r7, #16]
 802102e:	461a      	mov	r2, r3
 8021030:	492a      	ldr	r1, [pc, #168]	@ (80210dc <json_serialize_string+0x830>)
 8021032:	6878      	ldr	r0, [r7, #4]
 8021034:	f003 f8db 	bl	80241ee <memcpy>
 8021038:	693b      	ldr	r3, [r7, #16]
 802103a:	687a      	ldr	r2, [r7, #4]
 802103c:	4413      	add	r3, r2
 802103e:	2200      	movs	r2, #0
 8021040:	701a      	strb	r2, [r3, #0]
 8021042:	693b      	ldr	r3, [r7, #16]
 8021044:	687a      	ldr	r2, [r7, #4]
 8021046:	4413      	add	r3, r2
 8021048:	607b      	str	r3, [r7, #4]
 802104a:	69ba      	ldr	r2, [r7, #24]
 802104c:	693b      	ldr	r3, [r7, #16]
 802104e:	4413      	add	r3, r2
 8021050:	61bb      	str	r3, [r7, #24]
 8021052:	e0f0      	b.n	8021236 <json_serialize_string+0x98a>
            case '\x1a': APPEND_STRING("\\u001a"); break;
 8021054:	2306      	movs	r3, #6
 8021056:	613b      	str	r3, [r7, #16]
 8021058:	687b      	ldr	r3, [r7, #4]
 802105a:	2b00      	cmp	r3, #0
 802105c:	d00e      	beq.n	802107c <json_serialize_string+0x7d0>
 802105e:	693b      	ldr	r3, [r7, #16]
 8021060:	461a      	mov	r2, r3
 8021062:	491f      	ldr	r1, [pc, #124]	@ (80210e0 <json_serialize_string+0x834>)
 8021064:	6878      	ldr	r0, [r7, #4]
 8021066:	f003 f8c2 	bl	80241ee <memcpy>
 802106a:	693b      	ldr	r3, [r7, #16]
 802106c:	687a      	ldr	r2, [r7, #4]
 802106e:	4413      	add	r3, r2
 8021070:	2200      	movs	r2, #0
 8021072:	701a      	strb	r2, [r3, #0]
 8021074:	693b      	ldr	r3, [r7, #16]
 8021076:	687a      	ldr	r2, [r7, #4]
 8021078:	4413      	add	r3, r2
 802107a:	607b      	str	r3, [r7, #4]
 802107c:	69ba      	ldr	r2, [r7, #24]
 802107e:	693b      	ldr	r3, [r7, #16]
 8021080:	4413      	add	r3, r2
 8021082:	61bb      	str	r3, [r7, #24]
 8021084:	e0d7      	b.n	8021236 <json_serialize_string+0x98a>
            case '\x1b': APPEND_STRING("\\u001b"); break;
 8021086:	2306      	movs	r3, #6
 8021088:	613b      	str	r3, [r7, #16]
 802108a:	687b      	ldr	r3, [r7, #4]
 802108c:	2b00      	cmp	r3, #0
 802108e:	d00e      	beq.n	80210ae <json_serialize_string+0x802>
 8021090:	693b      	ldr	r3, [r7, #16]
 8021092:	461a      	mov	r2, r3
 8021094:	4913      	ldr	r1, [pc, #76]	@ (80210e4 <json_serialize_string+0x838>)
 8021096:	6878      	ldr	r0, [r7, #4]
 8021098:	f003 f8a9 	bl	80241ee <memcpy>
 802109c:	693b      	ldr	r3, [r7, #16]
 802109e:	687a      	ldr	r2, [r7, #4]
 80210a0:	4413      	add	r3, r2
 80210a2:	2200      	movs	r2, #0
 80210a4:	701a      	strb	r2, [r3, #0]
 80210a6:	693b      	ldr	r3, [r7, #16]
 80210a8:	687a      	ldr	r2, [r7, #4]
 80210aa:	4413      	add	r3, r2
 80210ac:	607b      	str	r3, [r7, #4]
 80210ae:	69ba      	ldr	r2, [r7, #24]
 80210b0:	693b      	ldr	r3, [r7, #16]
 80210b2:	4413      	add	r3, r2
 80210b4:	61bb      	str	r3, [r7, #24]
 80210b6:	e0be      	b.n	8021236 <json_serialize_string+0x98a>
 80210b8:	0802a390 	.word	0x0802a390
 80210bc:	0802a398 	.word	0x0802a398
 80210c0:	0802a3a0 	.word	0x0802a3a0
 80210c4:	0802a3a8 	.word	0x0802a3a8
 80210c8:	0802a3b0 	.word	0x0802a3b0
 80210cc:	0802a3b8 	.word	0x0802a3b8
 80210d0:	0802a3c0 	.word	0x0802a3c0
 80210d4:	0802a3c8 	.word	0x0802a3c8
 80210d8:	0802a3d0 	.word	0x0802a3d0
 80210dc:	0802a3d8 	.word	0x0802a3d8
 80210e0:	0802a3e0 	.word	0x0802a3e0
 80210e4:	0802a3e8 	.word	0x0802a3e8
            case '\x1c': APPEND_STRING("\\u001c"); break;
 80210e8:	2306      	movs	r3, #6
 80210ea:	613b      	str	r3, [r7, #16]
 80210ec:	687b      	ldr	r3, [r7, #4]
 80210ee:	2b00      	cmp	r3, #0
 80210f0:	d00e      	beq.n	8021110 <json_serialize_string+0x864>
 80210f2:	693b      	ldr	r3, [r7, #16]
 80210f4:	461a      	mov	r2, r3
 80210f6:	4962      	ldr	r1, [pc, #392]	@ (8021280 <json_serialize_string+0x9d4>)
 80210f8:	6878      	ldr	r0, [r7, #4]
 80210fa:	f003 f878 	bl	80241ee <memcpy>
 80210fe:	693b      	ldr	r3, [r7, #16]
 8021100:	687a      	ldr	r2, [r7, #4]
 8021102:	4413      	add	r3, r2
 8021104:	2200      	movs	r2, #0
 8021106:	701a      	strb	r2, [r3, #0]
 8021108:	693b      	ldr	r3, [r7, #16]
 802110a:	687a      	ldr	r2, [r7, #4]
 802110c:	4413      	add	r3, r2
 802110e:	607b      	str	r3, [r7, #4]
 8021110:	69ba      	ldr	r2, [r7, #24]
 8021112:	693b      	ldr	r3, [r7, #16]
 8021114:	4413      	add	r3, r2
 8021116:	61bb      	str	r3, [r7, #24]
 8021118:	e08d      	b.n	8021236 <json_serialize_string+0x98a>
            case '\x1d': APPEND_STRING("\\u001d"); break;
 802111a:	2306      	movs	r3, #6
 802111c:	613b      	str	r3, [r7, #16]
 802111e:	687b      	ldr	r3, [r7, #4]
 8021120:	2b00      	cmp	r3, #0
 8021122:	d00e      	beq.n	8021142 <json_serialize_string+0x896>
 8021124:	693b      	ldr	r3, [r7, #16]
 8021126:	461a      	mov	r2, r3
 8021128:	4956      	ldr	r1, [pc, #344]	@ (8021284 <json_serialize_string+0x9d8>)
 802112a:	6878      	ldr	r0, [r7, #4]
 802112c:	f003 f85f 	bl	80241ee <memcpy>
 8021130:	693b      	ldr	r3, [r7, #16]
 8021132:	687a      	ldr	r2, [r7, #4]
 8021134:	4413      	add	r3, r2
 8021136:	2200      	movs	r2, #0
 8021138:	701a      	strb	r2, [r3, #0]
 802113a:	693b      	ldr	r3, [r7, #16]
 802113c:	687a      	ldr	r2, [r7, #4]
 802113e:	4413      	add	r3, r2
 8021140:	607b      	str	r3, [r7, #4]
 8021142:	69ba      	ldr	r2, [r7, #24]
 8021144:	693b      	ldr	r3, [r7, #16]
 8021146:	4413      	add	r3, r2
 8021148:	61bb      	str	r3, [r7, #24]
 802114a:	e074      	b.n	8021236 <json_serialize_string+0x98a>
            case '\x1e': APPEND_STRING("\\u001e"); break;
 802114c:	2306      	movs	r3, #6
 802114e:	613b      	str	r3, [r7, #16]
 8021150:	687b      	ldr	r3, [r7, #4]
 8021152:	2b00      	cmp	r3, #0
 8021154:	d00e      	beq.n	8021174 <json_serialize_string+0x8c8>
 8021156:	693b      	ldr	r3, [r7, #16]
 8021158:	461a      	mov	r2, r3
 802115a:	494b      	ldr	r1, [pc, #300]	@ (8021288 <json_serialize_string+0x9dc>)
 802115c:	6878      	ldr	r0, [r7, #4]
 802115e:	f003 f846 	bl	80241ee <memcpy>
 8021162:	693b      	ldr	r3, [r7, #16]
 8021164:	687a      	ldr	r2, [r7, #4]
 8021166:	4413      	add	r3, r2
 8021168:	2200      	movs	r2, #0
 802116a:	701a      	strb	r2, [r3, #0]
 802116c:	693b      	ldr	r3, [r7, #16]
 802116e:	687a      	ldr	r2, [r7, #4]
 8021170:	4413      	add	r3, r2
 8021172:	607b      	str	r3, [r7, #4]
 8021174:	69ba      	ldr	r2, [r7, #24]
 8021176:	693b      	ldr	r3, [r7, #16]
 8021178:	4413      	add	r3, r2
 802117a:	61bb      	str	r3, [r7, #24]
 802117c:	e05b      	b.n	8021236 <json_serialize_string+0x98a>
            case '\x1f': APPEND_STRING("\\u001f"); break;
 802117e:	2306      	movs	r3, #6
 8021180:	613b      	str	r3, [r7, #16]
 8021182:	687b      	ldr	r3, [r7, #4]
 8021184:	2b00      	cmp	r3, #0
 8021186:	d00e      	beq.n	80211a6 <json_serialize_string+0x8fa>
 8021188:	693b      	ldr	r3, [r7, #16]
 802118a:	461a      	mov	r2, r3
 802118c:	493f      	ldr	r1, [pc, #252]	@ (802128c <json_serialize_string+0x9e0>)
 802118e:	6878      	ldr	r0, [r7, #4]
 8021190:	f003 f82d 	bl	80241ee <memcpy>
 8021194:	693b      	ldr	r3, [r7, #16]
 8021196:	687a      	ldr	r2, [r7, #4]
 8021198:	4413      	add	r3, r2
 802119a:	2200      	movs	r2, #0
 802119c:	701a      	strb	r2, [r3, #0]
 802119e:	693b      	ldr	r3, [r7, #16]
 80211a0:	687a      	ldr	r2, [r7, #4]
 80211a2:	4413      	add	r3, r2
 80211a4:	607b      	str	r3, [r7, #4]
 80211a6:	69ba      	ldr	r2, [r7, #24]
 80211a8:	693b      	ldr	r3, [r7, #16]
 80211aa:	4413      	add	r3, r2
 80211ac:	61bb      	str	r3, [r7, #24]
 80211ae:	e042      	b.n	8021236 <json_serialize_string+0x98a>
            case '/':
                if (parson_escape_slashes) {
 80211b0:	4b37      	ldr	r3, [pc, #220]	@ (8021290 <json_serialize_string+0x9e4>)
 80211b2:	681b      	ldr	r3, [r3, #0]
 80211b4:	2b00      	cmp	r3, #0
 80211b6:	d018      	beq.n	80211ea <json_serialize_string+0x93e>
                    APPEND_STRING("\\/");  /* to make json embeddable in xml\/html */
 80211b8:	2302      	movs	r3, #2
 80211ba:	613b      	str	r3, [r7, #16]
 80211bc:	687b      	ldr	r3, [r7, #4]
 80211be:	2b00      	cmp	r3, #0
 80211c0:	d00e      	beq.n	80211e0 <json_serialize_string+0x934>
 80211c2:	693b      	ldr	r3, [r7, #16]
 80211c4:	461a      	mov	r2, r3
 80211c6:	4933      	ldr	r1, [pc, #204]	@ (8021294 <json_serialize_string+0x9e8>)
 80211c8:	6878      	ldr	r0, [r7, #4]
 80211ca:	f003 f810 	bl	80241ee <memcpy>
 80211ce:	693b      	ldr	r3, [r7, #16]
 80211d0:	687a      	ldr	r2, [r7, #4]
 80211d2:	4413      	add	r3, r2
 80211d4:	2200      	movs	r2, #0
 80211d6:	701a      	strb	r2, [r3, #0]
 80211d8:	693b      	ldr	r3, [r7, #16]
 80211da:	687a      	ldr	r2, [r7, #4]
 80211dc:	4413      	add	r3, r2
 80211de:	607b      	str	r3, [r7, #4]
 80211e0:	69ba      	ldr	r2, [r7, #24]
 80211e2:	693b      	ldr	r3, [r7, #16]
 80211e4:	4413      	add	r3, r2
 80211e6:	61bb      	str	r3, [r7, #24]
                } else {
                    APPEND_STRING("/");
                }
                break;
 80211e8:	e025      	b.n	8021236 <json_serialize_string+0x98a>
                    APPEND_STRING("/");
 80211ea:	2301      	movs	r3, #1
 80211ec:	613b      	str	r3, [r7, #16]
 80211ee:	687b      	ldr	r3, [r7, #4]
 80211f0:	2b00      	cmp	r3, #0
 80211f2:	d00e      	beq.n	8021212 <json_serialize_string+0x966>
 80211f4:	693b      	ldr	r3, [r7, #16]
 80211f6:	461a      	mov	r2, r3
 80211f8:	4927      	ldr	r1, [pc, #156]	@ (8021298 <json_serialize_string+0x9ec>)
 80211fa:	6878      	ldr	r0, [r7, #4]
 80211fc:	f002 fff7 	bl	80241ee <memcpy>
 8021200:	693b      	ldr	r3, [r7, #16]
 8021202:	687a      	ldr	r2, [r7, #4]
 8021204:	4413      	add	r3, r2
 8021206:	2200      	movs	r2, #0
 8021208:	701a      	strb	r2, [r3, #0]
 802120a:	693b      	ldr	r3, [r7, #16]
 802120c:	687a      	ldr	r2, [r7, #4]
 802120e:	4413      	add	r3, r2
 8021210:	607b      	str	r3, [r7, #4]
 8021212:	69ba      	ldr	r2, [r7, #24]
 8021214:	693b      	ldr	r3, [r7, #16]
 8021216:	4413      	add	r3, r2
 8021218:	61bb      	str	r3, [r7, #24]
                break;
 802121a:	e00c      	b.n	8021236 <json_serialize_string+0x98a>
            default:
                if (buf != NULL) {
 802121c:	687b      	ldr	r3, [r7, #4]
 802121e:	2b00      	cmp	r3, #0
 8021220:	d005      	beq.n	802122e <json_serialize_string+0x982>
                    buf[0] = c;
 8021222:	687b      	ldr	r3, [r7, #4]
 8021224:	7dfa      	ldrb	r2, [r7, #23]
 8021226:	701a      	strb	r2, [r3, #0]
                    buf += 1;
 8021228:	687b      	ldr	r3, [r7, #4]
 802122a:	3301      	adds	r3, #1
 802122c:	607b      	str	r3, [r7, #4]
                }
                written_total += 1;
 802122e:	69bb      	ldr	r3, [r7, #24]
 8021230:	3301      	adds	r3, #1
 8021232:	61bb      	str	r3, [r7, #24]
                break;
 8021234:	bf00      	nop
    for (i = 0; i < len; i++) {
 8021236:	69fb      	ldr	r3, [r7, #28]
 8021238:	3301      	adds	r3, #1
 802123a:	61fb      	str	r3, [r7, #28]
 802123c:	69fa      	ldr	r2, [r7, #28]
 802123e:	68bb      	ldr	r3, [r7, #8]
 8021240:	429a      	cmp	r2, r3
 8021242:	f4ff ab5e 	bcc.w	8020902 <json_serialize_string+0x56>
        }
    }
    APPEND_STRING("\"");
 8021246:	2301      	movs	r3, #1
 8021248:	613b      	str	r3, [r7, #16]
 802124a:	687b      	ldr	r3, [r7, #4]
 802124c:	2b00      	cmp	r3, #0
 802124e:	d00e      	beq.n	802126e <json_serialize_string+0x9c2>
 8021250:	693b      	ldr	r3, [r7, #16]
 8021252:	461a      	mov	r2, r3
 8021254:	4911      	ldr	r1, [pc, #68]	@ (802129c <json_serialize_string+0x9f0>)
 8021256:	6878      	ldr	r0, [r7, #4]
 8021258:	f002 ffc9 	bl	80241ee <memcpy>
 802125c:	693b      	ldr	r3, [r7, #16]
 802125e:	687a      	ldr	r2, [r7, #4]
 8021260:	4413      	add	r3, r2
 8021262:	2200      	movs	r2, #0
 8021264:	701a      	strb	r2, [r3, #0]
 8021266:	693b      	ldr	r3, [r7, #16]
 8021268:	687a      	ldr	r2, [r7, #4]
 802126a:	4413      	add	r3, r2
 802126c:	607b      	str	r3, [r7, #4]
 802126e:	69ba      	ldr	r2, [r7, #24]
 8021270:	693b      	ldr	r3, [r7, #16]
 8021272:	4413      	add	r3, r2
 8021274:	61bb      	str	r3, [r7, #24]
    return written_total;
 8021276:	69bb      	ldr	r3, [r7, #24]
}
 8021278:	4618      	mov	r0, r3
 802127a:	3720      	adds	r7, #32
 802127c:	46bd      	mov	sp, r7
 802127e:	bd80      	pop	{r7, pc}
 8021280:	0802a3f0 	.word	0x0802a3f0
 8021284:	0802a3f8 	.word	0x0802a3f8
 8021288:	0802a400 	.word	0x0802a400
 802128c:	0802a408 	.word	0x0802a408
 8021290:	20000218 	.word	0x20000218
 8021294:	0802a410 	.word	0x0802a410
 8021298:	0802a414 	.word	0x0802a414
 802129c:	0802a318 	.word	0x0802a318

080212a0 <json_parse_string>:
    output_value = json_parse_string_with_comments(file_contents);
    parson_free(file_contents);
    return output_value;
}

JSON_Value * json_parse_string(const char *string) {
 80212a0:	b580      	push	{r7, lr}
 80212a2:	b082      	sub	sp, #8
 80212a4:	af00      	add	r7, sp, #0
 80212a6:	6078      	str	r0, [r7, #4]
    if (string == NULL) {
 80212a8:	687b      	ldr	r3, [r7, #4]
 80212aa:	2b00      	cmp	r3, #0
 80212ac:	d101      	bne.n	80212b2 <json_parse_string+0x12>
        return NULL;
 80212ae:	2300      	movs	r3, #0
 80212b0:	e016      	b.n	80212e0 <json_parse_string+0x40>
    }
    if (string[0] == '\xEF' && string[1] == '\xBB' && string[2] == '\xBF') {
 80212b2:	687b      	ldr	r3, [r7, #4]
 80212b4:	781b      	ldrb	r3, [r3, #0]
 80212b6:	2bef      	cmp	r3, #239	@ 0xef
 80212b8:	d10c      	bne.n	80212d4 <json_parse_string+0x34>
 80212ba:	687b      	ldr	r3, [r7, #4]
 80212bc:	3301      	adds	r3, #1
 80212be:	781b      	ldrb	r3, [r3, #0]
 80212c0:	2bbb      	cmp	r3, #187	@ 0xbb
 80212c2:	d107      	bne.n	80212d4 <json_parse_string+0x34>
 80212c4:	687b      	ldr	r3, [r7, #4]
 80212c6:	3302      	adds	r3, #2
 80212c8:	781b      	ldrb	r3, [r3, #0]
 80212ca:	2bbf      	cmp	r3, #191	@ 0xbf
 80212cc:	d102      	bne.n	80212d4 <json_parse_string+0x34>
        string = string + 3; /* Support for UTF-8 BOM */
 80212ce:	687b      	ldr	r3, [r7, #4]
 80212d0:	3303      	adds	r3, #3
 80212d2:	607b      	str	r3, [r7, #4]
    }
    return parse_value((const char**)&string, 0);
 80212d4:	1d3b      	adds	r3, r7, #4
 80212d6:	2100      	movs	r1, #0
 80212d8:	4618      	mov	r0, r3
 80212da:	f7fe fbeb 	bl	801fab4 <parse_value>
 80212de:	4603      	mov	r3, r0
}
 80212e0:	4618      	mov	r0, r3
 80212e2:	3708      	adds	r7, #8
 80212e4:	46bd      	mov	sp, r7
 80212e6:	bd80      	pop	{r7, pc}

080212e8 <json_object_get_value>:
    return result;
}

/* JSON Object API */

JSON_Value * json_object_get_value(const JSON_Object *object, const char *name) {
 80212e8:	b580      	push	{r7, lr}
 80212ea:	b082      	sub	sp, #8
 80212ec:	af00      	add	r7, sp, #0
 80212ee:	6078      	str	r0, [r7, #4]
 80212f0:	6039      	str	r1, [r7, #0]
    if (object == NULL || name == NULL) {
 80212f2:	687b      	ldr	r3, [r7, #4]
 80212f4:	2b00      	cmp	r3, #0
 80212f6:	d002      	beq.n	80212fe <json_object_get_value+0x16>
 80212f8:	683b      	ldr	r3, [r7, #0]
 80212fa:	2b00      	cmp	r3, #0
 80212fc:	d101      	bne.n	8021302 <json_object_get_value+0x1a>
        return NULL;
 80212fe:	2300      	movs	r3, #0
 8021300:	e009      	b.n	8021316 <json_object_get_value+0x2e>
    }
    return json_object_getn_value(object, name, strlen(name));
 8021302:	6838      	ldr	r0, [r7, #0]
 8021304:	f7de ffc2 	bl	800028c <strlen>
 8021308:	4603      	mov	r3, r0
 802130a:	461a      	mov	r2, r3
 802130c:	6839      	ldr	r1, [r7, #0]
 802130e:	6878      	ldr	r0, [r7, #4]
 8021310:	f7fd ff03 	bl	801f11a <json_object_getn_value>
 8021314:	4603      	mov	r3, r0
}
 8021316:	4618      	mov	r0, r3
 8021318:	3708      	adds	r7, #8
 802131a:	46bd      	mov	sp, r7
 802131c:	bd80      	pop	{r7, pc}

0802131e <json_object_get_string>:

const char * json_object_get_string(const JSON_Object *object, const char *name) {
 802131e:	b580      	push	{r7, lr}
 8021320:	b082      	sub	sp, #8
 8021322:	af00      	add	r7, sp, #0
 8021324:	6078      	str	r0, [r7, #4]
 8021326:	6039      	str	r1, [r7, #0]
    return json_value_get_string(json_object_get_value(object, name));
 8021328:	6839      	ldr	r1, [r7, #0]
 802132a:	6878      	ldr	r0, [r7, #4]
 802132c:	f7ff ffdc 	bl	80212e8 <json_object_get_value>
 8021330:	4603      	mov	r3, r0
 8021332:	4618      	mov	r0, r3
 8021334:	f000 f9a1 	bl	802167a <json_value_get_string>
 8021338:	4603      	mov	r3, r0
}
 802133a:	4618      	mov	r0, r3
 802133c:	3708      	adds	r7, #8
 802133e:	46bd      	mov	sp, r7
 8021340:	bd80      	pop	{r7, pc}

08021342 <json_object_get_object>:

double json_object_get_number(const JSON_Object *object, const char *name) {
    return json_value_get_number(json_object_get_value(object, name));
}

JSON_Object * json_object_get_object(const JSON_Object *object, const char *name) {
 8021342:	b580      	push	{r7, lr}
 8021344:	b082      	sub	sp, #8
 8021346:	af00      	add	r7, sp, #0
 8021348:	6078      	str	r0, [r7, #4]
 802134a:	6039      	str	r1, [r7, #0]
    return json_value_get_object(json_object_get_value(object, name));
 802134c:	6839      	ldr	r1, [r7, #0]
 802134e:	6878      	ldr	r0, [r7, #4]
 8021350:	f7ff ffca 	bl	80212e8 <json_object_get_value>
 8021354:	4603      	mov	r3, r0
 8021356:	4618      	mov	r0, r3
 8021358:	f000 f959 	bl	802160e <json_value_get_object>
 802135c:	4603      	mov	r3, r0
}
 802135e:	4618      	mov	r0, r3
 8021360:	3708      	adds	r7, #8
 8021362:	46bd      	mov	sp, r7
 8021364:	bd80      	pop	{r7, pc}

08021366 <json_object_get_array>:

JSON_Array * json_object_get_array(const JSON_Object *object, const char *name) {
 8021366:	b580      	push	{r7, lr}
 8021368:	b082      	sub	sp, #8
 802136a:	af00      	add	r7, sp, #0
 802136c:	6078      	str	r0, [r7, #4]
 802136e:	6039      	str	r1, [r7, #0]
    return json_value_get_array(json_object_get_value(object, name));
 8021370:	6839      	ldr	r1, [r7, #0]
 8021372:	6878      	ldr	r0, [r7, #4]
 8021374:	f7ff ffb8 	bl	80212e8 <json_object_get_value>
 8021378:	4603      	mov	r3, r0
 802137a:	4618      	mov	r0, r3
 802137c:	f000 f959 	bl	8021632 <json_value_get_array>
 8021380:	4603      	mov	r3, r0
}
 8021382:	4618      	mov	r0, r3
 8021384:	3708      	adds	r7, #8
 8021386:	46bd      	mov	sp, r7
 8021388:	bd80      	pop	{r7, pc}

0802138a <json_object_dotget_value>:

int json_object_get_boolean(const JSON_Object *object, const char *name) {
    return json_value_get_boolean(json_object_get_value(object, name));
}

JSON_Value * json_object_dotget_value(const JSON_Object *object, const char *name) {
 802138a:	b580      	push	{r7, lr}
 802138c:	b084      	sub	sp, #16
 802138e:	af00      	add	r7, sp, #0
 8021390:	6078      	str	r0, [r7, #4]
 8021392:	6039      	str	r1, [r7, #0]
    const char *dot_position = strchr(name, '.');
 8021394:	212e      	movs	r1, #46	@ 0x2e
 8021396:	6838      	ldr	r0, [r7, #0]
 8021398:	f002 fe6c 	bl	8024074 <strchr>
 802139c:	60f8      	str	r0, [r7, #12]
    if (!dot_position) {
 802139e:	68fb      	ldr	r3, [r7, #12]
 80213a0:	2b00      	cmp	r3, #0
 80213a2:	d105      	bne.n	80213b0 <json_object_dotget_value+0x26>
        return json_object_get_value(object, name);
 80213a4:	6839      	ldr	r1, [r7, #0]
 80213a6:	6878      	ldr	r0, [r7, #4]
 80213a8:	f7ff ff9e 	bl	80212e8 <json_object_get_value>
 80213ac:	4603      	mov	r3, r0
 80213ae:	e013      	b.n	80213d8 <json_object_dotget_value+0x4e>
    }
    object = json_value_get_object(json_object_getn_value(object, name, dot_position - name));
 80213b0:	68fa      	ldr	r2, [r7, #12]
 80213b2:	683b      	ldr	r3, [r7, #0]
 80213b4:	1ad3      	subs	r3, r2, r3
 80213b6:	461a      	mov	r2, r3
 80213b8:	6839      	ldr	r1, [r7, #0]
 80213ba:	6878      	ldr	r0, [r7, #4]
 80213bc:	f7fd fead 	bl	801f11a <json_object_getn_value>
 80213c0:	4603      	mov	r3, r0
 80213c2:	4618      	mov	r0, r3
 80213c4:	f000 f923 	bl	802160e <json_value_get_object>
 80213c8:	6078      	str	r0, [r7, #4]
    return json_object_dotget_value(object, dot_position + 1);
 80213ca:	68fb      	ldr	r3, [r7, #12]
 80213cc:	3301      	adds	r3, #1
 80213ce:	4619      	mov	r1, r3
 80213d0:	6878      	ldr	r0, [r7, #4]
 80213d2:	f7ff ffda 	bl	802138a <json_object_dotget_value>
 80213d6:	4603      	mov	r3, r0
}
 80213d8:	4618      	mov	r0, r3
 80213da:	3710      	adds	r7, #16
 80213dc:	46bd      	mov	sp, r7
 80213de:	bd80      	pop	{r7, pc}

080213e0 <json_object_dotget_string>:

const char * json_object_dotget_string(const JSON_Object *object, const char *name) {
 80213e0:	b580      	push	{r7, lr}
 80213e2:	b082      	sub	sp, #8
 80213e4:	af00      	add	r7, sp, #0
 80213e6:	6078      	str	r0, [r7, #4]
 80213e8:	6039      	str	r1, [r7, #0]
    return json_value_get_string(json_object_dotget_value(object, name));
 80213ea:	6839      	ldr	r1, [r7, #0]
 80213ec:	6878      	ldr	r0, [r7, #4]
 80213ee:	f7ff ffcc 	bl	802138a <json_object_dotget_value>
 80213f2:	4603      	mov	r3, r0
 80213f4:	4618      	mov	r0, r3
 80213f6:	f000 f940 	bl	802167a <json_value_get_string>
 80213fa:	4603      	mov	r3, r0
}
 80213fc:	4618      	mov	r0, r3
 80213fe:	3708      	adds	r7, #8
 8021400:	46bd      	mov	sp, r7
 8021402:	bd80      	pop	{r7, pc}

08021404 <json_object_dotget_number>:

size_t json_object_dotget_string_len(const JSON_Object *object, const char *name) {
    return json_value_get_string_len(json_object_dotget_value(object, name));
}

double json_object_dotget_number(const JSON_Object *object, const char *name) {
 8021404:	b580      	push	{r7, lr}
 8021406:	b082      	sub	sp, #8
 8021408:	af00      	add	r7, sp, #0
 802140a:	6078      	str	r0, [r7, #4]
 802140c:	6039      	str	r1, [r7, #0]
    return json_value_get_number(json_object_dotget_value(object, name));
 802140e:	6839      	ldr	r1, [r7, #0]
 8021410:	6878      	ldr	r0, [r7, #4]
 8021412:	f7ff ffba 	bl	802138a <json_object_dotget_value>
 8021416:	4603      	mov	r3, r0
 8021418:	4618      	mov	r0, r3
 802141a:	f000 f954 	bl	80216c6 <json_value_get_number>
 802141e:	4602      	mov	r2, r0
 8021420:	460b      	mov	r3, r1
}
 8021422:	4610      	mov	r0, r2
 8021424:	4619      	mov	r1, r3
 8021426:	3708      	adds	r7, #8
 8021428:	46bd      	mov	sp, r7
 802142a:	bd80      	pop	{r7, pc}

0802142c <json_object_dotget_array>:

JSON_Object * json_object_dotget_object(const JSON_Object *object, const char *name) {
    return json_value_get_object(json_object_dotget_value(object, name));
}

JSON_Array * json_object_dotget_array(const JSON_Object *object, const char *name) {
 802142c:	b580      	push	{r7, lr}
 802142e:	b082      	sub	sp, #8
 8021430:	af00      	add	r7, sp, #0
 8021432:	6078      	str	r0, [r7, #4]
 8021434:	6039      	str	r1, [r7, #0]
    return json_value_get_array(json_object_dotget_value(object, name));
 8021436:	6839      	ldr	r1, [r7, #0]
 8021438:	6878      	ldr	r0, [r7, #4]
 802143a:	f7ff ffa6 	bl	802138a <json_object_dotget_value>
 802143e:	4603      	mov	r3, r0
 8021440:	4618      	mov	r0, r3
 8021442:	f000 f8f6 	bl	8021632 <json_value_get_array>
 8021446:	4603      	mov	r3, r0
}
 8021448:	4618      	mov	r0, r3
 802144a:	3708      	adds	r7, #8
 802144c:	46bd      	mov	sp, r7
 802144e:	bd80      	pop	{r7, pc}

08021450 <json_object_get_count>:

int json_object_dotget_boolean(const JSON_Object *object, const char *name) {
    return json_value_get_boolean(json_object_dotget_value(object, name));
}

size_t json_object_get_count(const JSON_Object *object) {
 8021450:	b480      	push	{r7}
 8021452:	b083      	sub	sp, #12
 8021454:	af00      	add	r7, sp, #0
 8021456:	6078      	str	r0, [r7, #4]
    return object ? object->count : 0;
 8021458:	687b      	ldr	r3, [r7, #4]
 802145a:	2b00      	cmp	r3, #0
 802145c:	d002      	beq.n	8021464 <json_object_get_count+0x14>
 802145e:	687b      	ldr	r3, [r7, #4]
 8021460:	699b      	ldr	r3, [r3, #24]
 8021462:	e000      	b.n	8021466 <json_object_get_count+0x16>
 8021464:	2300      	movs	r3, #0
}
 8021466:	4618      	mov	r0, r3
 8021468:	370c      	adds	r7, #12
 802146a:	46bd      	mov	sp, r7
 802146c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021470:	4770      	bx	lr

08021472 <json_object_get_name>:

const char * json_object_get_name(const JSON_Object *object, size_t index) {
 8021472:	b580      	push	{r7, lr}
 8021474:	b082      	sub	sp, #8
 8021476:	af00      	add	r7, sp, #0
 8021478:	6078      	str	r0, [r7, #4]
 802147a:	6039      	str	r1, [r7, #0]
    if (object == NULL || index >= json_object_get_count(object)) {
 802147c:	687b      	ldr	r3, [r7, #4]
 802147e:	2b00      	cmp	r3, #0
 8021480:	d006      	beq.n	8021490 <json_object_get_name+0x1e>
 8021482:	6878      	ldr	r0, [r7, #4]
 8021484:	f7ff ffe4 	bl	8021450 <json_object_get_count>
 8021488:	4602      	mov	r2, r0
 802148a:	683b      	ldr	r3, [r7, #0]
 802148c:	4293      	cmp	r3, r2
 802148e:	d301      	bcc.n	8021494 <json_object_get_name+0x22>
        return NULL;
 8021490:	2300      	movs	r3, #0
 8021492:	e005      	b.n	80214a0 <json_object_get_name+0x2e>
    }
    return object->names[index];
 8021494:	687b      	ldr	r3, [r7, #4]
 8021496:	68da      	ldr	r2, [r3, #12]
 8021498:	683b      	ldr	r3, [r7, #0]
 802149a:	009b      	lsls	r3, r3, #2
 802149c:	4413      	add	r3, r2
 802149e:	681b      	ldr	r3, [r3, #0]
}
 80214a0:	4618      	mov	r0, r3
 80214a2:	3708      	adds	r7, #8
 80214a4:	46bd      	mov	sp, r7
 80214a6:	bd80      	pop	{r7, pc}

080214a8 <json_object_get_value_at>:

JSON_Value * json_object_get_value_at(const JSON_Object *object, size_t index) {
 80214a8:	b580      	push	{r7, lr}
 80214aa:	b082      	sub	sp, #8
 80214ac:	af00      	add	r7, sp, #0
 80214ae:	6078      	str	r0, [r7, #4]
 80214b0:	6039      	str	r1, [r7, #0]
    if (object == NULL || index >= json_object_get_count(object)) {
 80214b2:	687b      	ldr	r3, [r7, #4]
 80214b4:	2b00      	cmp	r3, #0
 80214b6:	d006      	beq.n	80214c6 <json_object_get_value_at+0x1e>
 80214b8:	6878      	ldr	r0, [r7, #4]
 80214ba:	f7ff ffc9 	bl	8021450 <json_object_get_count>
 80214be:	4602      	mov	r2, r0
 80214c0:	683b      	ldr	r3, [r7, #0]
 80214c2:	4293      	cmp	r3, r2
 80214c4:	d301      	bcc.n	80214ca <json_object_get_value_at+0x22>
        return NULL;
 80214c6:	2300      	movs	r3, #0
 80214c8:	e005      	b.n	80214d6 <json_object_get_value_at+0x2e>
    }
    return object->values[index];
 80214ca:	687b      	ldr	r3, [r7, #4]
 80214cc:	691a      	ldr	r2, [r3, #16]
 80214ce:	683b      	ldr	r3, [r7, #0]
 80214d0:	009b      	lsls	r3, r3, #2
 80214d2:	4413      	add	r3, r2
 80214d4:	681b      	ldr	r3, [r3, #0]
}
 80214d6:	4618      	mov	r0, r3
 80214d8:	3708      	adds	r7, #8
 80214da:	46bd      	mov	sp, r7
 80214dc:	bd80      	pop	{r7, pc}

080214de <json_object_get_wrapping_value>:

JSON_Value *json_object_get_wrapping_value(const JSON_Object *object) {
 80214de:	b480      	push	{r7}
 80214e0:	b083      	sub	sp, #12
 80214e2:	af00      	add	r7, sp, #0
 80214e4:	6078      	str	r0, [r7, #4]
    if (!object) {
 80214e6:	687b      	ldr	r3, [r7, #4]
 80214e8:	2b00      	cmp	r3, #0
 80214ea:	d101      	bne.n	80214f0 <json_object_get_wrapping_value+0x12>
        return NULL;
 80214ec:	2300      	movs	r3, #0
 80214ee:	e001      	b.n	80214f4 <json_object_get_wrapping_value+0x16>
    }
    return object->wrapping_value;
 80214f0:	687b      	ldr	r3, [r7, #4]
 80214f2:	681b      	ldr	r3, [r3, #0]
}
 80214f4:	4618      	mov	r0, r3
 80214f6:	370c      	adds	r7, #12
 80214f8:	46bd      	mov	sp, r7
 80214fa:	f85d 7b04 	ldr.w	r7, [sp], #4
 80214fe:	4770      	bx	lr

08021500 <json_object_has_value>:

int json_object_has_value (const JSON_Object *object, const char *name) {
 8021500:	b580      	push	{r7, lr}
 8021502:	b082      	sub	sp, #8
 8021504:	af00      	add	r7, sp, #0
 8021506:	6078      	str	r0, [r7, #4]
 8021508:	6039      	str	r1, [r7, #0]
    return json_object_get_value(object, name) != NULL;
 802150a:	6839      	ldr	r1, [r7, #0]
 802150c:	6878      	ldr	r0, [r7, #4]
 802150e:	f7ff feeb 	bl	80212e8 <json_object_get_value>
 8021512:	4603      	mov	r3, r0
 8021514:	2b00      	cmp	r3, #0
 8021516:	bf14      	ite	ne
 8021518:	2301      	movne	r3, #1
 802151a:	2300      	moveq	r3, #0
 802151c:	b2db      	uxtb	r3, r3
}
 802151e:	4618      	mov	r0, r3
 8021520:	3708      	adds	r7, #8
 8021522:	46bd      	mov	sp, r7
 8021524:	bd80      	pop	{r7, pc}

08021526 <json_object_dothas_value>:
int json_object_has_value_of_type(const JSON_Object *object, const char *name, JSON_Value_Type type) {
    JSON_Value *val = json_object_get_value(object, name);
    return val != NULL && json_value_get_type(val) == type;
}

int json_object_dothas_value (const JSON_Object *object, const char *name) {
 8021526:	b580      	push	{r7, lr}
 8021528:	b082      	sub	sp, #8
 802152a:	af00      	add	r7, sp, #0
 802152c:	6078      	str	r0, [r7, #4]
 802152e:	6039      	str	r1, [r7, #0]
    return json_object_dotget_value(object, name) != NULL;
 8021530:	6839      	ldr	r1, [r7, #0]
 8021532:	6878      	ldr	r0, [r7, #4]
 8021534:	f7ff ff29 	bl	802138a <json_object_dotget_value>
 8021538:	4603      	mov	r3, r0
 802153a:	2b00      	cmp	r3, #0
 802153c:	bf14      	ite	ne
 802153e:	2301      	movne	r3, #1
 8021540:	2300      	moveq	r3, #0
 8021542:	b2db      	uxtb	r3, r3
}
 8021544:	4618      	mov	r0, r3
 8021546:	3708      	adds	r7, #8
 8021548:	46bd      	mov	sp, r7
 802154a:	bd80      	pop	{r7, pc}

0802154c <json_array_get_value>:
    JSON_Value *val = json_object_dotget_value(object, name);
    return val != NULL && json_value_get_type(val) == type;
}

/* JSON Array API */
JSON_Value * json_array_get_value(const JSON_Array *array, size_t index) {
 802154c:	b580      	push	{r7, lr}
 802154e:	b082      	sub	sp, #8
 8021550:	af00      	add	r7, sp, #0
 8021552:	6078      	str	r0, [r7, #4]
 8021554:	6039      	str	r1, [r7, #0]
    if (array == NULL || index >= json_array_get_count(array)) {
 8021556:	687b      	ldr	r3, [r7, #4]
 8021558:	2b00      	cmp	r3, #0
 802155a:	d006      	beq.n	802156a <json_array_get_value+0x1e>
 802155c:	6878      	ldr	r0, [r7, #4]
 802155e:	f000 f822 	bl	80215a6 <json_array_get_count>
 8021562:	4602      	mov	r2, r0
 8021564:	683b      	ldr	r3, [r7, #0]
 8021566:	4293      	cmp	r3, r2
 8021568:	d301      	bcc.n	802156e <json_array_get_value+0x22>
        return NULL;
 802156a:	2300      	movs	r3, #0
 802156c:	e005      	b.n	802157a <json_array_get_value+0x2e>
    }
    return array->items[index];
 802156e:	687b      	ldr	r3, [r7, #4]
 8021570:	685a      	ldr	r2, [r3, #4]
 8021572:	683b      	ldr	r3, [r7, #0]
 8021574:	009b      	lsls	r3, r3, #2
 8021576:	4413      	add	r3, r2
 8021578:	681b      	ldr	r3, [r3, #0]
}
 802157a:	4618      	mov	r0, r3
 802157c:	3708      	adds	r7, #8
 802157e:	46bd      	mov	sp, r7
 8021580:	bd80      	pop	{r7, pc}

08021582 <json_array_get_object>:

double json_array_get_number(const JSON_Array *array, size_t index) {
    return json_value_get_number(json_array_get_value(array, index));
}

JSON_Object * json_array_get_object(const JSON_Array *array, size_t index) {
 8021582:	b580      	push	{r7, lr}
 8021584:	b082      	sub	sp, #8
 8021586:	af00      	add	r7, sp, #0
 8021588:	6078      	str	r0, [r7, #4]
 802158a:	6039      	str	r1, [r7, #0]
    return json_value_get_object(json_array_get_value(array, index));
 802158c:	6839      	ldr	r1, [r7, #0]
 802158e:	6878      	ldr	r0, [r7, #4]
 8021590:	f7ff ffdc 	bl	802154c <json_array_get_value>
 8021594:	4603      	mov	r3, r0
 8021596:	4618      	mov	r0, r3
 8021598:	f000 f839 	bl	802160e <json_value_get_object>
 802159c:	4603      	mov	r3, r0
}
 802159e:	4618      	mov	r0, r3
 80215a0:	3708      	adds	r7, #8
 80215a2:	46bd      	mov	sp, r7
 80215a4:	bd80      	pop	{r7, pc}

080215a6 <json_array_get_count>:

int json_array_get_boolean(const JSON_Array *array, size_t index) {
    return json_value_get_boolean(json_array_get_value(array, index));
}

size_t json_array_get_count(const JSON_Array *array) {
 80215a6:	b480      	push	{r7}
 80215a8:	b083      	sub	sp, #12
 80215aa:	af00      	add	r7, sp, #0
 80215ac:	6078      	str	r0, [r7, #4]
    return array ? array->count : 0;
 80215ae:	687b      	ldr	r3, [r7, #4]
 80215b0:	2b00      	cmp	r3, #0
 80215b2:	d002      	beq.n	80215ba <json_array_get_count+0x14>
 80215b4:	687b      	ldr	r3, [r7, #4]
 80215b6:	689b      	ldr	r3, [r3, #8]
 80215b8:	e000      	b.n	80215bc <json_array_get_count+0x16>
 80215ba:	2300      	movs	r3, #0
}
 80215bc:	4618      	mov	r0, r3
 80215be:	370c      	adds	r7, #12
 80215c0:	46bd      	mov	sp, r7
 80215c2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80215c6:	4770      	bx	lr

080215c8 <json_array_get_wrapping_value>:

JSON_Value * json_array_get_wrapping_value(const JSON_Array *array) {
 80215c8:	b480      	push	{r7}
 80215ca:	b083      	sub	sp, #12
 80215cc:	af00      	add	r7, sp, #0
 80215ce:	6078      	str	r0, [r7, #4]
    if (!array) {
 80215d0:	687b      	ldr	r3, [r7, #4]
 80215d2:	2b00      	cmp	r3, #0
 80215d4:	d101      	bne.n	80215da <json_array_get_wrapping_value+0x12>
        return NULL;
 80215d6:	2300      	movs	r3, #0
 80215d8:	e001      	b.n	80215de <json_array_get_wrapping_value+0x16>
    }
    return array->wrapping_value;
 80215da:	687b      	ldr	r3, [r7, #4]
 80215dc:	681b      	ldr	r3, [r3, #0]
}
 80215de:	4618      	mov	r0, r3
 80215e0:	370c      	adds	r7, #12
 80215e2:	46bd      	mov	sp, r7
 80215e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80215e8:	4770      	bx	lr

080215ea <json_value_get_type>:

/* JSON Value API */
JSON_Value_Type json_value_get_type(const JSON_Value *value) {
 80215ea:	b480      	push	{r7}
 80215ec:	b083      	sub	sp, #12
 80215ee:	af00      	add	r7, sp, #0
 80215f0:	6078      	str	r0, [r7, #4]
    return value ? value->type : JSONError;
 80215f2:	687b      	ldr	r3, [r7, #4]
 80215f4:	2b00      	cmp	r3, #0
 80215f6:	d002      	beq.n	80215fe <json_value_get_type+0x14>
 80215f8:	687b      	ldr	r3, [r7, #4]
 80215fa:	685b      	ldr	r3, [r3, #4]
 80215fc:	e001      	b.n	8021602 <json_value_get_type+0x18>
 80215fe:	f04f 33ff 	mov.w	r3, #4294967295
}
 8021602:	4618      	mov	r0, r3
 8021604:	370c      	adds	r7, #12
 8021606:	46bd      	mov	sp, r7
 8021608:	f85d 7b04 	ldr.w	r7, [sp], #4
 802160c:	4770      	bx	lr

0802160e <json_value_get_object>:

JSON_Object * json_value_get_object(const JSON_Value *value) {
 802160e:	b580      	push	{r7, lr}
 8021610:	b082      	sub	sp, #8
 8021612:	af00      	add	r7, sp, #0
 8021614:	6078      	str	r0, [r7, #4]
    return json_value_get_type(value) == JSONObject ? value->value.object : NULL;
 8021616:	6878      	ldr	r0, [r7, #4]
 8021618:	f7ff ffe7 	bl	80215ea <json_value_get_type>
 802161c:	4603      	mov	r3, r0
 802161e:	2b04      	cmp	r3, #4
 8021620:	d102      	bne.n	8021628 <json_value_get_object+0x1a>
 8021622:	687b      	ldr	r3, [r7, #4]
 8021624:	689b      	ldr	r3, [r3, #8]
 8021626:	e000      	b.n	802162a <json_value_get_object+0x1c>
 8021628:	2300      	movs	r3, #0
}
 802162a:	4618      	mov	r0, r3
 802162c:	3708      	adds	r7, #8
 802162e:	46bd      	mov	sp, r7
 8021630:	bd80      	pop	{r7, pc}

08021632 <json_value_get_array>:

JSON_Array * json_value_get_array(const JSON_Value *value) {
 8021632:	b580      	push	{r7, lr}
 8021634:	b082      	sub	sp, #8
 8021636:	af00      	add	r7, sp, #0
 8021638:	6078      	str	r0, [r7, #4]
    return json_value_get_type(value) == JSONArray ? value->value.array : NULL;
 802163a:	6878      	ldr	r0, [r7, #4]
 802163c:	f7ff ffd5 	bl	80215ea <json_value_get_type>
 8021640:	4603      	mov	r3, r0
 8021642:	2b05      	cmp	r3, #5
 8021644:	d102      	bne.n	802164c <json_value_get_array+0x1a>
 8021646:	687b      	ldr	r3, [r7, #4]
 8021648:	689b      	ldr	r3, [r3, #8]
 802164a:	e000      	b.n	802164e <json_value_get_array+0x1c>
 802164c:	2300      	movs	r3, #0
}
 802164e:	4618      	mov	r0, r3
 8021650:	3708      	adds	r7, #8
 8021652:	46bd      	mov	sp, r7
 8021654:	bd80      	pop	{r7, pc}

08021656 <json_value_get_string_desc>:

static const JSON_String * json_value_get_string_desc(const JSON_Value *value) {
 8021656:	b580      	push	{r7, lr}
 8021658:	b082      	sub	sp, #8
 802165a:	af00      	add	r7, sp, #0
 802165c:	6078      	str	r0, [r7, #4]
    return json_value_get_type(value) == JSONString ? &value->value.string : NULL;
 802165e:	6878      	ldr	r0, [r7, #4]
 8021660:	f7ff ffc3 	bl	80215ea <json_value_get_type>
 8021664:	4603      	mov	r3, r0
 8021666:	2b02      	cmp	r3, #2
 8021668:	d102      	bne.n	8021670 <json_value_get_string_desc+0x1a>
 802166a:	687b      	ldr	r3, [r7, #4]
 802166c:	3308      	adds	r3, #8
 802166e:	e000      	b.n	8021672 <json_value_get_string_desc+0x1c>
 8021670:	2300      	movs	r3, #0
}
 8021672:	4618      	mov	r0, r3
 8021674:	3708      	adds	r7, #8
 8021676:	46bd      	mov	sp, r7
 8021678:	bd80      	pop	{r7, pc}

0802167a <json_value_get_string>:

const char * json_value_get_string(const JSON_Value *value) {
 802167a:	b580      	push	{r7, lr}
 802167c:	b084      	sub	sp, #16
 802167e:	af00      	add	r7, sp, #0
 8021680:	6078      	str	r0, [r7, #4]
    const JSON_String *str = json_value_get_string_desc(value);
 8021682:	6878      	ldr	r0, [r7, #4]
 8021684:	f7ff ffe7 	bl	8021656 <json_value_get_string_desc>
 8021688:	60f8      	str	r0, [r7, #12]
    return str ? str->chars : NULL;
 802168a:	68fb      	ldr	r3, [r7, #12]
 802168c:	2b00      	cmp	r3, #0
 802168e:	d002      	beq.n	8021696 <json_value_get_string+0x1c>
 8021690:	68fb      	ldr	r3, [r7, #12]
 8021692:	681b      	ldr	r3, [r3, #0]
 8021694:	e000      	b.n	8021698 <json_value_get_string+0x1e>
 8021696:	2300      	movs	r3, #0
}
 8021698:	4618      	mov	r0, r3
 802169a:	3710      	adds	r7, #16
 802169c:	46bd      	mov	sp, r7
 802169e:	bd80      	pop	{r7, pc}

080216a0 <json_value_get_string_len>:

size_t json_value_get_string_len(const JSON_Value *value) {
 80216a0:	b580      	push	{r7, lr}
 80216a2:	b084      	sub	sp, #16
 80216a4:	af00      	add	r7, sp, #0
 80216a6:	6078      	str	r0, [r7, #4]
    const JSON_String *str = json_value_get_string_desc(value);
 80216a8:	6878      	ldr	r0, [r7, #4]
 80216aa:	f7ff ffd4 	bl	8021656 <json_value_get_string_desc>
 80216ae:	60f8      	str	r0, [r7, #12]
    return str ? str->length : 0;
 80216b0:	68fb      	ldr	r3, [r7, #12]
 80216b2:	2b00      	cmp	r3, #0
 80216b4:	d002      	beq.n	80216bc <json_value_get_string_len+0x1c>
 80216b6:	68fb      	ldr	r3, [r7, #12]
 80216b8:	685b      	ldr	r3, [r3, #4]
 80216ba:	e000      	b.n	80216be <json_value_get_string_len+0x1e>
 80216bc:	2300      	movs	r3, #0
}
 80216be:	4618      	mov	r0, r3
 80216c0:	3710      	adds	r7, #16
 80216c2:	46bd      	mov	sp, r7
 80216c4:	bd80      	pop	{r7, pc}

080216c6 <json_value_get_number>:

double json_value_get_number(const JSON_Value *value) {
 80216c6:	b580      	push	{r7, lr}
 80216c8:	b082      	sub	sp, #8
 80216ca:	af00      	add	r7, sp, #0
 80216cc:	6078      	str	r0, [r7, #4]
    return json_value_get_type(value) == JSONNumber ? value->value.number : 0;
 80216ce:	6878      	ldr	r0, [r7, #4]
 80216d0:	f7ff ff8b 	bl	80215ea <json_value_get_type>
 80216d4:	4603      	mov	r3, r0
 80216d6:	2b03      	cmp	r3, #3
 80216d8:	d103      	bne.n	80216e2 <json_value_get_number+0x1c>
 80216da:	687b      	ldr	r3, [r7, #4]
 80216dc:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 80216e0:	e003      	b.n	80216ea <json_value_get_number+0x24>
 80216e2:	f04f 0200 	mov.w	r2, #0
 80216e6:	f04f 0300 	mov.w	r3, #0
}
 80216ea:	4610      	mov	r0, r2
 80216ec:	4619      	mov	r1, r3
 80216ee:	3708      	adds	r7, #8
 80216f0:	46bd      	mov	sp, r7
 80216f2:	bd80      	pop	{r7, pc}

080216f4 <json_value_get_boolean>:

int json_value_get_boolean(const JSON_Value *value) {
 80216f4:	b580      	push	{r7, lr}
 80216f6:	b082      	sub	sp, #8
 80216f8:	af00      	add	r7, sp, #0
 80216fa:	6078      	str	r0, [r7, #4]
    return json_value_get_type(value) == JSONBoolean ? value->value.boolean : -1;
 80216fc:	6878      	ldr	r0, [r7, #4]
 80216fe:	f7ff ff74 	bl	80215ea <json_value_get_type>
 8021702:	4603      	mov	r3, r0
 8021704:	2b06      	cmp	r3, #6
 8021706:	d102      	bne.n	802170e <json_value_get_boolean+0x1a>
 8021708:	687b      	ldr	r3, [r7, #4]
 802170a:	689b      	ldr	r3, [r3, #8]
 802170c:	e001      	b.n	8021712 <json_value_get_boolean+0x1e>
 802170e:	f04f 33ff 	mov.w	r3, #4294967295
}
 8021712:	4618      	mov	r0, r3
 8021714:	3708      	adds	r7, #8
 8021716:	46bd      	mov	sp, r7
 8021718:	bd80      	pop	{r7, pc}

0802171a <json_value_get_parent>:

JSON_Value * json_value_get_parent (const JSON_Value *value) {
 802171a:	b480      	push	{r7}
 802171c:	b083      	sub	sp, #12
 802171e:	af00      	add	r7, sp, #0
 8021720:	6078      	str	r0, [r7, #4]
    return value ? value->parent : NULL;
 8021722:	687b      	ldr	r3, [r7, #4]
 8021724:	2b00      	cmp	r3, #0
 8021726:	d002      	beq.n	802172e <json_value_get_parent+0x14>
 8021728:	687b      	ldr	r3, [r7, #4]
 802172a:	681b      	ldr	r3, [r3, #0]
 802172c:	e000      	b.n	8021730 <json_value_get_parent+0x16>
 802172e:	2300      	movs	r3, #0
}
 8021730:	4618      	mov	r0, r3
 8021732:	370c      	adds	r7, #12
 8021734:	46bd      	mov	sp, r7
 8021736:	f85d 7b04 	ldr.w	r7, [sp], #4
 802173a:	4770      	bx	lr

0802173c <json_value_free>:

void json_value_free(JSON_Value *value) {
 802173c:	b580      	push	{r7, lr}
 802173e:	b082      	sub	sp, #8
 8021740:	af00      	add	r7, sp, #0
 8021742:	6078      	str	r0, [r7, #4]
    switch (json_value_get_type(value)) {
 8021744:	6878      	ldr	r0, [r7, #4]
 8021746:	f7ff ff50 	bl	80215ea <json_value_get_type>
 802174a:	4603      	mov	r3, r0
 802174c:	2b05      	cmp	r3, #5
 802174e:	d012      	beq.n	8021776 <json_value_free+0x3a>
 8021750:	2b05      	cmp	r3, #5
 8021752:	dc16      	bgt.n	8021782 <json_value_free+0x46>
 8021754:	2b02      	cmp	r3, #2
 8021756:	d007      	beq.n	8021768 <json_value_free+0x2c>
 8021758:	2b04      	cmp	r3, #4
 802175a:	d112      	bne.n	8021782 <json_value_free+0x46>
        case JSONObject:
            json_object_free(value->value.object);
 802175c:	687b      	ldr	r3, [r7, #4]
 802175e:	689b      	ldr	r3, [r3, #8]
 8021760:	4618      	mov	r0, r3
 8021762:	f7fd fe6d 	bl	801f440 <json_object_free>
            break;
 8021766:	e00d      	b.n	8021784 <json_value_free+0x48>
        case JSONString:
            parson_free(value->value.string.chars);
 8021768:	4b0a      	ldr	r3, [pc, #40]	@ (8021794 <json_value_free+0x58>)
 802176a:	681b      	ldr	r3, [r3, #0]
 802176c:	687a      	ldr	r2, [r7, #4]
 802176e:	6892      	ldr	r2, [r2, #8]
 8021770:	4610      	mov	r0, r2
 8021772:	4798      	blx	r3
            break;
 8021774:	e006      	b.n	8021784 <json_value_free+0x48>
        case JSONArray:
            json_array_free(value->value.array);
 8021776:	687b      	ldr	r3, [r7, #4]
 8021778:	689b      	ldr	r3, [r3, #8]
 802177a:	4618      	mov	r0, r3
 802177c:	f7fd ff0a 	bl	801f594 <json_array_free>
            break;
 8021780:	e000      	b.n	8021784 <json_value_free+0x48>
        default:
            break;
 8021782:	bf00      	nop
    }
    parson_free(value);
 8021784:	4b03      	ldr	r3, [pc, #12]	@ (8021794 <json_value_free+0x58>)
 8021786:	681b      	ldr	r3, [r3, #0]
 8021788:	6878      	ldr	r0, [r7, #4]
 802178a:	4798      	blx	r3
}
 802178c:	bf00      	nop
 802178e:	3708      	adds	r7, #8
 8021790:	46bd      	mov	sp, r7
 8021792:	bd80      	pop	{r7, pc}
 8021794:	20000214 	.word	0x20000214

08021798 <json_value_init_object>:

JSON_Value * json_value_init_object(void) {
 8021798:	b580      	push	{r7, lr}
 802179a:	b082      	sub	sp, #8
 802179c:	af00      	add	r7, sp, #0
    JSON_Value *new_value = (JSON_Value*)parson_malloc(sizeof(JSON_Value));
 802179e:	4b12      	ldr	r3, [pc, #72]	@ (80217e8 <json_value_init_object+0x50>)
 80217a0:	681b      	ldr	r3, [r3, #0]
 80217a2:	2010      	movs	r0, #16
 80217a4:	4798      	blx	r3
 80217a6:	6078      	str	r0, [r7, #4]
    if (!new_value) {
 80217a8:	687b      	ldr	r3, [r7, #4]
 80217aa:	2b00      	cmp	r3, #0
 80217ac:	d101      	bne.n	80217b2 <json_value_init_object+0x1a>
        return NULL;
 80217ae:	2300      	movs	r3, #0
 80217b0:	e016      	b.n	80217e0 <json_value_init_object+0x48>
    }
    new_value->parent = NULL;
 80217b2:	687b      	ldr	r3, [r7, #4]
 80217b4:	2200      	movs	r2, #0
 80217b6:	601a      	str	r2, [r3, #0]
    new_value->type = JSONObject;
 80217b8:	687b      	ldr	r3, [r7, #4]
 80217ba:	2204      	movs	r2, #4
 80217bc:	605a      	str	r2, [r3, #4]
    new_value->value.object = json_object_make(new_value);
 80217be:	6878      	ldr	r0, [r7, #4]
 80217c0:	f7fd fa02 	bl	801ebc8 <json_object_make>
 80217c4:	4602      	mov	r2, r0
 80217c6:	687b      	ldr	r3, [r7, #4]
 80217c8:	609a      	str	r2, [r3, #8]
    if (!new_value->value.object) {
 80217ca:	687b      	ldr	r3, [r7, #4]
 80217cc:	689b      	ldr	r3, [r3, #8]
 80217ce:	2b00      	cmp	r3, #0
 80217d0:	d105      	bne.n	80217de <json_value_init_object+0x46>
        parson_free(new_value);
 80217d2:	4b06      	ldr	r3, [pc, #24]	@ (80217ec <json_value_init_object+0x54>)
 80217d4:	681b      	ldr	r3, [r3, #0]
 80217d6:	6878      	ldr	r0, [r7, #4]
 80217d8:	4798      	blx	r3
        return NULL;
 80217da:	2300      	movs	r3, #0
 80217dc:	e000      	b.n	80217e0 <json_value_init_object+0x48>
    }
    return new_value;
 80217de:	687b      	ldr	r3, [r7, #4]
}
 80217e0:	4618      	mov	r0, r3
 80217e2:	3708      	adds	r7, #8
 80217e4:	46bd      	mov	sp, r7
 80217e6:	bd80      	pop	{r7, pc}
 80217e8:	20000210 	.word	0x20000210
 80217ec:	20000214 	.word	0x20000214

080217f0 <json_value_init_array>:

JSON_Value * json_value_init_array(void) {
 80217f0:	b580      	push	{r7, lr}
 80217f2:	b082      	sub	sp, #8
 80217f4:	af00      	add	r7, sp, #0
    JSON_Value *new_value = (JSON_Value*)parson_malloc(sizeof(JSON_Value));
 80217f6:	4b12      	ldr	r3, [pc, #72]	@ (8021840 <json_value_init_array+0x50>)
 80217f8:	681b      	ldr	r3, [r3, #0]
 80217fa:	2010      	movs	r0, #16
 80217fc:	4798      	blx	r3
 80217fe:	6078      	str	r0, [r7, #4]
    if (!new_value) {
 8021800:	687b      	ldr	r3, [r7, #4]
 8021802:	2b00      	cmp	r3, #0
 8021804:	d101      	bne.n	802180a <json_value_init_array+0x1a>
        return NULL;
 8021806:	2300      	movs	r3, #0
 8021808:	e016      	b.n	8021838 <json_value_init_array+0x48>
    }
    new_value->parent = NULL;
 802180a:	687b      	ldr	r3, [r7, #4]
 802180c:	2200      	movs	r2, #0
 802180e:	601a      	str	r2, [r3, #0]
    new_value->type = JSONArray;
 8021810:	687b      	ldr	r3, [r7, #4]
 8021812:	2205      	movs	r2, #5
 8021814:	605a      	str	r2, [r3, #4]
    new_value->value.array = json_array_make(new_value);
 8021816:	6878      	ldr	r0, [r7, #4]
 8021818:	f7fd fe26 	bl	801f468 <json_array_make>
 802181c:	4602      	mov	r2, r0
 802181e:	687b      	ldr	r3, [r7, #4]
 8021820:	609a      	str	r2, [r3, #8]
    if (!new_value->value.array) {
 8021822:	687b      	ldr	r3, [r7, #4]
 8021824:	689b      	ldr	r3, [r3, #8]
 8021826:	2b00      	cmp	r3, #0
 8021828:	d105      	bne.n	8021836 <json_value_init_array+0x46>
        parson_free(new_value);
 802182a:	4b06      	ldr	r3, [pc, #24]	@ (8021844 <json_value_init_array+0x54>)
 802182c:	681b      	ldr	r3, [r3, #0]
 802182e:	6878      	ldr	r0, [r7, #4]
 8021830:	4798      	blx	r3
        return NULL;
 8021832:	2300      	movs	r3, #0
 8021834:	e000      	b.n	8021838 <json_value_init_array+0x48>
    }
    return new_value;
 8021836:	687b      	ldr	r3, [r7, #4]
}
 8021838:	4618      	mov	r0, r3
 802183a:	3708      	adds	r7, #8
 802183c:	46bd      	mov	sp, r7
 802183e:	bd80      	pop	{r7, pc}
 8021840:	20000210 	.word	0x20000210
 8021844:	20000214 	.word	0x20000214

08021848 <json_value_init_string>:

JSON_Value * json_value_init_string(const char *string) {
 8021848:	b580      	push	{r7, lr}
 802184a:	b082      	sub	sp, #8
 802184c:	af00      	add	r7, sp, #0
 802184e:	6078      	str	r0, [r7, #4]
    if (string == NULL) {
 8021850:	687b      	ldr	r3, [r7, #4]
 8021852:	2b00      	cmp	r3, #0
 8021854:	d101      	bne.n	802185a <json_value_init_string+0x12>
        return NULL;
 8021856:	2300      	movs	r3, #0
 8021858:	e008      	b.n	802186c <json_value_init_string+0x24>
    }
    return json_value_init_string_with_len(string, strlen(string));
 802185a:	6878      	ldr	r0, [r7, #4]
 802185c:	f7de fd16 	bl	800028c <strlen>
 8021860:	4603      	mov	r3, r0
 8021862:	4619      	mov	r1, r3
 8021864:	6878      	ldr	r0, [r7, #4]
 8021866:	f000 f805 	bl	8021874 <json_value_init_string_with_len>
 802186a:	4603      	mov	r3, r0
}
 802186c:	4618      	mov	r0, r3
 802186e:	3708      	adds	r7, #8
 8021870:	46bd      	mov	sp, r7
 8021872:	bd80      	pop	{r7, pc}

08021874 <json_value_init_string_with_len>:

JSON_Value * json_value_init_string_with_len(const char *string, size_t length) {
 8021874:	b580      	push	{r7, lr}
 8021876:	b084      	sub	sp, #16
 8021878:	af00      	add	r7, sp, #0
 802187a:	6078      	str	r0, [r7, #4]
 802187c:	6039      	str	r1, [r7, #0]
    char *copy = NULL;
 802187e:	2300      	movs	r3, #0
 8021880:	60fb      	str	r3, [r7, #12]
    JSON_Value *value;
    if (string == NULL) {
 8021882:	687b      	ldr	r3, [r7, #4]
 8021884:	2b00      	cmp	r3, #0
 8021886:	d101      	bne.n	802188c <json_value_init_string_with_len+0x18>
        return NULL;
 8021888:	2300      	movs	r3, #0
 802188a:	e01f      	b.n	80218cc <json_value_init_string_with_len+0x58>
    }
    if (!is_valid_utf8(string, length)) {
 802188c:	6839      	ldr	r1, [r7, #0]
 802188e:	6878      	ldr	r0, [r7, #4]
 8021890:	f7fd f908 	bl	801eaa4 <is_valid_utf8>
 8021894:	4603      	mov	r3, r0
 8021896:	2b00      	cmp	r3, #0
 8021898:	d101      	bne.n	802189e <json_value_init_string_with_len+0x2a>
        return NULL;
 802189a:	2300      	movs	r3, #0
 802189c:	e016      	b.n	80218cc <json_value_init_string_with_len+0x58>
    }
    copy = parson_strndup(string, length);
 802189e:	6839      	ldr	r1, [r7, #0]
 80218a0:	6878      	ldr	r0, [r7, #4]
 80218a2:	f7fc ff49 	bl	801e738 <parson_strndup>
 80218a6:	60f8      	str	r0, [r7, #12]
    if (copy == NULL) {
 80218a8:	68fb      	ldr	r3, [r7, #12]
 80218aa:	2b00      	cmp	r3, #0
 80218ac:	d101      	bne.n	80218b2 <json_value_init_string_with_len+0x3e>
        return NULL;
 80218ae:	2300      	movs	r3, #0
 80218b0:	e00c      	b.n	80218cc <json_value_init_string_with_len+0x58>
    }
    value = json_value_init_string_no_copy(copy, length);
 80218b2:	6839      	ldr	r1, [r7, #0]
 80218b4:	68f8      	ldr	r0, [r7, #12]
 80218b6:	f7fd fe95 	bl	801f5e4 <json_value_init_string_no_copy>
 80218ba:	60b8      	str	r0, [r7, #8]
    if (value == NULL) {
 80218bc:	68bb      	ldr	r3, [r7, #8]
 80218be:	2b00      	cmp	r3, #0
 80218c0:	d103      	bne.n	80218ca <json_value_init_string_with_len+0x56>
        parson_free(copy);
 80218c2:	4b04      	ldr	r3, [pc, #16]	@ (80218d4 <json_value_init_string_with_len+0x60>)
 80218c4:	681b      	ldr	r3, [r3, #0]
 80218c6:	68f8      	ldr	r0, [r7, #12]
 80218c8:	4798      	blx	r3
    }
    return value;
 80218ca:	68bb      	ldr	r3, [r7, #8]
}
 80218cc:	4618      	mov	r0, r3
 80218ce:	3710      	adds	r7, #16
 80218d0:	46bd      	mov	sp, r7
 80218d2:	bd80      	pop	{r7, pc}
 80218d4:	20000214 	.word	0x20000214

080218d8 <json_value_init_number>:

JSON_Value * json_value_init_number(double number) {
 80218d8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80218da:	b085      	sub	sp, #20
 80218dc:	af00      	add	r7, sp, #0
 80218de:	e9c7 0100 	strd	r0, r1, [r7]
    JSON_Value *new_value = NULL;
 80218e2:	2300      	movs	r3, #0
 80218e4:	60fb      	str	r3, [r7, #12]
    if (IS_NUMBER_INVALID(number)) {
 80218e6:	e9d7 2300 	ldrd	r2, r3, [r7]
 80218ea:	e9d7 0100 	ldrd	r0, r1, [r7]
 80218ee:	f7df f92b 	bl	8000b48 <__aeabi_dcmpun>
 80218f2:	4603      	mov	r3, r0
 80218f4:	2b00      	cmp	r3, #0
 80218f6:	d121      	bne.n	802193c <json_value_init_number+0x64>
 80218f8:	683c      	ldr	r4, [r7, #0]
 80218fa:	687b      	ldr	r3, [r7, #4]
 80218fc:	f023 4500 	bic.w	r5, r3, #2147483648	@ 0x80000000
 8021900:	2301      	movs	r3, #1
 8021902:	461e      	mov	r6, r3
 8021904:	f04f 32ff 	mov.w	r2, #4294967295
 8021908:	4b1a      	ldr	r3, [pc, #104]	@ (8021974 <json_value_init_number+0x9c>)
 802190a:	4620      	mov	r0, r4
 802190c:	4629      	mov	r1, r5
 802190e:	f7df f91b 	bl	8000b48 <__aeabi_dcmpun>
 8021912:	4603      	mov	r3, r0
 8021914:	2b00      	cmp	r3, #0
 8021916:	d10b      	bne.n	8021930 <json_value_init_number+0x58>
 8021918:	f04f 32ff 	mov.w	r2, #4294967295
 802191c:	4b15      	ldr	r3, [pc, #84]	@ (8021974 <json_value_init_number+0x9c>)
 802191e:	4620      	mov	r0, r4
 8021920:	4629      	mov	r1, r5
 8021922:	f7df f8f3 	bl	8000b0c <__aeabi_dcmple>
 8021926:	4603      	mov	r3, r0
 8021928:	2b00      	cmp	r3, #0
 802192a:	d101      	bne.n	8021930 <json_value_init_number+0x58>
 802192c:	2300      	movs	r3, #0
 802192e:	461e      	mov	r6, r3
 8021930:	b2f3      	uxtb	r3, r6
 8021932:	f083 0301 	eor.w	r3, r3, #1
 8021936:	b2db      	uxtb	r3, r3
 8021938:	2b00      	cmp	r3, #0
 802193a:	d001      	beq.n	8021940 <json_value_init_number+0x68>
        return NULL;
 802193c:	2300      	movs	r3, #0
 802193e:	e015      	b.n	802196c <json_value_init_number+0x94>
    }
    new_value = (JSON_Value*)parson_malloc(sizeof(JSON_Value));
 8021940:	4b0d      	ldr	r3, [pc, #52]	@ (8021978 <json_value_init_number+0xa0>)
 8021942:	681b      	ldr	r3, [r3, #0]
 8021944:	2010      	movs	r0, #16
 8021946:	4798      	blx	r3
 8021948:	60f8      	str	r0, [r7, #12]
    if (new_value == NULL) {
 802194a:	68fb      	ldr	r3, [r7, #12]
 802194c:	2b00      	cmp	r3, #0
 802194e:	d101      	bne.n	8021954 <json_value_init_number+0x7c>
        return NULL;
 8021950:	2300      	movs	r3, #0
 8021952:	e00b      	b.n	802196c <json_value_init_number+0x94>
    }
    new_value->parent = NULL;
 8021954:	68fb      	ldr	r3, [r7, #12]
 8021956:	2200      	movs	r2, #0
 8021958:	601a      	str	r2, [r3, #0]
    new_value->type = JSONNumber;
 802195a:	68fb      	ldr	r3, [r7, #12]
 802195c:	2203      	movs	r2, #3
 802195e:	605a      	str	r2, [r3, #4]
    new_value->value.number = number;
 8021960:	68f9      	ldr	r1, [r7, #12]
 8021962:	e9d7 2300 	ldrd	r2, r3, [r7]
 8021966:	e9c1 2302 	strd	r2, r3, [r1, #8]
    return new_value;
 802196a:	68fb      	ldr	r3, [r7, #12]
}
 802196c:	4618      	mov	r0, r3
 802196e:	3714      	adds	r7, #20
 8021970:	46bd      	mov	sp, r7
 8021972:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8021974:	7fefffff 	.word	0x7fefffff
 8021978:	20000210 	.word	0x20000210

0802197c <json_value_init_boolean>:

JSON_Value * json_value_init_boolean(int boolean) {
 802197c:	b580      	push	{r7, lr}
 802197e:	b084      	sub	sp, #16
 8021980:	af00      	add	r7, sp, #0
 8021982:	6078      	str	r0, [r7, #4]
    JSON_Value *new_value = (JSON_Value*)parson_malloc(sizeof(JSON_Value));
 8021984:	4b0e      	ldr	r3, [pc, #56]	@ (80219c0 <json_value_init_boolean+0x44>)
 8021986:	681b      	ldr	r3, [r3, #0]
 8021988:	2010      	movs	r0, #16
 802198a:	4798      	blx	r3
 802198c:	60f8      	str	r0, [r7, #12]
    if (!new_value) {
 802198e:	68fb      	ldr	r3, [r7, #12]
 8021990:	2b00      	cmp	r3, #0
 8021992:	d101      	bne.n	8021998 <json_value_init_boolean+0x1c>
        return NULL;
 8021994:	2300      	movs	r3, #0
 8021996:	e00f      	b.n	80219b8 <json_value_init_boolean+0x3c>
    }
    new_value->parent = NULL;
 8021998:	68fb      	ldr	r3, [r7, #12]
 802199a:	2200      	movs	r2, #0
 802199c:	601a      	str	r2, [r3, #0]
    new_value->type = JSONBoolean;
 802199e:	68fb      	ldr	r3, [r7, #12]
 80219a0:	2206      	movs	r2, #6
 80219a2:	605a      	str	r2, [r3, #4]
    new_value->value.boolean = boolean ? 1 : 0;
 80219a4:	687b      	ldr	r3, [r7, #4]
 80219a6:	2b00      	cmp	r3, #0
 80219a8:	bf14      	ite	ne
 80219aa:	2301      	movne	r3, #1
 80219ac:	2300      	moveq	r3, #0
 80219ae:	b2db      	uxtb	r3, r3
 80219b0:	461a      	mov	r2, r3
 80219b2:	68fb      	ldr	r3, [r7, #12]
 80219b4:	609a      	str	r2, [r3, #8]
    return new_value;
 80219b6:	68fb      	ldr	r3, [r7, #12]
}
 80219b8:	4618      	mov	r0, r3
 80219ba:	3710      	adds	r7, #16
 80219bc:	46bd      	mov	sp, r7
 80219be:	bd80      	pop	{r7, pc}
 80219c0:	20000210 	.word	0x20000210

080219c4 <json_value_init_null>:

JSON_Value * json_value_init_null(void) {
 80219c4:	b580      	push	{r7, lr}
 80219c6:	b082      	sub	sp, #8
 80219c8:	af00      	add	r7, sp, #0
    JSON_Value *new_value = (JSON_Value*)parson_malloc(sizeof(JSON_Value));
 80219ca:	4b0a      	ldr	r3, [pc, #40]	@ (80219f4 <json_value_init_null+0x30>)
 80219cc:	681b      	ldr	r3, [r3, #0]
 80219ce:	2010      	movs	r0, #16
 80219d0:	4798      	blx	r3
 80219d2:	6078      	str	r0, [r7, #4]
    if (!new_value) {
 80219d4:	687b      	ldr	r3, [r7, #4]
 80219d6:	2b00      	cmp	r3, #0
 80219d8:	d101      	bne.n	80219de <json_value_init_null+0x1a>
        return NULL;
 80219da:	2300      	movs	r3, #0
 80219dc:	e006      	b.n	80219ec <json_value_init_null+0x28>
    }
    new_value->parent = NULL;
 80219de:	687b      	ldr	r3, [r7, #4]
 80219e0:	2200      	movs	r2, #0
 80219e2:	601a      	str	r2, [r3, #0]
    new_value->type = JSONNull;
 80219e4:	687b      	ldr	r3, [r7, #4]
 80219e6:	2201      	movs	r2, #1
 80219e8:	605a      	str	r2, [r3, #4]
    return new_value;
 80219ea:	687b      	ldr	r3, [r7, #4]
}
 80219ec:	4618      	mov	r0, r3
 80219ee:	3708      	adds	r7, #8
 80219f0:	46bd      	mov	sp, r7
 80219f2:	bd80      	pop	{r7, pc}
 80219f4:	20000210 	.word	0x20000210

080219f8 <json_serialization_size>:
        default:
            return NULL;
    }
}

size_t json_serialization_size(const JSON_Value *value) {
 80219f8:	b580      	push	{r7, lr}
 80219fa:	b096      	sub	sp, #88	@ 0x58
 80219fc:	af02      	add	r7, sp, #8
 80219fe:	6078      	str	r0, [r7, #4]
    char num_buf[PARSON_NUM_BUF_SIZE]; /* recursively allocating buffer on stack is a bad idea, so let's do it only once */
    int res = json_serialize_to_buffer_r(value, NULL, 0, PARSON_FALSE, num_buf);
 8021a00:	f107 030c 	add.w	r3, r7, #12
 8021a04:	9300      	str	r3, [sp, #0]
 8021a06:	2300      	movs	r3, #0
 8021a08:	2200      	movs	r2, #0
 8021a0a:	2100      	movs	r1, #0
 8021a0c:	6878      	ldr	r0, [r7, #4]
 8021a0e:	f7fe fbb7 	bl	8020180 <json_serialize_to_buffer_r>
 8021a12:	64f8      	str	r0, [r7, #76]	@ 0x4c
    return res < 0 ? 0 : (size_t)(res) + 1;
 8021a14:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8021a16:	2b00      	cmp	r3, #0
 8021a18:	db02      	blt.n	8021a20 <json_serialization_size+0x28>
 8021a1a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8021a1c:	3301      	adds	r3, #1
 8021a1e:	e000      	b.n	8021a22 <json_serialization_size+0x2a>
 8021a20:	2300      	movs	r3, #0
}
 8021a22:	4618      	mov	r0, r3
 8021a24:	3750      	adds	r7, #80	@ 0x50
 8021a26:	46bd      	mov	sp, r7
 8021a28:	bd80      	pop	{r7, pc}

08021a2a <json_serialize_to_buffer>:

JSON_Status json_serialize_to_buffer(const JSON_Value *value, char *buf, size_t buf_size_in_bytes) {
 8021a2a:	b580      	push	{r7, lr}
 8021a2c:	b088      	sub	sp, #32
 8021a2e:	af02      	add	r7, sp, #8
 8021a30:	60f8      	str	r0, [r7, #12]
 8021a32:	60b9      	str	r1, [r7, #8]
 8021a34:	607a      	str	r2, [r7, #4]
    int written = -1;
 8021a36:	f04f 33ff 	mov.w	r3, #4294967295
 8021a3a:	617b      	str	r3, [r7, #20]
    size_t needed_size_in_bytes = json_serialization_size(value);
 8021a3c:	68f8      	ldr	r0, [r7, #12]
 8021a3e:	f7ff ffdb 	bl	80219f8 <json_serialization_size>
 8021a42:	6138      	str	r0, [r7, #16]
    if (needed_size_in_bytes == 0 || buf_size_in_bytes < needed_size_in_bytes) {
 8021a44:	693b      	ldr	r3, [r7, #16]
 8021a46:	2b00      	cmp	r3, #0
 8021a48:	d003      	beq.n	8021a52 <json_serialize_to_buffer+0x28>
 8021a4a:	687a      	ldr	r2, [r7, #4]
 8021a4c:	693b      	ldr	r3, [r7, #16]
 8021a4e:	429a      	cmp	r2, r3
 8021a50:	d202      	bcs.n	8021a58 <json_serialize_to_buffer+0x2e>
        return JSONFailure;
 8021a52:	f04f 33ff 	mov.w	r3, #4294967295
 8021a56:	e00f      	b.n	8021a78 <json_serialize_to_buffer+0x4e>
    }
    written = json_serialize_to_buffer_r(value, buf, 0, PARSON_FALSE, NULL);
 8021a58:	2300      	movs	r3, #0
 8021a5a:	9300      	str	r3, [sp, #0]
 8021a5c:	2300      	movs	r3, #0
 8021a5e:	2200      	movs	r2, #0
 8021a60:	68b9      	ldr	r1, [r7, #8]
 8021a62:	68f8      	ldr	r0, [r7, #12]
 8021a64:	f7fe fb8c 	bl	8020180 <json_serialize_to_buffer_r>
 8021a68:	6178      	str	r0, [r7, #20]
    if (written < 0) {
 8021a6a:	697b      	ldr	r3, [r7, #20]
 8021a6c:	2b00      	cmp	r3, #0
 8021a6e:	da02      	bge.n	8021a76 <json_serialize_to_buffer+0x4c>
        return JSONFailure;
 8021a70:	f04f 33ff 	mov.w	r3, #4294967295
 8021a74:	e000      	b.n	8021a78 <json_serialize_to_buffer+0x4e>
    }
    return JSONSuccess;
 8021a76:	2300      	movs	r3, #0
}
 8021a78:	4618      	mov	r0, r3
 8021a7a:	3718      	adds	r7, #24
 8021a7c:	46bd      	mov	sp, r7
 8021a7e:	bd80      	pop	{r7, pc}

08021a80 <json_serialize_to_string>:
    }
    json_free_serialized_string(serialized_string);
    return return_code;
}

char * json_serialize_to_string(const JSON_Value *value) {
 8021a80:	b580      	push	{r7, lr}
 8021a82:	b086      	sub	sp, #24
 8021a84:	af00      	add	r7, sp, #0
 8021a86:	6078      	str	r0, [r7, #4]
    JSON_Status serialization_result = JSONFailure;
 8021a88:	f04f 33ff 	mov.w	r3, #4294967295
 8021a8c:	617b      	str	r3, [r7, #20]
    size_t buf_size_bytes = json_serialization_size(value);
 8021a8e:	6878      	ldr	r0, [r7, #4]
 8021a90:	f7ff ffb2 	bl	80219f8 <json_serialization_size>
 8021a94:	6138      	str	r0, [r7, #16]
    char *buf = NULL;
 8021a96:	2300      	movs	r3, #0
 8021a98:	60fb      	str	r3, [r7, #12]
    if (buf_size_bytes == 0) {
 8021a9a:	693b      	ldr	r3, [r7, #16]
 8021a9c:	2b00      	cmp	r3, #0
 8021a9e:	d101      	bne.n	8021aa4 <json_serialize_to_string+0x24>
        return NULL;
 8021aa0:	2300      	movs	r3, #0
 8021aa2:	e018      	b.n	8021ad6 <json_serialize_to_string+0x56>
    }
    buf = (char*)parson_malloc(buf_size_bytes);
 8021aa4:	4b0e      	ldr	r3, [pc, #56]	@ (8021ae0 <json_serialize_to_string+0x60>)
 8021aa6:	681b      	ldr	r3, [r3, #0]
 8021aa8:	6938      	ldr	r0, [r7, #16]
 8021aaa:	4798      	blx	r3
 8021aac:	60f8      	str	r0, [r7, #12]
    if (buf == NULL) {
 8021aae:	68fb      	ldr	r3, [r7, #12]
 8021ab0:	2b00      	cmp	r3, #0
 8021ab2:	d101      	bne.n	8021ab8 <json_serialize_to_string+0x38>
        return NULL;
 8021ab4:	2300      	movs	r3, #0
 8021ab6:	e00e      	b.n	8021ad6 <json_serialize_to_string+0x56>
    }
    serialization_result = json_serialize_to_buffer(value, buf, buf_size_bytes);
 8021ab8:	693a      	ldr	r2, [r7, #16]
 8021aba:	68f9      	ldr	r1, [r7, #12]
 8021abc:	6878      	ldr	r0, [r7, #4]
 8021abe:	f7ff ffb4 	bl	8021a2a <json_serialize_to_buffer>
 8021ac2:	6178      	str	r0, [r7, #20]
    if (serialization_result != JSONSuccess) {
 8021ac4:	697b      	ldr	r3, [r7, #20]
 8021ac6:	2b00      	cmp	r3, #0
 8021ac8:	d004      	beq.n	8021ad4 <json_serialize_to_string+0x54>
        json_free_serialized_string(buf);
 8021aca:	68f8      	ldr	r0, [r7, #12]
 8021acc:	f000 f880 	bl	8021bd0 <json_free_serialized_string>
        return NULL;
 8021ad0:	2300      	movs	r3, #0
 8021ad2:	e000      	b.n	8021ad6 <json_serialize_to_string+0x56>
    }
    return buf;
 8021ad4:	68fb      	ldr	r3, [r7, #12]
}
 8021ad6:	4618      	mov	r0, r3
 8021ad8:	3718      	adds	r7, #24
 8021ada:	46bd      	mov	sp, r7
 8021adc:	bd80      	pop	{r7, pc}
 8021ade:	bf00      	nop
 8021ae0:	20000210 	.word	0x20000210

08021ae4 <json_serialization_size_pretty>:

size_t json_serialization_size_pretty(const JSON_Value *value) {
 8021ae4:	b580      	push	{r7, lr}
 8021ae6:	b096      	sub	sp, #88	@ 0x58
 8021ae8:	af02      	add	r7, sp, #8
 8021aea:	6078      	str	r0, [r7, #4]
    char num_buf[PARSON_NUM_BUF_SIZE]; /* recursively allocating buffer on stack is a bad idea, so let's do it only once */
    int res = json_serialize_to_buffer_r(value, NULL, 0, PARSON_TRUE, num_buf);
 8021aec:	f107 030c 	add.w	r3, r7, #12
 8021af0:	9300      	str	r3, [sp, #0]
 8021af2:	2301      	movs	r3, #1
 8021af4:	2200      	movs	r2, #0
 8021af6:	2100      	movs	r1, #0
 8021af8:	6878      	ldr	r0, [r7, #4]
 8021afa:	f7fe fb41 	bl	8020180 <json_serialize_to_buffer_r>
 8021afe:	64f8      	str	r0, [r7, #76]	@ 0x4c
    return res < 0 ? 0 : (size_t)(res) + 1;
 8021b00:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8021b02:	2b00      	cmp	r3, #0
 8021b04:	db02      	blt.n	8021b0c <json_serialization_size_pretty+0x28>
 8021b06:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8021b08:	3301      	adds	r3, #1
 8021b0a:	e000      	b.n	8021b0e <json_serialization_size_pretty+0x2a>
 8021b0c:	2300      	movs	r3, #0
}
 8021b0e:	4618      	mov	r0, r3
 8021b10:	3750      	adds	r7, #80	@ 0x50
 8021b12:	46bd      	mov	sp, r7
 8021b14:	bd80      	pop	{r7, pc}

08021b16 <json_serialize_to_buffer_pretty>:

JSON_Status json_serialize_to_buffer_pretty(const JSON_Value *value, char *buf, size_t buf_size_in_bytes) {
 8021b16:	b580      	push	{r7, lr}
 8021b18:	b088      	sub	sp, #32
 8021b1a:	af02      	add	r7, sp, #8
 8021b1c:	60f8      	str	r0, [r7, #12]
 8021b1e:	60b9      	str	r1, [r7, #8]
 8021b20:	607a      	str	r2, [r7, #4]
    int written = -1;
 8021b22:	f04f 33ff 	mov.w	r3, #4294967295
 8021b26:	617b      	str	r3, [r7, #20]
    size_t needed_size_in_bytes = json_serialization_size_pretty(value);
 8021b28:	68f8      	ldr	r0, [r7, #12]
 8021b2a:	f7ff ffdb 	bl	8021ae4 <json_serialization_size_pretty>
 8021b2e:	6138      	str	r0, [r7, #16]
    if (needed_size_in_bytes == 0 || buf_size_in_bytes < needed_size_in_bytes) {
 8021b30:	693b      	ldr	r3, [r7, #16]
 8021b32:	2b00      	cmp	r3, #0
 8021b34:	d003      	beq.n	8021b3e <json_serialize_to_buffer_pretty+0x28>
 8021b36:	687a      	ldr	r2, [r7, #4]
 8021b38:	693b      	ldr	r3, [r7, #16]
 8021b3a:	429a      	cmp	r2, r3
 8021b3c:	d202      	bcs.n	8021b44 <json_serialize_to_buffer_pretty+0x2e>
        return JSONFailure;
 8021b3e:	f04f 33ff 	mov.w	r3, #4294967295
 8021b42:	e00f      	b.n	8021b64 <json_serialize_to_buffer_pretty+0x4e>
    }
    written = json_serialize_to_buffer_r(value, buf, 0, PARSON_TRUE, NULL);
 8021b44:	2300      	movs	r3, #0
 8021b46:	9300      	str	r3, [sp, #0]
 8021b48:	2301      	movs	r3, #1
 8021b4a:	2200      	movs	r2, #0
 8021b4c:	68b9      	ldr	r1, [r7, #8]
 8021b4e:	68f8      	ldr	r0, [r7, #12]
 8021b50:	f7fe fb16 	bl	8020180 <json_serialize_to_buffer_r>
 8021b54:	6178      	str	r0, [r7, #20]
    if (written < 0) {
 8021b56:	697b      	ldr	r3, [r7, #20]
 8021b58:	2b00      	cmp	r3, #0
 8021b5a:	da02      	bge.n	8021b62 <json_serialize_to_buffer_pretty+0x4c>
        return JSONFailure;
 8021b5c:	f04f 33ff 	mov.w	r3, #4294967295
 8021b60:	e000      	b.n	8021b64 <json_serialize_to_buffer_pretty+0x4e>
    }
    return JSONSuccess;
 8021b62:	2300      	movs	r3, #0
}
 8021b64:	4618      	mov	r0, r3
 8021b66:	3718      	adds	r7, #24
 8021b68:	46bd      	mov	sp, r7
 8021b6a:	bd80      	pop	{r7, pc}

08021b6c <json_serialize_to_string_pretty>:
    }
    json_free_serialized_string(serialized_string);
    return return_code;
}

char * json_serialize_to_string_pretty(const JSON_Value *value) {
 8021b6c:	b580      	push	{r7, lr}
 8021b6e:	b086      	sub	sp, #24
 8021b70:	af00      	add	r7, sp, #0
 8021b72:	6078      	str	r0, [r7, #4]
    JSON_Status serialization_result = JSONFailure;
 8021b74:	f04f 33ff 	mov.w	r3, #4294967295
 8021b78:	617b      	str	r3, [r7, #20]
    size_t buf_size_bytes = json_serialization_size_pretty(value);
 8021b7a:	6878      	ldr	r0, [r7, #4]
 8021b7c:	f7ff ffb2 	bl	8021ae4 <json_serialization_size_pretty>
 8021b80:	6138      	str	r0, [r7, #16]
    char *buf = NULL;
 8021b82:	2300      	movs	r3, #0
 8021b84:	60fb      	str	r3, [r7, #12]
    if (buf_size_bytes == 0) {
 8021b86:	693b      	ldr	r3, [r7, #16]
 8021b88:	2b00      	cmp	r3, #0
 8021b8a:	d101      	bne.n	8021b90 <json_serialize_to_string_pretty+0x24>
        return NULL;
 8021b8c:	2300      	movs	r3, #0
 8021b8e:	e018      	b.n	8021bc2 <json_serialize_to_string_pretty+0x56>
    }
    buf = (char*)parson_malloc(buf_size_bytes);
 8021b90:	4b0e      	ldr	r3, [pc, #56]	@ (8021bcc <json_serialize_to_string_pretty+0x60>)
 8021b92:	681b      	ldr	r3, [r3, #0]
 8021b94:	6938      	ldr	r0, [r7, #16]
 8021b96:	4798      	blx	r3
 8021b98:	60f8      	str	r0, [r7, #12]
    if (buf == NULL) {
 8021b9a:	68fb      	ldr	r3, [r7, #12]
 8021b9c:	2b00      	cmp	r3, #0
 8021b9e:	d101      	bne.n	8021ba4 <json_serialize_to_string_pretty+0x38>
        return NULL;
 8021ba0:	2300      	movs	r3, #0
 8021ba2:	e00e      	b.n	8021bc2 <json_serialize_to_string_pretty+0x56>
    }
    serialization_result = json_serialize_to_buffer_pretty(value, buf, buf_size_bytes);
 8021ba4:	693a      	ldr	r2, [r7, #16]
 8021ba6:	68f9      	ldr	r1, [r7, #12]
 8021ba8:	6878      	ldr	r0, [r7, #4]
 8021baa:	f7ff ffb4 	bl	8021b16 <json_serialize_to_buffer_pretty>
 8021bae:	6178      	str	r0, [r7, #20]
    if (serialization_result != JSONSuccess) {
 8021bb0:	697b      	ldr	r3, [r7, #20]
 8021bb2:	2b00      	cmp	r3, #0
 8021bb4:	d004      	beq.n	8021bc0 <json_serialize_to_string_pretty+0x54>
        json_free_serialized_string(buf);
 8021bb6:	68f8      	ldr	r0, [r7, #12]
 8021bb8:	f000 f80a 	bl	8021bd0 <json_free_serialized_string>
        return NULL;
 8021bbc:	2300      	movs	r3, #0
 8021bbe:	e000      	b.n	8021bc2 <json_serialize_to_string_pretty+0x56>
    }
    return buf;
 8021bc0:	68fb      	ldr	r3, [r7, #12]
}
 8021bc2:	4618      	mov	r0, r3
 8021bc4:	3718      	adds	r7, #24
 8021bc6:	46bd      	mov	sp, r7
 8021bc8:	bd80      	pop	{r7, pc}
 8021bca:	bf00      	nop
 8021bcc:	20000210 	.word	0x20000210

08021bd0 <json_free_serialized_string>:

void json_free_serialized_string(char *string) {
 8021bd0:	b580      	push	{r7, lr}
 8021bd2:	b082      	sub	sp, #8
 8021bd4:	af00      	add	r7, sp, #0
 8021bd6:	6078      	str	r0, [r7, #4]
    parson_free(string);
 8021bd8:	4b03      	ldr	r3, [pc, #12]	@ (8021be8 <json_free_serialized_string+0x18>)
 8021bda:	681b      	ldr	r3, [r3, #0]
 8021bdc:	6878      	ldr	r0, [r7, #4]
 8021bde:	4798      	blx	r3
}
 8021be0:	bf00      	nop
 8021be2:	3708      	adds	r7, #8
 8021be4:	46bd      	mov	sp, r7
 8021be6:	bd80      	pop	{r7, pc}
 8021be8:	20000214 	.word	0x20000214

08021bec <json_array_append_value>:
    }
    array->count = 0;
    return JSONSuccess;
}

JSON_Status json_array_append_value(JSON_Array *array, JSON_Value *value) {
 8021bec:	b580      	push	{r7, lr}
 8021bee:	b082      	sub	sp, #8
 8021bf0:	af00      	add	r7, sp, #0
 8021bf2:	6078      	str	r0, [r7, #4]
 8021bf4:	6039      	str	r1, [r7, #0]
    if (array == NULL || value == NULL || value->parent != NULL) {
 8021bf6:	687b      	ldr	r3, [r7, #4]
 8021bf8:	2b00      	cmp	r3, #0
 8021bfa:	d006      	beq.n	8021c0a <json_array_append_value+0x1e>
 8021bfc:	683b      	ldr	r3, [r7, #0]
 8021bfe:	2b00      	cmp	r3, #0
 8021c00:	d003      	beq.n	8021c0a <json_array_append_value+0x1e>
 8021c02:	683b      	ldr	r3, [r7, #0]
 8021c04:	681b      	ldr	r3, [r3, #0]
 8021c06:	2b00      	cmp	r3, #0
 8021c08:	d002      	beq.n	8021c10 <json_array_append_value+0x24>
        return JSONFailure;
 8021c0a:	f04f 33ff 	mov.w	r3, #4294967295
 8021c0e:	e004      	b.n	8021c1a <json_array_append_value+0x2e>
    }
    return json_array_add(array, value);
 8021c10:	6839      	ldr	r1, [r7, #0]
 8021c12:	6878      	ldr	r0, [r7, #4]
 8021c14:	f7fd fc4a 	bl	801f4ac <json_array_add>
 8021c18:	4603      	mov	r3, r0
}
 8021c1a:	4618      	mov	r0, r3
 8021c1c:	3708      	adds	r7, #8
 8021c1e:	46bd      	mov	sp, r7
 8021c20:	bd80      	pop	{r7, pc}

08021c22 <json_object_set_value>:
        return JSONFailure;
    }
    return JSONSuccess;
}

JSON_Status json_object_set_value(JSON_Object *object, const char *name, JSON_Value *value) {
 8021c22:	b580      	push	{r7, lr}
 8021c24:	b08e      	sub	sp, #56	@ 0x38
 8021c26:	af02      	add	r7, sp, #8
 8021c28:	60f8      	str	r0, [r7, #12]
 8021c2a:	60b9      	str	r1, [r7, #8]
 8021c2c:	607a      	str	r2, [r7, #4]
    unsigned long hash = 0;
 8021c2e:	2300      	movs	r3, #0
 8021c30:	62bb      	str	r3, [r7, #40]	@ 0x28
    parson_bool_t found = PARSON_FALSE;
 8021c32:	2300      	movs	r3, #0
 8021c34:	617b      	str	r3, [r7, #20]
    size_t cell_ix = 0;
 8021c36:	2300      	movs	r3, #0
 8021c38:	62fb      	str	r3, [r7, #44]	@ 0x2c
    size_t item_ix = 0;
 8021c3a:	2300      	movs	r3, #0
 8021c3c:	627b      	str	r3, [r7, #36]	@ 0x24
    JSON_Value *old_value = NULL;
 8021c3e:	2300      	movs	r3, #0
 8021c40:	623b      	str	r3, [r7, #32]
    char *key_copy = NULL;
 8021c42:	2300      	movs	r3, #0
 8021c44:	61fb      	str	r3, [r7, #28]

    if (!object || !name || !value || value->parent) {
 8021c46:	68fb      	ldr	r3, [r7, #12]
 8021c48:	2b00      	cmp	r3, #0
 8021c4a:	d009      	beq.n	8021c60 <json_object_set_value+0x3e>
 8021c4c:	68bb      	ldr	r3, [r7, #8]
 8021c4e:	2b00      	cmp	r3, #0
 8021c50:	d006      	beq.n	8021c60 <json_object_set_value+0x3e>
 8021c52:	687b      	ldr	r3, [r7, #4]
 8021c54:	2b00      	cmp	r3, #0
 8021c56:	d003      	beq.n	8021c60 <json_object_set_value+0x3e>
 8021c58:	687b      	ldr	r3, [r7, #4]
 8021c5a:	681b      	ldr	r3, [r3, #0]
 8021c5c:	2b00      	cmp	r3, #0
 8021c5e:	d002      	beq.n	8021c66 <json_object_set_value+0x44>
        return JSONFailure;
 8021c60:	f04f 33ff 	mov.w	r3, #4294967295
 8021c64:	e095      	b.n	8021d92 <json_object_set_value+0x170>
    }
    hash = hash_string(name, strlen(name));
 8021c66:	68b8      	ldr	r0, [r7, #8]
 8021c68:	f7de fb10 	bl	800028c <strlen>
 8021c6c:	4603      	mov	r3, r0
 8021c6e:	4619      	mov	r1, r3
 8021c70:	68b8      	ldr	r0, [r7, #8]
 8021c72:	f7fc ff7d 	bl	801eb70 <hash_string>
 8021c76:	62b8      	str	r0, [r7, #40]	@ 0x28
    found = PARSON_FALSE;
 8021c78:	2300      	movs	r3, #0
 8021c7a:	617b      	str	r3, [r7, #20]
    cell_ix = json_object_get_cell_ix(object, name, strlen(name), hash, &found);
 8021c7c:	68b8      	ldr	r0, [r7, #8]
 8021c7e:	f7de fb05 	bl	800028c <strlen>
 8021c82:	4602      	mov	r2, r0
 8021c84:	f107 0314 	add.w	r3, r7, #20
 8021c88:	9300      	str	r3, [sp, #0]
 8021c8a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8021c8c:	68b9      	ldr	r1, [r7, #8]
 8021c8e:	68f8      	ldr	r0, [r7, #12]
 8021c90:	f7fd f94b 	bl	801ef2a <json_object_get_cell_ix>
 8021c94:	62f8      	str	r0, [r7, #44]	@ 0x2c
    if (found) {
 8021c96:	697b      	ldr	r3, [r7, #20]
 8021c98:	2b00      	cmp	r3, #0
 8021c9a:	d01f      	beq.n	8021cdc <json_object_set_value+0xba>
        item_ix = object->cells[cell_ix];
 8021c9c:	68fb      	ldr	r3, [r7, #12]
 8021c9e:	685a      	ldr	r2, [r3, #4]
 8021ca0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8021ca2:	009b      	lsls	r3, r3, #2
 8021ca4:	4413      	add	r3, r2
 8021ca6:	681b      	ldr	r3, [r3, #0]
 8021ca8:	627b      	str	r3, [r7, #36]	@ 0x24
        old_value = object->values[item_ix];
 8021caa:	68fb      	ldr	r3, [r7, #12]
 8021cac:	691a      	ldr	r2, [r3, #16]
 8021cae:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8021cb0:	009b      	lsls	r3, r3, #2
 8021cb2:	4413      	add	r3, r2
 8021cb4:	681b      	ldr	r3, [r3, #0]
 8021cb6:	623b      	str	r3, [r7, #32]
        json_value_free(old_value);
 8021cb8:	6a38      	ldr	r0, [r7, #32]
 8021cba:	f7ff fd3f 	bl	802173c <json_value_free>
        object->values[item_ix] = value;
 8021cbe:	68fb      	ldr	r3, [r7, #12]
 8021cc0:	691a      	ldr	r2, [r3, #16]
 8021cc2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8021cc4:	009b      	lsls	r3, r3, #2
 8021cc6:	4413      	add	r3, r2
 8021cc8:	687a      	ldr	r2, [r7, #4]
 8021cca:	601a      	str	r2, [r3, #0]
        value->parent = json_object_get_wrapping_value(object);
 8021ccc:	68f8      	ldr	r0, [r7, #12]
 8021cce:	f7ff fc06 	bl	80214de <json_object_get_wrapping_value>
 8021cd2:	4602      	mov	r2, r0
 8021cd4:	687b      	ldr	r3, [r7, #4]
 8021cd6:	601a      	str	r2, [r3, #0]
        return JSONSuccess;
 8021cd8:	2300      	movs	r3, #0
 8021cda:	e05a      	b.n	8021d92 <json_object_set_value+0x170>
    }
    if (object->count >= object->item_capacity) {
 8021cdc:	68fb      	ldr	r3, [r7, #12]
 8021cde:	699a      	ldr	r2, [r3, #24]
 8021ce0:	68fb      	ldr	r3, [r7, #12]
 8021ce2:	69db      	ldr	r3, [r3, #28]
 8021ce4:	429a      	cmp	r2, r3
 8021ce6:	d316      	bcc.n	8021d16 <json_object_set_value+0xf4>
        JSON_Status res = json_object_grow_and_rehash(object);
 8021ce8:	68f8      	ldr	r0, [r7, #12]
 8021cea:	f7fd f8b3 	bl	801ee54 <json_object_grow_and_rehash>
 8021cee:	61b8      	str	r0, [r7, #24]
        if (res != JSONSuccess) {
 8021cf0:	69bb      	ldr	r3, [r7, #24]
 8021cf2:	2b00      	cmp	r3, #0
 8021cf4:	d002      	beq.n	8021cfc <json_object_set_value+0xda>
            return JSONFailure;
 8021cf6:	f04f 33ff 	mov.w	r3, #4294967295
 8021cfa:	e04a      	b.n	8021d92 <json_object_set_value+0x170>
        }
        cell_ix = json_object_get_cell_ix(object, name, strlen(name), hash, &found);
 8021cfc:	68b8      	ldr	r0, [r7, #8]
 8021cfe:	f7de fac5 	bl	800028c <strlen>
 8021d02:	4602      	mov	r2, r0
 8021d04:	f107 0314 	add.w	r3, r7, #20
 8021d08:	9300      	str	r3, [sp, #0]
 8021d0a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8021d0c:	68b9      	ldr	r1, [r7, #8]
 8021d0e:	68f8      	ldr	r0, [r7, #12]
 8021d10:	f7fd f90b 	bl	801ef2a <json_object_get_cell_ix>
 8021d14:	62f8      	str	r0, [r7, #44]	@ 0x2c
    }
    key_copy = parson_strdup(name);
 8021d16:	68b8      	ldr	r0, [r7, #8]
 8021d18:	f7fc fd30 	bl	801e77c <parson_strdup>
 8021d1c:	61f8      	str	r0, [r7, #28]
    if (!key_copy) {
 8021d1e:	69fb      	ldr	r3, [r7, #28]
 8021d20:	2b00      	cmp	r3, #0
 8021d22:	d102      	bne.n	8021d2a <json_object_set_value+0x108>
        return JSONFailure;
 8021d24:	f04f 33ff 	mov.w	r3, #4294967295
 8021d28:	e033      	b.n	8021d92 <json_object_set_value+0x170>
    }
    object->names[object->count] = key_copy;
 8021d2a:	68fb      	ldr	r3, [r7, #12]
 8021d2c:	68da      	ldr	r2, [r3, #12]
 8021d2e:	68fb      	ldr	r3, [r7, #12]
 8021d30:	699b      	ldr	r3, [r3, #24]
 8021d32:	009b      	lsls	r3, r3, #2
 8021d34:	4413      	add	r3, r2
 8021d36:	69fa      	ldr	r2, [r7, #28]
 8021d38:	601a      	str	r2, [r3, #0]
    object->cells[cell_ix] = object->count;
 8021d3a:	68fb      	ldr	r3, [r7, #12]
 8021d3c:	685a      	ldr	r2, [r3, #4]
 8021d3e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8021d40:	009b      	lsls	r3, r3, #2
 8021d42:	4413      	add	r3, r2
 8021d44:	68fa      	ldr	r2, [r7, #12]
 8021d46:	6992      	ldr	r2, [r2, #24]
 8021d48:	601a      	str	r2, [r3, #0]
    object->values[object->count] = value;
 8021d4a:	68fb      	ldr	r3, [r7, #12]
 8021d4c:	691a      	ldr	r2, [r3, #16]
 8021d4e:	68fb      	ldr	r3, [r7, #12]
 8021d50:	699b      	ldr	r3, [r3, #24]
 8021d52:	009b      	lsls	r3, r3, #2
 8021d54:	4413      	add	r3, r2
 8021d56:	687a      	ldr	r2, [r7, #4]
 8021d58:	601a      	str	r2, [r3, #0]
    object->cell_ixs[object->count] = cell_ix;
 8021d5a:	68fb      	ldr	r3, [r7, #12]
 8021d5c:	695a      	ldr	r2, [r3, #20]
 8021d5e:	68fb      	ldr	r3, [r7, #12]
 8021d60:	699b      	ldr	r3, [r3, #24]
 8021d62:	009b      	lsls	r3, r3, #2
 8021d64:	4413      	add	r3, r2
 8021d66:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8021d68:	601a      	str	r2, [r3, #0]
    object->hashes[object->count] = hash;
 8021d6a:	68fb      	ldr	r3, [r7, #12]
 8021d6c:	689a      	ldr	r2, [r3, #8]
 8021d6e:	68fb      	ldr	r3, [r7, #12]
 8021d70:	699b      	ldr	r3, [r3, #24]
 8021d72:	009b      	lsls	r3, r3, #2
 8021d74:	4413      	add	r3, r2
 8021d76:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8021d78:	601a      	str	r2, [r3, #0]
    object->count++;
 8021d7a:	68fb      	ldr	r3, [r7, #12]
 8021d7c:	699b      	ldr	r3, [r3, #24]
 8021d7e:	1c5a      	adds	r2, r3, #1
 8021d80:	68fb      	ldr	r3, [r7, #12]
 8021d82:	619a      	str	r2, [r3, #24]
    value->parent = json_object_get_wrapping_value(object);
 8021d84:	68f8      	ldr	r0, [r7, #12]
 8021d86:	f7ff fbaa 	bl	80214de <json_object_get_wrapping_value>
 8021d8a:	4602      	mov	r2, r0
 8021d8c:	687b      	ldr	r3, [r7, #4]
 8021d8e:	601a      	str	r2, [r3, #0]
    return JSONSuccess;
 8021d90:	2300      	movs	r3, #0
}
 8021d92:	4618      	mov	r0, r3
 8021d94:	3730      	adds	r7, #48	@ 0x30
 8021d96:	46bd      	mov	sp, r7
 8021d98:	bd80      	pop	{r7, pc}
	...

08021d9c <json_object_dotset_value>:
        json_value_free(value);
    }
    return status;
}

JSON_Status json_object_dotset_value(JSON_Object *object, const char *name, JSON_Value *value) {
 8021d9c:	b580      	push	{r7, lr}
 8021d9e:	b08c      	sub	sp, #48	@ 0x30
 8021da0:	af00      	add	r7, sp, #0
 8021da2:	60f8      	str	r0, [r7, #12]
 8021da4:	60b9      	str	r1, [r7, #8]
 8021da6:	607a      	str	r2, [r7, #4]
    const char *dot_pos = NULL;
 8021da8:	2300      	movs	r3, #0
 8021daa:	62fb      	str	r3, [r7, #44]	@ 0x2c
    JSON_Value *temp_value = NULL, *new_value = NULL;
 8021dac:	2300      	movs	r3, #0
 8021dae:	62bb      	str	r3, [r7, #40]	@ 0x28
 8021db0:	2300      	movs	r3, #0
 8021db2:	627b      	str	r3, [r7, #36]	@ 0x24
    JSON_Object *temp_object = NULL, *new_object = NULL;
 8021db4:	2300      	movs	r3, #0
 8021db6:	623b      	str	r3, [r7, #32]
 8021db8:	2300      	movs	r3, #0
 8021dba:	61fb      	str	r3, [r7, #28]
    JSON_Status status = JSONFailure;
 8021dbc:	f04f 33ff 	mov.w	r3, #4294967295
 8021dc0:	61bb      	str	r3, [r7, #24]
    size_t name_len = 0;
 8021dc2:	2300      	movs	r3, #0
 8021dc4:	617b      	str	r3, [r7, #20]
    char *name_copy = NULL;
 8021dc6:	2300      	movs	r3, #0
 8021dc8:	613b      	str	r3, [r7, #16]
    
    if (object == NULL || name == NULL || value == NULL) {
 8021dca:	68fb      	ldr	r3, [r7, #12]
 8021dcc:	2b00      	cmp	r3, #0
 8021dce:	d005      	beq.n	8021ddc <json_object_dotset_value+0x40>
 8021dd0:	68bb      	ldr	r3, [r7, #8]
 8021dd2:	2b00      	cmp	r3, #0
 8021dd4:	d002      	beq.n	8021ddc <json_object_dotset_value+0x40>
 8021dd6:	687b      	ldr	r3, [r7, #4]
 8021dd8:	2b00      	cmp	r3, #0
 8021dda:	d102      	bne.n	8021de2 <json_object_dotset_value+0x46>
        return JSONFailure;
 8021ddc:	f04f 33ff 	mov.w	r3, #4294967295
 8021de0:	e07f      	b.n	8021ee2 <json_object_dotset_value+0x146>
    }
    dot_pos = strchr(name, '.');
 8021de2:	212e      	movs	r1, #46	@ 0x2e
 8021de4:	68b8      	ldr	r0, [r7, #8]
 8021de6:	f002 f945 	bl	8024074 <strchr>
 8021dea:	62f8      	str	r0, [r7, #44]	@ 0x2c
    if (dot_pos == NULL) {
 8021dec:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8021dee:	2b00      	cmp	r3, #0
 8021df0:	d106      	bne.n	8021e00 <json_object_dotset_value+0x64>
        return json_object_set_value(object, name, value);
 8021df2:	687a      	ldr	r2, [r7, #4]
 8021df4:	68b9      	ldr	r1, [r7, #8]
 8021df6:	68f8      	ldr	r0, [r7, #12]
 8021df8:	f7ff ff13 	bl	8021c22 <json_object_set_value>
 8021dfc:	4603      	mov	r3, r0
 8021dfe:	e070      	b.n	8021ee2 <json_object_dotset_value+0x146>
    }
    name_len = dot_pos - name;
 8021e00:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8021e02:	68bb      	ldr	r3, [r7, #8]
 8021e04:	1ad3      	subs	r3, r2, r3
 8021e06:	617b      	str	r3, [r7, #20]
    temp_value = json_object_getn_value(object, name, name_len);
 8021e08:	697a      	ldr	r2, [r7, #20]
 8021e0a:	68b9      	ldr	r1, [r7, #8]
 8021e0c:	68f8      	ldr	r0, [r7, #12]
 8021e0e:	f7fd f984 	bl	801f11a <json_object_getn_value>
 8021e12:	62b8      	str	r0, [r7, #40]	@ 0x28
    if (temp_value) {
 8021e14:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8021e16:	2b00      	cmp	r3, #0
 8021e18:	d015      	beq.n	8021e46 <json_object_dotset_value+0xaa>
        /* Don't overwrite existing non-object (unlike json_object_set_value, but it shouldn't be changed at this point) */
        if (json_value_get_type(temp_value) != JSONObject) {
 8021e1a:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 8021e1c:	f7ff fbe5 	bl	80215ea <json_value_get_type>
 8021e20:	4603      	mov	r3, r0
 8021e22:	2b04      	cmp	r3, #4
 8021e24:	d002      	beq.n	8021e2c <json_object_dotset_value+0x90>
            return JSONFailure;
 8021e26:	f04f 33ff 	mov.w	r3, #4294967295
 8021e2a:	e05a      	b.n	8021ee2 <json_object_dotset_value+0x146>
        }
        temp_object = json_value_get_object(temp_value);
 8021e2c:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 8021e2e:	f7ff fbee 	bl	802160e <json_value_get_object>
 8021e32:	6238      	str	r0, [r7, #32]
        return json_object_dotset_value(temp_object, dot_pos + 1, value);
 8021e34:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8021e36:	3301      	adds	r3, #1
 8021e38:	687a      	ldr	r2, [r7, #4]
 8021e3a:	4619      	mov	r1, r3
 8021e3c:	6a38      	ldr	r0, [r7, #32]
 8021e3e:	f7ff ffad 	bl	8021d9c <json_object_dotset_value>
 8021e42:	4603      	mov	r3, r0
 8021e44:	e04d      	b.n	8021ee2 <json_object_dotset_value+0x146>
    }
    new_value = json_value_init_object();
 8021e46:	f7ff fca7 	bl	8021798 <json_value_init_object>
 8021e4a:	6278      	str	r0, [r7, #36]	@ 0x24
    if (new_value == NULL) {
 8021e4c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8021e4e:	2b00      	cmp	r3, #0
 8021e50:	d102      	bne.n	8021e58 <json_object_dotset_value+0xbc>
        return JSONFailure;
 8021e52:	f04f 33ff 	mov.w	r3, #4294967295
 8021e56:	e044      	b.n	8021ee2 <json_object_dotset_value+0x146>
    }
    new_object = json_value_get_object(new_value);
 8021e58:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8021e5a:	f7ff fbd8 	bl	802160e <json_value_get_object>
 8021e5e:	61f8      	str	r0, [r7, #28]
    status = json_object_dotset_value(new_object, dot_pos + 1, value);
 8021e60:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8021e62:	3301      	adds	r3, #1
 8021e64:	687a      	ldr	r2, [r7, #4]
 8021e66:	4619      	mov	r1, r3
 8021e68:	69f8      	ldr	r0, [r7, #28]
 8021e6a:	f7ff ff97 	bl	8021d9c <json_object_dotset_value>
 8021e6e:	61b8      	str	r0, [r7, #24]
    if (status != JSONSuccess) {
 8021e70:	69bb      	ldr	r3, [r7, #24]
 8021e72:	2b00      	cmp	r3, #0
 8021e74:	d005      	beq.n	8021e82 <json_object_dotset_value+0xe6>
        json_value_free(new_value);
 8021e76:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8021e78:	f7ff fc60 	bl	802173c <json_value_free>
        return JSONFailure;
 8021e7c:	f04f 33ff 	mov.w	r3, #4294967295
 8021e80:	e02f      	b.n	8021ee2 <json_object_dotset_value+0x146>
    }
    name_copy = parson_strndup(name, name_len);
 8021e82:	6979      	ldr	r1, [r7, #20]
 8021e84:	68b8      	ldr	r0, [r7, #8]
 8021e86:	f7fc fc57 	bl	801e738 <parson_strndup>
 8021e8a:	6138      	str	r0, [r7, #16]
    if (!name_copy) {
 8021e8c:	693b      	ldr	r3, [r7, #16]
 8021e8e:	2b00      	cmp	r3, #0
 8021e90:	d10c      	bne.n	8021eac <json_object_dotset_value+0x110>
        json_object_dotremove_internal(new_object, dot_pos + 1, 0);
 8021e92:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8021e94:	3301      	adds	r3, #1
 8021e96:	2200      	movs	r2, #0
 8021e98:	4619      	mov	r1, r3
 8021e9a:	69f8      	ldr	r0, [r7, #28]
 8021e9c:	f7fd fa94 	bl	801f3c8 <json_object_dotremove_internal>
        json_value_free(new_value);
 8021ea0:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8021ea2:	f7ff fc4b 	bl	802173c <json_value_free>
        return JSONFailure;
 8021ea6:	f04f 33ff 	mov.w	r3, #4294967295
 8021eaa:	e01a      	b.n	8021ee2 <json_object_dotset_value+0x146>
    }
    status = json_object_add(object, name_copy, new_value);
 8021eac:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8021eae:	6939      	ldr	r1, [r7, #16]
 8021eb0:	68f8      	ldr	r0, [r7, #12]
 8021eb2:	f7fd f8a4 	bl	801effe <json_object_add>
 8021eb6:	61b8      	str	r0, [r7, #24]
    if (status != JSONSuccess) {
 8021eb8:	69bb      	ldr	r3, [r7, #24]
 8021eba:	2b00      	cmp	r3, #0
 8021ebc:	d010      	beq.n	8021ee0 <json_object_dotset_value+0x144>
        parson_free(name_copy);
 8021ebe:	4b0b      	ldr	r3, [pc, #44]	@ (8021eec <json_object_dotset_value+0x150>)
 8021ec0:	681b      	ldr	r3, [r3, #0]
 8021ec2:	6938      	ldr	r0, [r7, #16]
 8021ec4:	4798      	blx	r3
        json_object_dotremove_internal(new_object, dot_pos + 1, 0);
 8021ec6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8021ec8:	3301      	adds	r3, #1
 8021eca:	2200      	movs	r2, #0
 8021ecc:	4619      	mov	r1, r3
 8021ece:	69f8      	ldr	r0, [r7, #28]
 8021ed0:	f7fd fa7a 	bl	801f3c8 <json_object_dotremove_internal>
        json_value_free(new_value);
 8021ed4:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8021ed6:	f7ff fc31 	bl	802173c <json_value_free>
        return JSONFailure;
 8021eda:	f04f 33ff 	mov.w	r3, #4294967295
 8021ede:	e000      	b.n	8021ee2 <json_object_dotset_value+0x146>
    }
    return JSONSuccess;
 8021ee0:	2300      	movs	r3, #0
}
 8021ee2:	4618      	mov	r0, r3
 8021ee4:	3730      	adds	r7, #48	@ 0x30
 8021ee6:	46bd      	mov	sp, r7
 8021ee8:	bd80      	pop	{r7, pc}
 8021eea:	bf00      	nop
 8021eec:	20000214 	.word	0x20000214

08021ef0 <json_object_dotset_string>:

JSON_Status json_object_dotset_string(JSON_Object *object, const char *name, const char *string) {
 8021ef0:	b580      	push	{r7, lr}
 8021ef2:	b086      	sub	sp, #24
 8021ef4:	af00      	add	r7, sp, #0
 8021ef6:	60f8      	str	r0, [r7, #12]
 8021ef8:	60b9      	str	r1, [r7, #8]
 8021efa:	607a      	str	r2, [r7, #4]
    JSON_Value *value = json_value_init_string(string);
 8021efc:	6878      	ldr	r0, [r7, #4]
 8021efe:	f7ff fca3 	bl	8021848 <json_value_init_string>
 8021f02:	6178      	str	r0, [r7, #20]
    if (value == NULL) {
 8021f04:	697b      	ldr	r3, [r7, #20]
 8021f06:	2b00      	cmp	r3, #0
 8021f08:	d102      	bne.n	8021f10 <json_object_dotset_string+0x20>
        return JSONFailure;
 8021f0a:	f04f 33ff 	mov.w	r3, #4294967295
 8021f0e:	e00e      	b.n	8021f2e <json_object_dotset_string+0x3e>
    }
    if (json_object_dotset_value(object, name, value) != JSONSuccess) {
 8021f10:	697a      	ldr	r2, [r7, #20]
 8021f12:	68b9      	ldr	r1, [r7, #8]
 8021f14:	68f8      	ldr	r0, [r7, #12]
 8021f16:	f7ff ff41 	bl	8021d9c <json_object_dotset_value>
 8021f1a:	4603      	mov	r3, r0
 8021f1c:	2b00      	cmp	r3, #0
 8021f1e:	d005      	beq.n	8021f2c <json_object_dotset_string+0x3c>
        json_value_free(value);
 8021f20:	6978      	ldr	r0, [r7, #20]
 8021f22:	f7ff fc0b 	bl	802173c <json_value_free>
        return JSONFailure;
 8021f26:	f04f 33ff 	mov.w	r3, #4294967295
 8021f2a:	e000      	b.n	8021f2e <json_object_dotset_string+0x3e>
    }
    return JSONSuccess;
 8021f2c:	2300      	movs	r3, #0
}
 8021f2e:	4618      	mov	r0, r3
 8021f30:	3718      	adds	r7, #24
 8021f32:	46bd      	mov	sp, r7
 8021f34:	bd80      	pop	{r7, pc}

08021f36 <json_object_dotset_number>:
        return JSONFailure;
    }
    return JSONSuccess;
}

JSON_Status json_object_dotset_number(JSON_Object *object, const char *name, double number) {
 8021f36:	b580      	push	{r7, lr}
 8021f38:	b086      	sub	sp, #24
 8021f3a:	af00      	add	r7, sp, #0
 8021f3c:	60f8      	str	r0, [r7, #12]
 8021f3e:	60b9      	str	r1, [r7, #8]
 8021f40:	e9c7 2300 	strd	r2, r3, [r7]
    JSON_Value *value = json_value_init_number(number);
 8021f44:	e9d7 0100 	ldrd	r0, r1, [r7]
 8021f48:	f7ff fcc6 	bl	80218d8 <json_value_init_number>
 8021f4c:	6178      	str	r0, [r7, #20]
    if (value == NULL) {
 8021f4e:	697b      	ldr	r3, [r7, #20]
 8021f50:	2b00      	cmp	r3, #0
 8021f52:	d102      	bne.n	8021f5a <json_object_dotset_number+0x24>
        return JSONFailure;
 8021f54:	f04f 33ff 	mov.w	r3, #4294967295
 8021f58:	e00e      	b.n	8021f78 <json_object_dotset_number+0x42>
    }
    if (json_object_dotset_value(object, name, value) != JSONSuccess) {
 8021f5a:	697a      	ldr	r2, [r7, #20]
 8021f5c:	68b9      	ldr	r1, [r7, #8]
 8021f5e:	68f8      	ldr	r0, [r7, #12]
 8021f60:	f7ff ff1c 	bl	8021d9c <json_object_dotset_value>
 8021f64:	4603      	mov	r3, r0
 8021f66:	2b00      	cmp	r3, #0
 8021f68:	d005      	beq.n	8021f76 <json_object_dotset_number+0x40>
        json_value_free(value);
 8021f6a:	6978      	ldr	r0, [r7, #20]
 8021f6c:	f7ff fbe6 	bl	802173c <json_value_free>
        return JSONFailure;
 8021f70:	f04f 33ff 	mov.w	r3, #4294967295
 8021f74:	e000      	b.n	8021f78 <json_object_dotset_number+0x42>
    }
    return JSONSuccess;
 8021f76:	2300      	movs	r3, #0
}
 8021f78:	4618      	mov	r0, r3
 8021f7a:	3718      	adds	r7, #24
 8021f7c:	46bd      	mov	sp, r7
 8021f7e:	bd80      	pop	{r7, pc}

08021f80 <json_object_dotset_boolean>:

JSON_Status json_object_dotset_boolean(JSON_Object *object, const char *name, int boolean) {
 8021f80:	b580      	push	{r7, lr}
 8021f82:	b086      	sub	sp, #24
 8021f84:	af00      	add	r7, sp, #0
 8021f86:	60f8      	str	r0, [r7, #12]
 8021f88:	60b9      	str	r1, [r7, #8]
 8021f8a:	607a      	str	r2, [r7, #4]
    JSON_Value *value = json_value_init_boolean(boolean);
 8021f8c:	6878      	ldr	r0, [r7, #4]
 8021f8e:	f7ff fcf5 	bl	802197c <json_value_init_boolean>
 8021f92:	6178      	str	r0, [r7, #20]
    if (value == NULL) {
 8021f94:	697b      	ldr	r3, [r7, #20]
 8021f96:	2b00      	cmp	r3, #0
 8021f98:	d102      	bne.n	8021fa0 <json_object_dotset_boolean+0x20>
        return JSONFailure;
 8021f9a:	f04f 33ff 	mov.w	r3, #4294967295
 8021f9e:	e00e      	b.n	8021fbe <json_object_dotset_boolean+0x3e>
    }
    if (json_object_dotset_value(object, name, value) != JSONSuccess) {
 8021fa0:	697a      	ldr	r2, [r7, #20]
 8021fa2:	68b9      	ldr	r1, [r7, #8]
 8021fa4:	68f8      	ldr	r0, [r7, #12]
 8021fa6:	f7ff fef9 	bl	8021d9c <json_object_dotset_value>
 8021faa:	4603      	mov	r3, r0
 8021fac:	2b00      	cmp	r3, #0
 8021fae:	d005      	beq.n	8021fbc <json_object_dotset_boolean+0x3c>
        json_value_free(value);
 8021fb0:	6978      	ldr	r0, [r7, #20]
 8021fb2:	f7ff fbc3 	bl	802173c <json_value_free>
        return JSONFailure;
 8021fb6:	f04f 33ff 	mov.w	r3, #4294967295
 8021fba:	e000      	b.n	8021fbe <json_object_dotset_boolean+0x3e>
    }
    return JSONSuccess;
 8021fbc:	2300      	movs	r3, #0
}
 8021fbe:	4618      	mov	r0, r3
 8021fc0:	3718      	adds	r7, #24
 8021fc2:	46bd      	mov	sp, r7
 8021fc4:	bd80      	pop	{r7, pc}
	...

08021fc8 <malloc>:
 8021fc8:	4b02      	ldr	r3, [pc, #8]	@ (8021fd4 <malloc+0xc>)
 8021fca:	4601      	mov	r1, r0
 8021fcc:	6818      	ldr	r0, [r3, #0]
 8021fce:	f000 b82d 	b.w	802202c <_malloc_r>
 8021fd2:	bf00      	nop
 8021fd4:	20000394 	.word	0x20000394

08021fd8 <free>:
 8021fd8:	4b02      	ldr	r3, [pc, #8]	@ (8021fe4 <free+0xc>)
 8021fda:	4601      	mov	r1, r0
 8021fdc:	6818      	ldr	r0, [r3, #0]
 8021fde:	f002 bf9d 	b.w	8024f1c <_free_r>
 8021fe2:	bf00      	nop
 8021fe4:	20000394 	.word	0x20000394

08021fe8 <sbrk_aligned>:
 8021fe8:	b570      	push	{r4, r5, r6, lr}
 8021fea:	4e0f      	ldr	r6, [pc, #60]	@ (8022028 <sbrk_aligned+0x40>)
 8021fec:	460c      	mov	r4, r1
 8021fee:	4605      	mov	r5, r0
 8021ff0:	6831      	ldr	r1, [r6, #0]
 8021ff2:	b911      	cbnz	r1, 8021ffa <sbrk_aligned+0x12>
 8021ff4:	f002 f896 	bl	8024124 <_sbrk_r>
 8021ff8:	6030      	str	r0, [r6, #0]
 8021ffa:	4621      	mov	r1, r4
 8021ffc:	4628      	mov	r0, r5
 8021ffe:	f002 f891 	bl	8024124 <_sbrk_r>
 8022002:	1c43      	adds	r3, r0, #1
 8022004:	d103      	bne.n	802200e <sbrk_aligned+0x26>
 8022006:	f04f 34ff 	mov.w	r4, #4294967295
 802200a:	4620      	mov	r0, r4
 802200c:	bd70      	pop	{r4, r5, r6, pc}
 802200e:	1cc4      	adds	r4, r0, #3
 8022010:	f024 0403 	bic.w	r4, r4, #3
 8022014:	42a0      	cmp	r0, r4
 8022016:	d0f8      	beq.n	802200a <sbrk_aligned+0x22>
 8022018:	1a21      	subs	r1, r4, r0
 802201a:	4628      	mov	r0, r5
 802201c:	f002 f882 	bl	8024124 <_sbrk_r>
 8022020:	3001      	adds	r0, #1
 8022022:	d1f2      	bne.n	802200a <sbrk_aligned+0x22>
 8022024:	e7ef      	b.n	8022006 <sbrk_aligned+0x1e>
 8022026:	bf00      	nop
 8022028:	20001ea0 	.word	0x20001ea0

0802202c <_malloc_r>:
 802202c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8022030:	1ccd      	adds	r5, r1, #3
 8022032:	4606      	mov	r6, r0
 8022034:	f025 0503 	bic.w	r5, r5, #3
 8022038:	3508      	adds	r5, #8
 802203a:	2d0c      	cmp	r5, #12
 802203c:	bf38      	it	cc
 802203e:	250c      	movcc	r5, #12
 8022040:	2d00      	cmp	r5, #0
 8022042:	db01      	blt.n	8022048 <_malloc_r+0x1c>
 8022044:	42a9      	cmp	r1, r5
 8022046:	d904      	bls.n	8022052 <_malloc_r+0x26>
 8022048:	230c      	movs	r3, #12
 802204a:	6033      	str	r3, [r6, #0]
 802204c:	2000      	movs	r0, #0
 802204e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8022052:	f8df 80d4 	ldr.w	r8, [pc, #212]	@ 8022128 <_malloc_r+0xfc>
 8022056:	f000 f869 	bl	802212c <__malloc_lock>
 802205a:	f8d8 3000 	ldr.w	r3, [r8]
 802205e:	461c      	mov	r4, r3
 8022060:	bb44      	cbnz	r4, 80220b4 <_malloc_r+0x88>
 8022062:	4629      	mov	r1, r5
 8022064:	4630      	mov	r0, r6
 8022066:	f7ff ffbf 	bl	8021fe8 <sbrk_aligned>
 802206a:	1c43      	adds	r3, r0, #1
 802206c:	4604      	mov	r4, r0
 802206e:	d158      	bne.n	8022122 <_malloc_r+0xf6>
 8022070:	f8d8 4000 	ldr.w	r4, [r8]
 8022074:	4627      	mov	r7, r4
 8022076:	2f00      	cmp	r7, #0
 8022078:	d143      	bne.n	8022102 <_malloc_r+0xd6>
 802207a:	2c00      	cmp	r4, #0
 802207c:	d04b      	beq.n	8022116 <_malloc_r+0xea>
 802207e:	6823      	ldr	r3, [r4, #0]
 8022080:	4639      	mov	r1, r7
 8022082:	4630      	mov	r0, r6
 8022084:	eb04 0903 	add.w	r9, r4, r3
 8022088:	f002 f84c 	bl	8024124 <_sbrk_r>
 802208c:	4581      	cmp	r9, r0
 802208e:	d142      	bne.n	8022116 <_malloc_r+0xea>
 8022090:	6821      	ldr	r1, [r4, #0]
 8022092:	4630      	mov	r0, r6
 8022094:	1a6d      	subs	r5, r5, r1
 8022096:	4629      	mov	r1, r5
 8022098:	f7ff ffa6 	bl	8021fe8 <sbrk_aligned>
 802209c:	3001      	adds	r0, #1
 802209e:	d03a      	beq.n	8022116 <_malloc_r+0xea>
 80220a0:	6823      	ldr	r3, [r4, #0]
 80220a2:	442b      	add	r3, r5
 80220a4:	6023      	str	r3, [r4, #0]
 80220a6:	f8d8 3000 	ldr.w	r3, [r8]
 80220aa:	685a      	ldr	r2, [r3, #4]
 80220ac:	bb62      	cbnz	r2, 8022108 <_malloc_r+0xdc>
 80220ae:	f8c8 7000 	str.w	r7, [r8]
 80220b2:	e00f      	b.n	80220d4 <_malloc_r+0xa8>
 80220b4:	6822      	ldr	r2, [r4, #0]
 80220b6:	1b52      	subs	r2, r2, r5
 80220b8:	d420      	bmi.n	80220fc <_malloc_r+0xd0>
 80220ba:	2a0b      	cmp	r2, #11
 80220bc:	d917      	bls.n	80220ee <_malloc_r+0xc2>
 80220be:	1961      	adds	r1, r4, r5
 80220c0:	42a3      	cmp	r3, r4
 80220c2:	6025      	str	r5, [r4, #0]
 80220c4:	bf18      	it	ne
 80220c6:	6059      	strne	r1, [r3, #4]
 80220c8:	6863      	ldr	r3, [r4, #4]
 80220ca:	bf08      	it	eq
 80220cc:	f8c8 1000 	streq.w	r1, [r8]
 80220d0:	5162      	str	r2, [r4, r5]
 80220d2:	604b      	str	r3, [r1, #4]
 80220d4:	4630      	mov	r0, r6
 80220d6:	f000 f82f 	bl	8022138 <__malloc_unlock>
 80220da:	f104 000b 	add.w	r0, r4, #11
 80220de:	1d23      	adds	r3, r4, #4
 80220e0:	f020 0007 	bic.w	r0, r0, #7
 80220e4:	1ac2      	subs	r2, r0, r3
 80220e6:	bf1c      	itt	ne
 80220e8:	1a1b      	subne	r3, r3, r0
 80220ea:	50a3      	strne	r3, [r4, r2]
 80220ec:	e7af      	b.n	802204e <_malloc_r+0x22>
 80220ee:	6862      	ldr	r2, [r4, #4]
 80220f0:	42a3      	cmp	r3, r4
 80220f2:	bf0c      	ite	eq
 80220f4:	f8c8 2000 	streq.w	r2, [r8]
 80220f8:	605a      	strne	r2, [r3, #4]
 80220fa:	e7eb      	b.n	80220d4 <_malloc_r+0xa8>
 80220fc:	4623      	mov	r3, r4
 80220fe:	6864      	ldr	r4, [r4, #4]
 8022100:	e7ae      	b.n	8022060 <_malloc_r+0x34>
 8022102:	463c      	mov	r4, r7
 8022104:	687f      	ldr	r7, [r7, #4]
 8022106:	e7b6      	b.n	8022076 <_malloc_r+0x4a>
 8022108:	461a      	mov	r2, r3
 802210a:	685b      	ldr	r3, [r3, #4]
 802210c:	42a3      	cmp	r3, r4
 802210e:	d1fb      	bne.n	8022108 <_malloc_r+0xdc>
 8022110:	2300      	movs	r3, #0
 8022112:	6053      	str	r3, [r2, #4]
 8022114:	e7de      	b.n	80220d4 <_malloc_r+0xa8>
 8022116:	230c      	movs	r3, #12
 8022118:	4630      	mov	r0, r6
 802211a:	6033      	str	r3, [r6, #0]
 802211c:	f000 f80c 	bl	8022138 <__malloc_unlock>
 8022120:	e794      	b.n	802204c <_malloc_r+0x20>
 8022122:	6005      	str	r5, [r0, #0]
 8022124:	e7d6      	b.n	80220d4 <_malloc_r+0xa8>
 8022126:	bf00      	nop
 8022128:	20001ea4 	.word	0x20001ea4

0802212c <__malloc_lock>:
 802212c:	4801      	ldr	r0, [pc, #4]	@ (8022134 <__malloc_lock+0x8>)
 802212e:	f002 b846 	b.w	80241be <__retarget_lock_acquire_recursive>
 8022132:	bf00      	nop
 8022134:	20001fe8 	.word	0x20001fe8

08022138 <__malloc_unlock>:
 8022138:	4801      	ldr	r0, [pc, #4]	@ (8022140 <__malloc_unlock+0x8>)
 802213a:	f002 b841 	b.w	80241c0 <__retarget_lock_release_recursive>
 802213e:	bf00      	nop
 8022140:	20001fe8 	.word	0x20001fe8

08022144 <srand>:
 8022144:	b538      	push	{r3, r4, r5, lr}
 8022146:	4b10      	ldr	r3, [pc, #64]	@ (8022188 <srand+0x44>)
 8022148:	4604      	mov	r4, r0
 802214a:	681d      	ldr	r5, [r3, #0]
 802214c:	6b2b      	ldr	r3, [r5, #48]	@ 0x30
 802214e:	b9b3      	cbnz	r3, 802217e <srand+0x3a>
 8022150:	2018      	movs	r0, #24
 8022152:	f7ff ff39 	bl	8021fc8 <malloc>
 8022156:	4602      	mov	r2, r0
 8022158:	6328      	str	r0, [r5, #48]	@ 0x30
 802215a:	b920      	cbnz	r0, 8022166 <srand+0x22>
 802215c:	4b0b      	ldr	r3, [pc, #44]	@ (802218c <srand+0x48>)
 802215e:	2146      	movs	r1, #70	@ 0x46
 8022160:	480b      	ldr	r0, [pc, #44]	@ (8022190 <srand+0x4c>)
 8022162:	f002 f85b 	bl	802421c <__assert_func>
 8022166:	490b      	ldr	r1, [pc, #44]	@ (8022194 <srand+0x50>)
 8022168:	4b0b      	ldr	r3, [pc, #44]	@ (8022198 <srand+0x54>)
 802216a:	e9c0 1300 	strd	r1, r3, [r0]
 802216e:	4b0b      	ldr	r3, [pc, #44]	@ (802219c <srand+0x58>)
 8022170:	2100      	movs	r1, #0
 8022172:	6083      	str	r3, [r0, #8]
 8022174:	230b      	movs	r3, #11
 8022176:	8183      	strh	r3, [r0, #12]
 8022178:	2001      	movs	r0, #1
 802217a:	e9c2 0104 	strd	r0, r1, [r2, #16]
 802217e:	6b2b      	ldr	r3, [r5, #48]	@ 0x30
 8022180:	2200      	movs	r2, #0
 8022182:	611c      	str	r4, [r3, #16]
 8022184:	615a      	str	r2, [r3, #20]
 8022186:	bd38      	pop	{r3, r4, r5, pc}
 8022188:	20000394 	.word	0x20000394
 802218c:	0802a840 	.word	0x0802a840
 8022190:	0802a857 	.word	0x0802a857
 8022194:	abcd330e 	.word	0xabcd330e
 8022198:	e66d1234 	.word	0xe66d1234
 802219c:	0005deec 	.word	0x0005deec

080221a0 <sulp>:
 80221a0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80221a4:	4690      	mov	r8, r2
 80221a6:	460f      	mov	r7, r1
 80221a8:	f003 fdbe 	bl	8025d28 <__ulp>
 80221ac:	4604      	mov	r4, r0
 80221ae:	460d      	mov	r5, r1
 80221b0:	f1b8 0f00 	cmp.w	r8, #0
 80221b4:	d011      	beq.n	80221da <sulp+0x3a>
 80221b6:	f3c7 530a 	ubfx	r3, r7, #20, #11
 80221ba:	f1c3 036b 	rsb	r3, r3, #107	@ 0x6b
 80221be:	2b00      	cmp	r3, #0
 80221c0:	dd0b      	ble.n	80221da <sulp+0x3a>
 80221c2:	051b      	lsls	r3, r3, #20
 80221c4:	2400      	movs	r4, #0
 80221c6:	f103 557f 	add.w	r5, r3, #1069547520	@ 0x3fc00000
 80221ca:	4622      	mov	r2, r4
 80221cc:	f505 1540 	add.w	r5, r5, #3145728	@ 0x300000
 80221d0:	462b      	mov	r3, r5
 80221d2:	f7de fa1f 	bl	8000614 <__aeabi_dmul>
 80221d6:	4604      	mov	r4, r0
 80221d8:	460d      	mov	r5, r1
 80221da:	4620      	mov	r0, r4
 80221dc:	4629      	mov	r1, r5
 80221de:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80221e2:	0000      	movs	r0, r0
 80221e4:	0000      	movs	r0, r0
	...

080221e8 <_strtod_l>:
 80221e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80221ec:	b09f      	sub	sp, #124	@ 0x7c
 80221ee:	460c      	mov	r4, r1
 80221f0:	f04f 0a00 	mov.w	sl, #0
 80221f4:	f04f 0b00 	mov.w	fp, #0
 80221f8:	9217      	str	r2, [sp, #92]	@ 0x5c
 80221fa:	2200      	movs	r2, #0
 80221fc:	9005      	str	r0, [sp, #20]
 80221fe:	921a      	str	r2, [sp, #104]	@ 0x68
 8022200:	460a      	mov	r2, r1
 8022202:	9219      	str	r2, [sp, #100]	@ 0x64
 8022204:	7811      	ldrb	r1, [r2, #0]
 8022206:	292b      	cmp	r1, #43	@ 0x2b
 8022208:	d048      	beq.n	802229c <_strtod_l+0xb4>
 802220a:	d836      	bhi.n	802227a <_strtod_l+0x92>
 802220c:	290d      	cmp	r1, #13
 802220e:	d830      	bhi.n	8022272 <_strtod_l+0x8a>
 8022210:	2908      	cmp	r1, #8
 8022212:	d830      	bhi.n	8022276 <_strtod_l+0x8e>
 8022214:	2900      	cmp	r1, #0
 8022216:	d039      	beq.n	802228c <_strtod_l+0xa4>
 8022218:	2200      	movs	r2, #0
 802221a:	920e      	str	r2, [sp, #56]	@ 0x38
 802221c:	9d19      	ldr	r5, [sp, #100]	@ 0x64
 802221e:	782a      	ldrb	r2, [r5, #0]
 8022220:	2a30      	cmp	r2, #48	@ 0x30
 8022222:	f040 80b0 	bne.w	8022386 <_strtod_l+0x19e>
 8022226:	786a      	ldrb	r2, [r5, #1]
 8022228:	f002 02df 	and.w	r2, r2, #223	@ 0xdf
 802222c:	2a58      	cmp	r2, #88	@ 0x58
 802222e:	d16c      	bne.n	802230a <_strtod_l+0x122>
 8022230:	9302      	str	r3, [sp, #8]
 8022232:	a919      	add	r1, sp, #100	@ 0x64
 8022234:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 8022236:	4a8f      	ldr	r2, [pc, #572]	@ (8022474 <_strtod_l+0x28c>)
 8022238:	9301      	str	r3, [sp, #4]
 802223a:	ab1a      	add	r3, sp, #104	@ 0x68
 802223c:	9805      	ldr	r0, [sp, #20]
 802223e:	9300      	str	r3, [sp, #0]
 8022240:	ab1b      	add	r3, sp, #108	@ 0x6c
 8022242:	f002 ff1b 	bl	802507c <__gethex>
 8022246:	f010 060f 	ands.w	r6, r0, #15
 802224a:	4604      	mov	r4, r0
 802224c:	d005      	beq.n	802225a <_strtod_l+0x72>
 802224e:	2e06      	cmp	r6, #6
 8022250:	d126      	bne.n	80222a0 <_strtod_l+0xb8>
 8022252:	3501      	adds	r5, #1
 8022254:	2300      	movs	r3, #0
 8022256:	9519      	str	r5, [sp, #100]	@ 0x64
 8022258:	930e      	str	r3, [sp, #56]	@ 0x38
 802225a:	9b17      	ldr	r3, [sp, #92]	@ 0x5c
 802225c:	2b00      	cmp	r3, #0
 802225e:	f040 8584 	bne.w	8022d6a <_strtod_l+0xb82>
 8022262:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 8022264:	b1bb      	cbz	r3, 8022296 <_strtod_l+0xae>
 8022266:	4650      	mov	r0, sl
 8022268:	f10b 4100 	add.w	r1, fp, #2147483648	@ 0x80000000
 802226c:	b01f      	add	sp, #124	@ 0x7c
 802226e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8022272:	2920      	cmp	r1, #32
 8022274:	d1d0      	bne.n	8022218 <_strtod_l+0x30>
 8022276:	3201      	adds	r2, #1
 8022278:	e7c3      	b.n	8022202 <_strtod_l+0x1a>
 802227a:	292d      	cmp	r1, #45	@ 0x2d
 802227c:	d1cc      	bne.n	8022218 <_strtod_l+0x30>
 802227e:	2101      	movs	r1, #1
 8022280:	910e      	str	r1, [sp, #56]	@ 0x38
 8022282:	1c51      	adds	r1, r2, #1
 8022284:	9119      	str	r1, [sp, #100]	@ 0x64
 8022286:	7852      	ldrb	r2, [r2, #1]
 8022288:	2a00      	cmp	r2, #0
 802228a:	d1c7      	bne.n	802221c <_strtod_l+0x34>
 802228c:	9b17      	ldr	r3, [sp, #92]	@ 0x5c
 802228e:	9419      	str	r4, [sp, #100]	@ 0x64
 8022290:	2b00      	cmp	r3, #0
 8022292:	f040 8568 	bne.w	8022d66 <_strtod_l+0xb7e>
 8022296:	4650      	mov	r0, sl
 8022298:	4659      	mov	r1, fp
 802229a:	e7e7      	b.n	802226c <_strtod_l+0x84>
 802229c:	2100      	movs	r1, #0
 802229e:	e7ef      	b.n	8022280 <_strtod_l+0x98>
 80222a0:	9a1a      	ldr	r2, [sp, #104]	@ 0x68
 80222a2:	b13a      	cbz	r2, 80222b4 <_strtod_l+0xcc>
 80222a4:	2135      	movs	r1, #53	@ 0x35
 80222a6:	a81c      	add	r0, sp, #112	@ 0x70
 80222a8:	f003 fe30 	bl	8025f0c <__copybits>
 80222ac:	991a      	ldr	r1, [sp, #104]	@ 0x68
 80222ae:	9805      	ldr	r0, [sp, #20]
 80222b0:	f003 fa06 	bl	80256c0 <_Bfree>
 80222b4:	3e01      	subs	r6, #1
 80222b6:	9a1b      	ldr	r2, [sp, #108]	@ 0x6c
 80222b8:	2e04      	cmp	r6, #4
 80222ba:	d806      	bhi.n	80222ca <_strtod_l+0xe2>
 80222bc:	e8df f006 	tbb	[pc, r6]
 80222c0:	201d0314 	.word	0x201d0314
 80222c4:	14          	.byte	0x14
 80222c5:	00          	.byte	0x00
 80222c6:	e9dd ab1c 	ldrd	sl, fp, [sp, #112]	@ 0x70
 80222ca:	05e1      	lsls	r1, r4, #23
 80222cc:	bf48      	it	mi
 80222ce:	f04b 4b00 	orrmi.w	fp, fp, #2147483648	@ 0x80000000
 80222d2:	f02b 4300 	bic.w	r3, fp, #2147483648	@ 0x80000000
 80222d6:	0d1b      	lsrs	r3, r3, #20
 80222d8:	051b      	lsls	r3, r3, #20
 80222da:	2b00      	cmp	r3, #0
 80222dc:	d1bd      	bne.n	802225a <_strtod_l+0x72>
 80222de:	f001 ff43 	bl	8024168 <__errno>
 80222e2:	2322      	movs	r3, #34	@ 0x22
 80222e4:	6003      	str	r3, [r0, #0]
 80222e6:	e7b8      	b.n	802225a <_strtod_l+0x72>
 80222e8:	e9dd a31c 	ldrd	sl, r3, [sp, #112]	@ 0x70
 80222ec:	f202 4233 	addw	r2, r2, #1075	@ 0x433
 80222f0:	f423 1380 	bic.w	r3, r3, #1048576	@ 0x100000
 80222f4:	ea43 5b02 	orr.w	fp, r3, r2, lsl #20
 80222f8:	e7e7      	b.n	80222ca <_strtod_l+0xe2>
 80222fa:	f8df b180 	ldr.w	fp, [pc, #384]	@ 802247c <_strtod_l+0x294>
 80222fe:	e7e4      	b.n	80222ca <_strtod_l+0xe2>
 8022300:	f06f 4b00 	mvn.w	fp, #2147483648	@ 0x80000000
 8022304:	f04f 3aff 	mov.w	sl, #4294967295
 8022308:	e7df      	b.n	80222ca <_strtod_l+0xe2>
 802230a:	9b19      	ldr	r3, [sp, #100]	@ 0x64
 802230c:	1c5a      	adds	r2, r3, #1
 802230e:	9219      	str	r2, [sp, #100]	@ 0x64
 8022310:	785b      	ldrb	r3, [r3, #1]
 8022312:	2b30      	cmp	r3, #48	@ 0x30
 8022314:	d0f9      	beq.n	802230a <_strtod_l+0x122>
 8022316:	2b00      	cmp	r3, #0
 8022318:	d09f      	beq.n	802225a <_strtod_l+0x72>
 802231a:	2301      	movs	r3, #1
 802231c:	2700      	movs	r7, #0
 802231e:	9308      	str	r3, [sp, #32]
 8022320:	220a      	movs	r2, #10
 8022322:	9b19      	ldr	r3, [sp, #100]	@ 0x64
 8022324:	46b9      	mov	r9, r7
 8022326:	970b      	str	r7, [sp, #44]	@ 0x2c
 8022328:	930c      	str	r3, [sp, #48]	@ 0x30
 802232a:	9819      	ldr	r0, [sp, #100]	@ 0x64
 802232c:	7805      	ldrb	r5, [r0, #0]
 802232e:	f1a5 0330 	sub.w	r3, r5, #48	@ 0x30
 8022332:	b2d9      	uxtb	r1, r3
 8022334:	2909      	cmp	r1, #9
 8022336:	d928      	bls.n	802238a <_strtod_l+0x1a2>
 8022338:	2201      	movs	r2, #1
 802233a:	494f      	ldr	r1, [pc, #316]	@ (8022478 <_strtod_l+0x290>)
 802233c:	f001 fea7 	bl	802408e <strncmp>
 8022340:	2800      	cmp	r0, #0
 8022342:	d032      	beq.n	80223aa <_strtod_l+0x1c2>
 8022344:	2000      	movs	r0, #0
 8022346:	462a      	mov	r2, r5
 8022348:	464d      	mov	r5, r9
 802234a:	4603      	mov	r3, r0
 802234c:	900a      	str	r0, [sp, #40]	@ 0x28
 802234e:	2a65      	cmp	r2, #101	@ 0x65
 8022350:	d001      	beq.n	8022356 <_strtod_l+0x16e>
 8022352:	2a45      	cmp	r2, #69	@ 0x45
 8022354:	d114      	bne.n	8022380 <_strtod_l+0x198>
 8022356:	b91d      	cbnz	r5, 8022360 <_strtod_l+0x178>
 8022358:	9a08      	ldr	r2, [sp, #32]
 802235a:	4302      	orrs	r2, r0
 802235c:	d096      	beq.n	802228c <_strtod_l+0xa4>
 802235e:	2500      	movs	r5, #0
 8022360:	9c19      	ldr	r4, [sp, #100]	@ 0x64
 8022362:	1c62      	adds	r2, r4, #1
 8022364:	9219      	str	r2, [sp, #100]	@ 0x64
 8022366:	7862      	ldrb	r2, [r4, #1]
 8022368:	2a2b      	cmp	r2, #43	@ 0x2b
 802236a:	d079      	beq.n	8022460 <_strtod_l+0x278>
 802236c:	2a2d      	cmp	r2, #45	@ 0x2d
 802236e:	d07d      	beq.n	802246c <_strtod_l+0x284>
 8022370:	f04f 0c00 	mov.w	ip, #0
 8022374:	f1a2 0130 	sub.w	r1, r2, #48	@ 0x30
 8022378:	2909      	cmp	r1, #9
 802237a:	f240 8085 	bls.w	8022488 <_strtod_l+0x2a0>
 802237e:	9419      	str	r4, [sp, #100]	@ 0x64
 8022380:	f04f 0800 	mov.w	r8, #0
 8022384:	e0a5      	b.n	80224d2 <_strtod_l+0x2ea>
 8022386:	2300      	movs	r3, #0
 8022388:	e7c8      	b.n	802231c <_strtod_l+0x134>
 802238a:	f1b9 0f08 	cmp.w	r9, #8
 802238e:	f100 0001 	add.w	r0, r0, #1
 8022392:	f109 0901 	add.w	r9, r9, #1
 8022396:	bfd4      	ite	le
 8022398:	990b      	ldrle	r1, [sp, #44]	@ 0x2c
 802239a:	fb02 3707 	mlagt	r7, r2, r7, r3
 802239e:	9019      	str	r0, [sp, #100]	@ 0x64
 80223a0:	bfdc      	itt	le
 80223a2:	fb02 3301 	mlale	r3, r2, r1, r3
 80223a6:	930b      	strle	r3, [sp, #44]	@ 0x2c
 80223a8:	e7bf      	b.n	802232a <_strtod_l+0x142>
 80223aa:	9b19      	ldr	r3, [sp, #100]	@ 0x64
 80223ac:	1c5a      	adds	r2, r3, #1
 80223ae:	9219      	str	r2, [sp, #100]	@ 0x64
 80223b0:	785a      	ldrb	r2, [r3, #1]
 80223b2:	f1b9 0f00 	cmp.w	r9, #0
 80223b6:	d03a      	beq.n	802242e <_strtod_l+0x246>
 80223b8:	464d      	mov	r5, r9
 80223ba:	900a      	str	r0, [sp, #40]	@ 0x28
 80223bc:	f1a2 0330 	sub.w	r3, r2, #48	@ 0x30
 80223c0:	2b09      	cmp	r3, #9
 80223c2:	d912      	bls.n	80223ea <_strtod_l+0x202>
 80223c4:	2301      	movs	r3, #1
 80223c6:	e7c2      	b.n	802234e <_strtod_l+0x166>
 80223c8:	9b19      	ldr	r3, [sp, #100]	@ 0x64
 80223ca:	3001      	adds	r0, #1
 80223cc:	1c5a      	adds	r2, r3, #1
 80223ce:	9219      	str	r2, [sp, #100]	@ 0x64
 80223d0:	785a      	ldrb	r2, [r3, #1]
 80223d2:	2a30      	cmp	r2, #48	@ 0x30
 80223d4:	d0f8      	beq.n	80223c8 <_strtod_l+0x1e0>
 80223d6:	f1a2 0331 	sub.w	r3, r2, #49	@ 0x31
 80223da:	2b08      	cmp	r3, #8
 80223dc:	f200 84ca 	bhi.w	8022d74 <_strtod_l+0xb8c>
 80223e0:	900a      	str	r0, [sp, #40]	@ 0x28
 80223e2:	2000      	movs	r0, #0
 80223e4:	9b19      	ldr	r3, [sp, #100]	@ 0x64
 80223e6:	4605      	mov	r5, r0
 80223e8:	930c      	str	r3, [sp, #48]	@ 0x30
 80223ea:	3a30      	subs	r2, #48	@ 0x30
 80223ec:	f100 0301 	add.w	r3, r0, #1
 80223f0:	d017      	beq.n	8022422 <_strtod_l+0x23a>
 80223f2:	990a      	ldr	r1, [sp, #40]	@ 0x28
 80223f4:	462e      	mov	r6, r5
 80223f6:	f04f 0e0a 	mov.w	lr, #10
 80223fa:	4419      	add	r1, r3
 80223fc:	910a      	str	r1, [sp, #40]	@ 0x28
 80223fe:	1c71      	adds	r1, r6, #1
 8022400:	eba1 0c05 	sub.w	ip, r1, r5
 8022404:	4563      	cmp	r3, ip
 8022406:	dc14      	bgt.n	8022432 <_strtod_l+0x24a>
 8022408:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
 802240c:	182b      	adds	r3, r5, r0
 802240e:	3501      	adds	r5, #1
 8022410:	2b08      	cmp	r3, #8
 8022412:	4405      	add	r5, r0
 8022414:	dc1a      	bgt.n	802244c <_strtod_l+0x264>
 8022416:	990b      	ldr	r1, [sp, #44]	@ 0x2c
 8022418:	230a      	movs	r3, #10
 802241a:	fb03 2301 	mla	r3, r3, r1, r2
 802241e:	930b      	str	r3, [sp, #44]	@ 0x2c
 8022420:	2300      	movs	r3, #0
 8022422:	9a19      	ldr	r2, [sp, #100]	@ 0x64
 8022424:	4618      	mov	r0, r3
 8022426:	1c51      	adds	r1, r2, #1
 8022428:	9119      	str	r1, [sp, #100]	@ 0x64
 802242a:	7852      	ldrb	r2, [r2, #1]
 802242c:	e7c6      	b.n	80223bc <_strtod_l+0x1d4>
 802242e:	4648      	mov	r0, r9
 8022430:	e7cf      	b.n	80223d2 <_strtod_l+0x1ea>
 8022432:	2e08      	cmp	r6, #8
 8022434:	dc05      	bgt.n	8022442 <_strtod_l+0x25a>
 8022436:	9e0b      	ldr	r6, [sp, #44]	@ 0x2c
 8022438:	fb0e f606 	mul.w	r6, lr, r6
 802243c:	960b      	str	r6, [sp, #44]	@ 0x2c
 802243e:	460e      	mov	r6, r1
 8022440:	e7dd      	b.n	80223fe <_strtod_l+0x216>
 8022442:	2910      	cmp	r1, #16
 8022444:	bfd8      	it	le
 8022446:	fb0e f707 	mulle.w	r7, lr, r7
 802244a:	e7f8      	b.n	802243e <_strtod_l+0x256>
 802244c:	2b0f      	cmp	r3, #15
 802244e:	bfdc      	itt	le
 8022450:	230a      	movle	r3, #10
 8022452:	fb03 2707 	mlale	r7, r3, r7, r2
 8022456:	e7e3      	b.n	8022420 <_strtod_l+0x238>
 8022458:	2300      	movs	r3, #0
 802245a:	930a      	str	r3, [sp, #40]	@ 0x28
 802245c:	2301      	movs	r3, #1
 802245e:	e77b      	b.n	8022358 <_strtod_l+0x170>
 8022460:	f04f 0c00 	mov.w	ip, #0
 8022464:	1ca2      	adds	r2, r4, #2
 8022466:	9219      	str	r2, [sp, #100]	@ 0x64
 8022468:	78a2      	ldrb	r2, [r4, #2]
 802246a:	e783      	b.n	8022374 <_strtod_l+0x18c>
 802246c:	f04f 0c01 	mov.w	ip, #1
 8022470:	e7f8      	b.n	8022464 <_strtod_l+0x27c>
 8022472:	bf00      	nop
 8022474:	0802aa84 	.word	0x0802aa84
 8022478:	0802a8af 	.word	0x0802a8af
 802247c:	7ff00000 	.word	0x7ff00000
 8022480:	9a19      	ldr	r2, [sp, #100]	@ 0x64
 8022482:	1c51      	adds	r1, r2, #1
 8022484:	9119      	str	r1, [sp, #100]	@ 0x64
 8022486:	7852      	ldrb	r2, [r2, #1]
 8022488:	2a30      	cmp	r2, #48	@ 0x30
 802248a:	d0f9      	beq.n	8022480 <_strtod_l+0x298>
 802248c:	f1a2 0131 	sub.w	r1, r2, #49	@ 0x31
 8022490:	2908      	cmp	r1, #8
 8022492:	f63f af75 	bhi.w	8022380 <_strtod_l+0x198>
 8022496:	3a30      	subs	r2, #48	@ 0x30
 8022498:	f04f 080a 	mov.w	r8, #10
 802249c:	9209      	str	r2, [sp, #36]	@ 0x24
 802249e:	9a19      	ldr	r2, [sp, #100]	@ 0x64
 80224a0:	920f      	str	r2, [sp, #60]	@ 0x3c
 80224a2:	9a19      	ldr	r2, [sp, #100]	@ 0x64
 80224a4:	1c56      	adds	r6, r2, #1
 80224a6:	9619      	str	r6, [sp, #100]	@ 0x64
 80224a8:	7852      	ldrb	r2, [r2, #1]
 80224aa:	f1a2 0e30 	sub.w	lr, r2, #48	@ 0x30
 80224ae:	f1be 0f09 	cmp.w	lr, #9
 80224b2:	d939      	bls.n	8022528 <_strtod_l+0x340>
 80224b4:	990f      	ldr	r1, [sp, #60]	@ 0x3c
 80224b6:	f644 681f 	movw	r8, #19999	@ 0x4e1f
 80224ba:	1a76      	subs	r6, r6, r1
 80224bc:	2e08      	cmp	r6, #8
 80224be:	dc03      	bgt.n	80224c8 <_strtod_l+0x2e0>
 80224c0:	9909      	ldr	r1, [sp, #36]	@ 0x24
 80224c2:	4588      	cmp	r8, r1
 80224c4:	bfa8      	it	ge
 80224c6:	4688      	movge	r8, r1
 80224c8:	f1bc 0f00 	cmp.w	ip, #0
 80224cc:	d001      	beq.n	80224d2 <_strtod_l+0x2ea>
 80224ce:	f1c8 0800 	rsb	r8, r8, #0
 80224d2:	2d00      	cmp	r5, #0
 80224d4:	d14e      	bne.n	8022574 <_strtod_l+0x38c>
 80224d6:	9908      	ldr	r1, [sp, #32]
 80224d8:	4308      	orrs	r0, r1
 80224da:	f47f aebe 	bne.w	802225a <_strtod_l+0x72>
 80224de:	2b00      	cmp	r3, #0
 80224e0:	f47f aed4 	bne.w	802228c <_strtod_l+0xa4>
 80224e4:	2a69      	cmp	r2, #105	@ 0x69
 80224e6:	d028      	beq.n	802253a <_strtod_l+0x352>
 80224e8:	dc25      	bgt.n	8022536 <_strtod_l+0x34e>
 80224ea:	2a49      	cmp	r2, #73	@ 0x49
 80224ec:	d025      	beq.n	802253a <_strtod_l+0x352>
 80224ee:	2a4e      	cmp	r2, #78	@ 0x4e
 80224f0:	f47f aecc 	bne.w	802228c <_strtod_l+0xa4>
 80224f4:	4999      	ldr	r1, [pc, #612]	@ (802275c <_strtod_l+0x574>)
 80224f6:	a819      	add	r0, sp, #100	@ 0x64
 80224f8:	f002 ffe0 	bl	80254bc <__match>
 80224fc:	2800      	cmp	r0, #0
 80224fe:	f43f aec5 	beq.w	802228c <_strtod_l+0xa4>
 8022502:	9b19      	ldr	r3, [sp, #100]	@ 0x64
 8022504:	781b      	ldrb	r3, [r3, #0]
 8022506:	2b28      	cmp	r3, #40	@ 0x28
 8022508:	d12e      	bne.n	8022568 <_strtod_l+0x380>
 802250a:	aa1c      	add	r2, sp, #112	@ 0x70
 802250c:	4994      	ldr	r1, [pc, #592]	@ (8022760 <_strtod_l+0x578>)
 802250e:	a819      	add	r0, sp, #100	@ 0x64
 8022510:	f002 ffe8 	bl	80254e4 <__hexnan>
 8022514:	2805      	cmp	r0, #5
 8022516:	d127      	bne.n	8022568 <_strtod_l+0x380>
 8022518:	9b1d      	ldr	r3, [sp, #116]	@ 0x74
 802251a:	f8dd a070 	ldr.w	sl, [sp, #112]	@ 0x70
 802251e:	f043 4bff 	orr.w	fp, r3, #2139095040	@ 0x7f800000
 8022522:	f44b 0be0 	orr.w	fp, fp, #7340032	@ 0x700000
 8022526:	e698      	b.n	802225a <_strtod_l+0x72>
 8022528:	9909      	ldr	r1, [sp, #36]	@ 0x24
 802252a:	fb08 2101 	mla	r1, r8, r1, r2
 802252e:	f1a1 0230 	sub.w	r2, r1, #48	@ 0x30
 8022532:	9209      	str	r2, [sp, #36]	@ 0x24
 8022534:	e7b5      	b.n	80224a2 <_strtod_l+0x2ba>
 8022536:	2a6e      	cmp	r2, #110	@ 0x6e
 8022538:	e7da      	b.n	80224f0 <_strtod_l+0x308>
 802253a:	498a      	ldr	r1, [pc, #552]	@ (8022764 <_strtod_l+0x57c>)
 802253c:	a819      	add	r0, sp, #100	@ 0x64
 802253e:	f002 ffbd 	bl	80254bc <__match>
 8022542:	2800      	cmp	r0, #0
 8022544:	f43f aea2 	beq.w	802228c <_strtod_l+0xa4>
 8022548:	9b19      	ldr	r3, [sp, #100]	@ 0x64
 802254a:	a819      	add	r0, sp, #100	@ 0x64
 802254c:	4986      	ldr	r1, [pc, #536]	@ (8022768 <_strtod_l+0x580>)
 802254e:	3b01      	subs	r3, #1
 8022550:	9319      	str	r3, [sp, #100]	@ 0x64
 8022552:	f002 ffb3 	bl	80254bc <__match>
 8022556:	b910      	cbnz	r0, 802255e <_strtod_l+0x376>
 8022558:	9b19      	ldr	r3, [sp, #100]	@ 0x64
 802255a:	3301      	adds	r3, #1
 802255c:	9319      	str	r3, [sp, #100]	@ 0x64
 802255e:	f8df b218 	ldr.w	fp, [pc, #536]	@ 8022778 <_strtod_l+0x590>
 8022562:	f04f 0a00 	mov.w	sl, #0
 8022566:	e678      	b.n	802225a <_strtod_l+0x72>
 8022568:	4880      	ldr	r0, [pc, #512]	@ (802276c <_strtod_l+0x584>)
 802256a:	f001 fe4d 	bl	8024208 <nan>
 802256e:	4682      	mov	sl, r0
 8022570:	468b      	mov	fp, r1
 8022572:	e672      	b.n	802225a <_strtod_l+0x72>
 8022574:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8022576:	f1b9 0f00 	cmp.w	r9, #0
 802257a:	bf08      	it	eq
 802257c:	46a9      	moveq	r9, r5
 802257e:	2d10      	cmp	r5, #16
 8022580:	980b      	ldr	r0, [sp, #44]	@ 0x2c
 8022582:	eba8 0303 	sub.w	r3, r8, r3
 8022586:	462c      	mov	r4, r5
 8022588:	bfa8      	it	ge
 802258a:	2410      	movge	r4, #16
 802258c:	9309      	str	r3, [sp, #36]	@ 0x24
 802258e:	f7dd ffc7 	bl	8000520 <__aeabi_ui2d>
 8022592:	2d09      	cmp	r5, #9
 8022594:	4682      	mov	sl, r0
 8022596:	468b      	mov	fp, r1
 8022598:	dc11      	bgt.n	80225be <_strtod_l+0x3d6>
 802259a:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 802259c:	2b00      	cmp	r3, #0
 802259e:	f43f ae5c 	beq.w	802225a <_strtod_l+0x72>
 80225a2:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 80225a4:	dd76      	ble.n	8022694 <_strtod_l+0x4ac>
 80225a6:	2b16      	cmp	r3, #22
 80225a8:	dc5d      	bgt.n	8022666 <_strtod_l+0x47e>
 80225aa:	4971      	ldr	r1, [pc, #452]	@ (8022770 <_strtod_l+0x588>)
 80225ac:	4652      	mov	r2, sl
 80225ae:	eb01 01c3 	add.w	r1, r1, r3, lsl #3
 80225b2:	465b      	mov	r3, fp
 80225b4:	e9d1 0100 	ldrd	r0, r1, [r1]
 80225b8:	f7de f82c 	bl	8000614 <__aeabi_dmul>
 80225bc:	e7d7      	b.n	802256e <_strtod_l+0x386>
 80225be:	4b6c      	ldr	r3, [pc, #432]	@ (8022770 <_strtod_l+0x588>)
 80225c0:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
 80225c4:	e953 2312 	ldrd	r2, r3, [r3, #-72]	@ 0x48
 80225c8:	f7de f824 	bl	8000614 <__aeabi_dmul>
 80225cc:	4682      	mov	sl, r0
 80225ce:	468b      	mov	fp, r1
 80225d0:	4638      	mov	r0, r7
 80225d2:	f7dd ffa5 	bl	8000520 <__aeabi_ui2d>
 80225d6:	4602      	mov	r2, r0
 80225d8:	460b      	mov	r3, r1
 80225da:	4650      	mov	r0, sl
 80225dc:	4659      	mov	r1, fp
 80225de:	f7dd fe63 	bl	80002a8 <__adddf3>
 80225e2:	2d0f      	cmp	r5, #15
 80225e4:	4682      	mov	sl, r0
 80225e6:	468b      	mov	fp, r1
 80225e8:	ddd7      	ble.n	802259a <_strtod_l+0x3b2>
 80225ea:	1b2c      	subs	r4, r5, r4
 80225ec:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 80225ee:	441c      	add	r4, r3
 80225f0:	2c00      	cmp	r4, #0
 80225f2:	f340 8093 	ble.w	802271c <_strtod_l+0x534>
 80225f6:	f014 030f 	ands.w	r3, r4, #15
 80225fa:	d00a      	beq.n	8022612 <_strtod_l+0x42a>
 80225fc:	495c      	ldr	r1, [pc, #368]	@ (8022770 <_strtod_l+0x588>)
 80225fe:	4652      	mov	r2, sl
 8022600:	eb01 01c3 	add.w	r1, r1, r3, lsl #3
 8022604:	465b      	mov	r3, fp
 8022606:	e9d1 0100 	ldrd	r0, r1, [r1]
 802260a:	f7de f803 	bl	8000614 <__aeabi_dmul>
 802260e:	4682      	mov	sl, r0
 8022610:	468b      	mov	fp, r1
 8022612:	f034 040f 	bics.w	r4, r4, #15
 8022616:	d073      	beq.n	8022700 <_strtod_l+0x518>
 8022618:	f5b4 7f9a 	cmp.w	r4, #308	@ 0x134
 802261c:	dd49      	ble.n	80226b2 <_strtod_l+0x4ca>
 802261e:	2400      	movs	r4, #0
 8022620:	46a0      	mov	r8, r4
 8022622:	46a1      	mov	r9, r4
 8022624:	940b      	str	r4, [sp, #44]	@ 0x2c
 8022626:	2322      	movs	r3, #34	@ 0x22
 8022628:	9a05      	ldr	r2, [sp, #20]
 802262a:	f8df b14c 	ldr.w	fp, [pc, #332]	@ 8022778 <_strtod_l+0x590>
 802262e:	f04f 0a00 	mov.w	sl, #0
 8022632:	6013      	str	r3, [r2, #0]
 8022634:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 8022636:	2b00      	cmp	r3, #0
 8022638:	f43f ae0f 	beq.w	802225a <_strtod_l+0x72>
 802263c:	991a      	ldr	r1, [sp, #104]	@ 0x68
 802263e:	9805      	ldr	r0, [sp, #20]
 8022640:	f003 f83e 	bl	80256c0 <_Bfree>
 8022644:	4649      	mov	r1, r9
 8022646:	9805      	ldr	r0, [sp, #20]
 8022648:	f003 f83a 	bl	80256c0 <_Bfree>
 802264c:	4641      	mov	r1, r8
 802264e:	9805      	ldr	r0, [sp, #20]
 8022650:	f003 f836 	bl	80256c0 <_Bfree>
 8022654:	990b      	ldr	r1, [sp, #44]	@ 0x2c
 8022656:	9805      	ldr	r0, [sp, #20]
 8022658:	f003 f832 	bl	80256c0 <_Bfree>
 802265c:	4621      	mov	r1, r4
 802265e:	9805      	ldr	r0, [sp, #20]
 8022660:	f003 f82e 	bl	80256c0 <_Bfree>
 8022664:	e5f9      	b.n	802225a <_strtod_l+0x72>
 8022666:	f1c5 0325 	rsb	r3, r5, #37	@ 0x25
 802266a:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 802266c:	4293      	cmp	r3, r2
 802266e:	dbbc      	blt.n	80225ea <_strtod_l+0x402>
 8022670:	f1c5 050f 	rsb	r5, r5, #15
 8022674:	4c3e      	ldr	r4, [pc, #248]	@ (8022770 <_strtod_l+0x588>)
 8022676:	4652      	mov	r2, sl
 8022678:	465b      	mov	r3, fp
 802267a:	eb04 01c5 	add.w	r1, r4, r5, lsl #3
 802267e:	e9d1 0100 	ldrd	r0, r1, [r1]
 8022682:	f7dd ffc7 	bl	8000614 <__aeabi_dmul>
 8022686:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8022688:	1b5d      	subs	r5, r3, r5
 802268a:	eb04 04c5 	add.w	r4, r4, r5, lsl #3
 802268e:	e9d4 2300 	ldrd	r2, r3, [r4]
 8022692:	e791      	b.n	80225b8 <_strtod_l+0x3d0>
 8022694:	3316      	adds	r3, #22
 8022696:	dba8      	blt.n	80225ea <_strtod_l+0x402>
 8022698:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 802269a:	4650      	mov	r0, sl
 802269c:	4659      	mov	r1, fp
 802269e:	eba3 0808 	sub.w	r8, r3, r8
 80226a2:	4b33      	ldr	r3, [pc, #204]	@ (8022770 <_strtod_l+0x588>)
 80226a4:	eb03 08c8 	add.w	r8, r3, r8, lsl #3
 80226a8:	e9d8 2300 	ldrd	r2, r3, [r8]
 80226ac:	f7de f8dc 	bl	8000868 <__aeabi_ddiv>
 80226b0:	e75d      	b.n	802256e <_strtod_l+0x386>
 80226b2:	2300      	movs	r3, #0
 80226b4:	1124      	asrs	r4, r4, #4
 80226b6:	4650      	mov	r0, sl
 80226b8:	4659      	mov	r1, fp
 80226ba:	4f2e      	ldr	r7, [pc, #184]	@ (8022774 <_strtod_l+0x58c>)
 80226bc:	461e      	mov	r6, r3
 80226be:	2c01      	cmp	r4, #1
 80226c0:	dc21      	bgt.n	8022706 <_strtod_l+0x51e>
 80226c2:	b10b      	cbz	r3, 80226c8 <_strtod_l+0x4e0>
 80226c4:	4682      	mov	sl, r0
 80226c6:	468b      	mov	fp, r1
 80226c8:	492a      	ldr	r1, [pc, #168]	@ (8022774 <_strtod_l+0x58c>)
 80226ca:	f1ab 7b54 	sub.w	fp, fp, #55574528	@ 0x3500000
 80226ce:	4652      	mov	r2, sl
 80226d0:	eb01 01c6 	add.w	r1, r1, r6, lsl #3
 80226d4:	465b      	mov	r3, fp
 80226d6:	e9d1 0100 	ldrd	r0, r1, [r1]
 80226da:	f7dd ff9b 	bl	8000614 <__aeabi_dmul>
 80226de:	4b26      	ldr	r3, [pc, #152]	@ (8022778 <_strtod_l+0x590>)
 80226e0:	460a      	mov	r2, r1
 80226e2:	4682      	mov	sl, r0
 80226e4:	400b      	ands	r3, r1
 80226e6:	4925      	ldr	r1, [pc, #148]	@ (802277c <_strtod_l+0x594>)
 80226e8:	428b      	cmp	r3, r1
 80226ea:	d898      	bhi.n	802261e <_strtod_l+0x436>
 80226ec:	f5a1 1180 	sub.w	r1, r1, #1048576	@ 0x100000
 80226f0:	428b      	cmp	r3, r1
 80226f2:	bf86      	itte	hi
 80226f4:	f8df b088 	ldrhi.w	fp, [pc, #136]	@ 8022780 <_strtod_l+0x598>
 80226f8:	f04f 3aff 	movhi.w	sl, #4294967295
 80226fc:	f102 7b54 	addls.w	fp, r2, #55574528	@ 0x3500000
 8022700:	2300      	movs	r3, #0
 8022702:	9308      	str	r3, [sp, #32]
 8022704:	e076      	b.n	80227f4 <_strtod_l+0x60c>
 8022706:	07e2      	lsls	r2, r4, #31
 8022708:	d504      	bpl.n	8022714 <_strtod_l+0x52c>
 802270a:	e9d7 2300 	ldrd	r2, r3, [r7]
 802270e:	f7dd ff81 	bl	8000614 <__aeabi_dmul>
 8022712:	2301      	movs	r3, #1
 8022714:	3601      	adds	r6, #1
 8022716:	1064      	asrs	r4, r4, #1
 8022718:	3708      	adds	r7, #8
 802271a:	e7d0      	b.n	80226be <_strtod_l+0x4d6>
 802271c:	d0f0      	beq.n	8022700 <_strtod_l+0x518>
 802271e:	4264      	negs	r4, r4
 8022720:	f014 020f 	ands.w	r2, r4, #15
 8022724:	d00a      	beq.n	802273c <_strtod_l+0x554>
 8022726:	4b12      	ldr	r3, [pc, #72]	@ (8022770 <_strtod_l+0x588>)
 8022728:	4650      	mov	r0, sl
 802272a:	4659      	mov	r1, fp
 802272c:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8022730:	e9d3 2300 	ldrd	r2, r3, [r3]
 8022734:	f7de f898 	bl	8000868 <__aeabi_ddiv>
 8022738:	4682      	mov	sl, r0
 802273a:	468b      	mov	fp, r1
 802273c:	1124      	asrs	r4, r4, #4
 802273e:	d0df      	beq.n	8022700 <_strtod_l+0x518>
 8022740:	2c1f      	cmp	r4, #31
 8022742:	dd1f      	ble.n	8022784 <_strtod_l+0x59c>
 8022744:	2400      	movs	r4, #0
 8022746:	46a0      	mov	r8, r4
 8022748:	46a1      	mov	r9, r4
 802274a:	940b      	str	r4, [sp, #44]	@ 0x2c
 802274c:	2322      	movs	r3, #34	@ 0x22
 802274e:	9a05      	ldr	r2, [sp, #20]
 8022750:	f04f 0a00 	mov.w	sl, #0
 8022754:	f04f 0b00 	mov.w	fp, #0
 8022758:	6013      	str	r3, [r2, #0]
 802275a:	e76b      	b.n	8022634 <_strtod_l+0x44c>
 802275c:	0802a8be 	.word	0x0802a8be
 8022760:	0802aa70 	.word	0x0802aa70
 8022764:	0802a8b6 	.word	0x0802a8b6
 8022768:	0802a931 	.word	0x0802a931
 802276c:	0802a92d 	.word	0x0802a92d
 8022770:	0802abf8 	.word	0x0802abf8
 8022774:	0802abd0 	.word	0x0802abd0
 8022778:	7ff00000 	.word	0x7ff00000
 802277c:	7ca00000 	.word	0x7ca00000
 8022780:	7fefffff 	.word	0x7fefffff
 8022784:	f014 0310 	ands.w	r3, r4, #16
 8022788:	4650      	mov	r0, sl
 802278a:	4659      	mov	r1, fp
 802278c:	4e78      	ldr	r6, [pc, #480]	@ (8022970 <_strtod_l+0x788>)
 802278e:	bf18      	it	ne
 8022790:	236a      	movne	r3, #106	@ 0x6a
 8022792:	9308      	str	r3, [sp, #32]
 8022794:	2300      	movs	r3, #0
 8022796:	07e7      	lsls	r7, r4, #31
 8022798:	d504      	bpl.n	80227a4 <_strtod_l+0x5bc>
 802279a:	e9d6 2300 	ldrd	r2, r3, [r6]
 802279e:	f7dd ff39 	bl	8000614 <__aeabi_dmul>
 80227a2:	2301      	movs	r3, #1
 80227a4:	1064      	asrs	r4, r4, #1
 80227a6:	f106 0608 	add.w	r6, r6, #8
 80227aa:	d1f4      	bne.n	8022796 <_strtod_l+0x5ae>
 80227ac:	b10b      	cbz	r3, 80227b2 <_strtod_l+0x5ca>
 80227ae:	4682      	mov	sl, r0
 80227b0:	468b      	mov	fp, r1
 80227b2:	9b08      	ldr	r3, [sp, #32]
 80227b4:	b1b3      	cbz	r3, 80227e4 <_strtod_l+0x5fc>
 80227b6:	f3cb 520a 	ubfx	r2, fp, #20, #11
 80227ba:	4659      	mov	r1, fp
 80227bc:	f1c2 036b 	rsb	r3, r2, #107	@ 0x6b
 80227c0:	2b00      	cmp	r3, #0
 80227c2:	dd0f      	ble.n	80227e4 <_strtod_l+0x5fc>
 80227c4:	2b1f      	cmp	r3, #31
 80227c6:	dd58      	ble.n	802287a <_strtod_l+0x692>
 80227c8:	2b34      	cmp	r3, #52	@ 0x34
 80227ca:	f04f 0a00 	mov.w	sl, #0
 80227ce:	bfdb      	ittet	le
 80227d0:	f04f 33ff 	movle.w	r3, #4294967295
 80227d4:	f1c2 024b 	rsble	r2, r2, #75	@ 0x4b
 80227d8:	f04f 7b5c 	movgt.w	fp, #57671680	@ 0x3700000
 80227dc:	4093      	lslle	r3, r2
 80227de:	bfd8      	it	le
 80227e0:	ea03 0b01 	andle.w	fp, r3, r1
 80227e4:	2200      	movs	r2, #0
 80227e6:	2300      	movs	r3, #0
 80227e8:	4650      	mov	r0, sl
 80227ea:	4659      	mov	r1, fp
 80227ec:	f7de f97a 	bl	8000ae4 <__aeabi_dcmpeq>
 80227f0:	2800      	cmp	r0, #0
 80227f2:	d1a7      	bne.n	8022744 <_strtod_l+0x55c>
 80227f4:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 80227f6:	464a      	mov	r2, r9
 80227f8:	990c      	ldr	r1, [sp, #48]	@ 0x30
 80227fa:	9300      	str	r3, [sp, #0]
 80227fc:	462b      	mov	r3, r5
 80227fe:	9805      	ldr	r0, [sp, #20]
 8022800:	f002 ffc8 	bl	8025794 <__s2b>
 8022804:	900b      	str	r0, [sp, #44]	@ 0x2c
 8022806:	2800      	cmp	r0, #0
 8022808:	f43f af09 	beq.w	802261e <_strtod_l+0x436>
 802280c:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 802280e:	2400      	movs	r4, #0
 8022810:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8022812:	2a00      	cmp	r2, #0
 8022814:	eba3 0308 	sub.w	r3, r3, r8
 8022818:	46a0      	mov	r8, r4
 802281a:	bfa8      	it	ge
 802281c:	2300      	movge	r3, #0
 802281e:	9312      	str	r3, [sp, #72]	@ 0x48
 8022820:	ea22 73e2 	bic.w	r3, r2, r2, asr #31
 8022824:	9316      	str	r3, [sp, #88]	@ 0x58
 8022826:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 8022828:	9805      	ldr	r0, [sp, #20]
 802282a:	6859      	ldr	r1, [r3, #4]
 802282c:	f002 ff08 	bl	8025640 <_Balloc>
 8022830:	4681      	mov	r9, r0
 8022832:	2800      	cmp	r0, #0
 8022834:	f43f aef7 	beq.w	8022626 <_strtod_l+0x43e>
 8022838:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 802283a:	300c      	adds	r0, #12
 802283c:	691a      	ldr	r2, [r3, #16]
 802283e:	f103 010c 	add.w	r1, r3, #12
 8022842:	3202      	adds	r2, #2
 8022844:	0092      	lsls	r2, r2, #2
 8022846:	f001 fcd2 	bl	80241ee <memcpy>
 802284a:	ab1c      	add	r3, sp, #112	@ 0x70
 802284c:	4652      	mov	r2, sl
 802284e:	9805      	ldr	r0, [sp, #20]
 8022850:	9301      	str	r3, [sp, #4]
 8022852:	ab1b      	add	r3, sp, #108	@ 0x6c
 8022854:	9300      	str	r3, [sp, #0]
 8022856:	465b      	mov	r3, fp
 8022858:	e9cd ab0c 	strd	sl, fp, [sp, #48]	@ 0x30
 802285c:	f003 face 	bl	8025dfc <__d2b>
 8022860:	901a      	str	r0, [sp, #104]	@ 0x68
 8022862:	2800      	cmp	r0, #0
 8022864:	f43f aedf 	beq.w	8022626 <_strtod_l+0x43e>
 8022868:	2101      	movs	r1, #1
 802286a:	9805      	ldr	r0, [sp, #20]
 802286c:	f003 f828 	bl	80258c0 <__i2b>
 8022870:	4680      	mov	r8, r0
 8022872:	b948      	cbnz	r0, 8022888 <_strtod_l+0x6a0>
 8022874:	f04f 0800 	mov.w	r8, #0
 8022878:	e6d5      	b.n	8022626 <_strtod_l+0x43e>
 802287a:	f04f 32ff 	mov.w	r2, #4294967295
 802287e:	fa02 f303 	lsl.w	r3, r2, r3
 8022882:	ea03 0a0a 	and.w	sl, r3, sl
 8022886:	e7ad      	b.n	80227e4 <_strtod_l+0x5fc>
 8022888:	9d1b      	ldr	r5, [sp, #108]	@ 0x6c
 802288a:	9a1c      	ldr	r2, [sp, #112]	@ 0x70
 802288c:	2d00      	cmp	r5, #0
 802288e:	bfa9      	itett	ge
 8022890:	9b12      	ldrge	r3, [sp, #72]	@ 0x48
 8022892:	9b16      	ldrlt	r3, [sp, #88]	@ 0x58
 8022894:	18ef      	addge	r7, r5, r3
 8022896:	9e16      	ldrge	r6, [sp, #88]	@ 0x58
 8022898:	bfb8      	it	lt
 802289a:	1b5e      	sublt	r6, r3, r5
 802289c:	9b08      	ldr	r3, [sp, #32]
 802289e:	bfb8      	it	lt
 80228a0:	9f12      	ldrlt	r7, [sp, #72]	@ 0x48
 80228a2:	1aed      	subs	r5, r5, r3
 80228a4:	4b33      	ldr	r3, [pc, #204]	@ (8022974 <_strtod_l+0x78c>)
 80228a6:	4415      	add	r5, r2
 80228a8:	f1c2 0236 	rsb	r2, r2, #54	@ 0x36
 80228ac:	3d01      	subs	r5, #1
 80228ae:	429d      	cmp	r5, r3
 80228b0:	da4f      	bge.n	8022952 <_strtod_l+0x76a>
 80228b2:	1b5b      	subs	r3, r3, r5
 80228b4:	2101      	movs	r1, #1
 80228b6:	2b1f      	cmp	r3, #31
 80228b8:	eba2 0203 	sub.w	r2, r2, r3
 80228bc:	dc3d      	bgt.n	802293a <_strtod_l+0x752>
 80228be:	fa01 f303 	lsl.w	r3, r1, r3
 80228c2:	9313      	str	r3, [sp, #76]	@ 0x4c
 80228c4:	2300      	movs	r3, #0
 80228c6:	9310      	str	r3, [sp, #64]	@ 0x40
 80228c8:	18bd      	adds	r5, r7, r2
 80228ca:	9b08      	ldr	r3, [sp, #32]
 80228cc:	4416      	add	r6, r2
 80228ce:	42af      	cmp	r7, r5
 80228d0:	441e      	add	r6, r3
 80228d2:	463b      	mov	r3, r7
 80228d4:	bfa8      	it	ge
 80228d6:	462b      	movge	r3, r5
 80228d8:	42b3      	cmp	r3, r6
 80228da:	bfa8      	it	ge
 80228dc:	4633      	movge	r3, r6
 80228de:	2b00      	cmp	r3, #0
 80228e0:	bfc2      	ittt	gt
 80228e2:	1aed      	subgt	r5, r5, r3
 80228e4:	1af6      	subgt	r6, r6, r3
 80228e6:	1aff      	subgt	r7, r7, r3
 80228e8:	9b12      	ldr	r3, [sp, #72]	@ 0x48
 80228ea:	2b00      	cmp	r3, #0
 80228ec:	dd16      	ble.n	802291c <_strtod_l+0x734>
 80228ee:	4641      	mov	r1, r8
 80228f0:	461a      	mov	r2, r3
 80228f2:	9805      	ldr	r0, [sp, #20]
 80228f4:	f003 f89e 	bl	8025a34 <__pow5mult>
 80228f8:	4680      	mov	r8, r0
 80228fa:	2800      	cmp	r0, #0
 80228fc:	d0ba      	beq.n	8022874 <_strtod_l+0x68c>
 80228fe:	4601      	mov	r1, r0
 8022900:	9a1a      	ldr	r2, [sp, #104]	@ 0x68
 8022902:	9805      	ldr	r0, [sp, #20]
 8022904:	f002 fff2 	bl	80258ec <__multiply>
 8022908:	900a      	str	r0, [sp, #40]	@ 0x28
 802290a:	2800      	cmp	r0, #0
 802290c:	f43f ae8b 	beq.w	8022626 <_strtod_l+0x43e>
 8022910:	991a      	ldr	r1, [sp, #104]	@ 0x68
 8022912:	9805      	ldr	r0, [sp, #20]
 8022914:	f002 fed4 	bl	80256c0 <_Bfree>
 8022918:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 802291a:	931a      	str	r3, [sp, #104]	@ 0x68
 802291c:	2d00      	cmp	r5, #0
 802291e:	dc1d      	bgt.n	802295c <_strtod_l+0x774>
 8022920:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8022922:	2b00      	cmp	r3, #0
 8022924:	dd28      	ble.n	8022978 <_strtod_l+0x790>
 8022926:	4649      	mov	r1, r9
 8022928:	9a16      	ldr	r2, [sp, #88]	@ 0x58
 802292a:	9805      	ldr	r0, [sp, #20]
 802292c:	f003 f882 	bl	8025a34 <__pow5mult>
 8022930:	4681      	mov	r9, r0
 8022932:	bb08      	cbnz	r0, 8022978 <_strtod_l+0x790>
 8022934:	f04f 0900 	mov.w	r9, #0
 8022938:	e675      	b.n	8022626 <_strtod_l+0x43e>
 802293a:	f1c5 457f 	rsb	r5, r5, #4278190080	@ 0xff000000
 802293e:	9113      	str	r1, [sp, #76]	@ 0x4c
 8022940:	f505 057f 	add.w	r5, r5, #16711680	@ 0xff0000
 8022944:	f505 457b 	add.w	r5, r5, #64256	@ 0xfb00
 8022948:	35e2      	adds	r5, #226	@ 0xe2
 802294a:	fa01 f305 	lsl.w	r3, r1, r5
 802294e:	9310      	str	r3, [sp, #64]	@ 0x40
 8022950:	e7ba      	b.n	80228c8 <_strtod_l+0x6e0>
 8022952:	2300      	movs	r3, #0
 8022954:	9310      	str	r3, [sp, #64]	@ 0x40
 8022956:	2301      	movs	r3, #1
 8022958:	9313      	str	r3, [sp, #76]	@ 0x4c
 802295a:	e7b5      	b.n	80228c8 <_strtod_l+0x6e0>
 802295c:	462a      	mov	r2, r5
 802295e:	991a      	ldr	r1, [sp, #104]	@ 0x68
 8022960:	9805      	ldr	r0, [sp, #20]
 8022962:	f003 f8c1 	bl	8025ae8 <__lshift>
 8022966:	901a      	str	r0, [sp, #104]	@ 0x68
 8022968:	2800      	cmp	r0, #0
 802296a:	d1d9      	bne.n	8022920 <_strtod_l+0x738>
 802296c:	e65b      	b.n	8022626 <_strtod_l+0x43e>
 802296e:	bf00      	nop
 8022970:	0802aa98 	.word	0x0802aa98
 8022974:	fffffc02 	.word	0xfffffc02
 8022978:	2e00      	cmp	r6, #0
 802297a:	dd07      	ble.n	802298c <_strtod_l+0x7a4>
 802297c:	4649      	mov	r1, r9
 802297e:	4632      	mov	r2, r6
 8022980:	9805      	ldr	r0, [sp, #20]
 8022982:	f003 f8b1 	bl	8025ae8 <__lshift>
 8022986:	4681      	mov	r9, r0
 8022988:	2800      	cmp	r0, #0
 802298a:	d0d3      	beq.n	8022934 <_strtod_l+0x74c>
 802298c:	2f00      	cmp	r7, #0
 802298e:	dd08      	ble.n	80229a2 <_strtod_l+0x7ba>
 8022990:	4641      	mov	r1, r8
 8022992:	463a      	mov	r2, r7
 8022994:	9805      	ldr	r0, [sp, #20]
 8022996:	f003 f8a7 	bl	8025ae8 <__lshift>
 802299a:	4680      	mov	r8, r0
 802299c:	2800      	cmp	r0, #0
 802299e:	f43f ae42 	beq.w	8022626 <_strtod_l+0x43e>
 80229a2:	464a      	mov	r2, r9
 80229a4:	991a      	ldr	r1, [sp, #104]	@ 0x68
 80229a6:	9805      	ldr	r0, [sp, #20]
 80229a8:	f003 f926 	bl	8025bf8 <__mdiff>
 80229ac:	4604      	mov	r4, r0
 80229ae:	2800      	cmp	r0, #0
 80229b0:	f43f ae39 	beq.w	8022626 <_strtod_l+0x43e>
 80229b4:	68c3      	ldr	r3, [r0, #12]
 80229b6:	4641      	mov	r1, r8
 80229b8:	930f      	str	r3, [sp, #60]	@ 0x3c
 80229ba:	2300      	movs	r3, #0
 80229bc:	60c3      	str	r3, [r0, #12]
 80229be:	f003 f8ff 	bl	8025bc0 <__mcmp>
 80229c2:	2800      	cmp	r0, #0
 80229c4:	da3d      	bge.n	8022a42 <_strtod_l+0x85a>
 80229c6:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 80229c8:	ea53 030a 	orrs.w	r3, r3, sl
 80229cc:	d163      	bne.n	8022a96 <_strtod_l+0x8ae>
 80229ce:	f3cb 0313 	ubfx	r3, fp, #0, #20
 80229d2:	2b00      	cmp	r3, #0
 80229d4:	d15f      	bne.n	8022a96 <_strtod_l+0x8ae>
 80229d6:	f02b 4300 	bic.w	r3, fp, #2147483648	@ 0x80000000
 80229da:	0d1b      	lsrs	r3, r3, #20
 80229dc:	051b      	lsls	r3, r3, #20
 80229de:	f1b3 6fd6 	cmp.w	r3, #112197632	@ 0x6b00000
 80229e2:	d958      	bls.n	8022a96 <_strtod_l+0x8ae>
 80229e4:	6963      	ldr	r3, [r4, #20]
 80229e6:	b913      	cbnz	r3, 80229ee <_strtod_l+0x806>
 80229e8:	6923      	ldr	r3, [r4, #16]
 80229ea:	2b01      	cmp	r3, #1
 80229ec:	dd53      	ble.n	8022a96 <_strtod_l+0x8ae>
 80229ee:	4621      	mov	r1, r4
 80229f0:	2201      	movs	r2, #1
 80229f2:	9805      	ldr	r0, [sp, #20]
 80229f4:	f003 f878 	bl	8025ae8 <__lshift>
 80229f8:	4641      	mov	r1, r8
 80229fa:	4604      	mov	r4, r0
 80229fc:	f003 f8e0 	bl	8025bc0 <__mcmp>
 8022a00:	2800      	cmp	r0, #0
 8022a02:	dd48      	ble.n	8022a96 <_strtod_l+0x8ae>
 8022a04:	f02b 4300 	bic.w	r3, fp, #2147483648	@ 0x80000000
 8022a08:	9a08      	ldr	r2, [sp, #32]
 8022a0a:	0d1b      	lsrs	r3, r3, #20
 8022a0c:	051b      	lsls	r3, r3, #20
 8022a0e:	2a00      	cmp	r2, #0
 8022a10:	d062      	beq.n	8022ad8 <_strtod_l+0x8f0>
 8022a12:	f1b3 6fd6 	cmp.w	r3, #112197632	@ 0x6b00000
 8022a16:	d85f      	bhi.n	8022ad8 <_strtod_l+0x8f0>
 8022a18:	f1b3 7f5c 	cmp.w	r3, #57671680	@ 0x3700000
 8022a1c:	f67f ae96 	bls.w	802274c <_strtod_l+0x564>
 8022a20:	4ba7      	ldr	r3, [pc, #668]	@ (8022cc0 <_strtod_l+0xad8>)
 8022a22:	4650      	mov	r0, sl
 8022a24:	4659      	mov	r1, fp
 8022a26:	2200      	movs	r2, #0
 8022a28:	f7dd fdf4 	bl	8000614 <__aeabi_dmul>
 8022a2c:	4ba5      	ldr	r3, [pc, #660]	@ (8022cc4 <_strtod_l+0xadc>)
 8022a2e:	4682      	mov	sl, r0
 8022a30:	468b      	mov	fp, r1
 8022a32:	400b      	ands	r3, r1
 8022a34:	2b00      	cmp	r3, #0
 8022a36:	f47f ae01 	bne.w	802263c <_strtod_l+0x454>
 8022a3a:	2322      	movs	r3, #34	@ 0x22
 8022a3c:	9a05      	ldr	r2, [sp, #20]
 8022a3e:	6013      	str	r3, [r2, #0]
 8022a40:	e5fc      	b.n	802263c <_strtod_l+0x454>
 8022a42:	f8cd b028 	str.w	fp, [sp, #40]	@ 0x28
 8022a46:	d165      	bne.n	8022b14 <_strtod_l+0x92c>
 8022a48:	9a0f      	ldr	r2, [sp, #60]	@ 0x3c
 8022a4a:	f3cb 0313 	ubfx	r3, fp, #0, #20
 8022a4e:	b35a      	cbz	r2, 8022aa8 <_strtod_l+0x8c0>
 8022a50:	4a9d      	ldr	r2, [pc, #628]	@ (8022cc8 <_strtod_l+0xae0>)
 8022a52:	4293      	cmp	r3, r2
 8022a54:	d12b      	bne.n	8022aae <_strtod_l+0x8c6>
 8022a56:	9b08      	ldr	r3, [sp, #32]
 8022a58:	4651      	mov	r1, sl
 8022a5a:	b303      	cbz	r3, 8022a9e <_strtod_l+0x8b6>
 8022a5c:	465a      	mov	r2, fp
 8022a5e:	4b99      	ldr	r3, [pc, #612]	@ (8022cc4 <_strtod_l+0xadc>)
 8022a60:	4013      	ands	r3, r2
 8022a62:	f04f 32ff 	mov.w	r2, #4294967295
 8022a66:	f1b3 6fd4 	cmp.w	r3, #111149056	@ 0x6a00000
 8022a6a:	d81b      	bhi.n	8022aa4 <_strtod_l+0x8bc>
 8022a6c:	0d1b      	lsrs	r3, r3, #20
 8022a6e:	f1c3 036b 	rsb	r3, r3, #107	@ 0x6b
 8022a72:	fa02 f303 	lsl.w	r3, r2, r3
 8022a76:	4299      	cmp	r1, r3
 8022a78:	d119      	bne.n	8022aae <_strtod_l+0x8c6>
 8022a7a:	4b94      	ldr	r3, [pc, #592]	@ (8022ccc <_strtod_l+0xae4>)
 8022a7c:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 8022a7e:	429a      	cmp	r2, r3
 8022a80:	d102      	bne.n	8022a88 <_strtod_l+0x8a0>
 8022a82:	3101      	adds	r1, #1
 8022a84:	f43f adcf 	beq.w	8022626 <_strtod_l+0x43e>
 8022a88:	4b8e      	ldr	r3, [pc, #568]	@ (8022cc4 <_strtod_l+0xadc>)
 8022a8a:	f04f 0a00 	mov.w	sl, #0
 8022a8e:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 8022a90:	401a      	ands	r2, r3
 8022a92:	f502 1b80 	add.w	fp, r2, #1048576	@ 0x100000
 8022a96:	9b08      	ldr	r3, [sp, #32]
 8022a98:	2b00      	cmp	r3, #0
 8022a9a:	d1c1      	bne.n	8022a20 <_strtod_l+0x838>
 8022a9c:	e5ce      	b.n	802263c <_strtod_l+0x454>
 8022a9e:	f04f 33ff 	mov.w	r3, #4294967295
 8022aa2:	e7e8      	b.n	8022a76 <_strtod_l+0x88e>
 8022aa4:	4613      	mov	r3, r2
 8022aa6:	e7e6      	b.n	8022a76 <_strtod_l+0x88e>
 8022aa8:	ea53 030a 	orrs.w	r3, r3, sl
 8022aac:	d0aa      	beq.n	8022a04 <_strtod_l+0x81c>
 8022aae:	9b10      	ldr	r3, [sp, #64]	@ 0x40
 8022ab0:	b1db      	cbz	r3, 8022aea <_strtod_l+0x902>
 8022ab2:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 8022ab4:	4213      	tst	r3, r2
 8022ab6:	d0ee      	beq.n	8022a96 <_strtod_l+0x8ae>
 8022ab8:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 8022aba:	4650      	mov	r0, sl
 8022abc:	9a08      	ldr	r2, [sp, #32]
 8022abe:	4659      	mov	r1, fp
 8022ac0:	b1bb      	cbz	r3, 8022af2 <_strtod_l+0x90a>
 8022ac2:	f7ff fb6d 	bl	80221a0 <sulp>
 8022ac6:	4602      	mov	r2, r0
 8022ac8:	460b      	mov	r3, r1
 8022aca:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	@ 0x30
 8022ace:	f7dd fbeb 	bl	80002a8 <__adddf3>
 8022ad2:	4682      	mov	sl, r0
 8022ad4:	468b      	mov	fp, r1
 8022ad6:	e7de      	b.n	8022a96 <_strtod_l+0x8ae>
 8022ad8:	f5a3 1380 	sub.w	r3, r3, #1048576	@ 0x100000
 8022adc:	f04f 3aff 	mov.w	sl, #4294967295
 8022ae0:	ea6f 5b13 	mvn.w	fp, r3, lsr #20
 8022ae4:	ea6f 5b0b 	mvn.w	fp, fp, lsl #20
 8022ae8:	e7d5      	b.n	8022a96 <_strtod_l+0x8ae>
 8022aea:	9b13      	ldr	r3, [sp, #76]	@ 0x4c
 8022aec:	ea13 0f0a 	tst.w	r3, sl
 8022af0:	e7e1      	b.n	8022ab6 <_strtod_l+0x8ce>
 8022af2:	f7ff fb55 	bl	80221a0 <sulp>
 8022af6:	4602      	mov	r2, r0
 8022af8:	460b      	mov	r3, r1
 8022afa:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	@ 0x30
 8022afe:	f7dd fbd1 	bl	80002a4 <__aeabi_dsub>
 8022b02:	2200      	movs	r2, #0
 8022b04:	2300      	movs	r3, #0
 8022b06:	4682      	mov	sl, r0
 8022b08:	468b      	mov	fp, r1
 8022b0a:	f7dd ffeb 	bl	8000ae4 <__aeabi_dcmpeq>
 8022b0e:	2800      	cmp	r0, #0
 8022b10:	d0c1      	beq.n	8022a96 <_strtod_l+0x8ae>
 8022b12:	e61b      	b.n	802274c <_strtod_l+0x564>
 8022b14:	4641      	mov	r1, r8
 8022b16:	4620      	mov	r0, r4
 8022b18:	f003 f9c8 	bl	8025eac <__ratio>
 8022b1c:	2200      	movs	r2, #0
 8022b1e:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8022b22:	4606      	mov	r6, r0
 8022b24:	460f      	mov	r7, r1
 8022b26:	f7dd fff1 	bl	8000b0c <__aeabi_dcmple>
 8022b2a:	2800      	cmp	r0, #0
 8022b2c:	d06d      	beq.n	8022c0a <_strtod_l+0xa22>
 8022b2e:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 8022b30:	2b00      	cmp	r3, #0
 8022b32:	d178      	bne.n	8022c26 <_strtod_l+0xa3e>
 8022b34:	f1ba 0f00 	cmp.w	sl, #0
 8022b38:	d156      	bne.n	8022be8 <_strtod_l+0xa00>
 8022b3a:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8022b3c:	f3c3 0313 	ubfx	r3, r3, #0, #20
 8022b40:	2b00      	cmp	r3, #0
 8022b42:	d158      	bne.n	8022bf6 <_strtod_l+0xa0e>
 8022b44:	2200      	movs	r2, #0
 8022b46:	4b62      	ldr	r3, [pc, #392]	@ (8022cd0 <_strtod_l+0xae8>)
 8022b48:	4630      	mov	r0, r6
 8022b4a:	4639      	mov	r1, r7
 8022b4c:	f7dd ffd4 	bl	8000af8 <__aeabi_dcmplt>
 8022b50:	2800      	cmp	r0, #0
 8022b52:	d157      	bne.n	8022c04 <_strtod_l+0xa1c>
 8022b54:	4630      	mov	r0, r6
 8022b56:	4639      	mov	r1, r7
 8022b58:	2200      	movs	r2, #0
 8022b5a:	4b5e      	ldr	r3, [pc, #376]	@ (8022cd4 <_strtod_l+0xaec>)
 8022b5c:	f7dd fd5a 	bl	8000614 <__aeabi_dmul>
 8022b60:	4606      	mov	r6, r0
 8022b62:	460f      	mov	r7, r1
 8022b64:	f107 4300 	add.w	r3, r7, #2147483648	@ 0x80000000
 8022b68:	9606      	str	r6, [sp, #24]
 8022b6a:	9307      	str	r3, [sp, #28]
 8022b6c:	4d55      	ldr	r5, [pc, #340]	@ (8022cc4 <_strtod_l+0xadc>)
 8022b6e:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
 8022b72:	e9cd 2310 	strd	r2, r3, [sp, #64]	@ 0x40
 8022b76:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8022b78:	401d      	ands	r5, r3
 8022b7a:	4b57      	ldr	r3, [pc, #348]	@ (8022cd8 <_strtod_l+0xaf0>)
 8022b7c:	429d      	cmp	r5, r3
 8022b7e:	f040 80af 	bne.w	8022ce0 <_strtod_l+0xaf8>
 8022b82:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8022b84:	4650      	mov	r0, sl
 8022b86:	f1a3 7b54 	sub.w	fp, r3, #55574528	@ 0x3500000
 8022b8a:	4659      	mov	r1, fp
 8022b8c:	f003 f8cc 	bl	8025d28 <__ulp>
 8022b90:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
 8022b94:	f7dd fd3e 	bl	8000614 <__aeabi_dmul>
 8022b98:	4652      	mov	r2, sl
 8022b9a:	465b      	mov	r3, fp
 8022b9c:	f7dd fb84 	bl	80002a8 <__adddf3>
 8022ba0:	460b      	mov	r3, r1
 8022ba2:	4948      	ldr	r1, [pc, #288]	@ (8022cc4 <_strtod_l+0xadc>)
 8022ba4:	4682      	mov	sl, r0
 8022ba6:	4a4d      	ldr	r2, [pc, #308]	@ (8022cdc <_strtod_l+0xaf4>)
 8022ba8:	4019      	ands	r1, r3
 8022baa:	4291      	cmp	r1, r2
 8022bac:	d942      	bls.n	8022c34 <_strtod_l+0xa4c>
 8022bae:	9a0d      	ldr	r2, [sp, #52]	@ 0x34
 8022bb0:	4b46      	ldr	r3, [pc, #280]	@ (8022ccc <_strtod_l+0xae4>)
 8022bb2:	429a      	cmp	r2, r3
 8022bb4:	d103      	bne.n	8022bbe <_strtod_l+0x9d6>
 8022bb6:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
 8022bb8:	3301      	adds	r3, #1
 8022bba:	f43f ad34 	beq.w	8022626 <_strtod_l+0x43e>
 8022bbe:	f8df b10c 	ldr.w	fp, [pc, #268]	@ 8022ccc <_strtod_l+0xae4>
 8022bc2:	f04f 3aff 	mov.w	sl, #4294967295
 8022bc6:	991a      	ldr	r1, [sp, #104]	@ 0x68
 8022bc8:	9805      	ldr	r0, [sp, #20]
 8022bca:	f002 fd79 	bl	80256c0 <_Bfree>
 8022bce:	4649      	mov	r1, r9
 8022bd0:	9805      	ldr	r0, [sp, #20]
 8022bd2:	f002 fd75 	bl	80256c0 <_Bfree>
 8022bd6:	4641      	mov	r1, r8
 8022bd8:	9805      	ldr	r0, [sp, #20]
 8022bda:	f002 fd71 	bl	80256c0 <_Bfree>
 8022bde:	4621      	mov	r1, r4
 8022be0:	9805      	ldr	r0, [sp, #20]
 8022be2:	f002 fd6d 	bl	80256c0 <_Bfree>
 8022be6:	e61e      	b.n	8022826 <_strtod_l+0x63e>
 8022be8:	f1ba 0f01 	cmp.w	sl, #1
 8022bec:	d103      	bne.n	8022bf6 <_strtod_l+0xa0e>
 8022bee:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8022bf0:	2b00      	cmp	r3, #0
 8022bf2:	f43f adab 	beq.w	802274c <_strtod_l+0x564>
 8022bf6:	2600      	movs	r6, #0
 8022bf8:	4f35      	ldr	r7, [pc, #212]	@ (8022cd0 <_strtod_l+0xae8>)
 8022bfa:	ed9f 7b29 	vldr	d7, [pc, #164]	@ 8022ca0 <_strtod_l+0xab8>
 8022bfe:	ed8d 7b06 	vstr	d7, [sp, #24]
 8022c02:	e7b3      	b.n	8022b6c <_strtod_l+0x984>
 8022c04:	2600      	movs	r6, #0
 8022c06:	4f33      	ldr	r7, [pc, #204]	@ (8022cd4 <_strtod_l+0xaec>)
 8022c08:	e7ac      	b.n	8022b64 <_strtod_l+0x97c>
 8022c0a:	4b32      	ldr	r3, [pc, #200]	@ (8022cd4 <_strtod_l+0xaec>)
 8022c0c:	4630      	mov	r0, r6
 8022c0e:	4639      	mov	r1, r7
 8022c10:	2200      	movs	r2, #0
 8022c12:	f7dd fcff 	bl	8000614 <__aeabi_dmul>
 8022c16:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 8022c18:	4606      	mov	r6, r0
 8022c1a:	460f      	mov	r7, r1
 8022c1c:	2b00      	cmp	r3, #0
 8022c1e:	d0a1      	beq.n	8022b64 <_strtod_l+0x97c>
 8022c20:	e9cd 6706 	strd	r6, r7, [sp, #24]
 8022c24:	e7a2      	b.n	8022b6c <_strtod_l+0x984>
 8022c26:	ed9f 7b20 	vldr	d7, [pc, #128]	@ 8022ca8 <_strtod_l+0xac0>
 8022c2a:	ec57 6b17 	vmov	r6, r7, d7
 8022c2e:	ed8d 7b06 	vstr	d7, [sp, #24]
 8022c32:	e79b      	b.n	8022b6c <_strtod_l+0x984>
 8022c34:	f103 7b54 	add.w	fp, r3, #55574528	@ 0x3500000
 8022c38:	9b08      	ldr	r3, [sp, #32]
 8022c3a:	f8cd b028 	str.w	fp, [sp, #40]	@ 0x28
 8022c3e:	2b00      	cmp	r3, #0
 8022c40:	d1c1      	bne.n	8022bc6 <_strtod_l+0x9de>
 8022c42:	f02b 4300 	bic.w	r3, fp, #2147483648	@ 0x80000000
 8022c46:	0d1b      	lsrs	r3, r3, #20
 8022c48:	051b      	lsls	r3, r3, #20
 8022c4a:	429d      	cmp	r5, r3
 8022c4c:	d1bb      	bne.n	8022bc6 <_strtod_l+0x9de>
 8022c4e:	4630      	mov	r0, r6
 8022c50:	4639      	mov	r1, r7
 8022c52:	f7de f83f 	bl	8000cd4 <__aeabi_d2lz>
 8022c56:	f7dd fcaf 	bl	80005b8 <__aeabi_l2d>
 8022c5a:	4602      	mov	r2, r0
 8022c5c:	460b      	mov	r3, r1
 8022c5e:	4630      	mov	r0, r6
 8022c60:	4639      	mov	r1, r7
 8022c62:	f3cb 0613 	ubfx	r6, fp, #0, #20
 8022c66:	f7dd fb1d 	bl	80002a4 <__aeabi_dsub>
 8022c6a:	460b      	mov	r3, r1
 8022c6c:	4602      	mov	r2, r0
 8022c6e:	ea46 060a 	orr.w	r6, r6, sl
 8022c72:	e9cd 230c 	strd	r2, r3, [sp, #48]	@ 0x30
 8022c76:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 8022c78:	431e      	orrs	r6, r3
 8022c7a:	d06e      	beq.n	8022d5a <_strtod_l+0xb72>
 8022c7c:	a30c      	add	r3, pc, #48	@ (adr r3, 8022cb0 <_strtod_l+0xac8>)
 8022c7e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8022c82:	f7dd ff39 	bl	8000af8 <__aeabi_dcmplt>
 8022c86:	2800      	cmp	r0, #0
 8022c88:	f47f acd8 	bne.w	802263c <_strtod_l+0x454>
 8022c8c:	a30a      	add	r3, pc, #40	@ (adr r3, 8022cb8 <_strtod_l+0xad0>)
 8022c8e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8022c92:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	@ 0x30
 8022c96:	f7dd ff4d 	bl	8000b34 <__aeabi_dcmpgt>
 8022c9a:	2800      	cmp	r0, #0
 8022c9c:	d093      	beq.n	8022bc6 <_strtod_l+0x9de>
 8022c9e:	e4cd      	b.n	802263c <_strtod_l+0x454>
 8022ca0:	00000000 	.word	0x00000000
 8022ca4:	bff00000 	.word	0xbff00000
 8022ca8:	00000000 	.word	0x00000000
 8022cac:	3ff00000 	.word	0x3ff00000
 8022cb0:	94a03595 	.word	0x94a03595
 8022cb4:	3fdfffff 	.word	0x3fdfffff
 8022cb8:	35afe535 	.word	0x35afe535
 8022cbc:	3fe00000 	.word	0x3fe00000
 8022cc0:	39500000 	.word	0x39500000
 8022cc4:	7ff00000 	.word	0x7ff00000
 8022cc8:	000fffff 	.word	0x000fffff
 8022ccc:	7fefffff 	.word	0x7fefffff
 8022cd0:	3ff00000 	.word	0x3ff00000
 8022cd4:	3fe00000 	.word	0x3fe00000
 8022cd8:	7fe00000 	.word	0x7fe00000
 8022cdc:	7c9fffff 	.word	0x7c9fffff
 8022ce0:	9b08      	ldr	r3, [sp, #32]
 8022ce2:	b323      	cbz	r3, 8022d2e <_strtod_l+0xb46>
 8022ce4:	f1b5 6fd4 	cmp.w	r5, #111149056	@ 0x6a00000
 8022ce8:	d821      	bhi.n	8022d2e <_strtod_l+0xb46>
 8022cea:	4630      	mov	r0, r6
 8022cec:	4639      	mov	r1, r7
 8022cee:	a326      	add	r3, pc, #152	@ (adr r3, 8022d88 <_strtod_l+0xba0>)
 8022cf0:	e9d3 2300 	ldrd	r2, r3, [r3]
 8022cf4:	f7dd ff0a 	bl	8000b0c <__aeabi_dcmple>
 8022cf8:	b1a0      	cbz	r0, 8022d24 <_strtod_l+0xb3c>
 8022cfa:	4639      	mov	r1, r7
 8022cfc:	4630      	mov	r0, r6
 8022cfe:	f7dd ff61 	bl	8000bc4 <__aeabi_d2uiz>
 8022d02:	2801      	cmp	r0, #1
 8022d04:	bf38      	it	cc
 8022d06:	2001      	movcc	r0, #1
 8022d08:	f7dd fc0a 	bl	8000520 <__aeabi_ui2d>
 8022d0c:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 8022d0e:	4606      	mov	r6, r0
 8022d10:	460f      	mov	r7, r1
 8022d12:	b9fb      	cbnz	r3, 8022d54 <_strtod_l+0xb6c>
 8022d14:	f101 4300 	add.w	r3, r1, #2147483648	@ 0x80000000
 8022d18:	9014      	str	r0, [sp, #80]	@ 0x50
 8022d1a:	9315      	str	r3, [sp, #84]	@ 0x54
 8022d1c:	e9dd 2314 	ldrd	r2, r3, [sp, #80]	@ 0x50
 8022d20:	e9cd 2310 	strd	r2, r3, [sp, #64]	@ 0x40
 8022d24:	9b11      	ldr	r3, [sp, #68]	@ 0x44
 8022d26:	f103 63d6 	add.w	r3, r3, #112197632	@ 0x6b00000
 8022d2a:	1b5b      	subs	r3, r3, r5
 8022d2c:	9311      	str	r3, [sp, #68]	@ 0x44
 8022d2e:	e9dd ab10 	ldrd	sl, fp, [sp, #64]	@ 0x40
 8022d32:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	@ 0x30
 8022d36:	f002 fff7 	bl	8025d28 <__ulp>
 8022d3a:	4602      	mov	r2, r0
 8022d3c:	460b      	mov	r3, r1
 8022d3e:	4650      	mov	r0, sl
 8022d40:	4659      	mov	r1, fp
 8022d42:	f7dd fc67 	bl	8000614 <__aeabi_dmul>
 8022d46:	e9dd 230c 	ldrd	r2, r3, [sp, #48]	@ 0x30
 8022d4a:	f7dd faad 	bl	80002a8 <__adddf3>
 8022d4e:	4682      	mov	sl, r0
 8022d50:	468b      	mov	fp, r1
 8022d52:	e771      	b.n	8022c38 <_strtod_l+0xa50>
 8022d54:	e9cd 6714 	strd	r6, r7, [sp, #80]	@ 0x50
 8022d58:	e7e0      	b.n	8022d1c <_strtod_l+0xb34>
 8022d5a:	a30d      	add	r3, pc, #52	@ (adr r3, 8022d90 <_strtod_l+0xba8>)
 8022d5c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8022d60:	f7dd feca 	bl	8000af8 <__aeabi_dcmplt>
 8022d64:	e799      	b.n	8022c9a <_strtod_l+0xab2>
 8022d66:	2300      	movs	r3, #0
 8022d68:	930e      	str	r3, [sp, #56]	@ 0x38
 8022d6a:	9b19      	ldr	r3, [sp, #100]	@ 0x64
 8022d6c:	9a17      	ldr	r2, [sp, #92]	@ 0x5c
 8022d6e:	6013      	str	r3, [r2, #0]
 8022d70:	f7ff ba77 	b.w	8022262 <_strtod_l+0x7a>
 8022d74:	2a65      	cmp	r2, #101	@ 0x65
 8022d76:	f43f ab6f 	beq.w	8022458 <_strtod_l+0x270>
 8022d7a:	2a45      	cmp	r2, #69	@ 0x45
 8022d7c:	f43f ab6c 	beq.w	8022458 <_strtod_l+0x270>
 8022d80:	2301      	movs	r3, #1
 8022d82:	f7ff bba8 	b.w	80224d6 <_strtod_l+0x2ee>
 8022d86:	bf00      	nop
 8022d88:	ffc00000 	.word	0xffc00000
 8022d8c:	41dfffff 	.word	0x41dfffff
 8022d90:	94a03595 	.word	0x94a03595
 8022d94:	3fcfffff 	.word	0x3fcfffff

08022d98 <_strtod_r>:
 8022d98:	4b01      	ldr	r3, [pc, #4]	@ (8022da0 <_strtod_r+0x8>)
 8022d9a:	f7ff ba25 	b.w	80221e8 <_strtod_l>
 8022d9e:	bf00      	nop
 8022da0:	20000228 	.word	0x20000228

08022da4 <strtod>:
 8022da4:	460a      	mov	r2, r1
 8022da6:	4601      	mov	r1, r0
 8022da8:	4802      	ldr	r0, [pc, #8]	@ (8022db4 <strtod+0x10>)
 8022daa:	4b03      	ldr	r3, [pc, #12]	@ (8022db8 <strtod+0x14>)
 8022dac:	6800      	ldr	r0, [r0, #0]
 8022dae:	f7ff ba1b 	b.w	80221e8 <_strtod_l>
 8022db2:	bf00      	nop
 8022db4:	20000394 	.word	0x20000394
 8022db8:	20000228 	.word	0x20000228

08022dbc <__cvt>:
 8022dbc:	2b00      	cmp	r3, #0
 8022dbe:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8022dc2:	461d      	mov	r5, r3
 8022dc4:	b088      	sub	sp, #32
 8022dc6:	bfb4      	ite	lt
 8022dc8:	f103 4300 	addlt.w	r3, r3, #2147483648	@ 0x80000000
 8022dcc:	2300      	movge	r3, #0
 8022dce:	4614      	mov	r4, r2
 8022dd0:	bfbc      	itt	lt
 8022dd2:	4614      	movlt	r4, r2
 8022dd4:	461d      	movlt	r5, r3
 8022dd6:	9a12      	ldr	r2, [sp, #72]	@ 0x48
 8022dd8:	bfb8      	it	lt
 8022dda:	232d      	movlt	r3, #45	@ 0x2d
 8022ddc:	9e10      	ldr	r6, [sp, #64]	@ 0x40
 8022dde:	f8dd a04c 	ldr.w	sl, [sp, #76]	@ 0x4c
 8022de2:	7013      	strb	r3, [r2, #0]
 8022de4:	9b14      	ldr	r3, [sp, #80]	@ 0x50
 8022de6:	f023 0820 	bic.w	r8, r3, #32
 8022dea:	f1b8 0f46 	cmp.w	r8, #70	@ 0x46
 8022dee:	d005      	beq.n	8022dfc <__cvt+0x40>
 8022df0:	f1b8 0f45 	cmp.w	r8, #69	@ 0x45
 8022df4:	d100      	bne.n	8022df8 <__cvt+0x3c>
 8022df6:	3601      	adds	r6, #1
 8022df8:	2302      	movs	r3, #2
 8022dfa:	e000      	b.n	8022dfe <__cvt+0x42>
 8022dfc:	2303      	movs	r3, #3
 8022dfe:	aa07      	add	r2, sp, #28
 8022e00:	9204      	str	r2, [sp, #16]
 8022e02:	aa06      	add	r2, sp, #24
 8022e04:	e9cd 3600 	strd	r3, r6, [sp]
 8022e08:	e9cd a202 	strd	sl, r2, [sp, #8]
 8022e0c:	462b      	mov	r3, r5
 8022e0e:	4622      	mov	r2, r4
 8022e10:	f001 fab2 	bl	8024378 <_dtoa_r>
 8022e14:	f1b8 0f47 	cmp.w	r8, #71	@ 0x47
 8022e18:	4607      	mov	r7, r0
 8022e1a:	d119      	bne.n	8022e50 <__cvt+0x94>
 8022e1c:	9b11      	ldr	r3, [sp, #68]	@ 0x44
 8022e1e:	07db      	lsls	r3, r3, #31
 8022e20:	d50e      	bpl.n	8022e40 <__cvt+0x84>
 8022e22:	eb00 0906 	add.w	r9, r0, r6
 8022e26:	2200      	movs	r2, #0
 8022e28:	2300      	movs	r3, #0
 8022e2a:	4620      	mov	r0, r4
 8022e2c:	4629      	mov	r1, r5
 8022e2e:	f7dd fe59 	bl	8000ae4 <__aeabi_dcmpeq>
 8022e32:	b108      	cbz	r0, 8022e38 <__cvt+0x7c>
 8022e34:	f8cd 901c 	str.w	r9, [sp, #28]
 8022e38:	2230      	movs	r2, #48	@ 0x30
 8022e3a:	9b07      	ldr	r3, [sp, #28]
 8022e3c:	454b      	cmp	r3, r9
 8022e3e:	d31e      	bcc.n	8022e7e <__cvt+0xc2>
 8022e40:	9b07      	ldr	r3, [sp, #28]
 8022e42:	4638      	mov	r0, r7
 8022e44:	9a15      	ldr	r2, [sp, #84]	@ 0x54
 8022e46:	1bdb      	subs	r3, r3, r7
 8022e48:	6013      	str	r3, [r2, #0]
 8022e4a:	b008      	add	sp, #32
 8022e4c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8022e50:	f1b8 0f46 	cmp.w	r8, #70	@ 0x46
 8022e54:	eb00 0906 	add.w	r9, r0, r6
 8022e58:	d1e5      	bne.n	8022e26 <__cvt+0x6a>
 8022e5a:	7803      	ldrb	r3, [r0, #0]
 8022e5c:	2b30      	cmp	r3, #48	@ 0x30
 8022e5e:	d10a      	bne.n	8022e76 <__cvt+0xba>
 8022e60:	2200      	movs	r2, #0
 8022e62:	2300      	movs	r3, #0
 8022e64:	4620      	mov	r0, r4
 8022e66:	4629      	mov	r1, r5
 8022e68:	f7dd fe3c 	bl	8000ae4 <__aeabi_dcmpeq>
 8022e6c:	b918      	cbnz	r0, 8022e76 <__cvt+0xba>
 8022e6e:	f1c6 0601 	rsb	r6, r6, #1
 8022e72:	f8ca 6000 	str.w	r6, [sl]
 8022e76:	f8da 3000 	ldr.w	r3, [sl]
 8022e7a:	4499      	add	r9, r3
 8022e7c:	e7d3      	b.n	8022e26 <__cvt+0x6a>
 8022e7e:	1c59      	adds	r1, r3, #1
 8022e80:	9107      	str	r1, [sp, #28]
 8022e82:	701a      	strb	r2, [r3, #0]
 8022e84:	e7d9      	b.n	8022e3a <__cvt+0x7e>

08022e86 <__exponent>:
 8022e86:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8022e88:	2900      	cmp	r1, #0
 8022e8a:	7002      	strb	r2, [r0, #0]
 8022e8c:	bfba      	itte	lt
 8022e8e:	4249      	neglt	r1, r1
 8022e90:	232d      	movlt	r3, #45	@ 0x2d
 8022e92:	232b      	movge	r3, #43	@ 0x2b
 8022e94:	2909      	cmp	r1, #9
 8022e96:	7043      	strb	r3, [r0, #1]
 8022e98:	dd28      	ble.n	8022eec <__exponent+0x66>
 8022e9a:	f10d 0307 	add.w	r3, sp, #7
 8022e9e:	270a      	movs	r7, #10
 8022ea0:	461d      	mov	r5, r3
 8022ea2:	461a      	mov	r2, r3
 8022ea4:	3b01      	subs	r3, #1
 8022ea6:	fbb1 f6f7 	udiv	r6, r1, r7
 8022eaa:	fb07 1416 	mls	r4, r7, r6, r1
 8022eae:	3430      	adds	r4, #48	@ 0x30
 8022eb0:	f802 4c01 	strb.w	r4, [r2, #-1]
 8022eb4:	460c      	mov	r4, r1
 8022eb6:	4631      	mov	r1, r6
 8022eb8:	2c63      	cmp	r4, #99	@ 0x63
 8022eba:	dcf2      	bgt.n	8022ea2 <__exponent+0x1c>
 8022ebc:	3130      	adds	r1, #48	@ 0x30
 8022ebe:	1e94      	subs	r4, r2, #2
 8022ec0:	f803 1c01 	strb.w	r1, [r3, #-1]
 8022ec4:	1c41      	adds	r1, r0, #1
 8022ec6:	4623      	mov	r3, r4
 8022ec8:	42ab      	cmp	r3, r5
 8022eca:	d30a      	bcc.n	8022ee2 <__exponent+0x5c>
 8022ecc:	f10d 0309 	add.w	r3, sp, #9
 8022ed0:	1a9b      	subs	r3, r3, r2
 8022ed2:	42ac      	cmp	r4, r5
 8022ed4:	bf88      	it	hi
 8022ed6:	2300      	movhi	r3, #0
 8022ed8:	3302      	adds	r3, #2
 8022eda:	4403      	add	r3, r0
 8022edc:	1a18      	subs	r0, r3, r0
 8022ede:	b003      	add	sp, #12
 8022ee0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8022ee2:	f813 6b01 	ldrb.w	r6, [r3], #1
 8022ee6:	f801 6f01 	strb.w	r6, [r1, #1]!
 8022eea:	e7ed      	b.n	8022ec8 <__exponent+0x42>
 8022eec:	2330      	movs	r3, #48	@ 0x30
 8022eee:	3130      	adds	r1, #48	@ 0x30
 8022ef0:	7083      	strb	r3, [r0, #2]
 8022ef2:	1d03      	adds	r3, r0, #4
 8022ef4:	70c1      	strb	r1, [r0, #3]
 8022ef6:	e7f1      	b.n	8022edc <__exponent+0x56>

08022ef8 <_printf_float>:
 8022ef8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8022efc:	b091      	sub	sp, #68	@ 0x44
 8022efe:	460c      	mov	r4, r1
 8022f00:	4616      	mov	r6, r2
 8022f02:	461f      	mov	r7, r3
 8022f04:	f8dd 8068 	ldr.w	r8, [sp, #104]	@ 0x68
 8022f08:	4605      	mov	r5, r0
 8022f0a:	f001 f8d3 	bl	80240b4 <_localeconv_r>
 8022f0e:	6803      	ldr	r3, [r0, #0]
 8022f10:	4618      	mov	r0, r3
 8022f12:	9308      	str	r3, [sp, #32]
 8022f14:	f7dd f9ba 	bl	800028c <strlen>
 8022f18:	2300      	movs	r3, #0
 8022f1a:	9009      	str	r0, [sp, #36]	@ 0x24
 8022f1c:	930e      	str	r3, [sp, #56]	@ 0x38
 8022f1e:	f8d8 3000 	ldr.w	r3, [r8]
 8022f22:	f894 a018 	ldrb.w	sl, [r4, #24]
 8022f26:	3307      	adds	r3, #7
 8022f28:	f8d4 b000 	ldr.w	fp, [r4]
 8022f2c:	f023 0307 	bic.w	r3, r3, #7
 8022f30:	f103 0208 	add.w	r2, r3, #8
 8022f34:	f8c8 2000 	str.w	r2, [r8]
 8022f38:	f04f 32ff 	mov.w	r2, #4294967295
 8022f3c:	e9d3 8900 	ldrd	r8, r9, [r3]
 8022f40:	f029 4300 	bic.w	r3, r9, #2147483648	@ 0x80000000
 8022f44:	f8cd 8028 	str.w	r8, [sp, #40]	@ 0x28
 8022f48:	930b      	str	r3, [sp, #44]	@ 0x2c
 8022f4a:	4b9e      	ldr	r3, [pc, #632]	@ (80231c4 <_printf_float+0x2cc>)
 8022f4c:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	@ 0x28
 8022f50:	e9c4 8912 	strd	r8, r9, [r4, #72]	@ 0x48
 8022f54:	f7dd fdf8 	bl	8000b48 <__aeabi_dcmpun>
 8022f58:	bb70      	cbnz	r0, 8022fb8 <_printf_float+0xc0>
 8022f5a:	f04f 32ff 	mov.w	r2, #4294967295
 8022f5e:	4b99      	ldr	r3, [pc, #612]	@ (80231c4 <_printf_float+0x2cc>)
 8022f60:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	@ 0x28
 8022f64:	f7dd fdd2 	bl	8000b0c <__aeabi_dcmple>
 8022f68:	bb30      	cbnz	r0, 8022fb8 <_printf_float+0xc0>
 8022f6a:	2200      	movs	r2, #0
 8022f6c:	2300      	movs	r3, #0
 8022f6e:	4640      	mov	r0, r8
 8022f70:	4649      	mov	r1, r9
 8022f72:	f7dd fdc1 	bl	8000af8 <__aeabi_dcmplt>
 8022f76:	b110      	cbz	r0, 8022f7e <_printf_float+0x86>
 8022f78:	232d      	movs	r3, #45	@ 0x2d
 8022f7a:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
 8022f7e:	4a92      	ldr	r2, [pc, #584]	@ (80231c8 <_printf_float+0x2d0>)
 8022f80:	4b92      	ldr	r3, [pc, #584]	@ (80231cc <_printf_float+0x2d4>)
 8022f82:	f1ba 0f47 	cmp.w	sl, #71	@ 0x47
 8022f86:	bf8c      	ite	hi
 8022f88:	4690      	movhi	r8, r2
 8022f8a:	4698      	movls	r8, r3
 8022f8c:	2303      	movs	r3, #3
 8022f8e:	f04f 0900 	mov.w	r9, #0
 8022f92:	6123      	str	r3, [r4, #16]
 8022f94:	f02b 0304 	bic.w	r3, fp, #4
 8022f98:	6023      	str	r3, [r4, #0]
 8022f9a:	4633      	mov	r3, r6
 8022f9c:	aa0f      	add	r2, sp, #60	@ 0x3c
 8022f9e:	4621      	mov	r1, r4
 8022fa0:	4628      	mov	r0, r5
 8022fa2:	9700      	str	r7, [sp, #0]
 8022fa4:	f000 f9d4 	bl	8023350 <_printf_common>
 8022fa8:	3001      	adds	r0, #1
 8022faa:	f040 808f 	bne.w	80230cc <_printf_float+0x1d4>
 8022fae:	f04f 30ff 	mov.w	r0, #4294967295
 8022fb2:	b011      	add	sp, #68	@ 0x44
 8022fb4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8022fb8:	4642      	mov	r2, r8
 8022fba:	464b      	mov	r3, r9
 8022fbc:	4640      	mov	r0, r8
 8022fbe:	4649      	mov	r1, r9
 8022fc0:	f7dd fdc2 	bl	8000b48 <__aeabi_dcmpun>
 8022fc4:	b140      	cbz	r0, 8022fd8 <_printf_float+0xe0>
 8022fc6:	464b      	mov	r3, r9
 8022fc8:	4a81      	ldr	r2, [pc, #516]	@ (80231d0 <_printf_float+0x2d8>)
 8022fca:	2b00      	cmp	r3, #0
 8022fcc:	bfbc      	itt	lt
 8022fce:	232d      	movlt	r3, #45	@ 0x2d
 8022fd0:	f884 3043 	strblt.w	r3, [r4, #67]	@ 0x43
 8022fd4:	4b7f      	ldr	r3, [pc, #508]	@ (80231d4 <_printf_float+0x2dc>)
 8022fd6:	e7d4      	b.n	8022f82 <_printf_float+0x8a>
 8022fd8:	6863      	ldr	r3, [r4, #4]
 8022fda:	f00a 01df 	and.w	r1, sl, #223	@ 0xdf
 8022fde:	1c5a      	adds	r2, r3, #1
 8022fe0:	d13f      	bne.n	8023062 <_printf_float+0x16a>
 8022fe2:	2306      	movs	r3, #6
 8022fe4:	6063      	str	r3, [r4, #4]
 8022fe6:	f44b 6380 	orr.w	r3, fp, #1024	@ 0x400
 8022fea:	2200      	movs	r2, #0
 8022fec:	4628      	mov	r0, r5
 8022fee:	910a      	str	r1, [sp, #40]	@ 0x28
 8022ff0:	6023      	str	r3, [r4, #0]
 8022ff2:	9206      	str	r2, [sp, #24]
 8022ff4:	aa0e      	add	r2, sp, #56	@ 0x38
 8022ff6:	e9cd a204 	strd	sl, r2, [sp, #16]
 8022ffa:	aa0d      	add	r2, sp, #52	@ 0x34
 8022ffc:	9203      	str	r2, [sp, #12]
 8022ffe:	f10d 0233 	add.w	r2, sp, #51	@ 0x33
 8023002:	e9cd 3201 	strd	r3, r2, [sp, #4]
 8023006:	6863      	ldr	r3, [r4, #4]
 8023008:	4642      	mov	r2, r8
 802300a:	9300      	str	r3, [sp, #0]
 802300c:	464b      	mov	r3, r9
 802300e:	f7ff fed5 	bl	8022dbc <__cvt>
 8023012:	990a      	ldr	r1, [sp, #40]	@ 0x28
 8023014:	4680      	mov	r8, r0
 8023016:	2947      	cmp	r1, #71	@ 0x47
 8023018:	990d      	ldr	r1, [sp, #52]	@ 0x34
 802301a:	d128      	bne.n	802306e <_printf_float+0x176>
 802301c:	1cc8      	adds	r0, r1, #3
 802301e:	db02      	blt.n	8023026 <_printf_float+0x12e>
 8023020:	6863      	ldr	r3, [r4, #4]
 8023022:	4299      	cmp	r1, r3
 8023024:	dd40      	ble.n	80230a8 <_printf_float+0x1b0>
 8023026:	f1aa 0a02 	sub.w	sl, sl, #2
 802302a:	fa5f fa8a 	uxtb.w	sl, sl
 802302e:	3901      	subs	r1, #1
 8023030:	4652      	mov	r2, sl
 8023032:	f104 0050 	add.w	r0, r4, #80	@ 0x50
 8023036:	910d      	str	r1, [sp, #52]	@ 0x34
 8023038:	f7ff ff25 	bl	8022e86 <__exponent>
 802303c:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
 802303e:	4681      	mov	r9, r0
 8023040:	1813      	adds	r3, r2, r0
 8023042:	2a01      	cmp	r2, #1
 8023044:	6123      	str	r3, [r4, #16]
 8023046:	dc02      	bgt.n	802304e <_printf_float+0x156>
 8023048:	6822      	ldr	r2, [r4, #0]
 802304a:	07d2      	lsls	r2, r2, #31
 802304c:	d501      	bpl.n	8023052 <_printf_float+0x15a>
 802304e:	3301      	adds	r3, #1
 8023050:	6123      	str	r3, [r4, #16]
 8023052:	f89d 3033 	ldrb.w	r3, [sp, #51]	@ 0x33
 8023056:	2b00      	cmp	r3, #0
 8023058:	d09f      	beq.n	8022f9a <_printf_float+0xa2>
 802305a:	232d      	movs	r3, #45	@ 0x2d
 802305c:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
 8023060:	e79b      	b.n	8022f9a <_printf_float+0xa2>
 8023062:	2947      	cmp	r1, #71	@ 0x47
 8023064:	d1bf      	bne.n	8022fe6 <_printf_float+0xee>
 8023066:	2b00      	cmp	r3, #0
 8023068:	d1bd      	bne.n	8022fe6 <_printf_float+0xee>
 802306a:	2301      	movs	r3, #1
 802306c:	e7ba      	b.n	8022fe4 <_printf_float+0xec>
 802306e:	f1ba 0f65 	cmp.w	sl, #101	@ 0x65
 8023072:	d9dc      	bls.n	802302e <_printf_float+0x136>
 8023074:	f1ba 0f66 	cmp.w	sl, #102	@ 0x66
 8023078:	d118      	bne.n	80230ac <_printf_float+0x1b4>
 802307a:	2900      	cmp	r1, #0
 802307c:	6863      	ldr	r3, [r4, #4]
 802307e:	dd0b      	ble.n	8023098 <_printf_float+0x1a0>
 8023080:	6121      	str	r1, [r4, #16]
 8023082:	b913      	cbnz	r3, 802308a <_printf_float+0x192>
 8023084:	6822      	ldr	r2, [r4, #0]
 8023086:	07d0      	lsls	r0, r2, #31
 8023088:	d502      	bpl.n	8023090 <_printf_float+0x198>
 802308a:	3301      	adds	r3, #1
 802308c:	440b      	add	r3, r1
 802308e:	6123      	str	r3, [r4, #16]
 8023090:	f04f 0900 	mov.w	r9, #0
 8023094:	65a1      	str	r1, [r4, #88]	@ 0x58
 8023096:	e7dc      	b.n	8023052 <_printf_float+0x15a>
 8023098:	b913      	cbnz	r3, 80230a0 <_printf_float+0x1a8>
 802309a:	6822      	ldr	r2, [r4, #0]
 802309c:	07d2      	lsls	r2, r2, #31
 802309e:	d501      	bpl.n	80230a4 <_printf_float+0x1ac>
 80230a0:	3302      	adds	r3, #2
 80230a2:	e7f4      	b.n	802308e <_printf_float+0x196>
 80230a4:	2301      	movs	r3, #1
 80230a6:	e7f2      	b.n	802308e <_printf_float+0x196>
 80230a8:	f04f 0a67 	mov.w	sl, #103	@ 0x67
 80230ac:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 80230ae:	4299      	cmp	r1, r3
 80230b0:	db05      	blt.n	80230be <_printf_float+0x1c6>
 80230b2:	6823      	ldr	r3, [r4, #0]
 80230b4:	6121      	str	r1, [r4, #16]
 80230b6:	07d8      	lsls	r0, r3, #31
 80230b8:	d5ea      	bpl.n	8023090 <_printf_float+0x198>
 80230ba:	1c4b      	adds	r3, r1, #1
 80230bc:	e7e7      	b.n	802308e <_printf_float+0x196>
 80230be:	2900      	cmp	r1, #0
 80230c0:	bfd4      	ite	le
 80230c2:	f1c1 0202 	rsble	r2, r1, #2
 80230c6:	2201      	movgt	r2, #1
 80230c8:	4413      	add	r3, r2
 80230ca:	e7e0      	b.n	802308e <_printf_float+0x196>
 80230cc:	6823      	ldr	r3, [r4, #0]
 80230ce:	055a      	lsls	r2, r3, #21
 80230d0:	d407      	bmi.n	80230e2 <_printf_float+0x1ea>
 80230d2:	6923      	ldr	r3, [r4, #16]
 80230d4:	4642      	mov	r2, r8
 80230d6:	4631      	mov	r1, r6
 80230d8:	4628      	mov	r0, r5
 80230da:	47b8      	blx	r7
 80230dc:	3001      	adds	r0, #1
 80230de:	d12b      	bne.n	8023138 <_printf_float+0x240>
 80230e0:	e765      	b.n	8022fae <_printf_float+0xb6>
 80230e2:	f1ba 0f65 	cmp.w	sl, #101	@ 0x65
 80230e6:	f240 80dd 	bls.w	80232a4 <_printf_float+0x3ac>
 80230ea:	2200      	movs	r2, #0
 80230ec:	2300      	movs	r3, #0
 80230ee:	e9d4 0112 	ldrd	r0, r1, [r4, #72]	@ 0x48
 80230f2:	f7dd fcf7 	bl	8000ae4 <__aeabi_dcmpeq>
 80230f6:	2800      	cmp	r0, #0
 80230f8:	d033      	beq.n	8023162 <_printf_float+0x26a>
 80230fa:	2301      	movs	r3, #1
 80230fc:	4a36      	ldr	r2, [pc, #216]	@ (80231d8 <_printf_float+0x2e0>)
 80230fe:	4631      	mov	r1, r6
 8023100:	4628      	mov	r0, r5
 8023102:	47b8      	blx	r7
 8023104:	3001      	adds	r0, #1
 8023106:	f43f af52 	beq.w	8022fae <_printf_float+0xb6>
 802310a:	e9dd 380d 	ldrd	r3, r8, [sp, #52]	@ 0x34
 802310e:	4543      	cmp	r3, r8
 8023110:	db02      	blt.n	8023118 <_printf_float+0x220>
 8023112:	6823      	ldr	r3, [r4, #0]
 8023114:	07d8      	lsls	r0, r3, #31
 8023116:	d50f      	bpl.n	8023138 <_printf_float+0x240>
 8023118:	4631      	mov	r1, r6
 802311a:	4628      	mov	r0, r5
 802311c:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 8023120:	47b8      	blx	r7
 8023122:	3001      	adds	r0, #1
 8023124:	f43f af43 	beq.w	8022fae <_printf_float+0xb6>
 8023128:	f04f 0900 	mov.w	r9, #0
 802312c:	f108 38ff 	add.w	r8, r8, #4294967295
 8023130:	f104 0a1a 	add.w	sl, r4, #26
 8023134:	45c8      	cmp	r8, r9
 8023136:	dc09      	bgt.n	802314c <_printf_float+0x254>
 8023138:	6823      	ldr	r3, [r4, #0]
 802313a:	079b      	lsls	r3, r3, #30
 802313c:	f100 8103 	bmi.w	8023346 <_printf_float+0x44e>
 8023140:	68e0      	ldr	r0, [r4, #12]
 8023142:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 8023144:	4298      	cmp	r0, r3
 8023146:	bfb8      	it	lt
 8023148:	4618      	movlt	r0, r3
 802314a:	e732      	b.n	8022fb2 <_printf_float+0xba>
 802314c:	2301      	movs	r3, #1
 802314e:	4652      	mov	r2, sl
 8023150:	4631      	mov	r1, r6
 8023152:	4628      	mov	r0, r5
 8023154:	47b8      	blx	r7
 8023156:	3001      	adds	r0, #1
 8023158:	f43f af29 	beq.w	8022fae <_printf_float+0xb6>
 802315c:	f109 0901 	add.w	r9, r9, #1
 8023160:	e7e8      	b.n	8023134 <_printf_float+0x23c>
 8023162:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 8023164:	2b00      	cmp	r3, #0
 8023166:	dc39      	bgt.n	80231dc <_printf_float+0x2e4>
 8023168:	2301      	movs	r3, #1
 802316a:	4a1b      	ldr	r2, [pc, #108]	@ (80231d8 <_printf_float+0x2e0>)
 802316c:	4631      	mov	r1, r6
 802316e:	4628      	mov	r0, r5
 8023170:	47b8      	blx	r7
 8023172:	3001      	adds	r0, #1
 8023174:	f43f af1b 	beq.w	8022fae <_printf_float+0xb6>
 8023178:	e9dd 390d 	ldrd	r3, r9, [sp, #52]	@ 0x34
 802317c:	ea59 0303 	orrs.w	r3, r9, r3
 8023180:	d102      	bne.n	8023188 <_printf_float+0x290>
 8023182:	6823      	ldr	r3, [r4, #0]
 8023184:	07d9      	lsls	r1, r3, #31
 8023186:	d5d7      	bpl.n	8023138 <_printf_float+0x240>
 8023188:	4631      	mov	r1, r6
 802318a:	4628      	mov	r0, r5
 802318c:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 8023190:	47b8      	blx	r7
 8023192:	3001      	adds	r0, #1
 8023194:	f43f af0b 	beq.w	8022fae <_printf_float+0xb6>
 8023198:	f04f 0a00 	mov.w	sl, #0
 802319c:	f104 0b1a 	add.w	fp, r4, #26
 80231a0:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 80231a2:	425b      	negs	r3, r3
 80231a4:	4553      	cmp	r3, sl
 80231a6:	dc01      	bgt.n	80231ac <_printf_float+0x2b4>
 80231a8:	464b      	mov	r3, r9
 80231aa:	e793      	b.n	80230d4 <_printf_float+0x1dc>
 80231ac:	2301      	movs	r3, #1
 80231ae:	465a      	mov	r2, fp
 80231b0:	4631      	mov	r1, r6
 80231b2:	4628      	mov	r0, r5
 80231b4:	47b8      	blx	r7
 80231b6:	3001      	adds	r0, #1
 80231b8:	f43f aef9 	beq.w	8022fae <_printf_float+0xb6>
 80231bc:	f10a 0a01 	add.w	sl, sl, #1
 80231c0:	e7ee      	b.n	80231a0 <_printf_float+0x2a8>
 80231c2:	bf00      	nop
 80231c4:	7fefffff 	.word	0x7fefffff
 80231c8:	0802a8b5 	.word	0x0802a8b5
 80231cc:	0802a8b1 	.word	0x0802a8b1
 80231d0:	0802a8bd 	.word	0x0802a8bd
 80231d4:	0802a8b9 	.word	0x0802a8b9
 80231d8:	0802a8c1 	.word	0x0802a8c1
 80231dc:	6da3      	ldr	r3, [r4, #88]	@ 0x58
 80231de:	f8dd a038 	ldr.w	sl, [sp, #56]	@ 0x38
 80231e2:	4553      	cmp	r3, sl
 80231e4:	bfa8      	it	ge
 80231e6:	4653      	movge	r3, sl
 80231e8:	2b00      	cmp	r3, #0
 80231ea:	4699      	mov	r9, r3
 80231ec:	dc36      	bgt.n	802325c <_printf_float+0x364>
 80231ee:	f04f 0b00 	mov.w	fp, #0
 80231f2:	ea29 79e9 	bic.w	r9, r9, r9, asr #31
 80231f6:	f104 021a 	add.w	r2, r4, #26
 80231fa:	6da3      	ldr	r3, [r4, #88]	@ 0x58
 80231fc:	930a      	str	r3, [sp, #40]	@ 0x28
 80231fe:	eba3 0309 	sub.w	r3, r3, r9
 8023202:	455b      	cmp	r3, fp
 8023204:	dc31      	bgt.n	802326a <_printf_float+0x372>
 8023206:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 8023208:	459a      	cmp	sl, r3
 802320a:	dc3a      	bgt.n	8023282 <_printf_float+0x38a>
 802320c:	6823      	ldr	r3, [r4, #0]
 802320e:	07da      	lsls	r2, r3, #31
 8023210:	d437      	bmi.n	8023282 <_printf_float+0x38a>
 8023212:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 8023214:	ebaa 0903 	sub.w	r9, sl, r3
 8023218:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 802321a:	ebaa 0303 	sub.w	r3, sl, r3
 802321e:	4599      	cmp	r9, r3
 8023220:	bfa8      	it	ge
 8023222:	4699      	movge	r9, r3
 8023224:	f1b9 0f00 	cmp.w	r9, #0
 8023228:	dc33      	bgt.n	8023292 <_printf_float+0x39a>
 802322a:	f04f 0800 	mov.w	r8, #0
 802322e:	ea29 79e9 	bic.w	r9, r9, r9, asr #31
 8023232:	f104 0b1a 	add.w	fp, r4, #26
 8023236:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 8023238:	ebaa 0303 	sub.w	r3, sl, r3
 802323c:	eba3 0309 	sub.w	r3, r3, r9
 8023240:	4543      	cmp	r3, r8
 8023242:	f77f af79 	ble.w	8023138 <_printf_float+0x240>
 8023246:	2301      	movs	r3, #1
 8023248:	465a      	mov	r2, fp
 802324a:	4631      	mov	r1, r6
 802324c:	4628      	mov	r0, r5
 802324e:	47b8      	blx	r7
 8023250:	3001      	adds	r0, #1
 8023252:	f43f aeac 	beq.w	8022fae <_printf_float+0xb6>
 8023256:	f108 0801 	add.w	r8, r8, #1
 802325a:	e7ec      	b.n	8023236 <_printf_float+0x33e>
 802325c:	4642      	mov	r2, r8
 802325e:	4631      	mov	r1, r6
 8023260:	4628      	mov	r0, r5
 8023262:	47b8      	blx	r7
 8023264:	3001      	adds	r0, #1
 8023266:	d1c2      	bne.n	80231ee <_printf_float+0x2f6>
 8023268:	e6a1      	b.n	8022fae <_printf_float+0xb6>
 802326a:	2301      	movs	r3, #1
 802326c:	4631      	mov	r1, r6
 802326e:	4628      	mov	r0, r5
 8023270:	920a      	str	r2, [sp, #40]	@ 0x28
 8023272:	47b8      	blx	r7
 8023274:	3001      	adds	r0, #1
 8023276:	f43f ae9a 	beq.w	8022fae <_printf_float+0xb6>
 802327a:	f10b 0b01 	add.w	fp, fp, #1
 802327e:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 8023280:	e7bb      	b.n	80231fa <_printf_float+0x302>
 8023282:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 8023286:	4631      	mov	r1, r6
 8023288:	4628      	mov	r0, r5
 802328a:	47b8      	blx	r7
 802328c:	3001      	adds	r0, #1
 802328e:	d1c0      	bne.n	8023212 <_printf_float+0x31a>
 8023290:	e68d      	b.n	8022fae <_printf_float+0xb6>
 8023292:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 8023294:	464b      	mov	r3, r9
 8023296:	4631      	mov	r1, r6
 8023298:	4628      	mov	r0, r5
 802329a:	4442      	add	r2, r8
 802329c:	47b8      	blx	r7
 802329e:	3001      	adds	r0, #1
 80232a0:	d1c3      	bne.n	802322a <_printf_float+0x332>
 80232a2:	e684      	b.n	8022fae <_printf_float+0xb6>
 80232a4:	f8dd a038 	ldr.w	sl, [sp, #56]	@ 0x38
 80232a8:	f1ba 0f01 	cmp.w	sl, #1
 80232ac:	dc01      	bgt.n	80232b2 <_printf_float+0x3ba>
 80232ae:	07db      	lsls	r3, r3, #31
 80232b0:	d536      	bpl.n	8023320 <_printf_float+0x428>
 80232b2:	2301      	movs	r3, #1
 80232b4:	4642      	mov	r2, r8
 80232b6:	4631      	mov	r1, r6
 80232b8:	4628      	mov	r0, r5
 80232ba:	47b8      	blx	r7
 80232bc:	3001      	adds	r0, #1
 80232be:	f43f ae76 	beq.w	8022fae <_printf_float+0xb6>
 80232c2:	4631      	mov	r1, r6
 80232c4:	4628      	mov	r0, r5
 80232c6:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 80232ca:	47b8      	blx	r7
 80232cc:	3001      	adds	r0, #1
 80232ce:	f43f ae6e 	beq.w	8022fae <_printf_float+0xb6>
 80232d2:	2200      	movs	r2, #0
 80232d4:	2300      	movs	r3, #0
 80232d6:	f10a 3aff 	add.w	sl, sl, #4294967295
 80232da:	e9d4 0112 	ldrd	r0, r1, [r4, #72]	@ 0x48
 80232de:	f7dd fc01 	bl	8000ae4 <__aeabi_dcmpeq>
 80232e2:	b9c0      	cbnz	r0, 8023316 <_printf_float+0x41e>
 80232e4:	4653      	mov	r3, sl
 80232e6:	f108 0201 	add.w	r2, r8, #1
 80232ea:	4631      	mov	r1, r6
 80232ec:	4628      	mov	r0, r5
 80232ee:	47b8      	blx	r7
 80232f0:	3001      	adds	r0, #1
 80232f2:	d10c      	bne.n	802330e <_printf_float+0x416>
 80232f4:	e65b      	b.n	8022fae <_printf_float+0xb6>
 80232f6:	2301      	movs	r3, #1
 80232f8:	465a      	mov	r2, fp
 80232fa:	4631      	mov	r1, r6
 80232fc:	4628      	mov	r0, r5
 80232fe:	47b8      	blx	r7
 8023300:	3001      	adds	r0, #1
 8023302:	f43f ae54 	beq.w	8022fae <_printf_float+0xb6>
 8023306:	f108 0801 	add.w	r8, r8, #1
 802330a:	45d0      	cmp	r8, sl
 802330c:	dbf3      	blt.n	80232f6 <_printf_float+0x3fe>
 802330e:	464b      	mov	r3, r9
 8023310:	f104 0250 	add.w	r2, r4, #80	@ 0x50
 8023314:	e6df      	b.n	80230d6 <_printf_float+0x1de>
 8023316:	f04f 0800 	mov.w	r8, #0
 802331a:	f104 0b1a 	add.w	fp, r4, #26
 802331e:	e7f4      	b.n	802330a <_printf_float+0x412>
 8023320:	2301      	movs	r3, #1
 8023322:	4642      	mov	r2, r8
 8023324:	e7e1      	b.n	80232ea <_printf_float+0x3f2>
 8023326:	2301      	movs	r3, #1
 8023328:	464a      	mov	r2, r9
 802332a:	4631      	mov	r1, r6
 802332c:	4628      	mov	r0, r5
 802332e:	47b8      	blx	r7
 8023330:	3001      	adds	r0, #1
 8023332:	f43f ae3c 	beq.w	8022fae <_printf_float+0xb6>
 8023336:	f108 0801 	add.w	r8, r8, #1
 802333a:	68e3      	ldr	r3, [r4, #12]
 802333c:	990f      	ldr	r1, [sp, #60]	@ 0x3c
 802333e:	1a5b      	subs	r3, r3, r1
 8023340:	4543      	cmp	r3, r8
 8023342:	dcf0      	bgt.n	8023326 <_printf_float+0x42e>
 8023344:	e6fc      	b.n	8023140 <_printf_float+0x248>
 8023346:	f04f 0800 	mov.w	r8, #0
 802334a:	f104 0919 	add.w	r9, r4, #25
 802334e:	e7f4      	b.n	802333a <_printf_float+0x442>

08023350 <_printf_common>:
 8023350:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8023354:	4616      	mov	r6, r2
 8023356:	4698      	mov	r8, r3
 8023358:	688a      	ldr	r2, [r1, #8]
 802335a:	4607      	mov	r7, r0
 802335c:	690b      	ldr	r3, [r1, #16]
 802335e:	460c      	mov	r4, r1
 8023360:	f8dd 9020 	ldr.w	r9, [sp, #32]
 8023364:	4293      	cmp	r3, r2
 8023366:	bfb8      	it	lt
 8023368:	4613      	movlt	r3, r2
 802336a:	6033      	str	r3, [r6, #0]
 802336c:	f891 2043 	ldrb.w	r2, [r1, #67]	@ 0x43
 8023370:	b10a      	cbz	r2, 8023376 <_printf_common+0x26>
 8023372:	3301      	adds	r3, #1
 8023374:	6033      	str	r3, [r6, #0]
 8023376:	6823      	ldr	r3, [r4, #0]
 8023378:	0699      	lsls	r1, r3, #26
 802337a:	bf42      	ittt	mi
 802337c:	6833      	ldrmi	r3, [r6, #0]
 802337e:	3302      	addmi	r3, #2
 8023380:	6033      	strmi	r3, [r6, #0]
 8023382:	6825      	ldr	r5, [r4, #0]
 8023384:	f015 0506 	ands.w	r5, r5, #6
 8023388:	d106      	bne.n	8023398 <_printf_common+0x48>
 802338a:	f104 0a19 	add.w	sl, r4, #25
 802338e:	68e3      	ldr	r3, [r4, #12]
 8023390:	6832      	ldr	r2, [r6, #0]
 8023392:	1a9b      	subs	r3, r3, r2
 8023394:	42ab      	cmp	r3, r5
 8023396:	dc2b      	bgt.n	80233f0 <_printf_common+0xa0>
 8023398:	f894 3043 	ldrb.w	r3, [r4, #67]	@ 0x43
 802339c:	6822      	ldr	r2, [r4, #0]
 802339e:	3b00      	subs	r3, #0
 80233a0:	bf18      	it	ne
 80233a2:	2301      	movne	r3, #1
 80233a4:	0692      	lsls	r2, r2, #26
 80233a6:	d430      	bmi.n	802340a <_printf_common+0xba>
 80233a8:	f104 0243 	add.w	r2, r4, #67	@ 0x43
 80233ac:	4641      	mov	r1, r8
 80233ae:	4638      	mov	r0, r7
 80233b0:	47c8      	blx	r9
 80233b2:	3001      	adds	r0, #1
 80233b4:	d023      	beq.n	80233fe <_printf_common+0xae>
 80233b6:	6823      	ldr	r3, [r4, #0]
 80233b8:	341a      	adds	r4, #26
 80233ba:	f854 2c0a 	ldr.w	r2, [r4, #-10]
 80233be:	f003 0306 	and.w	r3, r3, #6
 80233c2:	2b04      	cmp	r3, #4
 80233c4:	bf0a      	itet	eq
 80233c6:	f854 5c0e 	ldreq.w	r5, [r4, #-14]
 80233ca:	2500      	movne	r5, #0
 80233cc:	6833      	ldreq	r3, [r6, #0]
 80233ce:	f04f 0600 	mov.w	r6, #0
 80233d2:	bf08      	it	eq
 80233d4:	1aed      	subeq	r5, r5, r3
 80233d6:	f854 3c12 	ldr.w	r3, [r4, #-18]
 80233da:	bf08      	it	eq
 80233dc:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 80233e0:	4293      	cmp	r3, r2
 80233e2:	bfc4      	itt	gt
 80233e4:	1a9b      	subgt	r3, r3, r2
 80233e6:	18ed      	addgt	r5, r5, r3
 80233e8:	42b5      	cmp	r5, r6
 80233ea:	d11a      	bne.n	8023422 <_printf_common+0xd2>
 80233ec:	2000      	movs	r0, #0
 80233ee:	e008      	b.n	8023402 <_printf_common+0xb2>
 80233f0:	2301      	movs	r3, #1
 80233f2:	4652      	mov	r2, sl
 80233f4:	4641      	mov	r1, r8
 80233f6:	4638      	mov	r0, r7
 80233f8:	47c8      	blx	r9
 80233fa:	3001      	adds	r0, #1
 80233fc:	d103      	bne.n	8023406 <_printf_common+0xb6>
 80233fe:	f04f 30ff 	mov.w	r0, #4294967295
 8023402:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8023406:	3501      	adds	r5, #1
 8023408:	e7c1      	b.n	802338e <_printf_common+0x3e>
 802340a:	18e1      	adds	r1, r4, r3
 802340c:	1c5a      	adds	r2, r3, #1
 802340e:	2030      	movs	r0, #48	@ 0x30
 8023410:	3302      	adds	r3, #2
 8023412:	4422      	add	r2, r4
 8023414:	f881 0043 	strb.w	r0, [r1, #67]	@ 0x43
 8023418:	f894 1045 	ldrb.w	r1, [r4, #69]	@ 0x45
 802341c:	f882 1043 	strb.w	r1, [r2, #67]	@ 0x43
 8023420:	e7c2      	b.n	80233a8 <_printf_common+0x58>
 8023422:	2301      	movs	r3, #1
 8023424:	4622      	mov	r2, r4
 8023426:	4641      	mov	r1, r8
 8023428:	4638      	mov	r0, r7
 802342a:	47c8      	blx	r9
 802342c:	3001      	adds	r0, #1
 802342e:	d0e6      	beq.n	80233fe <_printf_common+0xae>
 8023430:	3601      	adds	r6, #1
 8023432:	e7d9      	b.n	80233e8 <_printf_common+0x98>

08023434 <_printf_i>:
 8023434:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 8023438:	7e0f      	ldrb	r7, [r1, #24]
 802343a:	4691      	mov	r9, r2
 802343c:	4680      	mov	r8, r0
 802343e:	460c      	mov	r4, r1
 8023440:	2f78      	cmp	r7, #120	@ 0x78
 8023442:	469a      	mov	sl, r3
 8023444:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
 8023446:	f101 0243 	add.w	r2, r1, #67	@ 0x43
 802344a:	d807      	bhi.n	802345c <_printf_i+0x28>
 802344c:	2f62      	cmp	r7, #98	@ 0x62
 802344e:	d80a      	bhi.n	8023466 <_printf_i+0x32>
 8023450:	2f00      	cmp	r7, #0
 8023452:	f000 80d1 	beq.w	80235f8 <_printf_i+0x1c4>
 8023456:	2f58      	cmp	r7, #88	@ 0x58
 8023458:	f000 80b8 	beq.w	80235cc <_printf_i+0x198>
 802345c:	f104 0642 	add.w	r6, r4, #66	@ 0x42
 8023460:	f884 7042 	strb.w	r7, [r4, #66]	@ 0x42
 8023464:	e03a      	b.n	80234dc <_printf_i+0xa8>
 8023466:	f1a7 0363 	sub.w	r3, r7, #99	@ 0x63
 802346a:	2b15      	cmp	r3, #21
 802346c:	d8f6      	bhi.n	802345c <_printf_i+0x28>
 802346e:	a101      	add	r1, pc, #4	@ (adr r1, 8023474 <_printf_i+0x40>)
 8023470:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 8023474:	080234cd 	.word	0x080234cd
 8023478:	080234e1 	.word	0x080234e1
 802347c:	0802345d 	.word	0x0802345d
 8023480:	0802345d 	.word	0x0802345d
 8023484:	0802345d 	.word	0x0802345d
 8023488:	0802345d 	.word	0x0802345d
 802348c:	080234e1 	.word	0x080234e1
 8023490:	0802345d 	.word	0x0802345d
 8023494:	0802345d 	.word	0x0802345d
 8023498:	0802345d 	.word	0x0802345d
 802349c:	0802345d 	.word	0x0802345d
 80234a0:	080235df 	.word	0x080235df
 80234a4:	0802350b 	.word	0x0802350b
 80234a8:	08023599 	.word	0x08023599
 80234ac:	0802345d 	.word	0x0802345d
 80234b0:	0802345d 	.word	0x0802345d
 80234b4:	08023601 	.word	0x08023601
 80234b8:	0802345d 	.word	0x0802345d
 80234bc:	0802350b 	.word	0x0802350b
 80234c0:	0802345d 	.word	0x0802345d
 80234c4:	0802345d 	.word	0x0802345d
 80234c8:	080235a1 	.word	0x080235a1
 80234cc:	6833      	ldr	r3, [r6, #0]
 80234ce:	1d1a      	adds	r2, r3, #4
 80234d0:	681b      	ldr	r3, [r3, #0]
 80234d2:	6032      	str	r2, [r6, #0]
 80234d4:	f104 0642 	add.w	r6, r4, #66	@ 0x42
 80234d8:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
 80234dc:	2301      	movs	r3, #1
 80234de:	e09c      	b.n	802361a <_printf_i+0x1e6>
 80234e0:	6833      	ldr	r3, [r6, #0]
 80234e2:	6820      	ldr	r0, [r4, #0]
 80234e4:	1d19      	adds	r1, r3, #4
 80234e6:	6031      	str	r1, [r6, #0]
 80234e8:	0606      	lsls	r6, r0, #24
 80234ea:	d501      	bpl.n	80234f0 <_printf_i+0xbc>
 80234ec:	681d      	ldr	r5, [r3, #0]
 80234ee:	e003      	b.n	80234f8 <_printf_i+0xc4>
 80234f0:	0645      	lsls	r5, r0, #25
 80234f2:	d5fb      	bpl.n	80234ec <_printf_i+0xb8>
 80234f4:	f9b3 5000 	ldrsh.w	r5, [r3]
 80234f8:	2d00      	cmp	r5, #0
 80234fa:	da03      	bge.n	8023504 <_printf_i+0xd0>
 80234fc:	232d      	movs	r3, #45	@ 0x2d
 80234fe:	426d      	negs	r5, r5
 8023500:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
 8023504:	4858      	ldr	r0, [pc, #352]	@ (8023668 <_printf_i+0x234>)
 8023506:	230a      	movs	r3, #10
 8023508:	e011      	b.n	802352e <_printf_i+0xfa>
 802350a:	6821      	ldr	r1, [r4, #0]
 802350c:	6833      	ldr	r3, [r6, #0]
 802350e:	0608      	lsls	r0, r1, #24
 8023510:	f853 5b04 	ldr.w	r5, [r3], #4
 8023514:	d402      	bmi.n	802351c <_printf_i+0xe8>
 8023516:	0649      	lsls	r1, r1, #25
 8023518:	bf48      	it	mi
 802351a:	b2ad      	uxthmi	r5, r5
 802351c:	2f6f      	cmp	r7, #111	@ 0x6f
 802351e:	6033      	str	r3, [r6, #0]
 8023520:	4851      	ldr	r0, [pc, #324]	@ (8023668 <_printf_i+0x234>)
 8023522:	bf14      	ite	ne
 8023524:	230a      	movne	r3, #10
 8023526:	2308      	moveq	r3, #8
 8023528:	2100      	movs	r1, #0
 802352a:	f884 1043 	strb.w	r1, [r4, #67]	@ 0x43
 802352e:	6866      	ldr	r6, [r4, #4]
 8023530:	2e00      	cmp	r6, #0
 8023532:	60a6      	str	r6, [r4, #8]
 8023534:	db05      	blt.n	8023542 <_printf_i+0x10e>
 8023536:	6821      	ldr	r1, [r4, #0]
 8023538:	432e      	orrs	r6, r5
 802353a:	f021 0104 	bic.w	r1, r1, #4
 802353e:	6021      	str	r1, [r4, #0]
 8023540:	d04b      	beq.n	80235da <_printf_i+0x1a6>
 8023542:	4616      	mov	r6, r2
 8023544:	fbb5 f1f3 	udiv	r1, r5, r3
 8023548:	fb03 5711 	mls	r7, r3, r1, r5
 802354c:	5dc7      	ldrb	r7, [r0, r7]
 802354e:	f806 7d01 	strb.w	r7, [r6, #-1]!
 8023552:	462f      	mov	r7, r5
 8023554:	460d      	mov	r5, r1
 8023556:	42bb      	cmp	r3, r7
 8023558:	d9f4      	bls.n	8023544 <_printf_i+0x110>
 802355a:	2b08      	cmp	r3, #8
 802355c:	d10b      	bne.n	8023576 <_printf_i+0x142>
 802355e:	6823      	ldr	r3, [r4, #0]
 8023560:	07df      	lsls	r7, r3, #31
 8023562:	d508      	bpl.n	8023576 <_printf_i+0x142>
 8023564:	6923      	ldr	r3, [r4, #16]
 8023566:	6861      	ldr	r1, [r4, #4]
 8023568:	4299      	cmp	r1, r3
 802356a:	bfde      	ittt	le
 802356c:	2330      	movle	r3, #48	@ 0x30
 802356e:	f806 3c01 	strble.w	r3, [r6, #-1]
 8023572:	f106 36ff 	addle.w	r6, r6, #4294967295
 8023576:	1b92      	subs	r2, r2, r6
 8023578:	6122      	str	r2, [r4, #16]
 802357a:	464b      	mov	r3, r9
 802357c:	aa03      	add	r2, sp, #12
 802357e:	4621      	mov	r1, r4
 8023580:	4640      	mov	r0, r8
 8023582:	f8cd a000 	str.w	sl, [sp]
 8023586:	f7ff fee3 	bl	8023350 <_printf_common>
 802358a:	3001      	adds	r0, #1
 802358c:	d14a      	bne.n	8023624 <_printf_i+0x1f0>
 802358e:	f04f 30ff 	mov.w	r0, #4294967295
 8023592:	b004      	add	sp, #16
 8023594:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8023598:	6823      	ldr	r3, [r4, #0]
 802359a:	f043 0320 	orr.w	r3, r3, #32
 802359e:	6023      	str	r3, [r4, #0]
 80235a0:	2778      	movs	r7, #120	@ 0x78
 80235a2:	4832      	ldr	r0, [pc, #200]	@ (802366c <_printf_i+0x238>)
 80235a4:	6823      	ldr	r3, [r4, #0]
 80235a6:	f884 7045 	strb.w	r7, [r4, #69]	@ 0x45
 80235aa:	061f      	lsls	r7, r3, #24
 80235ac:	6831      	ldr	r1, [r6, #0]
 80235ae:	f851 5b04 	ldr.w	r5, [r1], #4
 80235b2:	d402      	bmi.n	80235ba <_printf_i+0x186>
 80235b4:	065f      	lsls	r7, r3, #25
 80235b6:	bf48      	it	mi
 80235b8:	b2ad      	uxthmi	r5, r5
 80235ba:	6031      	str	r1, [r6, #0]
 80235bc:	07d9      	lsls	r1, r3, #31
 80235be:	bf44      	itt	mi
 80235c0:	f043 0320 	orrmi.w	r3, r3, #32
 80235c4:	6023      	strmi	r3, [r4, #0]
 80235c6:	b11d      	cbz	r5, 80235d0 <_printf_i+0x19c>
 80235c8:	2310      	movs	r3, #16
 80235ca:	e7ad      	b.n	8023528 <_printf_i+0xf4>
 80235cc:	4826      	ldr	r0, [pc, #152]	@ (8023668 <_printf_i+0x234>)
 80235ce:	e7e9      	b.n	80235a4 <_printf_i+0x170>
 80235d0:	6823      	ldr	r3, [r4, #0]
 80235d2:	f023 0320 	bic.w	r3, r3, #32
 80235d6:	6023      	str	r3, [r4, #0]
 80235d8:	e7f6      	b.n	80235c8 <_printf_i+0x194>
 80235da:	4616      	mov	r6, r2
 80235dc:	e7bd      	b.n	802355a <_printf_i+0x126>
 80235de:	6833      	ldr	r3, [r6, #0]
 80235e0:	6825      	ldr	r5, [r4, #0]
 80235e2:	1d18      	adds	r0, r3, #4
 80235e4:	6961      	ldr	r1, [r4, #20]
 80235e6:	6030      	str	r0, [r6, #0]
 80235e8:	062e      	lsls	r6, r5, #24
 80235ea:	681b      	ldr	r3, [r3, #0]
 80235ec:	d501      	bpl.n	80235f2 <_printf_i+0x1be>
 80235ee:	6019      	str	r1, [r3, #0]
 80235f0:	e002      	b.n	80235f8 <_printf_i+0x1c4>
 80235f2:	0668      	lsls	r0, r5, #25
 80235f4:	d5fb      	bpl.n	80235ee <_printf_i+0x1ba>
 80235f6:	8019      	strh	r1, [r3, #0]
 80235f8:	2300      	movs	r3, #0
 80235fa:	4616      	mov	r6, r2
 80235fc:	6123      	str	r3, [r4, #16]
 80235fe:	e7bc      	b.n	802357a <_printf_i+0x146>
 8023600:	6833      	ldr	r3, [r6, #0]
 8023602:	2100      	movs	r1, #0
 8023604:	1d1a      	adds	r2, r3, #4
 8023606:	6032      	str	r2, [r6, #0]
 8023608:	681e      	ldr	r6, [r3, #0]
 802360a:	6862      	ldr	r2, [r4, #4]
 802360c:	4630      	mov	r0, r6
 802360e:	f000 fde0 	bl	80241d2 <memchr>
 8023612:	b108      	cbz	r0, 8023618 <_printf_i+0x1e4>
 8023614:	1b80      	subs	r0, r0, r6
 8023616:	6060      	str	r0, [r4, #4]
 8023618:	6863      	ldr	r3, [r4, #4]
 802361a:	6123      	str	r3, [r4, #16]
 802361c:	2300      	movs	r3, #0
 802361e:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
 8023622:	e7aa      	b.n	802357a <_printf_i+0x146>
 8023624:	6923      	ldr	r3, [r4, #16]
 8023626:	4632      	mov	r2, r6
 8023628:	4649      	mov	r1, r9
 802362a:	4640      	mov	r0, r8
 802362c:	47d0      	blx	sl
 802362e:	3001      	adds	r0, #1
 8023630:	d0ad      	beq.n	802358e <_printf_i+0x15a>
 8023632:	6823      	ldr	r3, [r4, #0]
 8023634:	079b      	lsls	r3, r3, #30
 8023636:	d413      	bmi.n	8023660 <_printf_i+0x22c>
 8023638:	68e0      	ldr	r0, [r4, #12]
 802363a:	9b03      	ldr	r3, [sp, #12]
 802363c:	4298      	cmp	r0, r3
 802363e:	bfb8      	it	lt
 8023640:	4618      	movlt	r0, r3
 8023642:	e7a6      	b.n	8023592 <_printf_i+0x15e>
 8023644:	2301      	movs	r3, #1
 8023646:	4632      	mov	r2, r6
 8023648:	4649      	mov	r1, r9
 802364a:	4640      	mov	r0, r8
 802364c:	47d0      	blx	sl
 802364e:	3001      	adds	r0, #1
 8023650:	d09d      	beq.n	802358e <_printf_i+0x15a>
 8023652:	3501      	adds	r5, #1
 8023654:	68e3      	ldr	r3, [r4, #12]
 8023656:	9903      	ldr	r1, [sp, #12]
 8023658:	1a5b      	subs	r3, r3, r1
 802365a:	42ab      	cmp	r3, r5
 802365c:	dcf2      	bgt.n	8023644 <_printf_i+0x210>
 802365e:	e7eb      	b.n	8023638 <_printf_i+0x204>
 8023660:	2500      	movs	r5, #0
 8023662:	f104 0619 	add.w	r6, r4, #25
 8023666:	e7f5      	b.n	8023654 <_printf_i+0x220>
 8023668:	0802a8c3 	.word	0x0802a8c3
 802366c:	0802a8d4 	.word	0x0802a8d4

08023670 <_scanf_float>:
 8023670:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8023674:	b087      	sub	sp, #28
 8023676:	4691      	mov	r9, r2
 8023678:	4680      	mov	r8, r0
 802367a:	460c      	mov	r4, r1
 802367c:	9303      	str	r3, [sp, #12]
 802367e:	688b      	ldr	r3, [r1, #8]
 8023680:	1e5a      	subs	r2, r3, #1
 8023682:	f5b2 7fae 	cmp.w	r2, #348	@ 0x15c
 8023686:	460a      	mov	r2, r1
 8023688:	bf89      	itett	hi
 802368a:	f46f 75ae 	mvnhi.w	r5, #348	@ 0x15c
 802368e:	f04f 0b00 	movls.w	fp, #0
 8023692:	eb03 0b05 	addhi.w	fp, r3, r5
 8023696:	f240 135d 	movwhi	r3, #349	@ 0x15d
 802369a:	f04f 0500 	mov.w	r5, #0
 802369e:	bf88      	it	hi
 80236a0:	608b      	strhi	r3, [r1, #8]
 80236a2:	680b      	ldr	r3, [r1, #0]
 80236a4:	46aa      	mov	sl, r5
 80236a6:	462f      	mov	r7, r5
 80236a8:	9502      	str	r5, [sp, #8]
 80236aa:	f443 63f0 	orr.w	r3, r3, #1920	@ 0x780
 80236ae:	f842 3b1c 	str.w	r3, [r2], #28
 80236b2:	4616      	mov	r6, r2
 80236b4:	9201      	str	r2, [sp, #4]
 80236b6:	e9cd 5504 	strd	r5, r5, [sp, #16]
 80236ba:	68a2      	ldr	r2, [r4, #8]
 80236bc:	b15a      	cbz	r2, 80236d6 <_scanf_float+0x66>
 80236be:	f8d9 3000 	ldr.w	r3, [r9]
 80236c2:	781b      	ldrb	r3, [r3, #0]
 80236c4:	2b4e      	cmp	r3, #78	@ 0x4e
 80236c6:	d863      	bhi.n	8023790 <_scanf_float+0x120>
 80236c8:	2b40      	cmp	r3, #64	@ 0x40
 80236ca:	d83b      	bhi.n	8023744 <_scanf_float+0xd4>
 80236cc:	f1a3 012b 	sub.w	r1, r3, #43	@ 0x2b
 80236d0:	b2c8      	uxtb	r0, r1
 80236d2:	280e      	cmp	r0, #14
 80236d4:	d939      	bls.n	802374a <_scanf_float+0xda>
 80236d6:	b11f      	cbz	r7, 80236e0 <_scanf_float+0x70>
 80236d8:	6823      	ldr	r3, [r4, #0]
 80236da:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
 80236de:	6023      	str	r3, [r4, #0]
 80236e0:	f10a 3aff 	add.w	sl, sl, #4294967295
 80236e4:	f1ba 0f01 	cmp.w	sl, #1
 80236e8:	f200 8115 	bhi.w	8023916 <_scanf_float+0x2a6>
 80236ec:	9b01      	ldr	r3, [sp, #4]
 80236ee:	429e      	cmp	r6, r3
 80236f0:	f200 8106 	bhi.w	8023900 <_scanf_float+0x290>
 80236f4:	2001      	movs	r0, #1
 80236f6:	b007      	add	sp, #28
 80236f8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80236fc:	f1a3 0261 	sub.w	r2, r3, #97	@ 0x61
 8023700:	2a0d      	cmp	r2, #13
 8023702:	d8e8      	bhi.n	80236d6 <_scanf_float+0x66>
 8023704:	a101      	add	r1, pc, #4	@ (adr r1, 802370c <_scanf_float+0x9c>)
 8023706:	f851 f022 	ldr.w	pc, [r1, r2, lsl #2]
 802370a:	bf00      	nop
 802370c:	08023855 	.word	0x08023855
 8023710:	080236d7 	.word	0x080236d7
 8023714:	080236d7 	.word	0x080236d7
 8023718:	080236d7 	.word	0x080236d7
 802371c:	080238b1 	.word	0x080238b1
 8023720:	0802388b 	.word	0x0802388b
 8023724:	080236d7 	.word	0x080236d7
 8023728:	080236d7 	.word	0x080236d7
 802372c:	08023863 	.word	0x08023863
 8023730:	080236d7 	.word	0x080236d7
 8023734:	080236d7 	.word	0x080236d7
 8023738:	080236d7 	.word	0x080236d7
 802373c:	080236d7 	.word	0x080236d7
 8023740:	0802381f 	.word	0x0802381f
 8023744:	f1a3 0241 	sub.w	r2, r3, #65	@ 0x41
 8023748:	e7da      	b.n	8023700 <_scanf_float+0x90>
 802374a:	290e      	cmp	r1, #14
 802374c:	d8c3      	bhi.n	80236d6 <_scanf_float+0x66>
 802374e:	a001      	add	r0, pc, #4	@ (adr r0, 8023754 <_scanf_float+0xe4>)
 8023750:	f850 f021 	ldr.w	pc, [r0, r1, lsl #2]
 8023754:	0802380f 	.word	0x0802380f
 8023758:	080236d7 	.word	0x080236d7
 802375c:	0802380f 	.word	0x0802380f
 8023760:	0802389f 	.word	0x0802389f
 8023764:	080236d7 	.word	0x080236d7
 8023768:	080237b1 	.word	0x080237b1
 802376c:	080237f5 	.word	0x080237f5
 8023770:	080237f5 	.word	0x080237f5
 8023774:	080237f5 	.word	0x080237f5
 8023778:	080237f5 	.word	0x080237f5
 802377c:	080237f5 	.word	0x080237f5
 8023780:	080237f5 	.word	0x080237f5
 8023784:	080237f5 	.word	0x080237f5
 8023788:	080237f5 	.word	0x080237f5
 802378c:	080237f5 	.word	0x080237f5
 8023790:	2b6e      	cmp	r3, #110	@ 0x6e
 8023792:	d809      	bhi.n	80237a8 <_scanf_float+0x138>
 8023794:	2b60      	cmp	r3, #96	@ 0x60
 8023796:	d8b1      	bhi.n	80236fc <_scanf_float+0x8c>
 8023798:	2b54      	cmp	r3, #84	@ 0x54
 802379a:	d07b      	beq.n	8023894 <_scanf_float+0x224>
 802379c:	2b59      	cmp	r3, #89	@ 0x59
 802379e:	d19a      	bne.n	80236d6 <_scanf_float+0x66>
 80237a0:	2d07      	cmp	r5, #7
 80237a2:	d198      	bne.n	80236d6 <_scanf_float+0x66>
 80237a4:	2508      	movs	r5, #8
 80237a6:	e02f      	b.n	8023808 <_scanf_float+0x198>
 80237a8:	2b74      	cmp	r3, #116	@ 0x74
 80237aa:	d073      	beq.n	8023894 <_scanf_float+0x224>
 80237ac:	2b79      	cmp	r3, #121	@ 0x79
 80237ae:	e7f6      	b.n	802379e <_scanf_float+0x12e>
 80237b0:	6821      	ldr	r1, [r4, #0]
 80237b2:	05c8      	lsls	r0, r1, #23
 80237b4:	d51e      	bpl.n	80237f4 <_scanf_float+0x184>
 80237b6:	f021 0180 	bic.w	r1, r1, #128	@ 0x80
 80237ba:	3701      	adds	r7, #1
 80237bc:	6021      	str	r1, [r4, #0]
 80237be:	f1bb 0f00 	cmp.w	fp, #0
 80237c2:	d003      	beq.n	80237cc <_scanf_float+0x15c>
 80237c4:	3201      	adds	r2, #1
 80237c6:	f10b 3bff 	add.w	fp, fp, #4294967295
 80237ca:	60a2      	str	r2, [r4, #8]
 80237cc:	68a3      	ldr	r3, [r4, #8]
 80237ce:	3b01      	subs	r3, #1
 80237d0:	60a3      	str	r3, [r4, #8]
 80237d2:	6923      	ldr	r3, [r4, #16]
 80237d4:	3301      	adds	r3, #1
 80237d6:	6123      	str	r3, [r4, #16]
 80237d8:	f8d9 3004 	ldr.w	r3, [r9, #4]
 80237dc:	3b01      	subs	r3, #1
 80237de:	2b00      	cmp	r3, #0
 80237e0:	f8c9 3004 	str.w	r3, [r9, #4]
 80237e4:	f340 8083 	ble.w	80238ee <_scanf_float+0x27e>
 80237e8:	f8d9 3000 	ldr.w	r3, [r9]
 80237ec:	3301      	adds	r3, #1
 80237ee:	f8c9 3000 	str.w	r3, [r9]
 80237f2:	e762      	b.n	80236ba <_scanf_float+0x4a>
 80237f4:	eb1a 0105 	adds.w	r1, sl, r5
 80237f8:	f47f af6d 	bne.w	80236d6 <_scanf_float+0x66>
 80237fc:	6822      	ldr	r2, [r4, #0]
 80237fe:	460d      	mov	r5, r1
 8023800:	468a      	mov	sl, r1
 8023802:	f422 72c0 	bic.w	r2, r2, #384	@ 0x180
 8023806:	6022      	str	r2, [r4, #0]
 8023808:	f806 3b01 	strb.w	r3, [r6], #1
 802380c:	e7de      	b.n	80237cc <_scanf_float+0x15c>
 802380e:	6822      	ldr	r2, [r4, #0]
 8023810:	0610      	lsls	r0, r2, #24
 8023812:	f57f af60 	bpl.w	80236d6 <_scanf_float+0x66>
 8023816:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
 802381a:	6022      	str	r2, [r4, #0]
 802381c:	e7f4      	b.n	8023808 <_scanf_float+0x198>
 802381e:	f1ba 0f00 	cmp.w	sl, #0
 8023822:	d10c      	bne.n	802383e <_scanf_float+0x1ce>
 8023824:	b977      	cbnz	r7, 8023844 <_scanf_float+0x1d4>
 8023826:	6822      	ldr	r2, [r4, #0]
 8023828:	f402 61e0 	and.w	r1, r2, #1792	@ 0x700
 802382c:	f5b1 6fe0 	cmp.w	r1, #1792	@ 0x700
 8023830:	d108      	bne.n	8023844 <_scanf_float+0x1d4>
 8023832:	f422 62f0 	bic.w	r2, r2, #1920	@ 0x780
 8023836:	f04f 0a01 	mov.w	sl, #1
 802383a:	6022      	str	r2, [r4, #0]
 802383c:	e7e4      	b.n	8023808 <_scanf_float+0x198>
 802383e:	f1ba 0f02 	cmp.w	sl, #2
 8023842:	d051      	beq.n	80238e8 <_scanf_float+0x278>
 8023844:	2d01      	cmp	r5, #1
 8023846:	d002      	beq.n	802384e <_scanf_float+0x1de>
 8023848:	2d04      	cmp	r5, #4
 802384a:	f47f af44 	bne.w	80236d6 <_scanf_float+0x66>
 802384e:	3501      	adds	r5, #1
 8023850:	b2ed      	uxtb	r5, r5
 8023852:	e7d9      	b.n	8023808 <_scanf_float+0x198>
 8023854:	f1ba 0f01 	cmp.w	sl, #1
 8023858:	f47f af3d 	bne.w	80236d6 <_scanf_float+0x66>
 802385c:	f04f 0a02 	mov.w	sl, #2
 8023860:	e7d2      	b.n	8023808 <_scanf_float+0x198>
 8023862:	b975      	cbnz	r5, 8023882 <_scanf_float+0x212>
 8023864:	2f00      	cmp	r7, #0
 8023866:	f47f af37 	bne.w	80236d8 <_scanf_float+0x68>
 802386a:	6822      	ldr	r2, [r4, #0]
 802386c:	f402 61e0 	and.w	r1, r2, #1792	@ 0x700
 8023870:	f5b1 6fe0 	cmp.w	r1, #1792	@ 0x700
 8023874:	f040 80fe 	bne.w	8023a74 <_scanf_float+0x404>
 8023878:	f422 62f0 	bic.w	r2, r2, #1920	@ 0x780
 802387c:	2501      	movs	r5, #1
 802387e:	6022      	str	r2, [r4, #0]
 8023880:	e7c2      	b.n	8023808 <_scanf_float+0x198>
 8023882:	2d03      	cmp	r5, #3
 8023884:	d0e3      	beq.n	802384e <_scanf_float+0x1de>
 8023886:	2d05      	cmp	r5, #5
 8023888:	e7df      	b.n	802384a <_scanf_float+0x1da>
 802388a:	2d02      	cmp	r5, #2
 802388c:	f47f af23 	bne.w	80236d6 <_scanf_float+0x66>
 8023890:	2503      	movs	r5, #3
 8023892:	e7b9      	b.n	8023808 <_scanf_float+0x198>
 8023894:	2d06      	cmp	r5, #6
 8023896:	f47f af1e 	bne.w	80236d6 <_scanf_float+0x66>
 802389a:	2507      	movs	r5, #7
 802389c:	e7b4      	b.n	8023808 <_scanf_float+0x198>
 802389e:	6822      	ldr	r2, [r4, #0]
 80238a0:	0591      	lsls	r1, r2, #22
 80238a2:	f57f af18 	bpl.w	80236d6 <_scanf_float+0x66>
 80238a6:	f422 7220 	bic.w	r2, r2, #640	@ 0x280
 80238aa:	9702      	str	r7, [sp, #8]
 80238ac:	6022      	str	r2, [r4, #0]
 80238ae:	e7ab      	b.n	8023808 <_scanf_float+0x198>
 80238b0:	6822      	ldr	r2, [r4, #0]
 80238b2:	f402 61a0 	and.w	r1, r2, #1280	@ 0x500
 80238b6:	f5b1 6f80 	cmp.w	r1, #1024	@ 0x400
 80238ba:	d005      	beq.n	80238c8 <_scanf_float+0x258>
 80238bc:	0550      	lsls	r0, r2, #21
 80238be:	f57f af0a 	bpl.w	80236d6 <_scanf_float+0x66>
 80238c2:	2f00      	cmp	r7, #0
 80238c4:	f000 80d6 	beq.w	8023a74 <_scanf_float+0x404>
 80238c8:	0591      	lsls	r1, r2, #22
 80238ca:	f422 62f0 	bic.w	r2, r2, #1920	@ 0x780
 80238ce:	bf58      	it	pl
 80238d0:	9902      	ldrpl	r1, [sp, #8]
 80238d2:	f442 72c0 	orr.w	r2, r2, #384	@ 0x180
 80238d6:	bf58      	it	pl
 80238d8:	1a79      	subpl	r1, r7, r1
 80238da:	6022      	str	r2, [r4, #0]
 80238dc:	f04f 0700 	mov.w	r7, #0
 80238e0:	bf58      	it	pl
 80238e2:	e9cd 1604 	strdpl	r1, r6, [sp, #16]
 80238e6:	e78f      	b.n	8023808 <_scanf_float+0x198>
 80238e8:	f04f 0a03 	mov.w	sl, #3
 80238ec:	e78c      	b.n	8023808 <_scanf_float+0x198>
 80238ee:	f8d4 3180 	ldr.w	r3, [r4, #384]	@ 0x180
 80238f2:	4649      	mov	r1, r9
 80238f4:	4640      	mov	r0, r8
 80238f6:	4798      	blx	r3
 80238f8:	2800      	cmp	r0, #0
 80238fa:	f43f aede 	beq.w	80236ba <_scanf_float+0x4a>
 80238fe:	e6ea      	b.n	80236d6 <_scanf_float+0x66>
 8023900:	f8d4 317c 	ldr.w	r3, [r4, #380]	@ 0x17c
 8023904:	464a      	mov	r2, r9
 8023906:	f816 1d01 	ldrb.w	r1, [r6, #-1]!
 802390a:	4640      	mov	r0, r8
 802390c:	4798      	blx	r3
 802390e:	6923      	ldr	r3, [r4, #16]
 8023910:	3b01      	subs	r3, #1
 8023912:	6123      	str	r3, [r4, #16]
 8023914:	e6ea      	b.n	80236ec <_scanf_float+0x7c>
 8023916:	1e6b      	subs	r3, r5, #1
 8023918:	2b06      	cmp	r3, #6
 802391a:	d824      	bhi.n	8023966 <_scanf_float+0x2f6>
 802391c:	2d02      	cmp	r5, #2
 802391e:	d836      	bhi.n	802398e <_scanf_float+0x31e>
 8023920:	9b01      	ldr	r3, [sp, #4]
 8023922:	429e      	cmp	r6, r3
 8023924:	f67f aee6 	bls.w	80236f4 <_scanf_float+0x84>
 8023928:	f8d4 317c 	ldr.w	r3, [r4, #380]	@ 0x17c
 802392c:	464a      	mov	r2, r9
 802392e:	f816 1d01 	ldrb.w	r1, [r6, #-1]!
 8023932:	4640      	mov	r0, r8
 8023934:	4798      	blx	r3
 8023936:	6923      	ldr	r3, [r4, #16]
 8023938:	3b01      	subs	r3, #1
 802393a:	6123      	str	r3, [r4, #16]
 802393c:	e7f0      	b.n	8023920 <_scanf_float+0x2b0>
 802393e:	f8d4 317c 	ldr.w	r3, [r4, #380]	@ 0x17c
 8023942:	464a      	mov	r2, r9
 8023944:	f81b 1d01 	ldrb.w	r1, [fp, #-1]!
 8023948:	4640      	mov	r0, r8
 802394a:	4798      	blx	r3
 802394c:	6923      	ldr	r3, [r4, #16]
 802394e:	3b01      	subs	r3, #1
 8023950:	6123      	str	r3, [r4, #16]
 8023952:	f10a 3aff 	add.w	sl, sl, #4294967295
 8023956:	fa5f fa8a 	uxtb.w	sl, sl
 802395a:	f1ba 0f02 	cmp.w	sl, #2
 802395e:	d1ee      	bne.n	802393e <_scanf_float+0x2ce>
 8023960:	3d03      	subs	r5, #3
 8023962:	b2ed      	uxtb	r5, r5
 8023964:	1b76      	subs	r6, r6, r5
 8023966:	6823      	ldr	r3, [r4, #0]
 8023968:	05da      	lsls	r2, r3, #23
 802396a:	d52f      	bpl.n	80239cc <_scanf_float+0x35c>
 802396c:	055b      	lsls	r3, r3, #21
 802396e:	d511      	bpl.n	8023994 <_scanf_float+0x324>
 8023970:	9b01      	ldr	r3, [sp, #4]
 8023972:	429e      	cmp	r6, r3
 8023974:	f67f aebe 	bls.w	80236f4 <_scanf_float+0x84>
 8023978:	f8d4 317c 	ldr.w	r3, [r4, #380]	@ 0x17c
 802397c:	464a      	mov	r2, r9
 802397e:	f816 1d01 	ldrb.w	r1, [r6, #-1]!
 8023982:	4640      	mov	r0, r8
 8023984:	4798      	blx	r3
 8023986:	6923      	ldr	r3, [r4, #16]
 8023988:	3b01      	subs	r3, #1
 802398a:	6123      	str	r3, [r4, #16]
 802398c:	e7f0      	b.n	8023970 <_scanf_float+0x300>
 802398e:	46aa      	mov	sl, r5
 8023990:	46b3      	mov	fp, r6
 8023992:	e7de      	b.n	8023952 <_scanf_float+0x2e2>
 8023994:	f816 1c01 	ldrb.w	r1, [r6, #-1]
 8023998:	1e75      	subs	r5, r6, #1
 802399a:	6923      	ldr	r3, [r4, #16]
 802399c:	2965      	cmp	r1, #101	@ 0x65
 802399e:	f103 33ff 	add.w	r3, r3, #4294967295
 80239a2:	6123      	str	r3, [r4, #16]
 80239a4:	d00c      	beq.n	80239c0 <_scanf_float+0x350>
 80239a6:	2945      	cmp	r1, #69	@ 0x45
 80239a8:	d00a      	beq.n	80239c0 <_scanf_float+0x350>
 80239aa:	f8d4 317c 	ldr.w	r3, [r4, #380]	@ 0x17c
 80239ae:	464a      	mov	r2, r9
 80239b0:	4640      	mov	r0, r8
 80239b2:	1eb5      	subs	r5, r6, #2
 80239b4:	4798      	blx	r3
 80239b6:	6923      	ldr	r3, [r4, #16]
 80239b8:	f816 1c02 	ldrb.w	r1, [r6, #-2]
 80239bc:	3b01      	subs	r3, #1
 80239be:	6123      	str	r3, [r4, #16]
 80239c0:	462e      	mov	r6, r5
 80239c2:	f8d4 317c 	ldr.w	r3, [r4, #380]	@ 0x17c
 80239c6:	464a      	mov	r2, r9
 80239c8:	4640      	mov	r0, r8
 80239ca:	4798      	blx	r3
 80239cc:	6822      	ldr	r2, [r4, #0]
 80239ce:	f012 0210 	ands.w	r2, r2, #16
 80239d2:	d001      	beq.n	80239d8 <_scanf_float+0x368>
 80239d4:	2000      	movs	r0, #0
 80239d6:	e68e      	b.n	80236f6 <_scanf_float+0x86>
 80239d8:	7032      	strb	r2, [r6, #0]
 80239da:	6823      	ldr	r3, [r4, #0]
 80239dc:	f403 63c0 	and.w	r3, r3, #1536	@ 0x600
 80239e0:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 80239e4:	d125      	bne.n	8023a32 <_scanf_float+0x3c2>
 80239e6:	9b02      	ldr	r3, [sp, #8]
 80239e8:	429f      	cmp	r7, r3
 80239ea:	d00a      	beq.n	8023a02 <_scanf_float+0x392>
 80239ec:	1bda      	subs	r2, r3, r7
 80239ee:	f204 136f 	addw	r3, r4, #367	@ 0x16f
 80239f2:	4921      	ldr	r1, [pc, #132]	@ (8023a78 <_scanf_float+0x408>)
 80239f4:	429e      	cmp	r6, r3
 80239f6:	bf28      	it	cs
 80239f8:	f504 76b7 	addcs.w	r6, r4, #366	@ 0x16e
 80239fc:	4630      	mov	r0, r6
 80239fe:	f000 fa1d 	bl	8023e3c <siprintf>
 8023a02:	2200      	movs	r2, #0
 8023a04:	9901      	ldr	r1, [sp, #4]
 8023a06:	4640      	mov	r0, r8
 8023a08:	f7ff f9c6 	bl	8022d98 <_strtod_r>
 8023a0c:	6825      	ldr	r5, [r4, #0]
 8023a0e:	9b03      	ldr	r3, [sp, #12]
 8023a10:	4606      	mov	r6, r0
 8023a12:	f015 0f02 	tst.w	r5, #2
 8023a16:	460f      	mov	r7, r1
 8023a18:	681b      	ldr	r3, [r3, #0]
 8023a1a:	f103 0204 	add.w	r2, r3, #4
 8023a1e:	d015      	beq.n	8023a4c <_scanf_float+0x3dc>
 8023a20:	9903      	ldr	r1, [sp, #12]
 8023a22:	600a      	str	r2, [r1, #0]
 8023a24:	681b      	ldr	r3, [r3, #0]
 8023a26:	e9c3 6700 	strd	r6, r7, [r3]
 8023a2a:	68e3      	ldr	r3, [r4, #12]
 8023a2c:	3301      	adds	r3, #1
 8023a2e:	60e3      	str	r3, [r4, #12]
 8023a30:	e7d0      	b.n	80239d4 <_scanf_float+0x364>
 8023a32:	9b04      	ldr	r3, [sp, #16]
 8023a34:	2b00      	cmp	r3, #0
 8023a36:	d0e4      	beq.n	8023a02 <_scanf_float+0x392>
 8023a38:	9905      	ldr	r1, [sp, #20]
 8023a3a:	230a      	movs	r3, #10
 8023a3c:	4640      	mov	r0, r8
 8023a3e:	3101      	adds	r1, #1
 8023a40:	f002 fb22 	bl	8026088 <_strtol_r>
 8023a44:	9b04      	ldr	r3, [sp, #16]
 8023a46:	9e05      	ldr	r6, [sp, #20]
 8023a48:	1ac2      	subs	r2, r0, r3
 8023a4a:	e7d0      	b.n	80239ee <_scanf_float+0x37e>
 8023a4c:	076d      	lsls	r5, r5, #29
 8023a4e:	d4e7      	bmi.n	8023a20 <_scanf_float+0x3b0>
 8023a50:	9d03      	ldr	r5, [sp, #12]
 8023a52:	602a      	str	r2, [r5, #0]
 8023a54:	4602      	mov	r2, r0
 8023a56:	681d      	ldr	r5, [r3, #0]
 8023a58:	460b      	mov	r3, r1
 8023a5a:	f7dd f875 	bl	8000b48 <__aeabi_dcmpun>
 8023a5e:	b120      	cbz	r0, 8023a6a <_scanf_float+0x3fa>
 8023a60:	4806      	ldr	r0, [pc, #24]	@ (8023a7c <_scanf_float+0x40c>)
 8023a62:	f000 fbd7 	bl	8024214 <nanf>
 8023a66:	6028      	str	r0, [r5, #0]
 8023a68:	e7df      	b.n	8023a2a <_scanf_float+0x3ba>
 8023a6a:	4630      	mov	r0, r6
 8023a6c:	4639      	mov	r1, r7
 8023a6e:	f7dd f8c9 	bl	8000c04 <__aeabi_d2f>
 8023a72:	e7f8      	b.n	8023a66 <_scanf_float+0x3f6>
 8023a74:	2700      	movs	r7, #0
 8023a76:	e633      	b.n	80236e0 <_scanf_float+0x70>
 8023a78:	0802a8e5 	.word	0x0802a8e5
 8023a7c:	0802a92d 	.word	0x0802a92d

08023a80 <__sflush_r>:
 8023a80:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
 8023a84:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8023a88:	0716      	lsls	r6, r2, #28
 8023a8a:	4605      	mov	r5, r0
 8023a8c:	460c      	mov	r4, r1
 8023a8e:	d454      	bmi.n	8023b3a <__sflush_r+0xba>
 8023a90:	684b      	ldr	r3, [r1, #4]
 8023a92:	2b00      	cmp	r3, #0
 8023a94:	dc02      	bgt.n	8023a9c <__sflush_r+0x1c>
 8023a96:	6c0b      	ldr	r3, [r1, #64]	@ 0x40
 8023a98:	2b00      	cmp	r3, #0
 8023a9a:	dd48      	ble.n	8023b2e <__sflush_r+0xae>
 8023a9c:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
 8023a9e:	2e00      	cmp	r6, #0
 8023aa0:	d045      	beq.n	8023b2e <__sflush_r+0xae>
 8023aa2:	2300      	movs	r3, #0
 8023aa4:	f412 5280 	ands.w	r2, r2, #4096	@ 0x1000
 8023aa8:	682f      	ldr	r7, [r5, #0]
 8023aaa:	6a21      	ldr	r1, [r4, #32]
 8023aac:	602b      	str	r3, [r5, #0]
 8023aae:	d030      	beq.n	8023b12 <__sflush_r+0x92>
 8023ab0:	6d62      	ldr	r2, [r4, #84]	@ 0x54
 8023ab2:	89a3      	ldrh	r3, [r4, #12]
 8023ab4:	0759      	lsls	r1, r3, #29
 8023ab6:	d505      	bpl.n	8023ac4 <__sflush_r+0x44>
 8023ab8:	6863      	ldr	r3, [r4, #4]
 8023aba:	1ad2      	subs	r2, r2, r3
 8023abc:	6b63      	ldr	r3, [r4, #52]	@ 0x34
 8023abe:	b10b      	cbz	r3, 8023ac4 <__sflush_r+0x44>
 8023ac0:	6c23      	ldr	r3, [r4, #64]	@ 0x40
 8023ac2:	1ad2      	subs	r2, r2, r3
 8023ac4:	2300      	movs	r3, #0
 8023ac6:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
 8023ac8:	6a21      	ldr	r1, [r4, #32]
 8023aca:	4628      	mov	r0, r5
 8023acc:	47b0      	blx	r6
 8023ace:	1c43      	adds	r3, r0, #1
 8023ad0:	89a3      	ldrh	r3, [r4, #12]
 8023ad2:	d106      	bne.n	8023ae2 <__sflush_r+0x62>
 8023ad4:	6829      	ldr	r1, [r5, #0]
 8023ad6:	291d      	cmp	r1, #29
 8023ad8:	d82b      	bhi.n	8023b32 <__sflush_r+0xb2>
 8023ada:	4a2a      	ldr	r2, [pc, #168]	@ (8023b84 <__sflush_r+0x104>)
 8023adc:	40ca      	lsrs	r2, r1
 8023ade:	07d6      	lsls	r6, r2, #31
 8023ae0:	d527      	bpl.n	8023b32 <__sflush_r+0xb2>
 8023ae2:	2200      	movs	r2, #0
 8023ae4:	04d9      	lsls	r1, r3, #19
 8023ae6:	6062      	str	r2, [r4, #4]
 8023ae8:	6922      	ldr	r2, [r4, #16]
 8023aea:	6022      	str	r2, [r4, #0]
 8023aec:	d504      	bpl.n	8023af8 <__sflush_r+0x78>
 8023aee:	1c42      	adds	r2, r0, #1
 8023af0:	d101      	bne.n	8023af6 <__sflush_r+0x76>
 8023af2:	682b      	ldr	r3, [r5, #0]
 8023af4:	b903      	cbnz	r3, 8023af8 <__sflush_r+0x78>
 8023af6:	6560      	str	r0, [r4, #84]	@ 0x54
 8023af8:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 8023afa:	602f      	str	r7, [r5, #0]
 8023afc:	b1b9      	cbz	r1, 8023b2e <__sflush_r+0xae>
 8023afe:	f104 0344 	add.w	r3, r4, #68	@ 0x44
 8023b02:	4299      	cmp	r1, r3
 8023b04:	d002      	beq.n	8023b0c <__sflush_r+0x8c>
 8023b06:	4628      	mov	r0, r5
 8023b08:	f001 fa08 	bl	8024f1c <_free_r>
 8023b0c:	2300      	movs	r3, #0
 8023b0e:	6363      	str	r3, [r4, #52]	@ 0x34
 8023b10:	e00d      	b.n	8023b2e <__sflush_r+0xae>
 8023b12:	2301      	movs	r3, #1
 8023b14:	4628      	mov	r0, r5
 8023b16:	47b0      	blx	r6
 8023b18:	4602      	mov	r2, r0
 8023b1a:	1c50      	adds	r0, r2, #1
 8023b1c:	d1c9      	bne.n	8023ab2 <__sflush_r+0x32>
 8023b1e:	682b      	ldr	r3, [r5, #0]
 8023b20:	2b00      	cmp	r3, #0
 8023b22:	d0c6      	beq.n	8023ab2 <__sflush_r+0x32>
 8023b24:	2b1d      	cmp	r3, #29
 8023b26:	d001      	beq.n	8023b2c <__sflush_r+0xac>
 8023b28:	2b16      	cmp	r3, #22
 8023b2a:	d11d      	bne.n	8023b68 <__sflush_r+0xe8>
 8023b2c:	602f      	str	r7, [r5, #0]
 8023b2e:	2000      	movs	r0, #0
 8023b30:	e021      	b.n	8023b76 <__sflush_r+0xf6>
 8023b32:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8023b36:	b21b      	sxth	r3, r3
 8023b38:	e01a      	b.n	8023b70 <__sflush_r+0xf0>
 8023b3a:	690f      	ldr	r7, [r1, #16]
 8023b3c:	2f00      	cmp	r7, #0
 8023b3e:	d0f6      	beq.n	8023b2e <__sflush_r+0xae>
 8023b40:	0793      	lsls	r3, r2, #30
 8023b42:	680e      	ldr	r6, [r1, #0]
 8023b44:	600f      	str	r7, [r1, #0]
 8023b46:	bf0c      	ite	eq
 8023b48:	694b      	ldreq	r3, [r1, #20]
 8023b4a:	2300      	movne	r3, #0
 8023b4c:	eba6 0807 	sub.w	r8, r6, r7
 8023b50:	608b      	str	r3, [r1, #8]
 8023b52:	f1b8 0f00 	cmp.w	r8, #0
 8023b56:	ddea      	ble.n	8023b2e <__sflush_r+0xae>
 8023b58:	4643      	mov	r3, r8
 8023b5a:	463a      	mov	r2, r7
 8023b5c:	6a21      	ldr	r1, [r4, #32]
 8023b5e:	4628      	mov	r0, r5
 8023b60:	6aa6      	ldr	r6, [r4, #40]	@ 0x28
 8023b62:	47b0      	blx	r6
 8023b64:	2800      	cmp	r0, #0
 8023b66:	dc08      	bgt.n	8023b7a <__sflush_r+0xfa>
 8023b68:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8023b6c:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8023b70:	f04f 30ff 	mov.w	r0, #4294967295
 8023b74:	81a3      	strh	r3, [r4, #12]
 8023b76:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8023b7a:	4407      	add	r7, r0
 8023b7c:	eba8 0800 	sub.w	r8, r8, r0
 8023b80:	e7e7      	b.n	8023b52 <__sflush_r+0xd2>
 8023b82:	bf00      	nop
 8023b84:	20400001 	.word	0x20400001

08023b88 <_fflush_r>:
 8023b88:	b538      	push	{r3, r4, r5, lr}
 8023b8a:	690b      	ldr	r3, [r1, #16]
 8023b8c:	4605      	mov	r5, r0
 8023b8e:	460c      	mov	r4, r1
 8023b90:	b913      	cbnz	r3, 8023b98 <_fflush_r+0x10>
 8023b92:	2500      	movs	r5, #0
 8023b94:	4628      	mov	r0, r5
 8023b96:	bd38      	pop	{r3, r4, r5, pc}
 8023b98:	b118      	cbz	r0, 8023ba2 <_fflush_r+0x1a>
 8023b9a:	6a03      	ldr	r3, [r0, #32]
 8023b9c:	b90b      	cbnz	r3, 8023ba2 <_fflush_r+0x1a>
 8023b9e:	f000 f8a7 	bl	8023cf0 <__sinit>
 8023ba2:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8023ba6:	2b00      	cmp	r3, #0
 8023ba8:	d0f3      	beq.n	8023b92 <_fflush_r+0xa>
 8023baa:	6e62      	ldr	r2, [r4, #100]	@ 0x64
 8023bac:	07d0      	lsls	r0, r2, #31
 8023bae:	d404      	bmi.n	8023bba <_fflush_r+0x32>
 8023bb0:	0599      	lsls	r1, r3, #22
 8023bb2:	d402      	bmi.n	8023bba <_fflush_r+0x32>
 8023bb4:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 8023bb6:	f000 fb02 	bl	80241be <__retarget_lock_acquire_recursive>
 8023bba:	4628      	mov	r0, r5
 8023bbc:	4621      	mov	r1, r4
 8023bbe:	f7ff ff5f 	bl	8023a80 <__sflush_r>
 8023bc2:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 8023bc4:	4605      	mov	r5, r0
 8023bc6:	07da      	lsls	r2, r3, #31
 8023bc8:	d4e4      	bmi.n	8023b94 <_fflush_r+0xc>
 8023bca:	89a3      	ldrh	r3, [r4, #12]
 8023bcc:	059b      	lsls	r3, r3, #22
 8023bce:	d4e1      	bmi.n	8023b94 <_fflush_r+0xc>
 8023bd0:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 8023bd2:	f000 faf5 	bl	80241c0 <__retarget_lock_release_recursive>
 8023bd6:	e7dd      	b.n	8023b94 <_fflush_r+0xc>

08023bd8 <std>:
 8023bd8:	2300      	movs	r3, #0
 8023bda:	b510      	push	{r4, lr}
 8023bdc:	4604      	mov	r4, r0
 8023bde:	6083      	str	r3, [r0, #8]
 8023be0:	8181      	strh	r1, [r0, #12]
 8023be2:	4619      	mov	r1, r3
 8023be4:	6643      	str	r3, [r0, #100]	@ 0x64
 8023be6:	81c2      	strh	r2, [r0, #14]
 8023be8:	2208      	movs	r2, #8
 8023bea:	6183      	str	r3, [r0, #24]
 8023bec:	e9c0 3300 	strd	r3, r3, [r0]
 8023bf0:	e9c0 3304 	strd	r3, r3, [r0, #16]
 8023bf4:	305c      	adds	r0, #92	@ 0x5c
 8023bf6:	f000 fa35 	bl	8024064 <memset>
 8023bfa:	4b0d      	ldr	r3, [pc, #52]	@ (8023c30 <std+0x58>)
 8023bfc:	6224      	str	r4, [r4, #32]
 8023bfe:	6263      	str	r3, [r4, #36]	@ 0x24
 8023c00:	4b0c      	ldr	r3, [pc, #48]	@ (8023c34 <std+0x5c>)
 8023c02:	62a3      	str	r3, [r4, #40]	@ 0x28
 8023c04:	4b0c      	ldr	r3, [pc, #48]	@ (8023c38 <std+0x60>)
 8023c06:	62e3      	str	r3, [r4, #44]	@ 0x2c
 8023c08:	4b0c      	ldr	r3, [pc, #48]	@ (8023c3c <std+0x64>)
 8023c0a:	6323      	str	r3, [r4, #48]	@ 0x30
 8023c0c:	4b0c      	ldr	r3, [pc, #48]	@ (8023c40 <std+0x68>)
 8023c0e:	429c      	cmp	r4, r3
 8023c10:	d006      	beq.n	8023c20 <std+0x48>
 8023c12:	f103 0268 	add.w	r2, r3, #104	@ 0x68
 8023c16:	4294      	cmp	r4, r2
 8023c18:	d002      	beq.n	8023c20 <std+0x48>
 8023c1a:	33d0      	adds	r3, #208	@ 0xd0
 8023c1c:	429c      	cmp	r4, r3
 8023c1e:	d105      	bne.n	8023c2c <std+0x54>
 8023c20:	f104 0058 	add.w	r0, r4, #88	@ 0x58
 8023c24:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8023c28:	f000 bac8 	b.w	80241bc <__retarget_lock_init_recursive>
 8023c2c:	bd10      	pop	{r4, pc}
 8023c2e:	bf00      	nop
 8023c30:	08023e81 	.word	0x08023e81
 8023c34:	08023ea3 	.word	0x08023ea3
 8023c38:	08023edb 	.word	0x08023edb
 8023c3c:	08023eff 	.word	0x08023eff
 8023c40:	20001ea8 	.word	0x20001ea8

08023c44 <stdio_exit_handler>:
 8023c44:	4a02      	ldr	r2, [pc, #8]	@ (8023c50 <stdio_exit_handler+0xc>)
 8023c46:	4903      	ldr	r1, [pc, #12]	@ (8023c54 <stdio_exit_handler+0x10>)
 8023c48:	4803      	ldr	r0, [pc, #12]	@ (8023c58 <stdio_exit_handler+0x14>)
 8023c4a:	f000 b869 	b.w	8023d20 <_fwalk_sglue>
 8023c4e:	bf00      	nop
 8023c50:	2000021c 	.word	0x2000021c
 8023c54:	08023b89 	.word	0x08023b89
 8023c58:	20000398 	.word	0x20000398

08023c5c <cleanup_stdio>:
 8023c5c:	6841      	ldr	r1, [r0, #4]
 8023c5e:	4b0c      	ldr	r3, [pc, #48]	@ (8023c90 <cleanup_stdio+0x34>)
 8023c60:	4299      	cmp	r1, r3
 8023c62:	b510      	push	{r4, lr}
 8023c64:	4604      	mov	r4, r0
 8023c66:	d001      	beq.n	8023c6c <cleanup_stdio+0x10>
 8023c68:	f7ff ff8e 	bl	8023b88 <_fflush_r>
 8023c6c:	68a1      	ldr	r1, [r4, #8]
 8023c6e:	4b09      	ldr	r3, [pc, #36]	@ (8023c94 <cleanup_stdio+0x38>)
 8023c70:	4299      	cmp	r1, r3
 8023c72:	d002      	beq.n	8023c7a <cleanup_stdio+0x1e>
 8023c74:	4620      	mov	r0, r4
 8023c76:	f7ff ff87 	bl	8023b88 <_fflush_r>
 8023c7a:	68e1      	ldr	r1, [r4, #12]
 8023c7c:	4b06      	ldr	r3, [pc, #24]	@ (8023c98 <cleanup_stdio+0x3c>)
 8023c7e:	4299      	cmp	r1, r3
 8023c80:	d004      	beq.n	8023c8c <cleanup_stdio+0x30>
 8023c82:	4620      	mov	r0, r4
 8023c84:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8023c88:	f7ff bf7e 	b.w	8023b88 <_fflush_r>
 8023c8c:	bd10      	pop	{r4, pc}
 8023c8e:	bf00      	nop
 8023c90:	20001ea8 	.word	0x20001ea8
 8023c94:	20001f10 	.word	0x20001f10
 8023c98:	20001f78 	.word	0x20001f78

08023c9c <global_stdio_init.part.0>:
 8023c9c:	b510      	push	{r4, lr}
 8023c9e:	4b0b      	ldr	r3, [pc, #44]	@ (8023ccc <global_stdio_init.part.0+0x30>)
 8023ca0:	2104      	movs	r1, #4
 8023ca2:	4c0b      	ldr	r4, [pc, #44]	@ (8023cd0 <global_stdio_init.part.0+0x34>)
 8023ca4:	4a0b      	ldr	r2, [pc, #44]	@ (8023cd4 <global_stdio_init.part.0+0x38>)
 8023ca6:	4620      	mov	r0, r4
 8023ca8:	601a      	str	r2, [r3, #0]
 8023caa:	2200      	movs	r2, #0
 8023cac:	f7ff ff94 	bl	8023bd8 <std>
 8023cb0:	f104 0068 	add.w	r0, r4, #104	@ 0x68
 8023cb4:	2201      	movs	r2, #1
 8023cb6:	2109      	movs	r1, #9
 8023cb8:	f7ff ff8e 	bl	8023bd8 <std>
 8023cbc:	f104 00d0 	add.w	r0, r4, #208	@ 0xd0
 8023cc0:	2202      	movs	r2, #2
 8023cc2:	2112      	movs	r1, #18
 8023cc4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8023cc8:	f7ff bf86 	b.w	8023bd8 <std>
 8023ccc:	20001fe0 	.word	0x20001fe0
 8023cd0:	20001ea8 	.word	0x20001ea8
 8023cd4:	08023c45 	.word	0x08023c45

08023cd8 <__sfp_lock_acquire>:
 8023cd8:	4801      	ldr	r0, [pc, #4]	@ (8023ce0 <__sfp_lock_acquire+0x8>)
 8023cda:	f000 ba70 	b.w	80241be <__retarget_lock_acquire_recursive>
 8023cde:	bf00      	nop
 8023ce0:	20001fe9 	.word	0x20001fe9

08023ce4 <__sfp_lock_release>:
 8023ce4:	4801      	ldr	r0, [pc, #4]	@ (8023cec <__sfp_lock_release+0x8>)
 8023ce6:	f000 ba6b 	b.w	80241c0 <__retarget_lock_release_recursive>
 8023cea:	bf00      	nop
 8023cec:	20001fe9 	.word	0x20001fe9

08023cf0 <__sinit>:
 8023cf0:	b510      	push	{r4, lr}
 8023cf2:	4604      	mov	r4, r0
 8023cf4:	f7ff fff0 	bl	8023cd8 <__sfp_lock_acquire>
 8023cf8:	6a23      	ldr	r3, [r4, #32]
 8023cfa:	b11b      	cbz	r3, 8023d04 <__sinit+0x14>
 8023cfc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8023d00:	f7ff bff0 	b.w	8023ce4 <__sfp_lock_release>
 8023d04:	4b04      	ldr	r3, [pc, #16]	@ (8023d18 <__sinit+0x28>)
 8023d06:	6223      	str	r3, [r4, #32]
 8023d08:	4b04      	ldr	r3, [pc, #16]	@ (8023d1c <__sinit+0x2c>)
 8023d0a:	681b      	ldr	r3, [r3, #0]
 8023d0c:	2b00      	cmp	r3, #0
 8023d0e:	d1f5      	bne.n	8023cfc <__sinit+0xc>
 8023d10:	f7ff ffc4 	bl	8023c9c <global_stdio_init.part.0>
 8023d14:	e7f2      	b.n	8023cfc <__sinit+0xc>
 8023d16:	bf00      	nop
 8023d18:	08023c5d 	.word	0x08023c5d
 8023d1c:	20001fe0 	.word	0x20001fe0

08023d20 <_fwalk_sglue>:
 8023d20:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8023d24:	4607      	mov	r7, r0
 8023d26:	4688      	mov	r8, r1
 8023d28:	4614      	mov	r4, r2
 8023d2a:	2600      	movs	r6, #0
 8023d2c:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
 8023d30:	f1b9 0901 	subs.w	r9, r9, #1
 8023d34:	d505      	bpl.n	8023d42 <_fwalk_sglue+0x22>
 8023d36:	6824      	ldr	r4, [r4, #0]
 8023d38:	2c00      	cmp	r4, #0
 8023d3a:	d1f7      	bne.n	8023d2c <_fwalk_sglue+0xc>
 8023d3c:	4630      	mov	r0, r6
 8023d3e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8023d42:	89ab      	ldrh	r3, [r5, #12]
 8023d44:	2b01      	cmp	r3, #1
 8023d46:	d907      	bls.n	8023d58 <_fwalk_sglue+0x38>
 8023d48:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 8023d4c:	3301      	adds	r3, #1
 8023d4e:	d003      	beq.n	8023d58 <_fwalk_sglue+0x38>
 8023d50:	4629      	mov	r1, r5
 8023d52:	4638      	mov	r0, r7
 8023d54:	47c0      	blx	r8
 8023d56:	4306      	orrs	r6, r0
 8023d58:	3568      	adds	r5, #104	@ 0x68
 8023d5a:	e7e9      	b.n	8023d30 <_fwalk_sglue+0x10>

08023d5c <iprintf>:
 8023d5c:	b40f      	push	{r0, r1, r2, r3}
 8023d5e:	b507      	push	{r0, r1, r2, lr}
 8023d60:	4906      	ldr	r1, [pc, #24]	@ (8023d7c <iprintf+0x20>)
 8023d62:	ab04      	add	r3, sp, #16
 8023d64:	6808      	ldr	r0, [r1, #0]
 8023d66:	f853 2b04 	ldr.w	r2, [r3], #4
 8023d6a:	6881      	ldr	r1, [r0, #8]
 8023d6c:	9301      	str	r3, [sp, #4]
 8023d6e:	f002 fb1b 	bl	80263a8 <_vfiprintf_r>
 8023d72:	b003      	add	sp, #12
 8023d74:	f85d eb04 	ldr.w	lr, [sp], #4
 8023d78:	b004      	add	sp, #16
 8023d7a:	4770      	bx	lr
 8023d7c:	20000394 	.word	0x20000394

08023d80 <_puts_r>:
 8023d80:	6a03      	ldr	r3, [r0, #32]
 8023d82:	b570      	push	{r4, r5, r6, lr}
 8023d84:	4605      	mov	r5, r0
 8023d86:	460e      	mov	r6, r1
 8023d88:	6884      	ldr	r4, [r0, #8]
 8023d8a:	b90b      	cbnz	r3, 8023d90 <_puts_r+0x10>
 8023d8c:	f7ff ffb0 	bl	8023cf0 <__sinit>
 8023d90:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 8023d92:	07db      	lsls	r3, r3, #31
 8023d94:	d405      	bmi.n	8023da2 <_puts_r+0x22>
 8023d96:	89a3      	ldrh	r3, [r4, #12]
 8023d98:	0598      	lsls	r0, r3, #22
 8023d9a:	d402      	bmi.n	8023da2 <_puts_r+0x22>
 8023d9c:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 8023d9e:	f000 fa0e 	bl	80241be <__retarget_lock_acquire_recursive>
 8023da2:	89a3      	ldrh	r3, [r4, #12]
 8023da4:	0719      	lsls	r1, r3, #28
 8023da6:	d502      	bpl.n	8023dae <_puts_r+0x2e>
 8023da8:	6923      	ldr	r3, [r4, #16]
 8023daa:	2b00      	cmp	r3, #0
 8023dac:	d135      	bne.n	8023e1a <_puts_r+0x9a>
 8023dae:	4621      	mov	r1, r4
 8023db0:	4628      	mov	r0, r5
 8023db2:	f000 f8e7 	bl	8023f84 <__swsetup_r>
 8023db6:	b380      	cbz	r0, 8023e1a <_puts_r+0x9a>
 8023db8:	f04f 35ff 	mov.w	r5, #4294967295
 8023dbc:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 8023dbe:	07da      	lsls	r2, r3, #31
 8023dc0:	d405      	bmi.n	8023dce <_puts_r+0x4e>
 8023dc2:	89a3      	ldrh	r3, [r4, #12]
 8023dc4:	059b      	lsls	r3, r3, #22
 8023dc6:	d402      	bmi.n	8023dce <_puts_r+0x4e>
 8023dc8:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 8023dca:	f000 f9f9 	bl	80241c0 <__retarget_lock_release_recursive>
 8023dce:	4628      	mov	r0, r5
 8023dd0:	bd70      	pop	{r4, r5, r6, pc}
 8023dd2:	2b00      	cmp	r3, #0
 8023dd4:	da04      	bge.n	8023de0 <_puts_r+0x60>
 8023dd6:	69a2      	ldr	r2, [r4, #24]
 8023dd8:	429a      	cmp	r2, r3
 8023dda:	dc17      	bgt.n	8023e0c <_puts_r+0x8c>
 8023ddc:	290a      	cmp	r1, #10
 8023dde:	d015      	beq.n	8023e0c <_puts_r+0x8c>
 8023de0:	6823      	ldr	r3, [r4, #0]
 8023de2:	1c5a      	adds	r2, r3, #1
 8023de4:	6022      	str	r2, [r4, #0]
 8023de6:	7019      	strb	r1, [r3, #0]
 8023de8:	68a3      	ldr	r3, [r4, #8]
 8023dea:	f816 1f01 	ldrb.w	r1, [r6, #1]!
 8023dee:	3b01      	subs	r3, #1
 8023df0:	60a3      	str	r3, [r4, #8]
 8023df2:	2900      	cmp	r1, #0
 8023df4:	d1ed      	bne.n	8023dd2 <_puts_r+0x52>
 8023df6:	2b00      	cmp	r3, #0
 8023df8:	da11      	bge.n	8023e1e <_puts_r+0x9e>
 8023dfa:	4622      	mov	r2, r4
 8023dfc:	210a      	movs	r1, #10
 8023dfe:	4628      	mov	r0, r5
 8023e00:	f000 f881 	bl	8023f06 <__swbuf_r>
 8023e04:	3001      	adds	r0, #1
 8023e06:	d0d7      	beq.n	8023db8 <_puts_r+0x38>
 8023e08:	250a      	movs	r5, #10
 8023e0a:	e7d7      	b.n	8023dbc <_puts_r+0x3c>
 8023e0c:	4622      	mov	r2, r4
 8023e0e:	4628      	mov	r0, r5
 8023e10:	f000 f879 	bl	8023f06 <__swbuf_r>
 8023e14:	3001      	adds	r0, #1
 8023e16:	d1e7      	bne.n	8023de8 <_puts_r+0x68>
 8023e18:	e7ce      	b.n	8023db8 <_puts_r+0x38>
 8023e1a:	3e01      	subs	r6, #1
 8023e1c:	e7e4      	b.n	8023de8 <_puts_r+0x68>
 8023e1e:	6823      	ldr	r3, [r4, #0]
 8023e20:	1c5a      	adds	r2, r3, #1
 8023e22:	6022      	str	r2, [r4, #0]
 8023e24:	220a      	movs	r2, #10
 8023e26:	701a      	strb	r2, [r3, #0]
 8023e28:	e7ee      	b.n	8023e08 <_puts_r+0x88>
	...

08023e2c <puts>:
 8023e2c:	4b02      	ldr	r3, [pc, #8]	@ (8023e38 <puts+0xc>)
 8023e2e:	4601      	mov	r1, r0
 8023e30:	6818      	ldr	r0, [r3, #0]
 8023e32:	f7ff bfa5 	b.w	8023d80 <_puts_r>
 8023e36:	bf00      	nop
 8023e38:	20000394 	.word	0x20000394

08023e3c <siprintf>:
 8023e3c:	b40e      	push	{r1, r2, r3}
 8023e3e:	b510      	push	{r4, lr}
 8023e40:	b09d      	sub	sp, #116	@ 0x74
 8023e42:	f06f 4100 	mvn.w	r1, #2147483648	@ 0x80000000
 8023e46:	2400      	movs	r4, #0
 8023e48:	ab1f      	add	r3, sp, #124	@ 0x7c
 8023e4a:	9002      	str	r0, [sp, #8]
 8023e4c:	9006      	str	r0, [sp, #24]
 8023e4e:	9107      	str	r1, [sp, #28]
 8023e50:	9104      	str	r1, [sp, #16]
 8023e52:	4809      	ldr	r0, [pc, #36]	@ (8023e78 <siprintf+0x3c>)
 8023e54:	4909      	ldr	r1, [pc, #36]	@ (8023e7c <siprintf+0x40>)
 8023e56:	f853 2b04 	ldr.w	r2, [r3], #4
 8023e5a:	9105      	str	r1, [sp, #20]
 8023e5c:	a902      	add	r1, sp, #8
 8023e5e:	6800      	ldr	r0, [r0, #0]
 8023e60:	9301      	str	r3, [sp, #4]
 8023e62:	941b      	str	r4, [sp, #108]	@ 0x6c
 8023e64:	f002 f97a 	bl	802615c <_svfiprintf_r>
 8023e68:	9b02      	ldr	r3, [sp, #8]
 8023e6a:	701c      	strb	r4, [r3, #0]
 8023e6c:	b01d      	add	sp, #116	@ 0x74
 8023e6e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8023e72:	b003      	add	sp, #12
 8023e74:	4770      	bx	lr
 8023e76:	bf00      	nop
 8023e78:	20000394 	.word	0x20000394
 8023e7c:	ffff0208 	.word	0xffff0208

08023e80 <__sread>:
 8023e80:	b510      	push	{r4, lr}
 8023e82:	460c      	mov	r4, r1
 8023e84:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8023e88:	f000 f93a 	bl	8024100 <_read_r>
 8023e8c:	2800      	cmp	r0, #0
 8023e8e:	bfab      	itete	ge
 8023e90:	6d63      	ldrge	r3, [r4, #84]	@ 0x54
 8023e92:	89a3      	ldrhlt	r3, [r4, #12]
 8023e94:	181b      	addge	r3, r3, r0
 8023e96:	f423 5380 	biclt.w	r3, r3, #4096	@ 0x1000
 8023e9a:	bfac      	ite	ge
 8023e9c:	6563      	strge	r3, [r4, #84]	@ 0x54
 8023e9e:	81a3      	strhlt	r3, [r4, #12]
 8023ea0:	bd10      	pop	{r4, pc}

08023ea2 <__swrite>:
 8023ea2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8023ea6:	461f      	mov	r7, r3
 8023ea8:	898b      	ldrh	r3, [r1, #12]
 8023eaa:	4605      	mov	r5, r0
 8023eac:	460c      	mov	r4, r1
 8023eae:	05db      	lsls	r3, r3, #23
 8023eb0:	4616      	mov	r6, r2
 8023eb2:	d505      	bpl.n	8023ec0 <__swrite+0x1e>
 8023eb4:	2302      	movs	r3, #2
 8023eb6:	2200      	movs	r2, #0
 8023eb8:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8023ebc:	f000 f90e 	bl	80240dc <_lseek_r>
 8023ec0:	89a3      	ldrh	r3, [r4, #12]
 8023ec2:	4632      	mov	r2, r6
 8023ec4:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8023ec8:	4628      	mov	r0, r5
 8023eca:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
 8023ece:	81a3      	strh	r3, [r4, #12]
 8023ed0:	463b      	mov	r3, r7
 8023ed2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8023ed6:	f000 b935 	b.w	8024144 <_write_r>

08023eda <__sseek>:
 8023eda:	b510      	push	{r4, lr}
 8023edc:	460c      	mov	r4, r1
 8023ede:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8023ee2:	f000 f8fb 	bl	80240dc <_lseek_r>
 8023ee6:	1c43      	adds	r3, r0, #1
 8023ee8:	89a3      	ldrh	r3, [r4, #12]
 8023eea:	bf15      	itete	ne
 8023eec:	6560      	strne	r0, [r4, #84]	@ 0x54
 8023eee:	f423 5380 	biceq.w	r3, r3, #4096	@ 0x1000
 8023ef2:	f443 5380 	orrne.w	r3, r3, #4096	@ 0x1000
 8023ef6:	81a3      	strheq	r3, [r4, #12]
 8023ef8:	bf18      	it	ne
 8023efa:	81a3      	strhne	r3, [r4, #12]
 8023efc:	bd10      	pop	{r4, pc}

08023efe <__sclose>:
 8023efe:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8023f02:	f000 b8db 	b.w	80240bc <_close_r>

08023f06 <__swbuf_r>:
 8023f06:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8023f08:	460e      	mov	r6, r1
 8023f0a:	4614      	mov	r4, r2
 8023f0c:	4605      	mov	r5, r0
 8023f0e:	b118      	cbz	r0, 8023f18 <__swbuf_r+0x12>
 8023f10:	6a03      	ldr	r3, [r0, #32]
 8023f12:	b90b      	cbnz	r3, 8023f18 <__swbuf_r+0x12>
 8023f14:	f7ff feec 	bl	8023cf0 <__sinit>
 8023f18:	69a3      	ldr	r3, [r4, #24]
 8023f1a:	60a3      	str	r3, [r4, #8]
 8023f1c:	89a3      	ldrh	r3, [r4, #12]
 8023f1e:	071a      	lsls	r2, r3, #28
 8023f20:	d501      	bpl.n	8023f26 <__swbuf_r+0x20>
 8023f22:	6923      	ldr	r3, [r4, #16]
 8023f24:	b943      	cbnz	r3, 8023f38 <__swbuf_r+0x32>
 8023f26:	4621      	mov	r1, r4
 8023f28:	4628      	mov	r0, r5
 8023f2a:	f000 f82b 	bl	8023f84 <__swsetup_r>
 8023f2e:	b118      	cbz	r0, 8023f38 <__swbuf_r+0x32>
 8023f30:	f04f 37ff 	mov.w	r7, #4294967295
 8023f34:	4638      	mov	r0, r7
 8023f36:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8023f38:	6823      	ldr	r3, [r4, #0]
 8023f3a:	b2f6      	uxtb	r6, r6
 8023f3c:	6922      	ldr	r2, [r4, #16]
 8023f3e:	4637      	mov	r7, r6
 8023f40:	1a98      	subs	r0, r3, r2
 8023f42:	6963      	ldr	r3, [r4, #20]
 8023f44:	4283      	cmp	r3, r0
 8023f46:	dc05      	bgt.n	8023f54 <__swbuf_r+0x4e>
 8023f48:	4621      	mov	r1, r4
 8023f4a:	4628      	mov	r0, r5
 8023f4c:	f7ff fe1c 	bl	8023b88 <_fflush_r>
 8023f50:	2800      	cmp	r0, #0
 8023f52:	d1ed      	bne.n	8023f30 <__swbuf_r+0x2a>
 8023f54:	68a3      	ldr	r3, [r4, #8]
 8023f56:	3b01      	subs	r3, #1
 8023f58:	60a3      	str	r3, [r4, #8]
 8023f5a:	6823      	ldr	r3, [r4, #0]
 8023f5c:	1c5a      	adds	r2, r3, #1
 8023f5e:	6022      	str	r2, [r4, #0]
 8023f60:	701e      	strb	r6, [r3, #0]
 8023f62:	1c43      	adds	r3, r0, #1
 8023f64:	6962      	ldr	r2, [r4, #20]
 8023f66:	429a      	cmp	r2, r3
 8023f68:	d004      	beq.n	8023f74 <__swbuf_r+0x6e>
 8023f6a:	89a3      	ldrh	r3, [r4, #12]
 8023f6c:	07db      	lsls	r3, r3, #31
 8023f6e:	d5e1      	bpl.n	8023f34 <__swbuf_r+0x2e>
 8023f70:	2e0a      	cmp	r6, #10
 8023f72:	d1df      	bne.n	8023f34 <__swbuf_r+0x2e>
 8023f74:	4621      	mov	r1, r4
 8023f76:	4628      	mov	r0, r5
 8023f78:	f7ff fe06 	bl	8023b88 <_fflush_r>
 8023f7c:	2800      	cmp	r0, #0
 8023f7e:	d0d9      	beq.n	8023f34 <__swbuf_r+0x2e>
 8023f80:	e7d6      	b.n	8023f30 <__swbuf_r+0x2a>
	...

08023f84 <__swsetup_r>:
 8023f84:	b538      	push	{r3, r4, r5, lr}
 8023f86:	4b29      	ldr	r3, [pc, #164]	@ (802402c <__swsetup_r+0xa8>)
 8023f88:	4605      	mov	r5, r0
 8023f8a:	460c      	mov	r4, r1
 8023f8c:	6818      	ldr	r0, [r3, #0]
 8023f8e:	b118      	cbz	r0, 8023f98 <__swsetup_r+0x14>
 8023f90:	6a03      	ldr	r3, [r0, #32]
 8023f92:	b90b      	cbnz	r3, 8023f98 <__swsetup_r+0x14>
 8023f94:	f7ff feac 	bl	8023cf0 <__sinit>
 8023f98:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8023f9c:	0719      	lsls	r1, r3, #28
 8023f9e:	d422      	bmi.n	8023fe6 <__swsetup_r+0x62>
 8023fa0:	06da      	lsls	r2, r3, #27
 8023fa2:	d407      	bmi.n	8023fb4 <__swsetup_r+0x30>
 8023fa4:	2209      	movs	r2, #9
 8023fa6:	602a      	str	r2, [r5, #0]
 8023fa8:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8023fac:	f04f 30ff 	mov.w	r0, #4294967295
 8023fb0:	81a3      	strh	r3, [r4, #12]
 8023fb2:	e033      	b.n	802401c <__swsetup_r+0x98>
 8023fb4:	0758      	lsls	r0, r3, #29
 8023fb6:	d512      	bpl.n	8023fde <__swsetup_r+0x5a>
 8023fb8:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 8023fba:	b141      	cbz	r1, 8023fce <__swsetup_r+0x4a>
 8023fbc:	f104 0344 	add.w	r3, r4, #68	@ 0x44
 8023fc0:	4299      	cmp	r1, r3
 8023fc2:	d002      	beq.n	8023fca <__swsetup_r+0x46>
 8023fc4:	4628      	mov	r0, r5
 8023fc6:	f000 ffa9 	bl	8024f1c <_free_r>
 8023fca:	2300      	movs	r3, #0
 8023fcc:	6363      	str	r3, [r4, #52]	@ 0x34
 8023fce:	89a3      	ldrh	r3, [r4, #12]
 8023fd0:	f023 0324 	bic.w	r3, r3, #36	@ 0x24
 8023fd4:	81a3      	strh	r3, [r4, #12]
 8023fd6:	2300      	movs	r3, #0
 8023fd8:	6063      	str	r3, [r4, #4]
 8023fda:	6923      	ldr	r3, [r4, #16]
 8023fdc:	6023      	str	r3, [r4, #0]
 8023fde:	89a3      	ldrh	r3, [r4, #12]
 8023fe0:	f043 0308 	orr.w	r3, r3, #8
 8023fe4:	81a3      	strh	r3, [r4, #12]
 8023fe6:	6923      	ldr	r3, [r4, #16]
 8023fe8:	b94b      	cbnz	r3, 8023ffe <__swsetup_r+0x7a>
 8023fea:	89a3      	ldrh	r3, [r4, #12]
 8023fec:	f403 7320 	and.w	r3, r3, #640	@ 0x280
 8023ff0:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8023ff4:	d003      	beq.n	8023ffe <__swsetup_r+0x7a>
 8023ff6:	4621      	mov	r1, r4
 8023ff8:	4628      	mov	r0, r5
 8023ffa:	f002 fb24 	bl	8026646 <__smakebuf_r>
 8023ffe:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8024002:	f013 0201 	ands.w	r2, r3, #1
 8024006:	d00a      	beq.n	802401e <__swsetup_r+0x9a>
 8024008:	2200      	movs	r2, #0
 802400a:	60a2      	str	r2, [r4, #8]
 802400c:	6962      	ldr	r2, [r4, #20]
 802400e:	4252      	negs	r2, r2
 8024010:	61a2      	str	r2, [r4, #24]
 8024012:	6922      	ldr	r2, [r4, #16]
 8024014:	b942      	cbnz	r2, 8024028 <__swsetup_r+0xa4>
 8024016:	f013 0080 	ands.w	r0, r3, #128	@ 0x80
 802401a:	d1c5      	bne.n	8023fa8 <__swsetup_r+0x24>
 802401c:	bd38      	pop	{r3, r4, r5, pc}
 802401e:	0799      	lsls	r1, r3, #30
 8024020:	bf58      	it	pl
 8024022:	6962      	ldrpl	r2, [r4, #20]
 8024024:	60a2      	str	r2, [r4, #8]
 8024026:	e7f4      	b.n	8024012 <__swsetup_r+0x8e>
 8024028:	2000      	movs	r0, #0
 802402a:	e7f7      	b.n	802401c <__swsetup_r+0x98>
 802402c:	20000394 	.word	0x20000394

08024030 <memmove>:
 8024030:	4288      	cmp	r0, r1
 8024032:	b510      	push	{r4, lr}
 8024034:	eb01 0402 	add.w	r4, r1, r2
 8024038:	d902      	bls.n	8024040 <memmove+0x10>
 802403a:	4284      	cmp	r4, r0
 802403c:	4623      	mov	r3, r4
 802403e:	d807      	bhi.n	8024050 <memmove+0x20>
 8024040:	1e43      	subs	r3, r0, #1
 8024042:	42a1      	cmp	r1, r4
 8024044:	d008      	beq.n	8024058 <memmove+0x28>
 8024046:	f811 2b01 	ldrb.w	r2, [r1], #1
 802404a:	f803 2f01 	strb.w	r2, [r3, #1]!
 802404e:	e7f8      	b.n	8024042 <memmove+0x12>
 8024050:	4402      	add	r2, r0
 8024052:	4601      	mov	r1, r0
 8024054:	428a      	cmp	r2, r1
 8024056:	d100      	bne.n	802405a <memmove+0x2a>
 8024058:	bd10      	pop	{r4, pc}
 802405a:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 802405e:	f802 4d01 	strb.w	r4, [r2, #-1]!
 8024062:	e7f7      	b.n	8024054 <memmove+0x24>

08024064 <memset>:
 8024064:	4402      	add	r2, r0
 8024066:	4603      	mov	r3, r0
 8024068:	4293      	cmp	r3, r2
 802406a:	d100      	bne.n	802406e <memset+0xa>
 802406c:	4770      	bx	lr
 802406e:	f803 1b01 	strb.w	r1, [r3], #1
 8024072:	e7f9      	b.n	8024068 <memset+0x4>

08024074 <strchr>:
 8024074:	b2c9      	uxtb	r1, r1
 8024076:	4603      	mov	r3, r0
 8024078:	4618      	mov	r0, r3
 802407a:	f813 2b01 	ldrb.w	r2, [r3], #1
 802407e:	b112      	cbz	r2, 8024086 <strchr+0x12>
 8024080:	428a      	cmp	r2, r1
 8024082:	d1f9      	bne.n	8024078 <strchr+0x4>
 8024084:	4770      	bx	lr
 8024086:	2900      	cmp	r1, #0
 8024088:	bf18      	it	ne
 802408a:	2000      	movne	r0, #0
 802408c:	4770      	bx	lr

0802408e <strncmp>:
 802408e:	b510      	push	{r4, lr}
 8024090:	b16a      	cbz	r2, 80240ae <strncmp+0x20>
 8024092:	3901      	subs	r1, #1
 8024094:	1884      	adds	r4, r0, r2
 8024096:	f810 2b01 	ldrb.w	r2, [r0], #1
 802409a:	f811 3f01 	ldrb.w	r3, [r1, #1]!
 802409e:	429a      	cmp	r2, r3
 80240a0:	d103      	bne.n	80240aa <strncmp+0x1c>
 80240a2:	42a0      	cmp	r0, r4
 80240a4:	d001      	beq.n	80240aa <strncmp+0x1c>
 80240a6:	2a00      	cmp	r2, #0
 80240a8:	d1f5      	bne.n	8024096 <strncmp+0x8>
 80240aa:	1ad0      	subs	r0, r2, r3
 80240ac:	bd10      	pop	{r4, pc}
 80240ae:	4610      	mov	r0, r2
 80240b0:	e7fc      	b.n	80240ac <strncmp+0x1e>
	...

080240b4 <_localeconv_r>:
 80240b4:	4800      	ldr	r0, [pc, #0]	@ (80240b8 <_localeconv_r+0x4>)
 80240b6:	4770      	bx	lr
 80240b8:	20000318 	.word	0x20000318

080240bc <_close_r>:
 80240bc:	b538      	push	{r3, r4, r5, lr}
 80240be:	2300      	movs	r3, #0
 80240c0:	4d05      	ldr	r5, [pc, #20]	@ (80240d8 <_close_r+0x1c>)
 80240c2:	4604      	mov	r4, r0
 80240c4:	4608      	mov	r0, r1
 80240c6:	602b      	str	r3, [r5, #0]
 80240c8:	f7e2 fb57 	bl	800677a <_close>
 80240cc:	1c43      	adds	r3, r0, #1
 80240ce:	d102      	bne.n	80240d6 <_close_r+0x1a>
 80240d0:	682b      	ldr	r3, [r5, #0]
 80240d2:	b103      	cbz	r3, 80240d6 <_close_r+0x1a>
 80240d4:	6023      	str	r3, [r4, #0]
 80240d6:	bd38      	pop	{r3, r4, r5, pc}
 80240d8:	20001fe4 	.word	0x20001fe4

080240dc <_lseek_r>:
 80240dc:	b538      	push	{r3, r4, r5, lr}
 80240de:	4604      	mov	r4, r0
 80240e0:	4d06      	ldr	r5, [pc, #24]	@ (80240fc <_lseek_r+0x20>)
 80240e2:	4608      	mov	r0, r1
 80240e4:	4611      	mov	r1, r2
 80240e6:	2200      	movs	r2, #0
 80240e8:	602a      	str	r2, [r5, #0]
 80240ea:	461a      	mov	r2, r3
 80240ec:	f7e2 fb6c 	bl	80067c8 <_lseek>
 80240f0:	1c43      	adds	r3, r0, #1
 80240f2:	d102      	bne.n	80240fa <_lseek_r+0x1e>
 80240f4:	682b      	ldr	r3, [r5, #0]
 80240f6:	b103      	cbz	r3, 80240fa <_lseek_r+0x1e>
 80240f8:	6023      	str	r3, [r4, #0]
 80240fa:	bd38      	pop	{r3, r4, r5, pc}
 80240fc:	20001fe4 	.word	0x20001fe4

08024100 <_read_r>:
 8024100:	b538      	push	{r3, r4, r5, lr}
 8024102:	4604      	mov	r4, r0
 8024104:	4d06      	ldr	r5, [pc, #24]	@ (8024120 <_read_r+0x20>)
 8024106:	4608      	mov	r0, r1
 8024108:	4611      	mov	r1, r2
 802410a:	2200      	movs	r2, #0
 802410c:	602a      	str	r2, [r5, #0]
 802410e:	461a      	mov	r2, r3
 8024110:	f7e2 fafa 	bl	8006708 <_read>
 8024114:	1c43      	adds	r3, r0, #1
 8024116:	d102      	bne.n	802411e <_read_r+0x1e>
 8024118:	682b      	ldr	r3, [r5, #0]
 802411a:	b103      	cbz	r3, 802411e <_read_r+0x1e>
 802411c:	6023      	str	r3, [r4, #0]
 802411e:	bd38      	pop	{r3, r4, r5, pc}
 8024120:	20001fe4 	.word	0x20001fe4

08024124 <_sbrk_r>:
 8024124:	b538      	push	{r3, r4, r5, lr}
 8024126:	2300      	movs	r3, #0
 8024128:	4d05      	ldr	r5, [pc, #20]	@ (8024140 <_sbrk_r+0x1c>)
 802412a:	4604      	mov	r4, r0
 802412c:	4608      	mov	r0, r1
 802412e:	602b      	str	r3, [r5, #0]
 8024130:	f7e2 fb58 	bl	80067e4 <_sbrk>
 8024134:	1c43      	adds	r3, r0, #1
 8024136:	d102      	bne.n	802413e <_sbrk_r+0x1a>
 8024138:	682b      	ldr	r3, [r5, #0]
 802413a:	b103      	cbz	r3, 802413e <_sbrk_r+0x1a>
 802413c:	6023      	str	r3, [r4, #0]
 802413e:	bd38      	pop	{r3, r4, r5, pc}
 8024140:	20001fe4 	.word	0x20001fe4

08024144 <_write_r>:
 8024144:	b538      	push	{r3, r4, r5, lr}
 8024146:	4604      	mov	r4, r0
 8024148:	4d06      	ldr	r5, [pc, #24]	@ (8024164 <_write_r+0x20>)
 802414a:	4608      	mov	r0, r1
 802414c:	4611      	mov	r1, r2
 802414e:	2200      	movs	r2, #0
 8024150:	602a      	str	r2, [r5, #0]
 8024152:	461a      	mov	r2, r3
 8024154:	f7e2 faf5 	bl	8006742 <_write>
 8024158:	1c43      	adds	r3, r0, #1
 802415a:	d102      	bne.n	8024162 <_write_r+0x1e>
 802415c:	682b      	ldr	r3, [r5, #0]
 802415e:	b103      	cbz	r3, 8024162 <_write_r+0x1e>
 8024160:	6023      	str	r3, [r4, #0]
 8024162:	bd38      	pop	{r3, r4, r5, pc}
 8024164:	20001fe4 	.word	0x20001fe4

08024168 <__errno>:
 8024168:	4b01      	ldr	r3, [pc, #4]	@ (8024170 <__errno+0x8>)
 802416a:	6818      	ldr	r0, [r3, #0]
 802416c:	4770      	bx	lr
 802416e:	bf00      	nop
 8024170:	20000394 	.word	0x20000394

08024174 <__libc_init_array>:
 8024174:	b570      	push	{r4, r5, r6, lr}
 8024176:	4d0d      	ldr	r5, [pc, #52]	@ (80241ac <__libc_init_array+0x38>)
 8024178:	2600      	movs	r6, #0
 802417a:	4c0d      	ldr	r4, [pc, #52]	@ (80241b0 <__libc_init_array+0x3c>)
 802417c:	1b64      	subs	r4, r4, r5
 802417e:	10a4      	asrs	r4, r4, #2
 8024180:	42a6      	cmp	r6, r4
 8024182:	d109      	bne.n	8024198 <__libc_init_array+0x24>
 8024184:	4d0b      	ldr	r5, [pc, #44]	@ (80241b4 <__libc_init_array+0x40>)
 8024186:	2600      	movs	r6, #0
 8024188:	4c0b      	ldr	r4, [pc, #44]	@ (80241b8 <__libc_init_array+0x44>)
 802418a:	f002 fb51 	bl	8026830 <_init>
 802418e:	1b64      	subs	r4, r4, r5
 8024190:	10a4      	asrs	r4, r4, #2
 8024192:	42a6      	cmp	r6, r4
 8024194:	d105      	bne.n	80241a2 <__libc_init_array+0x2e>
 8024196:	bd70      	pop	{r4, r5, r6, pc}
 8024198:	f855 3b04 	ldr.w	r3, [r5], #4
 802419c:	3601      	adds	r6, #1
 802419e:	4798      	blx	r3
 80241a0:	e7ee      	b.n	8024180 <__libc_init_array+0xc>
 80241a2:	f855 3b04 	ldr.w	r3, [r5], #4
 80241a6:	3601      	adds	r6, #1
 80241a8:	4798      	blx	r3
 80241aa:	e7f2      	b.n	8024192 <__libc_init_array+0x1e>
 80241ac:	0802acc8 	.word	0x0802acc8
 80241b0:	0802acc8 	.word	0x0802acc8
 80241b4:	0802acc8 	.word	0x0802acc8
 80241b8:	0802accc 	.word	0x0802accc

080241bc <__retarget_lock_init_recursive>:
 80241bc:	4770      	bx	lr

080241be <__retarget_lock_acquire_recursive>:
 80241be:	4770      	bx	lr

080241c0 <__retarget_lock_release_recursive>:
 80241c0:	4770      	bx	lr

080241c2 <strcpy>:
 80241c2:	4603      	mov	r3, r0
 80241c4:	f811 2b01 	ldrb.w	r2, [r1], #1
 80241c8:	f803 2b01 	strb.w	r2, [r3], #1
 80241cc:	2a00      	cmp	r2, #0
 80241ce:	d1f9      	bne.n	80241c4 <strcpy+0x2>
 80241d0:	4770      	bx	lr

080241d2 <memchr>:
 80241d2:	b2c9      	uxtb	r1, r1
 80241d4:	4603      	mov	r3, r0
 80241d6:	4402      	add	r2, r0
 80241d8:	b510      	push	{r4, lr}
 80241da:	4293      	cmp	r3, r2
 80241dc:	4618      	mov	r0, r3
 80241de:	d101      	bne.n	80241e4 <memchr+0x12>
 80241e0:	2000      	movs	r0, #0
 80241e2:	e003      	b.n	80241ec <memchr+0x1a>
 80241e4:	7804      	ldrb	r4, [r0, #0]
 80241e6:	3301      	adds	r3, #1
 80241e8:	428c      	cmp	r4, r1
 80241ea:	d1f6      	bne.n	80241da <memchr+0x8>
 80241ec:	bd10      	pop	{r4, pc}

080241ee <memcpy>:
 80241ee:	440a      	add	r2, r1
 80241f0:	1e43      	subs	r3, r0, #1
 80241f2:	4291      	cmp	r1, r2
 80241f4:	d100      	bne.n	80241f8 <memcpy+0xa>
 80241f6:	4770      	bx	lr
 80241f8:	b510      	push	{r4, lr}
 80241fa:	f811 4b01 	ldrb.w	r4, [r1], #1
 80241fe:	4291      	cmp	r1, r2
 8024200:	f803 4f01 	strb.w	r4, [r3, #1]!
 8024204:	d1f9      	bne.n	80241fa <memcpy+0xc>
 8024206:	bd10      	pop	{r4, pc}

08024208 <nan>:
 8024208:	2000      	movs	r0, #0
 802420a:	4901      	ldr	r1, [pc, #4]	@ (8024210 <nan+0x8>)
 802420c:	4770      	bx	lr
 802420e:	bf00      	nop
 8024210:	7ff80000 	.word	0x7ff80000

08024214 <nanf>:
 8024214:	4800      	ldr	r0, [pc, #0]	@ (8024218 <nanf+0x4>)
 8024216:	4770      	bx	lr
 8024218:	7fc00000 	.word	0x7fc00000

0802421c <__assert_func>:
 802421c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 802421e:	4614      	mov	r4, r2
 8024220:	461a      	mov	r2, r3
 8024222:	4b09      	ldr	r3, [pc, #36]	@ (8024248 <__assert_func+0x2c>)
 8024224:	4605      	mov	r5, r0
 8024226:	681b      	ldr	r3, [r3, #0]
 8024228:	68d8      	ldr	r0, [r3, #12]
 802422a:	b14c      	cbz	r4, 8024240 <__assert_func+0x24>
 802422c:	4b07      	ldr	r3, [pc, #28]	@ (802424c <__assert_func+0x30>)
 802422e:	9100      	str	r1, [sp, #0]
 8024230:	4907      	ldr	r1, [pc, #28]	@ (8024250 <__assert_func+0x34>)
 8024232:	e9cd 3401 	strd	r3, r4, [sp, #4]
 8024236:	462b      	mov	r3, r5
 8024238:	f002 f9ce 	bl	80265d8 <fiprintf>
 802423c:	f002 fa62 	bl	8026704 <abort>
 8024240:	4b04      	ldr	r3, [pc, #16]	@ (8024254 <__assert_func+0x38>)
 8024242:	461c      	mov	r4, r3
 8024244:	e7f3      	b.n	802422e <__assert_func+0x12>
 8024246:	bf00      	nop
 8024248:	20000394 	.word	0x20000394
 802424c:	0802a8f2 	.word	0x0802a8f2
 8024250:	0802a8ff 	.word	0x0802a8ff
 8024254:	0802a92d 	.word	0x0802a92d

08024258 <quorem>:
 8024258:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802425c:	6903      	ldr	r3, [r0, #16]
 802425e:	4607      	mov	r7, r0
 8024260:	690c      	ldr	r4, [r1, #16]
 8024262:	42a3      	cmp	r3, r4
 8024264:	f2c0 8083 	blt.w	802436e <quorem+0x116>
 8024268:	3c01      	subs	r4, #1
 802426a:	f100 0514 	add.w	r5, r0, #20
 802426e:	f101 0814 	add.w	r8, r1, #20
 8024272:	00a3      	lsls	r3, r4, #2
 8024274:	f855 2024 	ldr.w	r2, [r5, r4, lsl #2]
 8024278:	eb08 0984 	add.w	r9, r8, r4, lsl #2
 802427c:	9300      	str	r3, [sp, #0]
 802427e:	eb05 0384 	add.w	r3, r5, r4, lsl #2
 8024282:	9301      	str	r3, [sp, #4]
 8024284:	f858 3024 	ldr.w	r3, [r8, r4, lsl #2]
 8024288:	3301      	adds	r3, #1
 802428a:	429a      	cmp	r2, r3
 802428c:	fbb2 f6f3 	udiv	r6, r2, r3
 8024290:	d331      	bcc.n	80242f6 <quorem+0x9e>
 8024292:	f04f 0a00 	mov.w	sl, #0
 8024296:	46c4      	mov	ip, r8
 8024298:	46ae      	mov	lr, r5
 802429a:	46d3      	mov	fp, sl
 802429c:	f85c 3b04 	ldr.w	r3, [ip], #4
 80242a0:	b298      	uxth	r0, r3
 80242a2:	45e1      	cmp	r9, ip
 80242a4:	ea4f 4313 	mov.w	r3, r3, lsr #16
 80242a8:	fb06 a000 	mla	r0, r6, r0, sl
 80242ac:	ea4f 4210 	mov.w	r2, r0, lsr #16
 80242b0:	b280      	uxth	r0, r0
 80242b2:	fb06 2303 	mla	r3, r6, r3, r2
 80242b6:	f8de 2000 	ldr.w	r2, [lr]
 80242ba:	b292      	uxth	r2, r2
 80242bc:	ea4f 4a13 	mov.w	sl, r3, lsr #16
 80242c0:	eba2 0200 	sub.w	r2, r2, r0
 80242c4:	b29b      	uxth	r3, r3
 80242c6:	f8de 0000 	ldr.w	r0, [lr]
 80242ca:	445a      	add	r2, fp
 80242cc:	ebc3 4322 	rsb	r3, r3, r2, asr #16
 80242d0:	b292      	uxth	r2, r2
 80242d2:	eb03 4310 	add.w	r3, r3, r0, lsr #16
 80242d6:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
 80242da:	ea4f 4b23 	mov.w	fp, r3, asr #16
 80242de:	f84e 2b04 	str.w	r2, [lr], #4
 80242e2:	d2db      	bcs.n	802429c <quorem+0x44>
 80242e4:	9b00      	ldr	r3, [sp, #0]
 80242e6:	58eb      	ldr	r3, [r5, r3]
 80242e8:	b92b      	cbnz	r3, 80242f6 <quorem+0x9e>
 80242ea:	9b01      	ldr	r3, [sp, #4]
 80242ec:	3b04      	subs	r3, #4
 80242ee:	429d      	cmp	r5, r3
 80242f0:	461a      	mov	r2, r3
 80242f2:	d330      	bcc.n	8024356 <quorem+0xfe>
 80242f4:	613c      	str	r4, [r7, #16]
 80242f6:	4638      	mov	r0, r7
 80242f8:	f001 fc62 	bl	8025bc0 <__mcmp>
 80242fc:	2800      	cmp	r0, #0
 80242fe:	db26      	blt.n	802434e <quorem+0xf6>
 8024300:	4629      	mov	r1, r5
 8024302:	2000      	movs	r0, #0
 8024304:	f858 2b04 	ldr.w	r2, [r8], #4
 8024308:	f8d1 c000 	ldr.w	ip, [r1]
 802430c:	fa1f fe82 	uxth.w	lr, r2
 8024310:	45c1      	cmp	r9, r8
 8024312:	fa1f f38c 	uxth.w	r3, ip
 8024316:	ea4f 4212 	mov.w	r2, r2, lsr #16
 802431a:	eba3 030e 	sub.w	r3, r3, lr
 802431e:	4403      	add	r3, r0
 8024320:	ebc2 4223 	rsb	r2, r2, r3, asr #16
 8024324:	b29b      	uxth	r3, r3
 8024326:	eb02 421c 	add.w	r2, r2, ip, lsr #16
 802432a:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 802432e:	ea4f 4022 	mov.w	r0, r2, asr #16
 8024332:	f841 3b04 	str.w	r3, [r1], #4
 8024336:	d2e5      	bcs.n	8024304 <quorem+0xac>
 8024338:	f855 2024 	ldr.w	r2, [r5, r4, lsl #2]
 802433c:	eb05 0384 	add.w	r3, r5, r4, lsl #2
 8024340:	b922      	cbnz	r2, 802434c <quorem+0xf4>
 8024342:	3b04      	subs	r3, #4
 8024344:	429d      	cmp	r5, r3
 8024346:	461a      	mov	r2, r3
 8024348:	d30b      	bcc.n	8024362 <quorem+0x10a>
 802434a:	613c      	str	r4, [r7, #16]
 802434c:	3601      	adds	r6, #1
 802434e:	4630      	mov	r0, r6
 8024350:	b003      	add	sp, #12
 8024352:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8024356:	6812      	ldr	r2, [r2, #0]
 8024358:	3b04      	subs	r3, #4
 802435a:	2a00      	cmp	r2, #0
 802435c:	d1ca      	bne.n	80242f4 <quorem+0x9c>
 802435e:	3c01      	subs	r4, #1
 8024360:	e7c5      	b.n	80242ee <quorem+0x96>
 8024362:	6812      	ldr	r2, [r2, #0]
 8024364:	3b04      	subs	r3, #4
 8024366:	2a00      	cmp	r2, #0
 8024368:	d1ef      	bne.n	802434a <quorem+0xf2>
 802436a:	3c01      	subs	r4, #1
 802436c:	e7ea      	b.n	8024344 <quorem+0xec>
 802436e:	2000      	movs	r0, #0
 8024370:	e7ee      	b.n	8024350 <quorem+0xf8>
 8024372:	0000      	movs	r0, r0
 8024374:	0000      	movs	r0, r0
	...

08024378 <_dtoa_r>:
 8024378:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802437c:	4614      	mov	r4, r2
 802437e:	b097      	sub	sp, #92	@ 0x5c
 8024380:	461d      	mov	r5, r3
 8024382:	69c7      	ldr	r7, [r0, #28]
 8024384:	4681      	mov	r9, r0
 8024386:	9e23      	ldr	r6, [sp, #140]	@ 0x8c
 8024388:	e9cd 4506 	strd	r4, r5, [sp, #24]
 802438c:	b97f      	cbnz	r7, 80243ae <_dtoa_r+0x36>
 802438e:	2010      	movs	r0, #16
 8024390:	f7fd fe1a 	bl	8021fc8 <malloc>
 8024394:	4602      	mov	r2, r0
 8024396:	f8c9 001c 	str.w	r0, [r9, #28]
 802439a:	b920      	cbnz	r0, 80243a6 <_dtoa_r+0x2e>
 802439c:	4baa      	ldr	r3, [pc, #680]	@ (8024648 <_dtoa_r+0x2d0>)
 802439e:	21ef      	movs	r1, #239	@ 0xef
 80243a0:	48aa      	ldr	r0, [pc, #680]	@ (802464c <_dtoa_r+0x2d4>)
 80243a2:	f7ff ff3b 	bl	802421c <__assert_func>
 80243a6:	e9c0 7701 	strd	r7, r7, [r0, #4]
 80243aa:	6007      	str	r7, [r0, #0]
 80243ac:	60c7      	str	r7, [r0, #12]
 80243ae:	f8d9 301c 	ldr.w	r3, [r9, #28]
 80243b2:	6819      	ldr	r1, [r3, #0]
 80243b4:	b159      	cbz	r1, 80243ce <_dtoa_r+0x56>
 80243b6:	685a      	ldr	r2, [r3, #4]
 80243b8:	2301      	movs	r3, #1
 80243ba:	4648      	mov	r0, r9
 80243bc:	4093      	lsls	r3, r2
 80243be:	604a      	str	r2, [r1, #4]
 80243c0:	608b      	str	r3, [r1, #8]
 80243c2:	f001 f97d 	bl	80256c0 <_Bfree>
 80243c6:	f8d9 301c 	ldr.w	r3, [r9, #28]
 80243ca:	2200      	movs	r2, #0
 80243cc:	601a      	str	r2, [r3, #0]
 80243ce:	1e2b      	subs	r3, r5, #0
 80243d0:	bfb7      	itett	lt
 80243d2:	f023 4300 	biclt.w	r3, r3, #2147483648	@ 0x80000000
 80243d6:	2300      	movge	r3, #0
 80243d8:	2201      	movlt	r2, #1
 80243da:	9307      	strlt	r3, [sp, #28]
 80243dc:	bfa8      	it	ge
 80243de:	6033      	strge	r3, [r6, #0]
 80243e0:	f8dd 801c 	ldr.w	r8, [sp, #28]
 80243e4:	4b9a      	ldr	r3, [pc, #616]	@ (8024650 <_dtoa_r+0x2d8>)
 80243e6:	bfb8      	it	lt
 80243e8:	6032      	strlt	r2, [r6, #0]
 80243ea:	ea33 0308 	bics.w	r3, r3, r8
 80243ee:	d112      	bne.n	8024416 <_dtoa_r+0x9e>
 80243f0:	f242 730f 	movw	r3, #9999	@ 0x270f
 80243f4:	9a22      	ldr	r2, [sp, #136]	@ 0x88
 80243f6:	6013      	str	r3, [r2, #0]
 80243f8:	f3c8 0313 	ubfx	r3, r8, #0, #20
 80243fc:	4323      	orrs	r3, r4
 80243fe:	f000 855b 	beq.w	8024eb8 <_dtoa_r+0xb40>
 8024402:	9b24      	ldr	r3, [sp, #144]	@ 0x90
 8024404:	f8df a25c 	ldr.w	sl, [pc, #604]	@ 8024664 <_dtoa_r+0x2ec>
 8024408:	2b00      	cmp	r3, #0
 802440a:	f000 855d 	beq.w	8024ec8 <_dtoa_r+0xb50>
 802440e:	f10a 0303 	add.w	r3, sl, #3
 8024412:	f000 bd57 	b.w	8024ec4 <_dtoa_r+0xb4c>
 8024416:	ed9d 7b06 	vldr	d7, [sp, #24]
 802441a:	2200      	movs	r2, #0
 802441c:	2300      	movs	r3, #0
 802441e:	ec51 0b17 	vmov	r0, r1, d7
 8024422:	ed8d 7b0c 	vstr	d7, [sp, #48]	@ 0x30
 8024426:	f7dc fb5d 	bl	8000ae4 <__aeabi_dcmpeq>
 802442a:	4607      	mov	r7, r0
 802442c:	b158      	cbz	r0, 8024446 <_dtoa_r+0xce>
 802442e:	2301      	movs	r3, #1
 8024430:	9a22      	ldr	r2, [sp, #136]	@ 0x88
 8024432:	6013      	str	r3, [r2, #0]
 8024434:	9b24      	ldr	r3, [sp, #144]	@ 0x90
 8024436:	b113      	cbz	r3, 802443e <_dtoa_r+0xc6>
 8024438:	4b86      	ldr	r3, [pc, #536]	@ (8024654 <_dtoa_r+0x2dc>)
 802443a:	9a24      	ldr	r2, [sp, #144]	@ 0x90
 802443c:	6013      	str	r3, [r2, #0]
 802443e:	f8df a228 	ldr.w	sl, [pc, #552]	@ 8024668 <_dtoa_r+0x2f0>
 8024442:	f000 bd41 	b.w	8024ec8 <_dtoa_r+0xb50>
 8024446:	ab14      	add	r3, sp, #80	@ 0x50
 8024448:	f3c8 560a 	ubfx	r6, r8, #20, #11
 802444c:	4648      	mov	r0, r9
 802444e:	9301      	str	r3, [sp, #4]
 8024450:	ab15      	add	r3, sp, #84	@ 0x54
 8024452:	9300      	str	r3, [sp, #0]
 8024454:	e9dd 230c 	ldrd	r2, r3, [sp, #48]	@ 0x30
 8024458:	f001 fcd0 	bl	8025dfc <__d2b>
 802445c:	9003      	str	r0, [sp, #12]
 802445e:	2e00      	cmp	r6, #0
 8024460:	d075      	beq.n	802454e <_dtoa_r+0x1d6>
 8024462:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 8024464:	f2a6 36ff 	subw	r6, r6, #1023	@ 0x3ff
 8024468:	9712      	str	r7, [sp, #72]	@ 0x48
 802446a:	f3c3 0313 	ubfx	r3, r3, #0, #20
 802446e:	f043 537f 	orr.w	r3, r3, #1069547520	@ 0x3fc00000
 8024472:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	@ 0x30
 8024476:	f443 1340 	orr.w	r3, r3, #3145728	@ 0x300000
 802447a:	4619      	mov	r1, r3
 802447c:	2200      	movs	r2, #0
 802447e:	4b76      	ldr	r3, [pc, #472]	@ (8024658 <_dtoa_r+0x2e0>)
 8024480:	f7db ff10 	bl	80002a4 <__aeabi_dsub>
 8024484:	a36a      	add	r3, pc, #424	@ (adr r3, 8024630 <_dtoa_r+0x2b8>)
 8024486:	e9d3 2300 	ldrd	r2, r3, [r3]
 802448a:	f7dc f8c3 	bl	8000614 <__aeabi_dmul>
 802448e:	a36a      	add	r3, pc, #424	@ (adr r3, 8024638 <_dtoa_r+0x2c0>)
 8024490:	e9d3 2300 	ldrd	r2, r3, [r3]
 8024494:	f7db ff08 	bl	80002a8 <__adddf3>
 8024498:	4604      	mov	r4, r0
 802449a:	460d      	mov	r5, r1
 802449c:	4630      	mov	r0, r6
 802449e:	f7dc f84f 	bl	8000540 <__aeabi_i2d>
 80244a2:	a367      	add	r3, pc, #412	@ (adr r3, 8024640 <_dtoa_r+0x2c8>)
 80244a4:	e9d3 2300 	ldrd	r2, r3, [r3]
 80244a8:	f7dc f8b4 	bl	8000614 <__aeabi_dmul>
 80244ac:	4602      	mov	r2, r0
 80244ae:	460b      	mov	r3, r1
 80244b0:	4620      	mov	r0, r4
 80244b2:	4629      	mov	r1, r5
 80244b4:	f7db fef8 	bl	80002a8 <__adddf3>
 80244b8:	4604      	mov	r4, r0
 80244ba:	460d      	mov	r5, r1
 80244bc:	f7dc fb5a 	bl	8000b74 <__aeabi_d2iz>
 80244c0:	2200      	movs	r2, #0
 80244c2:	4607      	mov	r7, r0
 80244c4:	2300      	movs	r3, #0
 80244c6:	4620      	mov	r0, r4
 80244c8:	4629      	mov	r1, r5
 80244ca:	f7dc fb15 	bl	8000af8 <__aeabi_dcmplt>
 80244ce:	b140      	cbz	r0, 80244e2 <_dtoa_r+0x16a>
 80244d0:	4638      	mov	r0, r7
 80244d2:	f7dc f835 	bl	8000540 <__aeabi_i2d>
 80244d6:	4622      	mov	r2, r4
 80244d8:	462b      	mov	r3, r5
 80244da:	f7dc fb03 	bl	8000ae4 <__aeabi_dcmpeq>
 80244de:	b900      	cbnz	r0, 80244e2 <_dtoa_r+0x16a>
 80244e0:	3f01      	subs	r7, #1
 80244e2:	2f16      	cmp	r7, #22
 80244e4:	d853      	bhi.n	802458e <_dtoa_r+0x216>
 80244e6:	4b5d      	ldr	r3, [pc, #372]	@ (802465c <_dtoa_r+0x2e4>)
 80244e8:	eb03 03c7 	add.w	r3, r3, r7, lsl #3
 80244ec:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	@ 0x30
 80244f0:	e9d3 2300 	ldrd	r2, r3, [r3]
 80244f4:	f7dc fb00 	bl	8000af8 <__aeabi_dcmplt>
 80244f8:	2800      	cmp	r0, #0
 80244fa:	d04a      	beq.n	8024592 <_dtoa_r+0x21a>
 80244fc:	3f01      	subs	r7, #1
 80244fe:	2300      	movs	r3, #0
 8024500:	930f      	str	r3, [sp, #60]	@ 0x3c
 8024502:	9b14      	ldr	r3, [sp, #80]	@ 0x50
 8024504:	1b9b      	subs	r3, r3, r6
 8024506:	1e5a      	subs	r2, r3, #1
 8024508:	bf4c      	ite	mi
 802450a:	f1c3 0301 	rsbmi	r3, r3, #1
 802450e:	2300      	movpl	r3, #0
 8024510:	9209      	str	r2, [sp, #36]	@ 0x24
 8024512:	bf45      	ittet	mi
 8024514:	9304      	strmi	r3, [sp, #16]
 8024516:	2300      	movmi	r3, #0
 8024518:	9304      	strpl	r3, [sp, #16]
 802451a:	9309      	strmi	r3, [sp, #36]	@ 0x24
 802451c:	2f00      	cmp	r7, #0
 802451e:	db3a      	blt.n	8024596 <_dtoa_r+0x21e>
 8024520:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8024522:	970e      	str	r7, [sp, #56]	@ 0x38
 8024524:	443b      	add	r3, r7
 8024526:	9309      	str	r3, [sp, #36]	@ 0x24
 8024528:	2300      	movs	r3, #0
 802452a:	930a      	str	r3, [sp, #40]	@ 0x28
 802452c:	9b20      	ldr	r3, [sp, #128]	@ 0x80
 802452e:	2b09      	cmp	r3, #9
 8024530:	d864      	bhi.n	80245fc <_dtoa_r+0x284>
 8024532:	2b05      	cmp	r3, #5
 8024534:	bfc5      	ittet	gt
 8024536:	3b04      	subgt	r3, #4
 8024538:	2400      	movgt	r4, #0
 802453a:	2401      	movle	r4, #1
 802453c:	9320      	strgt	r3, [sp, #128]	@ 0x80
 802453e:	9b20      	ldr	r3, [sp, #128]	@ 0x80
 8024540:	3b02      	subs	r3, #2
 8024542:	2b03      	cmp	r3, #3
 8024544:	d866      	bhi.n	8024614 <_dtoa_r+0x29c>
 8024546:	e8df f003 	tbb	[pc, r3]
 802454a:	5755      	.short	0x5755
 802454c:	2e3a      	.short	0x2e3a
 802454e:	e9dd 6314 	ldrd	r6, r3, [sp, #80]	@ 0x50
 8024552:	441e      	add	r6, r3
 8024554:	f206 4332 	addw	r3, r6, #1074	@ 0x432
 8024558:	2b20      	cmp	r3, #32
 802455a:	bfc9      	itett	gt
 802455c:	f1c3 0340 	rsbgt	r3, r3, #64	@ 0x40
 8024560:	f1c3 0320 	rsble	r3, r3, #32
 8024564:	fa08 f803 	lslgt.w	r8, r8, r3
 8024568:	f206 4312 	addwgt	r3, r6, #1042	@ 0x412
 802456c:	bfd8      	it	le
 802456e:	fa04 f003 	lslle.w	r0, r4, r3
 8024572:	f106 36ff 	add.w	r6, r6, #4294967295
 8024576:	bfc4      	itt	gt
 8024578:	fa24 f303 	lsrgt.w	r3, r4, r3
 802457c:	ea48 0003 	orrgt.w	r0, r8, r3
 8024580:	f7db ffce 	bl	8000520 <__aeabi_ui2d>
 8024584:	2201      	movs	r2, #1
 8024586:	f1a1 73f8 	sub.w	r3, r1, #32505856	@ 0x1f00000
 802458a:	9212      	str	r2, [sp, #72]	@ 0x48
 802458c:	e775      	b.n	802447a <_dtoa_r+0x102>
 802458e:	2301      	movs	r3, #1
 8024590:	e7b6      	b.n	8024500 <_dtoa_r+0x188>
 8024592:	900f      	str	r0, [sp, #60]	@ 0x3c
 8024594:	e7b5      	b.n	8024502 <_dtoa_r+0x18a>
 8024596:	9b04      	ldr	r3, [sp, #16]
 8024598:	1bdb      	subs	r3, r3, r7
 802459a:	9304      	str	r3, [sp, #16]
 802459c:	427b      	negs	r3, r7
 802459e:	930a      	str	r3, [sp, #40]	@ 0x28
 80245a0:	2300      	movs	r3, #0
 80245a2:	930e      	str	r3, [sp, #56]	@ 0x38
 80245a4:	e7c2      	b.n	802452c <_dtoa_r+0x1b4>
 80245a6:	2301      	movs	r3, #1
 80245a8:	930b      	str	r3, [sp, #44]	@ 0x2c
 80245aa:	9b21      	ldr	r3, [sp, #132]	@ 0x84
 80245ac:	eb07 0b03 	add.w	fp, r7, r3
 80245b0:	f10b 0301 	add.w	r3, fp, #1
 80245b4:	2b01      	cmp	r3, #1
 80245b6:	9308      	str	r3, [sp, #32]
 80245b8:	bfb8      	it	lt
 80245ba:	2301      	movlt	r3, #1
 80245bc:	e006      	b.n	80245cc <_dtoa_r+0x254>
 80245be:	2301      	movs	r3, #1
 80245c0:	930b      	str	r3, [sp, #44]	@ 0x2c
 80245c2:	9b21      	ldr	r3, [sp, #132]	@ 0x84
 80245c4:	2b00      	cmp	r3, #0
 80245c6:	dd28      	ble.n	802461a <_dtoa_r+0x2a2>
 80245c8:	469b      	mov	fp, r3
 80245ca:	9308      	str	r3, [sp, #32]
 80245cc:	f8d9 001c 	ldr.w	r0, [r9, #28]
 80245d0:	2100      	movs	r1, #0
 80245d2:	2204      	movs	r2, #4
 80245d4:	f102 0514 	add.w	r5, r2, #20
 80245d8:	429d      	cmp	r5, r3
 80245da:	d926      	bls.n	802462a <_dtoa_r+0x2b2>
 80245dc:	6041      	str	r1, [r0, #4]
 80245de:	4648      	mov	r0, r9
 80245e0:	f001 f82e 	bl	8025640 <_Balloc>
 80245e4:	4682      	mov	sl, r0
 80245e6:	2800      	cmp	r0, #0
 80245e8:	d140      	bne.n	802466c <_dtoa_r+0x2f4>
 80245ea:	4b1d      	ldr	r3, [pc, #116]	@ (8024660 <_dtoa_r+0x2e8>)
 80245ec:	4602      	mov	r2, r0
 80245ee:	f240 11af 	movw	r1, #431	@ 0x1af
 80245f2:	e6d5      	b.n	80243a0 <_dtoa_r+0x28>
 80245f4:	2300      	movs	r3, #0
 80245f6:	e7e3      	b.n	80245c0 <_dtoa_r+0x248>
 80245f8:	2300      	movs	r3, #0
 80245fa:	e7d5      	b.n	80245a8 <_dtoa_r+0x230>
 80245fc:	2401      	movs	r4, #1
 80245fe:	2300      	movs	r3, #0
 8024600:	940b      	str	r4, [sp, #44]	@ 0x2c
 8024602:	9320      	str	r3, [sp, #128]	@ 0x80
 8024604:	f04f 3bff 	mov.w	fp, #4294967295
 8024608:	2200      	movs	r2, #0
 802460a:	2312      	movs	r3, #18
 802460c:	f8cd b020 	str.w	fp, [sp, #32]
 8024610:	9221      	str	r2, [sp, #132]	@ 0x84
 8024612:	e7db      	b.n	80245cc <_dtoa_r+0x254>
 8024614:	2301      	movs	r3, #1
 8024616:	930b      	str	r3, [sp, #44]	@ 0x2c
 8024618:	e7f4      	b.n	8024604 <_dtoa_r+0x28c>
 802461a:	f04f 0b01 	mov.w	fp, #1
 802461e:	465b      	mov	r3, fp
 8024620:	f8cd b020 	str.w	fp, [sp, #32]
 8024624:	f8cd b084 	str.w	fp, [sp, #132]	@ 0x84
 8024628:	e7d0      	b.n	80245cc <_dtoa_r+0x254>
 802462a:	3101      	adds	r1, #1
 802462c:	0052      	lsls	r2, r2, #1
 802462e:	e7d1      	b.n	80245d4 <_dtoa_r+0x25c>
 8024630:	636f4361 	.word	0x636f4361
 8024634:	3fd287a7 	.word	0x3fd287a7
 8024638:	8b60c8b3 	.word	0x8b60c8b3
 802463c:	3fc68a28 	.word	0x3fc68a28
 8024640:	509f79fb 	.word	0x509f79fb
 8024644:	3fd34413 	.word	0x3fd34413
 8024648:	0802a840 	.word	0x0802a840
 802464c:	0802a93b 	.word	0x0802a93b
 8024650:	7ff00000 	.word	0x7ff00000
 8024654:	0802a8c2 	.word	0x0802a8c2
 8024658:	3ff80000 	.word	0x3ff80000
 802465c:	0802abf8 	.word	0x0802abf8
 8024660:	0802a993 	.word	0x0802a993
 8024664:	0802a937 	.word	0x0802a937
 8024668:	0802a8c1 	.word	0x0802a8c1
 802466c:	f8d9 301c 	ldr.w	r3, [r9, #28]
 8024670:	6018      	str	r0, [r3, #0]
 8024672:	9b08      	ldr	r3, [sp, #32]
 8024674:	2b0e      	cmp	r3, #14
 8024676:	f200 80a1 	bhi.w	80247bc <_dtoa_r+0x444>
 802467a:	2c00      	cmp	r4, #0
 802467c:	f000 809e 	beq.w	80247bc <_dtoa_r+0x444>
 8024680:	2f00      	cmp	r7, #0
 8024682:	dd33      	ble.n	80246ec <_dtoa_r+0x374>
 8024684:	f007 020f 	and.w	r2, r7, #15
 8024688:	4b9b      	ldr	r3, [pc, #620]	@ (80248f8 <_dtoa_r+0x580>)
 802468a:	05f8      	lsls	r0, r7, #23
 802468c:	ea4f 1427 	mov.w	r4, r7, asr #4
 8024690:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8024694:	ed93 7b00 	vldr	d7, [r3]
 8024698:	ed8d 7b10 	vstr	d7, [sp, #64]	@ 0x40
 802469c:	d516      	bpl.n	80246cc <_dtoa_r+0x354>
 802469e:	4b97      	ldr	r3, [pc, #604]	@ (80248fc <_dtoa_r+0x584>)
 80246a0:	f004 040f 	and.w	r4, r4, #15
 80246a4:	2603      	movs	r6, #3
 80246a6:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
 80246aa:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	@ 0x30
 80246ae:	f7dc f8db 	bl	8000868 <__aeabi_ddiv>
 80246b2:	e9cd 0106 	strd	r0, r1, [sp, #24]
 80246b6:	4d91      	ldr	r5, [pc, #580]	@ (80248fc <_dtoa_r+0x584>)
 80246b8:	b954      	cbnz	r4, 80246d0 <_dtoa_r+0x358>
 80246ba:	e9dd 2310 	ldrd	r2, r3, [sp, #64]	@ 0x40
 80246be:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 80246c2:	f7dc f8d1 	bl	8000868 <__aeabi_ddiv>
 80246c6:	e9cd 0106 	strd	r0, r1, [sp, #24]
 80246ca:	e028      	b.n	802471e <_dtoa_r+0x3a6>
 80246cc:	2602      	movs	r6, #2
 80246ce:	e7f2      	b.n	80246b6 <_dtoa_r+0x33e>
 80246d0:	07e1      	lsls	r1, r4, #31
 80246d2:	d508      	bpl.n	80246e6 <_dtoa_r+0x36e>
 80246d4:	3601      	adds	r6, #1
 80246d6:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	@ 0x40
 80246da:	e9d5 2300 	ldrd	r2, r3, [r5]
 80246de:	f7db ff99 	bl	8000614 <__aeabi_dmul>
 80246e2:	e9cd 0110 	strd	r0, r1, [sp, #64]	@ 0x40
 80246e6:	1064      	asrs	r4, r4, #1
 80246e8:	3508      	adds	r5, #8
 80246ea:	e7e5      	b.n	80246b8 <_dtoa_r+0x340>
 80246ec:	f000 80af 	beq.w	802484e <_dtoa_r+0x4d6>
 80246f0:	427c      	negs	r4, r7
 80246f2:	4b81      	ldr	r3, [pc, #516]	@ (80248f8 <_dtoa_r+0x580>)
 80246f4:	4d81      	ldr	r5, [pc, #516]	@ (80248fc <_dtoa_r+0x584>)
 80246f6:	2602      	movs	r6, #2
 80246f8:	f004 020f 	and.w	r2, r4, #15
 80246fc:	1124      	asrs	r4, r4, #4
 80246fe:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8024702:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	@ 0x30
 8024706:	e9d3 2300 	ldrd	r2, r3, [r3]
 802470a:	f7db ff83 	bl	8000614 <__aeabi_dmul>
 802470e:	2300      	movs	r3, #0
 8024710:	e9cd 0106 	strd	r0, r1, [sp, #24]
 8024714:	2c00      	cmp	r4, #0
 8024716:	f040 808f 	bne.w	8024838 <_dtoa_r+0x4c0>
 802471a:	2b00      	cmp	r3, #0
 802471c:	d1d3      	bne.n	80246c6 <_dtoa_r+0x34e>
 802471e:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 8024720:	e9dd 4506 	ldrd	r4, r5, [sp, #24]
 8024724:	2b00      	cmp	r3, #0
 8024726:	f000 8094 	beq.w	8024852 <_dtoa_r+0x4da>
 802472a:	2200      	movs	r2, #0
 802472c:	4b74      	ldr	r3, [pc, #464]	@ (8024900 <_dtoa_r+0x588>)
 802472e:	4620      	mov	r0, r4
 8024730:	4629      	mov	r1, r5
 8024732:	f7dc f9e1 	bl	8000af8 <__aeabi_dcmplt>
 8024736:	2800      	cmp	r0, #0
 8024738:	f000 808b 	beq.w	8024852 <_dtoa_r+0x4da>
 802473c:	9b08      	ldr	r3, [sp, #32]
 802473e:	2b00      	cmp	r3, #0
 8024740:	f000 8087 	beq.w	8024852 <_dtoa_r+0x4da>
 8024744:	f1bb 0f00 	cmp.w	fp, #0
 8024748:	dd34      	ble.n	80247b4 <_dtoa_r+0x43c>
 802474a:	4620      	mov	r0, r4
 802474c:	f107 38ff 	add.w	r8, r7, #4294967295
 8024750:	3601      	adds	r6, #1
 8024752:	465c      	mov	r4, fp
 8024754:	2200      	movs	r2, #0
 8024756:	4b6b      	ldr	r3, [pc, #428]	@ (8024904 <_dtoa_r+0x58c>)
 8024758:	4629      	mov	r1, r5
 802475a:	f7db ff5b 	bl	8000614 <__aeabi_dmul>
 802475e:	e9cd 0106 	strd	r0, r1, [sp, #24]
 8024762:	4630      	mov	r0, r6
 8024764:	f7db feec 	bl	8000540 <__aeabi_i2d>
 8024768:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
 802476c:	f7db ff52 	bl	8000614 <__aeabi_dmul>
 8024770:	2200      	movs	r2, #0
 8024772:	4b65      	ldr	r3, [pc, #404]	@ (8024908 <_dtoa_r+0x590>)
 8024774:	f7db fd98 	bl	80002a8 <__adddf3>
 8024778:	4605      	mov	r5, r0
 802477a:	f1a1 7650 	sub.w	r6, r1, #54525952	@ 0x3400000
 802477e:	2c00      	cmp	r4, #0
 8024780:	d16a      	bne.n	8024858 <_dtoa_r+0x4e0>
 8024782:	2200      	movs	r2, #0
 8024784:	4b61      	ldr	r3, [pc, #388]	@ (802490c <_dtoa_r+0x594>)
 8024786:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 802478a:	f7db fd8b 	bl	80002a4 <__aeabi_dsub>
 802478e:	4602      	mov	r2, r0
 8024790:	460b      	mov	r3, r1
 8024792:	e9cd 2306 	strd	r2, r3, [sp, #24]
 8024796:	462a      	mov	r2, r5
 8024798:	4633      	mov	r3, r6
 802479a:	f7dc f9cb 	bl	8000b34 <__aeabi_dcmpgt>
 802479e:	2800      	cmp	r0, #0
 80247a0:	f040 8298 	bne.w	8024cd4 <_dtoa_r+0x95c>
 80247a4:	462a      	mov	r2, r5
 80247a6:	f106 4300 	add.w	r3, r6, #2147483648	@ 0x80000000
 80247aa:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 80247ae:	f7dc f9a3 	bl	8000af8 <__aeabi_dcmplt>
 80247b2:	bb38      	cbnz	r0, 8024804 <_dtoa_r+0x48c>
 80247b4:	e9dd 340c 	ldrd	r3, r4, [sp, #48]	@ 0x30
 80247b8:	e9cd 3406 	strd	r3, r4, [sp, #24]
 80247bc:	9b15      	ldr	r3, [sp, #84]	@ 0x54
 80247be:	2b00      	cmp	r3, #0
 80247c0:	f2c0 8157 	blt.w	8024a72 <_dtoa_r+0x6fa>
 80247c4:	2f0e      	cmp	r7, #14
 80247c6:	f300 8154 	bgt.w	8024a72 <_dtoa_r+0x6fa>
 80247ca:	4b4b      	ldr	r3, [pc, #300]	@ (80248f8 <_dtoa_r+0x580>)
 80247cc:	eb03 03c7 	add.w	r3, r3, r7, lsl #3
 80247d0:	ed93 7b00 	vldr	d7, [r3]
 80247d4:	9b21      	ldr	r3, [sp, #132]	@ 0x84
 80247d6:	2b00      	cmp	r3, #0
 80247d8:	ed8d 7b04 	vstr	d7, [sp, #16]
 80247dc:	f280 80e5 	bge.w	80249aa <_dtoa_r+0x632>
 80247e0:	9b08      	ldr	r3, [sp, #32]
 80247e2:	2b00      	cmp	r3, #0
 80247e4:	f300 80e1 	bgt.w	80249aa <_dtoa_r+0x632>
 80247e8:	d10c      	bne.n	8024804 <_dtoa_r+0x48c>
 80247ea:	2200      	movs	r2, #0
 80247ec:	4b47      	ldr	r3, [pc, #284]	@ (802490c <_dtoa_r+0x594>)
 80247ee:	ec51 0b17 	vmov	r0, r1, d7
 80247f2:	f7db ff0f 	bl	8000614 <__aeabi_dmul>
 80247f6:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
 80247fa:	f7dc f991 	bl	8000b20 <__aeabi_dcmpge>
 80247fe:	2800      	cmp	r0, #0
 8024800:	f000 8266 	beq.w	8024cd0 <_dtoa_r+0x958>
 8024804:	2400      	movs	r4, #0
 8024806:	4625      	mov	r5, r4
 8024808:	9b21      	ldr	r3, [sp, #132]	@ 0x84
 802480a:	4656      	mov	r6, sl
 802480c:	ea6f 0803 	mvn.w	r8, r3
 8024810:	2700      	movs	r7, #0
 8024812:	4621      	mov	r1, r4
 8024814:	4648      	mov	r0, r9
 8024816:	f000 ff53 	bl	80256c0 <_Bfree>
 802481a:	2d00      	cmp	r5, #0
 802481c:	f000 80bd 	beq.w	802499a <_dtoa_r+0x622>
 8024820:	b12f      	cbz	r7, 802482e <_dtoa_r+0x4b6>
 8024822:	42af      	cmp	r7, r5
 8024824:	d003      	beq.n	802482e <_dtoa_r+0x4b6>
 8024826:	4639      	mov	r1, r7
 8024828:	4648      	mov	r0, r9
 802482a:	f000 ff49 	bl	80256c0 <_Bfree>
 802482e:	4629      	mov	r1, r5
 8024830:	4648      	mov	r0, r9
 8024832:	f000 ff45 	bl	80256c0 <_Bfree>
 8024836:	e0b0      	b.n	802499a <_dtoa_r+0x622>
 8024838:	07e2      	lsls	r2, r4, #31
 802483a:	d505      	bpl.n	8024848 <_dtoa_r+0x4d0>
 802483c:	3601      	adds	r6, #1
 802483e:	e9d5 2300 	ldrd	r2, r3, [r5]
 8024842:	f7db fee7 	bl	8000614 <__aeabi_dmul>
 8024846:	2301      	movs	r3, #1
 8024848:	1064      	asrs	r4, r4, #1
 802484a:	3508      	adds	r5, #8
 802484c:	e762      	b.n	8024714 <_dtoa_r+0x39c>
 802484e:	2602      	movs	r6, #2
 8024850:	e765      	b.n	802471e <_dtoa_r+0x3a6>
 8024852:	46b8      	mov	r8, r7
 8024854:	9c08      	ldr	r4, [sp, #32]
 8024856:	e784      	b.n	8024762 <_dtoa_r+0x3ea>
 8024858:	4b27      	ldr	r3, [pc, #156]	@ (80248f8 <_dtoa_r+0x580>)
 802485a:	990b      	ldr	r1, [sp, #44]	@ 0x2c
 802485c:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
 8024860:	4454      	add	r4, sl
 8024862:	e953 2302 	ldrd	r2, r3, [r3, #-8]
 8024866:	2900      	cmp	r1, #0
 8024868:	d054      	beq.n	8024914 <_dtoa_r+0x59c>
 802486a:	2000      	movs	r0, #0
 802486c:	4928      	ldr	r1, [pc, #160]	@ (8024910 <_dtoa_r+0x598>)
 802486e:	f7db fffb 	bl	8000868 <__aeabi_ddiv>
 8024872:	4633      	mov	r3, r6
 8024874:	4656      	mov	r6, sl
 8024876:	462a      	mov	r2, r5
 8024878:	f7db fd14 	bl	80002a4 <__aeabi_dsub>
 802487c:	e9cd 0110 	strd	r0, r1, [sp, #64]	@ 0x40
 8024880:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 8024884:	f7dc f976 	bl	8000b74 <__aeabi_d2iz>
 8024888:	4605      	mov	r5, r0
 802488a:	f7db fe59 	bl	8000540 <__aeabi_i2d>
 802488e:	4602      	mov	r2, r0
 8024890:	460b      	mov	r3, r1
 8024892:	3530      	adds	r5, #48	@ 0x30
 8024894:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 8024898:	f7db fd04 	bl	80002a4 <__aeabi_dsub>
 802489c:	4602      	mov	r2, r0
 802489e:	460b      	mov	r3, r1
 80248a0:	f806 5b01 	strb.w	r5, [r6], #1
 80248a4:	e9cd 2306 	strd	r2, r3, [sp, #24]
 80248a8:	e9dd 2310 	ldrd	r2, r3, [sp, #64]	@ 0x40
 80248ac:	f7dc f924 	bl	8000af8 <__aeabi_dcmplt>
 80248b0:	2800      	cmp	r0, #0
 80248b2:	d172      	bne.n	802499a <_dtoa_r+0x622>
 80248b4:	2000      	movs	r0, #0
 80248b6:	4912      	ldr	r1, [pc, #72]	@ (8024900 <_dtoa_r+0x588>)
 80248b8:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
 80248bc:	f7db fcf2 	bl	80002a4 <__aeabi_dsub>
 80248c0:	e9dd 2310 	ldrd	r2, r3, [sp, #64]	@ 0x40
 80248c4:	f7dc f918 	bl	8000af8 <__aeabi_dcmplt>
 80248c8:	2800      	cmp	r0, #0
 80248ca:	f040 80b4 	bne.w	8024a36 <_dtoa_r+0x6be>
 80248ce:	42a6      	cmp	r6, r4
 80248d0:	f43f af70 	beq.w	80247b4 <_dtoa_r+0x43c>
 80248d4:	2200      	movs	r2, #0
 80248d6:	4b0b      	ldr	r3, [pc, #44]	@ (8024904 <_dtoa_r+0x58c>)
 80248d8:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	@ 0x40
 80248dc:	f7db fe9a 	bl	8000614 <__aeabi_dmul>
 80248e0:	2200      	movs	r2, #0
 80248e2:	4b08      	ldr	r3, [pc, #32]	@ (8024904 <_dtoa_r+0x58c>)
 80248e4:	e9cd 0110 	strd	r0, r1, [sp, #64]	@ 0x40
 80248e8:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 80248ec:	f7db fe92 	bl	8000614 <__aeabi_dmul>
 80248f0:	e9cd 0106 	strd	r0, r1, [sp, #24]
 80248f4:	e7c4      	b.n	8024880 <_dtoa_r+0x508>
 80248f6:	bf00      	nop
 80248f8:	0802abf8 	.word	0x0802abf8
 80248fc:	0802abd0 	.word	0x0802abd0
 8024900:	3ff00000 	.word	0x3ff00000
 8024904:	40240000 	.word	0x40240000
 8024908:	401c0000 	.word	0x401c0000
 802490c:	40140000 	.word	0x40140000
 8024910:	3fe00000 	.word	0x3fe00000
 8024914:	4631      	mov	r1, r6
 8024916:	4656      	mov	r6, sl
 8024918:	4628      	mov	r0, r5
 802491a:	f7db fe7b 	bl	8000614 <__aeabi_dmul>
 802491e:	9413      	str	r4, [sp, #76]	@ 0x4c
 8024920:	e9cd 0110 	strd	r0, r1, [sp, #64]	@ 0x40
 8024924:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 8024928:	f7dc f924 	bl	8000b74 <__aeabi_d2iz>
 802492c:	4605      	mov	r5, r0
 802492e:	f7db fe07 	bl	8000540 <__aeabi_i2d>
 8024932:	4602      	mov	r2, r0
 8024934:	3530      	adds	r5, #48	@ 0x30
 8024936:	460b      	mov	r3, r1
 8024938:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 802493c:	f7db fcb2 	bl	80002a4 <__aeabi_dsub>
 8024940:	f806 5b01 	strb.w	r5, [r6], #1
 8024944:	4602      	mov	r2, r0
 8024946:	460b      	mov	r3, r1
 8024948:	42a6      	cmp	r6, r4
 802494a:	e9cd 2306 	strd	r2, r3, [sp, #24]
 802494e:	f04f 0200 	mov.w	r2, #0
 8024952:	d124      	bne.n	802499e <_dtoa_r+0x626>
 8024954:	4baf      	ldr	r3, [pc, #700]	@ (8024c14 <_dtoa_r+0x89c>)
 8024956:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	@ 0x40
 802495a:	f7db fca5 	bl	80002a8 <__adddf3>
 802495e:	4602      	mov	r2, r0
 8024960:	460b      	mov	r3, r1
 8024962:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 8024966:	f7dc f8e5 	bl	8000b34 <__aeabi_dcmpgt>
 802496a:	2800      	cmp	r0, #0
 802496c:	d163      	bne.n	8024a36 <_dtoa_r+0x6be>
 802496e:	2000      	movs	r0, #0
 8024970:	49a8      	ldr	r1, [pc, #672]	@ (8024c14 <_dtoa_r+0x89c>)
 8024972:	e9dd 2310 	ldrd	r2, r3, [sp, #64]	@ 0x40
 8024976:	f7db fc95 	bl	80002a4 <__aeabi_dsub>
 802497a:	4602      	mov	r2, r0
 802497c:	460b      	mov	r3, r1
 802497e:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 8024982:	f7dc f8b9 	bl	8000af8 <__aeabi_dcmplt>
 8024986:	2800      	cmp	r0, #0
 8024988:	f43f af14 	beq.w	80247b4 <_dtoa_r+0x43c>
 802498c:	9e13      	ldr	r6, [sp, #76]	@ 0x4c
 802498e:	1e73      	subs	r3, r6, #1
 8024990:	9313      	str	r3, [sp, #76]	@ 0x4c
 8024992:	f816 3c01 	ldrb.w	r3, [r6, #-1]
 8024996:	2b30      	cmp	r3, #48	@ 0x30
 8024998:	d0f8      	beq.n	802498c <_dtoa_r+0x614>
 802499a:	4647      	mov	r7, r8
 802499c:	e03b      	b.n	8024a16 <_dtoa_r+0x69e>
 802499e:	4b9e      	ldr	r3, [pc, #632]	@ (8024c18 <_dtoa_r+0x8a0>)
 80249a0:	f7db fe38 	bl	8000614 <__aeabi_dmul>
 80249a4:	e9cd 0106 	strd	r0, r1, [sp, #24]
 80249a8:	e7bc      	b.n	8024924 <_dtoa_r+0x5ac>
 80249aa:	e9dd 4506 	ldrd	r4, r5, [sp, #24]
 80249ae:	4656      	mov	r6, sl
 80249b0:	4620      	mov	r0, r4
 80249b2:	4629      	mov	r1, r5
 80249b4:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 80249b8:	f7db ff56 	bl	8000868 <__aeabi_ddiv>
 80249bc:	f7dc f8da 	bl	8000b74 <__aeabi_d2iz>
 80249c0:	4680      	mov	r8, r0
 80249c2:	f7db fdbd 	bl	8000540 <__aeabi_i2d>
 80249c6:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 80249ca:	f7db fe23 	bl	8000614 <__aeabi_dmul>
 80249ce:	4602      	mov	r2, r0
 80249d0:	4620      	mov	r0, r4
 80249d2:	f108 0430 	add.w	r4, r8, #48	@ 0x30
 80249d6:	460b      	mov	r3, r1
 80249d8:	4629      	mov	r1, r5
 80249da:	f7db fc63 	bl	80002a4 <__aeabi_dsub>
 80249de:	9d08      	ldr	r5, [sp, #32]
 80249e0:	f806 4b01 	strb.w	r4, [r6], #1
 80249e4:	eba6 040a 	sub.w	r4, r6, sl
 80249e8:	4602      	mov	r2, r0
 80249ea:	460b      	mov	r3, r1
 80249ec:	42a5      	cmp	r5, r4
 80249ee:	d133      	bne.n	8024a58 <_dtoa_r+0x6e0>
 80249f0:	f7db fc5a 	bl	80002a8 <__adddf3>
 80249f4:	4604      	mov	r4, r0
 80249f6:	460d      	mov	r5, r1
 80249f8:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 80249fc:	f7dc f89a 	bl	8000b34 <__aeabi_dcmpgt>
 8024a00:	b9c0      	cbnz	r0, 8024a34 <_dtoa_r+0x6bc>
 8024a02:	4620      	mov	r0, r4
 8024a04:	4629      	mov	r1, r5
 8024a06:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 8024a0a:	f7dc f86b 	bl	8000ae4 <__aeabi_dcmpeq>
 8024a0e:	b110      	cbz	r0, 8024a16 <_dtoa_r+0x69e>
 8024a10:	f018 0f01 	tst.w	r8, #1
 8024a14:	d10e      	bne.n	8024a34 <_dtoa_r+0x6bc>
 8024a16:	9903      	ldr	r1, [sp, #12]
 8024a18:	4648      	mov	r0, r9
 8024a1a:	f000 fe51 	bl	80256c0 <_Bfree>
 8024a1e:	2300      	movs	r3, #0
 8024a20:	3701      	adds	r7, #1
 8024a22:	7033      	strb	r3, [r6, #0]
 8024a24:	9b22      	ldr	r3, [sp, #136]	@ 0x88
 8024a26:	601f      	str	r7, [r3, #0]
 8024a28:	9b24      	ldr	r3, [sp, #144]	@ 0x90
 8024a2a:	2b00      	cmp	r3, #0
 8024a2c:	f000 824c 	beq.w	8024ec8 <_dtoa_r+0xb50>
 8024a30:	601e      	str	r6, [r3, #0]
 8024a32:	e249      	b.n	8024ec8 <_dtoa_r+0xb50>
 8024a34:	46b8      	mov	r8, r7
 8024a36:	4633      	mov	r3, r6
 8024a38:	461e      	mov	r6, r3
 8024a3a:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
 8024a3e:	2a39      	cmp	r2, #57	@ 0x39
 8024a40:	d106      	bne.n	8024a50 <_dtoa_r+0x6d8>
 8024a42:	459a      	cmp	sl, r3
 8024a44:	d1f8      	bne.n	8024a38 <_dtoa_r+0x6c0>
 8024a46:	2230      	movs	r2, #48	@ 0x30
 8024a48:	f108 0801 	add.w	r8, r8, #1
 8024a4c:	f88a 2000 	strb.w	r2, [sl]
 8024a50:	781a      	ldrb	r2, [r3, #0]
 8024a52:	3201      	adds	r2, #1
 8024a54:	701a      	strb	r2, [r3, #0]
 8024a56:	e7a0      	b.n	802499a <_dtoa_r+0x622>
 8024a58:	2200      	movs	r2, #0
 8024a5a:	4b6f      	ldr	r3, [pc, #444]	@ (8024c18 <_dtoa_r+0x8a0>)
 8024a5c:	f7db fdda 	bl	8000614 <__aeabi_dmul>
 8024a60:	2200      	movs	r2, #0
 8024a62:	2300      	movs	r3, #0
 8024a64:	4604      	mov	r4, r0
 8024a66:	460d      	mov	r5, r1
 8024a68:	f7dc f83c 	bl	8000ae4 <__aeabi_dcmpeq>
 8024a6c:	2800      	cmp	r0, #0
 8024a6e:	d09f      	beq.n	80249b0 <_dtoa_r+0x638>
 8024a70:	e7d1      	b.n	8024a16 <_dtoa_r+0x69e>
 8024a72:	9a0b      	ldr	r2, [sp, #44]	@ 0x2c
 8024a74:	2a00      	cmp	r2, #0
 8024a76:	f000 80ea 	beq.w	8024c4e <_dtoa_r+0x8d6>
 8024a7a:	9a20      	ldr	r2, [sp, #128]	@ 0x80
 8024a7c:	2a01      	cmp	r2, #1
 8024a7e:	f300 80cd 	bgt.w	8024c1c <_dtoa_r+0x8a4>
 8024a82:	9a12      	ldr	r2, [sp, #72]	@ 0x48
 8024a84:	2a00      	cmp	r2, #0
 8024a86:	f000 80c1 	beq.w	8024c0c <_dtoa_r+0x894>
 8024a8a:	f203 4333 	addw	r3, r3, #1075	@ 0x433
 8024a8e:	9c0a      	ldr	r4, [sp, #40]	@ 0x28
 8024a90:	9e04      	ldr	r6, [sp, #16]
 8024a92:	9a04      	ldr	r2, [sp, #16]
 8024a94:	2101      	movs	r1, #1
 8024a96:	4648      	mov	r0, r9
 8024a98:	441a      	add	r2, r3
 8024a9a:	9204      	str	r2, [sp, #16]
 8024a9c:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 8024a9e:	441a      	add	r2, r3
 8024aa0:	9209      	str	r2, [sp, #36]	@ 0x24
 8024aa2:	f000 ff0d 	bl	80258c0 <__i2b>
 8024aa6:	4605      	mov	r5, r0
 8024aa8:	b166      	cbz	r6, 8024ac4 <_dtoa_r+0x74c>
 8024aaa:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8024aac:	2b00      	cmp	r3, #0
 8024aae:	dd09      	ble.n	8024ac4 <_dtoa_r+0x74c>
 8024ab0:	42b3      	cmp	r3, r6
 8024ab2:	9a04      	ldr	r2, [sp, #16]
 8024ab4:	bfa8      	it	ge
 8024ab6:	4633      	movge	r3, r6
 8024ab8:	1ad2      	subs	r2, r2, r3
 8024aba:	1af6      	subs	r6, r6, r3
 8024abc:	9204      	str	r2, [sp, #16]
 8024abe:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 8024ac0:	1ad3      	subs	r3, r2, r3
 8024ac2:	9309      	str	r3, [sp, #36]	@ 0x24
 8024ac4:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8024ac6:	b30b      	cbz	r3, 8024b0c <_dtoa_r+0x794>
 8024ac8:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 8024aca:	2b00      	cmp	r3, #0
 8024acc:	f000 80c6 	beq.w	8024c5c <_dtoa_r+0x8e4>
 8024ad0:	2c00      	cmp	r4, #0
 8024ad2:	f000 80c0 	beq.w	8024c56 <_dtoa_r+0x8de>
 8024ad6:	4629      	mov	r1, r5
 8024ad8:	4622      	mov	r2, r4
 8024ada:	4648      	mov	r0, r9
 8024adc:	f000 ffaa 	bl	8025a34 <__pow5mult>
 8024ae0:	9a03      	ldr	r2, [sp, #12]
 8024ae2:	4601      	mov	r1, r0
 8024ae4:	4605      	mov	r5, r0
 8024ae6:	4648      	mov	r0, r9
 8024ae8:	f000 ff00 	bl	80258ec <__multiply>
 8024aec:	9903      	ldr	r1, [sp, #12]
 8024aee:	4680      	mov	r8, r0
 8024af0:	4648      	mov	r0, r9
 8024af2:	f000 fde5 	bl	80256c0 <_Bfree>
 8024af6:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8024af8:	1b1b      	subs	r3, r3, r4
 8024afa:	930a      	str	r3, [sp, #40]	@ 0x28
 8024afc:	f000 80b1 	beq.w	8024c62 <_dtoa_r+0x8ea>
 8024b00:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 8024b02:	4641      	mov	r1, r8
 8024b04:	4648      	mov	r0, r9
 8024b06:	f000 ff95 	bl	8025a34 <__pow5mult>
 8024b0a:	9003      	str	r0, [sp, #12]
 8024b0c:	2101      	movs	r1, #1
 8024b0e:	4648      	mov	r0, r9
 8024b10:	f000 fed6 	bl	80258c0 <__i2b>
 8024b14:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 8024b16:	4604      	mov	r4, r0
 8024b18:	2b00      	cmp	r3, #0
 8024b1a:	f000 81d9 	beq.w	8024ed0 <_dtoa_r+0xb58>
 8024b1e:	461a      	mov	r2, r3
 8024b20:	4601      	mov	r1, r0
 8024b22:	4648      	mov	r0, r9
 8024b24:	f000 ff86 	bl	8025a34 <__pow5mult>
 8024b28:	9b20      	ldr	r3, [sp, #128]	@ 0x80
 8024b2a:	4604      	mov	r4, r0
 8024b2c:	2b01      	cmp	r3, #1
 8024b2e:	f300 809f 	bgt.w	8024c70 <_dtoa_r+0x8f8>
 8024b32:	9b06      	ldr	r3, [sp, #24]
 8024b34:	2b00      	cmp	r3, #0
 8024b36:	f040 8097 	bne.w	8024c68 <_dtoa_r+0x8f0>
 8024b3a:	9b07      	ldr	r3, [sp, #28]
 8024b3c:	f3c3 0313 	ubfx	r3, r3, #0, #20
 8024b40:	2b00      	cmp	r3, #0
 8024b42:	f040 8093 	bne.w	8024c6c <_dtoa_r+0x8f4>
 8024b46:	9b07      	ldr	r3, [sp, #28]
 8024b48:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 8024b4c:	0d1b      	lsrs	r3, r3, #20
 8024b4e:	051b      	lsls	r3, r3, #20
 8024b50:	b133      	cbz	r3, 8024b60 <_dtoa_r+0x7e8>
 8024b52:	9b04      	ldr	r3, [sp, #16]
 8024b54:	3301      	adds	r3, #1
 8024b56:	9304      	str	r3, [sp, #16]
 8024b58:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8024b5a:	3301      	adds	r3, #1
 8024b5c:	9309      	str	r3, [sp, #36]	@ 0x24
 8024b5e:	2301      	movs	r3, #1
 8024b60:	930a      	str	r3, [sp, #40]	@ 0x28
 8024b62:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 8024b64:	2b00      	cmp	r3, #0
 8024b66:	f000 81b9 	beq.w	8024edc <_dtoa_r+0xb64>
 8024b6a:	6923      	ldr	r3, [r4, #16]
 8024b6c:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 8024b70:	6918      	ldr	r0, [r3, #16]
 8024b72:	f000 fe59 	bl	8025828 <__hi0bits>
 8024b76:	f1c0 0020 	rsb	r0, r0, #32
 8024b7a:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8024b7c:	4418      	add	r0, r3
 8024b7e:	f010 001f 	ands.w	r0, r0, #31
 8024b82:	f000 8082 	beq.w	8024c8a <_dtoa_r+0x912>
 8024b86:	f1c0 0320 	rsb	r3, r0, #32
 8024b8a:	2b04      	cmp	r3, #4
 8024b8c:	dd73      	ble.n	8024c76 <_dtoa_r+0x8fe>
 8024b8e:	f1c0 001c 	rsb	r0, r0, #28
 8024b92:	9b04      	ldr	r3, [sp, #16]
 8024b94:	4403      	add	r3, r0
 8024b96:	4406      	add	r6, r0
 8024b98:	9304      	str	r3, [sp, #16]
 8024b9a:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8024b9c:	4403      	add	r3, r0
 8024b9e:	9309      	str	r3, [sp, #36]	@ 0x24
 8024ba0:	9b04      	ldr	r3, [sp, #16]
 8024ba2:	2b00      	cmp	r3, #0
 8024ba4:	dd05      	ble.n	8024bb2 <_dtoa_r+0x83a>
 8024ba6:	461a      	mov	r2, r3
 8024ba8:	9903      	ldr	r1, [sp, #12]
 8024baa:	4648      	mov	r0, r9
 8024bac:	f000 ff9c 	bl	8025ae8 <__lshift>
 8024bb0:	9003      	str	r0, [sp, #12]
 8024bb2:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8024bb4:	2b00      	cmp	r3, #0
 8024bb6:	dd05      	ble.n	8024bc4 <_dtoa_r+0x84c>
 8024bb8:	4621      	mov	r1, r4
 8024bba:	461a      	mov	r2, r3
 8024bbc:	4648      	mov	r0, r9
 8024bbe:	f000 ff93 	bl	8025ae8 <__lshift>
 8024bc2:	4604      	mov	r4, r0
 8024bc4:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 8024bc6:	2b00      	cmp	r3, #0
 8024bc8:	d061      	beq.n	8024c8e <_dtoa_r+0x916>
 8024bca:	4621      	mov	r1, r4
 8024bcc:	9803      	ldr	r0, [sp, #12]
 8024bce:	f000 fff7 	bl	8025bc0 <__mcmp>
 8024bd2:	2800      	cmp	r0, #0
 8024bd4:	da5b      	bge.n	8024c8e <_dtoa_r+0x916>
 8024bd6:	2300      	movs	r3, #0
 8024bd8:	220a      	movs	r2, #10
 8024bda:	9903      	ldr	r1, [sp, #12]
 8024bdc:	4648      	mov	r0, r9
 8024bde:	f000 fd91 	bl	8025704 <__multadd>
 8024be2:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 8024be4:	f107 38ff 	add.w	r8, r7, #4294967295
 8024be8:	9003      	str	r0, [sp, #12]
 8024bea:	2b00      	cmp	r3, #0
 8024bec:	f000 8178 	beq.w	8024ee0 <_dtoa_r+0xb68>
 8024bf0:	4629      	mov	r1, r5
 8024bf2:	2300      	movs	r3, #0
 8024bf4:	220a      	movs	r2, #10
 8024bf6:	4648      	mov	r0, r9
 8024bf8:	f000 fd84 	bl	8025704 <__multadd>
 8024bfc:	f1bb 0f00 	cmp.w	fp, #0
 8024c00:	4605      	mov	r5, r0
 8024c02:	dc6f      	bgt.n	8024ce4 <_dtoa_r+0x96c>
 8024c04:	9b20      	ldr	r3, [sp, #128]	@ 0x80
 8024c06:	2b02      	cmp	r3, #2
 8024c08:	dc49      	bgt.n	8024c9e <_dtoa_r+0x926>
 8024c0a:	e06b      	b.n	8024ce4 <_dtoa_r+0x96c>
 8024c0c:	9b14      	ldr	r3, [sp, #80]	@ 0x50
 8024c0e:	f1c3 0336 	rsb	r3, r3, #54	@ 0x36
 8024c12:	e73c      	b.n	8024a8e <_dtoa_r+0x716>
 8024c14:	3fe00000 	.word	0x3fe00000
 8024c18:	40240000 	.word	0x40240000
 8024c1c:	9b08      	ldr	r3, [sp, #32]
 8024c1e:	1e5c      	subs	r4, r3, #1
 8024c20:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8024c22:	42a3      	cmp	r3, r4
 8024c24:	db09      	blt.n	8024c3a <_dtoa_r+0x8c2>
 8024c26:	1b1c      	subs	r4, r3, r4
 8024c28:	9b08      	ldr	r3, [sp, #32]
 8024c2a:	2b00      	cmp	r3, #0
 8024c2c:	f6bf af30 	bge.w	8024a90 <_dtoa_r+0x718>
 8024c30:	9b04      	ldr	r3, [sp, #16]
 8024c32:	9a08      	ldr	r2, [sp, #32]
 8024c34:	1a9e      	subs	r6, r3, r2
 8024c36:	2300      	movs	r3, #0
 8024c38:	e72b      	b.n	8024a92 <_dtoa_r+0x71a>
 8024c3a:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8024c3c:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
 8024c3e:	1ae3      	subs	r3, r4, r3
 8024c40:	940a      	str	r4, [sp, #40]	@ 0x28
 8024c42:	9e04      	ldr	r6, [sp, #16]
 8024c44:	2400      	movs	r4, #0
 8024c46:	441a      	add	r2, r3
 8024c48:	9b08      	ldr	r3, [sp, #32]
 8024c4a:	920e      	str	r2, [sp, #56]	@ 0x38
 8024c4c:	e721      	b.n	8024a92 <_dtoa_r+0x71a>
 8024c4e:	9c0a      	ldr	r4, [sp, #40]	@ 0x28
 8024c50:	9e04      	ldr	r6, [sp, #16]
 8024c52:	9d0b      	ldr	r5, [sp, #44]	@ 0x2c
 8024c54:	e728      	b.n	8024aa8 <_dtoa_r+0x730>
 8024c56:	f8dd 800c 	ldr.w	r8, [sp, #12]
 8024c5a:	e751      	b.n	8024b00 <_dtoa_r+0x788>
 8024c5c:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 8024c5e:	9903      	ldr	r1, [sp, #12]
 8024c60:	e750      	b.n	8024b04 <_dtoa_r+0x78c>
 8024c62:	f8cd 800c 	str.w	r8, [sp, #12]
 8024c66:	e751      	b.n	8024b0c <_dtoa_r+0x794>
 8024c68:	2300      	movs	r3, #0
 8024c6a:	e779      	b.n	8024b60 <_dtoa_r+0x7e8>
 8024c6c:	9b06      	ldr	r3, [sp, #24]
 8024c6e:	e777      	b.n	8024b60 <_dtoa_r+0x7e8>
 8024c70:	2300      	movs	r3, #0
 8024c72:	930a      	str	r3, [sp, #40]	@ 0x28
 8024c74:	e779      	b.n	8024b6a <_dtoa_r+0x7f2>
 8024c76:	d093      	beq.n	8024ba0 <_dtoa_r+0x828>
 8024c78:	331c      	adds	r3, #28
 8024c7a:	9a04      	ldr	r2, [sp, #16]
 8024c7c:	441a      	add	r2, r3
 8024c7e:	441e      	add	r6, r3
 8024c80:	9204      	str	r2, [sp, #16]
 8024c82:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 8024c84:	441a      	add	r2, r3
 8024c86:	9209      	str	r2, [sp, #36]	@ 0x24
 8024c88:	e78a      	b.n	8024ba0 <_dtoa_r+0x828>
 8024c8a:	4603      	mov	r3, r0
 8024c8c:	e7f4      	b.n	8024c78 <_dtoa_r+0x900>
 8024c8e:	9b08      	ldr	r3, [sp, #32]
 8024c90:	46b8      	mov	r8, r7
 8024c92:	2b00      	cmp	r3, #0
 8024c94:	dc20      	bgt.n	8024cd8 <_dtoa_r+0x960>
 8024c96:	469b      	mov	fp, r3
 8024c98:	9b20      	ldr	r3, [sp, #128]	@ 0x80
 8024c9a:	2b02      	cmp	r3, #2
 8024c9c:	dd1e      	ble.n	8024cdc <_dtoa_r+0x964>
 8024c9e:	f1bb 0f00 	cmp.w	fp, #0
 8024ca2:	f47f adb1 	bne.w	8024808 <_dtoa_r+0x490>
 8024ca6:	4621      	mov	r1, r4
 8024ca8:	465b      	mov	r3, fp
 8024caa:	2205      	movs	r2, #5
 8024cac:	4648      	mov	r0, r9
 8024cae:	f000 fd29 	bl	8025704 <__multadd>
 8024cb2:	4601      	mov	r1, r0
 8024cb4:	4604      	mov	r4, r0
 8024cb6:	9803      	ldr	r0, [sp, #12]
 8024cb8:	f000 ff82 	bl	8025bc0 <__mcmp>
 8024cbc:	2800      	cmp	r0, #0
 8024cbe:	f77f ada3 	ble.w	8024808 <_dtoa_r+0x490>
 8024cc2:	4656      	mov	r6, sl
 8024cc4:	2331      	movs	r3, #49	@ 0x31
 8024cc6:	f108 0801 	add.w	r8, r8, #1
 8024cca:	f806 3b01 	strb.w	r3, [r6], #1
 8024cce:	e59f      	b.n	8024810 <_dtoa_r+0x498>
 8024cd0:	46b8      	mov	r8, r7
 8024cd2:	9c08      	ldr	r4, [sp, #32]
 8024cd4:	4625      	mov	r5, r4
 8024cd6:	e7f4      	b.n	8024cc2 <_dtoa_r+0x94a>
 8024cd8:	f8dd b020 	ldr.w	fp, [sp, #32]
 8024cdc:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 8024cde:	2b00      	cmp	r3, #0
 8024ce0:	f000 8102 	beq.w	8024ee8 <_dtoa_r+0xb70>
 8024ce4:	2e00      	cmp	r6, #0
 8024ce6:	dd05      	ble.n	8024cf4 <_dtoa_r+0x97c>
 8024ce8:	4629      	mov	r1, r5
 8024cea:	4632      	mov	r2, r6
 8024cec:	4648      	mov	r0, r9
 8024cee:	f000 fefb 	bl	8025ae8 <__lshift>
 8024cf2:	4605      	mov	r5, r0
 8024cf4:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8024cf6:	2b00      	cmp	r3, #0
 8024cf8:	d05c      	beq.n	8024db4 <_dtoa_r+0xa3c>
 8024cfa:	6869      	ldr	r1, [r5, #4]
 8024cfc:	4648      	mov	r0, r9
 8024cfe:	f000 fc9f 	bl	8025640 <_Balloc>
 8024d02:	4606      	mov	r6, r0
 8024d04:	b928      	cbnz	r0, 8024d12 <_dtoa_r+0x99a>
 8024d06:	4b83      	ldr	r3, [pc, #524]	@ (8024f14 <_dtoa_r+0xb9c>)
 8024d08:	4602      	mov	r2, r0
 8024d0a:	f240 21ef 	movw	r1, #751	@ 0x2ef
 8024d0e:	f7ff bb47 	b.w	80243a0 <_dtoa_r+0x28>
 8024d12:	692a      	ldr	r2, [r5, #16]
 8024d14:	f105 010c 	add.w	r1, r5, #12
 8024d18:	300c      	adds	r0, #12
 8024d1a:	3202      	adds	r2, #2
 8024d1c:	0092      	lsls	r2, r2, #2
 8024d1e:	f7ff fa66 	bl	80241ee <memcpy>
 8024d22:	2201      	movs	r2, #1
 8024d24:	4631      	mov	r1, r6
 8024d26:	4648      	mov	r0, r9
 8024d28:	f000 fede 	bl	8025ae8 <__lshift>
 8024d2c:	f10a 0301 	add.w	r3, sl, #1
 8024d30:	462f      	mov	r7, r5
 8024d32:	4605      	mov	r5, r0
 8024d34:	9304      	str	r3, [sp, #16]
 8024d36:	eb0a 030b 	add.w	r3, sl, fp
 8024d3a:	930a      	str	r3, [sp, #40]	@ 0x28
 8024d3c:	9b06      	ldr	r3, [sp, #24]
 8024d3e:	f003 0301 	and.w	r3, r3, #1
 8024d42:	9309      	str	r3, [sp, #36]	@ 0x24
 8024d44:	9b04      	ldr	r3, [sp, #16]
 8024d46:	4621      	mov	r1, r4
 8024d48:	9803      	ldr	r0, [sp, #12]
 8024d4a:	f103 3bff 	add.w	fp, r3, #4294967295
 8024d4e:	f7ff fa83 	bl	8024258 <quorem>
 8024d52:	4603      	mov	r3, r0
 8024d54:	4639      	mov	r1, r7
 8024d56:	9008      	str	r0, [sp, #32]
 8024d58:	3330      	adds	r3, #48	@ 0x30
 8024d5a:	9803      	ldr	r0, [sp, #12]
 8024d5c:	930b      	str	r3, [sp, #44]	@ 0x2c
 8024d5e:	f000 ff2f 	bl	8025bc0 <__mcmp>
 8024d62:	462a      	mov	r2, r5
 8024d64:	9006      	str	r0, [sp, #24]
 8024d66:	4621      	mov	r1, r4
 8024d68:	4648      	mov	r0, r9
 8024d6a:	f000 ff45 	bl	8025bf8 <__mdiff>
 8024d6e:	68c2      	ldr	r2, [r0, #12]
 8024d70:	4606      	mov	r6, r0
 8024d72:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 8024d74:	bb02      	cbnz	r2, 8024db8 <_dtoa_r+0xa40>
 8024d76:	4601      	mov	r1, r0
 8024d78:	9803      	ldr	r0, [sp, #12]
 8024d7a:	f000 ff21 	bl	8025bc0 <__mcmp>
 8024d7e:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 8024d80:	4602      	mov	r2, r0
 8024d82:	4631      	mov	r1, r6
 8024d84:	4648      	mov	r0, r9
 8024d86:	e9cd 320b 	strd	r3, r2, [sp, #44]	@ 0x2c
 8024d8a:	f000 fc99 	bl	80256c0 <_Bfree>
 8024d8e:	9b20      	ldr	r3, [sp, #128]	@ 0x80
 8024d90:	9a0c      	ldr	r2, [sp, #48]	@ 0x30
 8024d92:	9e04      	ldr	r6, [sp, #16]
 8024d94:	ea42 0103 	orr.w	r1, r2, r3
 8024d98:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8024d9a:	4319      	orrs	r1, r3
 8024d9c:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 8024d9e:	d10d      	bne.n	8024dbc <_dtoa_r+0xa44>
 8024da0:	2b39      	cmp	r3, #57	@ 0x39
 8024da2:	d027      	beq.n	8024df4 <_dtoa_r+0xa7c>
 8024da4:	9a06      	ldr	r2, [sp, #24]
 8024da6:	2a00      	cmp	r2, #0
 8024da8:	dd01      	ble.n	8024dae <_dtoa_r+0xa36>
 8024daa:	9b08      	ldr	r3, [sp, #32]
 8024dac:	3331      	adds	r3, #49	@ 0x31
 8024dae:	f88b 3000 	strb.w	r3, [fp]
 8024db2:	e52e      	b.n	8024812 <_dtoa_r+0x49a>
 8024db4:	4628      	mov	r0, r5
 8024db6:	e7b9      	b.n	8024d2c <_dtoa_r+0x9b4>
 8024db8:	2201      	movs	r2, #1
 8024dba:	e7e2      	b.n	8024d82 <_dtoa_r+0xa0a>
 8024dbc:	9906      	ldr	r1, [sp, #24]
 8024dbe:	2900      	cmp	r1, #0
 8024dc0:	db04      	blt.n	8024dcc <_dtoa_r+0xa54>
 8024dc2:	9820      	ldr	r0, [sp, #128]	@ 0x80
 8024dc4:	4301      	orrs	r1, r0
 8024dc6:	9809      	ldr	r0, [sp, #36]	@ 0x24
 8024dc8:	4301      	orrs	r1, r0
 8024dca:	d120      	bne.n	8024e0e <_dtoa_r+0xa96>
 8024dcc:	2a00      	cmp	r2, #0
 8024dce:	ddee      	ble.n	8024dae <_dtoa_r+0xa36>
 8024dd0:	2201      	movs	r2, #1
 8024dd2:	9903      	ldr	r1, [sp, #12]
 8024dd4:	4648      	mov	r0, r9
 8024dd6:	9304      	str	r3, [sp, #16]
 8024dd8:	f000 fe86 	bl	8025ae8 <__lshift>
 8024ddc:	4621      	mov	r1, r4
 8024dde:	9003      	str	r0, [sp, #12]
 8024de0:	f000 feee 	bl	8025bc0 <__mcmp>
 8024de4:	2800      	cmp	r0, #0
 8024de6:	9b04      	ldr	r3, [sp, #16]
 8024de8:	dc02      	bgt.n	8024df0 <_dtoa_r+0xa78>
 8024dea:	d1e0      	bne.n	8024dae <_dtoa_r+0xa36>
 8024dec:	07da      	lsls	r2, r3, #31
 8024dee:	d5de      	bpl.n	8024dae <_dtoa_r+0xa36>
 8024df0:	2b39      	cmp	r3, #57	@ 0x39
 8024df2:	d1da      	bne.n	8024daa <_dtoa_r+0xa32>
 8024df4:	2339      	movs	r3, #57	@ 0x39
 8024df6:	f88b 3000 	strb.w	r3, [fp]
 8024dfa:	4633      	mov	r3, r6
 8024dfc:	461e      	mov	r6, r3
 8024dfe:	3b01      	subs	r3, #1
 8024e00:	f816 2c01 	ldrb.w	r2, [r6, #-1]
 8024e04:	2a39      	cmp	r2, #57	@ 0x39
 8024e06:	d04f      	beq.n	8024ea8 <_dtoa_r+0xb30>
 8024e08:	3201      	adds	r2, #1
 8024e0a:	701a      	strb	r2, [r3, #0]
 8024e0c:	e501      	b.n	8024812 <_dtoa_r+0x49a>
 8024e0e:	2a00      	cmp	r2, #0
 8024e10:	dd03      	ble.n	8024e1a <_dtoa_r+0xaa2>
 8024e12:	2b39      	cmp	r3, #57	@ 0x39
 8024e14:	d0ee      	beq.n	8024df4 <_dtoa_r+0xa7c>
 8024e16:	3301      	adds	r3, #1
 8024e18:	e7c9      	b.n	8024dae <_dtoa_r+0xa36>
 8024e1a:	9a04      	ldr	r2, [sp, #16]
 8024e1c:	990a      	ldr	r1, [sp, #40]	@ 0x28
 8024e1e:	f802 3c01 	strb.w	r3, [r2, #-1]
 8024e22:	428a      	cmp	r2, r1
 8024e24:	d029      	beq.n	8024e7a <_dtoa_r+0xb02>
 8024e26:	2300      	movs	r3, #0
 8024e28:	220a      	movs	r2, #10
 8024e2a:	9903      	ldr	r1, [sp, #12]
 8024e2c:	4648      	mov	r0, r9
 8024e2e:	f000 fc69 	bl	8025704 <__multadd>
 8024e32:	42af      	cmp	r7, r5
 8024e34:	9003      	str	r0, [sp, #12]
 8024e36:	f04f 0300 	mov.w	r3, #0
 8024e3a:	f04f 020a 	mov.w	r2, #10
 8024e3e:	4639      	mov	r1, r7
 8024e40:	4648      	mov	r0, r9
 8024e42:	d107      	bne.n	8024e54 <_dtoa_r+0xadc>
 8024e44:	f000 fc5e 	bl	8025704 <__multadd>
 8024e48:	4607      	mov	r7, r0
 8024e4a:	4605      	mov	r5, r0
 8024e4c:	9b04      	ldr	r3, [sp, #16]
 8024e4e:	3301      	adds	r3, #1
 8024e50:	9304      	str	r3, [sp, #16]
 8024e52:	e777      	b.n	8024d44 <_dtoa_r+0x9cc>
 8024e54:	f000 fc56 	bl	8025704 <__multadd>
 8024e58:	4629      	mov	r1, r5
 8024e5a:	4607      	mov	r7, r0
 8024e5c:	2300      	movs	r3, #0
 8024e5e:	220a      	movs	r2, #10
 8024e60:	4648      	mov	r0, r9
 8024e62:	f000 fc4f 	bl	8025704 <__multadd>
 8024e66:	4605      	mov	r5, r0
 8024e68:	e7f0      	b.n	8024e4c <_dtoa_r+0xad4>
 8024e6a:	f1bb 0f00 	cmp.w	fp, #0
 8024e6e:	f04f 0700 	mov.w	r7, #0
 8024e72:	bfcc      	ite	gt
 8024e74:	465e      	movgt	r6, fp
 8024e76:	2601      	movle	r6, #1
 8024e78:	4456      	add	r6, sl
 8024e7a:	2201      	movs	r2, #1
 8024e7c:	9903      	ldr	r1, [sp, #12]
 8024e7e:	4648      	mov	r0, r9
 8024e80:	9304      	str	r3, [sp, #16]
 8024e82:	f000 fe31 	bl	8025ae8 <__lshift>
 8024e86:	4621      	mov	r1, r4
 8024e88:	9003      	str	r0, [sp, #12]
 8024e8a:	f000 fe99 	bl	8025bc0 <__mcmp>
 8024e8e:	2800      	cmp	r0, #0
 8024e90:	dcb3      	bgt.n	8024dfa <_dtoa_r+0xa82>
 8024e92:	d102      	bne.n	8024e9a <_dtoa_r+0xb22>
 8024e94:	9b04      	ldr	r3, [sp, #16]
 8024e96:	07db      	lsls	r3, r3, #31
 8024e98:	d4af      	bmi.n	8024dfa <_dtoa_r+0xa82>
 8024e9a:	4633      	mov	r3, r6
 8024e9c:	461e      	mov	r6, r3
 8024e9e:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
 8024ea2:	2a30      	cmp	r2, #48	@ 0x30
 8024ea4:	d0fa      	beq.n	8024e9c <_dtoa_r+0xb24>
 8024ea6:	e4b4      	b.n	8024812 <_dtoa_r+0x49a>
 8024ea8:	459a      	cmp	sl, r3
 8024eaa:	d1a7      	bne.n	8024dfc <_dtoa_r+0xa84>
 8024eac:	2331      	movs	r3, #49	@ 0x31
 8024eae:	f108 0801 	add.w	r8, r8, #1
 8024eb2:	f88a 3000 	strb.w	r3, [sl]
 8024eb6:	e4ac      	b.n	8024812 <_dtoa_r+0x49a>
 8024eb8:	9b24      	ldr	r3, [sp, #144]	@ 0x90
 8024eba:	f8df a05c 	ldr.w	sl, [pc, #92]	@ 8024f18 <_dtoa_r+0xba0>
 8024ebe:	b11b      	cbz	r3, 8024ec8 <_dtoa_r+0xb50>
 8024ec0:	f10a 0308 	add.w	r3, sl, #8
 8024ec4:	9a24      	ldr	r2, [sp, #144]	@ 0x90
 8024ec6:	6013      	str	r3, [r2, #0]
 8024ec8:	4650      	mov	r0, sl
 8024eca:	b017      	add	sp, #92	@ 0x5c
 8024ecc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8024ed0:	9b20      	ldr	r3, [sp, #128]	@ 0x80
 8024ed2:	2b01      	cmp	r3, #1
 8024ed4:	f77f ae2d 	ble.w	8024b32 <_dtoa_r+0x7ba>
 8024ed8:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 8024eda:	930a      	str	r3, [sp, #40]	@ 0x28
 8024edc:	2001      	movs	r0, #1
 8024ede:	e64c      	b.n	8024b7a <_dtoa_r+0x802>
 8024ee0:	f1bb 0f00 	cmp.w	fp, #0
 8024ee4:	f77f aed8 	ble.w	8024c98 <_dtoa_r+0x920>
 8024ee8:	4656      	mov	r6, sl
 8024eea:	4621      	mov	r1, r4
 8024eec:	9803      	ldr	r0, [sp, #12]
 8024eee:	f7ff f9b3 	bl	8024258 <quorem>
 8024ef2:	f100 0330 	add.w	r3, r0, #48	@ 0x30
 8024ef6:	f806 3b01 	strb.w	r3, [r6], #1
 8024efa:	eba6 020a 	sub.w	r2, r6, sl
 8024efe:	4593      	cmp	fp, r2
 8024f00:	ddb3      	ble.n	8024e6a <_dtoa_r+0xaf2>
 8024f02:	2300      	movs	r3, #0
 8024f04:	220a      	movs	r2, #10
 8024f06:	9903      	ldr	r1, [sp, #12]
 8024f08:	4648      	mov	r0, r9
 8024f0a:	f000 fbfb 	bl	8025704 <__multadd>
 8024f0e:	9003      	str	r0, [sp, #12]
 8024f10:	e7eb      	b.n	8024eea <_dtoa_r+0xb72>
 8024f12:	bf00      	nop
 8024f14:	0802a993 	.word	0x0802a993
 8024f18:	0802a92e 	.word	0x0802a92e

08024f1c <_free_r>:
 8024f1c:	b538      	push	{r3, r4, r5, lr}
 8024f1e:	4605      	mov	r5, r0
 8024f20:	2900      	cmp	r1, #0
 8024f22:	d041      	beq.n	8024fa8 <_free_r+0x8c>
 8024f24:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8024f28:	1f0c      	subs	r4, r1, #4
 8024f2a:	2b00      	cmp	r3, #0
 8024f2c:	bfb8      	it	lt
 8024f2e:	18e4      	addlt	r4, r4, r3
 8024f30:	f7fd f8fc 	bl	802212c <__malloc_lock>
 8024f34:	4a1d      	ldr	r2, [pc, #116]	@ (8024fac <_free_r+0x90>)
 8024f36:	6813      	ldr	r3, [r2, #0]
 8024f38:	b933      	cbnz	r3, 8024f48 <_free_r+0x2c>
 8024f3a:	6063      	str	r3, [r4, #4]
 8024f3c:	6014      	str	r4, [r2, #0]
 8024f3e:	4628      	mov	r0, r5
 8024f40:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8024f44:	f7fd b8f8 	b.w	8022138 <__malloc_unlock>
 8024f48:	42a3      	cmp	r3, r4
 8024f4a:	d908      	bls.n	8024f5e <_free_r+0x42>
 8024f4c:	6820      	ldr	r0, [r4, #0]
 8024f4e:	1821      	adds	r1, r4, r0
 8024f50:	428b      	cmp	r3, r1
 8024f52:	bf01      	itttt	eq
 8024f54:	6819      	ldreq	r1, [r3, #0]
 8024f56:	685b      	ldreq	r3, [r3, #4]
 8024f58:	1809      	addeq	r1, r1, r0
 8024f5a:	6021      	streq	r1, [r4, #0]
 8024f5c:	e7ed      	b.n	8024f3a <_free_r+0x1e>
 8024f5e:	461a      	mov	r2, r3
 8024f60:	685b      	ldr	r3, [r3, #4]
 8024f62:	b10b      	cbz	r3, 8024f68 <_free_r+0x4c>
 8024f64:	42a3      	cmp	r3, r4
 8024f66:	d9fa      	bls.n	8024f5e <_free_r+0x42>
 8024f68:	6811      	ldr	r1, [r2, #0]
 8024f6a:	1850      	adds	r0, r2, r1
 8024f6c:	42a0      	cmp	r0, r4
 8024f6e:	d10b      	bne.n	8024f88 <_free_r+0x6c>
 8024f70:	6820      	ldr	r0, [r4, #0]
 8024f72:	4401      	add	r1, r0
 8024f74:	1850      	adds	r0, r2, r1
 8024f76:	6011      	str	r1, [r2, #0]
 8024f78:	4283      	cmp	r3, r0
 8024f7a:	d1e0      	bne.n	8024f3e <_free_r+0x22>
 8024f7c:	6818      	ldr	r0, [r3, #0]
 8024f7e:	685b      	ldr	r3, [r3, #4]
 8024f80:	4408      	add	r0, r1
 8024f82:	6053      	str	r3, [r2, #4]
 8024f84:	6010      	str	r0, [r2, #0]
 8024f86:	e7da      	b.n	8024f3e <_free_r+0x22>
 8024f88:	d902      	bls.n	8024f90 <_free_r+0x74>
 8024f8a:	230c      	movs	r3, #12
 8024f8c:	602b      	str	r3, [r5, #0]
 8024f8e:	e7d6      	b.n	8024f3e <_free_r+0x22>
 8024f90:	6820      	ldr	r0, [r4, #0]
 8024f92:	1821      	adds	r1, r4, r0
 8024f94:	428b      	cmp	r3, r1
 8024f96:	bf02      	ittt	eq
 8024f98:	6819      	ldreq	r1, [r3, #0]
 8024f9a:	685b      	ldreq	r3, [r3, #4]
 8024f9c:	1809      	addeq	r1, r1, r0
 8024f9e:	6063      	str	r3, [r4, #4]
 8024fa0:	bf08      	it	eq
 8024fa2:	6021      	streq	r1, [r4, #0]
 8024fa4:	6054      	str	r4, [r2, #4]
 8024fa6:	e7ca      	b.n	8024f3e <_free_r+0x22>
 8024fa8:	bd38      	pop	{r3, r4, r5, pc}
 8024faa:	bf00      	nop
 8024fac:	20001ea4 	.word	0x20001ea4

08024fb0 <rshift>:
 8024fb0:	6903      	ldr	r3, [r0, #16]
 8024fb2:	114a      	asrs	r2, r1, #5
 8024fb4:	ebb3 1f61 	cmp.w	r3, r1, asr #5
 8024fb8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8024fbc:	f100 0414 	add.w	r4, r0, #20
 8024fc0:	dd45      	ble.n	802504e <rshift+0x9e>
 8024fc2:	f011 011f 	ands.w	r1, r1, #31
 8024fc6:	eb04 0683 	add.w	r6, r4, r3, lsl #2
 8024fca:	eb04 0582 	add.w	r5, r4, r2, lsl #2
 8024fce:	d10c      	bne.n	8024fea <rshift+0x3a>
 8024fd0:	f100 0710 	add.w	r7, r0, #16
 8024fd4:	4629      	mov	r1, r5
 8024fd6:	42b1      	cmp	r1, r6
 8024fd8:	d334      	bcc.n	8025044 <rshift+0x94>
 8024fda:	1a9b      	subs	r3, r3, r2
 8024fdc:	1eea      	subs	r2, r5, #3
 8024fde:	009b      	lsls	r3, r3, #2
 8024fe0:	4296      	cmp	r6, r2
 8024fe2:	bf38      	it	cc
 8024fe4:	2300      	movcc	r3, #0
 8024fe6:	4423      	add	r3, r4
 8024fe8:	e015      	b.n	8025016 <rshift+0x66>
 8024fea:	f854 7022 	ldr.w	r7, [r4, r2, lsl #2]
 8024fee:	f1c1 0820 	rsb	r8, r1, #32
 8024ff2:	f105 0e04 	add.w	lr, r5, #4
 8024ff6:	46a1      	mov	r9, r4
 8024ff8:	40cf      	lsrs	r7, r1
 8024ffa:	4576      	cmp	r6, lr
 8024ffc:	46f4      	mov	ip, lr
 8024ffe:	d815      	bhi.n	802502c <rshift+0x7c>
 8025000:	1a9a      	subs	r2, r3, r2
 8025002:	3501      	adds	r5, #1
 8025004:	0092      	lsls	r2, r2, #2
 8025006:	3a04      	subs	r2, #4
 8025008:	42ae      	cmp	r6, r5
 802500a:	bf38      	it	cc
 802500c:	2200      	movcc	r2, #0
 802500e:	18a3      	adds	r3, r4, r2
 8025010:	50a7      	str	r7, [r4, r2]
 8025012:	b107      	cbz	r7, 8025016 <rshift+0x66>
 8025014:	3304      	adds	r3, #4
 8025016:	1b1a      	subs	r2, r3, r4
 8025018:	42a3      	cmp	r3, r4
 802501a:	ea4f 02a2 	mov.w	r2, r2, asr #2
 802501e:	bf08      	it	eq
 8025020:	2300      	moveq	r3, #0
 8025022:	6102      	str	r2, [r0, #16]
 8025024:	bf08      	it	eq
 8025026:	6143      	streq	r3, [r0, #20]
 8025028:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 802502c:	f8dc c000 	ldr.w	ip, [ip]
 8025030:	fa0c fc08 	lsl.w	ip, ip, r8
 8025034:	ea4c 0707 	orr.w	r7, ip, r7
 8025038:	f849 7b04 	str.w	r7, [r9], #4
 802503c:	f85e 7b04 	ldr.w	r7, [lr], #4
 8025040:	40cf      	lsrs	r7, r1
 8025042:	e7da      	b.n	8024ffa <rshift+0x4a>
 8025044:	f851 cb04 	ldr.w	ip, [r1], #4
 8025048:	f847 cf04 	str.w	ip, [r7, #4]!
 802504c:	e7c3      	b.n	8024fd6 <rshift+0x26>
 802504e:	4623      	mov	r3, r4
 8025050:	e7e1      	b.n	8025016 <rshift+0x66>

08025052 <__hexdig_fun>:
 8025052:	f1a0 0330 	sub.w	r3, r0, #48	@ 0x30
 8025056:	2b09      	cmp	r3, #9
 8025058:	d802      	bhi.n	8025060 <__hexdig_fun+0xe>
 802505a:	3820      	subs	r0, #32
 802505c:	b2c0      	uxtb	r0, r0
 802505e:	4770      	bx	lr
 8025060:	f1a0 0361 	sub.w	r3, r0, #97	@ 0x61
 8025064:	2b05      	cmp	r3, #5
 8025066:	d801      	bhi.n	802506c <__hexdig_fun+0x1a>
 8025068:	3847      	subs	r0, #71	@ 0x47
 802506a:	e7f7      	b.n	802505c <__hexdig_fun+0xa>
 802506c:	f1a0 0341 	sub.w	r3, r0, #65	@ 0x41
 8025070:	2b05      	cmp	r3, #5
 8025072:	d801      	bhi.n	8025078 <__hexdig_fun+0x26>
 8025074:	3827      	subs	r0, #39	@ 0x27
 8025076:	e7f1      	b.n	802505c <__hexdig_fun+0xa>
 8025078:	2000      	movs	r0, #0
 802507a:	4770      	bx	lr

0802507c <__gethex>:
 802507c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8025080:	b085      	sub	sp, #20
 8025082:	468a      	mov	sl, r1
 8025084:	4690      	mov	r8, r2
 8025086:	9302      	str	r3, [sp, #8]
 8025088:	680b      	ldr	r3, [r1, #0]
 802508a:	9001      	str	r0, [sp, #4]
 802508c:	1c9c      	adds	r4, r3, #2
 802508e:	46a1      	mov	r9, r4
 8025090:	f814 0b01 	ldrb.w	r0, [r4], #1
 8025094:	2830      	cmp	r0, #48	@ 0x30
 8025096:	d0fa      	beq.n	802508e <__gethex+0x12>
 8025098:	eba9 0303 	sub.w	r3, r9, r3
 802509c:	f1a3 0b02 	sub.w	fp, r3, #2
 80250a0:	f7ff ffd7 	bl	8025052 <__hexdig_fun>
 80250a4:	4605      	mov	r5, r0
 80250a6:	2800      	cmp	r0, #0
 80250a8:	d166      	bne.n	8025178 <__gethex+0xfc>
 80250aa:	2201      	movs	r2, #1
 80250ac:	499e      	ldr	r1, [pc, #632]	@ (8025328 <__gethex+0x2ac>)
 80250ae:	4648      	mov	r0, r9
 80250b0:	f7fe ffed 	bl	802408e <strncmp>
 80250b4:	4607      	mov	r7, r0
 80250b6:	2800      	cmp	r0, #0
 80250b8:	d165      	bne.n	8025186 <__gethex+0x10a>
 80250ba:	f899 0001 	ldrb.w	r0, [r9, #1]
 80250be:	4626      	mov	r6, r4
 80250c0:	f7ff ffc7 	bl	8025052 <__hexdig_fun>
 80250c4:	2800      	cmp	r0, #0
 80250c6:	d060      	beq.n	802518a <__gethex+0x10e>
 80250c8:	4623      	mov	r3, r4
 80250ca:	7818      	ldrb	r0, [r3, #0]
 80250cc:	4699      	mov	r9, r3
 80250ce:	3301      	adds	r3, #1
 80250d0:	2830      	cmp	r0, #48	@ 0x30
 80250d2:	d0fa      	beq.n	80250ca <__gethex+0x4e>
 80250d4:	f7ff ffbd 	bl	8025052 <__hexdig_fun>
 80250d8:	fab0 f580 	clz	r5, r0
 80250dc:	f04f 0b01 	mov.w	fp, #1
 80250e0:	096d      	lsrs	r5, r5, #5
 80250e2:	464a      	mov	r2, r9
 80250e4:	4616      	mov	r6, r2
 80250e6:	3201      	adds	r2, #1
 80250e8:	7830      	ldrb	r0, [r6, #0]
 80250ea:	f7ff ffb2 	bl	8025052 <__hexdig_fun>
 80250ee:	2800      	cmp	r0, #0
 80250f0:	d1f8      	bne.n	80250e4 <__gethex+0x68>
 80250f2:	2201      	movs	r2, #1
 80250f4:	498c      	ldr	r1, [pc, #560]	@ (8025328 <__gethex+0x2ac>)
 80250f6:	4630      	mov	r0, r6
 80250f8:	f7fe ffc9 	bl	802408e <strncmp>
 80250fc:	2800      	cmp	r0, #0
 80250fe:	d13e      	bne.n	802517e <__gethex+0x102>
 8025100:	b944      	cbnz	r4, 8025114 <__gethex+0x98>
 8025102:	1c74      	adds	r4, r6, #1
 8025104:	4622      	mov	r2, r4
 8025106:	4616      	mov	r6, r2
 8025108:	3201      	adds	r2, #1
 802510a:	7830      	ldrb	r0, [r6, #0]
 802510c:	f7ff ffa1 	bl	8025052 <__hexdig_fun>
 8025110:	2800      	cmp	r0, #0
 8025112:	d1f8      	bne.n	8025106 <__gethex+0x8a>
 8025114:	1ba4      	subs	r4, r4, r6
 8025116:	00a7      	lsls	r7, r4, #2
 8025118:	7833      	ldrb	r3, [r6, #0]
 802511a:	f003 03df 	and.w	r3, r3, #223	@ 0xdf
 802511e:	2b50      	cmp	r3, #80	@ 0x50
 8025120:	d13d      	bne.n	802519e <__gethex+0x122>
 8025122:	7873      	ldrb	r3, [r6, #1]
 8025124:	2b2b      	cmp	r3, #43	@ 0x2b
 8025126:	d032      	beq.n	802518e <__gethex+0x112>
 8025128:	2b2d      	cmp	r3, #45	@ 0x2d
 802512a:	d033      	beq.n	8025194 <__gethex+0x118>
 802512c:	1c71      	adds	r1, r6, #1
 802512e:	2400      	movs	r4, #0
 8025130:	7808      	ldrb	r0, [r1, #0]
 8025132:	f7ff ff8e 	bl	8025052 <__hexdig_fun>
 8025136:	1e43      	subs	r3, r0, #1
 8025138:	b2db      	uxtb	r3, r3
 802513a:	2b18      	cmp	r3, #24
 802513c:	d82f      	bhi.n	802519e <__gethex+0x122>
 802513e:	f1a0 0210 	sub.w	r2, r0, #16
 8025142:	f811 0f01 	ldrb.w	r0, [r1, #1]!
 8025146:	f7ff ff84 	bl	8025052 <__hexdig_fun>
 802514a:	f100 3cff 	add.w	ip, r0, #4294967295
 802514e:	230a      	movs	r3, #10
 8025150:	fa5f fc8c 	uxtb.w	ip, ip
 8025154:	f1bc 0f18 	cmp.w	ip, #24
 8025158:	d91e      	bls.n	8025198 <__gethex+0x11c>
 802515a:	b104      	cbz	r4, 802515e <__gethex+0xe2>
 802515c:	4252      	negs	r2, r2
 802515e:	4417      	add	r7, r2
 8025160:	f8ca 1000 	str.w	r1, [sl]
 8025164:	b1ed      	cbz	r5, 80251a2 <__gethex+0x126>
 8025166:	f1bb 0f00 	cmp.w	fp, #0
 802516a:	bf0c      	ite	eq
 802516c:	2506      	moveq	r5, #6
 802516e:	2500      	movne	r5, #0
 8025170:	4628      	mov	r0, r5
 8025172:	b005      	add	sp, #20
 8025174:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8025178:	2500      	movs	r5, #0
 802517a:	462c      	mov	r4, r5
 802517c:	e7b1      	b.n	80250e2 <__gethex+0x66>
 802517e:	2c00      	cmp	r4, #0
 8025180:	d1c8      	bne.n	8025114 <__gethex+0x98>
 8025182:	4627      	mov	r7, r4
 8025184:	e7c8      	b.n	8025118 <__gethex+0x9c>
 8025186:	464e      	mov	r6, r9
 8025188:	462f      	mov	r7, r5
 802518a:	2501      	movs	r5, #1
 802518c:	e7c4      	b.n	8025118 <__gethex+0x9c>
 802518e:	2400      	movs	r4, #0
 8025190:	1cb1      	adds	r1, r6, #2
 8025192:	e7cd      	b.n	8025130 <__gethex+0xb4>
 8025194:	2401      	movs	r4, #1
 8025196:	e7fb      	b.n	8025190 <__gethex+0x114>
 8025198:	fb03 0002 	mla	r0, r3, r2, r0
 802519c:	e7cf      	b.n	802513e <__gethex+0xc2>
 802519e:	4631      	mov	r1, r6
 80251a0:	e7de      	b.n	8025160 <__gethex+0xe4>
 80251a2:	eba6 0309 	sub.w	r3, r6, r9
 80251a6:	4629      	mov	r1, r5
 80251a8:	3b01      	subs	r3, #1
 80251aa:	2b07      	cmp	r3, #7
 80251ac:	dc0a      	bgt.n	80251c4 <__gethex+0x148>
 80251ae:	9801      	ldr	r0, [sp, #4]
 80251b0:	f000 fa46 	bl	8025640 <_Balloc>
 80251b4:	4604      	mov	r4, r0
 80251b6:	b940      	cbnz	r0, 80251ca <__gethex+0x14e>
 80251b8:	4b5c      	ldr	r3, [pc, #368]	@ (802532c <__gethex+0x2b0>)
 80251ba:	4602      	mov	r2, r0
 80251bc:	21e4      	movs	r1, #228	@ 0xe4
 80251be:	485c      	ldr	r0, [pc, #368]	@ (8025330 <__gethex+0x2b4>)
 80251c0:	f7ff f82c 	bl	802421c <__assert_func>
 80251c4:	3101      	adds	r1, #1
 80251c6:	105b      	asrs	r3, r3, #1
 80251c8:	e7ef      	b.n	80251aa <__gethex+0x12e>
 80251ca:	f100 0a14 	add.w	sl, r0, #20
 80251ce:	2300      	movs	r3, #0
 80251d0:	4655      	mov	r5, sl
 80251d2:	469b      	mov	fp, r3
 80251d4:	45b1      	cmp	r9, r6
 80251d6:	d337      	bcc.n	8025248 <__gethex+0x1cc>
 80251d8:	f845 bb04 	str.w	fp, [r5], #4
 80251dc:	eba5 050a 	sub.w	r5, r5, sl
 80251e0:	4658      	mov	r0, fp
 80251e2:	10ad      	asrs	r5, r5, #2
 80251e4:	6125      	str	r5, [r4, #16]
 80251e6:	016d      	lsls	r5, r5, #5
 80251e8:	f000 fb1e 	bl	8025828 <__hi0bits>
 80251ec:	f8d8 6000 	ldr.w	r6, [r8]
 80251f0:	1a2d      	subs	r5, r5, r0
 80251f2:	42b5      	cmp	r5, r6
 80251f4:	dd54      	ble.n	80252a0 <__gethex+0x224>
 80251f6:	1bad      	subs	r5, r5, r6
 80251f8:	4620      	mov	r0, r4
 80251fa:	4629      	mov	r1, r5
 80251fc:	f000 fea9 	bl	8025f52 <__any_on>
 8025200:	4681      	mov	r9, r0
 8025202:	b178      	cbz	r0, 8025224 <__gethex+0x1a8>
 8025204:	1e6b      	subs	r3, r5, #1
 8025206:	f04f 0901 	mov.w	r9, #1
 802520a:	1159      	asrs	r1, r3, #5
 802520c:	f003 021f 	and.w	r2, r3, #31
 8025210:	f85a 1021 	ldr.w	r1, [sl, r1, lsl #2]
 8025214:	fa09 f202 	lsl.w	r2, r9, r2
 8025218:	420a      	tst	r2, r1
 802521a:	d003      	beq.n	8025224 <__gethex+0x1a8>
 802521c:	454b      	cmp	r3, r9
 802521e:	dc36      	bgt.n	802528e <__gethex+0x212>
 8025220:	f04f 0902 	mov.w	r9, #2
 8025224:	442f      	add	r7, r5
 8025226:	4629      	mov	r1, r5
 8025228:	4620      	mov	r0, r4
 802522a:	f7ff fec1 	bl	8024fb0 <rshift>
 802522e:	f8d8 3008 	ldr.w	r3, [r8, #8]
 8025232:	42bb      	cmp	r3, r7
 8025234:	da42      	bge.n	80252bc <__gethex+0x240>
 8025236:	4621      	mov	r1, r4
 8025238:	9801      	ldr	r0, [sp, #4]
 802523a:	f000 fa41 	bl	80256c0 <_Bfree>
 802523e:	2300      	movs	r3, #0
 8025240:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
 8025242:	25a3      	movs	r5, #163	@ 0xa3
 8025244:	6013      	str	r3, [r2, #0]
 8025246:	e793      	b.n	8025170 <__gethex+0xf4>
 8025248:	f816 2d01 	ldrb.w	r2, [r6, #-1]!
 802524c:	2a2e      	cmp	r2, #46	@ 0x2e
 802524e:	d012      	beq.n	8025276 <__gethex+0x1fa>
 8025250:	2b20      	cmp	r3, #32
 8025252:	d104      	bne.n	802525e <__gethex+0x1e2>
 8025254:	f845 bb04 	str.w	fp, [r5], #4
 8025258:	f04f 0b00 	mov.w	fp, #0
 802525c:	465b      	mov	r3, fp
 802525e:	7830      	ldrb	r0, [r6, #0]
 8025260:	9303      	str	r3, [sp, #12]
 8025262:	f7ff fef6 	bl	8025052 <__hexdig_fun>
 8025266:	9b03      	ldr	r3, [sp, #12]
 8025268:	f000 000f 	and.w	r0, r0, #15
 802526c:	4098      	lsls	r0, r3
 802526e:	3304      	adds	r3, #4
 8025270:	ea4b 0b00 	orr.w	fp, fp, r0
 8025274:	e7ae      	b.n	80251d4 <__gethex+0x158>
 8025276:	45b1      	cmp	r9, r6
 8025278:	d8ea      	bhi.n	8025250 <__gethex+0x1d4>
 802527a:	2201      	movs	r2, #1
 802527c:	492a      	ldr	r1, [pc, #168]	@ (8025328 <__gethex+0x2ac>)
 802527e:	4630      	mov	r0, r6
 8025280:	9303      	str	r3, [sp, #12]
 8025282:	f7fe ff04 	bl	802408e <strncmp>
 8025286:	9b03      	ldr	r3, [sp, #12]
 8025288:	2800      	cmp	r0, #0
 802528a:	d1e1      	bne.n	8025250 <__gethex+0x1d4>
 802528c:	e7a2      	b.n	80251d4 <__gethex+0x158>
 802528e:	1ea9      	subs	r1, r5, #2
 8025290:	4620      	mov	r0, r4
 8025292:	f000 fe5e 	bl	8025f52 <__any_on>
 8025296:	2800      	cmp	r0, #0
 8025298:	d0c2      	beq.n	8025220 <__gethex+0x1a4>
 802529a:	f04f 0903 	mov.w	r9, #3
 802529e:	e7c1      	b.n	8025224 <__gethex+0x1a8>
 80252a0:	da09      	bge.n	80252b6 <__gethex+0x23a>
 80252a2:	1b75      	subs	r5, r6, r5
 80252a4:	4621      	mov	r1, r4
 80252a6:	9801      	ldr	r0, [sp, #4]
 80252a8:	462a      	mov	r2, r5
 80252aa:	1b7f      	subs	r7, r7, r5
 80252ac:	f000 fc1c 	bl	8025ae8 <__lshift>
 80252b0:	4604      	mov	r4, r0
 80252b2:	f100 0a14 	add.w	sl, r0, #20
 80252b6:	f04f 0900 	mov.w	r9, #0
 80252ba:	e7b8      	b.n	802522e <__gethex+0x1b2>
 80252bc:	f8d8 5004 	ldr.w	r5, [r8, #4]
 80252c0:	42bd      	cmp	r5, r7
 80252c2:	dd6f      	ble.n	80253a4 <__gethex+0x328>
 80252c4:	1bed      	subs	r5, r5, r7
 80252c6:	42ae      	cmp	r6, r5
 80252c8:	dc34      	bgt.n	8025334 <__gethex+0x2b8>
 80252ca:	f8d8 300c 	ldr.w	r3, [r8, #12]
 80252ce:	2b02      	cmp	r3, #2
 80252d0:	d022      	beq.n	8025318 <__gethex+0x29c>
 80252d2:	2b03      	cmp	r3, #3
 80252d4:	d024      	beq.n	8025320 <__gethex+0x2a4>
 80252d6:	2b01      	cmp	r3, #1
 80252d8:	d115      	bne.n	8025306 <__gethex+0x28a>
 80252da:	42ae      	cmp	r6, r5
 80252dc:	d113      	bne.n	8025306 <__gethex+0x28a>
 80252de:	2e01      	cmp	r6, #1
 80252e0:	d10b      	bne.n	80252fa <__gethex+0x27e>
 80252e2:	f8d8 3004 	ldr.w	r3, [r8, #4]
 80252e6:	2562      	movs	r5, #98	@ 0x62
 80252e8:	9a02      	ldr	r2, [sp, #8]
 80252ea:	6013      	str	r3, [r2, #0]
 80252ec:	2301      	movs	r3, #1
 80252ee:	6123      	str	r3, [r4, #16]
 80252f0:	f8ca 3000 	str.w	r3, [sl]
 80252f4:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 80252f6:	601c      	str	r4, [r3, #0]
 80252f8:	e73a      	b.n	8025170 <__gethex+0xf4>
 80252fa:	1e71      	subs	r1, r6, #1
 80252fc:	4620      	mov	r0, r4
 80252fe:	f000 fe28 	bl	8025f52 <__any_on>
 8025302:	2800      	cmp	r0, #0
 8025304:	d1ed      	bne.n	80252e2 <__gethex+0x266>
 8025306:	4621      	mov	r1, r4
 8025308:	9801      	ldr	r0, [sp, #4]
 802530a:	f000 f9d9 	bl	80256c0 <_Bfree>
 802530e:	2300      	movs	r3, #0
 8025310:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
 8025312:	2550      	movs	r5, #80	@ 0x50
 8025314:	6013      	str	r3, [r2, #0]
 8025316:	e72b      	b.n	8025170 <__gethex+0xf4>
 8025318:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 802531a:	2b00      	cmp	r3, #0
 802531c:	d1f3      	bne.n	8025306 <__gethex+0x28a>
 802531e:	e7e0      	b.n	80252e2 <__gethex+0x266>
 8025320:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 8025322:	2b00      	cmp	r3, #0
 8025324:	d1dd      	bne.n	80252e2 <__gethex+0x266>
 8025326:	e7ee      	b.n	8025306 <__gethex+0x28a>
 8025328:	0802a8af 	.word	0x0802a8af
 802532c:	0802a993 	.word	0x0802a993
 8025330:	0802a9a4 	.word	0x0802a9a4
 8025334:	1e6f      	subs	r7, r5, #1
 8025336:	f1b9 0f00 	cmp.w	r9, #0
 802533a:	d130      	bne.n	802539e <__gethex+0x322>
 802533c:	b127      	cbz	r7, 8025348 <__gethex+0x2cc>
 802533e:	4639      	mov	r1, r7
 8025340:	4620      	mov	r0, r4
 8025342:	f000 fe06 	bl	8025f52 <__any_on>
 8025346:	4681      	mov	r9, r0
 8025348:	117a      	asrs	r2, r7, #5
 802534a:	2301      	movs	r3, #1
 802534c:	f007 071f 	and.w	r7, r7, #31
 8025350:	4629      	mov	r1, r5
 8025352:	f85a 2022 	ldr.w	r2, [sl, r2, lsl #2]
 8025356:	4620      	mov	r0, r4
 8025358:	40bb      	lsls	r3, r7
 802535a:	1b76      	subs	r6, r6, r5
 802535c:	2502      	movs	r5, #2
 802535e:	4213      	tst	r3, r2
 8025360:	bf18      	it	ne
 8025362:	f049 0902 	orrne.w	r9, r9, #2
 8025366:	f7ff fe23 	bl	8024fb0 <rshift>
 802536a:	f8d8 7004 	ldr.w	r7, [r8, #4]
 802536e:	f1b9 0f00 	cmp.w	r9, #0
 8025372:	d047      	beq.n	8025404 <__gethex+0x388>
 8025374:	f8d8 300c 	ldr.w	r3, [r8, #12]
 8025378:	2b02      	cmp	r3, #2
 802537a:	d015      	beq.n	80253a8 <__gethex+0x32c>
 802537c:	2b03      	cmp	r3, #3
 802537e:	d017      	beq.n	80253b0 <__gethex+0x334>
 8025380:	2b01      	cmp	r3, #1
 8025382:	d109      	bne.n	8025398 <__gethex+0x31c>
 8025384:	f019 0f02 	tst.w	r9, #2
 8025388:	d006      	beq.n	8025398 <__gethex+0x31c>
 802538a:	f8da 3000 	ldr.w	r3, [sl]
 802538e:	ea49 0903 	orr.w	r9, r9, r3
 8025392:	f019 0f01 	tst.w	r9, #1
 8025396:	d10e      	bne.n	80253b6 <__gethex+0x33a>
 8025398:	f045 0510 	orr.w	r5, r5, #16
 802539c:	e032      	b.n	8025404 <__gethex+0x388>
 802539e:	f04f 0901 	mov.w	r9, #1
 80253a2:	e7d1      	b.n	8025348 <__gethex+0x2cc>
 80253a4:	2501      	movs	r5, #1
 80253a6:	e7e2      	b.n	802536e <__gethex+0x2f2>
 80253a8:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 80253aa:	f1c3 0301 	rsb	r3, r3, #1
 80253ae:	930f      	str	r3, [sp, #60]	@ 0x3c
 80253b0:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 80253b2:	2b00      	cmp	r3, #0
 80253b4:	d0f0      	beq.n	8025398 <__gethex+0x31c>
 80253b6:	f8d4 b010 	ldr.w	fp, [r4, #16]
 80253ba:	f104 0314 	add.w	r3, r4, #20
 80253be:	f04f 0c00 	mov.w	ip, #0
 80253c2:	ea4f 0a8b 	mov.w	sl, fp, lsl #2
 80253c6:	eb03 018b 	add.w	r1, r3, fp, lsl #2
 80253ca:	4618      	mov	r0, r3
 80253cc:	f853 2b04 	ldr.w	r2, [r3], #4
 80253d0:	f1b2 3fff 	cmp.w	r2, #4294967295
 80253d4:	d01b      	beq.n	802540e <__gethex+0x392>
 80253d6:	3201      	adds	r2, #1
 80253d8:	6002      	str	r2, [r0, #0]
 80253da:	2d02      	cmp	r5, #2
 80253dc:	f104 0314 	add.w	r3, r4, #20
 80253e0:	d13c      	bne.n	802545c <__gethex+0x3e0>
 80253e2:	f8d8 2000 	ldr.w	r2, [r8]
 80253e6:	3a01      	subs	r2, #1
 80253e8:	42b2      	cmp	r2, r6
 80253ea:	d109      	bne.n	8025400 <__gethex+0x384>
 80253ec:	1171      	asrs	r1, r6, #5
 80253ee:	2201      	movs	r2, #1
 80253f0:	f006 061f 	and.w	r6, r6, #31
 80253f4:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 80253f8:	fa02 f606 	lsl.w	r6, r2, r6
 80253fc:	421e      	tst	r6, r3
 80253fe:	d13a      	bne.n	8025476 <__gethex+0x3fa>
 8025400:	f045 0520 	orr.w	r5, r5, #32
 8025404:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 8025406:	601c      	str	r4, [r3, #0]
 8025408:	9b02      	ldr	r3, [sp, #8]
 802540a:	601f      	str	r7, [r3, #0]
 802540c:	e6b0      	b.n	8025170 <__gethex+0xf4>
 802540e:	4299      	cmp	r1, r3
 8025410:	f843 cc04 	str.w	ip, [r3, #-4]
 8025414:	d8d9      	bhi.n	80253ca <__gethex+0x34e>
 8025416:	68a3      	ldr	r3, [r4, #8]
 8025418:	459b      	cmp	fp, r3
 802541a:	db17      	blt.n	802544c <__gethex+0x3d0>
 802541c:	6861      	ldr	r1, [r4, #4]
 802541e:	9801      	ldr	r0, [sp, #4]
 8025420:	3101      	adds	r1, #1
 8025422:	f000 f90d 	bl	8025640 <_Balloc>
 8025426:	4681      	mov	r9, r0
 8025428:	b918      	cbnz	r0, 8025432 <__gethex+0x3b6>
 802542a:	4b1a      	ldr	r3, [pc, #104]	@ (8025494 <__gethex+0x418>)
 802542c:	4602      	mov	r2, r0
 802542e:	2184      	movs	r1, #132	@ 0x84
 8025430:	e6c5      	b.n	80251be <__gethex+0x142>
 8025432:	6922      	ldr	r2, [r4, #16]
 8025434:	f104 010c 	add.w	r1, r4, #12
 8025438:	300c      	adds	r0, #12
 802543a:	3202      	adds	r2, #2
 802543c:	0092      	lsls	r2, r2, #2
 802543e:	f7fe fed6 	bl	80241ee <memcpy>
 8025442:	4621      	mov	r1, r4
 8025444:	464c      	mov	r4, r9
 8025446:	9801      	ldr	r0, [sp, #4]
 8025448:	f000 f93a 	bl	80256c0 <_Bfree>
 802544c:	6923      	ldr	r3, [r4, #16]
 802544e:	1c5a      	adds	r2, r3, #1
 8025450:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 8025454:	6122      	str	r2, [r4, #16]
 8025456:	2201      	movs	r2, #1
 8025458:	615a      	str	r2, [r3, #20]
 802545a:	e7be      	b.n	80253da <__gethex+0x35e>
 802545c:	6922      	ldr	r2, [r4, #16]
 802545e:	455a      	cmp	r2, fp
 8025460:	dd0b      	ble.n	802547a <__gethex+0x3fe>
 8025462:	2101      	movs	r1, #1
 8025464:	4620      	mov	r0, r4
 8025466:	f7ff fda3 	bl	8024fb0 <rshift>
 802546a:	3701      	adds	r7, #1
 802546c:	f8d8 3008 	ldr.w	r3, [r8, #8]
 8025470:	42bb      	cmp	r3, r7
 8025472:	f6ff aee0 	blt.w	8025236 <__gethex+0x1ba>
 8025476:	2501      	movs	r5, #1
 8025478:	e7c2      	b.n	8025400 <__gethex+0x384>
 802547a:	f016 061f 	ands.w	r6, r6, #31
 802547e:	d0fa      	beq.n	8025476 <__gethex+0x3fa>
 8025480:	4453      	add	r3, sl
 8025482:	f1c6 0620 	rsb	r6, r6, #32
 8025486:	f853 0c04 	ldr.w	r0, [r3, #-4]
 802548a:	f000 f9cd 	bl	8025828 <__hi0bits>
 802548e:	42b0      	cmp	r0, r6
 8025490:	dbe7      	blt.n	8025462 <__gethex+0x3e6>
 8025492:	e7f0      	b.n	8025476 <__gethex+0x3fa>
 8025494:	0802a993 	.word	0x0802a993

08025498 <L_shift>:
 8025498:	f1c2 0208 	rsb	r2, r2, #8
 802549c:	0092      	lsls	r2, r2, #2
 802549e:	b570      	push	{r4, r5, r6, lr}
 80254a0:	f1c2 0620 	rsb	r6, r2, #32
 80254a4:	6843      	ldr	r3, [r0, #4]
 80254a6:	6804      	ldr	r4, [r0, #0]
 80254a8:	fa03 f506 	lsl.w	r5, r3, r6
 80254ac:	40d3      	lsrs	r3, r2
 80254ae:	432c      	orrs	r4, r5
 80254b0:	6004      	str	r4, [r0, #0]
 80254b2:	f840 3f04 	str.w	r3, [r0, #4]!
 80254b6:	4288      	cmp	r0, r1
 80254b8:	d3f4      	bcc.n	80254a4 <L_shift+0xc>
 80254ba:	bd70      	pop	{r4, r5, r6, pc}

080254bc <__match>:
 80254bc:	6803      	ldr	r3, [r0, #0]
 80254be:	3301      	adds	r3, #1
 80254c0:	b530      	push	{r4, r5, lr}
 80254c2:	f811 4b01 	ldrb.w	r4, [r1], #1
 80254c6:	b914      	cbnz	r4, 80254ce <__match+0x12>
 80254c8:	6003      	str	r3, [r0, #0]
 80254ca:	2001      	movs	r0, #1
 80254cc:	bd30      	pop	{r4, r5, pc}
 80254ce:	f813 2b01 	ldrb.w	r2, [r3], #1
 80254d2:	f1a2 0541 	sub.w	r5, r2, #65	@ 0x41
 80254d6:	2d19      	cmp	r5, #25
 80254d8:	bf98      	it	ls
 80254da:	3220      	addls	r2, #32
 80254dc:	42a2      	cmp	r2, r4
 80254de:	d0f0      	beq.n	80254c2 <__match+0x6>
 80254e0:	2000      	movs	r0, #0
 80254e2:	e7f3      	b.n	80254cc <__match+0x10>

080254e4 <__hexnan>:
 80254e4:	680b      	ldr	r3, [r1, #0]
 80254e6:	6801      	ldr	r1, [r0, #0]
 80254e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80254ec:	115e      	asrs	r6, r3, #5
 80254ee:	f013 031f 	ands.w	r3, r3, #31
 80254f2:	f04f 0500 	mov.w	r5, #0
 80254f6:	b087      	sub	sp, #28
 80254f8:	eb02 0686 	add.w	r6, r2, r6, lsl #2
 80254fc:	4682      	mov	sl, r0
 80254fe:	4690      	mov	r8, r2
 8025500:	46ab      	mov	fp, r5
 8025502:	bf18      	it	ne
 8025504:	3604      	addne	r6, #4
 8025506:	9301      	str	r3, [sp, #4]
 8025508:	9502      	str	r5, [sp, #8]
 802550a:	1f37      	subs	r7, r6, #4
 802550c:	f846 5c04 	str.w	r5, [r6, #-4]
 8025510:	46b9      	mov	r9, r7
 8025512:	463c      	mov	r4, r7
 8025514:	1c4b      	adds	r3, r1, #1
 8025516:	784a      	ldrb	r2, [r1, #1]
 8025518:	9303      	str	r3, [sp, #12]
 802551a:	b342      	cbz	r2, 802556e <__hexnan+0x8a>
 802551c:	4610      	mov	r0, r2
 802551e:	9105      	str	r1, [sp, #20]
 8025520:	9204      	str	r2, [sp, #16]
 8025522:	f7ff fd96 	bl	8025052 <__hexdig_fun>
 8025526:	2800      	cmp	r0, #0
 8025528:	d151      	bne.n	80255ce <__hexnan+0xea>
 802552a:	9a04      	ldr	r2, [sp, #16]
 802552c:	9905      	ldr	r1, [sp, #20]
 802552e:	2a20      	cmp	r2, #32
 8025530:	d818      	bhi.n	8025564 <__hexnan+0x80>
 8025532:	9b02      	ldr	r3, [sp, #8]
 8025534:	459b      	cmp	fp, r3
 8025536:	dd13      	ble.n	8025560 <__hexnan+0x7c>
 8025538:	454c      	cmp	r4, r9
 802553a:	d206      	bcs.n	802554a <__hexnan+0x66>
 802553c:	2d07      	cmp	r5, #7
 802553e:	dc04      	bgt.n	802554a <__hexnan+0x66>
 8025540:	462a      	mov	r2, r5
 8025542:	4649      	mov	r1, r9
 8025544:	4620      	mov	r0, r4
 8025546:	f7ff ffa7 	bl	8025498 <L_shift>
 802554a:	4544      	cmp	r4, r8
 802554c:	d951      	bls.n	80255f2 <__hexnan+0x10e>
 802554e:	2300      	movs	r3, #0
 8025550:	f1a4 0904 	sub.w	r9, r4, #4
 8025554:	f8cd b008 	str.w	fp, [sp, #8]
 8025558:	f844 3c04 	str.w	r3, [r4, #-4]
 802555c:	461d      	mov	r5, r3
 802555e:	464c      	mov	r4, r9
 8025560:	9903      	ldr	r1, [sp, #12]
 8025562:	e7d7      	b.n	8025514 <__hexnan+0x30>
 8025564:	2a29      	cmp	r2, #41	@ 0x29
 8025566:	d156      	bne.n	8025616 <__hexnan+0x132>
 8025568:	3102      	adds	r1, #2
 802556a:	f8ca 1000 	str.w	r1, [sl]
 802556e:	f1bb 0f00 	cmp.w	fp, #0
 8025572:	d050      	beq.n	8025616 <__hexnan+0x132>
 8025574:	454c      	cmp	r4, r9
 8025576:	d206      	bcs.n	8025586 <__hexnan+0xa2>
 8025578:	2d07      	cmp	r5, #7
 802557a:	dc04      	bgt.n	8025586 <__hexnan+0xa2>
 802557c:	462a      	mov	r2, r5
 802557e:	4649      	mov	r1, r9
 8025580:	4620      	mov	r0, r4
 8025582:	f7ff ff89 	bl	8025498 <L_shift>
 8025586:	4544      	cmp	r4, r8
 8025588:	d935      	bls.n	80255f6 <__hexnan+0x112>
 802558a:	f1a8 0204 	sub.w	r2, r8, #4
 802558e:	4623      	mov	r3, r4
 8025590:	f853 1b04 	ldr.w	r1, [r3], #4
 8025594:	429f      	cmp	r7, r3
 8025596:	f842 1f04 	str.w	r1, [r2, #4]!
 802559a:	d2f9      	bcs.n	8025590 <__hexnan+0xac>
 802559c:	1b3b      	subs	r3, r7, r4
 802559e:	3e03      	subs	r6, #3
 80255a0:	3401      	adds	r4, #1
 80255a2:	2200      	movs	r2, #0
 80255a4:	f023 0303 	bic.w	r3, r3, #3
 80255a8:	3304      	adds	r3, #4
 80255aa:	42b4      	cmp	r4, r6
 80255ac:	bf88      	it	hi
 80255ae:	2304      	movhi	r3, #4
 80255b0:	4443      	add	r3, r8
 80255b2:	f843 2b04 	str.w	r2, [r3], #4
 80255b6:	429f      	cmp	r7, r3
 80255b8:	d2fb      	bcs.n	80255b2 <__hexnan+0xce>
 80255ba:	683b      	ldr	r3, [r7, #0]
 80255bc:	b91b      	cbnz	r3, 80255c6 <__hexnan+0xe2>
 80255be:	4547      	cmp	r7, r8
 80255c0:	d127      	bne.n	8025612 <__hexnan+0x12e>
 80255c2:	2301      	movs	r3, #1
 80255c4:	603b      	str	r3, [r7, #0]
 80255c6:	2005      	movs	r0, #5
 80255c8:	b007      	add	sp, #28
 80255ca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80255ce:	3501      	adds	r5, #1
 80255d0:	f10b 0b01 	add.w	fp, fp, #1
 80255d4:	2d08      	cmp	r5, #8
 80255d6:	dd05      	ble.n	80255e4 <__hexnan+0x100>
 80255d8:	4544      	cmp	r4, r8
 80255da:	d9c1      	bls.n	8025560 <__hexnan+0x7c>
 80255dc:	2300      	movs	r3, #0
 80255de:	3c04      	subs	r4, #4
 80255e0:	2501      	movs	r5, #1
 80255e2:	6023      	str	r3, [r4, #0]
 80255e4:	6822      	ldr	r2, [r4, #0]
 80255e6:	f000 000f 	and.w	r0, r0, #15
 80255ea:	ea40 1002 	orr.w	r0, r0, r2, lsl #4
 80255ee:	6020      	str	r0, [r4, #0]
 80255f0:	e7b6      	b.n	8025560 <__hexnan+0x7c>
 80255f2:	2508      	movs	r5, #8
 80255f4:	e7b4      	b.n	8025560 <__hexnan+0x7c>
 80255f6:	9b01      	ldr	r3, [sp, #4]
 80255f8:	2b00      	cmp	r3, #0
 80255fa:	d0de      	beq.n	80255ba <__hexnan+0xd6>
 80255fc:	f1c3 0320 	rsb	r3, r3, #32
 8025600:	f04f 32ff 	mov.w	r2, #4294967295
 8025604:	40da      	lsrs	r2, r3
 8025606:	f856 3c04 	ldr.w	r3, [r6, #-4]
 802560a:	4013      	ands	r3, r2
 802560c:	f846 3c04 	str.w	r3, [r6, #-4]
 8025610:	e7d3      	b.n	80255ba <__hexnan+0xd6>
 8025612:	3f04      	subs	r7, #4
 8025614:	e7d1      	b.n	80255ba <__hexnan+0xd6>
 8025616:	2004      	movs	r0, #4
 8025618:	e7d6      	b.n	80255c8 <__hexnan+0xe4>

0802561a <__ascii_mbtowc>:
 802561a:	b082      	sub	sp, #8
 802561c:	b901      	cbnz	r1, 8025620 <__ascii_mbtowc+0x6>
 802561e:	a901      	add	r1, sp, #4
 8025620:	b142      	cbz	r2, 8025634 <__ascii_mbtowc+0x1a>
 8025622:	b14b      	cbz	r3, 8025638 <__ascii_mbtowc+0x1e>
 8025624:	7813      	ldrb	r3, [r2, #0]
 8025626:	600b      	str	r3, [r1, #0]
 8025628:	7812      	ldrb	r2, [r2, #0]
 802562a:	1e10      	subs	r0, r2, #0
 802562c:	bf18      	it	ne
 802562e:	2001      	movne	r0, #1
 8025630:	b002      	add	sp, #8
 8025632:	4770      	bx	lr
 8025634:	4610      	mov	r0, r2
 8025636:	e7fb      	b.n	8025630 <__ascii_mbtowc+0x16>
 8025638:	f06f 0001 	mvn.w	r0, #1
 802563c:	e7f8      	b.n	8025630 <__ascii_mbtowc+0x16>
	...

08025640 <_Balloc>:
 8025640:	b570      	push	{r4, r5, r6, lr}
 8025642:	69c6      	ldr	r6, [r0, #28]
 8025644:	4604      	mov	r4, r0
 8025646:	460d      	mov	r5, r1
 8025648:	b976      	cbnz	r6, 8025668 <_Balloc+0x28>
 802564a:	2010      	movs	r0, #16
 802564c:	f7fc fcbc 	bl	8021fc8 <malloc>
 8025650:	4602      	mov	r2, r0
 8025652:	61e0      	str	r0, [r4, #28]
 8025654:	b920      	cbnz	r0, 8025660 <_Balloc+0x20>
 8025656:	4b18      	ldr	r3, [pc, #96]	@ (80256b8 <_Balloc+0x78>)
 8025658:	216b      	movs	r1, #107	@ 0x6b
 802565a:	4818      	ldr	r0, [pc, #96]	@ (80256bc <_Balloc+0x7c>)
 802565c:	f7fe fdde 	bl	802421c <__assert_func>
 8025660:	e9c0 6601 	strd	r6, r6, [r0, #4]
 8025664:	6006      	str	r6, [r0, #0]
 8025666:	60c6      	str	r6, [r0, #12]
 8025668:	69e6      	ldr	r6, [r4, #28]
 802566a:	68f3      	ldr	r3, [r6, #12]
 802566c:	b183      	cbz	r3, 8025690 <_Balloc+0x50>
 802566e:	69e3      	ldr	r3, [r4, #28]
 8025670:	68db      	ldr	r3, [r3, #12]
 8025672:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
 8025676:	b9b8      	cbnz	r0, 80256a8 <_Balloc+0x68>
 8025678:	2101      	movs	r1, #1
 802567a:	4620      	mov	r0, r4
 802567c:	fa01 f605 	lsl.w	r6, r1, r5
 8025680:	1d72      	adds	r2, r6, #5
 8025682:	0092      	lsls	r2, r2, #2
 8025684:	f001 f845 	bl	8026712 <_calloc_r>
 8025688:	b160      	cbz	r0, 80256a4 <_Balloc+0x64>
 802568a:	e9c0 5601 	strd	r5, r6, [r0, #4]
 802568e:	e00e      	b.n	80256ae <_Balloc+0x6e>
 8025690:	2221      	movs	r2, #33	@ 0x21
 8025692:	2104      	movs	r1, #4
 8025694:	4620      	mov	r0, r4
 8025696:	f001 f83c 	bl	8026712 <_calloc_r>
 802569a:	69e3      	ldr	r3, [r4, #28]
 802569c:	60f0      	str	r0, [r6, #12]
 802569e:	68db      	ldr	r3, [r3, #12]
 80256a0:	2b00      	cmp	r3, #0
 80256a2:	d1e4      	bne.n	802566e <_Balloc+0x2e>
 80256a4:	2000      	movs	r0, #0
 80256a6:	bd70      	pop	{r4, r5, r6, pc}
 80256a8:	6802      	ldr	r2, [r0, #0]
 80256aa:	f843 2025 	str.w	r2, [r3, r5, lsl #2]
 80256ae:	2300      	movs	r3, #0
 80256b0:	e9c0 3303 	strd	r3, r3, [r0, #12]
 80256b4:	e7f7      	b.n	80256a6 <_Balloc+0x66>
 80256b6:	bf00      	nop
 80256b8:	0802a840 	.word	0x0802a840
 80256bc:	0802aa04 	.word	0x0802aa04

080256c0 <_Bfree>:
 80256c0:	b570      	push	{r4, r5, r6, lr}
 80256c2:	69c6      	ldr	r6, [r0, #28]
 80256c4:	4605      	mov	r5, r0
 80256c6:	460c      	mov	r4, r1
 80256c8:	b976      	cbnz	r6, 80256e8 <_Bfree+0x28>
 80256ca:	2010      	movs	r0, #16
 80256cc:	f7fc fc7c 	bl	8021fc8 <malloc>
 80256d0:	4602      	mov	r2, r0
 80256d2:	61e8      	str	r0, [r5, #28]
 80256d4:	b920      	cbnz	r0, 80256e0 <_Bfree+0x20>
 80256d6:	4b09      	ldr	r3, [pc, #36]	@ (80256fc <_Bfree+0x3c>)
 80256d8:	218f      	movs	r1, #143	@ 0x8f
 80256da:	4809      	ldr	r0, [pc, #36]	@ (8025700 <_Bfree+0x40>)
 80256dc:	f7fe fd9e 	bl	802421c <__assert_func>
 80256e0:	e9c0 6601 	strd	r6, r6, [r0, #4]
 80256e4:	6006      	str	r6, [r0, #0]
 80256e6:	60c6      	str	r6, [r0, #12]
 80256e8:	b13c      	cbz	r4, 80256fa <_Bfree+0x3a>
 80256ea:	69eb      	ldr	r3, [r5, #28]
 80256ec:	6862      	ldr	r2, [r4, #4]
 80256ee:	68db      	ldr	r3, [r3, #12]
 80256f0:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 80256f4:	6021      	str	r1, [r4, #0]
 80256f6:	f843 4022 	str.w	r4, [r3, r2, lsl #2]
 80256fa:	bd70      	pop	{r4, r5, r6, pc}
 80256fc:	0802a840 	.word	0x0802a840
 8025700:	0802aa04 	.word	0x0802aa04

08025704 <__multadd>:
 8025704:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8025708:	f101 0c14 	add.w	ip, r1, #20
 802570c:	4607      	mov	r7, r0
 802570e:	460c      	mov	r4, r1
 8025710:	461e      	mov	r6, r3
 8025712:	690d      	ldr	r5, [r1, #16]
 8025714:	2000      	movs	r0, #0
 8025716:	f8dc 3000 	ldr.w	r3, [ip]
 802571a:	3001      	adds	r0, #1
 802571c:	b299      	uxth	r1, r3
 802571e:	4285      	cmp	r5, r0
 8025720:	fb02 6101 	mla	r1, r2, r1, r6
 8025724:	ea4f 4613 	mov.w	r6, r3, lsr #16
 8025728:	ea4f 4311 	mov.w	r3, r1, lsr #16
 802572c:	b289      	uxth	r1, r1
 802572e:	fb02 3306 	mla	r3, r2, r6, r3
 8025732:	eb01 4103 	add.w	r1, r1, r3, lsl #16
 8025736:	ea4f 4613 	mov.w	r6, r3, lsr #16
 802573a:	f84c 1b04 	str.w	r1, [ip], #4
 802573e:	dcea      	bgt.n	8025716 <__multadd+0x12>
 8025740:	b30e      	cbz	r6, 8025786 <__multadd+0x82>
 8025742:	68a3      	ldr	r3, [r4, #8]
 8025744:	42ab      	cmp	r3, r5
 8025746:	dc19      	bgt.n	802577c <__multadd+0x78>
 8025748:	6861      	ldr	r1, [r4, #4]
 802574a:	4638      	mov	r0, r7
 802574c:	3101      	adds	r1, #1
 802574e:	f7ff ff77 	bl	8025640 <_Balloc>
 8025752:	4680      	mov	r8, r0
 8025754:	b928      	cbnz	r0, 8025762 <__multadd+0x5e>
 8025756:	4602      	mov	r2, r0
 8025758:	4b0c      	ldr	r3, [pc, #48]	@ (802578c <__multadd+0x88>)
 802575a:	21ba      	movs	r1, #186	@ 0xba
 802575c:	480c      	ldr	r0, [pc, #48]	@ (8025790 <__multadd+0x8c>)
 802575e:	f7fe fd5d 	bl	802421c <__assert_func>
 8025762:	6922      	ldr	r2, [r4, #16]
 8025764:	f104 010c 	add.w	r1, r4, #12
 8025768:	300c      	adds	r0, #12
 802576a:	3202      	adds	r2, #2
 802576c:	0092      	lsls	r2, r2, #2
 802576e:	f7fe fd3e 	bl	80241ee <memcpy>
 8025772:	4621      	mov	r1, r4
 8025774:	4644      	mov	r4, r8
 8025776:	4638      	mov	r0, r7
 8025778:	f7ff ffa2 	bl	80256c0 <_Bfree>
 802577c:	eb04 0385 	add.w	r3, r4, r5, lsl #2
 8025780:	3501      	adds	r5, #1
 8025782:	615e      	str	r6, [r3, #20]
 8025784:	6125      	str	r5, [r4, #16]
 8025786:	4620      	mov	r0, r4
 8025788:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802578c:	0802a993 	.word	0x0802a993
 8025790:	0802aa04 	.word	0x0802aa04

08025794 <__s2b>:
 8025794:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8025798:	4615      	mov	r5, r2
 802579a:	461f      	mov	r7, r3
 802579c:	2209      	movs	r2, #9
 802579e:	3308      	adds	r3, #8
 80257a0:	460c      	mov	r4, r1
 80257a2:	4606      	mov	r6, r0
 80257a4:	2100      	movs	r1, #0
 80257a6:	fb93 f3f2 	sdiv	r3, r3, r2
 80257aa:	2201      	movs	r2, #1
 80257ac:	429a      	cmp	r2, r3
 80257ae:	db09      	blt.n	80257c4 <__s2b+0x30>
 80257b0:	4630      	mov	r0, r6
 80257b2:	f7ff ff45 	bl	8025640 <_Balloc>
 80257b6:	b940      	cbnz	r0, 80257ca <__s2b+0x36>
 80257b8:	4602      	mov	r2, r0
 80257ba:	4b19      	ldr	r3, [pc, #100]	@ (8025820 <__s2b+0x8c>)
 80257bc:	21d3      	movs	r1, #211	@ 0xd3
 80257be:	4819      	ldr	r0, [pc, #100]	@ (8025824 <__s2b+0x90>)
 80257c0:	f7fe fd2c 	bl	802421c <__assert_func>
 80257c4:	0052      	lsls	r2, r2, #1
 80257c6:	3101      	adds	r1, #1
 80257c8:	e7f0      	b.n	80257ac <__s2b+0x18>
 80257ca:	9b08      	ldr	r3, [sp, #32]
 80257cc:	2d09      	cmp	r5, #9
 80257ce:	6143      	str	r3, [r0, #20]
 80257d0:	f04f 0301 	mov.w	r3, #1
 80257d4:	6103      	str	r3, [r0, #16]
 80257d6:	dd16      	ble.n	8025806 <__s2b+0x72>
 80257d8:	f104 0909 	add.w	r9, r4, #9
 80257dc:	442c      	add	r4, r5
 80257de:	46c8      	mov	r8, r9
 80257e0:	f818 3b01 	ldrb.w	r3, [r8], #1
 80257e4:	4601      	mov	r1, r0
 80257e6:	220a      	movs	r2, #10
 80257e8:	4630      	mov	r0, r6
 80257ea:	3b30      	subs	r3, #48	@ 0x30
 80257ec:	f7ff ff8a 	bl	8025704 <__multadd>
 80257f0:	45a0      	cmp	r8, r4
 80257f2:	d1f5      	bne.n	80257e0 <__s2b+0x4c>
 80257f4:	f1a5 0408 	sub.w	r4, r5, #8
 80257f8:	444c      	add	r4, r9
 80257fa:	1b2d      	subs	r5, r5, r4
 80257fc:	1963      	adds	r3, r4, r5
 80257fe:	42bb      	cmp	r3, r7
 8025800:	db04      	blt.n	802580c <__s2b+0x78>
 8025802:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8025806:	340a      	adds	r4, #10
 8025808:	2509      	movs	r5, #9
 802580a:	e7f6      	b.n	80257fa <__s2b+0x66>
 802580c:	f814 3b01 	ldrb.w	r3, [r4], #1
 8025810:	4601      	mov	r1, r0
 8025812:	220a      	movs	r2, #10
 8025814:	4630      	mov	r0, r6
 8025816:	3b30      	subs	r3, #48	@ 0x30
 8025818:	f7ff ff74 	bl	8025704 <__multadd>
 802581c:	e7ee      	b.n	80257fc <__s2b+0x68>
 802581e:	bf00      	nop
 8025820:	0802a993 	.word	0x0802a993
 8025824:	0802aa04 	.word	0x0802aa04

08025828 <__hi0bits>:
 8025828:	f5b0 3f80 	cmp.w	r0, #65536	@ 0x10000
 802582c:	4603      	mov	r3, r0
 802582e:	bf36      	itet	cc
 8025830:	0403      	lslcc	r3, r0, #16
 8025832:	2000      	movcs	r0, #0
 8025834:	2010      	movcc	r0, #16
 8025836:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
 802583a:	bf3c      	itt	cc
 802583c:	021b      	lslcc	r3, r3, #8
 802583e:	3008      	addcc	r0, #8
 8025840:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 8025844:	bf3c      	itt	cc
 8025846:	011b      	lslcc	r3, r3, #4
 8025848:	3004      	addcc	r0, #4
 802584a:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 802584e:	bf3c      	itt	cc
 8025850:	009b      	lslcc	r3, r3, #2
 8025852:	3002      	addcc	r0, #2
 8025854:	2b00      	cmp	r3, #0
 8025856:	db05      	blt.n	8025864 <__hi0bits+0x3c>
 8025858:	f013 4f80 	tst.w	r3, #1073741824	@ 0x40000000
 802585c:	f100 0001 	add.w	r0, r0, #1
 8025860:	bf08      	it	eq
 8025862:	2020      	moveq	r0, #32
 8025864:	4770      	bx	lr

08025866 <__lo0bits>:
 8025866:	6803      	ldr	r3, [r0, #0]
 8025868:	4602      	mov	r2, r0
 802586a:	f013 0007 	ands.w	r0, r3, #7
 802586e:	d00b      	beq.n	8025888 <__lo0bits+0x22>
 8025870:	07d9      	lsls	r1, r3, #31
 8025872:	d421      	bmi.n	80258b8 <__lo0bits+0x52>
 8025874:	0798      	lsls	r0, r3, #30
 8025876:	bf47      	ittee	mi
 8025878:	085b      	lsrmi	r3, r3, #1
 802587a:	2001      	movmi	r0, #1
 802587c:	089b      	lsrpl	r3, r3, #2
 802587e:	2002      	movpl	r0, #2
 8025880:	bf4c      	ite	mi
 8025882:	6013      	strmi	r3, [r2, #0]
 8025884:	6013      	strpl	r3, [r2, #0]
 8025886:	4770      	bx	lr
 8025888:	b299      	uxth	r1, r3
 802588a:	b909      	cbnz	r1, 8025890 <__lo0bits+0x2a>
 802588c:	0c1b      	lsrs	r3, r3, #16
 802588e:	2010      	movs	r0, #16
 8025890:	b2d9      	uxtb	r1, r3
 8025892:	b909      	cbnz	r1, 8025898 <__lo0bits+0x32>
 8025894:	3008      	adds	r0, #8
 8025896:	0a1b      	lsrs	r3, r3, #8
 8025898:	0719      	lsls	r1, r3, #28
 802589a:	bf04      	itt	eq
 802589c:	091b      	lsreq	r3, r3, #4
 802589e:	3004      	addeq	r0, #4
 80258a0:	0799      	lsls	r1, r3, #30
 80258a2:	bf04      	itt	eq
 80258a4:	089b      	lsreq	r3, r3, #2
 80258a6:	3002      	addeq	r0, #2
 80258a8:	07d9      	lsls	r1, r3, #31
 80258aa:	d403      	bmi.n	80258b4 <__lo0bits+0x4e>
 80258ac:	085b      	lsrs	r3, r3, #1
 80258ae:	f100 0001 	add.w	r0, r0, #1
 80258b2:	d003      	beq.n	80258bc <__lo0bits+0x56>
 80258b4:	6013      	str	r3, [r2, #0]
 80258b6:	4770      	bx	lr
 80258b8:	2000      	movs	r0, #0
 80258ba:	4770      	bx	lr
 80258bc:	2020      	movs	r0, #32
 80258be:	4770      	bx	lr

080258c0 <__i2b>:
 80258c0:	b510      	push	{r4, lr}
 80258c2:	460c      	mov	r4, r1
 80258c4:	2101      	movs	r1, #1
 80258c6:	f7ff febb 	bl	8025640 <_Balloc>
 80258ca:	4602      	mov	r2, r0
 80258cc:	b928      	cbnz	r0, 80258da <__i2b+0x1a>
 80258ce:	4b05      	ldr	r3, [pc, #20]	@ (80258e4 <__i2b+0x24>)
 80258d0:	f240 1145 	movw	r1, #325	@ 0x145
 80258d4:	4804      	ldr	r0, [pc, #16]	@ (80258e8 <__i2b+0x28>)
 80258d6:	f7fe fca1 	bl	802421c <__assert_func>
 80258da:	2301      	movs	r3, #1
 80258dc:	6144      	str	r4, [r0, #20]
 80258de:	6103      	str	r3, [r0, #16]
 80258e0:	bd10      	pop	{r4, pc}
 80258e2:	bf00      	nop
 80258e4:	0802a993 	.word	0x0802a993
 80258e8:	0802aa04 	.word	0x0802aa04

080258ec <__multiply>:
 80258ec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80258f0:	4617      	mov	r7, r2
 80258f2:	690a      	ldr	r2, [r1, #16]
 80258f4:	4689      	mov	r9, r1
 80258f6:	b085      	sub	sp, #20
 80258f8:	693b      	ldr	r3, [r7, #16]
 80258fa:	429a      	cmp	r2, r3
 80258fc:	bfa2      	ittt	ge
 80258fe:	463b      	movge	r3, r7
 8025900:	460f      	movge	r7, r1
 8025902:	4699      	movge	r9, r3
 8025904:	693d      	ldr	r5, [r7, #16]
 8025906:	68bb      	ldr	r3, [r7, #8]
 8025908:	f8d9 a010 	ldr.w	sl, [r9, #16]
 802590c:	6879      	ldr	r1, [r7, #4]
 802590e:	eb05 060a 	add.w	r6, r5, sl
 8025912:	42b3      	cmp	r3, r6
 8025914:	bfb8      	it	lt
 8025916:	3101      	addlt	r1, #1
 8025918:	f7ff fe92 	bl	8025640 <_Balloc>
 802591c:	b930      	cbnz	r0, 802592c <__multiply+0x40>
 802591e:	4602      	mov	r2, r0
 8025920:	4b42      	ldr	r3, [pc, #264]	@ (8025a2c <__multiply+0x140>)
 8025922:	f44f 71b1 	mov.w	r1, #354	@ 0x162
 8025926:	4842      	ldr	r0, [pc, #264]	@ (8025a30 <__multiply+0x144>)
 8025928:	f7fe fc78 	bl	802421c <__assert_func>
 802592c:	f100 0414 	add.w	r4, r0, #20
 8025930:	2200      	movs	r2, #0
 8025932:	eb04 0e86 	add.w	lr, r4, r6, lsl #2
 8025936:	4623      	mov	r3, r4
 8025938:	4573      	cmp	r3, lr
 802593a:	d320      	bcc.n	802597e <__multiply+0x92>
 802593c:	f107 0814 	add.w	r8, r7, #20
 8025940:	f109 0114 	add.w	r1, r9, #20
 8025944:	eb08 0585 	add.w	r5, r8, r5, lsl #2
 8025948:	eb01 038a 	add.w	r3, r1, sl, lsl #2
 802594c:	9302      	str	r3, [sp, #8]
 802594e:	1beb      	subs	r3, r5, r7
 8025950:	3715      	adds	r7, #21
 8025952:	3b15      	subs	r3, #21
 8025954:	f023 0303 	bic.w	r3, r3, #3
 8025958:	3304      	adds	r3, #4
 802595a:	42bd      	cmp	r5, r7
 802595c:	bf38      	it	cc
 802595e:	2304      	movcc	r3, #4
 8025960:	9301      	str	r3, [sp, #4]
 8025962:	9b02      	ldr	r3, [sp, #8]
 8025964:	9103      	str	r1, [sp, #12]
 8025966:	428b      	cmp	r3, r1
 8025968:	d80c      	bhi.n	8025984 <__multiply+0x98>
 802596a:	2e00      	cmp	r6, #0
 802596c:	dd03      	ble.n	8025976 <__multiply+0x8a>
 802596e:	f85e 3d04 	ldr.w	r3, [lr, #-4]!
 8025972:	2b00      	cmp	r3, #0
 8025974:	d057      	beq.n	8025a26 <__multiply+0x13a>
 8025976:	6106      	str	r6, [r0, #16]
 8025978:	b005      	add	sp, #20
 802597a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802597e:	f843 2b04 	str.w	r2, [r3], #4
 8025982:	e7d9      	b.n	8025938 <__multiply+0x4c>
 8025984:	f8b1 a000 	ldrh.w	sl, [r1]
 8025988:	f1ba 0f00 	cmp.w	sl, #0
 802598c:	d021      	beq.n	80259d2 <__multiply+0xe6>
 802598e:	46c4      	mov	ip, r8
 8025990:	46a1      	mov	r9, r4
 8025992:	2700      	movs	r7, #0
 8025994:	f85c 2b04 	ldr.w	r2, [ip], #4
 8025998:	f8d9 3000 	ldr.w	r3, [r9]
 802599c:	fa1f fb82 	uxth.w	fp, r2
 80259a0:	4565      	cmp	r5, ip
 80259a2:	b29b      	uxth	r3, r3
 80259a4:	ea4f 4212 	mov.w	r2, r2, lsr #16
 80259a8:	fb0a 330b 	mla	r3, sl, fp, r3
 80259ac:	443b      	add	r3, r7
 80259ae:	f8d9 7000 	ldr.w	r7, [r9]
 80259b2:	ea4f 4717 	mov.w	r7, r7, lsr #16
 80259b6:	fb0a 7202 	mla	r2, sl, r2, r7
 80259ba:	eb02 4213 	add.w	r2, r2, r3, lsr #16
 80259be:	b29b      	uxth	r3, r3
 80259c0:	ea4f 4712 	mov.w	r7, r2, lsr #16
 80259c4:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 80259c8:	f849 3b04 	str.w	r3, [r9], #4
 80259cc:	d8e2      	bhi.n	8025994 <__multiply+0xa8>
 80259ce:	9b01      	ldr	r3, [sp, #4]
 80259d0:	50e7      	str	r7, [r4, r3]
 80259d2:	9b03      	ldr	r3, [sp, #12]
 80259d4:	3104      	adds	r1, #4
 80259d6:	f8b3 9002 	ldrh.w	r9, [r3, #2]
 80259da:	f1b9 0f00 	cmp.w	r9, #0
 80259de:	d020      	beq.n	8025a22 <__multiply+0x136>
 80259e0:	6823      	ldr	r3, [r4, #0]
 80259e2:	4647      	mov	r7, r8
 80259e4:	46a4      	mov	ip, r4
 80259e6:	f04f 0a00 	mov.w	sl, #0
 80259ea:	f8b7 b000 	ldrh.w	fp, [r7]
 80259ee:	b29b      	uxth	r3, r3
 80259f0:	f8bc 2002 	ldrh.w	r2, [ip, #2]
 80259f4:	fb09 220b 	mla	r2, r9, fp, r2
 80259f8:	4452      	add	r2, sl
 80259fa:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 80259fe:	f84c 3b04 	str.w	r3, [ip], #4
 8025a02:	f857 3b04 	ldr.w	r3, [r7], #4
 8025a06:	ea4f 4a13 	mov.w	sl, r3, lsr #16
 8025a0a:	f8bc 3000 	ldrh.w	r3, [ip]
 8025a0e:	42bd      	cmp	r5, r7
 8025a10:	fb09 330a 	mla	r3, r9, sl, r3
 8025a14:	eb03 4312 	add.w	r3, r3, r2, lsr #16
 8025a18:	ea4f 4a13 	mov.w	sl, r3, lsr #16
 8025a1c:	d8e5      	bhi.n	80259ea <__multiply+0xfe>
 8025a1e:	9a01      	ldr	r2, [sp, #4]
 8025a20:	50a3      	str	r3, [r4, r2]
 8025a22:	3404      	adds	r4, #4
 8025a24:	e79d      	b.n	8025962 <__multiply+0x76>
 8025a26:	3e01      	subs	r6, #1
 8025a28:	e79f      	b.n	802596a <__multiply+0x7e>
 8025a2a:	bf00      	nop
 8025a2c:	0802a993 	.word	0x0802a993
 8025a30:	0802aa04 	.word	0x0802aa04

08025a34 <__pow5mult>:
 8025a34:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8025a38:	4615      	mov	r5, r2
 8025a3a:	f012 0203 	ands.w	r2, r2, #3
 8025a3e:	4607      	mov	r7, r0
 8025a40:	460e      	mov	r6, r1
 8025a42:	d007      	beq.n	8025a54 <__pow5mult+0x20>
 8025a44:	3a01      	subs	r2, #1
 8025a46:	4c25      	ldr	r4, [pc, #148]	@ (8025adc <__pow5mult+0xa8>)
 8025a48:	2300      	movs	r3, #0
 8025a4a:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
 8025a4e:	f7ff fe59 	bl	8025704 <__multadd>
 8025a52:	4606      	mov	r6, r0
 8025a54:	10ad      	asrs	r5, r5, #2
 8025a56:	d03d      	beq.n	8025ad4 <__pow5mult+0xa0>
 8025a58:	69fc      	ldr	r4, [r7, #28]
 8025a5a:	b97c      	cbnz	r4, 8025a7c <__pow5mult+0x48>
 8025a5c:	2010      	movs	r0, #16
 8025a5e:	f7fc fab3 	bl	8021fc8 <malloc>
 8025a62:	4602      	mov	r2, r0
 8025a64:	61f8      	str	r0, [r7, #28]
 8025a66:	b928      	cbnz	r0, 8025a74 <__pow5mult+0x40>
 8025a68:	4b1d      	ldr	r3, [pc, #116]	@ (8025ae0 <__pow5mult+0xac>)
 8025a6a:	f240 11b3 	movw	r1, #435	@ 0x1b3
 8025a6e:	481d      	ldr	r0, [pc, #116]	@ (8025ae4 <__pow5mult+0xb0>)
 8025a70:	f7fe fbd4 	bl	802421c <__assert_func>
 8025a74:	e9c0 4401 	strd	r4, r4, [r0, #4]
 8025a78:	6004      	str	r4, [r0, #0]
 8025a7a:	60c4      	str	r4, [r0, #12]
 8025a7c:	f8d7 801c 	ldr.w	r8, [r7, #28]
 8025a80:	f8d8 4008 	ldr.w	r4, [r8, #8]
 8025a84:	b94c      	cbnz	r4, 8025a9a <__pow5mult+0x66>
 8025a86:	f240 2171 	movw	r1, #625	@ 0x271
 8025a8a:	4638      	mov	r0, r7
 8025a8c:	f7ff ff18 	bl	80258c0 <__i2b>
 8025a90:	2300      	movs	r3, #0
 8025a92:	4604      	mov	r4, r0
 8025a94:	f8c8 0008 	str.w	r0, [r8, #8]
 8025a98:	6003      	str	r3, [r0, #0]
 8025a9a:	f04f 0900 	mov.w	r9, #0
 8025a9e:	07eb      	lsls	r3, r5, #31
 8025aa0:	d50a      	bpl.n	8025ab8 <__pow5mult+0x84>
 8025aa2:	4631      	mov	r1, r6
 8025aa4:	4622      	mov	r2, r4
 8025aa6:	4638      	mov	r0, r7
 8025aa8:	f7ff ff20 	bl	80258ec <__multiply>
 8025aac:	4680      	mov	r8, r0
 8025aae:	4631      	mov	r1, r6
 8025ab0:	4638      	mov	r0, r7
 8025ab2:	4646      	mov	r6, r8
 8025ab4:	f7ff fe04 	bl	80256c0 <_Bfree>
 8025ab8:	106d      	asrs	r5, r5, #1
 8025aba:	d00b      	beq.n	8025ad4 <__pow5mult+0xa0>
 8025abc:	6820      	ldr	r0, [r4, #0]
 8025abe:	b938      	cbnz	r0, 8025ad0 <__pow5mult+0x9c>
 8025ac0:	4622      	mov	r2, r4
 8025ac2:	4621      	mov	r1, r4
 8025ac4:	4638      	mov	r0, r7
 8025ac6:	f7ff ff11 	bl	80258ec <__multiply>
 8025aca:	6020      	str	r0, [r4, #0]
 8025acc:	f8c0 9000 	str.w	r9, [r0]
 8025ad0:	4604      	mov	r4, r0
 8025ad2:	e7e4      	b.n	8025a9e <__pow5mult+0x6a>
 8025ad4:	4630      	mov	r0, r6
 8025ad6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8025ada:	bf00      	nop
 8025adc:	0802abc4 	.word	0x0802abc4
 8025ae0:	0802a840 	.word	0x0802a840
 8025ae4:	0802aa04 	.word	0x0802aa04

08025ae8 <__lshift>:
 8025ae8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8025aec:	460c      	mov	r4, r1
 8025aee:	4607      	mov	r7, r0
 8025af0:	4691      	mov	r9, r2
 8025af2:	ea4f 1a62 	mov.w	sl, r2, asr #5
 8025af6:	6923      	ldr	r3, [r4, #16]
 8025af8:	6849      	ldr	r1, [r1, #4]
 8025afa:	eb03 1862 	add.w	r8, r3, r2, asr #5
 8025afe:	68a3      	ldr	r3, [r4, #8]
 8025b00:	f108 0601 	add.w	r6, r8, #1
 8025b04:	42b3      	cmp	r3, r6
 8025b06:	db0b      	blt.n	8025b20 <__lshift+0x38>
 8025b08:	4638      	mov	r0, r7
 8025b0a:	f7ff fd99 	bl	8025640 <_Balloc>
 8025b0e:	4605      	mov	r5, r0
 8025b10:	b948      	cbnz	r0, 8025b26 <__lshift+0x3e>
 8025b12:	4602      	mov	r2, r0
 8025b14:	4b28      	ldr	r3, [pc, #160]	@ (8025bb8 <__lshift+0xd0>)
 8025b16:	f44f 71ef 	mov.w	r1, #478	@ 0x1de
 8025b1a:	4828      	ldr	r0, [pc, #160]	@ (8025bbc <__lshift+0xd4>)
 8025b1c:	f7fe fb7e 	bl	802421c <__assert_func>
 8025b20:	3101      	adds	r1, #1
 8025b22:	005b      	lsls	r3, r3, #1
 8025b24:	e7ee      	b.n	8025b04 <__lshift+0x1c>
 8025b26:	2300      	movs	r3, #0
 8025b28:	f100 0114 	add.w	r1, r0, #20
 8025b2c:	f100 0210 	add.w	r2, r0, #16
 8025b30:	4618      	mov	r0, r3
 8025b32:	4553      	cmp	r3, sl
 8025b34:	db33      	blt.n	8025b9e <__lshift+0xb6>
 8025b36:	ea2a 7aea 	bic.w	sl, sl, sl, asr #31
 8025b3a:	f104 0314 	add.w	r3, r4, #20
 8025b3e:	6920      	ldr	r0, [r4, #16]
 8025b40:	f019 091f 	ands.w	r9, r9, #31
 8025b44:	eb01 018a 	add.w	r1, r1, sl, lsl #2
 8025b48:	eb03 0c80 	add.w	ip, r3, r0, lsl #2
 8025b4c:	d02b      	beq.n	8025ba6 <__lshift+0xbe>
 8025b4e:	f1c9 0e20 	rsb	lr, r9, #32
 8025b52:	468a      	mov	sl, r1
 8025b54:	2200      	movs	r2, #0
 8025b56:	6818      	ldr	r0, [r3, #0]
 8025b58:	fa00 f009 	lsl.w	r0, r0, r9
 8025b5c:	4310      	orrs	r0, r2
 8025b5e:	f84a 0b04 	str.w	r0, [sl], #4
 8025b62:	f853 2b04 	ldr.w	r2, [r3], #4
 8025b66:	459c      	cmp	ip, r3
 8025b68:	fa22 f20e 	lsr.w	r2, r2, lr
 8025b6c:	d8f3      	bhi.n	8025b56 <__lshift+0x6e>
 8025b6e:	ebac 0304 	sub.w	r3, ip, r4
 8025b72:	f104 0015 	add.w	r0, r4, #21
 8025b76:	3b15      	subs	r3, #21
 8025b78:	f023 0303 	bic.w	r3, r3, #3
 8025b7c:	3304      	adds	r3, #4
 8025b7e:	4560      	cmp	r0, ip
 8025b80:	bf88      	it	hi
 8025b82:	2304      	movhi	r3, #4
 8025b84:	50ca      	str	r2, [r1, r3]
 8025b86:	b10a      	cbz	r2, 8025b8c <__lshift+0xa4>
 8025b88:	f108 0602 	add.w	r6, r8, #2
 8025b8c:	3e01      	subs	r6, #1
 8025b8e:	4638      	mov	r0, r7
 8025b90:	4621      	mov	r1, r4
 8025b92:	612e      	str	r6, [r5, #16]
 8025b94:	f7ff fd94 	bl	80256c0 <_Bfree>
 8025b98:	4628      	mov	r0, r5
 8025b9a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8025b9e:	3301      	adds	r3, #1
 8025ba0:	f842 0f04 	str.w	r0, [r2, #4]!
 8025ba4:	e7c5      	b.n	8025b32 <__lshift+0x4a>
 8025ba6:	3904      	subs	r1, #4
 8025ba8:	f853 2b04 	ldr.w	r2, [r3], #4
 8025bac:	459c      	cmp	ip, r3
 8025bae:	f841 2f04 	str.w	r2, [r1, #4]!
 8025bb2:	d8f9      	bhi.n	8025ba8 <__lshift+0xc0>
 8025bb4:	e7ea      	b.n	8025b8c <__lshift+0xa4>
 8025bb6:	bf00      	nop
 8025bb8:	0802a993 	.word	0x0802a993
 8025bbc:	0802aa04 	.word	0x0802aa04

08025bc0 <__mcmp>:
 8025bc0:	4603      	mov	r3, r0
 8025bc2:	690a      	ldr	r2, [r1, #16]
 8025bc4:	6900      	ldr	r0, [r0, #16]
 8025bc6:	1a80      	subs	r0, r0, r2
 8025bc8:	b530      	push	{r4, r5, lr}
 8025bca:	d10e      	bne.n	8025bea <__mcmp+0x2a>
 8025bcc:	3314      	adds	r3, #20
 8025bce:	3114      	adds	r1, #20
 8025bd0:	eb03 0482 	add.w	r4, r3, r2, lsl #2
 8025bd4:	eb01 0182 	add.w	r1, r1, r2, lsl #2
 8025bd8:	f854 5d04 	ldr.w	r5, [r4, #-4]!
 8025bdc:	f851 2d04 	ldr.w	r2, [r1, #-4]!
 8025be0:	4295      	cmp	r5, r2
 8025be2:	d003      	beq.n	8025bec <__mcmp+0x2c>
 8025be4:	d205      	bcs.n	8025bf2 <__mcmp+0x32>
 8025be6:	f04f 30ff 	mov.w	r0, #4294967295
 8025bea:	bd30      	pop	{r4, r5, pc}
 8025bec:	42a3      	cmp	r3, r4
 8025bee:	d3f3      	bcc.n	8025bd8 <__mcmp+0x18>
 8025bf0:	e7fb      	b.n	8025bea <__mcmp+0x2a>
 8025bf2:	2001      	movs	r0, #1
 8025bf4:	e7f9      	b.n	8025bea <__mcmp+0x2a>
	...

08025bf8 <__mdiff>:
 8025bf8:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8025bfc:	4689      	mov	r9, r1
 8025bfe:	4606      	mov	r6, r0
 8025c00:	4611      	mov	r1, r2
 8025c02:	4614      	mov	r4, r2
 8025c04:	4648      	mov	r0, r9
 8025c06:	f7ff ffdb 	bl	8025bc0 <__mcmp>
 8025c0a:	1e05      	subs	r5, r0, #0
 8025c0c:	d112      	bne.n	8025c34 <__mdiff+0x3c>
 8025c0e:	4629      	mov	r1, r5
 8025c10:	4630      	mov	r0, r6
 8025c12:	f7ff fd15 	bl	8025640 <_Balloc>
 8025c16:	4602      	mov	r2, r0
 8025c18:	b928      	cbnz	r0, 8025c26 <__mdiff+0x2e>
 8025c1a:	4b41      	ldr	r3, [pc, #260]	@ (8025d20 <__mdiff+0x128>)
 8025c1c:	f240 2137 	movw	r1, #567	@ 0x237
 8025c20:	4840      	ldr	r0, [pc, #256]	@ (8025d24 <__mdiff+0x12c>)
 8025c22:	f7fe fafb 	bl	802421c <__assert_func>
 8025c26:	2301      	movs	r3, #1
 8025c28:	e9c0 3504 	strd	r3, r5, [r0, #16]
 8025c2c:	4610      	mov	r0, r2
 8025c2e:	b003      	add	sp, #12
 8025c30:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8025c34:	bfbc      	itt	lt
 8025c36:	464b      	movlt	r3, r9
 8025c38:	46a1      	movlt	r9, r4
 8025c3a:	4630      	mov	r0, r6
 8025c3c:	bfb8      	it	lt
 8025c3e:	2501      	movlt	r5, #1
 8025c40:	f8d9 1004 	ldr.w	r1, [r9, #4]
 8025c44:	bfb4      	ite	lt
 8025c46:	461c      	movlt	r4, r3
 8025c48:	2500      	movge	r5, #0
 8025c4a:	f7ff fcf9 	bl	8025640 <_Balloc>
 8025c4e:	4602      	mov	r2, r0
 8025c50:	b918      	cbnz	r0, 8025c5a <__mdiff+0x62>
 8025c52:	4b33      	ldr	r3, [pc, #204]	@ (8025d20 <__mdiff+0x128>)
 8025c54:	f240 2145 	movw	r1, #581	@ 0x245
 8025c58:	e7e2      	b.n	8025c20 <__mdiff+0x28>
 8025c5a:	f8d9 7010 	ldr.w	r7, [r9, #16]
 8025c5e:	f104 0e14 	add.w	lr, r4, #20
 8025c62:	6926      	ldr	r6, [r4, #16]
 8025c64:	f100 0b14 	add.w	fp, r0, #20
 8025c68:	60c5      	str	r5, [r0, #12]
 8025c6a:	f109 0514 	add.w	r5, r9, #20
 8025c6e:	f109 0310 	add.w	r3, r9, #16
 8025c72:	eb0e 0686 	add.w	r6, lr, r6, lsl #2
 8025c76:	eb05 0887 	add.w	r8, r5, r7, lsl #2
 8025c7a:	46d9      	mov	r9, fp
 8025c7c:	f04f 0c00 	mov.w	ip, #0
 8025c80:	9301      	str	r3, [sp, #4]
 8025c82:	9b01      	ldr	r3, [sp, #4]
 8025c84:	f85e 0b04 	ldr.w	r0, [lr], #4
 8025c88:	f853 af04 	ldr.w	sl, [r3, #4]!
 8025c8c:	4576      	cmp	r6, lr
 8025c8e:	9301      	str	r3, [sp, #4]
 8025c90:	fa1f f38a 	uxth.w	r3, sl
 8025c94:	4619      	mov	r1, r3
 8025c96:	b283      	uxth	r3, r0
 8025c98:	ea4f 4010 	mov.w	r0, r0, lsr #16
 8025c9c:	eba1 0303 	sub.w	r3, r1, r3
 8025ca0:	ebc0 401a 	rsb	r0, r0, sl, lsr #16
 8025ca4:	4463      	add	r3, ip
 8025ca6:	eb00 4023 	add.w	r0, r0, r3, asr #16
 8025caa:	b29b      	uxth	r3, r3
 8025cac:	ea4f 4c20 	mov.w	ip, r0, asr #16
 8025cb0:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
 8025cb4:	f849 3b04 	str.w	r3, [r9], #4
 8025cb8:	d8e3      	bhi.n	8025c82 <__mdiff+0x8a>
 8025cba:	1b33      	subs	r3, r6, r4
 8025cbc:	3415      	adds	r4, #21
 8025cbe:	3b15      	subs	r3, #21
 8025cc0:	f023 0303 	bic.w	r3, r3, #3
 8025cc4:	3304      	adds	r3, #4
 8025cc6:	42a6      	cmp	r6, r4
 8025cc8:	bf38      	it	cc
 8025cca:	2304      	movcc	r3, #4
 8025ccc:	441d      	add	r5, r3
 8025cce:	445b      	add	r3, fp
 8025cd0:	462c      	mov	r4, r5
 8025cd2:	461e      	mov	r6, r3
 8025cd4:	4544      	cmp	r4, r8
 8025cd6:	d30e      	bcc.n	8025cf6 <__mdiff+0xfe>
 8025cd8:	f108 0103 	add.w	r1, r8, #3
 8025cdc:	1b49      	subs	r1, r1, r5
 8025cde:	3d03      	subs	r5, #3
 8025ce0:	f021 0103 	bic.w	r1, r1, #3
 8025ce4:	45a8      	cmp	r8, r5
 8025ce6:	bf38      	it	cc
 8025ce8:	2100      	movcc	r1, #0
 8025cea:	440b      	add	r3, r1
 8025cec:	f853 1d04 	ldr.w	r1, [r3, #-4]!
 8025cf0:	b199      	cbz	r1, 8025d1a <__mdiff+0x122>
 8025cf2:	6117      	str	r7, [r2, #16]
 8025cf4:	e79a      	b.n	8025c2c <__mdiff+0x34>
 8025cf6:	f854 1b04 	ldr.w	r1, [r4], #4
 8025cfa:	46e6      	mov	lr, ip
 8025cfc:	fa1f fc81 	uxth.w	ip, r1
 8025d00:	0c08      	lsrs	r0, r1, #16
 8025d02:	4471      	add	r1, lr
 8025d04:	44f4      	add	ip, lr
 8025d06:	b289      	uxth	r1, r1
 8025d08:	eb00 402c 	add.w	r0, r0, ip, asr #16
 8025d0c:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
 8025d10:	ea4f 4c20 	mov.w	ip, r0, asr #16
 8025d14:	f846 1b04 	str.w	r1, [r6], #4
 8025d18:	e7dc      	b.n	8025cd4 <__mdiff+0xdc>
 8025d1a:	3f01      	subs	r7, #1
 8025d1c:	e7e6      	b.n	8025cec <__mdiff+0xf4>
 8025d1e:	bf00      	nop
 8025d20:	0802a993 	.word	0x0802a993
 8025d24:	0802aa04 	.word	0x0802aa04

08025d28 <__ulp>:
 8025d28:	4b0e      	ldr	r3, [pc, #56]	@ (8025d64 <__ulp+0x3c>)
 8025d2a:	400b      	ands	r3, r1
 8025d2c:	f1a3 7350 	sub.w	r3, r3, #54525952	@ 0x3400000
 8025d30:	2b00      	cmp	r3, #0
 8025d32:	dc08      	bgt.n	8025d46 <__ulp+0x1e>
 8025d34:	425b      	negs	r3, r3
 8025d36:	f1b3 7fa0 	cmp.w	r3, #20971520	@ 0x1400000
 8025d3a:	ea4f 5223 	mov.w	r2, r3, asr #20
 8025d3e:	da04      	bge.n	8025d4a <__ulp+0x22>
 8025d40:	f44f 2300 	mov.w	r3, #524288	@ 0x80000
 8025d44:	4113      	asrs	r3, r2
 8025d46:	2200      	movs	r2, #0
 8025d48:	e008      	b.n	8025d5c <__ulp+0x34>
 8025d4a:	f1a2 0314 	sub.w	r3, r2, #20
 8025d4e:	2b1e      	cmp	r3, #30
 8025d50:	bfd6      	itet	le
 8025d52:	f04f 4200 	movle.w	r2, #2147483648	@ 0x80000000
 8025d56:	2201      	movgt	r2, #1
 8025d58:	40da      	lsrle	r2, r3
 8025d5a:	2300      	movs	r3, #0
 8025d5c:	4619      	mov	r1, r3
 8025d5e:	4610      	mov	r0, r2
 8025d60:	4770      	bx	lr
 8025d62:	bf00      	nop
 8025d64:	7ff00000 	.word	0x7ff00000

08025d68 <__b2d>:
 8025d68:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8025d6a:	6902      	ldr	r2, [r0, #16]
 8025d6c:	f100 0614 	add.w	r6, r0, #20
 8025d70:	4f21      	ldr	r7, [pc, #132]	@ (8025df8 <__b2d+0x90>)
 8025d72:	eb06 0282 	add.w	r2, r6, r2, lsl #2
 8025d76:	f852 4c04 	ldr.w	r4, [r2, #-4]
 8025d7a:	1f15      	subs	r5, r2, #4
 8025d7c:	4620      	mov	r0, r4
 8025d7e:	f7ff fd53 	bl	8025828 <__hi0bits>
 8025d82:	4603      	mov	r3, r0
 8025d84:	f1c0 0020 	rsb	r0, r0, #32
 8025d88:	2b0a      	cmp	r3, #10
 8025d8a:	6008      	str	r0, [r1, #0]
 8025d8c:	dc13      	bgt.n	8025db6 <__b2d+0x4e>
 8025d8e:	42ae      	cmp	r6, r5
 8025d90:	f1c3 0c0b 	rsb	ip, r3, #11
 8025d94:	f103 0315 	add.w	r3, r3, #21
 8025d98:	bf34      	ite	cc
 8025d9a:	f852 2c08 	ldrcc.w	r2, [r2, #-8]
 8025d9e:	2200      	movcs	r2, #0
 8025da0:	fa24 fe0c 	lsr.w	lr, r4, ip
 8025da4:	fa04 f303 	lsl.w	r3, r4, r3
 8025da8:	fa22 f20c 	lsr.w	r2, r2, ip
 8025dac:	ea4e 0107 	orr.w	r1, lr, r7
 8025db0:	431a      	orrs	r2, r3
 8025db2:	4610      	mov	r0, r2
 8025db4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8025db6:	42ae      	cmp	r6, r5
 8025db8:	bf36      	itet	cc
 8025dba:	f1a2 0508 	subcc.w	r5, r2, #8
 8025dbe:	2200      	movcs	r2, #0
 8025dc0:	f852 2c08 	ldrcc.w	r2, [r2, #-8]
 8025dc4:	3b0b      	subs	r3, #11
 8025dc6:	d014      	beq.n	8025df2 <__b2d+0x8a>
 8025dc8:	f1c3 0720 	rsb	r7, r3, #32
 8025dcc:	409c      	lsls	r4, r3
 8025dce:	42b5      	cmp	r5, r6
 8025dd0:	fa22 f107 	lsr.w	r1, r2, r7
 8025dd4:	fa02 f203 	lsl.w	r2, r2, r3
 8025dd8:	ea44 0401 	orr.w	r4, r4, r1
 8025ddc:	f044 517f 	orr.w	r1, r4, #1069547520	@ 0x3fc00000
 8025de0:	bf8c      	ite	hi
 8025de2:	f855 4c04 	ldrhi.w	r4, [r5, #-4]
 8025de6:	2400      	movls	r4, #0
 8025de8:	f441 1140 	orr.w	r1, r1, #3145728	@ 0x300000
 8025dec:	40fc      	lsrs	r4, r7
 8025dee:	4322      	orrs	r2, r4
 8025df0:	e7df      	b.n	8025db2 <__b2d+0x4a>
 8025df2:	ea44 0107 	orr.w	r1, r4, r7
 8025df6:	e7dc      	b.n	8025db2 <__b2d+0x4a>
 8025df8:	3ff00000 	.word	0x3ff00000

08025dfc <__d2b>:
 8025dfc:	e92d 4373 	stmdb	sp!, {r0, r1, r4, r5, r6, r8, r9, lr}
 8025e00:	2101      	movs	r1, #1
 8025e02:	4690      	mov	r8, r2
 8025e04:	4699      	mov	r9, r3
 8025e06:	9e08      	ldr	r6, [sp, #32]
 8025e08:	f7ff fc1a 	bl	8025640 <_Balloc>
 8025e0c:	4604      	mov	r4, r0
 8025e0e:	b930      	cbnz	r0, 8025e1e <__d2b+0x22>
 8025e10:	4602      	mov	r2, r0
 8025e12:	4b24      	ldr	r3, [pc, #144]	@ (8025ea4 <__d2b+0xa8>)
 8025e14:	f240 310f 	movw	r1, #783	@ 0x30f
 8025e18:	4823      	ldr	r0, [pc, #140]	@ (8025ea8 <__d2b+0xac>)
 8025e1a:	f7fe f9ff 	bl	802421c <__assert_func>
 8025e1e:	f3c9 550a 	ubfx	r5, r9, #20, #11
 8025e22:	f3c9 0313 	ubfx	r3, r9, #0, #20
 8025e26:	b10d      	cbz	r5, 8025e2c <__d2b+0x30>
 8025e28:	f443 1380 	orr.w	r3, r3, #1048576	@ 0x100000
 8025e2c:	9301      	str	r3, [sp, #4]
 8025e2e:	f1b8 0300 	subs.w	r3, r8, #0
 8025e32:	d024      	beq.n	8025e7e <__d2b+0x82>
 8025e34:	4668      	mov	r0, sp
 8025e36:	9300      	str	r3, [sp, #0]
 8025e38:	f7ff fd15 	bl	8025866 <__lo0bits>
 8025e3c:	e9dd 1200 	ldrd	r1, r2, [sp]
 8025e40:	b1d8      	cbz	r0, 8025e7a <__d2b+0x7e>
 8025e42:	f1c0 0320 	rsb	r3, r0, #32
 8025e46:	fa02 f303 	lsl.w	r3, r2, r3
 8025e4a:	40c2      	lsrs	r2, r0
 8025e4c:	430b      	orrs	r3, r1
 8025e4e:	9201      	str	r2, [sp, #4]
 8025e50:	6163      	str	r3, [r4, #20]
 8025e52:	9b01      	ldr	r3, [sp, #4]
 8025e54:	2b00      	cmp	r3, #0
 8025e56:	61a3      	str	r3, [r4, #24]
 8025e58:	bf0c      	ite	eq
 8025e5a:	2201      	moveq	r2, #1
 8025e5c:	2202      	movne	r2, #2
 8025e5e:	6122      	str	r2, [r4, #16]
 8025e60:	b1ad      	cbz	r5, 8025e8e <__d2b+0x92>
 8025e62:	f2a5 4533 	subw	r5, r5, #1075	@ 0x433
 8025e66:	4405      	add	r5, r0
 8025e68:	f1c0 0035 	rsb	r0, r0, #53	@ 0x35
 8025e6c:	6035      	str	r5, [r6, #0]
 8025e6e:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8025e70:	6018      	str	r0, [r3, #0]
 8025e72:	4620      	mov	r0, r4
 8025e74:	b002      	add	sp, #8
 8025e76:	e8bd 8370 	ldmia.w	sp!, {r4, r5, r6, r8, r9, pc}
 8025e7a:	6161      	str	r1, [r4, #20]
 8025e7c:	e7e9      	b.n	8025e52 <__d2b+0x56>
 8025e7e:	a801      	add	r0, sp, #4
 8025e80:	f7ff fcf1 	bl	8025866 <__lo0bits>
 8025e84:	9b01      	ldr	r3, [sp, #4]
 8025e86:	3020      	adds	r0, #32
 8025e88:	2201      	movs	r2, #1
 8025e8a:	6163      	str	r3, [r4, #20]
 8025e8c:	e7e7      	b.n	8025e5e <__d2b+0x62>
 8025e8e:	f2a0 4032 	subw	r0, r0, #1074	@ 0x432
 8025e92:	eb04 0382 	add.w	r3, r4, r2, lsl #2
 8025e96:	6030      	str	r0, [r6, #0]
 8025e98:	6918      	ldr	r0, [r3, #16]
 8025e9a:	f7ff fcc5 	bl	8025828 <__hi0bits>
 8025e9e:	ebc0 1042 	rsb	r0, r0, r2, lsl #5
 8025ea2:	e7e4      	b.n	8025e6e <__d2b+0x72>
 8025ea4:	0802a993 	.word	0x0802a993
 8025ea8:	0802aa04 	.word	0x0802aa04

08025eac <__ratio>:
 8025eac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8025eb0:	b085      	sub	sp, #20
 8025eb2:	e9cd 1000 	strd	r1, r0, [sp]
 8025eb6:	a902      	add	r1, sp, #8
 8025eb8:	f7ff ff56 	bl	8025d68 <__b2d>
 8025ebc:	468b      	mov	fp, r1
 8025ebe:	4606      	mov	r6, r0
 8025ec0:	460f      	mov	r7, r1
 8025ec2:	9800      	ldr	r0, [sp, #0]
 8025ec4:	a903      	add	r1, sp, #12
 8025ec6:	f7ff ff4f 	bl	8025d68 <__b2d>
 8025eca:	9b01      	ldr	r3, [sp, #4]
 8025ecc:	4689      	mov	r9, r1
 8025ece:	460d      	mov	r5, r1
 8025ed0:	6919      	ldr	r1, [r3, #16]
 8025ed2:	4604      	mov	r4, r0
 8025ed4:	9b00      	ldr	r3, [sp, #0]
 8025ed6:	4630      	mov	r0, r6
 8025ed8:	691b      	ldr	r3, [r3, #16]
 8025eda:	1ac9      	subs	r1, r1, r3
 8025edc:	e9dd 3202 	ldrd	r3, r2, [sp, #8]
 8025ee0:	1a9b      	subs	r3, r3, r2
 8025ee2:	eb03 1341 	add.w	r3, r3, r1, lsl #5
 8025ee6:	2b00      	cmp	r3, #0
 8025ee8:	bfdb      	ittet	le
 8025eea:	ebc3 3303 	rsble	r3, r3, r3, lsl #12
 8025eee:	462a      	movle	r2, r5
 8025ef0:	463a      	movgt	r2, r7
 8025ef2:	eb02 5903 	addle.w	r9, r2, r3, lsl #20
 8025ef6:	bfc8      	it	gt
 8025ef8:	eb02 5b03 	addgt.w	fp, r2, r3, lsl #20
 8025efc:	4622      	mov	r2, r4
 8025efe:	464b      	mov	r3, r9
 8025f00:	4659      	mov	r1, fp
 8025f02:	f7da fcb1 	bl	8000868 <__aeabi_ddiv>
 8025f06:	b005      	add	sp, #20
 8025f08:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08025f0c <__copybits>:
 8025f0c:	3901      	subs	r1, #1
 8025f0e:	f102 0314 	add.w	r3, r2, #20
 8025f12:	1149      	asrs	r1, r1, #5
 8025f14:	b570      	push	{r4, r5, r6, lr}
 8025f16:	3101      	adds	r1, #1
 8025f18:	6914      	ldr	r4, [r2, #16]
 8025f1a:	1f05      	subs	r5, r0, #4
 8025f1c:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 8025f20:	eb03 0484 	add.w	r4, r3, r4, lsl #2
 8025f24:	42a3      	cmp	r3, r4
 8025f26:	d30c      	bcc.n	8025f42 <__copybits+0x36>
 8025f28:	1aa3      	subs	r3, r4, r2
 8025f2a:	3211      	adds	r2, #17
 8025f2c:	3b11      	subs	r3, #17
 8025f2e:	f023 0303 	bic.w	r3, r3, #3
 8025f32:	42a2      	cmp	r2, r4
 8025f34:	bf88      	it	hi
 8025f36:	2300      	movhi	r3, #0
 8025f38:	4418      	add	r0, r3
 8025f3a:	2300      	movs	r3, #0
 8025f3c:	4288      	cmp	r0, r1
 8025f3e:	d305      	bcc.n	8025f4c <__copybits+0x40>
 8025f40:	bd70      	pop	{r4, r5, r6, pc}
 8025f42:	f853 6b04 	ldr.w	r6, [r3], #4
 8025f46:	f845 6f04 	str.w	r6, [r5, #4]!
 8025f4a:	e7eb      	b.n	8025f24 <__copybits+0x18>
 8025f4c:	f840 3b04 	str.w	r3, [r0], #4
 8025f50:	e7f4      	b.n	8025f3c <__copybits+0x30>

08025f52 <__any_on>:
 8025f52:	f100 0214 	add.w	r2, r0, #20
 8025f56:	114b      	asrs	r3, r1, #5
 8025f58:	6900      	ldr	r0, [r0, #16]
 8025f5a:	4298      	cmp	r0, r3
 8025f5c:	b510      	push	{r4, lr}
 8025f5e:	db11      	blt.n	8025f84 <__any_on+0x32>
 8025f60:	dd0a      	ble.n	8025f78 <__any_on+0x26>
 8025f62:	f011 011f 	ands.w	r1, r1, #31
 8025f66:	d007      	beq.n	8025f78 <__any_on+0x26>
 8025f68:	f852 4023 	ldr.w	r4, [r2, r3, lsl #2]
 8025f6c:	fa24 f001 	lsr.w	r0, r4, r1
 8025f70:	fa00 f101 	lsl.w	r1, r0, r1
 8025f74:	428c      	cmp	r4, r1
 8025f76:	d10b      	bne.n	8025f90 <__any_on+0x3e>
 8025f78:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8025f7c:	4293      	cmp	r3, r2
 8025f7e:	d803      	bhi.n	8025f88 <__any_on+0x36>
 8025f80:	2000      	movs	r0, #0
 8025f82:	bd10      	pop	{r4, pc}
 8025f84:	4603      	mov	r3, r0
 8025f86:	e7f7      	b.n	8025f78 <__any_on+0x26>
 8025f88:	f853 1d04 	ldr.w	r1, [r3, #-4]!
 8025f8c:	2900      	cmp	r1, #0
 8025f8e:	d0f5      	beq.n	8025f7c <__any_on+0x2a>
 8025f90:	2001      	movs	r0, #1
 8025f92:	e7f6      	b.n	8025f82 <__any_on+0x30>

08025f94 <_strtol_l.isra.0>:
 8025f94:	2b24      	cmp	r3, #36	@ 0x24
 8025f96:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8025f9a:	4686      	mov	lr, r0
 8025f9c:	4690      	mov	r8, r2
 8025f9e:	d801      	bhi.n	8025fa4 <_strtol_l.isra.0+0x10>
 8025fa0:	2b01      	cmp	r3, #1
 8025fa2:	d106      	bne.n	8025fb2 <_strtol_l.isra.0+0x1e>
 8025fa4:	f7fe f8e0 	bl	8024168 <__errno>
 8025fa8:	2316      	movs	r3, #22
 8025faa:	6003      	str	r3, [r0, #0]
 8025fac:	2000      	movs	r0, #0
 8025fae:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8025fb2:	460d      	mov	r5, r1
 8025fb4:	4833      	ldr	r0, [pc, #204]	@ (8026084 <_strtol_l.isra.0+0xf0>)
 8025fb6:	462a      	mov	r2, r5
 8025fb8:	f815 4b01 	ldrb.w	r4, [r5], #1
 8025fbc:	5d06      	ldrb	r6, [r0, r4]
 8025fbe:	f016 0608 	ands.w	r6, r6, #8
 8025fc2:	d1f8      	bne.n	8025fb6 <_strtol_l.isra.0+0x22>
 8025fc4:	2c2d      	cmp	r4, #45	@ 0x2d
 8025fc6:	d110      	bne.n	8025fea <_strtol_l.isra.0+0x56>
 8025fc8:	782c      	ldrb	r4, [r5, #0]
 8025fca:	2601      	movs	r6, #1
 8025fcc:	1c95      	adds	r5, r2, #2
 8025fce:	f033 0210 	bics.w	r2, r3, #16
 8025fd2:	d115      	bne.n	8026000 <_strtol_l.isra.0+0x6c>
 8025fd4:	2c30      	cmp	r4, #48	@ 0x30
 8025fd6:	d10d      	bne.n	8025ff4 <_strtol_l.isra.0+0x60>
 8025fd8:	782a      	ldrb	r2, [r5, #0]
 8025fda:	f002 02df 	and.w	r2, r2, #223	@ 0xdf
 8025fde:	2a58      	cmp	r2, #88	@ 0x58
 8025fe0:	d108      	bne.n	8025ff4 <_strtol_l.isra.0+0x60>
 8025fe2:	786c      	ldrb	r4, [r5, #1]
 8025fe4:	3502      	adds	r5, #2
 8025fe6:	2310      	movs	r3, #16
 8025fe8:	e00a      	b.n	8026000 <_strtol_l.isra.0+0x6c>
 8025fea:	2c2b      	cmp	r4, #43	@ 0x2b
 8025fec:	bf04      	itt	eq
 8025fee:	782c      	ldrbeq	r4, [r5, #0]
 8025ff0:	1c95      	addeq	r5, r2, #2
 8025ff2:	e7ec      	b.n	8025fce <_strtol_l.isra.0+0x3a>
 8025ff4:	2b00      	cmp	r3, #0
 8025ff6:	d1f6      	bne.n	8025fe6 <_strtol_l.isra.0+0x52>
 8025ff8:	2c30      	cmp	r4, #48	@ 0x30
 8025ffa:	bf14      	ite	ne
 8025ffc:	230a      	movne	r3, #10
 8025ffe:	2308      	moveq	r3, #8
 8026000:	f106 4c00 	add.w	ip, r6, #2147483648	@ 0x80000000
 8026004:	2200      	movs	r2, #0
 8026006:	f10c 3cff 	add.w	ip, ip, #4294967295
 802600a:	4610      	mov	r0, r2
 802600c:	fbbc f9f3 	udiv	r9, ip, r3
 8026010:	fb03 ca19 	mls	sl, r3, r9, ip
 8026014:	f1a4 0730 	sub.w	r7, r4, #48	@ 0x30
 8026018:	2f09      	cmp	r7, #9
 802601a:	d80f      	bhi.n	802603c <_strtol_l.isra.0+0xa8>
 802601c:	463c      	mov	r4, r7
 802601e:	42a3      	cmp	r3, r4
 8026020:	dd1b      	ble.n	802605a <_strtol_l.isra.0+0xc6>
 8026022:	1c57      	adds	r7, r2, #1
 8026024:	d007      	beq.n	8026036 <_strtol_l.isra.0+0xa2>
 8026026:	4581      	cmp	r9, r0
 8026028:	d314      	bcc.n	8026054 <_strtol_l.isra.0+0xc0>
 802602a:	d101      	bne.n	8026030 <_strtol_l.isra.0+0x9c>
 802602c:	45a2      	cmp	sl, r4
 802602e:	db11      	blt.n	8026054 <_strtol_l.isra.0+0xc0>
 8026030:	fb00 4003 	mla	r0, r0, r3, r4
 8026034:	2201      	movs	r2, #1
 8026036:	f815 4b01 	ldrb.w	r4, [r5], #1
 802603a:	e7eb      	b.n	8026014 <_strtol_l.isra.0+0x80>
 802603c:	f1a4 0741 	sub.w	r7, r4, #65	@ 0x41
 8026040:	2f19      	cmp	r7, #25
 8026042:	d801      	bhi.n	8026048 <_strtol_l.isra.0+0xb4>
 8026044:	3c37      	subs	r4, #55	@ 0x37
 8026046:	e7ea      	b.n	802601e <_strtol_l.isra.0+0x8a>
 8026048:	f1a4 0761 	sub.w	r7, r4, #97	@ 0x61
 802604c:	2f19      	cmp	r7, #25
 802604e:	d804      	bhi.n	802605a <_strtol_l.isra.0+0xc6>
 8026050:	3c57      	subs	r4, #87	@ 0x57
 8026052:	e7e4      	b.n	802601e <_strtol_l.isra.0+0x8a>
 8026054:	f04f 32ff 	mov.w	r2, #4294967295
 8026058:	e7ed      	b.n	8026036 <_strtol_l.isra.0+0xa2>
 802605a:	1c53      	adds	r3, r2, #1
 802605c:	d108      	bne.n	8026070 <_strtol_l.isra.0+0xdc>
 802605e:	2322      	movs	r3, #34	@ 0x22
 8026060:	4660      	mov	r0, ip
 8026062:	f8ce 3000 	str.w	r3, [lr]
 8026066:	f1b8 0f00 	cmp.w	r8, #0
 802606a:	d0a0      	beq.n	8025fae <_strtol_l.isra.0+0x1a>
 802606c:	1e69      	subs	r1, r5, #1
 802606e:	e006      	b.n	802607e <_strtol_l.isra.0+0xea>
 8026070:	b106      	cbz	r6, 8026074 <_strtol_l.isra.0+0xe0>
 8026072:	4240      	negs	r0, r0
 8026074:	f1b8 0f00 	cmp.w	r8, #0
 8026078:	d099      	beq.n	8025fae <_strtol_l.isra.0+0x1a>
 802607a:	2a00      	cmp	r2, #0
 802607c:	d1f6      	bne.n	802606c <_strtol_l.isra.0+0xd8>
 802607e:	f8c8 1000 	str.w	r1, [r8]
 8026082:	e794      	b.n	8025fae <_strtol_l.isra.0+0x1a>
 8026084:	0802aac1 	.word	0x0802aac1

08026088 <_strtol_r>:
 8026088:	f7ff bf84 	b.w	8025f94 <_strtol_l.isra.0>

0802608c <__ascii_wctomb>:
 802608c:	4603      	mov	r3, r0
 802608e:	4608      	mov	r0, r1
 8026090:	b141      	cbz	r1, 80260a4 <__ascii_wctomb+0x18>
 8026092:	2aff      	cmp	r2, #255	@ 0xff
 8026094:	d904      	bls.n	80260a0 <__ascii_wctomb+0x14>
 8026096:	228a      	movs	r2, #138	@ 0x8a
 8026098:	f04f 30ff 	mov.w	r0, #4294967295
 802609c:	601a      	str	r2, [r3, #0]
 802609e:	4770      	bx	lr
 80260a0:	2001      	movs	r0, #1
 80260a2:	700a      	strb	r2, [r1, #0]
 80260a4:	4770      	bx	lr

080260a6 <__ssputs_r>:
 80260a6:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80260aa:	461f      	mov	r7, r3
 80260ac:	688e      	ldr	r6, [r1, #8]
 80260ae:	4682      	mov	sl, r0
 80260b0:	460c      	mov	r4, r1
 80260b2:	42be      	cmp	r6, r7
 80260b4:	4690      	mov	r8, r2
 80260b6:	680b      	ldr	r3, [r1, #0]
 80260b8:	d82d      	bhi.n	8026116 <__ssputs_r+0x70>
 80260ba:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
 80260be:	f412 6f90 	tst.w	r2, #1152	@ 0x480
 80260c2:	d026      	beq.n	8026112 <__ssputs_r+0x6c>
 80260c4:	6965      	ldr	r5, [r4, #20]
 80260c6:	6909      	ldr	r1, [r1, #16]
 80260c8:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 80260cc:	eba3 0901 	sub.w	r9, r3, r1
 80260d0:	1c7b      	adds	r3, r7, #1
 80260d2:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
 80260d6:	444b      	add	r3, r9
 80260d8:	106d      	asrs	r5, r5, #1
 80260da:	429d      	cmp	r5, r3
 80260dc:	bf38      	it	cc
 80260de:	461d      	movcc	r5, r3
 80260e0:	0553      	lsls	r3, r2, #21
 80260e2:	d527      	bpl.n	8026134 <__ssputs_r+0x8e>
 80260e4:	4629      	mov	r1, r5
 80260e6:	f7fb ffa1 	bl	802202c <_malloc_r>
 80260ea:	4606      	mov	r6, r0
 80260ec:	b360      	cbz	r0, 8026148 <__ssputs_r+0xa2>
 80260ee:	464a      	mov	r2, r9
 80260f0:	6921      	ldr	r1, [r4, #16]
 80260f2:	f7fe f87c 	bl	80241ee <memcpy>
 80260f6:	89a3      	ldrh	r3, [r4, #12]
 80260f8:	f423 6390 	bic.w	r3, r3, #1152	@ 0x480
 80260fc:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8026100:	81a3      	strh	r3, [r4, #12]
 8026102:	6126      	str	r6, [r4, #16]
 8026104:	444e      	add	r6, r9
 8026106:	6165      	str	r5, [r4, #20]
 8026108:	eba5 0509 	sub.w	r5, r5, r9
 802610c:	6026      	str	r6, [r4, #0]
 802610e:	463e      	mov	r6, r7
 8026110:	60a5      	str	r5, [r4, #8]
 8026112:	42be      	cmp	r6, r7
 8026114:	d900      	bls.n	8026118 <__ssputs_r+0x72>
 8026116:	463e      	mov	r6, r7
 8026118:	4632      	mov	r2, r6
 802611a:	4641      	mov	r1, r8
 802611c:	6820      	ldr	r0, [r4, #0]
 802611e:	f7fd ff87 	bl	8024030 <memmove>
 8026122:	68a3      	ldr	r3, [r4, #8]
 8026124:	2000      	movs	r0, #0
 8026126:	1b9b      	subs	r3, r3, r6
 8026128:	60a3      	str	r3, [r4, #8]
 802612a:	6823      	ldr	r3, [r4, #0]
 802612c:	4433      	add	r3, r6
 802612e:	6023      	str	r3, [r4, #0]
 8026130:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8026134:	462a      	mov	r2, r5
 8026136:	f000 fb00 	bl	802673a <_realloc_r>
 802613a:	4606      	mov	r6, r0
 802613c:	2800      	cmp	r0, #0
 802613e:	d1e0      	bne.n	8026102 <__ssputs_r+0x5c>
 8026140:	6921      	ldr	r1, [r4, #16]
 8026142:	4650      	mov	r0, sl
 8026144:	f7fe feea 	bl	8024f1c <_free_r>
 8026148:	230c      	movs	r3, #12
 802614a:	f04f 30ff 	mov.w	r0, #4294967295
 802614e:	f8ca 3000 	str.w	r3, [sl]
 8026152:	89a3      	ldrh	r3, [r4, #12]
 8026154:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8026158:	81a3      	strh	r3, [r4, #12]
 802615a:	e7e9      	b.n	8026130 <__ssputs_r+0x8a>

0802615c <_svfiprintf_r>:
 802615c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8026160:	4698      	mov	r8, r3
 8026162:	898b      	ldrh	r3, [r1, #12]
 8026164:	b09d      	sub	sp, #116	@ 0x74
 8026166:	4607      	mov	r7, r0
 8026168:	061b      	lsls	r3, r3, #24
 802616a:	460d      	mov	r5, r1
 802616c:	4614      	mov	r4, r2
 802616e:	d510      	bpl.n	8026192 <_svfiprintf_r+0x36>
 8026170:	690b      	ldr	r3, [r1, #16]
 8026172:	b973      	cbnz	r3, 8026192 <_svfiprintf_r+0x36>
 8026174:	2140      	movs	r1, #64	@ 0x40
 8026176:	f7fb ff59 	bl	802202c <_malloc_r>
 802617a:	6028      	str	r0, [r5, #0]
 802617c:	6128      	str	r0, [r5, #16]
 802617e:	b930      	cbnz	r0, 802618e <_svfiprintf_r+0x32>
 8026180:	230c      	movs	r3, #12
 8026182:	603b      	str	r3, [r7, #0]
 8026184:	f04f 30ff 	mov.w	r0, #4294967295
 8026188:	b01d      	add	sp, #116	@ 0x74
 802618a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802618e:	2340      	movs	r3, #64	@ 0x40
 8026190:	616b      	str	r3, [r5, #20]
 8026192:	2300      	movs	r3, #0
 8026194:	f8cd 800c 	str.w	r8, [sp, #12]
 8026198:	f04f 0901 	mov.w	r9, #1
 802619c:	f8df 81a0 	ldr.w	r8, [pc, #416]	@ 8026340 <_svfiprintf_r+0x1e4>
 80261a0:	9309      	str	r3, [sp, #36]	@ 0x24
 80261a2:	2320      	movs	r3, #32
 80261a4:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
 80261a8:	2330      	movs	r3, #48	@ 0x30
 80261aa:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
 80261ae:	4623      	mov	r3, r4
 80261b0:	469a      	mov	sl, r3
 80261b2:	f813 2b01 	ldrb.w	r2, [r3], #1
 80261b6:	b10a      	cbz	r2, 80261bc <_svfiprintf_r+0x60>
 80261b8:	2a25      	cmp	r2, #37	@ 0x25
 80261ba:	d1f9      	bne.n	80261b0 <_svfiprintf_r+0x54>
 80261bc:	ebba 0b04 	subs.w	fp, sl, r4
 80261c0:	d00b      	beq.n	80261da <_svfiprintf_r+0x7e>
 80261c2:	465b      	mov	r3, fp
 80261c4:	4622      	mov	r2, r4
 80261c6:	4629      	mov	r1, r5
 80261c8:	4638      	mov	r0, r7
 80261ca:	f7ff ff6c 	bl	80260a6 <__ssputs_r>
 80261ce:	3001      	adds	r0, #1
 80261d0:	f000 80a7 	beq.w	8026322 <_svfiprintf_r+0x1c6>
 80261d4:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 80261d6:	445a      	add	r2, fp
 80261d8:	9209      	str	r2, [sp, #36]	@ 0x24
 80261da:	f89a 3000 	ldrb.w	r3, [sl]
 80261de:	2b00      	cmp	r3, #0
 80261e0:	f000 809f 	beq.w	8026322 <_svfiprintf_r+0x1c6>
 80261e4:	2300      	movs	r3, #0
 80261e6:	f04f 32ff 	mov.w	r2, #4294967295
 80261ea:	f10a 0a01 	add.w	sl, sl, #1
 80261ee:	9304      	str	r3, [sp, #16]
 80261f0:	9307      	str	r3, [sp, #28]
 80261f2:	f88d 3053 	strb.w	r3, [sp, #83]	@ 0x53
 80261f6:	931a      	str	r3, [sp, #104]	@ 0x68
 80261f8:	e9cd 2305 	strd	r2, r3, [sp, #20]
 80261fc:	4654      	mov	r4, sl
 80261fe:	2205      	movs	r2, #5
 8026200:	484f      	ldr	r0, [pc, #316]	@ (8026340 <_svfiprintf_r+0x1e4>)
 8026202:	f814 1b01 	ldrb.w	r1, [r4], #1
 8026206:	f7fd ffe4 	bl	80241d2 <memchr>
 802620a:	9a04      	ldr	r2, [sp, #16]
 802620c:	b9d8      	cbnz	r0, 8026246 <_svfiprintf_r+0xea>
 802620e:	06d0      	lsls	r0, r2, #27
 8026210:	bf44      	itt	mi
 8026212:	2320      	movmi	r3, #32
 8026214:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 8026218:	0711      	lsls	r1, r2, #28
 802621a:	bf44      	itt	mi
 802621c:	232b      	movmi	r3, #43	@ 0x2b
 802621e:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 8026222:	f89a 3000 	ldrb.w	r3, [sl]
 8026226:	2b2a      	cmp	r3, #42	@ 0x2a
 8026228:	d015      	beq.n	8026256 <_svfiprintf_r+0xfa>
 802622a:	9a07      	ldr	r2, [sp, #28]
 802622c:	4654      	mov	r4, sl
 802622e:	2000      	movs	r0, #0
 8026230:	f04f 0c0a 	mov.w	ip, #10
 8026234:	4621      	mov	r1, r4
 8026236:	f811 3b01 	ldrb.w	r3, [r1], #1
 802623a:	3b30      	subs	r3, #48	@ 0x30
 802623c:	2b09      	cmp	r3, #9
 802623e:	d94b      	bls.n	80262d8 <_svfiprintf_r+0x17c>
 8026240:	b1b0      	cbz	r0, 8026270 <_svfiprintf_r+0x114>
 8026242:	9207      	str	r2, [sp, #28]
 8026244:	e014      	b.n	8026270 <_svfiprintf_r+0x114>
 8026246:	eba0 0308 	sub.w	r3, r0, r8
 802624a:	46a2      	mov	sl, r4
 802624c:	fa09 f303 	lsl.w	r3, r9, r3
 8026250:	4313      	orrs	r3, r2
 8026252:	9304      	str	r3, [sp, #16]
 8026254:	e7d2      	b.n	80261fc <_svfiprintf_r+0xa0>
 8026256:	9b03      	ldr	r3, [sp, #12]
 8026258:	1d19      	adds	r1, r3, #4
 802625a:	681b      	ldr	r3, [r3, #0]
 802625c:	2b00      	cmp	r3, #0
 802625e:	9103      	str	r1, [sp, #12]
 8026260:	bfbb      	ittet	lt
 8026262:	425b      	neglt	r3, r3
 8026264:	f042 0202 	orrlt.w	r2, r2, #2
 8026268:	9307      	strge	r3, [sp, #28]
 802626a:	9307      	strlt	r3, [sp, #28]
 802626c:	bfb8      	it	lt
 802626e:	9204      	strlt	r2, [sp, #16]
 8026270:	7823      	ldrb	r3, [r4, #0]
 8026272:	2b2e      	cmp	r3, #46	@ 0x2e
 8026274:	d10a      	bne.n	802628c <_svfiprintf_r+0x130>
 8026276:	7863      	ldrb	r3, [r4, #1]
 8026278:	2b2a      	cmp	r3, #42	@ 0x2a
 802627a:	d132      	bne.n	80262e2 <_svfiprintf_r+0x186>
 802627c:	9b03      	ldr	r3, [sp, #12]
 802627e:	3402      	adds	r4, #2
 8026280:	1d1a      	adds	r2, r3, #4
 8026282:	681b      	ldr	r3, [r3, #0]
 8026284:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
 8026288:	9203      	str	r2, [sp, #12]
 802628a:	9305      	str	r3, [sp, #20]
 802628c:	f8df a0c0 	ldr.w	sl, [pc, #192]	@ 8026350 <_svfiprintf_r+0x1f4>
 8026290:	2203      	movs	r2, #3
 8026292:	7821      	ldrb	r1, [r4, #0]
 8026294:	4650      	mov	r0, sl
 8026296:	f7fd ff9c 	bl	80241d2 <memchr>
 802629a:	b138      	cbz	r0, 80262ac <_svfiprintf_r+0x150>
 802629c:	eba0 000a 	sub.w	r0, r0, sl
 80262a0:	2240      	movs	r2, #64	@ 0x40
 80262a2:	9b04      	ldr	r3, [sp, #16]
 80262a4:	3401      	adds	r4, #1
 80262a6:	4082      	lsls	r2, r0
 80262a8:	4313      	orrs	r3, r2
 80262aa:	9304      	str	r3, [sp, #16]
 80262ac:	f814 1b01 	ldrb.w	r1, [r4], #1
 80262b0:	2206      	movs	r2, #6
 80262b2:	4824      	ldr	r0, [pc, #144]	@ (8026344 <_svfiprintf_r+0x1e8>)
 80262b4:	f88d 1028 	strb.w	r1, [sp, #40]	@ 0x28
 80262b8:	f7fd ff8b 	bl	80241d2 <memchr>
 80262bc:	2800      	cmp	r0, #0
 80262be:	d036      	beq.n	802632e <_svfiprintf_r+0x1d2>
 80262c0:	4b21      	ldr	r3, [pc, #132]	@ (8026348 <_svfiprintf_r+0x1ec>)
 80262c2:	bb1b      	cbnz	r3, 802630c <_svfiprintf_r+0x1b0>
 80262c4:	9b03      	ldr	r3, [sp, #12]
 80262c6:	3307      	adds	r3, #7
 80262c8:	f023 0307 	bic.w	r3, r3, #7
 80262cc:	3308      	adds	r3, #8
 80262ce:	9303      	str	r3, [sp, #12]
 80262d0:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 80262d2:	4433      	add	r3, r6
 80262d4:	9309      	str	r3, [sp, #36]	@ 0x24
 80262d6:	e76a      	b.n	80261ae <_svfiprintf_r+0x52>
 80262d8:	fb0c 3202 	mla	r2, ip, r2, r3
 80262dc:	460c      	mov	r4, r1
 80262de:	2001      	movs	r0, #1
 80262e0:	e7a8      	b.n	8026234 <_svfiprintf_r+0xd8>
 80262e2:	2300      	movs	r3, #0
 80262e4:	3401      	adds	r4, #1
 80262e6:	f04f 0c0a 	mov.w	ip, #10
 80262ea:	4619      	mov	r1, r3
 80262ec:	9305      	str	r3, [sp, #20]
 80262ee:	4620      	mov	r0, r4
 80262f0:	f810 2b01 	ldrb.w	r2, [r0], #1
 80262f4:	3a30      	subs	r2, #48	@ 0x30
 80262f6:	2a09      	cmp	r2, #9
 80262f8:	d903      	bls.n	8026302 <_svfiprintf_r+0x1a6>
 80262fa:	2b00      	cmp	r3, #0
 80262fc:	d0c6      	beq.n	802628c <_svfiprintf_r+0x130>
 80262fe:	9105      	str	r1, [sp, #20]
 8026300:	e7c4      	b.n	802628c <_svfiprintf_r+0x130>
 8026302:	fb0c 2101 	mla	r1, ip, r1, r2
 8026306:	4604      	mov	r4, r0
 8026308:	2301      	movs	r3, #1
 802630a:	e7f0      	b.n	80262ee <_svfiprintf_r+0x192>
 802630c:	ab03      	add	r3, sp, #12
 802630e:	462a      	mov	r2, r5
 8026310:	a904      	add	r1, sp, #16
 8026312:	4638      	mov	r0, r7
 8026314:	9300      	str	r3, [sp, #0]
 8026316:	4b0d      	ldr	r3, [pc, #52]	@ (802634c <_svfiprintf_r+0x1f0>)
 8026318:	f7fc fdee 	bl	8022ef8 <_printf_float>
 802631c:	1c42      	adds	r2, r0, #1
 802631e:	4606      	mov	r6, r0
 8026320:	d1d6      	bne.n	80262d0 <_svfiprintf_r+0x174>
 8026322:	89ab      	ldrh	r3, [r5, #12]
 8026324:	065b      	lsls	r3, r3, #25
 8026326:	f53f af2d 	bmi.w	8026184 <_svfiprintf_r+0x28>
 802632a:	9809      	ldr	r0, [sp, #36]	@ 0x24
 802632c:	e72c      	b.n	8026188 <_svfiprintf_r+0x2c>
 802632e:	ab03      	add	r3, sp, #12
 8026330:	462a      	mov	r2, r5
 8026332:	a904      	add	r1, sp, #16
 8026334:	4638      	mov	r0, r7
 8026336:	9300      	str	r3, [sp, #0]
 8026338:	4b04      	ldr	r3, [pc, #16]	@ (802634c <_svfiprintf_r+0x1f0>)
 802633a:	f7fd f87b 	bl	8023434 <_printf_i>
 802633e:	e7ed      	b.n	802631c <_svfiprintf_r+0x1c0>
 8026340:	0802aa5d 	.word	0x0802aa5d
 8026344:	0802aa67 	.word	0x0802aa67
 8026348:	08022ef9 	.word	0x08022ef9
 802634c:	080260a7 	.word	0x080260a7
 8026350:	0802aa63 	.word	0x0802aa63

08026354 <__sfputc_r>:
 8026354:	6893      	ldr	r3, [r2, #8]
 8026356:	3b01      	subs	r3, #1
 8026358:	2b00      	cmp	r3, #0
 802635a:	b410      	push	{r4}
 802635c:	6093      	str	r3, [r2, #8]
 802635e:	da08      	bge.n	8026372 <__sfputc_r+0x1e>
 8026360:	6994      	ldr	r4, [r2, #24]
 8026362:	42a3      	cmp	r3, r4
 8026364:	db01      	blt.n	802636a <__sfputc_r+0x16>
 8026366:	290a      	cmp	r1, #10
 8026368:	d103      	bne.n	8026372 <__sfputc_r+0x1e>
 802636a:	f85d 4b04 	ldr.w	r4, [sp], #4
 802636e:	f7fd bdca 	b.w	8023f06 <__swbuf_r>
 8026372:	6813      	ldr	r3, [r2, #0]
 8026374:	1c58      	adds	r0, r3, #1
 8026376:	6010      	str	r0, [r2, #0]
 8026378:	4608      	mov	r0, r1
 802637a:	7019      	strb	r1, [r3, #0]
 802637c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8026380:	4770      	bx	lr

08026382 <__sfputs_r>:
 8026382:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8026384:	4606      	mov	r6, r0
 8026386:	460f      	mov	r7, r1
 8026388:	4614      	mov	r4, r2
 802638a:	18d5      	adds	r5, r2, r3
 802638c:	42ac      	cmp	r4, r5
 802638e:	d101      	bne.n	8026394 <__sfputs_r+0x12>
 8026390:	2000      	movs	r0, #0
 8026392:	e007      	b.n	80263a4 <__sfputs_r+0x22>
 8026394:	463a      	mov	r2, r7
 8026396:	f814 1b01 	ldrb.w	r1, [r4], #1
 802639a:	4630      	mov	r0, r6
 802639c:	f7ff ffda 	bl	8026354 <__sfputc_r>
 80263a0:	1c43      	adds	r3, r0, #1
 80263a2:	d1f3      	bne.n	802638c <__sfputs_r+0xa>
 80263a4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

080263a8 <_vfiprintf_r>:
 80263a8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80263ac:	460d      	mov	r5, r1
 80263ae:	b09d      	sub	sp, #116	@ 0x74
 80263b0:	4614      	mov	r4, r2
 80263b2:	4698      	mov	r8, r3
 80263b4:	4606      	mov	r6, r0
 80263b6:	b118      	cbz	r0, 80263c0 <_vfiprintf_r+0x18>
 80263b8:	6a03      	ldr	r3, [r0, #32]
 80263ba:	b90b      	cbnz	r3, 80263c0 <_vfiprintf_r+0x18>
 80263bc:	f7fd fc98 	bl	8023cf0 <__sinit>
 80263c0:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 80263c2:	07d9      	lsls	r1, r3, #31
 80263c4:	d405      	bmi.n	80263d2 <_vfiprintf_r+0x2a>
 80263c6:	89ab      	ldrh	r3, [r5, #12]
 80263c8:	059a      	lsls	r2, r3, #22
 80263ca:	d402      	bmi.n	80263d2 <_vfiprintf_r+0x2a>
 80263cc:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 80263ce:	f7fd fef6 	bl	80241be <__retarget_lock_acquire_recursive>
 80263d2:	89ab      	ldrh	r3, [r5, #12]
 80263d4:	071b      	lsls	r3, r3, #28
 80263d6:	d501      	bpl.n	80263dc <_vfiprintf_r+0x34>
 80263d8:	692b      	ldr	r3, [r5, #16]
 80263da:	b99b      	cbnz	r3, 8026404 <_vfiprintf_r+0x5c>
 80263dc:	4629      	mov	r1, r5
 80263de:	4630      	mov	r0, r6
 80263e0:	f7fd fdd0 	bl	8023f84 <__swsetup_r>
 80263e4:	b170      	cbz	r0, 8026404 <_vfiprintf_r+0x5c>
 80263e6:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 80263e8:	07dc      	lsls	r4, r3, #31
 80263ea:	d504      	bpl.n	80263f6 <_vfiprintf_r+0x4e>
 80263ec:	f04f 30ff 	mov.w	r0, #4294967295
 80263f0:	b01d      	add	sp, #116	@ 0x74
 80263f2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80263f6:	89ab      	ldrh	r3, [r5, #12]
 80263f8:	0598      	lsls	r0, r3, #22
 80263fa:	d4f7      	bmi.n	80263ec <_vfiprintf_r+0x44>
 80263fc:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 80263fe:	f7fd fedf 	bl	80241c0 <__retarget_lock_release_recursive>
 8026402:	e7f3      	b.n	80263ec <_vfiprintf_r+0x44>
 8026404:	2300      	movs	r3, #0
 8026406:	f8cd 800c 	str.w	r8, [sp, #12]
 802640a:	f04f 0901 	mov.w	r9, #1
 802640e:	f8df 81b4 	ldr.w	r8, [pc, #436]	@ 80265c4 <_vfiprintf_r+0x21c>
 8026412:	9309      	str	r3, [sp, #36]	@ 0x24
 8026414:	2320      	movs	r3, #32
 8026416:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
 802641a:	2330      	movs	r3, #48	@ 0x30
 802641c:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
 8026420:	4623      	mov	r3, r4
 8026422:	469a      	mov	sl, r3
 8026424:	f813 2b01 	ldrb.w	r2, [r3], #1
 8026428:	b10a      	cbz	r2, 802642e <_vfiprintf_r+0x86>
 802642a:	2a25      	cmp	r2, #37	@ 0x25
 802642c:	d1f9      	bne.n	8026422 <_vfiprintf_r+0x7a>
 802642e:	ebba 0b04 	subs.w	fp, sl, r4
 8026432:	d00b      	beq.n	802644c <_vfiprintf_r+0xa4>
 8026434:	465b      	mov	r3, fp
 8026436:	4622      	mov	r2, r4
 8026438:	4629      	mov	r1, r5
 802643a:	4630      	mov	r0, r6
 802643c:	f7ff ffa1 	bl	8026382 <__sfputs_r>
 8026440:	3001      	adds	r0, #1
 8026442:	f000 80a7 	beq.w	8026594 <_vfiprintf_r+0x1ec>
 8026446:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 8026448:	445a      	add	r2, fp
 802644a:	9209      	str	r2, [sp, #36]	@ 0x24
 802644c:	f89a 3000 	ldrb.w	r3, [sl]
 8026450:	2b00      	cmp	r3, #0
 8026452:	f000 809f 	beq.w	8026594 <_vfiprintf_r+0x1ec>
 8026456:	2300      	movs	r3, #0
 8026458:	f04f 32ff 	mov.w	r2, #4294967295
 802645c:	f10a 0a01 	add.w	sl, sl, #1
 8026460:	9304      	str	r3, [sp, #16]
 8026462:	9307      	str	r3, [sp, #28]
 8026464:	f88d 3053 	strb.w	r3, [sp, #83]	@ 0x53
 8026468:	931a      	str	r3, [sp, #104]	@ 0x68
 802646a:	e9cd 2305 	strd	r2, r3, [sp, #20]
 802646e:	4654      	mov	r4, sl
 8026470:	2205      	movs	r2, #5
 8026472:	4854      	ldr	r0, [pc, #336]	@ (80265c4 <_vfiprintf_r+0x21c>)
 8026474:	f814 1b01 	ldrb.w	r1, [r4], #1
 8026478:	f7fd feab 	bl	80241d2 <memchr>
 802647c:	9a04      	ldr	r2, [sp, #16]
 802647e:	b9d8      	cbnz	r0, 80264b8 <_vfiprintf_r+0x110>
 8026480:	06d1      	lsls	r1, r2, #27
 8026482:	bf44      	itt	mi
 8026484:	2320      	movmi	r3, #32
 8026486:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 802648a:	0713      	lsls	r3, r2, #28
 802648c:	bf44      	itt	mi
 802648e:	232b      	movmi	r3, #43	@ 0x2b
 8026490:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 8026494:	f89a 3000 	ldrb.w	r3, [sl]
 8026498:	2b2a      	cmp	r3, #42	@ 0x2a
 802649a:	d015      	beq.n	80264c8 <_vfiprintf_r+0x120>
 802649c:	9a07      	ldr	r2, [sp, #28]
 802649e:	4654      	mov	r4, sl
 80264a0:	2000      	movs	r0, #0
 80264a2:	f04f 0c0a 	mov.w	ip, #10
 80264a6:	4621      	mov	r1, r4
 80264a8:	f811 3b01 	ldrb.w	r3, [r1], #1
 80264ac:	3b30      	subs	r3, #48	@ 0x30
 80264ae:	2b09      	cmp	r3, #9
 80264b0:	d94b      	bls.n	802654a <_vfiprintf_r+0x1a2>
 80264b2:	b1b0      	cbz	r0, 80264e2 <_vfiprintf_r+0x13a>
 80264b4:	9207      	str	r2, [sp, #28]
 80264b6:	e014      	b.n	80264e2 <_vfiprintf_r+0x13a>
 80264b8:	eba0 0308 	sub.w	r3, r0, r8
 80264bc:	46a2      	mov	sl, r4
 80264be:	fa09 f303 	lsl.w	r3, r9, r3
 80264c2:	4313      	orrs	r3, r2
 80264c4:	9304      	str	r3, [sp, #16]
 80264c6:	e7d2      	b.n	802646e <_vfiprintf_r+0xc6>
 80264c8:	9b03      	ldr	r3, [sp, #12]
 80264ca:	1d19      	adds	r1, r3, #4
 80264cc:	681b      	ldr	r3, [r3, #0]
 80264ce:	2b00      	cmp	r3, #0
 80264d0:	9103      	str	r1, [sp, #12]
 80264d2:	bfbb      	ittet	lt
 80264d4:	425b      	neglt	r3, r3
 80264d6:	f042 0202 	orrlt.w	r2, r2, #2
 80264da:	9307      	strge	r3, [sp, #28]
 80264dc:	9307      	strlt	r3, [sp, #28]
 80264de:	bfb8      	it	lt
 80264e0:	9204      	strlt	r2, [sp, #16]
 80264e2:	7823      	ldrb	r3, [r4, #0]
 80264e4:	2b2e      	cmp	r3, #46	@ 0x2e
 80264e6:	d10a      	bne.n	80264fe <_vfiprintf_r+0x156>
 80264e8:	7863      	ldrb	r3, [r4, #1]
 80264ea:	2b2a      	cmp	r3, #42	@ 0x2a
 80264ec:	d132      	bne.n	8026554 <_vfiprintf_r+0x1ac>
 80264ee:	9b03      	ldr	r3, [sp, #12]
 80264f0:	3402      	adds	r4, #2
 80264f2:	1d1a      	adds	r2, r3, #4
 80264f4:	681b      	ldr	r3, [r3, #0]
 80264f6:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
 80264fa:	9203      	str	r2, [sp, #12]
 80264fc:	9305      	str	r3, [sp, #20]
 80264fe:	f8df a0d4 	ldr.w	sl, [pc, #212]	@ 80265d4 <_vfiprintf_r+0x22c>
 8026502:	2203      	movs	r2, #3
 8026504:	7821      	ldrb	r1, [r4, #0]
 8026506:	4650      	mov	r0, sl
 8026508:	f7fd fe63 	bl	80241d2 <memchr>
 802650c:	b138      	cbz	r0, 802651e <_vfiprintf_r+0x176>
 802650e:	eba0 000a 	sub.w	r0, r0, sl
 8026512:	2240      	movs	r2, #64	@ 0x40
 8026514:	9b04      	ldr	r3, [sp, #16]
 8026516:	3401      	adds	r4, #1
 8026518:	4082      	lsls	r2, r0
 802651a:	4313      	orrs	r3, r2
 802651c:	9304      	str	r3, [sp, #16]
 802651e:	f814 1b01 	ldrb.w	r1, [r4], #1
 8026522:	2206      	movs	r2, #6
 8026524:	4828      	ldr	r0, [pc, #160]	@ (80265c8 <_vfiprintf_r+0x220>)
 8026526:	f88d 1028 	strb.w	r1, [sp, #40]	@ 0x28
 802652a:	f7fd fe52 	bl	80241d2 <memchr>
 802652e:	2800      	cmp	r0, #0
 8026530:	d03f      	beq.n	80265b2 <_vfiprintf_r+0x20a>
 8026532:	4b26      	ldr	r3, [pc, #152]	@ (80265cc <_vfiprintf_r+0x224>)
 8026534:	bb1b      	cbnz	r3, 802657e <_vfiprintf_r+0x1d6>
 8026536:	9b03      	ldr	r3, [sp, #12]
 8026538:	3307      	adds	r3, #7
 802653a:	f023 0307 	bic.w	r3, r3, #7
 802653e:	3308      	adds	r3, #8
 8026540:	9303      	str	r3, [sp, #12]
 8026542:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8026544:	443b      	add	r3, r7
 8026546:	9309      	str	r3, [sp, #36]	@ 0x24
 8026548:	e76a      	b.n	8026420 <_vfiprintf_r+0x78>
 802654a:	fb0c 3202 	mla	r2, ip, r2, r3
 802654e:	460c      	mov	r4, r1
 8026550:	2001      	movs	r0, #1
 8026552:	e7a8      	b.n	80264a6 <_vfiprintf_r+0xfe>
 8026554:	2300      	movs	r3, #0
 8026556:	3401      	adds	r4, #1
 8026558:	f04f 0c0a 	mov.w	ip, #10
 802655c:	4619      	mov	r1, r3
 802655e:	9305      	str	r3, [sp, #20]
 8026560:	4620      	mov	r0, r4
 8026562:	f810 2b01 	ldrb.w	r2, [r0], #1
 8026566:	3a30      	subs	r2, #48	@ 0x30
 8026568:	2a09      	cmp	r2, #9
 802656a:	d903      	bls.n	8026574 <_vfiprintf_r+0x1cc>
 802656c:	2b00      	cmp	r3, #0
 802656e:	d0c6      	beq.n	80264fe <_vfiprintf_r+0x156>
 8026570:	9105      	str	r1, [sp, #20]
 8026572:	e7c4      	b.n	80264fe <_vfiprintf_r+0x156>
 8026574:	fb0c 2101 	mla	r1, ip, r1, r2
 8026578:	4604      	mov	r4, r0
 802657a:	2301      	movs	r3, #1
 802657c:	e7f0      	b.n	8026560 <_vfiprintf_r+0x1b8>
 802657e:	ab03      	add	r3, sp, #12
 8026580:	462a      	mov	r2, r5
 8026582:	a904      	add	r1, sp, #16
 8026584:	4630      	mov	r0, r6
 8026586:	9300      	str	r3, [sp, #0]
 8026588:	4b11      	ldr	r3, [pc, #68]	@ (80265d0 <_vfiprintf_r+0x228>)
 802658a:	f7fc fcb5 	bl	8022ef8 <_printf_float>
 802658e:	4607      	mov	r7, r0
 8026590:	1c78      	adds	r0, r7, #1
 8026592:	d1d6      	bne.n	8026542 <_vfiprintf_r+0x19a>
 8026594:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 8026596:	07d9      	lsls	r1, r3, #31
 8026598:	d405      	bmi.n	80265a6 <_vfiprintf_r+0x1fe>
 802659a:	89ab      	ldrh	r3, [r5, #12]
 802659c:	059a      	lsls	r2, r3, #22
 802659e:	d402      	bmi.n	80265a6 <_vfiprintf_r+0x1fe>
 80265a0:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 80265a2:	f7fd fe0d 	bl	80241c0 <__retarget_lock_release_recursive>
 80265a6:	89ab      	ldrh	r3, [r5, #12]
 80265a8:	065b      	lsls	r3, r3, #25
 80265aa:	f53f af1f 	bmi.w	80263ec <_vfiprintf_r+0x44>
 80265ae:	9809      	ldr	r0, [sp, #36]	@ 0x24
 80265b0:	e71e      	b.n	80263f0 <_vfiprintf_r+0x48>
 80265b2:	ab03      	add	r3, sp, #12
 80265b4:	462a      	mov	r2, r5
 80265b6:	a904      	add	r1, sp, #16
 80265b8:	4630      	mov	r0, r6
 80265ba:	9300      	str	r3, [sp, #0]
 80265bc:	4b04      	ldr	r3, [pc, #16]	@ (80265d0 <_vfiprintf_r+0x228>)
 80265be:	f7fc ff39 	bl	8023434 <_printf_i>
 80265c2:	e7e4      	b.n	802658e <_vfiprintf_r+0x1e6>
 80265c4:	0802aa5d 	.word	0x0802aa5d
 80265c8:	0802aa67 	.word	0x0802aa67
 80265cc:	08022ef9 	.word	0x08022ef9
 80265d0:	08026383 	.word	0x08026383
 80265d4:	0802aa63 	.word	0x0802aa63

080265d8 <fiprintf>:
 80265d8:	b40e      	push	{r1, r2, r3}
 80265da:	b503      	push	{r0, r1, lr}
 80265dc:	ab03      	add	r3, sp, #12
 80265de:	4601      	mov	r1, r0
 80265e0:	4805      	ldr	r0, [pc, #20]	@ (80265f8 <fiprintf+0x20>)
 80265e2:	f853 2b04 	ldr.w	r2, [r3], #4
 80265e6:	6800      	ldr	r0, [r0, #0]
 80265e8:	9301      	str	r3, [sp, #4]
 80265ea:	f7ff fedd 	bl	80263a8 <_vfiprintf_r>
 80265ee:	b002      	add	sp, #8
 80265f0:	f85d eb04 	ldr.w	lr, [sp], #4
 80265f4:	b003      	add	sp, #12
 80265f6:	4770      	bx	lr
 80265f8:	20000394 	.word	0x20000394

080265fc <__swhatbuf_r>:
 80265fc:	b570      	push	{r4, r5, r6, lr}
 80265fe:	460c      	mov	r4, r1
 8026600:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8026604:	b096      	sub	sp, #88	@ 0x58
 8026606:	4615      	mov	r5, r2
 8026608:	2900      	cmp	r1, #0
 802660a:	461e      	mov	r6, r3
 802660c:	da0c      	bge.n	8026628 <__swhatbuf_r+0x2c>
 802660e:	89a3      	ldrh	r3, [r4, #12]
 8026610:	2100      	movs	r1, #0
 8026612:	f013 0f80 	tst.w	r3, #128	@ 0x80
 8026616:	bf14      	ite	ne
 8026618:	2340      	movne	r3, #64	@ 0x40
 802661a:	f44f 6380 	moveq.w	r3, #1024	@ 0x400
 802661e:	2000      	movs	r0, #0
 8026620:	6031      	str	r1, [r6, #0]
 8026622:	602b      	str	r3, [r5, #0]
 8026624:	b016      	add	sp, #88	@ 0x58
 8026626:	bd70      	pop	{r4, r5, r6, pc}
 8026628:	466a      	mov	r2, sp
 802662a:	f000 f849 	bl	80266c0 <_fstat_r>
 802662e:	2800      	cmp	r0, #0
 8026630:	dbed      	blt.n	802660e <__swhatbuf_r+0x12>
 8026632:	9901      	ldr	r1, [sp, #4]
 8026634:	f401 4170 	and.w	r1, r1, #61440	@ 0xf000
 8026638:	f5a1 5300 	sub.w	r3, r1, #8192	@ 0x2000
 802663c:	4259      	negs	r1, r3
 802663e:	4159      	adcs	r1, r3
 8026640:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 8026644:	e7eb      	b.n	802661e <__swhatbuf_r+0x22>

08026646 <__smakebuf_r>:
 8026646:	898b      	ldrh	r3, [r1, #12]
 8026648:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 802664a:	079d      	lsls	r5, r3, #30
 802664c:	4606      	mov	r6, r0
 802664e:	460c      	mov	r4, r1
 8026650:	d507      	bpl.n	8026662 <__smakebuf_r+0x1c>
 8026652:	f104 0347 	add.w	r3, r4, #71	@ 0x47
 8026656:	6023      	str	r3, [r4, #0]
 8026658:	6123      	str	r3, [r4, #16]
 802665a:	2301      	movs	r3, #1
 802665c:	6163      	str	r3, [r4, #20]
 802665e:	b003      	add	sp, #12
 8026660:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8026662:	ab01      	add	r3, sp, #4
 8026664:	466a      	mov	r2, sp
 8026666:	f7ff ffc9 	bl	80265fc <__swhatbuf_r>
 802666a:	9f00      	ldr	r7, [sp, #0]
 802666c:	4605      	mov	r5, r0
 802666e:	4630      	mov	r0, r6
 8026670:	4639      	mov	r1, r7
 8026672:	f7fb fcdb 	bl	802202c <_malloc_r>
 8026676:	b948      	cbnz	r0, 802668c <__smakebuf_r+0x46>
 8026678:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 802667c:	059a      	lsls	r2, r3, #22
 802667e:	d4ee      	bmi.n	802665e <__smakebuf_r+0x18>
 8026680:	f023 0303 	bic.w	r3, r3, #3
 8026684:	f043 0302 	orr.w	r3, r3, #2
 8026688:	81a3      	strh	r3, [r4, #12]
 802668a:	e7e2      	b.n	8026652 <__smakebuf_r+0xc>
 802668c:	89a3      	ldrh	r3, [r4, #12]
 802668e:	6020      	str	r0, [r4, #0]
 8026690:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8026694:	81a3      	strh	r3, [r4, #12]
 8026696:	9b01      	ldr	r3, [sp, #4]
 8026698:	e9c4 0704 	strd	r0, r7, [r4, #16]
 802669c:	b15b      	cbz	r3, 80266b6 <__smakebuf_r+0x70>
 802669e:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 80266a2:	4630      	mov	r0, r6
 80266a4:	f000 f81e 	bl	80266e4 <_isatty_r>
 80266a8:	b128      	cbz	r0, 80266b6 <__smakebuf_r+0x70>
 80266aa:	89a3      	ldrh	r3, [r4, #12]
 80266ac:	f023 0303 	bic.w	r3, r3, #3
 80266b0:	f043 0301 	orr.w	r3, r3, #1
 80266b4:	81a3      	strh	r3, [r4, #12]
 80266b6:	89a3      	ldrh	r3, [r4, #12]
 80266b8:	431d      	orrs	r5, r3
 80266ba:	81a5      	strh	r5, [r4, #12]
 80266bc:	e7cf      	b.n	802665e <__smakebuf_r+0x18>
	...

080266c0 <_fstat_r>:
 80266c0:	b538      	push	{r3, r4, r5, lr}
 80266c2:	2300      	movs	r3, #0
 80266c4:	4d06      	ldr	r5, [pc, #24]	@ (80266e0 <_fstat_r+0x20>)
 80266c6:	4604      	mov	r4, r0
 80266c8:	4608      	mov	r0, r1
 80266ca:	4611      	mov	r1, r2
 80266cc:	602b      	str	r3, [r5, #0]
 80266ce:	f7e0 f860 	bl	8006792 <_fstat>
 80266d2:	1c43      	adds	r3, r0, #1
 80266d4:	d102      	bne.n	80266dc <_fstat_r+0x1c>
 80266d6:	682b      	ldr	r3, [r5, #0]
 80266d8:	b103      	cbz	r3, 80266dc <_fstat_r+0x1c>
 80266da:	6023      	str	r3, [r4, #0]
 80266dc:	bd38      	pop	{r3, r4, r5, pc}
 80266de:	bf00      	nop
 80266e0:	20001fe4 	.word	0x20001fe4

080266e4 <_isatty_r>:
 80266e4:	b538      	push	{r3, r4, r5, lr}
 80266e6:	2300      	movs	r3, #0
 80266e8:	4d05      	ldr	r5, [pc, #20]	@ (8026700 <_isatty_r+0x1c>)
 80266ea:	4604      	mov	r4, r0
 80266ec:	4608      	mov	r0, r1
 80266ee:	602b      	str	r3, [r5, #0]
 80266f0:	f7e0 f85f 	bl	80067b2 <_isatty>
 80266f4:	1c43      	adds	r3, r0, #1
 80266f6:	d102      	bne.n	80266fe <_isatty_r+0x1a>
 80266f8:	682b      	ldr	r3, [r5, #0]
 80266fa:	b103      	cbz	r3, 80266fe <_isatty_r+0x1a>
 80266fc:	6023      	str	r3, [r4, #0]
 80266fe:	bd38      	pop	{r3, r4, r5, pc}
 8026700:	20001fe4 	.word	0x20001fe4

08026704 <abort>:
 8026704:	2006      	movs	r0, #6
 8026706:	b508      	push	{r3, lr}
 8026708:	f000 f86e 	bl	80267e8 <raise>
 802670c:	2001      	movs	r0, #1
 802670e:	f7df fff1 	bl	80066f4 <_exit>

08026712 <_calloc_r>:
 8026712:	b570      	push	{r4, r5, r6, lr}
 8026714:	fba1 5402 	umull	r5, r4, r1, r2
 8026718:	b934      	cbnz	r4, 8026728 <_calloc_r+0x16>
 802671a:	4629      	mov	r1, r5
 802671c:	f7fb fc86 	bl	802202c <_malloc_r>
 8026720:	4606      	mov	r6, r0
 8026722:	b928      	cbnz	r0, 8026730 <_calloc_r+0x1e>
 8026724:	4630      	mov	r0, r6
 8026726:	bd70      	pop	{r4, r5, r6, pc}
 8026728:	220c      	movs	r2, #12
 802672a:	2600      	movs	r6, #0
 802672c:	6002      	str	r2, [r0, #0]
 802672e:	e7f9      	b.n	8026724 <_calloc_r+0x12>
 8026730:	462a      	mov	r2, r5
 8026732:	4621      	mov	r1, r4
 8026734:	f7fd fc96 	bl	8024064 <memset>
 8026738:	e7f4      	b.n	8026724 <_calloc_r+0x12>

0802673a <_realloc_r>:
 802673a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802673e:	4607      	mov	r7, r0
 8026740:	4614      	mov	r4, r2
 8026742:	460d      	mov	r5, r1
 8026744:	b921      	cbnz	r1, 8026750 <_realloc_r+0x16>
 8026746:	4611      	mov	r1, r2
 8026748:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 802674c:	f7fb bc6e 	b.w	802202c <_malloc_r>
 8026750:	b92a      	cbnz	r2, 802675e <_realloc_r+0x24>
 8026752:	4625      	mov	r5, r4
 8026754:	f7fe fbe2 	bl	8024f1c <_free_r>
 8026758:	4628      	mov	r0, r5
 802675a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802675e:	f000 f85f 	bl	8026820 <_malloc_usable_size_r>
 8026762:	4284      	cmp	r4, r0
 8026764:	4606      	mov	r6, r0
 8026766:	d802      	bhi.n	802676e <_realloc_r+0x34>
 8026768:	ebb4 0f50 	cmp.w	r4, r0, lsr #1
 802676c:	d8f4      	bhi.n	8026758 <_realloc_r+0x1e>
 802676e:	4621      	mov	r1, r4
 8026770:	4638      	mov	r0, r7
 8026772:	f7fb fc5b 	bl	802202c <_malloc_r>
 8026776:	4680      	mov	r8, r0
 8026778:	b908      	cbnz	r0, 802677e <_realloc_r+0x44>
 802677a:	4645      	mov	r5, r8
 802677c:	e7ec      	b.n	8026758 <_realloc_r+0x1e>
 802677e:	42b4      	cmp	r4, r6
 8026780:	4622      	mov	r2, r4
 8026782:	4629      	mov	r1, r5
 8026784:	bf28      	it	cs
 8026786:	4632      	movcs	r2, r6
 8026788:	f7fd fd31 	bl	80241ee <memcpy>
 802678c:	4629      	mov	r1, r5
 802678e:	4638      	mov	r0, r7
 8026790:	f7fe fbc4 	bl	8024f1c <_free_r>
 8026794:	e7f1      	b.n	802677a <_realloc_r+0x40>

08026796 <_raise_r>:
 8026796:	291f      	cmp	r1, #31
 8026798:	b538      	push	{r3, r4, r5, lr}
 802679a:	4605      	mov	r5, r0
 802679c:	460c      	mov	r4, r1
 802679e:	d904      	bls.n	80267aa <_raise_r+0x14>
 80267a0:	2316      	movs	r3, #22
 80267a2:	6003      	str	r3, [r0, #0]
 80267a4:	f04f 30ff 	mov.w	r0, #4294967295
 80267a8:	bd38      	pop	{r3, r4, r5, pc}
 80267aa:	6bc2      	ldr	r2, [r0, #60]	@ 0x3c
 80267ac:	b112      	cbz	r2, 80267b4 <_raise_r+0x1e>
 80267ae:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
 80267b2:	b94b      	cbnz	r3, 80267c8 <_raise_r+0x32>
 80267b4:	4628      	mov	r0, r5
 80267b6:	f000 f831 	bl	802681c <_getpid_r>
 80267ba:	4622      	mov	r2, r4
 80267bc:	4601      	mov	r1, r0
 80267be:	4628      	mov	r0, r5
 80267c0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 80267c4:	f000 b818 	b.w	80267f8 <_kill_r>
 80267c8:	2b01      	cmp	r3, #1
 80267ca:	d00a      	beq.n	80267e2 <_raise_r+0x4c>
 80267cc:	1c59      	adds	r1, r3, #1
 80267ce:	d103      	bne.n	80267d8 <_raise_r+0x42>
 80267d0:	2316      	movs	r3, #22
 80267d2:	6003      	str	r3, [r0, #0]
 80267d4:	2001      	movs	r0, #1
 80267d6:	e7e7      	b.n	80267a8 <_raise_r+0x12>
 80267d8:	2100      	movs	r1, #0
 80267da:	4620      	mov	r0, r4
 80267dc:	f842 1024 	str.w	r1, [r2, r4, lsl #2]
 80267e0:	4798      	blx	r3
 80267e2:	2000      	movs	r0, #0
 80267e4:	e7e0      	b.n	80267a8 <_raise_r+0x12>
	...

080267e8 <raise>:
 80267e8:	4b02      	ldr	r3, [pc, #8]	@ (80267f4 <raise+0xc>)
 80267ea:	4601      	mov	r1, r0
 80267ec:	6818      	ldr	r0, [r3, #0]
 80267ee:	f7ff bfd2 	b.w	8026796 <_raise_r>
 80267f2:	bf00      	nop
 80267f4:	20000394 	.word	0x20000394

080267f8 <_kill_r>:
 80267f8:	b538      	push	{r3, r4, r5, lr}
 80267fa:	2300      	movs	r3, #0
 80267fc:	4d06      	ldr	r5, [pc, #24]	@ (8026818 <_kill_r+0x20>)
 80267fe:	4604      	mov	r4, r0
 8026800:	4608      	mov	r0, r1
 8026802:	4611      	mov	r1, r2
 8026804:	602b      	str	r3, [r5, #0]
 8026806:	f7df ff65 	bl	80066d4 <_kill>
 802680a:	1c43      	adds	r3, r0, #1
 802680c:	d102      	bne.n	8026814 <_kill_r+0x1c>
 802680e:	682b      	ldr	r3, [r5, #0]
 8026810:	b103      	cbz	r3, 8026814 <_kill_r+0x1c>
 8026812:	6023      	str	r3, [r4, #0]
 8026814:	bd38      	pop	{r3, r4, r5, pc}
 8026816:	bf00      	nop
 8026818:	20001fe4 	.word	0x20001fe4

0802681c <_getpid_r>:
 802681c:	f7df bf52 	b.w	80066c4 <_getpid>

08026820 <_malloc_usable_size_r>:
 8026820:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8026824:	1f18      	subs	r0, r3, #4
 8026826:	2b00      	cmp	r3, #0
 8026828:	bfbc      	itt	lt
 802682a:	580b      	ldrlt	r3, [r1, r0]
 802682c:	18c0      	addlt	r0, r0, r3
 802682e:	4770      	bx	lr

08026830 <_init>:
 8026830:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8026832:	bf00      	nop
 8026834:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8026836:	bc08      	pop	{r3}
 8026838:	469e      	mov	lr, r3
 802683a:	4770      	bx	lr

0802683c <_fini>:
 802683c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802683e:	bf00      	nop
 8026840:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8026842:	bc08      	pop	{r3}
 8026844:	469e      	mov	lr, r3
 8026846:	4770      	bx	lr
